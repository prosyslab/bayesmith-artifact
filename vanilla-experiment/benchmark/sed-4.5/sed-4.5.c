/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 58 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 256 "/home/khheo/project/benchmark/sed-4.5/lib/acl-internal.h"
struct permission_context {
   mode_t mode ;
};
#line 82 "./lib/selinux/selinux.h"
typedef unsigned short security_class_t;
#line 83 "./lib/selinux/selinux.h"
typedef char *security_context_t;
#line 53 "./lib/selinux/context.h"
typedef int context_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 32 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    shell_escape_quoting_style = 3,
    shell_escape_always_quoting_style = 4,
    c_quoting_style = 5,
    c_maybe_quoting_style = 6,
    escape_quoting_style = 7,
    locale_quoting_style = 8,
    clocale_quoting_style = 9,
    custom_quoting_style = 10
} ;
#line 270
struct quoting_options ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_250081222 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_250081222 __mbstate_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 65 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 834 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef long ptrdiff_t;
#line 167 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[] ;
};
#line 174 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.h"
union __anonunion_temp_355861816 {
   size_t i ;
   void *p ;
};
#line 174 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.h"
union __anonunion_chunkfun_5259977 {
   void *(*plain)(size_t  ) ;
   void *(*extra)(void * , size_t  ) ;
};
#line 174 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.h"
union __anonunion_freefun_5259978 {
   void (*plain)(void * ) ;
   void (*extra)(void * , void * ) ;
};
#line 174 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.h"
struct obstack {
   size_t chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_355861816 temp ;
   size_t alignment_mask ;
   union __anonunion_chunkfun_5259977 chunkfun ;
   union __anonunion_freefun_5259978 freefun ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 112 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 38 "/home/khheo/project/benchmark/sed-4.5/lib/malloca.c"
typedef unsigned char small_t;
#line 26 "./lib/localeinfo.h"
struct localeinfo {
   _Bool multibyte ;
   _Bool using_utf8 ;
   signed char sbclen[256] ;
   wint_t sbctowc[256] ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 73 "./lib/regex.h"
typedef unsigned long reg_syntax_t;
#line 35 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.h"
struct dfamust {
   _Bool exact ;
   _Bool begline ;
   _Bool endline ;
   char *must ;
};
#line 44
struct dfa ;
#line 82 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
typedef unsigned long charclass_word;
#line 114 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct __anonstruct_charclass_425059741 {
   charclass_word w[4] ;
};
#line 114 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
typedef struct __anonstruct_charclass_425059741 charclass;
#line 216 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
typedef ptrdiff_t token;
#line 221 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
typedef ptrdiff_t state_num;
#line 316 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct __anonstruct_position_1023785459 {
   size_t index ;
   unsigned int constraint ;
};
#line 316 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
typedef struct __anonstruct_position_1023785459 position;
#line 323 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct __anonstruct_position_set_349475030 {
   position *elems ;
   ptrdiff_t nelem ;
   ptrdiff_t alloc ;
};
#line 323 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
typedef struct __anonstruct_position_set_349475030 position_set;
#line 331 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct __anonstruct_leaf_set_73278319 {
   size_t *elems ;
   size_t nelem ;
};
#line 331 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
typedef struct __anonstruct_leaf_set_73278319 leaf_set;
#line 340 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct __anonstruct_dfa_state_810101419 {
   size_t hash ;
   position_set elems ;
   unsigned char context ;
   unsigned short constraint ;
   token first_end ;
   position_set mbps ;
   state_num mb_trindex ;
};
#line 340 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
typedef struct __anonstruct_dfa_state_810101419 dfa_state;
#line 361 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct mb_char_classes {
   ptrdiff_t cset ;
   _Bool invert ;
   wchar_t *chars ;
   ptrdiff_t nchars ;
   ptrdiff_t nchars_alloc ;
};
#line 370 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct regex_syntax {
   reg_syntax_t syntax_bits ;
   _Bool syntax_bits_set ;
   _Bool case_fold ;
   _Bool anchor ;
   unsigned char eolbyte ;
   char sbit[256] ;
   _Bool never_trail[256] ;
   charclass letters ;
   charclass newline ;
};
#line 404 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct lexer_state {
   char const   *ptr ;
   size_t left ;
   token lasttok ;
   size_t parens ;
   int minrep ;
   int maxrep ;
   wint_t wctok ;
   int cur_mb_len ;
   struct mb_char_classes brack ;
   _Bool laststart ;
};
#line 429 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct parser_state {
   token tok ;
   size_t depth ;
};
#line 440 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct dfa {
   struct regex_syntax syntax ;
   charclass *charclasses ;
   ptrdiff_t cindex ;
   ptrdiff_t calloc ;
   size_t canychar ;
   struct lexer_state lex ;
   struct parser_state parse ;
   token *tokens ;
   size_t tindex ;
   size_t talloc ;
   size_t depth ;
   size_t nleaves ;
   size_t nregexps ;
   _Bool fast ;
   token utf8_anychar_classes[5] ;
   mbstate_t mbs ;
   char *multibyte_prop ;
   struct dfa *superset ;
   dfa_state *states ;
   state_num sindex ;
   ptrdiff_t salloc ;
   position_set *follows ;
   _Bool searchflag ;
   state_num tralloc ;
   int trcount ;
   int min_trcount ;
   state_num **trans ;
   state_num **fails ;
   char *success ;
   state_num *newlines ;
   state_num initstate_notbol ;
   position_set mb_follows ;
   state_num **mb_trans ;
   state_num mb_trcount ;
   char *(*dfaexec)(struct dfa * , char const   * , char * , _Bool  , size_t * , _Bool * ) ;
   _Bool simple_locale ;
   struct localeinfo localeinfo ;
};
#line 962 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
typedef int predicate(int  );
#line 968 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct dfa_ctype {
   char const   *name ;
   predicate *func ;
   _Bool single_byte_only ;
};
#line 1227 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct lexptr {
   char const   *ptr ;
   size_t left ;
};
#line 2371 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct __anonstruct_stkalloc_360611398 {
   _Bool nullable ;
   size_t nfirstpos ;
   size_t nlastpos ;
};
#line 3723
struct must ;
#line 3723 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
typedef struct must must;
#line 3725 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct must {
   char **in ;
   char *left ;
   char *right ;
   char *is ;
   _Bool begline ;
   _Bool endline ;
   must *prev ;
};
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 71 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 51 "/home/khheo/project/benchmark/sed-4.5/sed/utils.h"
struct buffer ;
#line 40 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
struct open_file {
   FILE *fp ;
   char *name ;
   struct open_file *link ;
   unsigned int temp : 1 ;
};
#line 444 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
struct buffer {
   size_t allocated ;
   size_t length ;
   char *b ;
};
#line 32 "./basicdefs.h"
typedef unsigned long countT;
#line 57 "./lib/regex.h"
typedef unsigned long __re_long_size_t;
#line 414
struct re_dfa_t ;
#line 414 "./lib/regex.h"
struct re_pattern_buffer {
   struct re_dfa_t *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 479 "./lib/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 29 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
struct sed_cmd ;
#line 29 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
struct vector {
   struct sed_cmd *v ;
   size_t v_allocated ;
   size_t v_length ;
};
#line 39 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
struct output {
   char *name ;
   _Bool missing_newline ;
   FILE *fp ;
   struct output *link ;
};
#line 46 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
struct text_buf {
   char *text ;
   size_t text_length ;
};
#line 51 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
struct regex {
   regex_t pattern ;
   int flags ;
   size_t sz ;
   struct dfa *dfa ;
   _Bool begline ;
   _Bool endline ;
   char re[1] ;
};
#line 61
enum replacement_types {
    REPL_ASIS = 0,
    REPL_UPPERCASE = 1,
    REPL_LOWERCASE = 2,
    REPL_UPPERCASE_FIRST = 4,
    REPL_LOWERCASE_FIRST = 8,
    REPL_MODIFIERS = 12,
    REPL_UPPERCASE_UPPERCASE = 5,
    REPL_UPPERCASE_LOWERCASE = 6,
    REPL_LOWERCASE_UPPERCASE = 9,
    REPL_LOWERCASE_LOWERCASE = 10
} ;
#line 82
enum posixicity_types {
    POSIXLY_EXTENDED = 0,
    POSIXLY_CORRECT = 1,
    POSIXLY_BASIC = 2
} ;
#line 88
enum addr_state {
    RANGE_INACTIVE = 0,
    RANGE_ACTIVE = 1,
    RANGE_CLOSED = 2
} ;
#line 94
enum addr_types {
    ADDR_IS_NULL = 0,
    ADDR_IS_REGEX = 1,
    ADDR_IS_NUM = 2,
    ADDR_IS_NUM_MOD = 3,
    ADDR_IS_STEP = 4,
    ADDR_IS_STEP_MOD = 5,
    ADDR_IS_LAST = 6
} ;
#line 104 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
struct addr {
   enum addr_types addr_type ;
   countT addr_number ;
   countT addr_step ;
   struct regex *addr_regex ;
};
#line 112 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
struct replacement {
   char *prefix ;
   size_t prefix_length ;
   int subst_id ;
   enum replacement_types repl_type ;
   struct replacement *next ;
};
#line 120 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
struct subst {
   struct regex *regx ;
   struct replacement *replacement ;
   countT numb ;
   struct output *outf ;
   unsigned int global : 1 ;
   unsigned int print : 2 ;
   unsigned int eval : 1 ;
   unsigned int max_id : 4 ;
};
#line 144 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
union __anonunion_x_936425645 {
   struct text_buf cmd_txt ;
   int int_arg ;
   countT jump_index ;
   char *fname ;
   struct subst *cmd_subst ;
   struct output *outf ;
   FILE *fp ;
   unsigned char *translate ;
   char **translatemb ;
};
#line 144 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
struct sed_cmd {
   struct addr *a1 ;
   struct addr *a2 ;
   enum addr_state range_state ;
   char addr_bang ;
   char cmd ;
   union __anonunion_x_936425645 x ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 56 "./lib/regex.h"
typedef unsigned int __re_size_t;
#line 491 "./lib/regex.h"
typedef int regoff_t;
#line 498 "./lib/regex.h"
struct re_registers {
   __re_size_t num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 76 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
enum text_types {
    TEXT_BUFFER = 0,
    TEXT_REPLACEMENT = 1,
    TEXT_REGEX = 2
} ;
#line 46 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
struct line {
   char *text ;
   char *active ;
   size_t length ;
   size_t alloc ;
   _Bool chomped ;
   mbstate_t mbstate ;
};
#line 59 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
struct append_queue {
   char const   *fname ;
   char *text ;
   size_t textlen ;
   struct append_queue *next ;
   _Bool free ;
};
#line 68 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
struct input {
   char **file_list ;
   countT bad_count ;
   countT line_number ;
   _Bool reset_at_next_file ;
   _Bool (*read_fn)(struct input * ) ;
   char *out_file_name ;
   char const   *in_file_name ;
   struct stat st ;
   FILE *fp ;
   _Bool no_buffering ;
};
#line 38 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
struct prog_info {
   unsigned char const   *base ;
   unsigned char const   *cur ;
   unsigned char const   *end ;
   FILE *file ;
};
#line 55 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
struct error_info {
   char const   *name ;
   countT line ;
   countT string_expr_count ;
};
#line 68 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
struct sed_label {
   countT v_index ;
   char *name ;
   struct error_info err_info ;
   struct sed_label *next ;
};
#line 75 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
struct special_files {
   struct output outf ;
   FILE **pfp ;
};
#line 29 "/home/khheo/project/benchmark/sed-4.5/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 57
void xalloc_die(void) ;
#line 59
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 61
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 63
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 65
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 67
void *x2realloc(void *p , size_t *pn ) ;
#line 68
void *xmemdup(void const   *p , size_t s )  __attribute__((__alloc_size__(2))) ;
#line 70
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 102
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 104
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 104 "/home/khheo/project/benchmark/sed-4.5/lib/xalloc.h"
__inline void *xnmalloc(size_t n , size_t s ) 
{ 
  void *tmp ;

  {
#line 107
  if (9223372036854775807UL / s < n) {
    {
#line 108
    xalloc_die();
    }
  }
  {
#line 109
  tmp = xmalloc(n * s);
  }
#line 109
  return (tmp);
}
}
#line 115
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 117
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 117 "/home/khheo/project/benchmark/sed-4.5/lib/xalloc.h"
__inline void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  void *tmp ;

  {
#line 120
  if (9223372036854775807UL / s < n) {
    {
#line 121
    xalloc_die();
    }
  }
  {
#line 122
  tmp = xrealloc(p, n * s);
  }
#line 122
  return (tmp);
}
}
#line 179 "/home/khheo/project/benchmark/sed-4.5/lib/xalloc.h"
__inline void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 182
  n = *pn;
#line 184
  if (! p) {
#line 186
    if (! n) {
#line 194
      n = 128UL / s;
#line 195
      n += (size_t )(! n);
    }
#line 197
    if (9223372036854775807UL / s < n) {
      {
#line 198
      xalloc_die();
      }
    }
  } else {
#line 206
    if (6148914691236517204UL / s <= n) {
      {
#line 208
      xalloc_die();
      }
    }
#line 209
    n += n / 2UL + 1UL;
  }
  {
#line 212
  *pn = n;
#line 213
  tmp = xrealloc(p, n * s);
  }
#line 213
  return (tmp);
}
}
#line 219
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 221
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 221 "/home/khheo/project/benchmark/sed-4.5/lib/xalloc.h"
__inline char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 224
  if (sizeof(char ) == 1UL) {
    {
#line 224
    tmp = xmalloc(n);
#line 224
    tmp___1 = tmp;
    }
  } else {
    {
#line 224
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 224
    tmp___1 = tmp___0;
    }
  }
#line 224
  return ((char *)tmp___1);
}
}
#line 266
#pragma GCC diagnostic pop
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 38 "/home/khheo/project/benchmark/sed-4.5/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 38 "/home/khheo/project/benchmark/sed-4.5/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc(n);
#line 41
  p = tmp;
  }
#line 42
  if (! p) {
#line 42
    if (n != 0UL) {
      {
#line 43
      xalloc_die();
      }
    }
  }
#line 44
  return (p);
}
}
#line 50
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 50 "/home/khheo/project/benchmark/sed-4.5/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 53
  if (! n) {
#line 53
    if (p) {
      {
#line 57
      free(p);
      }
#line 58
      return ((void *)0);
    }
  }
  {
#line 61
  p = realloc(p, n);
  }
#line 62
  if (! p) {
#line 62
    if (n) {
      {
#line 63
      xalloc_die();
      }
    }
  }
#line 64
  return (p);
}
}
#line 73 "/home/khheo/project/benchmark/sed-4.5/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 76
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 76
  return (tmp);
}
}
#line 83
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 83 "/home/khheo/project/benchmark/sed-4.5/lib/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 86
  tmp = xmalloc(s);
#line 86
  tmp___0 = memset(tmp, 0, s);
  }
#line 86
  return (tmp___0);
}
}
#line 92
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 92 "/home/khheo/project/benchmark/sed-4.5/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
#line 100
  if (9223372036854775807UL / s < n) {
    {
#line 102
    xalloc_die();
    }
  } else {
    {
#line 100
    p = calloc(n, s);
    }
#line 100
    if (! p) {
      {
#line 102
      xalloc_die();
      }
    }
  }
#line 103
  return (p);
}
}
#line 110
void *xmemdup(void const   *p , size_t s )  __attribute__((__alloc_size__(2))) ;
#line 110 "/home/khheo/project/benchmark/sed-4.5/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 113
  tmp = xmalloc(s);
#line 113
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 113
  return (tmp___0);
}
}
#line 118
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 118 "/home/khheo/project/benchmark/sed-4.5/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 121
  tmp = strlen(string);
#line 121
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  }
#line 121
  return ((char *)tmp___0);
}
}
#line 29 "/home/khheo/project/benchmark/sed-4.5/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 52 "/home/khheo/project/benchmark/sed-4.5/lib/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 18 "/home/khheo/project/benchmark/sed-4.5/lib/exitfail.h"
int volatile   exit_failure ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 31 "/home/khheo/project/benchmark/sed-4.5/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;

  {
  {
#line 34
  tmp = gettext("memory exhausted");
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
  }
}
}
#line 82 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 662
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 34 "/home/khheo/project/benchmark/sed-4.5/lib/version-etc.h"
char const   version_etc_copyright[47] ;
#line 52
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 58
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 63
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 69
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 76
void emit_bug_reporting_address(void) ;
#line 61 "/home/khheo/project/benchmark/sed-4.5/lib/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 67
  if (command_name) {
    {
#line 68
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 70
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 84
  tmp = gettext("(C)");
#line 84
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp, 2018);
#line 86
  tmp___0 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 86
  fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
  }
  {
#line 97
  if (n_authors == 0UL) {
#line 97
    goto case_0;
  }
#line 100
  if (n_authors == 1UL) {
#line 100
    goto case_1;
  }
#line 104
  if (n_authors == 2UL) {
#line 104
    goto case_2;
  }
#line 108
  if (n_authors == 3UL) {
#line 108
    goto case_3;
  }
#line 113
  if (n_authors == 4UL) {
#line 113
    goto case_4;
  }
#line 120
  if (n_authors == 5UL) {
#line 120
    goto case_5;
  }
#line 127
  if (n_authors == 6UL) {
#line 127
    goto case_6;
  }
#line 135
  if (n_authors == 7UL) {
#line 135
    goto case_7;
  }
#line 143
  if (n_authors == 8UL) {
#line 143
    goto case_8;
  }
#line 152
  if (n_authors == 9UL) {
#line 152
    goto case_9;
  }
#line 161
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 99
  abort();
  }
  case_1: /* CIL Label */ 
  {
#line 102
  tmp___1 = gettext("Written by %s.\n");
#line 102
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          *(authors + 0));
  }
#line 103
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 106
  tmp___2 = gettext("Written by %s and %s.\n");
#line 106
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
          *(authors + 0), *(authors + 1));
  }
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 110
  tmp___3 = gettext("Written by %s, %s, and %s.\n");
#line 110
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3,
          *(authors + 0), *(authors + 1), *(authors + 2));
  }
#line 112
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 117
  tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
#line 117
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3));
  }
#line 119
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 124
  tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
#line 124
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___5,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  }
#line 126
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 131
  tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
#line 131
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___6,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5));
  }
#line 134
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 139
  tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
#line 139
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___7,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6));
  }
#line 142
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 147
  tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
#line 147
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___8,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7));
  }
#line 151
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 156
  tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
#line 156
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___9,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 160
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 167
  tmp___10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
#line 167
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___10,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 171
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 179 "/home/khheo/project/benchmark/sed-4.5/lib/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ 
  size_t n_authors ;

  {
#line 186
  n_authors = (size_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! *(authors + n_authors)) {
#line 186
      goto while_break;
    }
#line 186
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
#line 189
  return;
}
}
#line 195 "/home/khheo/project/benchmark/sed-4.5/lib/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ 
  size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 203
  n_authors = (size_t )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (n_authors < 10UL) {
      {
#line 203
      tmp___0 = __builtin_va_arg(authors, char const   *);
#line 203
      tmp = tmp___0;
#line 203
      authtab[n_authors] = tmp;
      }
#line 203
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 203
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
  }
#line 210
  return;
}
}
#line 226
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 226 "/home/khheo/project/benchmark/sed-4.5/lib/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list authors ;

  {
  {
#line 233
  __builtin_va_start(authors, version);
#line 234
  version_etc_va(stream, command_name, package, version, authors);
#line 235
  __builtin_va_end(authors);
  }
#line 236
  return;
}
}
#line 238 "/home/khheo/project/benchmark/sed-4.5/lib/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 245
  tmp = gettext("\nReport bugs to: %s\n");
#line 245
  printf((char const   */* __restrict  */)tmp, "bug-sed@gnu.org");
#line 251
  tmp___0 = gettext("%s home page: <%s>\n");
#line 251
  printf((char const   */* __restrict  */)tmp___0, "GNU sed", "https://www.gnu.org/software/sed/");
#line 256
  tmp___1 = gettext("General help using GNU software: <https://www.gnu.org/gethelp/>\n");
#line 256
  fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
  }
#line 258
  return;
}
}
#line 26 "/home/khheo/project/benchmark/sed-4.5/lib/version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 26 "/home/khheo/project/benchmark/sed-4.5/lib/version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
#line 598 "/home/khheo/project/benchmark/sed-4.5/lib/unistd.h"
#pragma GCC diagnostic push
#line 598
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 598
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2086
#pragma GCC diagnostic pop
#line 52 "/home/khheo/project/benchmark/sed-4.5/lib/tempname.h"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) ;
#line 58
int try_tempname(char *tmpl , int suffixlen , void *args , int (*tryfunc)(char * ,
                                                                          void * ) ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 68 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 631 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 598 "./lib/unistd.h"
#pragma GCC diagnostic push
#line 598
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 598
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2086
#pragma GCC diagnostic pop
#line 259 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 317
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 176 "/home/khheo/project/benchmark/sed-4.5/lib/tempname.c"
static char const   letters[63]  = 
#line 176 "/home/khheo/project/benchmark/sed-4.5/lib/tempname.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 185 "/home/khheo/project/benchmark/sed-4.5/lib/tempname.c"
static uint64_t value  ;
#line 179 "/home/khheo/project/benchmark/sed-4.5/lib/tempname.c"
int try_tempname(char *tmpl , int suffixlen , void *args , int (*tryfunc)(char * ,
                                                                          void * ) ) 
{ 
  int len ;
  char *XXXXXX ;
  uint64_t random_time_bits ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *tmp ;
  unsigned int attempts ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  struct timeval tv ;
  __pid_t tmp___3 ;
  uint64_t v ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 188
  fd = -1;
#line 189
  tmp = __errno_location();
#line 189
  save_errno = *tmp;
#line 204
  attempts = 238328U;
#line 207
  tmp___0 = strlen((char const   *)tmpl);
#line 207
  len = (int )tmp___0;
  }
#line 208
  if (len < 6 + suffixlen) {
    {
#line 210
    tmp___1 = __errno_location();
#line 210
    *tmp___1 = 22;
    }
#line 211
    return (-1);
  } else {
    {
#line 208
    tmp___2 = memcmp((void const   *)(tmpl + ((len - 6) - suffixlen)), (void const   *)"XXXXXX",
                     (size_t )6);
    }
#line 208
    if (tmp___2) {
      {
#line 210
      tmp___1 = __errno_location();
#line 210
      *tmp___1 = 22;
      }
#line 211
      return (-1);
    }
  }
  {
#line 215
  XXXXXX = tmpl + ((len - 6) - suffixlen);
#line 223
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 224
  random_time_bits = ((uint64_t )tv.tv_usec << 16) ^ (unsigned long )tv.tv_sec;
#line 227
  tmp___3 = getpid();
#line 227
  value += random_time_bits ^ (unsigned long )tmp___3;
#line 229
  count = 0U;
  }
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (count < attempts)) {
#line 229
      goto while_break;
    }
    {
#line 231
    v = value;
#line 234
    *(XXXXXX + 0) = (char )letters[v % 62UL];
#line 235
    v /= 62UL;
#line 236
    *(XXXXXX + 1) = (char )letters[v % 62UL];
#line 237
    v /= 62UL;
#line 238
    *(XXXXXX + 2) = (char )letters[v % 62UL];
#line 239
    v /= 62UL;
#line 240
    *(XXXXXX + 3) = (char )letters[v % 62UL];
#line 241
    v /= 62UL;
#line 242
    *(XXXXXX + 4) = (char )letters[v % 62UL];
#line 243
    v /= 62UL;
#line 244
    *(XXXXXX + 5) = (char )letters[v % 62UL];
#line 246
    fd = (*tryfunc)(tmpl, args);
    }
#line 247
    if (fd >= 0) {
      {
#line 249
      tmp___4 = __errno_location();
#line 249
      *tmp___4 = save_errno;
      }
#line 250
      return (fd);
    } else {
      {
#line 252
      tmp___5 = __errno_location();
      }
#line 252
      if (*tmp___5 != 17) {
#line 253
        return (-1);
      }
    }
#line 229
    value += 7777UL;
#line 229
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  tmp___6 = __errno_location();
#line 257
  *tmp___6 = 17;
  }
#line 258
  return (-1);
}
}
#line 261 "/home/khheo/project/benchmark/sed-4.5/lib/tempname.c"
static int try_file(char *tmpl , void *flags ) 
{ 
  int *openflags ;
  int tmp ;

  {
  {
#line 264
  openflags = (int *)flags;
#line 265
  tmp = open((char const   *)tmpl, (((*openflags & -4) | 2) | 64) | 128, 384);
  }
#line 265
  return (tmp);
}
}
#line 270 "/home/khheo/project/benchmark/sed-4.5/lib/tempname.c"
static int try_dir(char *tmpl , void *flags  __attribute__((__unused__)) ) 
{ 
  int tmp ;

  {
  {
#line 273
  tmp = mkdir((char const   *)tmpl, (__mode_t )448);
  }
#line 273
  return (tmp);
}
}
#line 276 "/home/khheo/project/benchmark/sed-4.5/lib/tempname.c"
static int try_nocreate(char *tmpl , void *flags  __attribute__((__unused__)) ) 
{ 
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 281
  tmp___0 = lstat((char const   */* __restrict  */)tmpl, (struct stat */* __restrict  */)(& st));
  }
#line 281
  if (tmp___0 == 0) {
    {
#line 282
    tmp = __errno_location();
#line 282
    *tmp = 17;
    }
  } else {
    {
#line 281
    tmp___1 = __errno_location();
    }
#line 281
    if (*tmp___1 == 75) {
      {
#line 282
      tmp = __errno_location();
#line 282
      *tmp = 17;
      }
    }
  }
  {
#line 283
  tmp___4 = __errno_location();
  }
#line 283
  if (*tmp___4 == 2) {
#line 283
    tmp___3 = 0;
  } else {
#line 283
    tmp___3 = -1;
  }
#line 283
  return (tmp___3);
}
}
#line 299 "/home/khheo/project/benchmark/sed-4.5/lib/tempname.c"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) 
{ 
  int (*tryfunc)(char * , void * ) ;
  int tmp ;

  {
  {
#line 306
  if (kind == 0) {
#line 306
    goto case_0;
  }
#line 310
  if (kind == 1) {
#line 310
    goto case_1;
  }
#line 314
  if (kind == 2) {
#line 314
    goto case_2;
  }
#line 318
  goto switch_default;
  case_0: /* CIL Label */ 
#line 307
  tryfunc = & try_file;
#line 308
  goto switch_break;
  case_1: /* CIL Label */ 
#line 311
  tryfunc = & try_dir;
#line 312
  goto switch_break;
  case_2: /* CIL Label */ 
#line 315
  tryfunc = & try_nocreate;
#line 316
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 319
  __assert_fail("! \"invalid KIND in __gen_tempname\"", "/home/khheo/project/benchmark/sed-4.5/lib/tempname.c",
                319U, "gen_tempname");
#line 320
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 322
  tmp = try_tempname(tmpl, suffixlen, (void *)(& flags), tryfunc);
  }
#line 322
  return (tmp);
}
}
#line 44 "/home/khheo/project/benchmark/sed-4.5/lib/dirname.h"
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 46
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 48
_Bool strip_trailing_slashes(char *file ) ;
#line 30 "/home/khheo/project/benchmark/sed-4.5/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 33
  tmp = last_component((char const   *)file);
#line 33
  base = tmp;
  }
#line 39
  if (! *base) {
#line 40
    base = file;
  }
  {
#line 41
  tmp___0 = base_len((char const   *)base);
#line 41
  base_lim = base + tmp___0;
#line 42
  had_slash = (_Bool )((int )*base_lim != 0);
#line 43
  *base_lim = (char )'\000';
  }
#line 44
  return (had_slash);
}
}
#line 33 "/home/khheo/project/benchmark/sed-4.5/lib/stat-time.h"
#pragma GCC diagnostic push
#line 33
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 33
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 65 "/home/khheo/project/benchmark/sed-4.5/lib/stat-time.h"
__inline extern long __attribute__((__pure__))  get_stat_atime_ns(struct stat  const  *st ) 
{ 


  {
#line 69
  return ((long __attribute__((__pure__))  )st->st_atim.tv_nsec);
}
}
#line 78 "/home/khheo/project/benchmark/sed-4.5/lib/stat-time.h"
__inline extern long __attribute__((__pure__))  get_stat_ctime_ns(struct stat  const  *st ) 
{ 


  {
#line 82
  return ((long __attribute__((__pure__))  )st->st_ctim.tv_nsec);
}
}
#line 91 "/home/khheo/project/benchmark/sed-4.5/lib/stat-time.h"
__inline extern long __attribute__((__pure__))  get_stat_mtime_ns(struct stat  const  *st ) 
{ 


  {
#line 95
  return ((long __attribute__((__pure__))  )st->st_mtim.tv_nsec);
}
}
#line 104 "/home/khheo/project/benchmark/sed-4.5/lib/stat-time.h"
__inline extern long __attribute__((__pure__))  get_stat_birthtime_ns(struct stat  const  *st  __attribute__((__unused__)) ) 
{ 


  {
#line 112
  return ((long __attribute__((__pure__))  )0);
}
}
#line 117 "/home/khheo/project/benchmark/sed-4.5/lib/stat-time.h"
__inline extern struct timespec  __attribute__((__pure__)) get_stat_atime(struct stat  const  *st ) 
{ 


  {
#line 121
  return ((struct timespec  __attribute__((__pure__)) )st->st_atim);
}
}
#line 131 "/home/khheo/project/benchmark/sed-4.5/lib/stat-time.h"
__inline extern struct timespec  __attribute__((__pure__)) get_stat_ctime(struct stat  const  *st ) 
{ 


  {
#line 135
  return ((struct timespec  __attribute__((__pure__)) )st->st_ctim);
}
}
#line 145 "/home/khheo/project/benchmark/sed-4.5/lib/stat-time.h"
__inline extern struct timespec  __attribute__((__pure__)) get_stat_mtime(struct stat  const  *st ) 
{ 


  {
#line 149
  return ((struct timespec  __attribute__((__pure__)) )st->st_mtim);
}
}
#line 160 "/home/khheo/project/benchmark/sed-4.5/lib/stat-time.h"
__inline extern struct timespec  __attribute__((__pure__)) get_stat_birthtime(struct stat  const  *st  __attribute__((__unused__)) ) 
{ 
  struct timespec t ;

  {
#line 183
  t.tv_sec = (__time_t )-1;
#line 184
  t.tv_nsec = (__syscall_slong_t )-1;
#line 202
  return ((struct timespec  __attribute__((__pure__)) )t);
}
}
#line 210 "/home/khheo/project/benchmark/sed-4.5/lib/stat-time.h"
__inline extern int stat_time_normalize(int result , struct stat *st  __attribute__((__unused__)) ) 
{ 


  {
#line 243
  return (result);
}
}
#line 250
#pragma GCC diagnostic pop
#line 280 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 293
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 33 "/home/khheo/project/benchmark/sed-4.5/lib/acl.h"
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) ;
#line 66 "/home/khheo/project/benchmark/sed-4.5/lib/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 295
int set_permissions(struct permission_context *ctx , char const   *name , int desc ) ;
#line 302
#pragma GCC diagnostic pop
#line 759 "/home/khheo/project/benchmark/sed-4.5/lib/set-permissions.c"
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 762
  if (desc != -1) {
    {
#line 763
    tmp = fchmod(desc, mode);
    }
#line 763
    return (tmp);
  } else {
    {
#line 765
    tmp___0 = chmod(name, mode);
    }
#line 765
    return (tmp___0);
  }
}
}
#line 775 "/home/khheo/project/benchmark/sed-4.5/lib/set-permissions.c"
int set_permissions(struct permission_context *ctx , char const   *name , int desc ) 
{ 
  _Bool acls_set  __attribute__((__unused__)) ;
  _Bool early_chmod ;
  _Bool must_chmod ;
  int ret ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 778
  acls_set = (_Bool)0;
#line 780
  must_chmod = (_Bool)0;
#line 781
  ret = 0;
#line 801
  early_chmod = (_Bool)1;
#line 804
  if (early_chmod) {
    {
#line 806
    ret = chmod_or_fchmod(name, desc, ctx->mode);
    }
#line 807
    if (ret != 0) {
#line 808
      return (-1);
    }
  }
#line 833
  if (must_chmod) {
#line 833
    if (! early_chmod) {
#line 835
      if (ret) {
        {
#line 835
        tmp = __errno_location();
#line 835
        tmp___0 = *tmp;
        }
      } else {
#line 835
        tmp___0 = 0;
      }
      {
#line 835
      saved_errno = tmp___0;
#line 837
      ret = chmod_or_fchmod(name, desc, ctx->mode);
      }
#line 839
      if (saved_errno) {
        {
#line 841
        tmp___1 = __errno_location();
#line 841
        *tmp___1 = saved_errno;
#line 842
        ret = -1;
        }
      }
    }
  }
#line 846
  return (ret);
}
}
#line 29 "/home/khheo/project/benchmark/sed-4.5/lib/acl.h"
int qset_acl(char const   *name , int desc , mode_t mode ) ;
#line 30
int set_acl(char const   *name , int desc , mode_t mode ) ;
#line 44 "/home/khheo/project/benchmark/sed-4.5/lib/quote.h"
char const   *quote(char const   *arg ) ;
#line 41 "/home/khheo/project/benchmark/sed-4.5/lib/set-acl.c"
int set_acl(char const   *name , int desc , mode_t mode ) 
{ 
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 44
  tmp = qset_acl(name, desc, mode);
#line 44
  ret = tmp;
  }
#line 45
  if (ret != 0) {
    {
#line 46
    tmp___0 = quote(name);
#line 46
    tmp___1 = gettext("setting permissions for %s");
#line 46
    tmp___2 = __errno_location();
#line 46
    error(0, *tmp___2, (char const   *)tmp___1, tmp___0);
    }
  }
#line 47
  return (ret);
}
}
#line 37 "./lib/selinux/selinux.h"
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 37
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 86 "./lib/selinux/selinux.h"
__inline int getcon(security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 88
  tmp = __errno_location();
#line 88
  *tmp = 95;
  }
#line 88
  return (-1);
}
}
#line 89 "./lib/selinux/selinux.h"
__inline void freecon(security_context_t con  __attribute__((__unused__)) ) 
{ 


  {
#line 90
  return;
}
}
#line 95 "./lib/selinux/selinux.h"
__inline int setfscreatecon(security_context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 97
  tmp = __errno_location();
#line 97
  *tmp = 95;
  }
#line 97
  return (-1);
}
}
#line 98 "./lib/selinux/selinux.h"
__inline int matchpathcon(char const   *file  __attribute__((__unused__)) , mode_t m  __attribute__((__unused__)) ,
                          security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 102
  tmp = __errno_location();
#line 102
  *tmp = 95;
  }
#line 102
  return (-1);
}
}
#line 103 "./lib/selinux/selinux.h"
__inline int getfilecon(char const   *file  __attribute__((__unused__)) , security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 106
  tmp = __errno_location();
#line 106
  *tmp = 95;
  }
#line 106
  return (-1);
}
}
#line 111 "./lib/selinux/selinux.h"
__inline int fgetfilecon(int fd , security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 113
  tmp = __errno_location();
#line 113
  *tmp = 95;
  }
#line 113
  return (-1);
}
}
#line 114 "./lib/selinux/selinux.h"
__inline int setfilecon(char const   *file  __attribute__((__unused__)) , security_context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 117
  tmp = __errno_location();
#line 117
  *tmp = 95;
  }
#line 117
  return (-1);
}
}
#line 122 "./lib/selinux/selinux.h"
__inline int fsetfilecon(int fd  __attribute__((__unused__)) , security_context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 125
  tmp = __errno_location();
#line 125
  *tmp = 95;
  }
#line 125
  return (-1);
}
}
#line 136 "./lib/selinux/selinux.h"
__inline int security_compute_create(security_context_t scon  __attribute__((__unused__)) ,
                                     security_context_t tcon  __attribute__((__unused__)) ,
                                     security_class_t tclass  __attribute__((__unused__)) ,
                                     security_context_t *newcon  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 141
  tmp = __errno_location();
#line 141
  *tmp = 95;
  }
#line 141
  return (-1);
}
}
#line 142 "./lib/selinux/selinux.h"
__inline security_class_t string_to_security_class(char const   *name ) 
{ 
  int *tmp ;

  {
  {
#line 144
  tmp = __errno_location();
#line 144
  *tmp = 95;
  }
#line 144
  return ((security_class_t )0);
}
}
#line 145 "./lib/selinux/selinux.h"
__inline int matchpathcon_init_prefix(char const   *path  __attribute__((__unused__)) ,
                                      char const   *prefix  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 148
  tmp = __errno_location();
#line 148
  *tmp = 95;
  }
#line 148
  return (-1);
}
}
#line 153
#pragma GCC diagnostic pop
#line 10 "./lib/selinux/context.h"
#pragma GCC diagnostic push
#line 10
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 10
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 54 "./lib/selinux/context.h"
__inline context_t context_new(char const   *s  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 55
  tmp = __errno_location();
#line 55
  *tmp = 95;
  }
#line 55
  return (0);
}
}
#line 56 "./lib/selinux/context.h"
__inline char *context_str(context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 57
  tmp = __errno_location();
#line 57
  *tmp = 95;
  }
#line 57
  return ((char *)((void *)0));
}
}
#line 58 "./lib/selinux/context.h"
__inline void context_free(context_t c  __attribute__((__unused__)) ) 
{ 


  {
#line 58
  return;
}
}
#line 60 "./lib/selinux/context.h"
__inline int context_user_set(context_t sc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 62
  tmp = __errno_location();
#line 62
  *tmp = 95;
  }
#line 62
  return (-1);
}
}
#line 81
#pragma GCC diagnostic pop
#line 24 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
#line 267 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.h"
char const   * const  quoting_style_args[11] ;
#line 268
enum quoting_style  const  quoting_style_vals[10] ;
#line 278
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 281
enum quoting_style get_quoting_style(struct quoting_options  const  *o ) ;
#line 285
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 294
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 300
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 311
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 326
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) ;
#line 333
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 342
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 352
char *quotearg_n(int n , char const   *arg ) ;
#line 355
char *quotearg(char const   *arg ) ;
#line 360
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 363
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 368
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 373
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 377
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 380
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 385
char *quotearg_char(char const   *arg , char ch ) ;
#line 388
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 391
char *quotearg_colon(char const   *arg ) ;
#line 394
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 397
char *quotearg_n_style_colon(int n , enum quoting_style s , char const   *arg ) ;
#line 403
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 408
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 413
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 418
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 423
void quotearg_free(void) ;
#line 25 "/home/khheo/project/benchmark/sed-4.5/lib/quote.h"
struct quoting_options quote_quoting_options ;
#line 31
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 36
char const   *quote_mem(char const   *arg , size_t argsize ) ;
#line 40
char const   *quote_n(int n , char const   *arg ) ;
#line 29 "/home/khheo/project/benchmark/sed-4.5/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 42 "/home/khheo/project/benchmark/sed-4.5/lib/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 168 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline _Bool c_isalnum(int c ) 
{ 


  {
  {
#line 175
  if (c == 90) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 89) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 88) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 87) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 86) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 85) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 84) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 83) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 82) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 81) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 80) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 79) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 78) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 77) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 76) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 75) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 74) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 73) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 72) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 71) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 70) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 69) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 68) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 67) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 66) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 65) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 122) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 121) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 120) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 119) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 118) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 117) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 116) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 115) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 114) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 113) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 112) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 111) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 110) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 109) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 108) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 107) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 106) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 105) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 104) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 103) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 102) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 101) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 100) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 99) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 98) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 97) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 57) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 56) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 55) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 54) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 53) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 52) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 51) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 50) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 49) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 48) {
#line 175
    goto case_90;
  }
#line 177
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 176
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 178
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 182 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline _Bool c_isalpha(int c ) 
{ 


  {
  {
#line 188
  if (c == 90) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 89) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 88) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 87) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 86) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 85) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 84) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 83) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 82) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 81) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 80) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 79) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 78) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 77) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 76) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 75) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 74) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 73) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 72) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 71) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 70) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 69) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 68) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 67) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 66) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 65) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 122) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 121) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 120) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 119) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 118) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 117) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 116) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 115) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 114) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 113) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 112) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 111) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 110) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 109) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 108) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 107) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 106) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 105) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 104) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 103) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 102) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 101) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 100) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 99) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 98) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 97) {
#line 188
    goto case_90;
  }
#line 190
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 189
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 191
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 197 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline _Bool c_isascii(int c ) 
{ 


  {
  {
#line 207
  if (c == 90) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 89) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 88) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 87) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 86) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 85) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 84) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 83) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 82) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 81) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 80) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 79) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 78) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 77) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 76) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 75) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 74) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 73) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 72) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 71) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 70) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 69) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 68) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 67) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 66) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 65) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 126) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 125) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 124) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 123) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 96) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 95) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 94) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 93) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 92) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 91) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 64) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 63) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 62) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 61) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 60) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 59) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 58) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 47) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 46) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 45) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 44) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 43) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 42) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 41) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 40) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 39) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 38) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 37) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 36) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 35) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 34) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 33) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 122) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 121) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 120) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 119) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 118) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 117) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 116) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 115) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 114) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 113) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 112) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 111) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 110) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 109) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 108) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 107) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 106) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 105) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 104) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 103) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 102) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 101) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 100) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 99) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 98) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 97) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 57) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 56) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 55) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 54) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 53) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 52) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 51) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 50) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 49) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 48) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 127) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 31) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 30) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 29) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 28) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 27) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 26) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 25) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 24) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 23) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 22) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 21) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 20) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 19) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 18) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 17) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 16) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 15) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 14) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 6) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 5) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 4) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 3) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 2) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 1) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 0) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 11) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 9) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 13) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 10) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 12) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 8) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 7) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 32) {
#line 207
    goto case_90;
  }
#line 209
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_127: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 208
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 210
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 214 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline _Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 217
  if (c == 32) {
#line 217
    tmp = 1;
  } else
#line 217
  if (c == 9) {
#line 217
    tmp = 1;
  } else {
#line 217
    tmp = 0;
  }
#line 217
  return ((_Bool )tmp);
}
}
#line 220 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline _Bool c_iscntrl(int c ) 
{ 


  {
  {
#line 225
  if (c == 127) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 31) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 30) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 29) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 28) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 27) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 26) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 25) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 24) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 23) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 22) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 21) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 20) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 19) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 18) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 17) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 16) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 15) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 14) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 6) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 5) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 4) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 3) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 2) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 1) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 0) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 11) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 9) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 13) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 10) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 12) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 8) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 7) {
#line 225
    goto case_127;
  }
#line 227
  goto switch_default;
  case_127: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 226
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 228
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 232 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline _Bool c_isdigit(int c ) 
{ 


  {
  {
#line 237
  if (c == 57) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 56) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 55) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 54) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 53) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 52) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 51) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 50) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 49) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 48) {
#line 237
    goto case_57;
  }
#line 239
  goto switch_default;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 238
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 240
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 244 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline _Bool c_isgraph(int c ) 
{ 


  {
  {
#line 252
  if (c == 90) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 89) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 88) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 87) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 86) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 85) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 84) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 83) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 82) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 81) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 80) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 79) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 78) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 77) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 76) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 75) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 74) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 73) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 72) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 71) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 70) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 69) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 68) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 67) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 66) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 65) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 126) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 125) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 124) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 123) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 96) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 95) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 94) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 93) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 92) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 91) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 64) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 63) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 62) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 61) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 60) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 59) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 58) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 47) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 46) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 45) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 44) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 43) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 42) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 41) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 40) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 39) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 38) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 37) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 36) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 35) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 34) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 33) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 122) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 121) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 120) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 119) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 118) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 117) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 116) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 115) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 114) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 113) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 112) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 111) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 110) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 109) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 108) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 107) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 106) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 105) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 104) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 103) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 102) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 101) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 100) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 99) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 98) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 97) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 57) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 56) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 55) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 54) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 53) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 52) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 51) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 50) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 49) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 48) {
#line 252
    goto case_90;
  }
#line 254
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 253
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 255
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 259 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline _Bool c_islower(int c ) 
{ 


  {
  {
#line 264
  if (c == 122) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 121) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 120) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 119) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 118) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 117) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 116) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 115) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 114) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 113) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 112) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 111) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 110) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 109) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 108) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 107) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 106) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 105) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 104) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 103) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 102) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 101) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 100) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 99) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 98) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 97) {
#line 264
    goto case_122;
  }
#line 266
  goto switch_default;
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 265
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 267
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 271 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline _Bool c_isprint(int c ) 
{ 


  {
  {
#line 280
  if (c == 90) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 89) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 88) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 87) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 86) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 85) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 84) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 83) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 82) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 81) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 80) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 79) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 78) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 77) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 76) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 75) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 74) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 73) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 72) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 71) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 70) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 69) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 68) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 67) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 66) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 65) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 126) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 125) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 124) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 123) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 96) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 95) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 94) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 93) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 92) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 91) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 64) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 63) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 62) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 61) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 60) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 59) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 58) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 47) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 46) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 45) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 44) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 43) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 42) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 41) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 40) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 39) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 38) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 37) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 36) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 35) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 34) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 33) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 122) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 121) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 120) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 119) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 118) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 117) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 116) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 115) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 114) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 113) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 112) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 111) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 110) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 109) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 108) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 107) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 106) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 105) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 104) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 103) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 102) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 101) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 100) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 99) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 98) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 97) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 57) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 56) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 55) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 54) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 53) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 52) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 51) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 50) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 49) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 48) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 32) {
#line 280
    goto case_90;
  }
#line 282
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 281
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 283
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 287 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline _Bool c_ispunct(int c ) 
{ 


  {
  {
#line 292
  if (c == 126) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 125) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 124) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 123) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 96) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 95) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 94) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 93) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 92) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 91) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 64) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 63) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 62) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 61) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 60) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 59) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 58) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 47) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 46) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 45) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 44) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 43) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 42) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 41) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 40) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 39) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 38) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 37) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 36) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 35) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 34) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 33) {
#line 292
    goto case_126;
  }
#line 294
  goto switch_default;
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
#line 293
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 295
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 299 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline _Bool c_isspace(int c ) 
{ 


  {
  {
#line 304
  if (c == 13) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 12) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 11) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 10) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 9) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 32) {
#line 304
    goto case_13;
  }
#line 306
  goto switch_default;
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 305
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 307
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 311 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline _Bool c_isupper(int c ) 
{ 


  {
  {
#line 316
  if (c == 90) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 89) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 88) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 87) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 86) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 85) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 84) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 83) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 82) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 81) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 80) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 79) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 78) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 77) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 76) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 75) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 74) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 73) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 72) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 71) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 70) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 69) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 68) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 67) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 66) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 65) {
#line 316
    goto case_90;
  }
#line 318
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 317
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 319
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 323 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline _Bool c_isxdigit(int c ) 
{ 


  {
  {
#line 329
  if (c == 70) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 69) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 68) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 67) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 66) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 65) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 102) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 101) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 100) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 99) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 98) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 97) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 57) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 56) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 55) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 54) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 53) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 52) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 51) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 50) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 49) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 48) {
#line 329
    goto case_70;
  }
#line 331
  goto switch_default;
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 330
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 332
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 336 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline int c_tolower(int c ) 
{ 


  {
  {
#line 341
  if (c == 90) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 89) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 88) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 87) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 86) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 85) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 84) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 83) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 82) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 81) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 80) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 79) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 78) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 77) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 76) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 75) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 74) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 73) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 72) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 71) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 70) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 69) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 68) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 67) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 66) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 65) {
#line 341
    goto case_90;
  }
#line 343
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 342
  return ((c - 65) + 97);
  switch_default: /* CIL Label */ 
#line 344
  return (c);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 348 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
__inline int c_toupper(int c ) 
{ 


  {
  {
#line 353
  if (c == 122) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 121) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 120) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 119) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 118) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 117) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 116) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 115) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 114) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 113) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 112) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 111) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 110) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 109) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 108) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 107) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 106) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 105) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 104) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 103) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 102) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 101) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 100) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 99) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 98) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 97) {
#line 353
    goto case_122;
  }
#line 355
  goto switch_default;
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 354
  return ((c - 97) + 65);
  switch_default: /* CIL Label */ 
#line 356
  return (c);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 364
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/sed-4.5/lib/localcharset.h"
char const   *locale_charset(void) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 292 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mbsinit)(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 686 "./lib/wchar.h"
size_t rpl_mbrtowc(wchar_t *pwc , char const   *s , size_t n , mbstate_t *ps ) ;
#line 120 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswprint)(wint_t __wc ) ;
#line 82 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 85 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char const   * const  quoting_style_args[11]  = 
#line 85 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"shell-escape", 
        (char const   */* const  */)"shell-escape-always",      (char const   */* const  */)"c",      (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape", 
        (char const   */* const  */)"locale",      (char const   */* const  */)"clocale",      (char const   */* const  */)0};
#line 101 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[10]  = 
#line 101
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7, 
        (enum quoting_style  const  )8,      (enum quoting_style  const  )9};
#line 116 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 121 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 124
  tmp = __errno_location();
#line 124
  e = *tmp;
  }
#line 125
  if (o) {
#line 125
    tmp___0 = o;
  } else {
#line 125
    tmp___0 = & default_quoting_options;
  }
  {
#line 125
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 125
  p = (struct quoting_options *)tmp___1;
#line 127
  tmp___2 = __errno_location();
#line 127
  *tmp___2 = e;
  }
#line 128
  return (p);
}
}
#line 132 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *tmp ;

  {
#line 135
  if (o) {
#line 135
    tmp = o;
  } else {
#line 135
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
#line 135
  return ((enum quoting_style )tmp->style);
}
}
#line 140 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 143
  if (o) {
#line 143
    tmp = o;
  } else {
#line 143
    tmp = & default_quoting_options;
  }
#line 143
  tmp->style = s;
#line 144
  return;
}
}
#line 151 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 154
  uc = (unsigned char )c;
#line 155
  if (o) {
#line 155
    tmp = o;
  } else {
#line 155
    tmp = & default_quoting_options;
  }
#line 155
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 157
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 158
  r = (int )((*p >> shift) & 1U);
#line 159
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 160
  return (r);
}
}
#line 167 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 171
  if (! o) {
#line 172
    o = & default_quoting_options;
  }
#line 173
  r = o->flags;
#line 174
  o->flags = i;
#line 175
  return (r);
}
}
#line 178 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 182
  if (! o) {
#line 183
    o = & default_quoting_options;
  }
#line 184
  o->style = (enum quoting_style )10;
#line 185
  if (! left_quote) {
    {
#line 186
    abort();
    }
  } else
#line 185
  if (! right_quote) {
    {
#line 186
    abort();
    }
  }
#line 187
  o->left_quote = left_quote;
#line 188
  o->right_quote = right_quote;
#line 189
  return;
}
}
#line 192 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  unsigned int tmp ;

  {
#line 195
  o.style = (enum quoting_style )0;
#line 195
  o.flags = 0;
#line 195
  o.quote_these_too[0] = 0U;
#line 195
  tmp = 1U;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (tmp >= 8U) {
#line 195
      goto while_break;
    }
#line 195
    o.quote_these_too[tmp] = 0U;
#line 195
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  o.left_quote = (char const   *)((void *)0);
#line 195
  o.right_quote = (char const   *)((void *)0);
#line 196
  if ((unsigned int )style == 10U) {
    {
#line 197
    abort();
    }
  }
#line 198
  o.style = style;
#line 199
  return (o);
}
}
#line 206 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 209
  tmp = gettext(msgid);
#line 209
  translation = (char const   *)tmp;
  }
#line 212
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 213
    return (translation);
  }
  {
#line 233
  locale_code = locale_charset();
#line 234
  tmp___1 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 234
  if (tmp___1 == 0) {
#line 235
    if ((int const   )*(msgid + 0) == 96) {
#line 235
      tmp___0 = "\342\200\230";
    } else {
#line 235
      tmp___0 = "\342\200\231";
    }
#line 235
    return (tmp___0);
  }
  {
#line 236
  tmp___3 = c_strcasecmp(locale_code, "GB18030");
  }
#line 236
  if (tmp___3 == 0) {
#line 237
    if ((int const   )*(msgid + 0) == 96) {
#line 237
      tmp___2 = "\241\ae";
    } else {
#line 237
      tmp___2 = "\241\257";
    }
#line 237
    return (tmp___2);
  }
#line 239
  if ((unsigned int )s == 9U) {
#line 239
    tmp___4 = "\"";
  } else {
#line 239
    tmp___4 = "\'";
  }
#line 239
  return (tmp___4);
}
}
#line 255 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer___0 , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  size_t orig_buffersize ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  _Bool pending_shell_escape_end ;
  _Bool encountered_single_quote ;
  _Bool all_c_and_shell_quote_compat ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  _Bool escaping ;
  _Bool c_and_shell_quote_compat ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___3 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___4 ;
  size_t j ;
  int tmp___5 ;
  int tmp___6 ;
  size_t ilim ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 264
  len = (size_t )0;
#line 265
  orig_buffersize = (size_t )0;
#line 266
  quote_string = (char const   *)0;
#line 267
  quote_string_len = (size_t )0;
#line 268
  backslash_escapes = (_Bool)0;
#line 269
  tmp = __ctype_get_mb_cur_max();
#line 269
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 270
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
#line 271
  pending_shell_escape_end = (_Bool)0;
#line 272
  encountered_single_quote = (_Bool)0;
#line 273
  all_c_and_shell_quote_compat = (_Bool)1;
  }
  process_input: 
  {
#line 318
  if ((unsigned int )quoting_style == 6U) {
#line 318
    goto case_6;
  }
#line 322
  if ((unsigned int )quoting_style == 5U) {
#line 322
    goto case_5;
  }
#line 330
  if ((unsigned int )quoting_style == 7U) {
#line 330
    goto case_7;
  }
#line 337
  if ((unsigned int )quoting_style == 10U) {
#line 337
    goto case_10;
  }
#line 337
  if ((unsigned int )quoting_style == 9U) {
#line 337
    goto case_10;
  }
#line 337
  if ((unsigned int )quoting_style == 8U) {
#line 337
    goto case_10;
  }
#line 374
  if ((unsigned int )quoting_style == 3U) {
#line 374
    goto case_3;
  }
#line 377
  if ((unsigned int )quoting_style == 1U) {
#line 377
    goto case_1;
  }
#line 380
  if ((unsigned int )quoting_style == 4U) {
#line 380
    goto case_4;
  }
#line 384
  if ((unsigned int )quoting_style == 2U) {
#line 384
    goto case_2;
  }
#line 392
  if ((unsigned int )quoting_style == 0U) {
#line 392
    goto case_0;
  }
#line 396
  goto switch_default;
  case_6: /* CIL Label */ 
#line 319
  quoting_style = (enum quoting_style )5;
#line 320
  elide_outer_quotes = (_Bool)1;
  case_5: /* CIL Label */ 
#line 323
  if (! elide_outer_quotes) {
    {
#line 324
    while (1) {
      while_continue: /* CIL Label */ ;
#line 324
      if (len < buffersize) {
#line 324
        *(buffer___0 + len) = (char )'\"';
      }
#line 324
      len ++;
#line 324
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 325
  backslash_escapes = (_Bool)1;
#line 326
  quote_string = "\"";
#line 327
  quote_string_len = (size_t )1;
#line 328
  goto switch_break;
  case_7: /* CIL Label */ 
#line 331
  backslash_escapes = (_Bool)1;
#line 332
  elide_outer_quotes = (_Bool)0;
#line 333
  goto switch_break;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 339
  if ((unsigned int )quoting_style != 10U) {
    {
#line 362
    left_quote = gettext_quote("`", quoting_style);
#line 363
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 365
  if (! elide_outer_quotes) {
#line 366
    quote_string = left_quote;
    {
#line 366
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 366
      if (! *quote_string) {
#line 366
        goto while_break___0;
      }
      {
#line 367
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 367
        if (len < buffersize) {
#line 367
          *(buffer___0 + len) = (char )*quote_string;
        }
#line 367
        len ++;
#line 367
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 366
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 368
  backslash_escapes = (_Bool)1;
#line 369
  quote_string = right_quote;
#line 370
  quote_string_len = strlen(quote_string);
  }
#line 372
  goto switch_break;
  case_3: /* CIL Label */ 
#line 375
  backslash_escapes = (_Bool)1;
  case_1: /* CIL Label */ 
#line 378
  elide_outer_quotes = (_Bool)1;
  case_4: /* CIL Label */ 
#line 381
  if (! elide_outer_quotes) {
#line 382
    backslash_escapes = (_Bool)1;
  }
  case_2: /* CIL Label */ 
#line 385
  quoting_style = (enum quoting_style )2;
#line 386
  if (! elide_outer_quotes) {
    {
#line 387
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 387
      if (len < buffersize) {
#line 387
        *(buffer___0 + len) = (char )'\'';
      }
#line 387
      len ++;
#line 387
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 388
  quote_string = "\'";
#line 389
  quote_string_len = (size_t )1;
#line 390
  goto switch_break;
  case_0: /* CIL Label */ 
#line 393
  elide_outer_quotes = (_Bool)0;
#line 394
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 397
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 400
  i = (size_t )0;
  {
#line 400
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 400
    if (argsize == 0xffffffffffffffffUL) {
#line 400
      tmp___7 = (int const   )*(arg + i) == 0;
    } else {
#line 400
      tmp___7 = i == argsize;
    }
#line 400
    if (tmp___7) {
#line 400
      goto while_break___3;
    }
#line 404
    is_right_quote = (_Bool)0;
#line 405
    escaping = (_Bool)0;
#line 406
    c_and_shell_quote_compat = (_Bool)0;
#line 408
    if (backslash_escapes) {
#line 408
      if ((unsigned int )quoting_style != 2U) {
#line 408
        if (quote_string_len) {
#line 408
          if (argsize == 0xffffffffffffffffUL) {
#line 408
            if (1UL < quote_string_len) {
              {
#line 408
              argsize = strlen(arg);
#line 408
              tmp___0 = argsize;
              }
            } else {
#line 408
              tmp___0 = argsize;
            }
          } else {
#line 408
            tmp___0 = argsize;
          }
#line 408
          if (i + quote_string_len <= tmp___0) {
            {
#line 408
            tmp___1 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                             quote_string_len);
            }
#line 408
            if (tmp___1 == 0) {
#line 419
              if (elide_outer_quotes) {
#line 420
                goto force_outer_quoting_style;
              }
#line 421
              is_right_quote = (_Bool)1;
            }
          }
        }
      }
    }
#line 424
    c = (unsigned char )*(arg + i);
    {
#line 427
    if ((int )c == 0) {
#line 427
      goto case_0___0;
    }
#line 453
    if ((int )c == 63) {
#line 453
      goto case_63;
    }
#line 491
    if ((int )c == 7) {
#line 491
      goto case_7___0;
    }
#line 492
    if ((int )c == 8) {
#line 492
      goto case_8___0;
    }
#line 493
    if ((int )c == 12) {
#line 493
      goto case_12;
    }
#line 494
    if ((int )c == 10) {
#line 494
      goto case_10___0;
    }
#line 495
    if ((int )c == 13) {
#line 495
      goto case_13;
    }
#line 496
    if ((int )c == 9) {
#line 496
      goto case_9___0;
    }
#line 497
    if ((int )c == 11) {
#line 497
      goto case_11;
    }
#line 498
    if ((int )c == 92) {
#line 498
      goto case_92;
    }
#line 525
    if ((int )c == 125) {
#line 525
      goto case_125;
    }
#line 525
    if ((int )c == 123) {
#line 525
      goto case_125;
    }
#line 529
    if ((int )c == 126) {
#line 529
      goto case_126;
    }
#line 529
    if ((int )c == 35) {
#line 529
      goto case_126;
    }
#line 533
    if ((int )c == 32) {
#line 533
      goto case_32;
    }
#line 543
    if ((int )c == 124) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 96) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 94) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 91) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 62) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 61) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 60) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 59) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 42) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 41) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 40) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 38) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 36) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 34) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 33) {
#line 543
      goto case_124;
    }
#line 553
    if ((int )c == 39) {
#line 553
      goto case_39___0;
    }
#line 588
    if ((int )c == 122) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 121) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 120) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 119) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 118) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 117) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 116) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 115) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 114) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 113) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 112) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 111) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 110) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 109) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 108) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 107) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 106) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 105) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 104) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 103) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 102) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 101) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 100) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 99) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 98) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 97) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 95) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 93) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 90) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 89) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 88) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 87) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 86) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 85) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 84) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 83) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 82) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 81) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 80) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 79) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 78) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 77) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 76) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 75) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 74) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 73) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 72) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 71) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 70) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 69) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 68) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 67) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 66) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 65) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 58) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 57) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 56) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 55) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 54) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 53) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 52) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 51) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 50) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 49) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 48) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 47) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 46) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 45) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 44) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 43) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 37) {
#line 588
      goto case_122;
    }
#line 602
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 428
    if (backslash_escapes) {
      {
#line 430
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 430
        if (elide_outer_quotes) {
#line 430
          goto force_outer_quoting_style;
        }
#line 430
        escaping = (_Bool)1;
#line 430
        if ((unsigned int )quoting_style == 2U) {
#line 430
          if (! pending_shell_escape_end) {
            {
#line 430
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 430
              if (len < buffersize) {
#line 430
                *(buffer___0 + len) = (char )'\'';
              }
#line 430
              len ++;
#line 430
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 430
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 430
              if (len < buffersize) {
#line 430
                *(buffer___0 + len) = (char )'$';
              }
#line 430
              len ++;
#line 430
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 430
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 430
              if (len < buffersize) {
#line 430
                *(buffer___0 + len) = (char )'\'';
              }
#line 430
              len ++;
#line 430
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 430
            pending_shell_escape_end = (_Bool)1;
          }
        }
        {
#line 430
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 430
          if (len < buffersize) {
#line 430
            *(buffer___0 + len) = (char )'\\';
          }
#line 430
          len ++;
#line 430
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 430
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 437
      if ((unsigned int )quoting_style != 2U) {
#line 437
        if (i + 1UL < argsize) {
#line 437
          if (48 <= (int )*(arg + (i + 1UL))) {
#line 437
            if ((int const   )*(arg + (i + 1UL)) <= 57) {
              {
#line 440
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 440
                if (len < buffersize) {
#line 440
                  *(buffer___0 + len) = (char )'0';
                }
#line 440
                len ++;
#line 440
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
              {
#line 441
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 441
                if (len < buffersize) {
#line 441
                  *(buffer___0 + len) = (char )'0';
                }
#line 441
                len ++;
#line 441
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        }
      }
#line 443
      c = (unsigned char )'0';
    } else
#line 449
    if (flags & 1) {
#line 450
      goto __Cont;
    }
#line 451
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 456
    if ((unsigned int )quoting_style == 2U) {
#line 456
      goto case_2___0;
    }
#line 461
    if ((unsigned int )quoting_style == 5U) {
#line 461
      goto case_5___0;
    }
#line 486
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 457
    if (elide_outer_quotes) {
#line 458
      goto force_outer_quoting_style;
    }
#line 459
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 462
    if (flags & 4) {
#line 462
      if (i + 2UL < argsize) {
#line 462
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 468
            goto case_62;
          }
#line 481
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 471
          if (elide_outer_quotes) {
#line 472
            goto force_outer_quoting_style;
          }
#line 473
          c = (unsigned char )*(arg + (i + 2UL));
#line 474
          i += 2UL;
          {
#line 475
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 475
            if (len < buffersize) {
#line 475
              *(buffer___0 + len) = (char )'?';
            }
#line 475
            len ++;
#line 475
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 476
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 476
            if (len < buffersize) {
#line 476
              *(buffer___0 + len) = (char )'\"';
            }
#line 476
            len ++;
#line 476
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 477
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 477
            if (len < buffersize) {
#line 477
              *(buffer___0 + len) = (char )'\"';
            }
#line 477
            len ++;
#line 477
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
          {
#line 478
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 478
            if (len < buffersize) {
#line 478
              *(buffer___0 + len) = (char )'?';
            }
#line 478
            len ++;
#line 478
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 479
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 482
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 484
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 487
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 489
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 491
    esc = (unsigned char )'a';
#line 491
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 492
    esc = (unsigned char )'b';
#line 492
    goto c_escape;
    case_12: /* CIL Label */ 
#line 493
    esc = (unsigned char )'f';
#line 493
    goto c_escape;
    case_10___0: /* CIL Label */ 
#line 494
    esc = (unsigned char )'n';
#line 494
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 495
    esc = (unsigned char )'r';
#line 495
    goto c_and_shell_escape;
    case_9___0: /* CIL Label */ 
#line 496
    esc = (unsigned char )'t';
#line 496
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 497
    esc = (unsigned char )'v';
#line 497
    goto c_escape;
    case_92: /* CIL Label */ 
#line 498
    esc = c;
#line 500
    if ((unsigned int )quoting_style == 2U) {
#line 502
      if (elide_outer_quotes) {
#line 503
        goto force_outer_quoting_style;
      }
#line 504
      goto store_c;
    }
#line 509
    if (backslash_escapes) {
#line 509
      if (elide_outer_quotes) {
#line 509
        if (quote_string_len) {
#line 510
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 513
    if ((unsigned int )quoting_style == 2U) {
#line 513
      if (elide_outer_quotes) {
#line 515
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 518
    if (backslash_escapes) {
#line 520
      c = esc;
#line 521
      goto store_escape;
    }
#line 523
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 526
    if (argsize == 0xffffffffffffffffUL) {
#line 526
      tmp___2 = (int const   )*(arg + 1) == 0;
    } else {
#line 526
      tmp___2 = argsize == 1UL;
    }
#line 526
    if (! tmp___2) {
#line 527
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 530
    if (i != 0UL) {
#line 531
      goto switch_break___0;
    }
    case_32: /* CIL Label */ 
#line 534
    c_and_shell_quote_compat = (_Bool)1;
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
#line 548
    if ((unsigned int )quoting_style == 2U) {
#line 548
      if (elide_outer_quotes) {
#line 550
        goto force_outer_quoting_style;
      }
    }
#line 551
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 554
    encountered_single_quote = (_Bool)1;
#line 555
    c_and_shell_quote_compat = (_Bool)1;
#line 556
    if ((unsigned int )quoting_style == 2U) {
#line 558
      if (elide_outer_quotes) {
#line 559
        goto force_outer_quoting_style;
      }
#line 561
      if (buffersize) {
#line 561
        if (! orig_buffersize) {
#line 566
          orig_buffersize = buffersize;
#line 567
          buffersize = (size_t )0;
        }
      }
      {
#line 570
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 570
        if (len < buffersize) {
#line 570
          *(buffer___0 + len) = (char )'\'';
        }
#line 570
        len ++;
#line 570
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 571
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 571
        if (len < buffersize) {
#line 571
          *(buffer___0 + len) = (char )'\\';
        }
#line 571
        len ++;
#line 571
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 572
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 572
        if (len < buffersize) {
#line 572
          *(buffer___0 + len) = (char )'\'';
        }
#line 572
        len ++;
#line 572
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 573
      pending_shell_escape_end = (_Bool)0;
    }
#line 575
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 599
    c_and_shell_quote_compat = (_Bool)1;
#line 600
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 614
    if (unibyte_locale) {
      {
#line 616
      m = (size_t )1;
#line 617
      tmp___3 = __ctype_b_loc();
#line 617
      printable = (_Bool )(((int const   )*(*tmp___3 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 622
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 624
      m = (size_t )0;
#line 625
      printable = (_Bool)1;
      }
#line 626
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 627
        argsize = strlen(arg);
        }
      }
      {
#line 629
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 632
        tmp___4 = rpl_mbrtowc(& w, arg + (i + m), argsize - (i + m), & mbstate);
#line 632
        bytes = tmp___4;
        }
#line 634
        if (bytes == 0UL) {
#line 635
          goto while_break___18;
        } else
#line 636
        if (bytes == 0xffffffffffffffffUL) {
#line 638
          printable = (_Bool)0;
#line 639
          goto while_break___18;
        } else
#line 641
        if (bytes == 0xfffffffffffffffeUL) {
#line 643
          printable = (_Bool)0;
          {
#line 644
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 644
            if (i + m < argsize) {
#line 644
              if (! *(arg + (i + m))) {
#line 644
                goto while_break___19;
              }
            } else {
#line 644
              goto while_break___19;
            }
#line 645
            m ++;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 646
          goto while_break___18;
        } else {
#line 654
          if (elide_outer_quotes) {
#line 654
            if ((unsigned int )quoting_style == 2U) {
#line 658
              j = (size_t )1;
              {
#line 658
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 658
                if (! (j < bytes)) {
#line 658
                  goto while_break___20;
                }
                {
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 662
                  goto case_124___0;
                }
#line 665
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 663
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 666
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 658
                j ++;
              }
              while_break___20: /* CIL Label */ ;
              }
            }
          }
          {
#line 670
          tmp___5 = iswprint((wint_t )w);
          }
#line 670
          if (! tmp___5) {
#line 671
            printable = (_Bool)0;
          }
#line 672
          m += bytes;
        }
        {
#line 629
        tmp___6 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 629
        if (tmp___6) {
#line 629
          goto while_break___18;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
    }
#line 678
    c_and_shell_quote_compat = printable;
#line 680
    if (1UL < m) {
#line 680
      goto _L___0;
    } else
#line 680
    if (backslash_escapes) {
#line 680
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 684
        ilim = i + m;
        {
#line 686
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 688
          if (backslash_escapes) {
#line 688
            if (! printable) {
              {
#line 690
              while (1) {
                while_continue___22: /* CIL Label */ ;
#line 690
                if (elide_outer_quotes) {
#line 690
                  goto force_outer_quoting_style;
                }
#line 690
                escaping = (_Bool)1;
#line 690
                if ((unsigned int )quoting_style == 2U) {
#line 690
                  if (! pending_shell_escape_end) {
                    {
#line 690
                    while (1) {
                      while_continue___23: /* CIL Label */ ;
#line 690
                      if (len < buffersize) {
#line 690
                        *(buffer___0 + len) = (char )'\'';
                      }
#line 690
                      len ++;
#line 690
                      goto while_break___23;
                    }
                    while_break___23: /* CIL Label */ ;
                    }
                    {
#line 690
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 690
                      if (len < buffersize) {
#line 690
                        *(buffer___0 + len) = (char )'$';
                      }
#line 690
                      len ++;
#line 690
                      goto while_break___24;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                    {
#line 690
                    while (1) {
                      while_continue___25: /* CIL Label */ ;
#line 690
                      if (len < buffersize) {
#line 690
                        *(buffer___0 + len) = (char )'\'';
                      }
#line 690
                      len ++;
#line 690
                      goto while_break___25;
                    }
                    while_break___25: /* CIL Label */ ;
                    }
#line 690
                    pending_shell_escape_end = (_Bool)1;
                  }
                }
                {
#line 690
                while (1) {
                  while_continue___26: /* CIL Label */ ;
#line 690
                  if (len < buffersize) {
#line 690
                    *(buffer___0 + len) = (char )'\\';
                  }
#line 690
                  len ++;
#line 690
                  goto while_break___26;
                }
                while_break___26: /* CIL Label */ ;
                }
#line 690
                goto while_break___22;
              }
              while_break___22: /* CIL Label */ ;
              }
              {
#line 691
              while (1) {
                while_continue___27: /* CIL Label */ ;
#line 691
                if (len < buffersize) {
#line 691
                  *(buffer___0 + len) = (char )(48 + ((int )c >> 6));
                }
#line 691
                len ++;
#line 691
                goto while_break___27;
              }
              while_break___27: /* CIL Label */ ;
              }
              {
#line 692
              while (1) {
                while_continue___28: /* CIL Label */ ;
#line 692
                if (len < buffersize) {
#line 692
                  *(buffer___0 + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 692
                len ++;
#line 692
                goto while_break___28;
              }
              while_break___28: /* CIL Label */ ;
              }
#line 693
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 688
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 695
          if (is_right_quote) {
            {
#line 697
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 697
              if (len < buffersize) {
#line 697
                *(buffer___0 + len) = (char )'\\';
              }
#line 697
              len ++;
#line 697
              goto while_break___29;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 698
            is_right_quote = (_Bool)0;
          }
#line 700
          if (ilim <= i + 1UL) {
#line 701
            goto while_break___21;
          }
          {
#line 702
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 702
            if (pending_shell_escape_end) {
#line 702
              if (! escaping) {
                {
#line 702
                while (1) {
                  while_continue___31: /* CIL Label */ ;
#line 702
                  if (len < buffersize) {
#line 702
                    *(buffer___0 + len) = (char )'\'';
                  }
#line 702
                  len ++;
#line 702
                  goto while_break___31;
                }
                while_break___31: /* CIL Label */ ;
                }
                {
#line 702
                while (1) {
                  while_continue___32: /* CIL Label */ ;
#line 702
                  if (len < buffersize) {
#line 702
                    *(buffer___0 + len) = (char )'\'';
                  }
#line 702
                  len ++;
#line 702
                  goto while_break___32;
                }
                while_break___32: /* CIL Label */ ;
                }
#line 702
                pending_shell_escape_end = (_Bool)0;
              }
            }
#line 702
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
          {
#line 703
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 703
            if (len < buffersize) {
#line 703
              *(buffer___0 + len) = (char )c;
            }
#line 703
            len ++;
#line 703
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
#line 704
          i ++;
#line 704
          c = (unsigned char )*(arg + i);
        }
        while_break___21: /* CIL Label */ ;
        }
#line 707
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 712
    if (backslash_escapes) {
#line 712
      if ((unsigned int )quoting_style != 2U) {
#line 712
        goto _L___3;
      } else {
#line 712
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 712
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 712
      if (quote_these_too) {
#line 712
        if (! ((*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) >> (unsigned long )c % (sizeof(int ) * 8UL)) & 1U)) {
#line 712
          goto _L___2;
        }
      } else {
#line 712
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 712
    if (! is_right_quote) {
#line 717
      goto store_c;
    }
    store_escape: 
    {
#line 720
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 720
      if (elide_outer_quotes) {
#line 720
        goto force_outer_quoting_style;
      }
#line 720
      escaping = (_Bool)1;
#line 720
      if ((unsigned int )quoting_style == 2U) {
#line 720
        if (! pending_shell_escape_end) {
          {
#line 720
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 720
            if (len < buffersize) {
#line 720
              *(buffer___0 + len) = (char )'\'';
            }
#line 720
            len ++;
#line 720
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
          {
#line 720
          while (1) {
            while_continue___36: /* CIL Label */ ;
#line 720
            if (len < buffersize) {
#line 720
              *(buffer___0 + len) = (char )'$';
            }
#line 720
            len ++;
#line 720
            goto while_break___36;
          }
          while_break___36: /* CIL Label */ ;
          }
          {
#line 720
          while (1) {
            while_continue___37: /* CIL Label */ ;
#line 720
            if (len < buffersize) {
#line 720
              *(buffer___0 + len) = (char )'\'';
            }
#line 720
            len ++;
#line 720
            goto while_break___37;
          }
          while_break___37: /* CIL Label */ ;
          }
#line 720
          pending_shell_escape_end = (_Bool)1;
        }
      }
      {
#line 720
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 720
        if (len < buffersize) {
#line 720
          *(buffer___0 + len) = (char )'\\';
        }
#line 720
        len ++;
#line 720
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 720
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    store_c: 
    {
#line 723
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 723
      if (pending_shell_escape_end) {
#line 723
        if (! escaping) {
          {
#line 723
          while (1) {
            while_continue___40: /* CIL Label */ ;
#line 723
            if (len < buffersize) {
#line 723
              *(buffer___0 + len) = (char )'\'';
            }
#line 723
            len ++;
#line 723
            goto while_break___40;
          }
          while_break___40: /* CIL Label */ ;
          }
          {
#line 723
          while (1) {
            while_continue___41: /* CIL Label */ ;
#line 723
            if (len < buffersize) {
#line 723
              *(buffer___0 + len) = (char )'\'';
            }
#line 723
            len ++;
#line 723
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
#line 723
          pending_shell_escape_end = (_Bool)0;
        }
      }
#line 723
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 724
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 724
      if (len < buffersize) {
#line 724
        *(buffer___0 + len) = (char )c;
      }
#line 724
      len ++;
#line 724
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
#line 726
    if (! c_and_shell_quote_compat) {
#line 727
      all_c_and_shell_quote_compat = (_Bool)0;
    }
    __Cont: /* CIL Label */ 
#line 400
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 730
  if (len == 0UL) {
#line 730
    if ((unsigned int )quoting_style == 2U) {
#line 730
      if (elide_outer_quotes) {
#line 732
        goto force_outer_quoting_style;
      }
    }
  }
#line 738
  if ((unsigned int )quoting_style == 2U) {
#line 738
    if (! elide_outer_quotes) {
#line 738
      if (encountered_single_quote) {
#line 741
        if (all_c_and_shell_quote_compat) {
          {
#line 742
          tmp___8 = quotearg_buffer_restyled(buffer___0, orig_buffersize, arg, argsize,
                                             (enum quoting_style )5, flags, quote_these_too,
                                             left_quote, right_quote);
          }
#line 742
          return (tmp___8);
        } else
#line 746
        if (! buffersize) {
#line 746
          if (orig_buffersize) {
#line 749
            buffersize = orig_buffersize;
#line 750
            len = (size_t )0;
#line 751
            goto process_input;
          }
        }
      }
    }
  }
#line 755
  if (quote_string) {
#line 755
    if (! elide_outer_quotes) {
      {
#line 756
      while (1) {
        while_continue___43: /* CIL Label */ ;
#line 756
        if (! *quote_string) {
#line 756
          goto while_break___43;
        }
        {
#line 757
        while (1) {
          while_continue___44: /* CIL Label */ ;
#line 757
          if (len < buffersize) {
#line 757
            *(buffer___0 + len) = (char )*quote_string;
          }
#line 757
          len ++;
#line 757
          goto while_break___44;
        }
        while_break___44: /* CIL Label */ ;
        }
#line 756
        quote_string ++;
      }
      while_break___43: /* CIL Label */ ;
      }
    }
  }
#line 759
  if (len < buffersize) {
#line 760
    *(buffer___0 + len) = (char )'\000';
  }
#line 761
  return (len);
  force_outer_quoting_style: 
#line 766
  if ((unsigned int )quoting_style == 2U) {
#line 766
    if (backslash_escapes) {
#line 767
      quoting_style = (enum quoting_style )4;
    }
  }
  {
#line 768
  tmp___9 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 768
  return (tmp___9);
}
}
#line 783 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 788
  if (o) {
#line 788
    tmp = o;
  } else {
#line 788
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 788
  p = tmp;
#line 789
  tmp___0 = __errno_location();
#line 789
  e = *tmp___0;
#line 790
  tmp___1 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 790
  r = tmp___1;
#line 793
  tmp___2 = __errno_location();
#line 793
  *tmp___2 = e;
  }
#line 794
  return (r);
}
}
#line 798 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 802
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 802
  return (tmp);
}
}
#line 811 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *buf ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 815
  if (o) {
#line 815
    tmp = o;
  } else {
#line 815
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 815
  p = tmp;
#line 816
  tmp___0 = __errno_location();
#line 816
  e = *tmp___0;
  }
#line 818
  if (size) {
#line 818
    tmp___1 = 0;
  } else {
#line 818
    tmp___1 = 1;
  }
  {
#line 818
  flags = (int )(p->flags | (int const   )tmp___1);
#line 819
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 819
  bufsize = tmp___2 + 1UL;
#line 823
  tmp___3 = xcharalloc(bufsize);
#line 823
  buf = tmp___3;
#line 824
  quotearg_buffer_restyled(buf, bufsize, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 827
  tmp___4 = __errno_location();
#line 827
  *tmp___4 = e;
  }
#line 828
  if (size) {
#line 829
    *size = bufsize - 1UL;
  }
#line 830
  return (buf);
}
}
#line 842 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
static char slot0[256]  ;
#line 843 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
static int nslots  =    1;
#line 844 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 845 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 847 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  int i ;

  {
#line 850
  sv = slotvec;
#line 852
  i = 1;
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (! (i < nslots)) {
#line 852
      goto while_break;
    }
    {
#line 853
    free((void *)(sv + i)->val);
#line 852
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 856
    free((void *)(sv + 0)->val);
#line 857
    slotvec0.size = sizeof(slot0);
#line 858
    slotvec0.val = slot0;
    }
  }
#line 860
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 862
    free((void *)sv);
#line 863
    slotvec = & slotvec0;
    }
  }
#line 865
  nslots = 1;
#line 866
  return;
}
}
#line 876 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  struct slotvec *sv ;
  _Bool preallocated ;
  int nmax ;
  unsigned long tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 880
  tmp = __errno_location();
#line 880
  e = *tmp;
#line 882
  sv = slotvec;
  }
#line 884
  if (n < 0) {
    {
#line 885
    abort();
    }
  }
#line 887
  if (nslots <= n) {
#line 889
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 890
    if (2147483647UL < 9223372036854775807UL / sizeof(*sv)) {
#line 890
      tmp___0 = 2147483647UL;
    } else {
#line 890
      tmp___0 = 9223372036854775807UL / sizeof(*sv);
    }
#line 890
    nmax = (int )(tmp___0 - 1UL);
#line 892
    if (nmax < n) {
      {
#line 893
      xalloc_die();
      }
    }
#line 895
    if (preallocated) {
#line 895
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 895
      tmp___1 = sv;
    }
    {
#line 895
    tmp___2 = xrealloc((void *)tmp___1, (unsigned long )(n + 1) * sizeof(*sv));
#line 895
    sv = (struct slotvec *)tmp___2;
#line 895
    slotvec = sv;
    }
#line 896
    if (preallocated) {
#line 897
      *sv = slotvec0;
    }
    {
#line 898
    memset((void *)(sv + nslots), 0, (unsigned long )((n + 1) - nslots) * sizeof(*sv));
#line 899
    nslots = n + 1;
    }
  }
  {
#line 903
  size = (sv + n)->size;
#line 904
  val = (sv + n)->val;
#line 906
  flags = (int )(options->flags | 1);
#line 907
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 907
  qsize = tmp___3;
  }
#line 913
  if (size <= qsize) {
#line 915
    size = qsize + 1UL;
#line 915
    (sv + n)->size = size;
#line 916
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 917
      free((void *)val);
      }
    }
    {
#line 918
    val = xcharalloc(size);
#line 918
    (sv + n)->val = val;
#line 919
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 925
  tmp___4 = __errno_location();
#line 925
  *tmp___4 = e;
  }
#line 926
  return (val);
}
}
#line 930 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 933
  tmp = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 933
  return (tmp);
}
}
#line 936 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 939
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 939
  return (tmp);
}
}
#line 942 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 945
  tmp = quotearg_n(0, arg);
  }
#line 945
  return (tmp);
}
}
#line 948 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 951
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 951
  return (tmp);
}
}
#line 954 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 957
  tmp = quoting_options_from_style(s);
#line 957
  o = tmp;
#line 958
  tmp___0 = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& o));
  }
#line 958
  return (tmp___0);
}
}
#line 961 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 965
  tmp = quoting_options_from_style(s);
#line 965
  o = tmp;
#line 966
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 966
  return (tmp___0);
}
}
#line 969 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 972
  tmp = quotearg_n_style(0, s, arg);
  }
#line 972
  return (tmp);
}
}
#line 975 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 978
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 978
  return (tmp);
}
}
#line 981 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 985
  options = default_quoting_options;
#line 986
  set_char_quoting(& options, ch, 1);
#line 987
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 987
  return (tmp);
}
}
#line 990 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 993
  tmp = quotearg_char_mem(arg, 0xffffffffffffffffUL, ch);
  }
#line 993
  return (tmp);
}
}
#line 996 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 999
  tmp = quotearg_char(arg, (char )':');
  }
#line 999
  return (tmp);
}
}
#line 1002 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 1005
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 1005
  return (tmp);
}
}
#line 1008 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_n_style_colon(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 1012
  options = quoting_options_from_style(s);
#line 1013
  set_char_quoting(& options, (char )':', 1);
#line 1014
  tmp = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& options));
  }
#line 1014
  return (tmp);
}
}
#line 1017 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 1021
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, 0xffffffffffffffffUL);
  }
#line 1021
  return (tmp);
}
}
#line 1025 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *tmp ;

  {
  {
#line 1030
  o = default_quoting_options;
#line 1031
  set_custom_quoting(& o, left_quote, right_quote);
#line 1032
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 1032
  return (tmp);
}
}
#line 1035 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 1039
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
  }
#line 1039
  return (tmp);
}
}
#line 1042 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 1046
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  }
#line 1046
  return (tmp);
}
}
#line 1052 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
struct quoting_options quote_quoting_options  =    {(enum quoting_style )8, 0, {0U}, (char const   *)((void *)0), (char const   *)((void *)0)};
#line 1060 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 1063
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& quote_quoting_options));
  }
#line 1063
  return ((char const   *)tmp);
}
}
#line 1066 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char const   *quote_mem(char const   *arg , size_t argsize ) 
{ 
  char const   *tmp ;

  {
  {
#line 1069
  tmp = quote_n_mem(0, arg, argsize);
  }
#line 1069
  return (tmp);
}
}
#line 1072 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char const   *quote_n(int n , char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 1075
  tmp = quote_n_mem(n, arg, 0xffffffffffffffffUL);
  }
#line 1075
  return (tmp);
}
}
#line 1078 "/home/khheo/project/benchmark/sed-4.5/lib/quotearg.c"
char const   *quote(char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 1081
  tmp = quote_n(0, arg);
  }
#line 1081
  return (tmp);
}
}
#line 66 "/home/khheo/project/benchmark/sed-4.5/lib/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 296
void free_permission_context(struct permission_context *ctx )  __attribute__((__const__)) ;
#line 302
#pragma GCC diagnostic pop
#line 38 "/home/khheo/project/benchmark/sed-4.5/lib/qset-acl.c"
int qset_acl(char const   *name , int desc , mode_t mode ) 
{ 
  struct permission_context ctx ;
  int ret ;

  {
  {
#line 44
  memset((void *)(& ctx), 0, sizeof(ctx));
#line 45
  ctx.mode = mode;
#line 46
  ret = set_permissions(& ctx, name, desc);
#line 47
  free_permission_context(& ctx);
  }
#line 48
  return (ret);
}
}
#line 31 "/home/khheo/project/benchmark/sed-4.5/lib/acl.h"
int qcopy_acl(char const   *src_name , int source_desc , char const   *dst_name ,
              int dest_desc , mode_t mode ) ;
#line 66 "/home/khheo/project/benchmark/sed-4.5/lib/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 294
int get_permissions(char const   *name , int desc , mode_t mode , struct permission_context *ctx ) ;
#line 302
#pragma GCC diagnostic pop
#line 38 "/home/khheo/project/benchmark/sed-4.5/lib/qcopy-acl.c"
int qcopy_acl(char const   *src_name , int source_desc , char const   *dst_name ,
              int dest_desc , mode_t mode ) 
{ 
  struct permission_context ctx ;
  int ret ;

  {
  {
#line 45
  ret = get_permissions(src_name, source_desc, mode, & ctx);
  }
#line 46
  if (ret != 0) {
#line 47
    return (-2);
  }
  {
#line 48
  ret = set_permissions(& ctx, dst_name, dest_desc);
#line 49
  free_permission_context(& ctx);
  }
#line 50
  return (ret);
}
}
#line 32 "/home/khheo/project/benchmark/sed-4.5/lib/progname.h"
char const   *program_name ;
#line 37
void set_program_name(char const   *argv0 ) ;
#line 45 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 46
extern char *program_invocation_short_name ;
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 626
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 252
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 33 "/home/khheo/project/benchmark/sed-4.5/lib/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 38 "/home/khheo/project/benchmark/sed-4.5/lib/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 51
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
    {
#line 54
    fputs((char const   */* __restrict  */)"A NULL argv[0] was passed through an exec system call.\n",
          (FILE */* __restrict  */)stderr);
#line 56
    abort();
    }
  }
  {
#line 59
  tmp = strrchr(argv0, '/');
#line 59
  slash = (char const   *)tmp;
  }
#line 60
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 60
    base = slash + 1;
  } else {
#line 60
    base = argv0;
  }
#line 61
  if (base - argv0 >= 7L) {
    {
#line 61
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
    }
#line 61
    if (tmp___1 == 0) {
      {
#line 63
      argv0 = base;
#line 64
      tmp___0 = strncmp(base, "lt-", (size_t )3);
      }
#line 64
      if (tmp___0 == 0) {
#line 66
        argv0 = base + 3;
#line 70
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 84
  program_name = argv0;
#line 90
  program_invocation_name = (char *)argv0;
#line 92
  return;
}
}
#line 213 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.h"
void _obstack_newchunk(struct obstack *h , size_t length ) ;
#line 214
void _obstack_free(struct obstack *h , void *obj ) ;
#line 215
int _obstack_begin(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(size_t  ) ,
                   void (*freefun)(void * ) ) ;
#line 218
int _obstack_begin_1(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(void * ,
                                                                                            size_t  ) ,
                     void (*freefun)(void * , void * ) , void *arg ) ;
#line 222
size_t _obstack_memory_used(struct obstack *h )  __attribute__((__pure__)) ;
#line 230
 __attribute__((__noreturn__)) void (*obstack_alloc_failed_handler)(void) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 83 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.c"
static void *call_chunkfun(struct obstack *h , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 86
  if (h->use_extra_arg) {
    {
#line 87
    tmp = (*(h->chunkfun.extra))(h->extra_arg, size);
    }
#line 87
    return (tmp);
  } else {
    {
#line 89
    tmp___0 = (*(h->chunkfun.plain))(size);
    }
#line 89
    return (tmp___0);
  }
}
}
#line 92 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.c"
static void call_freefun(struct obstack *h , void *old_chunk ) 
{ 


  {
#line 95
  if (h->use_extra_arg) {
    {
#line 96
    (*(h->freefun.extra))(h->extra_arg, old_chunk);
    }
  } else {
    {
#line 98
    (*(h->freefun.plain))(old_chunk);
    }
  }
#line 99
  return;
}
}
#line 108 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.c"
static int _obstack_begin_worker(struct obstack *h , size_t size , size_t alignment ) 
{ 
  struct _obstack_chunk *chunk ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int extra ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  struct _obstack_chunk *tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;

  {
#line 114
  if (alignment == 0UL) {
#line 115
    if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
      tmp___1 = __alignof__(uintmax_t );
    } else {
#line 115
      tmp___1 = __alignof__(void *);
    }
#line 115
    if (__alignof__(long double ) > tmp___1) {
#line 115
      alignment = __alignof__(long double );
    } else {
#line 115
      if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
        tmp___0 = __alignof__(uintmax_t );
      } else {
#line 115
        tmp___0 = __alignof__(void *);
      }
#line 115
      alignment = tmp___0;
    }
  }
#line 116
  if (size == 0UL) {
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___5 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___5 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___5) {
#line 127
      tmp___4 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___3 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___3 = sizeof(void *);
      }
#line 127
      tmp___4 = tmp___3;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___9 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___9 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___9) {
#line 127
      tmp___8 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___7 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___7 = sizeof(void *);
      }
#line 127
      tmp___8 = tmp___7;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___13 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___13 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___13) {
#line 127
      tmp___12 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___11 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___11 = sizeof(void *);
      }
#line 127
      tmp___12 = tmp___11;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___17 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___17 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___17) {
#line 127
      tmp___16 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___15 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___15 = sizeof(void *);
      }
#line 127
      tmp___16 = tmp___15;
    }
#line 127
    extra = (int )(((((((12UL + tmp___4) - 1UL) & ~ (tmp___8 - 1UL)) + 4UL) + tmp___12) - 1UL) & ~ (tmp___16 - 1UL));
#line 130
    size = (size_t )(4096 - extra);
  }
  {
#line 133
  h->chunk_size = size;
#line 134
  h->alignment_mask = alignment - 1UL;
#line 136
  tmp___19 = call_chunkfun(h, h->chunk_size);
#line 136
  tmp___18 = (struct _obstack_chunk *)tmp___19;
#line 136
  h->chunk = tmp___18;
#line 136
  chunk = tmp___18;
  }
#line 137
  if (! chunk) {
    {
#line 138
    (*obstack_alloc_failed_handler)();
    }
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___21 = (char *)chunk;
  } else {
#line 139
    tmp___21 = (char *)0;
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___22 = (char *)chunk;
  } else {
#line 139
    tmp___22 = (char *)0;
  }
#line 139
  tmp___20 = tmp___21 + (((size_t )(chunk->contents - tmp___22) + (alignment - 1UL)) & ~ (alignment - 1UL));
#line 139
  h->object_base = tmp___20;
#line 139
  h->next_free = tmp___20;
#line 141
  tmp___23 = (char *)chunk + h->chunk_size;
#line 141
  chunk->limit = tmp___23;
#line 141
  h->chunk_limit = tmp___23;
#line 142
  chunk->prev = (struct _obstack_chunk *)0;
#line 144
  h->maybe_empty_object = 0U;
#line 145
  h->alloc_failed = 0U;
#line 146
  return (1);
}
}
#line 149 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.c"
int _obstack_begin(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(size_t  ) ,
                   void (*freefun)(void * ) ) 
{ 
  int tmp ;

  {
  {
#line 155
  h->chunkfun.plain = chunkfun;
#line 156
  h->freefun.plain = freefun;
#line 157
  h->use_extra_arg = 0U;
#line 158
  tmp = _obstack_begin_worker(h, size, alignment);
  }
#line 158
  return (tmp);
}
}
#line 161 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.c"
int _obstack_begin_1(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(void * ,
                                                                                            size_t  ) ,
                     void (*freefun)(void * , void * ) , void *arg ) 
{ 
  int tmp ;

  {
  {
#line 168
  h->chunkfun.extra = chunkfun;
#line 169
  h->freefun.extra = freefun;
#line 170
  h->extra_arg = arg;
#line 171
  h->use_extra_arg = 1U;
#line 172
  tmp = _obstack_begin_worker(h, size, alignment);
  }
#line 172
  return (tmp);
}
}
#line 181 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.c"
void _obstack_newchunk(struct obstack *h , size_t length ) 
{ 
  struct _obstack_chunk *old_chunk ;
  struct _obstack_chunk *new_chunk ;
  size_t obj_size ;
  char *object_base ;
  size_t sum1 ;
  size_t sum2 ;
  size_t new_size ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 184
  old_chunk = h->chunk;
#line 185
  new_chunk = (struct _obstack_chunk *)0;
#line 186
  obj_size = (size_t )(h->next_free - h->object_base);
#line 190
  sum1 = obj_size + length;
#line 191
  sum2 = sum1 + h->alignment_mask;
#line 192
  new_size = (sum2 + (obj_size >> 3)) + 100UL;
#line 193
  if (new_size < sum2) {
#line 194
    new_size = sum2;
  }
#line 195
  if (new_size < h->chunk_size) {
#line 196
    new_size = h->chunk_size;
  }
#line 199
  if (obj_size <= sum1) {
#line 199
    if (sum1 <= sum2) {
      {
#line 200
      tmp = call_chunkfun(h, new_size);
#line 200
      new_chunk = (struct _obstack_chunk *)tmp;
      }
    }
  }
#line 201
  if (! new_chunk) {
    {
#line 202
    (*obstack_alloc_failed_handler)();
    }
  }
#line 203
  h->chunk = new_chunk;
#line 204
  new_chunk->prev = old_chunk;
#line 205
  tmp___0 = (char *)new_chunk + new_size;
#line 205
  h->chunk_limit = tmp___0;
#line 205
  new_chunk->limit = tmp___0;
#line 208
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 208
    tmp___1 = (char *)new_chunk;
  } else {
#line 208
    tmp___1 = (char *)0;
  }
#line 208
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 208
    tmp___2 = (char *)new_chunk;
  } else {
#line 208
    tmp___2 = (char *)0;
  }
  {
#line 208
  object_base = tmp___1 + (((size_t )(new_chunk->contents - tmp___2) + h->alignment_mask) & ~ h->alignment_mask);
#line 212
  memcpy((void */* __restrict  */)object_base, (void const   */* __restrict  */)h->object_base,
         obj_size);
  }
#line 217
  if (! h->maybe_empty_object) {
#line 217
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
      tmp___3 = (char *)old_chunk;
    } else {
#line 217
      tmp___3 = (char *)0;
    }
#line 217
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
      tmp___4 = (char *)old_chunk;
    } else {
#line 217
      tmp___4 = (char *)0;
    }
#line 217
    if ((unsigned long )h->object_base == (unsigned long )(tmp___3 + (((size_t )(old_chunk->contents - tmp___4) + h->alignment_mask) & ~ h->alignment_mask))) {
      {
#line 222
      new_chunk->prev = old_chunk->prev;
#line 223
      call_freefun(h, (void *)old_chunk);
      }
    }
  }
#line 226
  h->object_base = object_base;
#line 227
  h->next_free = h->object_base + obj_size;
#line 229
  h->maybe_empty_object = 0U;
#line 230
  return;
}
}
#line 238
int _obstack_allocated_p(struct obstack *h , void *obj )  __attribute__((__pure__)) ;
#line 240
int _obstack_allocated_p(struct obstack *h , void *obj )  __attribute__((__pure__)) ;
#line 240 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.c"
int _obstack_allocated_p(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;

  {
#line 246
  lp = h->chunk;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 250
      if (! ((unsigned long )((void *)lp) >= (unsigned long )obj)) {
#line 250
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 250
          goto while_break;
        }
      }
    } else {
#line 250
      goto while_break;
    }
#line 252
    plp = lp->prev;
#line 253
    lp = plp;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0));
}
}
#line 261 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.c"
void _obstack_free(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;
  char *tmp ;

  {
#line 267
  lp = h->chunk;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 271
      if (! ((unsigned long )((void *)lp) >= (unsigned long )obj)) {
#line 271
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 271
          goto while_break;
        }
      }
    } else {
#line 271
      goto while_break;
    }
    {
#line 273
    plp = lp->prev;
#line 274
    call_freefun(h, (void *)lp);
#line 275
    lp = plp;
#line 278
    h->maybe_empty_object = 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if (lp) {
#line 282
    tmp = (char *)obj;
#line 282
    h->next_free = tmp;
#line 282
    h->object_base = tmp;
#line 283
    h->chunk_limit = lp->limit;
#line 284
    h->chunk = lp;
  } else
#line 286
  if ((unsigned long )obj != (unsigned long )((void *)0)) {
    {
#line 288
    abort();
    }
  }
#line 289
  return;
}
}
#line 291
size_t _obstack_memory_used(struct obstack *h )  __attribute__((__pure__)) ;
#line 291 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.c"
size_t _obstack_memory_used(struct obstack *h ) 
{ 
  struct _obstack_chunk *lp ;
  size_t nbytes ;

  {
#line 295
  nbytes = (size_t )0;
#line 297
  lp = h->chunk;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0))) {
#line 297
      goto while_break;
    }
#line 299
    nbytes += (size_t )(lp->limit - (char *)lp);
#line 297
    lp = lp->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return (nbytes);
}
}
#line 329 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.c"
static void print_and_abort(void) 
{ 
  char *tmp ;

  {
  {
#line 340
  tmp = gettext("memory exhausted");
#line 340
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          tmp);
#line 342
  exit((int )exit_failure);
  }
}
}
#line 351 "/home/khheo/project/benchmark/sed-4.5/lib/obstack.c"
 __attribute__((__noreturn__)) void (*obstack_alloc_failed_handler)(void)  =    & print_and_abort;
#line 296 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrtowc)(wchar_t * __restrict  __pwc ,
                                                                                 char const   * __restrict  __s ,
                                                                                 size_t __n ,
                                                                                 mbstate_t * __restrict  __p ) ;
#line 23 "/home/khheo/project/benchmark/sed-4.5/lib/hard-locale.h"
_Bool hard_locale(int category ) ;
#line 340 "/home/khheo/project/benchmark/sed-4.5/lib/mbrtowc.c"
size_t rpl_mbrtowc(wchar_t *pwc , char const   *s , size_t n , mbstate_t *ps ) 
{ 
  size_t ret ;
  wchar_t wc ;
  unsigned char uc ;
  _Bool tmp ;

  {
#line 360
  if (! pwc) {
#line 361
    pwc = & wc;
  }
  {
#line 395
  ret = mbrtowc((wchar_t */* __restrict  */)pwc, (char const   */* __restrict  */)s,
                n, (mbstate_t */* __restrict  */)ps);
  }
#line 403
  if (0xfffffffffffffffeUL <= ret) {
#line 403
    if (n != 0UL) {
      {
#line 403
      tmp = hard_locale(0);
      }
#line 403
      if (! tmp) {
#line 405
        uc = (unsigned char )*s;
#line 406
        *pwc = (wchar_t )uc;
#line 407
        return ((size_t )1);
      }
    }
  }
#line 411
  return (ret);
}
}
#line 715 "./lib/wchar.h"
size_t rpl_mbrlen(char const   *s , size_t n , mbstate_t *ps ) ;
#line 24 "/home/khheo/project/benchmark/sed-4.5/lib/mbrlen.c"
static mbstate_t internal_state  ;
#line 26 "/home/khheo/project/benchmark/sed-4.5/lib/mbrlen.c"
size_t rpl_mbrlen(char const   *s , size_t n , mbstate_t *ps ) 
{ 
  size_t tmp ;

  {
#line 29
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
#line 30
    ps = & internal_state;
  }
  {
#line 31
  tmp = rpl_mbrtowc((wchar_t *)((void *)0), s, n, ps);
  }
#line 31
  return (tmp);
}
}
#line 68 "/home/khheo/project/benchmark/sed-4.5/lib/malloca.h"
void *mmalloca(size_t n ) ;
#line 72
void freea(void *p ) ;
#line 42 "/home/khheo/project/benchmark/sed-4.5/lib/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  char *mem ;
  void *tmp ;
  char *p ;

  {
#line 48
  nplus = ((n + sizeof(small_t )) + 32UL) - 1UL;
#line 50
  if (nplus >= n) {
    {
#line 52
    tmp = malloc(nplus);
#line 52
    mem = (char *)tmp;
    }
#line 54
    if ((unsigned long )mem != (unsigned long )((void *)0)) {
#line 56
      p = (char *)((((((uintptr_t )mem + sizeof(small_t )) + 16UL) - 1UL) & 0xffffffffffffffe0UL) + 16UL);
#line 65
      *((small_t *)p + -1) = (small_t )(p - mem);
#line 67
      return ((void *)p);
    }
  }
#line 71
  return ((void *)0);
}
}
#line 82 "/home/khheo/project/benchmark/sed-4.5/lib/malloca.c"
void freea(void *p ) 
{ 
  void *mem ;

  {
#line 86
  if ((uintptr_t )p & 15UL) {
    {
#line 89
    abort();
    }
  }
#line 92
  if ((uintptr_t )p & 16UL) {
    {
#line 94
    mem = (void *)((char *)p - (int )*((small_t *)p + -1));
#line 95
    free(mem);
    }
  }
#line 97
  return;
}
}
#line 47 "./lib/localeinfo.h"
void init_localeinfo(struct localeinfo *localeinfo___0 ) ;
#line 54
int case_folded_counterparts(wint_t c , wchar_t *folded ) ;
#line 166 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towlower)(wint_t __wc ) ;
#line 169
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towupper)(wint_t __wc ) ;
#line 82 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 39 "/home/khheo/project/benchmark/sed-4.5/lib/localeinfo.c"
static _Bool is_using_utf8(void) 
{ 
  wchar_t wc ;
  mbstate_t mbs ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 43
  mbs.__count = 0;
#line 43
  mbs.__value.__wch = 0U;
#line 44
  tmp = rpl_mbrtowc(& wc, "\304\200", (size_t )2, & mbs);
  }
#line 44
  if (tmp == 2UL) {
#line 44
    if (wc == 256) {
#line 44
      tmp___0 = 1;
    } else {
#line 44
      tmp___0 = 0;
    }
  } else {
#line 44
    tmp___0 = 0;
  }
#line 44
  return ((_Bool )tmp___0);
}
}
#line 49 "/home/khheo/project/benchmark/sed-4.5/lib/localeinfo.c"
void init_localeinfo(struct localeinfo *localeinfo___0 ) 
{ 
  int i ;
  size_t tmp ;
  char c ;
  unsigned char uc ;
  mbstate_t s ;
  wchar_t wc ;
  size_t len ;
  size_t tmp___0 ;

  {
  {
#line 54
  tmp = __ctype_get_mb_cur_max();
#line 54
  localeinfo___0->multibyte = (_Bool )(tmp > 1UL);
#line 55
  localeinfo___0->using_utf8 = is_using_utf8();
#line 57
  i = -128;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i <= 127)) {
#line 57
      goto while_break;
    }
    {
#line 59
    c = (char )i;
#line 60
    uc = (unsigned char )i;
#line 61
    s.__count = 0;
#line 61
    s.__value.__wch = 0U;
#line 63
    tmp___0 = rpl_mbrtowc(& wc, (char const   *)(& c), (size_t )1, & s);
#line 63
    len = tmp___0;
    }
#line 64
    if (len <= 1UL) {
#line 64
      localeinfo___0->sbclen[uc] = (signed char)1;
    } else {
#line 64
      localeinfo___0->sbclen[uc] = (signed char )(- ((int )(- len)));
    }
#line 65
    if (len <= 1UL) {
#line 65
      localeinfo___0->sbctowc[uc] = (wint_t )wc;
    } else {
#line 65
      localeinfo___0->sbctowc[uc] = 4294967295U;
    }
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return;
}
}
#line 74 "/home/khheo/project/benchmark/sed-4.5/lib/localeinfo.c"
static short const   lonesome_lower[19]  = 
#line 74
  {      (short const   )181,      (short const   )305,      (short const   )383,      (short const   )453, 
        (short const   )456,      (short const   )459,      (short const   )498,      (short const   )837, 
        (short const   )962,      (short const   )976,      (short const   )977,      (short const   )981, 
        (short const   )982,      (short const   )1008,      (short const   )1009,      (short const   )1010, 
        (short const   )1013,      (short const   )7835,      (short const   )8126};
#line 95 "/home/khheo/project/benchmark/sed-4.5/lib/localeinfo.c"
int case_folded_counterparts(wint_t c , wchar_t *folded ) 
{ 
  int i ;
  int n ;
  wint_t uc ;
  wint_t tmp ;
  wint_t lc ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  wint_t tmp___3 ;
  wint_t li ;
  int tmp___4 ;
  wint_t tmp___5 ;

  {
  {
#line 99
  n = 0;
#line 100
  tmp = towupper(c);
#line 100
  uc = tmp;
#line 101
  tmp___0 = towlower(uc);
#line 101
  lc = tmp___0;
  }
#line 102
  if (uc != c) {
#line 103
    tmp___1 = n;
#line 103
    n ++;
#line 103
    *(folded + tmp___1) = (wchar_t )uc;
  }
#line 104
  if (lc != uc) {
#line 104
    if (lc != c) {
      {
#line 104
      tmp___3 = towupper(lc);
      }
#line 104
      if (tmp___3 == uc) {
#line 105
        tmp___2 = n;
#line 105
        n ++;
#line 105
        *(folded + tmp___2) = (wchar_t )lc;
      }
    }
  }
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! ((unsigned long )i < sizeof(lonesome_lower) / sizeof(lonesome_lower[0]))) {
#line 106
      goto while_break;
    }
#line 108
    li = (wint_t )lonesome_lower[i];
#line 109
    if (li != lc) {
#line 109
      if (li != uc) {
#line 109
        if (li != c) {
          {
#line 109
          tmp___5 = towupper(li);
          }
#line 109
          if (tmp___5 == uc) {
#line 110
            tmp___4 = n;
#line 110
            n ++;
#line 110
            *(folded + tmp___4) = (wchar_t )li;
          }
        }
      }
    }
#line 106
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (n);
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 377
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 495
extern int getc_unlocked(FILE *__stream ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 136
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 598 "./lib/unistd.h"
#pragma GCC diagnostic push
#line 598
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 598
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2086
#pragma GCC diagnostic pop
#line 661 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 121 "/home/khheo/project/benchmark/sed-4.5/lib/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 124 "/home/khheo/project/benchmark/sed-4.5/lib/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char *malloc_dir ;
  char const   *dir ;
  char const   *base ;
  char *file_name___0 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1___0[51] ;
  char buf2___0[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 129
  cp = (char const   *)charset_aliases;
#line 130
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 133
    malloc_dir = (char *)((void *)0);
#line 135
    base = "charset.alias";
#line 140
    tmp = getenv("CHARSETALIASDIR");
#line 140
    dir = (char const   *)tmp;
    }
#line 141
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 142
      malloc_dir = (char *)((void *)0);
#line 142
      dir = "/usr/local/lib";
    } else
#line 141
    if ((int const   )*(dir + 0) == 0) {
#line 142
      malloc_dir = (char *)((void *)0);
#line 142
      dir = "/usr/local/lib";
    }
    {
#line 146
    tmp___0 = strlen(dir);
#line 146
    dir_len___0 = tmp___0;
#line 147
    tmp___1 = strlen(base);
#line 147
    base_len___0 = tmp___1;
    }
#line 148
    if (dir_len___0 > 0UL) {
#line 148
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 148
        tmp___2 = 1;
      } else {
#line 148
        tmp___2 = 0;
      }
    } else {
#line 148
      tmp___2 = 0;
    }
    {
#line 148
    add_slash = tmp___2;
#line 149
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 149
    file_name___0 = (char *)tmp___3;
    }
#line 150
    if ((unsigned long )file_name___0 != (unsigned long )((void *)0)) {
      {
#line 152
      memcpy((void */* __restrict  */)file_name___0, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 153
      if (add_slash) {
#line 154
        *(file_name___0 + dir_len___0) = (char )'/';
      }
      {
#line 155
      memcpy((void */* __restrict  */)((file_name___0 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
    {
#line 159
    free((void *)malloc_dir);
    }
#line 161
    if ((unsigned long )file_name___0 == (unsigned long )((void *)0)) {
#line 163
      cp = "";
    } else {
      {
#line 175
      fd = open((char const   *)file_name___0, 131072);
      }
#line 177
      if (fd < 0) {
#line 179
        cp = "";
      } else {
        {
#line 184
        fp = fdopen(fd, "r");
        }
#line 185
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 188
          close(fd);
#line 189
          cp = "";
          }
        } else {
#line 194
          res_ptr = (char *)((void *)0);
#line 195
          res_size = (size_t )0;
          {
#line 197
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 205
            c = getc_unlocked(fp);
            }
#line 206
            if (c == -1) {
#line 207
              goto while_break;
            }
#line 208
            if (c == 10) {
#line 209
              goto __Cont;
            } else
#line 208
            if (c == 32) {
#line 209
              goto __Cont;
            } else
#line 208
            if (c == 9) {
#line 209
              goto __Cont;
            }
#line 210
            if (c == 35) {
              {
#line 213
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 214
                c = getc_unlocked(fp);
                }
#line 213
                if (c == -1) {
#line 213
                  goto while_break___0;
                } else
#line 213
                if (c == 10) {
#line 213
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 216
              if (c == -1) {
#line 217
                goto while_break;
              }
#line 218
              goto __Cont;
            }
            {
#line 220
            ungetc(c, fp);
#line 221
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1___0, buf2___0);
            }
#line 221
            if (tmp___4 < 2) {
#line 222
              goto while_break;
            }
            {
#line 223
            l1 = strlen((char const   *)(buf1___0));
#line 224
            l2 = strlen((char const   *)(buf2___0));
#line 225
            old_res_ptr = res_ptr;
            }
#line 226
            if (res_size == 0UL) {
              {
#line 228
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 229
              tmp___5 = malloc(res_size + 1UL);
#line 229
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 233
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 234
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 234
              res_ptr = (char *)tmp___6;
              }
            }
#line 236
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 239
              res_size = (size_t )0;
#line 240
              free((void *)old_res_ptr);
              }
#line 241
              goto while_break;
            }
            {
#line 243
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1___0));
#line 244
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2___0));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 246
          fclose(fp);
          }
#line 247
          if (res_size == 0UL) {
#line 248
            cp = "";
          } else {
#line 251
            *(res_ptr + res_size) = (char )'\000';
#line 252
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 257
      free((void *)file_name___0);
      }
    }
#line 381
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 384
  return (cp);
}
}
#line 396 "/home/khheo/project/benchmark/sed-4.5/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 407
  tmp = nl_langinfo(14);
#line 407
  codeset = (char const   *)tmp;
  }
#line 588
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 590
    codeset = "";
  }
  {
#line 593
  aliases = get_charset_aliases();
  }
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 593
    if (! ((int const   )*aliases != 0)) {
#line 593
      goto while_break;
    }
    {
#line 596
    tmp___3 = strcmp(codeset, aliases);
    }
#line 596
    if (tmp___3 == 0) {
      {
#line 599
      tmp___2 = strlen(aliases);
#line 599
      codeset = (aliases + tmp___2) + 1;
      }
#line 600
      goto while_break;
    } else
#line 596
    if ((int const   )*(aliases + 0) == 42) {
#line 596
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 599
        tmp___2 = strlen(aliases);
#line 599
        codeset = (aliases + tmp___2) + 1;
        }
#line 600
        goto while_break;
      }
    }
    {
#line 593
    tmp___0 = strlen(aliases);
#line 593
    aliases += tmp___0 + 1UL;
#line 593
    tmp___1 = strlen(aliases);
#line 593
    aliases += tmp___1 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 606
  if ((int const   )*(codeset + 0) == 0) {
#line 607
    codeset = "ASCII";
  }
#line 616
  return (codeset);
}
}
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 166 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 37 "/home/khheo/project/benchmark/sed-4.5/lib/hard-locale.c"
_Bool hard_locale(int category ) 
{ 
  _Bool hard ;
  char const   *p ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *locale ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 40
  hard = (_Bool)1;
#line 41
  tmp = setlocale(category, (char const   *)((void *)0));
#line 41
  p = (char const   *)tmp;
  }
#line 43
  if (p) {
#line 45
    if (1) {
      {
#line 47
      tmp___0 = strcmp(p, "C");
      }
#line 47
      if (tmp___0 == 0) {
#line 48
        hard = (_Bool)0;
      } else {
        {
#line 47
        tmp___1 = strcmp(p, "POSIX");
        }
#line 47
        if (tmp___1 == 0) {
#line 48
          hard = (_Bool)0;
        }
      }
    } else {
      {
#line 52
      tmp___2 = strdup(p);
#line 52
      locale = tmp___2;
      }
#line 53
      if (locale) {
        {
#line 58
        tmp___3 = setlocale(category, "C");
#line 58
        p = (char const   *)tmp___3;
        }
#line 58
        if (p) {
          {
#line 58
          tmp___4 = strcmp(p, (char const   *)locale);
          }
#line 58
          if (tmp___4 == 0) {
#line 62
            hard = (_Bool)0;
          } else {
#line 58
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 58
          tmp___5 = setlocale(category, "POSIX");
#line 58
          p = (char const   *)tmp___5;
          }
#line 58
          if (p) {
            {
#line 58
            tmp___6 = strcmp(p, (char const   *)locale);
            }
#line 58
            if (tmp___6 == 0) {
#line 62
              hard = (_Bool)0;
            }
          }
        }
        {
#line 65
        setlocale(category, (char const   *)locale);
#line 66
        free((void *)locale);
        }
      }
    }
  }
#line 71
  return (hard);
}
}
#line 29 "/home/khheo/project/benchmark/sed-4.5/lib/getprogname.h"
char const   *getprogname(void)  __attribute__((__pure__)) ;
#line 57 "/home/khheo/project/benchmark/sed-4.5/lib/getprogname.c"
char const   *getprogname(void)  __attribute__((__pure__)) ;
#line 57 "/home/khheo/project/benchmark/sed-4.5/lib/getprogname.c"
char const   *getprogname(void) 
{ 


  {
#line 62
  return ((char const   *)program_invocation_short_name);
}
}
#line 66 "/home/khheo/project/benchmark/sed-4.5/lib/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 302
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/sed-4.5/lib/get-permissions.c"
int get_permissions(char const   *name , int desc , mode_t mode , struct permission_context *ctx ) 
{ 


  {
  {
#line 36
  memset((void *)ctx, 0, sizeof(*ctx));
#line 37
  ctx->mode = mode;
  }
#line 289
  return (0);
}
}
#line 24 "/home/khheo/project/benchmark/sed-4.5/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 43 "/home/khheo/project/benchmark/sed-4.5/lib/dirname.h"
char *mdir_name(char const   *file ) ;
#line 45
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/sed-4.5/lib/dirname-lgpl.c"
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/sed-4.5/lib/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/home/khheo/project/benchmark/sed-4.5/lib/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
  }
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
  {
#line 81
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 51 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.h"
struct dfa *dfaalloc(void)  __attribute__((__malloc__)) ;
#line 71
void dfasyntax(struct dfa *dfa , struct localeinfo  const  *linfo , reg_syntax_t bits ,
               int dfaopts ) ;
#line 75
struct dfamust *dfamust(struct dfa  const  *d ) ;
#line 78
void dfamustfree(struct dfamust *dm ) ;
#line 83
void dfacomp(char const   *s , size_t len , struct dfa *d , _Bool searchflag ) ;
#line 97
char *dfaexec(struct dfa *d , char const   *begin , char *end , _Bool allow_nl , size_t *count ,
              _Bool *backref ) ;
#line 104
struct dfa *dfasuperset(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 107
_Bool dfaisfast(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 110
void dfafree(struct dfa *d ) ;
#line 118
void dfawarn(char const   *mesg ) ;
#line 123
void dfaerror(char const   *mesg ) ;
#line 108 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isalnum)(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isalpha)(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iscntrl)(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isdigit)(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) islower)(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isgraph)(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isprint)(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ispunct)(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isspace)(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isupper)(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isxdigit)(int  ) ;
#line 125
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 130
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isblank)(int  ) ;
#line 225 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 329
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool streq(char const   *a , char const   *b___0 ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = strcmp(a, b___0);
  }
#line 39
  return ((_Bool )(tmp == 0));
}
}
#line 42 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool isasciidigit(char c ) 
{ 
  int tmp ;

  {
#line 45
  if (48 <= (int )c) {
#line 45
    if ((int )c <= 57) {
#line 45
      tmp = 1;
    } else {
#line 45
      tmp = 0;
    }
  } else {
#line 45
    tmp = 0;
  }
#line 45
  return ((_Bool )tmp);
}
}
#line 288 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wctob)(wint_t __c ) ;
#line 301
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcrtomb)(char * __restrict  __s ,
                                                                                 wchar_t __wc ,
                                                                                 mbstate_t * __restrict  __ps ) ;
#line 29 "/home/khheo/project/benchmark/sed-4.5/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 104 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static unsigned long const   CHARCLASS_WORD_MASK  =    (charclass_word const   )(((1UL << 63) << 1) - 1UL);
#line 119 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static unsigned char to_uchar(char ch ) 
{ 


  {
#line 122
  return ((unsigned char )ch);
}
}
#line 160 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static int newline_constraint(int constraint ) 
{ 


  {
#line 163
  return ((constraint >> 6) & 7);
}
}
#line 165 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static int letter_constraint(int constraint ) 
{ 


  {
#line 168
  return ((constraint >> 3) & 7);
}
}
#line 170 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static int other_constraint(int constraint ) 
{ 


  {
#line 173
  return (constraint & 7);
}
}
#line 176 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool succeeds_in_context(int constraint , int prev , int curr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 179
  if (curr & 1) {
    {
#line 179
    tmp = other_constraint(constraint);
#line 179
    tmp___0 = tmp;
    }
  } else {
#line 179
    tmp___0 = 0;
  }
#line 179
  if (curr & 2) {
    {
#line 179
    tmp___1 = letter_constraint(constraint);
#line 179
    tmp___2 = tmp___1;
    }
  } else {
#line 179
    tmp___2 = 0;
  }
#line 179
  if (curr & 4) {
    {
#line 179
    tmp___3 = newline_constraint(constraint);
#line 179
    tmp___4 = tmp___3;
    }
  } else {
#line 179
    tmp___4 = 0;
  }
#line 179
  if (((tmp___0 | tmp___2) | tmp___4) & prev) {
#line 179
    tmp___5 = 1;
  } else {
#line 179
    tmp___5 = 0;
  }
#line 179
  return ((_Bool )tmp___5);
}
}
#line 186 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool prev_newline_dependent(int constraint ) 
{ 


  {
#line 189
  return ((_Bool )(((constraint ^ (constraint >> 2)) & 73) != 0));
}
}
#line 191 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool prev_letter_dependent(int constraint ) 
{ 


  {
#line 194
  return ((_Bool )(((constraint ^ (constraint >> 1)) & 73) != 0));
}
}
#line 217 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static long const   TOKEN_MAX  =    (ptrdiff_t const   )9223372036854775807L;
#line 574 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool accepting(state_num s , struct dfa  const  *r ) 
{ 


  {
#line 577
  return ((_Bool )((int )(r->states + s)->constraint != 0));
}
}
#line 581 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool accepts_in_context(int prev , int curr , state_num state , struct dfa  const  *dfa ) 
{ 
  _Bool tmp ;

  {
  {
#line 584
  tmp = succeeds_in_context((int )(dfa->states + state)->constraint, prev, curr);
  }
#line 584
  return (tmp);
}
}
#line 587
static void regexp(struct dfa *dfa ) ;
#line 606 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static size_t mbs_to_wchar(wint_t *pwc , char const   *s , size_t n , struct dfa *d ) 
{ 
  unsigned char uc ;
  wint_t wc ;
  wchar_t wch ;
  size_t nbytes ;
  size_t tmp ;

  {
#line 609
  uc = (unsigned char )*(s + 0);
#line 610
  wc = d->localeinfo.sbctowc[uc];
#line 612
  if (wc == 4294967295U) {
    {
#line 615
    tmp = rpl_mbrtowc(& wch, s, n, & d->mbs);
#line 615
    nbytes = tmp;
    }
#line 616
    if (0UL < nbytes) {
#line 616
      if (nbytes < 0xfffffffffffffffeUL) {
#line 618
        *pwc = (wint_t )wch;
#line 619
        return (nbytes);
      }
    }
    {
#line 621
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
  }
#line 624
  *pwc = wc;
#line 625
  return ((size_t )1);
}
}
#line 707 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool tstbit(unsigned int b___0 , charclass const   *c ) 
{ 


  {
#line 710
  return ((_Bool )((c->w[b___0 / 64U] >> b___0 % 64U) & 1UL));
}
}
#line 713 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void setbit(unsigned int b___0 , charclass *c ) 
{ 
  charclass_word one ;

  {
#line 716
  one = (charclass_word )1;
#line 717
  c->w[b___0 / 64U] |= one << b___0 % 64U;
#line 718
  return;
}
}
#line 720 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void clrbit(unsigned int b___0 , charclass *c ) 
{ 
  charclass_word one ;

  {
#line 723
  one = (charclass_word )1;
#line 724
  c->w[b___0 / 64U] &= ~ (one << b___0 % 64U);
#line 725
  return;
}
}
#line 727 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void zeroset(charclass *s ) 
{ 


  {
  {
#line 730
  memset((void *)s, 0, sizeof(*s));
  }
#line 731
  return;
}
}
#line 733 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void fillset(charclass *s ) 
{ 
  int i ;

  {
#line 736
  i = 0;
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (! (i < 4)) {
#line 736
      goto while_break;
    }
#line 737
    s->w[i] = (charclass_word )CHARCLASS_WORD_MASK;
#line 736
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 738
  return;
}
}
#line 740 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void notset(charclass *s ) 
{ 
  int i ;

  {
#line 743
  i = 0;
  {
#line 743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 743
    if (! (i < 4)) {
#line 743
      goto while_break;
    }
#line 744
    s->w[i] = (charclass_word )(CHARCLASS_WORD_MASK & (unsigned long const   )(~ s->w[i]));
#line 743
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 745
  return;
}
}
#line 747 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool equal(charclass const   *s1 , charclass const   *s2 ) 
{ 
  charclass_word w ;
  int i ;

  {
#line 750
  w = (charclass_word )0;
#line 751
  i = 0;
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 751
    if (! (i < 4)) {
#line 751
      goto while_break;
    }
#line 752
    w |= s1->w[i] ^ s2->w[i];
#line 751
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 753
  return ((_Bool )(w == 0UL));
}
}
#line 756 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool emptyset(charclass const   *s ) 
{ 
  charclass_word w ;
  int i ;

  {
#line 759
  w = (charclass_word )0;
#line 760
  i = 0;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! (i < 4)) {
#line 760
      goto while_break;
    }
#line 761
    w |= s->w[i];
#line 760
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 762
  return ((_Bool )(w == 0UL));
}
}
#line 781 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void *xpalloc(void *pa , ptrdiff_t *nitems , ptrdiff_t nitems_incr_min , ptrdiff_t nitems_max ,
                     ptrdiff_t item_size ) 
{ 
  ptrdiff_t n0 ;
  ptrdiff_t n ;
  ptrdiff_t nbytes ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  ptrdiff_t adjusted_nbytes ;
  int tmp___217 ;
  unsigned long tmp___218 ;
  int tmp___224 ;
  int tmp___225 ;
  int tmp___226 ;
  int tmp___227 ;
  int tmp___228 ;
  int tmp___229 ;
  int tmp___235 ;
  int tmp___236 ;
  int tmp___237 ;
  int tmp___238 ;
  int tmp___239 ;
  int tmp___240 ;
  int tmp___241 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  int tmp___251 ;
  int tmp___252 ;
  int tmp___258 ;
  int tmp___259 ;
  int tmp___260 ;
  int tmp___261 ;
  int tmp___262 ;
  int tmp___263 ;
  int tmp___264 ;
  int tmp___270 ;
  int tmp___271 ;
  int tmp___272 ;
  int tmp___273 ;
  int tmp___274 ;
  int tmp___275 ;
  int tmp___281 ;
  int tmp___282 ;
  int tmp___283 ;
  int tmp___284 ;
  int tmp___285 ;
  int tmp___286 ;
  int tmp___287 ;
  int tmp___293 ;
  int tmp___294 ;
  int tmp___295 ;
  int tmp___296 ;
  int tmp___297 ;
  int tmp___298 ;
  int tmp___304 ;
  int tmp___305 ;
  int tmp___306 ;
  int tmp___307 ;
  int tmp___308 ;
  int tmp___309 ;
  int tmp___310 ;
  int tmp___316 ;
  int tmp___317 ;
  int tmp___318 ;
  int tmp___319 ;
  int tmp___320 ;
  int tmp___321 ;
  int tmp___327 ;
  int tmp___328 ;
  int tmp___329 ;
  int tmp___330 ;
  int tmp___331 ;
  int tmp___332 ;
  int tmp___333 ;
  int tmp___334 ;
  int tmp___335 ;
  int tmp___336 ;
  int tmp___337 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___344 ;
  int tmp___345 ;
  int tmp___346 ;
  int tmp___351 ;
  int tmp___352 ;
  int tmp___353 ;
  int tmp___354 ;
  int tmp___355 ;
  int tmp___356 ;
  int tmp___361 ;
  int tmp___362 ;
  int tmp___363 ;
  int tmp___364 ;
  int tmp___365 ;
  int tmp___370 ;
  int tmp___371 ;
  int tmp___372 ;
  int tmp___373 ;
  int tmp___374 ;
  int tmp___375 ;
  int tmp___380 ;
  int tmp___381 ;
  int tmp___382 ;
  int tmp___383 ;
  int tmp___384 ;
  int tmp___389 ;
  int tmp___390 ;
  int tmp___391 ;
  int tmp___392 ;
  int tmp___393 ;
  int tmp___394 ;
  int tmp___399 ;
  int tmp___400 ;
  int tmp___401 ;
  int tmp___402 ;
  int tmp___403 ;
  int tmp___408 ;
  int tmp___409 ;
  int tmp___410 ;
  int tmp___411 ;
  int tmp___412 ;
  int tmp___413 ;
  int tmp___418 ;
  int tmp___419 ;
  int tmp___420 ;
  int tmp___421 ;
  int tmp___422 ;
  int tmp___427 ;
  int tmp___428 ;
  int tmp___429 ;
  int tmp___430 ;
  int tmp___431 ;
  int tmp___432 ;
  int tmp___433 ;
  int tmp___434 ;
  int tmp___435 ;
  int tmp___436 ;
  int tmp___442 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___445 ;
  int tmp___446 ;
  int tmp___447 ;
  int tmp___453 ;
  int tmp___454 ;
  int tmp___455 ;
  int tmp___456 ;
  int tmp___457 ;
  int tmp___458 ;
  int tmp___459 ;
  int tmp___465 ;
  int tmp___466 ;
  int tmp___467 ;
  int tmp___468 ;
  int tmp___469 ;
  int tmp___470 ;
  int tmp___476 ;
  int tmp___477 ;
  int tmp___478 ;
  int tmp___479 ;
  int tmp___480 ;
  int tmp___481 ;
  int tmp___482 ;
  int tmp___488 ;
  int tmp___489 ;
  int tmp___490 ;
  int tmp___491 ;
  int tmp___492 ;
  int tmp___493 ;
  int tmp___499 ;
  int tmp___500 ;
  int tmp___501 ;
  int tmp___502 ;
  int tmp___503 ;
  int tmp___504 ;
  int tmp___505 ;
  int tmp___511 ;
  int tmp___512 ;
  int tmp___513 ;
  int tmp___514 ;
  int tmp___515 ;
  int tmp___516 ;
  int tmp___522 ;
  int tmp___523 ;
  int tmp___524 ;
  int tmp___525 ;
  int tmp___526 ;
  int tmp___527 ;
  int tmp___528 ;
  int tmp___534 ;
  int tmp___535 ;
  int tmp___536 ;
  int tmp___537 ;
  int tmp___538 ;
  int tmp___539 ;
  int tmp___545 ;
  int tmp___546 ;
  int tmp___547 ;
  int tmp___548 ;
  int tmp___549 ;
  int tmp___550 ;
  int tmp___551 ;
  int tmp___552 ;
  int tmp___553 ;
  int tmp___554 ;
  int tmp___555 ;

  {
#line 785
  n0 = *nitems;
#line 798
  if (sizeof(n) == sizeof(signed char )) {
#line 798
    if (sizeof(n0 + (n0 >> 1)) < sizeof(signed char )) {
#line 798
      if (~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 798
        if ((int )((signed char )(n0 >> 1)) < 0) {
#line 798
          tmp___4 = (int )((signed char )n0) < ~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )(n0 >> 1));
        } else {
#line 798
          tmp___4 = (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )(n0 >> 1)) < (int )((signed char )n0);
        }
#line 798
        tmp___7 = tmp___4;
      } else {
#line 798
        if ((int )((signed char )n0) < 0) {
#line 798
          tmp___6 = (int )((signed char )(n0 >> 1)) <= (int )((signed char )n0) + (int )((signed char )(n0 >> 1));
        } else {
#line 798
          if ((int )((signed char )(n0 >> 1)) < 0) {
#line 798
            tmp___5 = (int )((signed char )n0) <= (int )((signed char )n0) + (int )((signed char )(n0 >> 1));
          } else {
#line 798
            tmp___5 = (int )((signed char )n0) + (int )((signed char )(n0 >> 1)) < (int )((signed char )(n0 >> 1));
          }
#line 798
          tmp___6 = tmp___5;
        }
#line 798
        tmp___7 = tmp___6;
      }
#line 798
      if (tmp___7) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )(n0 >> 1))));
#line 798
        tmp___3 = 1;
      } else
#line 798
      if ((int )((signed char )n0) + (int )((signed char )(n0 >> 1)) < -128) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )(n0 >> 1))));
#line 798
        tmp___3 = 1;
      } else
#line 798
      if (127 < (int )((signed char )n0) + (int )((signed char )(n0 >> 1))) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )(n0 >> 1))));
#line 798
        tmp___3 = 1;
      } else {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )(n0 >> 1))));
#line 798
        tmp___3 = 0;
      }
#line 798
      tmp___17 = tmp___3;
    } else {
#line 798
      if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
        if (n0 >> 1 < 0L) {
#line 798
          tmp___13 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
        } else {
#line 798
          tmp___13 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
        }
#line 798
        tmp___16 = tmp___13;
      } else {
#line 798
        if (n0 < 0L) {
#line 798
          tmp___15 = n0 >> 1 <= n0 + (n0 >> 1);
        } else {
#line 798
          if (n0 >> 1 < 0L) {
#line 798
            tmp___14 = n0 <= n0 + (n0 >> 1);
          } else {
#line 798
            tmp___14 = n0 + (n0 >> 1) < n0 >> 1;
          }
#line 798
          tmp___15 = tmp___14;
        }
#line 798
        tmp___16 = tmp___15;
      }
#line 798
      if (tmp___16) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
        tmp___12 = 1;
      } else
#line 798
      if (n0 + (n0 >> 1) < -128L) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
        tmp___12 = 1;
      } else
#line 798
      if (127L < n0 + (n0 >> 1)) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
        tmp___12 = 1;
      } else {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
        tmp___12 = 0;
      }
#line 798
      tmp___17 = tmp___12;
    }
#line 798
    tmp___97 = tmp___17;
  } else {
#line 798
    if (sizeof(n) == sizeof(short )) {
#line 798
      if (sizeof(n0 + (n0 >> 1)) < sizeof(short )) {
#line 798
        if (~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 798
          if ((int )((short )(n0 >> 1)) < 0) {
#line 798
            tmp___23 = (int )((short )n0) < ~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )(n0 >> 1));
          } else {
#line 798
            tmp___23 = (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )(n0 >> 1)) < (int )((short )n0);
          }
#line 798
          tmp___26 = tmp___23;
        } else {
#line 798
          if ((int )((short )n0) < 0) {
#line 798
            tmp___25 = (int )((short )(n0 >> 1)) <= (int )((short )n0) + (int )((short )(n0 >> 1));
          } else {
#line 798
            if ((int )((short )(n0 >> 1)) < 0) {
#line 798
              tmp___24 = (int )((short )n0) <= (int )((short )n0) + (int )((short )(n0 >> 1));
            } else {
#line 798
              tmp___24 = (int )((short )n0) + (int )((short )(n0 >> 1)) < (int )((short )(n0 >> 1));
            }
#line 798
            tmp___25 = tmp___24;
          }
#line 798
          tmp___26 = tmp___25;
        }
#line 798
        if (tmp___26) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )(n0 >> 1))));
#line 798
          tmp___22 = 1;
        } else
#line 798
        if ((int )((short )n0) + (int )((short )(n0 >> 1)) < -32768) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )(n0 >> 1))));
#line 798
          tmp___22 = 1;
        } else
#line 798
        if (32767 < (int )((short )n0) + (int )((short )(n0 >> 1))) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )(n0 >> 1))));
#line 798
          tmp___22 = 1;
        } else {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )(n0 >> 1))));
#line 798
          tmp___22 = 0;
        }
#line 798
        tmp___36 = tmp___22;
      } else {
#line 798
        if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
          if (n0 >> 1 < 0L) {
#line 798
            tmp___32 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
          } else {
#line 798
            tmp___32 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
          }
#line 798
          tmp___35 = tmp___32;
        } else {
#line 798
          if (n0 < 0L) {
#line 798
            tmp___34 = n0 >> 1 <= n0 + (n0 >> 1);
          } else {
#line 798
            if (n0 >> 1 < 0L) {
#line 798
              tmp___33 = n0 <= n0 + (n0 >> 1);
            } else {
#line 798
              tmp___33 = n0 + (n0 >> 1) < n0 >> 1;
            }
#line 798
            tmp___34 = tmp___33;
          }
#line 798
          tmp___35 = tmp___34;
        }
#line 798
        if (tmp___35) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
          tmp___31 = 1;
        } else
#line 798
        if (n0 + (n0 >> 1) < -32768L) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
          tmp___31 = 1;
        } else
#line 798
        if (32767L < n0 + (n0 >> 1)) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
          tmp___31 = 1;
        } else {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
          tmp___31 = 0;
        }
#line 798
        tmp___36 = tmp___31;
      }
#line 798
      tmp___96 = tmp___36;
    } else {
#line 798
      if (sizeof(n) == sizeof(int )) {
#line 798
        if (sizeof(n0 + (n0 >> 1)) < sizeof(int )) {
#line 798
          if (~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 798
            if ((int )(n0 >> 1) < 0) {
#line 798
              tmp___42 = (int )n0 < ~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )(n0 >> 1);
            } else {
#line 798
              tmp___42 = (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )(n0 >> 1) < (int )n0;
            }
#line 798
            tmp___45 = tmp___42;
          } else {
#line 798
            if ((int )n0 < 0) {
#line 798
              tmp___44 = (int )(n0 >> 1) <= (int )n0 + (int )(n0 >> 1);
            } else {
#line 798
              if ((int )(n0 >> 1) < 0) {
#line 798
                tmp___43 = (int )n0 <= (int )n0 + (int )(n0 >> 1);
              } else {
#line 798
                tmp___43 = (int )n0 + (int )(n0 >> 1) < (int )(n0 >> 1);
              }
#line 798
              tmp___44 = tmp___43;
            }
#line 798
            tmp___45 = tmp___44;
          }
#line 798
          if (tmp___45) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
#line 798
            tmp___41 = 1;
          } else
#line 798
          if ((int )n0 + (int )(n0 >> 1) < (-0x7FFFFFFF-1)) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
#line 798
            tmp___41 = 1;
          } else
#line 798
          if (2147483647 < (int )n0 + (int )(n0 >> 1)) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
#line 798
            tmp___41 = 1;
          } else {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
#line 798
            tmp___41 = 0;
          }
#line 798
          tmp___55 = tmp___41;
        } else {
#line 798
          if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
            if (n0 >> 1 < 0L) {
#line 798
              tmp___51 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
            } else {
#line 798
              tmp___51 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
            }
#line 798
            tmp___54 = tmp___51;
          } else {
#line 798
            if (n0 < 0L) {
#line 798
              tmp___53 = n0 >> 1 <= n0 + (n0 >> 1);
            } else {
#line 798
              if (n0 >> 1 < 0L) {
#line 798
                tmp___52 = n0 <= n0 + (n0 >> 1);
              } else {
#line 798
                tmp___52 = n0 + (n0 >> 1) < n0 >> 1;
              }
#line 798
              tmp___53 = tmp___52;
            }
#line 798
            tmp___54 = tmp___53;
          }
#line 798
          if (tmp___54) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
            tmp___50 = 1;
          } else
#line 798
          if (n0 + (n0 >> 1) < (-0x7FFFFFFF-1)) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
            tmp___50 = 1;
          } else
#line 798
          if (2147483647L < n0 + (n0 >> 1)) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
            tmp___50 = 1;
          } else {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
            tmp___50 = 0;
          }
#line 798
          tmp___55 = tmp___50;
        }
#line 798
        tmp___95 = tmp___55;
      } else {
#line 798
        if (sizeof(n) == sizeof(long )) {
#line 798
          if (sizeof(n0 + (n0 >> 1)) < sizeof(long )) {
#line 798
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
              if (n0 >> 1 < 0L) {
#line 798
                tmp___61 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 798
                tmp___61 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 798
              tmp___64 = tmp___61;
            } else {
#line 798
              if (n0 < 0L) {
#line 798
                tmp___63 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 798
                if (n0 >> 1 < 0L) {
#line 798
                  tmp___62 = n0 <= n0 + (n0 >> 1);
                } else {
#line 798
                  tmp___62 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 798
                tmp___63 = tmp___62;
              }
#line 798
              tmp___64 = tmp___63;
            }
#line 798
            if (tmp___64) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___60 = 1;
            } else
#line 798
            if (n0 + (n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___60 = 1;
            } else
#line 798
            if (9223372036854775807L < n0 + (n0 >> 1)) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___60 = 1;
            } else {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___60 = 0;
            }
#line 798
            tmp___74 = tmp___60;
          } else {
#line 798
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
              if (n0 >> 1 < 0L) {
#line 798
                tmp___70 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 798
                tmp___70 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 798
              tmp___73 = tmp___70;
            } else {
#line 798
              if (n0 < 0L) {
#line 798
                tmp___72 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 798
                if (n0 >> 1 < 0L) {
#line 798
                  tmp___71 = n0 <= n0 + (n0 >> 1);
                } else {
#line 798
                  tmp___71 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 798
                tmp___72 = tmp___71;
              }
#line 798
              tmp___73 = tmp___72;
            }
#line 798
            if (tmp___73) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___69 = 1;
            } else
#line 798
            if (n0 + (n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___69 = 1;
            } else
#line 798
            if (9223372036854775807L < n0 + (n0 >> 1)) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___69 = 1;
            } else {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___69 = 0;
            }
#line 798
            tmp___74 = tmp___69;
          }
#line 798
          tmp___94 = tmp___74;
        } else {
#line 798
          if (sizeof(n0 + (n0 >> 1)) < sizeof(long long )) {
#line 798
            if (~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 798
              if ((long long )(n0 >> 1) < 0LL) {
#line 798
                tmp___80 = (long long )n0 < ~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )(n0 >> 1);
              } else {
#line 798
                tmp___80 = (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )(n0 >> 1) < (long long )n0;
              }
#line 798
              tmp___83 = tmp___80;
            } else {
#line 798
              if ((long long )n0 < 0LL) {
#line 798
                tmp___82 = (long long )(n0 >> 1) <= (long long )n0 + (long long )(n0 >> 1);
              } else {
#line 798
                if ((long long )(n0 >> 1) < 0LL) {
#line 798
                  tmp___81 = (long long )n0 <= (long long )n0 + (long long )(n0 >> 1);
                } else {
#line 798
                  tmp___81 = (long long )n0 + (long long )(n0 >> 1) < (long long )(n0 >> 1);
                }
#line 798
                tmp___82 = tmp___81;
              }
#line 798
              tmp___83 = tmp___82;
            }
#line 798
            if (tmp___83) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
#line 798
              tmp___79 = 1;
            } else
#line 798
            if ((long long )n0 + (long long )(n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
#line 798
              tmp___79 = 1;
            } else
#line 798
            if (9223372036854775807LL < (long long )n0 + (long long )(n0 >> 1)) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
#line 798
              tmp___79 = 1;
            } else {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
#line 798
              tmp___79 = 0;
            }
#line 798
            tmp___93 = tmp___79;
          } else {
#line 798
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
              if (n0 >> 1 < 0L) {
#line 798
                tmp___89 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 798
                tmp___89 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 798
              tmp___92 = tmp___89;
            } else {
#line 798
              if (n0 < 0L) {
#line 798
                tmp___91 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 798
                if (n0 >> 1 < 0L) {
#line 798
                  tmp___90 = n0 <= n0 + (n0 >> 1);
                } else {
#line 798
                  tmp___90 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 798
                tmp___91 = tmp___90;
              }
#line 798
              tmp___92 = tmp___91;
            }
#line 798
            if (tmp___92) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
#line 798
              tmp___88 = 1;
            } else
#line 798
            if ((long long )(n0 + (n0 >> 1)) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
#line 798
              tmp___88 = 1;
            } else
#line 798
            if (9223372036854775807LL < (long long )(n0 + (n0 >> 1))) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
#line 798
              tmp___88 = 1;
            } else {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
#line 798
              tmp___88 = 0;
            }
#line 798
            tmp___93 = tmp___88;
          }
#line 798
          tmp___94 = tmp___93;
        }
#line 798
        tmp___95 = tmp___94;
      }
#line 798
      tmp___96 = tmp___95;
    }
#line 798
    tmp___97 = tmp___96;
  }
#line 798
  if (tmp___97) {
#line 799
    n = 9223372036854775807L;
  }
#line 800
  if (0L <= nitems_max) {
#line 800
    if (nitems_max < n) {
#line 801
      n = nitems_max;
    }
  }
#line 803
  if (sizeof(nbytes) == sizeof(signed char )) {
#line 803
    if (sizeof(n * item_size) < sizeof(signed char )) {
#line 803
      if (~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 803
        if ((int )((signed char )n) < 0) {
#line 803
          if (0 < (int )((signed char )item_size)) {
#line 803
            nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
            tmp___224 = 1;
          } else {
#line 803
            goto _L___20;
          }
        } else
        _L___20: /* CIL Label */ 
#line 803
        if ((int )((signed char )item_size) < 0) {
#line 803
          if (0 < (int )((signed char )n)) {
#line 803
            nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
            tmp___224 = 1;
          } else {
#line 803
            goto _L___19;
          }
        } else {
#line 803
          goto _L___19;
        }
      } else {
        _L___19: /* CIL Label */ 
#line 803
        if ((int )((signed char )item_size) < 0) {
#line 803
          if ((int )((signed char )n) < 0) {
#line 803
            tmp___226 = (int )((signed char )n) < (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
          } else {
#line 803
            if ((int )((signed char )item_size) == -1) {
#line 803
              tmp___225 = 0;
            } else {
#line 803
              tmp___225 = ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
            }
#line 803
            tmp___226 = tmp___225;
          }
#line 803
          tmp___229 = tmp___226;
        } else {
#line 803
          if ((int )((signed char )item_size) == 0) {
#line 803
            tmp___228 = 0;
          } else {
#line 803
            if ((int )((signed char )n) < 0) {
#line 803
              tmp___227 = (int )((signed char )n) < ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
            } else {
#line 803
              tmp___227 = (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
            }
#line 803
            tmp___228 = tmp___227;
          }
#line 803
          tmp___229 = tmp___228;
        }
#line 803
        if (tmp___229) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
          tmp___224 = 1;
        } else
#line 803
        if ((int )((signed char )n) * (int )((signed char )item_size) < -128) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
          tmp___224 = 1;
        } else
#line 803
        if (127 < (int )((signed char )n) * (int )((signed char )item_size)) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
          tmp___224 = 1;
        } else {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
          tmp___224 = 0;
        }
      }
#line 803
      tmp___241 = tmp___224;
    } else {
#line 803
      if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
        if (n < 0L) {
#line 803
          if (0L < item_size) {
#line 803
            nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___235 = 1;
          } else {
#line 803
            goto _L___22;
          }
        } else
        _L___22: /* CIL Label */ 
#line 803
        if (item_size < 0L) {
#line 803
          if (0L < n) {
#line 803
            nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___235 = 1;
          } else {
#line 803
            goto _L___21;
          }
        } else {
#line 803
          goto _L___21;
        }
      } else {
        _L___21: /* CIL Label */ 
#line 803
        if (item_size < 0L) {
#line 803
          if (n < 0L) {
#line 803
            tmp___237 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
          } else {
#line 803
            if (item_size == -1L) {
#line 803
              tmp___236 = 0;
            } else {
#line 803
              tmp___236 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
            }
#line 803
            tmp___237 = tmp___236;
          }
#line 803
          tmp___240 = tmp___237;
        } else {
#line 803
          if (item_size == 0L) {
#line 803
            tmp___239 = 0;
          } else {
#line 803
            if (n < 0L) {
#line 803
              tmp___238 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
            } else {
#line 803
              tmp___238 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
            }
#line 803
            tmp___239 = tmp___238;
          }
#line 803
          tmp___240 = tmp___239;
        }
#line 803
        if (tmp___240) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
          tmp___235 = 1;
        } else
#line 803
        if (n * item_size < -128L) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
          tmp___235 = 1;
        } else
#line 803
        if (127L < n * item_size) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
          tmp___235 = 1;
        } else {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
          tmp___235 = 0;
        }
      }
#line 803
      tmp___241 = tmp___235;
    }
#line 803
    tmp___337 = tmp___241;
  } else {
#line 803
    if (sizeof(nbytes) == sizeof(short )) {
#line 803
      if (sizeof(n * item_size) < sizeof(short )) {
#line 803
        if (~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 803
          if ((int )((short )n) < 0) {
#line 803
            if (0 < (int )((short )item_size)) {
#line 803
              nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
              tmp___247 = 1;
            } else {
#line 803
              goto _L___24;
            }
          } else
          _L___24: /* CIL Label */ 
#line 803
          if ((int )((short )item_size) < 0) {
#line 803
            if (0 < (int )((short )n)) {
#line 803
              nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
              tmp___247 = 1;
            } else {
#line 803
              goto _L___23;
            }
          } else {
#line 803
            goto _L___23;
          }
        } else {
          _L___23: /* CIL Label */ 
#line 803
          if ((int )((short )item_size) < 0) {
#line 803
            if ((int )((short )n) < 0) {
#line 803
              tmp___249 = (int )((short )n) < (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
            } else {
#line 803
              if ((int )((short )item_size) == -1) {
#line 803
                tmp___248 = 0;
              } else {
#line 803
                tmp___248 = ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
              }
#line 803
              tmp___249 = tmp___248;
            }
#line 803
            tmp___252 = tmp___249;
          } else {
#line 803
            if ((int )((short )item_size) == 0) {
#line 803
              tmp___251 = 0;
            } else {
#line 803
              if ((int )((short )n) < 0) {
#line 803
                tmp___250 = (int )((short )n) < ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
              } else {
#line 803
                tmp___250 = (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
              }
#line 803
              tmp___251 = tmp___250;
            }
#line 803
            tmp___252 = tmp___251;
          }
#line 803
          if (tmp___252) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
            tmp___247 = 1;
          } else
#line 803
          if ((int )((short )n) * (int )((short )item_size) < -32768) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
            tmp___247 = 1;
          } else
#line 803
          if (32767 < (int )((short )n) * (int )((short )item_size)) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
            tmp___247 = 1;
          } else {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
            tmp___247 = 0;
          }
        }
#line 803
        tmp___264 = tmp___247;
      } else {
#line 803
        if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
          if (n < 0L) {
#line 803
            if (0L < item_size) {
#line 803
              nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___258 = 1;
            } else {
#line 803
              goto _L___26;
            }
          } else
          _L___26: /* CIL Label */ 
#line 803
          if (item_size < 0L) {
#line 803
            if (0L < n) {
#line 803
              nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___258 = 1;
            } else {
#line 803
              goto _L___25;
            }
          } else {
#line 803
            goto _L___25;
          }
        } else {
          _L___25: /* CIL Label */ 
#line 803
          if (item_size < 0L) {
#line 803
            if (n < 0L) {
#line 803
              tmp___260 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
            } else {
#line 803
              if (item_size == -1L) {
#line 803
                tmp___259 = 0;
              } else {
#line 803
                tmp___259 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
              }
#line 803
              tmp___260 = tmp___259;
            }
#line 803
            tmp___263 = tmp___260;
          } else {
#line 803
            if (item_size == 0L) {
#line 803
              tmp___262 = 0;
            } else {
#line 803
              if (n < 0L) {
#line 803
                tmp___261 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 803
                tmp___261 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
              }
#line 803
              tmp___262 = tmp___261;
            }
#line 803
            tmp___263 = tmp___262;
          }
#line 803
          if (tmp___263) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___258 = 1;
          } else
#line 803
          if (n * item_size < -32768L) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___258 = 1;
          } else
#line 803
          if (32767L < n * item_size) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___258 = 1;
          } else {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___258 = 0;
          }
        }
#line 803
        tmp___264 = tmp___258;
      }
#line 803
      tmp___336 = tmp___264;
    } else {
#line 803
      if (sizeof(nbytes) == sizeof(int )) {
#line 803
        if (sizeof(n * item_size) < sizeof(int )) {
#line 803
          if (~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 803
            if ((int )n < 0) {
#line 803
              if (0 < (int )item_size) {
#line 803
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
                tmp___270 = 1;
              } else {
#line 803
                goto _L___28;
              }
            } else
            _L___28: /* CIL Label */ 
#line 803
            if ((int )item_size < 0) {
#line 803
              if (0 < (int )n) {
#line 803
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
                tmp___270 = 1;
              } else {
#line 803
                goto _L___27;
              }
            } else {
#line 803
              goto _L___27;
            }
          } else {
            _L___27: /* CIL Label */ 
#line 803
            if ((int )item_size < 0) {
#line 803
              if ((int )n < 0) {
#line 803
                tmp___272 = (int )n < (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
              } else {
#line 803
                if ((int )item_size == -1) {
#line 803
                  tmp___271 = 0;
                } else {
#line 803
                  tmp___271 = ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                }
#line 803
                tmp___272 = tmp___271;
              }
#line 803
              tmp___275 = tmp___272;
            } else {
#line 803
              if ((int )item_size == 0) {
#line 803
                tmp___274 = 0;
              } else {
#line 803
                if ((int )n < 0) {
#line 803
                  tmp___273 = (int )n < ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                } else {
#line 803
                  tmp___273 = (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                }
#line 803
                tmp___274 = tmp___273;
              }
#line 803
              tmp___275 = tmp___274;
            }
#line 803
            if (tmp___275) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
              tmp___270 = 1;
            } else
#line 803
            if ((int )n * (int )item_size < (-0x7FFFFFFF-1)) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
              tmp___270 = 1;
            } else
#line 803
            if (2147483647 < (int )n * (int )item_size) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
              tmp___270 = 1;
            } else {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
              tmp___270 = 0;
            }
          }
#line 803
          tmp___287 = tmp___270;
        } else {
#line 803
          if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
            if (n < 0L) {
#line 803
              if (0L < item_size) {
#line 803
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
                tmp___281 = 1;
              } else {
#line 803
                goto _L___30;
              }
            } else
            _L___30: /* CIL Label */ 
#line 803
            if (item_size < 0L) {
#line 803
              if (0L < n) {
#line 803
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
                tmp___281 = 1;
              } else {
#line 803
                goto _L___29;
              }
            } else {
#line 803
              goto _L___29;
            }
          } else {
            _L___29: /* CIL Label */ 
#line 803
            if (item_size < 0L) {
#line 803
              if (n < 0L) {
#line 803
                tmp___283 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 803
                if (item_size == -1L) {
#line 803
                  tmp___282 = 0;
                } else {
#line 803
                  tmp___282 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 803
                tmp___283 = tmp___282;
              }
#line 803
              tmp___286 = tmp___283;
            } else {
#line 803
              if (item_size == 0L) {
#line 803
                tmp___285 = 0;
              } else {
#line 803
                if (n < 0L) {
#line 803
                  tmp___284 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 803
                  tmp___284 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 803
                tmp___285 = tmp___284;
              }
#line 803
              tmp___286 = tmp___285;
            }
#line 803
            if (tmp___286) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___281 = 1;
            } else
#line 803
            if (n * item_size < (-0x7FFFFFFF-1)) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___281 = 1;
            } else
#line 803
            if (2147483647L < n * item_size) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___281 = 1;
            } else {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___281 = 0;
            }
          }
#line 803
          tmp___287 = tmp___281;
        }
#line 803
        tmp___335 = tmp___287;
      } else {
#line 803
        if (sizeof(nbytes) == sizeof(long )) {
#line 803
          if (sizeof(n * item_size) < sizeof(long )) {
#line 803
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
              if (n < 0L) {
#line 803
                if (0L < item_size) {
#line 803
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                  tmp___293 = 1;
                } else {
#line 803
                  goto _L___32;
                }
              } else
              _L___32: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (0L < n) {
#line 803
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                  tmp___293 = 1;
                } else {
#line 803
                  goto _L___31;
                }
              } else {
#line 803
                goto _L___31;
              }
            } else {
              _L___31: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (n < 0L) {
#line 803
                  tmp___295 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 803
                  if (item_size == -1L) {
#line 803
                    tmp___294 = 0;
                  } else {
#line 803
                    tmp___294 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___295 = tmp___294;
                }
#line 803
                tmp___298 = tmp___295;
              } else {
#line 803
                if (item_size == 0L) {
#line 803
                  tmp___297 = 0;
                } else {
#line 803
                  if (n < 0L) {
#line 803
                    tmp___296 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 803
                    tmp___296 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___297 = tmp___296;
                }
#line 803
                tmp___298 = tmp___297;
              }
#line 803
              if (tmp___298) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___293 = 1;
              } else
#line 803
              if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___293 = 1;
              } else
#line 803
              if (9223372036854775807L < n * item_size) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___293 = 1;
              } else {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___293 = 0;
              }
            }
#line 803
            tmp___310 = tmp___293;
          } else {
#line 803
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
              if (n < 0L) {
#line 803
                if (0L < item_size) {
#line 803
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                  tmp___304 = 1;
                } else {
#line 803
                  goto _L___34;
                }
              } else
              _L___34: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (0L < n) {
#line 803
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                  tmp___304 = 1;
                } else {
#line 803
                  goto _L___33;
                }
              } else {
#line 803
                goto _L___33;
              }
            } else {
              _L___33: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (n < 0L) {
#line 803
                  tmp___306 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 803
                  if (item_size == -1L) {
#line 803
                    tmp___305 = 0;
                  } else {
#line 803
                    tmp___305 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___306 = tmp___305;
                }
#line 803
                tmp___309 = tmp___306;
              } else {
#line 803
                if (item_size == 0L) {
#line 803
                  tmp___308 = 0;
                } else {
#line 803
                  if (n < 0L) {
#line 803
                    tmp___307 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 803
                    tmp___307 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___308 = tmp___307;
                }
#line 803
                tmp___309 = tmp___308;
              }
#line 803
              if (tmp___309) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___304 = 1;
              } else
#line 803
              if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___304 = 1;
              } else
#line 803
              if (9223372036854775807L < n * item_size) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___304 = 1;
              } else {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___304 = 0;
              }
            }
#line 803
            tmp___310 = tmp___304;
          }
#line 803
          tmp___334 = tmp___310;
        } else {
#line 803
          if (sizeof(n * item_size) < sizeof(long long )) {
#line 803
            if (~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 803
              if ((long long )n < 0LL) {
#line 803
                if (0LL < (long long )item_size) {
#line 803
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                  tmp___316 = 1;
                } else {
#line 803
                  goto _L___36;
                }
              } else
              _L___36: /* CIL Label */ 
#line 803
              if ((long long )item_size < 0LL) {
#line 803
                if (0LL < (long long )n) {
#line 803
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                  tmp___316 = 1;
                } else {
#line 803
                  goto _L___35;
                }
              } else {
#line 803
                goto _L___35;
              }
            } else {
              _L___35: /* CIL Label */ 
#line 803
              if ((long long )item_size < 0LL) {
#line 803
                if ((long long )n < 0LL) {
#line 803
                  tmp___318 = (long long )n < (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                } else {
#line 803
                  if ((long long )item_size == -1LL) {
#line 803
                    tmp___317 = 0;
                  } else {
#line 803
                    tmp___317 = ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                  }
#line 803
                  tmp___318 = tmp___317;
                }
#line 803
                tmp___321 = tmp___318;
              } else {
#line 803
                if ((long long )item_size == 0LL) {
#line 803
                  tmp___320 = 0;
                } else {
#line 803
                  if ((long long )n < 0LL) {
#line 803
                    tmp___319 = (long long )n < ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                  } else {
#line 803
                    tmp___319 = (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                  }
#line 803
                  tmp___320 = tmp___319;
                }
#line 803
                tmp___321 = tmp___320;
              }
#line 803
              if (tmp___321) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                tmp___316 = 1;
              } else
#line 803
              if ((long long )n * (long long )item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                tmp___316 = 1;
              } else
#line 803
              if (9223372036854775807LL < (long long )n * (long long )item_size) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                tmp___316 = 1;
              } else {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                tmp___316 = 0;
              }
            }
#line 803
            tmp___333 = tmp___316;
          } else {
#line 803
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
              if (n < 0L) {
#line 803
                if (0L < item_size) {
#line 803
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                  tmp___327 = 1;
                } else {
#line 803
                  goto _L___38;
                }
              } else
              _L___38: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (0L < n) {
#line 803
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                  tmp___327 = 1;
                } else {
#line 803
                  goto _L___37;
                }
              } else {
#line 803
                goto _L___37;
              }
            } else {
              _L___37: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (n < 0L) {
#line 803
                  tmp___329 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 803
                  if (item_size == -1L) {
#line 803
                    tmp___328 = 0;
                  } else {
#line 803
                    tmp___328 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___329 = tmp___328;
                }
#line 803
                tmp___332 = tmp___329;
              } else {
#line 803
                if (item_size == 0L) {
#line 803
                  tmp___331 = 0;
                } else {
#line 803
                  if (n < 0L) {
#line 803
                    tmp___330 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 803
                    tmp___330 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___331 = tmp___330;
                }
#line 803
                tmp___332 = tmp___331;
              }
#line 803
              if (tmp___332) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                tmp___327 = 1;
              } else
#line 803
              if ((long long )(n * item_size) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                tmp___327 = 1;
              } else
#line 803
              if (9223372036854775807LL < (long long )(n * item_size)) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                tmp___327 = 1;
              } else {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                tmp___327 = 0;
              }
            }
#line 803
            tmp___333 = tmp___327;
          }
#line 803
          tmp___334 = tmp___333;
        }
#line 803
        tmp___335 = tmp___334;
      }
#line 803
      tmp___336 = tmp___335;
    }
#line 803
    tmp___337 = tmp___336;
  }
#line 803
  if (tmp___337) {
#line 803
    tmp___218 = 9223372036854775807UL;
  } else
#line 803
  if (0xffffffffffffffffUL < (unsigned long )nbytes) {
#line 803
    tmp___218 = 9223372036854775807UL;
  } else {
#line 803
    if (nbytes < 128L) {
#line 803
      tmp___217 = 128;
    } else {
#line 803
      tmp___217 = 0;
    }
#line 803
    tmp___218 = (unsigned long )tmp___217;
  }
#line 803
  adjusted_nbytes = (ptrdiff_t )tmp___218;
#line 807
  if (adjusted_nbytes) {
#line 809
    n = adjusted_nbytes / item_size;
#line 810
    nbytes = adjusted_nbytes - adjusted_nbytes % item_size;
  }
#line 813
  if (! pa) {
#line 814
    *nitems = (ptrdiff_t )0;
  }
#line 815
  if (n - n0 < nitems_incr_min) {
#line 815
    if (sizeof(n) == sizeof(signed char )) {
#line 815
      if (sizeof(n0 + nitems_incr_min) < sizeof(signed char )) {
#line 815
        if (~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 815
          if ((int )((signed char )nitems_incr_min) < 0) {
#line 815
            tmp___343 = (int )((signed char )n0) < ~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )nitems_incr_min);
          } else {
#line 815
            tmp___343 = (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )nitems_incr_min) < (int )((signed char )n0);
          }
#line 815
          tmp___346 = tmp___343;
        } else {
#line 815
          if ((int )((signed char )n0) < 0) {
#line 815
            tmp___345 = (int )((signed char )nitems_incr_min) <= (int )((signed char )n0) + (int )((signed char )nitems_incr_min);
          } else {
#line 815
            if ((int )((signed char )nitems_incr_min) < 0) {
#line 815
              tmp___344 = (int )((signed char )n0) <= (int )((signed char )n0) + (int )((signed char )nitems_incr_min);
            } else {
#line 815
              tmp___344 = (int )((signed char )n0) + (int )((signed char )nitems_incr_min) < (int )((signed char )nitems_incr_min);
            }
#line 815
            tmp___345 = tmp___344;
          }
#line 815
          tmp___346 = tmp___345;
        }
#line 815
        if (tmp___346) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )nitems_incr_min)));
#line 815
          tmp___342 = 1;
        } else
#line 815
        if ((int )((signed char )n0) + (int )((signed char )nitems_incr_min) < -128) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )nitems_incr_min)));
#line 815
          tmp___342 = 1;
        } else
#line 815
        if (127 < (int )((signed char )n0) + (int )((signed char )nitems_incr_min)) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )nitems_incr_min)));
#line 815
          tmp___342 = 1;
        } else {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )nitems_incr_min)));
#line 815
          tmp___342 = 0;
        }
#line 815
        tmp___356 = tmp___342;
      } else {
#line 815
        if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
          if (nitems_incr_min < 0L) {
#line 815
            tmp___352 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
          } else {
#line 815
            tmp___352 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
          }
#line 815
          tmp___355 = tmp___352;
        } else {
#line 815
          if (n0 < 0L) {
#line 815
            tmp___354 = nitems_incr_min <= n0 + nitems_incr_min;
          } else {
#line 815
            if (nitems_incr_min < 0L) {
#line 815
              tmp___353 = n0 <= n0 + nitems_incr_min;
            } else {
#line 815
              tmp___353 = n0 + nitems_incr_min < nitems_incr_min;
            }
#line 815
            tmp___354 = tmp___353;
          }
#line 815
          tmp___355 = tmp___354;
        }
#line 815
        if (tmp___355) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
          tmp___351 = 1;
        } else
#line 815
        if (n0 + nitems_incr_min < -128L) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
          tmp___351 = 1;
        } else
#line 815
        if (127L < n0 + nitems_incr_min) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
          tmp___351 = 1;
        } else {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
          tmp___351 = 0;
        }
#line 815
        tmp___356 = tmp___351;
      }
#line 815
      tmp___436 = tmp___356;
    } else {
#line 815
      if (sizeof(n) == sizeof(short )) {
#line 815
        if (sizeof(n0 + nitems_incr_min) < sizeof(short )) {
#line 815
          if (~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 815
            if ((int )((short )nitems_incr_min) < 0) {
#line 815
              tmp___362 = (int )((short )n0) < ~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )nitems_incr_min);
            } else {
#line 815
              tmp___362 = (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )nitems_incr_min) < (int )((short )n0);
            }
#line 815
            tmp___365 = tmp___362;
          } else {
#line 815
            if ((int )((short )n0) < 0) {
#line 815
              tmp___364 = (int )((short )nitems_incr_min) <= (int )((short )n0) + (int )((short )nitems_incr_min);
            } else {
#line 815
              if ((int )((short )nitems_incr_min) < 0) {
#line 815
                tmp___363 = (int )((short )n0) <= (int )((short )n0) + (int )((short )nitems_incr_min);
              } else {
#line 815
                tmp___363 = (int )((short )n0) + (int )((short )nitems_incr_min) < (int )((short )nitems_incr_min);
              }
#line 815
              tmp___364 = tmp___363;
            }
#line 815
            tmp___365 = tmp___364;
          }
#line 815
          if (tmp___365) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )nitems_incr_min)));
#line 815
            tmp___361 = 1;
          } else
#line 815
          if ((int )((short )n0) + (int )((short )nitems_incr_min) < -32768) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )nitems_incr_min)));
#line 815
            tmp___361 = 1;
          } else
#line 815
          if (32767 < (int )((short )n0) + (int )((short )nitems_incr_min)) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )nitems_incr_min)));
#line 815
            tmp___361 = 1;
          } else {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )nitems_incr_min)));
#line 815
            tmp___361 = 0;
          }
#line 815
          tmp___375 = tmp___361;
        } else {
#line 815
          if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
            if (nitems_incr_min < 0L) {
#line 815
              tmp___371 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
            } else {
#line 815
              tmp___371 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
            }
#line 815
            tmp___374 = tmp___371;
          } else {
#line 815
            if (n0 < 0L) {
#line 815
              tmp___373 = nitems_incr_min <= n0 + nitems_incr_min;
            } else {
#line 815
              if (nitems_incr_min < 0L) {
#line 815
                tmp___372 = n0 <= n0 + nitems_incr_min;
              } else {
#line 815
                tmp___372 = n0 + nitems_incr_min < nitems_incr_min;
              }
#line 815
              tmp___373 = tmp___372;
            }
#line 815
            tmp___374 = tmp___373;
          }
#line 815
          if (tmp___374) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
            tmp___370 = 1;
          } else
#line 815
          if (n0 + nitems_incr_min < -32768L) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
            tmp___370 = 1;
          } else
#line 815
          if (32767L < n0 + nitems_incr_min) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
            tmp___370 = 1;
          } else {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
            tmp___370 = 0;
          }
#line 815
          tmp___375 = tmp___370;
        }
#line 815
        tmp___435 = tmp___375;
      } else {
#line 815
        if (sizeof(n) == sizeof(int )) {
#line 815
          if (sizeof(n0 + nitems_incr_min) < sizeof(int )) {
#line 815
            if (~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 815
              if ((int )nitems_incr_min < 0) {
#line 815
                tmp___381 = (int )n0 < ~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )nitems_incr_min;
              } else {
#line 815
                tmp___381 = (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )nitems_incr_min < (int )n0;
              }
#line 815
              tmp___384 = tmp___381;
            } else {
#line 815
              if ((int )n0 < 0) {
#line 815
                tmp___383 = (int )nitems_incr_min <= (int )n0 + (int )nitems_incr_min;
              } else {
#line 815
                if ((int )nitems_incr_min < 0) {
#line 815
                  tmp___382 = (int )n0 <= (int )n0 + (int )nitems_incr_min;
                } else {
#line 815
                  tmp___382 = (int )n0 + (int )nitems_incr_min < (int )nitems_incr_min;
                }
#line 815
                tmp___383 = tmp___382;
              }
#line 815
              tmp___384 = tmp___383;
            }
#line 815
            if (tmp___384) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
#line 815
              tmp___380 = 1;
            } else
#line 815
            if ((int )n0 + (int )nitems_incr_min < (-0x7FFFFFFF-1)) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
#line 815
              tmp___380 = 1;
            } else
#line 815
            if (2147483647 < (int )n0 + (int )nitems_incr_min) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
#line 815
              tmp___380 = 1;
            } else {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
#line 815
              tmp___380 = 0;
            }
#line 815
            tmp___394 = tmp___380;
          } else {
#line 815
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
              if (nitems_incr_min < 0L) {
#line 815
                tmp___390 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
              } else {
#line 815
                tmp___390 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
              }
#line 815
              tmp___393 = tmp___390;
            } else {
#line 815
              if (n0 < 0L) {
#line 815
                tmp___392 = nitems_incr_min <= n0 + nitems_incr_min;
              } else {
#line 815
                if (nitems_incr_min < 0L) {
#line 815
                  tmp___391 = n0 <= n0 + nitems_incr_min;
                } else {
#line 815
                  tmp___391 = n0 + nitems_incr_min < nitems_incr_min;
                }
#line 815
                tmp___392 = tmp___391;
              }
#line 815
              tmp___393 = tmp___392;
            }
#line 815
            if (tmp___393) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
              tmp___389 = 1;
            } else
#line 815
            if (n0 + nitems_incr_min < (-0x7FFFFFFF-1)) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
              tmp___389 = 1;
            } else
#line 815
            if (2147483647L < n0 + nitems_incr_min) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
              tmp___389 = 1;
            } else {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
              tmp___389 = 0;
            }
#line 815
            tmp___394 = tmp___389;
          }
#line 815
          tmp___434 = tmp___394;
        } else {
#line 815
          if (sizeof(n) == sizeof(long )) {
#line 815
            if (sizeof(n0 + nitems_incr_min) < sizeof(long )) {
#line 815
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
                if (nitems_incr_min < 0L) {
#line 815
                  tmp___400 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 815
                  tmp___400 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 815
                tmp___403 = tmp___400;
              } else {
#line 815
                if (n0 < 0L) {
#line 815
                  tmp___402 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 815
                  if (nitems_incr_min < 0L) {
#line 815
                    tmp___401 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 815
                    tmp___401 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 815
                  tmp___402 = tmp___401;
                }
#line 815
                tmp___403 = tmp___402;
              }
#line 815
              if (tmp___403) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___399 = 1;
              } else
#line 815
              if (n0 + nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___399 = 1;
              } else
#line 815
              if (9223372036854775807L < n0 + nitems_incr_min) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___399 = 1;
              } else {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___399 = 0;
              }
#line 815
              tmp___413 = tmp___399;
            } else {
#line 815
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
                if (nitems_incr_min < 0L) {
#line 815
                  tmp___409 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 815
                  tmp___409 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 815
                tmp___412 = tmp___409;
              } else {
#line 815
                if (n0 < 0L) {
#line 815
                  tmp___411 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 815
                  if (nitems_incr_min < 0L) {
#line 815
                    tmp___410 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 815
                    tmp___410 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 815
                  tmp___411 = tmp___410;
                }
#line 815
                tmp___412 = tmp___411;
              }
#line 815
              if (tmp___412) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___408 = 1;
              } else
#line 815
              if (n0 + nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___408 = 1;
              } else
#line 815
              if (9223372036854775807L < n0 + nitems_incr_min) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___408 = 1;
              } else {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___408 = 0;
              }
#line 815
              tmp___413 = tmp___408;
            }
#line 815
            tmp___433 = tmp___413;
          } else {
#line 815
            if (sizeof(n0 + nitems_incr_min) < sizeof(long long )) {
#line 815
              if (~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 815
                if ((long long )nitems_incr_min < 0LL) {
#line 815
                  tmp___419 = (long long )n0 < ~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )nitems_incr_min;
                } else {
#line 815
                  tmp___419 = (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )nitems_incr_min < (long long )n0;
                }
#line 815
                tmp___422 = tmp___419;
              } else {
#line 815
                if ((long long )n0 < 0LL) {
#line 815
                  tmp___421 = (long long )nitems_incr_min <= (long long )n0 + (long long )nitems_incr_min;
                } else {
#line 815
                  if ((long long )nitems_incr_min < 0LL) {
#line 815
                    tmp___420 = (long long )n0 <= (long long )n0 + (long long )nitems_incr_min;
                  } else {
#line 815
                    tmp___420 = (long long )n0 + (long long )nitems_incr_min < (long long )nitems_incr_min;
                  }
#line 815
                  tmp___421 = tmp___420;
                }
#line 815
                tmp___422 = tmp___421;
              }
#line 815
              if (tmp___422) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
#line 815
                tmp___418 = 1;
              } else
#line 815
              if ((long long )n0 + (long long )nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
#line 815
                tmp___418 = 1;
              } else
#line 815
              if (9223372036854775807LL < (long long )n0 + (long long )nitems_incr_min) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
#line 815
                tmp___418 = 1;
              } else {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
#line 815
                tmp___418 = 0;
              }
#line 815
              tmp___432 = tmp___418;
            } else {
#line 815
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
                if (nitems_incr_min < 0L) {
#line 815
                  tmp___428 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 815
                  tmp___428 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 815
                tmp___431 = tmp___428;
              } else {
#line 815
                if (n0 < 0L) {
#line 815
                  tmp___430 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 815
                  if (nitems_incr_min < 0L) {
#line 815
                    tmp___429 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 815
                    tmp___429 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 815
                  tmp___430 = tmp___429;
                }
#line 815
                tmp___431 = tmp___430;
              }
#line 815
              if (tmp___431) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
#line 815
                tmp___427 = 1;
              } else
#line 815
              if ((long long )(n0 + nitems_incr_min) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
#line 815
                tmp___427 = 1;
              } else
#line 815
              if (9223372036854775807LL < (long long )(n0 + nitems_incr_min)) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
#line 815
                tmp___427 = 1;
              } else {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
#line 815
                tmp___427 = 0;
              }
#line 815
              tmp___432 = tmp___427;
            }
#line 815
            tmp___433 = tmp___432;
          }
#line 815
          tmp___434 = tmp___433;
        }
#line 815
        tmp___435 = tmp___434;
      }
#line 815
      tmp___436 = tmp___435;
    }
#line 815
    if (tmp___436) {
      {
#line 819
      xalloc_die();
      }
    } else
#line 815
    if (0L <= nitems_max) {
#line 815
      if (nitems_max < n) {
        {
#line 819
        xalloc_die();
        }
      } else {
#line 815
        goto _L___59;
      }
    } else {
      _L___59: /* CIL Label */ 
#line 815
      if (sizeof(nbytes) == sizeof(signed char )) {
#line 815
        if (sizeof(n * item_size) < sizeof(signed char )) {
#line 815
          if (~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 815
            if ((int )((signed char )n) < 0) {
#line 815
              if (0 < (int )((signed char )item_size)) {
#line 815
                nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
                tmp___442 = 1;
              } else {
#line 815
                goto _L___40;
              }
            } else
            _L___40: /* CIL Label */ 
#line 815
            if ((int )((signed char )item_size) < 0) {
#line 815
              if (0 < (int )((signed char )n)) {
#line 815
                nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
                tmp___442 = 1;
              } else {
#line 815
                goto _L___39;
              }
            } else {
#line 815
              goto _L___39;
            }
          } else {
            _L___39: /* CIL Label */ 
#line 815
            if ((int )((signed char )item_size) < 0) {
#line 815
              if ((int )((signed char )n) < 0) {
#line 815
                tmp___444 = (int )((signed char )n) < (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
              } else {
#line 815
                if ((int )((signed char )item_size) == -1) {
#line 815
                  tmp___443 = 0;
                } else {
#line 815
                  tmp___443 = ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
                }
#line 815
                tmp___444 = tmp___443;
              }
#line 815
              tmp___447 = tmp___444;
            } else {
#line 815
              if ((int )((signed char )item_size) == 0) {
#line 815
                tmp___446 = 0;
              } else {
#line 815
                if ((int )((signed char )n) < 0) {
#line 815
                  tmp___445 = (int )((signed char )n) < ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
                } else {
#line 815
                  tmp___445 = (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
                }
#line 815
                tmp___446 = tmp___445;
              }
#line 815
              tmp___447 = tmp___446;
            }
#line 815
            if (tmp___447) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
              tmp___442 = 1;
            } else
#line 815
            if ((int )((signed char )n) * (int )((signed char )item_size) < -128) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
              tmp___442 = 1;
            } else
#line 815
            if (127 < (int )((signed char )n) * (int )((signed char )item_size)) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
              tmp___442 = 1;
            } else {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
              tmp___442 = 0;
            }
          }
#line 815
          tmp___459 = tmp___442;
        } else {
#line 815
          if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
            if (n < 0L) {
#line 815
              if (0L < item_size) {
#line 815
                nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___453 = 1;
              } else {
#line 815
                goto _L___42;
              }
            } else
            _L___42: /* CIL Label */ 
#line 815
            if (item_size < 0L) {
#line 815
              if (0L < n) {
#line 815
                nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___453 = 1;
              } else {
#line 815
                goto _L___41;
              }
            } else {
#line 815
              goto _L___41;
            }
          } else {
            _L___41: /* CIL Label */ 
#line 815
            if (item_size < 0L) {
#line 815
              if (n < 0L) {
#line 815
                tmp___455 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 815
                if (item_size == -1L) {
#line 815
                  tmp___454 = 0;
                } else {
#line 815
                  tmp___454 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 815
                tmp___455 = tmp___454;
              }
#line 815
              tmp___458 = tmp___455;
            } else {
#line 815
              if (item_size == 0L) {
#line 815
                tmp___457 = 0;
              } else {
#line 815
                if (n < 0L) {
#line 815
                  tmp___456 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 815
                  tmp___456 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 815
                tmp___457 = tmp___456;
              }
#line 815
              tmp___458 = tmp___457;
            }
#line 815
            if (tmp___458) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
              tmp___453 = 1;
            } else
#line 815
            if (n * item_size < -128L) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
              tmp___453 = 1;
            } else
#line 815
            if (127L < n * item_size) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
              tmp___453 = 1;
            } else {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
              tmp___453 = 0;
            }
          }
#line 815
          tmp___459 = tmp___453;
        }
#line 815
        tmp___555 = tmp___459;
      } else {
#line 815
        if (sizeof(nbytes) == sizeof(short )) {
#line 815
          if (sizeof(n * item_size) < sizeof(short )) {
#line 815
            if (~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 815
              if ((int )((short )n) < 0) {
#line 815
                if (0 < (int )((short )item_size)) {
#line 815
                  nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                  tmp___465 = 1;
                } else {
#line 815
                  goto _L___44;
                }
              } else
              _L___44: /* CIL Label */ 
#line 815
              if ((int )((short )item_size) < 0) {
#line 815
                if (0 < (int )((short )n)) {
#line 815
                  nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                  tmp___465 = 1;
                } else {
#line 815
                  goto _L___43;
                }
              } else {
#line 815
                goto _L___43;
              }
            } else {
              _L___43: /* CIL Label */ 
#line 815
              if ((int )((short )item_size) < 0) {
#line 815
                if ((int )((short )n) < 0) {
#line 815
                  tmp___467 = (int )((short )n) < (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
                } else {
#line 815
                  if ((int )((short )item_size) == -1) {
#line 815
                    tmp___466 = 0;
                  } else {
#line 815
                    tmp___466 = ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
                  }
#line 815
                  tmp___467 = tmp___466;
                }
#line 815
                tmp___470 = tmp___467;
              } else {
#line 815
                if ((int )((short )item_size) == 0) {
#line 815
                  tmp___469 = 0;
                } else {
#line 815
                  if ((int )((short )n) < 0) {
#line 815
                    tmp___468 = (int )((short )n) < ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
                  } else {
#line 815
                    tmp___468 = (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
                  }
#line 815
                  tmp___469 = tmp___468;
                }
#line 815
                tmp___470 = tmp___469;
              }
#line 815
              if (tmp___470) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                tmp___465 = 1;
              } else
#line 815
              if ((int )((short )n) * (int )((short )item_size) < -32768) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                tmp___465 = 1;
              } else
#line 815
              if (32767 < (int )((short )n) * (int )((short )item_size)) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                tmp___465 = 1;
              } else {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                tmp___465 = 0;
              }
            }
#line 815
            tmp___482 = tmp___465;
          } else {
#line 815
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
              if (n < 0L) {
#line 815
                if (0L < item_size) {
#line 815
                  nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___476 = 1;
                } else {
#line 815
                  goto _L___46;
                }
              } else
              _L___46: /* CIL Label */ 
#line 815
              if (item_size < 0L) {
#line 815
                if (0L < n) {
#line 815
                  nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___476 = 1;
                } else {
#line 815
                  goto _L___45;
                }
              } else {
#line 815
                goto _L___45;
              }
            } else {
              _L___45: /* CIL Label */ 
#line 815
              if (item_size < 0L) {
#line 815
                if (n < 0L) {
#line 815
                  tmp___478 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 815
                  if (item_size == -1L) {
#line 815
                    tmp___477 = 0;
                  } else {
#line 815
                    tmp___477 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 815
                  tmp___478 = tmp___477;
                }
#line 815
                tmp___481 = tmp___478;
              } else {
#line 815
                if (item_size == 0L) {
#line 815
                  tmp___480 = 0;
                } else {
#line 815
                  if (n < 0L) {
#line 815
                    tmp___479 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 815
                    tmp___479 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 815
                  tmp___480 = tmp___479;
                }
#line 815
                tmp___481 = tmp___480;
              }
#line 815
              if (tmp___481) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___476 = 1;
              } else
#line 815
              if (n * item_size < -32768L) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___476 = 1;
              } else
#line 815
              if (32767L < n * item_size) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___476 = 1;
              } else {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___476 = 0;
              }
            }
#line 815
            tmp___482 = tmp___476;
          }
#line 815
          tmp___554 = tmp___482;
        } else {
#line 815
          if (sizeof(nbytes) == sizeof(int )) {
#line 815
            if (sizeof(n * item_size) < sizeof(int )) {
#line 815
              if (~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 815
                if ((int )n < 0) {
#line 815
                  if (0 < (int )item_size) {
#line 815
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                    tmp___488 = 1;
                  } else {
#line 815
                    goto _L___48;
                  }
                } else
                _L___48: /* CIL Label */ 
#line 815
                if ((int )item_size < 0) {
#line 815
                  if (0 < (int )n) {
#line 815
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                    tmp___488 = 1;
                  } else {
#line 815
                    goto _L___47;
                  }
                } else {
#line 815
                  goto _L___47;
                }
              } else {
                _L___47: /* CIL Label */ 
#line 815
                if ((int )item_size < 0) {
#line 815
                  if ((int )n < 0) {
#line 815
                    tmp___490 = (int )n < (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                  } else {
#line 815
                    if ((int )item_size == -1) {
#line 815
                      tmp___489 = 0;
                    } else {
#line 815
                      tmp___489 = ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                    }
#line 815
                    tmp___490 = tmp___489;
                  }
#line 815
                  tmp___493 = tmp___490;
                } else {
#line 815
                  if ((int )item_size == 0) {
#line 815
                    tmp___492 = 0;
                  } else {
#line 815
                    if ((int )n < 0) {
#line 815
                      tmp___491 = (int )n < ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                    } else {
#line 815
                      tmp___491 = (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                    }
#line 815
                    tmp___492 = tmp___491;
                  }
#line 815
                  tmp___493 = tmp___492;
                }
#line 815
                if (tmp___493) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                  tmp___488 = 1;
                } else
#line 815
                if ((int )n * (int )item_size < (-0x7FFFFFFF-1)) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                  tmp___488 = 1;
                } else
#line 815
                if (2147483647 < (int )n * (int )item_size) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                  tmp___488 = 1;
                } else {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                  tmp___488 = 0;
                }
              }
#line 815
              tmp___505 = tmp___488;
            } else {
#line 815
              if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
                if (n < 0L) {
#line 815
                  if (0L < item_size) {
#line 815
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                    tmp___499 = 1;
                  } else {
#line 815
                    goto _L___50;
                  }
                } else
                _L___50: /* CIL Label */ 
#line 815
                if (item_size < 0L) {
#line 815
                  if (0L < n) {
#line 815
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                    tmp___499 = 1;
                  } else {
#line 815
                    goto _L___49;
                  }
                } else {
#line 815
                  goto _L___49;
                }
              } else {
                _L___49: /* CIL Label */ 
#line 815
                if (item_size < 0L) {
#line 815
                  if (n < 0L) {
#line 815
                    tmp___501 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 815
                    if (item_size == -1L) {
#line 815
                      tmp___500 = 0;
                    } else {
#line 815
                      tmp___500 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                    }
#line 815
                    tmp___501 = tmp___500;
                  }
#line 815
                  tmp___504 = tmp___501;
                } else {
#line 815
                  if (item_size == 0L) {
#line 815
                    tmp___503 = 0;
                  } else {
#line 815
                    if (n < 0L) {
#line 815
                      tmp___502 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 815
                      tmp___502 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                    }
#line 815
                    tmp___503 = tmp___502;
                  }
#line 815
                  tmp___504 = tmp___503;
                }
#line 815
                if (tmp___504) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___499 = 1;
                } else
#line 815
                if (n * item_size < (-0x7FFFFFFF-1)) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___499 = 1;
                } else
#line 815
                if (2147483647L < n * item_size) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___499 = 1;
                } else {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___499 = 0;
                }
              }
#line 815
              tmp___505 = tmp___499;
            }
#line 815
            tmp___553 = tmp___505;
          } else {
#line 815
            if (sizeof(nbytes) == sizeof(long )) {
#line 815
              if (sizeof(n * item_size) < sizeof(long )) {
#line 815
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
                  if (n < 0L) {
#line 815
                    if (0L < item_size) {
#line 815
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                      tmp___511 = 1;
                    } else {
#line 815
                      goto _L___52;
                    }
                  } else
                  _L___52: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (0L < n) {
#line 815
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                      tmp___511 = 1;
                    } else {
#line 815
                      goto _L___51;
                    }
                  } else {
#line 815
                    goto _L___51;
                  }
                } else {
                  _L___51: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (n < 0L) {
#line 815
                      tmp___513 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 815
                      if (item_size == -1L) {
#line 815
                        tmp___512 = 0;
                      } else {
#line 815
                        tmp___512 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___513 = tmp___512;
                    }
#line 815
                    tmp___516 = tmp___513;
                  } else {
#line 815
                    if (item_size == 0L) {
#line 815
                      tmp___515 = 0;
                    } else {
#line 815
                      if (n < 0L) {
#line 815
                        tmp___514 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 815
                        tmp___514 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___515 = tmp___514;
                    }
#line 815
                    tmp___516 = tmp___515;
                  }
#line 815
                  if (tmp___516) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___511 = 1;
                  } else
#line 815
                  if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___511 = 1;
                  } else
#line 815
                  if (9223372036854775807L < n * item_size) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___511 = 1;
                  } else {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___511 = 0;
                  }
                }
#line 815
                tmp___528 = tmp___511;
              } else {
#line 815
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
                  if (n < 0L) {
#line 815
                    if (0L < item_size) {
#line 815
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                      tmp___522 = 1;
                    } else {
#line 815
                      goto _L___54;
                    }
                  } else
                  _L___54: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (0L < n) {
#line 815
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                      tmp___522 = 1;
                    } else {
#line 815
                      goto _L___53;
                    }
                  } else {
#line 815
                    goto _L___53;
                  }
                } else {
                  _L___53: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (n < 0L) {
#line 815
                      tmp___524 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 815
                      if (item_size == -1L) {
#line 815
                        tmp___523 = 0;
                      } else {
#line 815
                        tmp___523 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___524 = tmp___523;
                    }
#line 815
                    tmp___527 = tmp___524;
                  } else {
#line 815
                    if (item_size == 0L) {
#line 815
                      tmp___526 = 0;
                    } else {
#line 815
                      if (n < 0L) {
#line 815
                        tmp___525 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 815
                        tmp___525 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___526 = tmp___525;
                    }
#line 815
                    tmp___527 = tmp___526;
                  }
#line 815
                  if (tmp___527) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___522 = 1;
                  } else
#line 815
                  if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___522 = 1;
                  } else
#line 815
                  if (9223372036854775807L < n * item_size) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___522 = 1;
                  } else {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___522 = 0;
                  }
                }
#line 815
                tmp___528 = tmp___522;
              }
#line 815
              tmp___552 = tmp___528;
            } else {
#line 815
              if (sizeof(n * item_size) < sizeof(long long )) {
#line 815
                if (~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 815
                  if ((long long )n < 0LL) {
#line 815
                    if (0LL < (long long )item_size) {
#line 815
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                      tmp___534 = 1;
                    } else {
#line 815
                      goto _L___56;
                    }
                  } else
                  _L___56: /* CIL Label */ 
#line 815
                  if ((long long )item_size < 0LL) {
#line 815
                    if (0LL < (long long )n) {
#line 815
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                      tmp___534 = 1;
                    } else {
#line 815
                      goto _L___55;
                    }
                  } else {
#line 815
                    goto _L___55;
                  }
                } else {
                  _L___55: /* CIL Label */ 
#line 815
                  if ((long long )item_size < 0LL) {
#line 815
                    if ((long long )n < 0LL) {
#line 815
                      tmp___536 = (long long )n < (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                    } else {
#line 815
                      if ((long long )item_size == -1LL) {
#line 815
                        tmp___535 = 0;
                      } else {
#line 815
                        tmp___535 = ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                      }
#line 815
                      tmp___536 = tmp___535;
                    }
#line 815
                    tmp___539 = tmp___536;
                  } else {
#line 815
                    if ((long long )item_size == 0LL) {
#line 815
                      tmp___538 = 0;
                    } else {
#line 815
                      if ((long long )n < 0LL) {
#line 815
                        tmp___537 = (long long )n < ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                      } else {
#line 815
                        tmp___537 = (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                      }
#line 815
                      tmp___538 = tmp___537;
                    }
#line 815
                    tmp___539 = tmp___538;
                  }
#line 815
                  if (tmp___539) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                    tmp___534 = 1;
                  } else
#line 815
                  if ((long long )n * (long long )item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                    tmp___534 = 1;
                  } else
#line 815
                  if (9223372036854775807LL < (long long )n * (long long )item_size) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                    tmp___534 = 1;
                  } else {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                    tmp___534 = 0;
                  }
                }
#line 815
                tmp___551 = tmp___534;
              } else {
#line 815
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
                  if (n < 0L) {
#line 815
                    if (0L < item_size) {
#line 815
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                      tmp___545 = 1;
                    } else {
#line 815
                      goto _L___58;
                    }
                  } else
                  _L___58: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (0L < n) {
#line 815
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                      tmp___545 = 1;
                    } else {
#line 815
                      goto _L___57;
                    }
                  } else {
#line 815
                    goto _L___57;
                  }
                } else {
                  _L___57: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (n < 0L) {
#line 815
                      tmp___547 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 815
                      if (item_size == -1L) {
#line 815
                        tmp___546 = 0;
                      } else {
#line 815
                        tmp___546 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___547 = tmp___546;
                    }
#line 815
                    tmp___550 = tmp___547;
                  } else {
#line 815
                    if (item_size == 0L) {
#line 815
                      tmp___549 = 0;
                    } else {
#line 815
                      if (n < 0L) {
#line 815
                        tmp___548 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 815
                        tmp___548 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___549 = tmp___548;
                    }
#line 815
                    tmp___550 = tmp___549;
                  }
#line 815
                  if (tmp___550) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                    tmp___545 = 1;
                  } else
#line 815
                  if ((long long )(n * item_size) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                    tmp___545 = 1;
                  } else
#line 815
                  if (9223372036854775807LL < (long long )(n * item_size)) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                    tmp___545 = 1;
                  } else {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                    tmp___545 = 0;
                  }
                }
#line 815
                tmp___551 = tmp___545;
              }
#line 815
              tmp___552 = tmp___551;
            }
#line 815
            tmp___553 = tmp___552;
          }
#line 815
          tmp___554 = tmp___553;
        }
#line 815
        tmp___555 = tmp___554;
      }
#line 815
      if (tmp___555) {
        {
#line 819
        xalloc_die();
        }
      }
    }
  }
  {
#line 820
  pa = xrealloc(pa, (size_t )nbytes);
#line 821
  *nitems = n;
  }
#line 822
  return (pa);
}
}
#line 834 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void *maybe_realloc(void *pa , ptrdiff_t i , ptrdiff_t *nitems , ptrdiff_t nitems_max ,
                           ptrdiff_t item_size ) 
{ 
  void *tmp ;

  {
#line 838
  if (i < *nitems) {
#line 839
    return (pa);
  }
  {
#line 840
  tmp = xpalloc(pa, nitems, (ptrdiff_t )1, nitems_max, item_size);
  }
#line 840
  return (tmp);
}
}
#line 844 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static ptrdiff_t charclass_index(struct dfa *d , charclass *s ) 
{ 
  ptrdiff_t i ;
  _Bool tmp ;
  void *tmp___0 ;

  {
#line 849
  i = (ptrdiff_t )0;
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    if (! (i < d->cindex)) {
#line 849
      goto while_break;
    }
    {
#line 850
    tmp = equal((charclass const   *)s, (charclass const   *)(d->charclasses + i));
    }
#line 850
    if (tmp) {
#line 851
      return (i);
    }
#line 849
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 852
  tmp___0 = maybe_realloc((void *)d->charclasses, d->cindex, & d->calloc, (ptrdiff_t )(TOKEN_MAX - 275L),
                          (ptrdiff_t )sizeof(*(d->charclasses)));
#line 852
  d->charclasses = (charclass *)tmp___0;
#line 854
  (d->cindex) ++;
#line 855
  *(d->charclasses + i) = *s;
  }
#line 856
  return (i);
}
}
#line 859 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool unibyte_word_constituent(struct dfa  const  *dfa , unsigned char c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 862
  if (dfa->localeinfo.sbctowc[c] != 4294967295U) {
    {
#line 862
    tmp = __ctype_b_loc();
    }
#line 862
    if ((int const   )*(*tmp + (int )c) & 8) {
#line 862
      tmp___0 = 1;
    } else
#line 862
    if ((int )c == 95) {
#line 862
      tmp___0 = 1;
    } else {
#line 862
      tmp___0 = 0;
    }
  } else {
#line 862
    tmp___0 = 0;
  }
#line 862
  return ((_Bool )tmp___0);
}
}
#line 865 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static int char_context(struct dfa  const  *dfa , unsigned char c ) 
{ 
  _Bool tmp ;

  {
#line 868
  if ((int )c == (int )dfa->syntax.eolbyte) {
#line 868
    if (! dfa->syntax.anchor) {
#line 869
      return (4);
    }
  }
  {
#line 870
  tmp = unibyte_word_constituent(dfa, c);
  }
#line 870
  if (tmp) {
#line 871
    return (2);
  }
#line 872
  return (1);
}
}
#line 880 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool setbit_wc(wint_t wc , charclass *c ) 
{ 
  int b___0 ;
  int tmp ;

  {
  {
#line 883
  tmp = wctob(wc);
#line 883
  b___0 = tmp;
  }
#line 884
  if (b___0 < 0) {
#line 885
    return ((_Bool)0);
  }
  {
#line 887
  setbit((unsigned int )b___0, c);
  }
#line 888
  return ((_Bool)1);
}
}
#line 893 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void setbit_case_fold_c(int b___0 , charclass *c ) 
{ 
  int ub ;
  int tmp ;
  int i ;
  int tmp___0 ;

  {
  {
#line 896
  tmp = toupper(b___0);
#line 896
  ub = tmp;
#line 897
  i = 0;
  }
  {
#line 897
  while (1) {
    while_continue: /* CIL Label */ ;
#line 897
    if (! (i < 256)) {
#line 897
      goto while_break;
    }
    {
#line 898
    tmp___0 = toupper(i);
    }
#line 898
    if (tmp___0 == ub) {
      {
#line 899
      setbit((unsigned int )i, c);
      }
    }
#line 897
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  return;
}
}
#line 904 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool using_simple_locale(_Bool multibyte ) 
{ 
  char const   *loc ;
  char *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
#line 923
  if (multibyte) {
#line 924
    return ((_Bool)0);
  } else {
    {
#line 929
    tmp = setlocale(6, (char const   *)((void *)0));
#line 929
    loc = (char const   *)tmp;
    }
#line 930
    if (! loc) {
#line 930
      tmp___2 = 1;
    } else {
      {
#line 930
      tmp___0 = streq(loc, "C");
      }
#line 930
      if (tmp___0) {
#line 930
        tmp___2 = 1;
      } else {
        {
#line 930
        tmp___1 = streq(loc, "POSIX");
        }
#line 930
        if (tmp___1) {
#line 930
          tmp___2 = 1;
        } else {
#line 930
          tmp___2 = 0;
        }
      }
    }
#line 930
    return ((_Bool )tmp___2);
  }
}
}
#line 940 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static int fetch_wc(struct dfa *dfa ) 
{ 
  size_t nbytes ;
  size_t tmp ;
  int c ;
  unsigned char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 943
  tmp = mbs_to_wchar(& dfa->lex.wctok, dfa->lex.ptr, dfa->lex.left, dfa);
#line 943
  nbytes = tmp;
#line 945
  dfa->lex.cur_mb_len = (int )nbytes;
  }
#line 946
  if (nbytes == 1UL) {
    {
#line 946
    tmp___0 = to_uchar((char )*(dfa->lex.ptr + 0));
#line 946
    tmp___1 = (int )tmp___0;
    }
  } else {
#line 946
    tmp___1 = -1;
  }
#line 946
  c = tmp___1;
#line 947
  dfa->lex.ptr += nbytes;
#line 948
  dfa->lex.left -= nbytes;
#line 949
  return (c);
}
}
#line 954 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static int bracket_fetch_wc(struct dfa *dfa ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 957
  if (! dfa->lex.left) {
    {
#line 958
    tmp = gettext("unbalanced [");
#line 958
    dfaerror((char const   *)tmp);
    }
  }
  {
#line 959
  tmp___0 = fetch_wc(dfa);
  }
#line 959
  return (tmp___0);
}
}
#line 975 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static struct dfa_ctype  const  prednames[13]  = 
#line 975
  {      {"alpha", (predicate *)(& isalpha), (_Bool)0}, 
        {"upper", (predicate *)(& isupper), (_Bool)0}, 
        {"lower", (predicate *)(& islower), (_Bool)0}, 
        {"digit", (predicate *)(& isdigit), (_Bool)1}, 
        {"xdigit", (predicate *)(& isxdigit), (_Bool)0}, 
        {"space", (predicate *)(& isspace), (_Bool)0}, 
        {"punct", (predicate *)(& ispunct), (_Bool)0}, 
        {"alnum", (predicate *)(& isalnum), (_Bool)0}, 
        {"print", (predicate *)(& isprint), (_Bool)0}, 
        {"graph", (predicate *)(& isgraph), (_Bool)0}, 
        {"cntrl", (predicate *)(& iscntrl), (_Bool)0}, 
        {"blank", (predicate *)(& isblank), (_Bool)0}, 
        {(char const   *)((void *)0), (predicate *)((void *)0), (_Bool)0}};
#line 991 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static struct dfa_ctype  const  * __attribute__((__pure__)) find_pred(char const   *str ) 
{ 
  unsigned int i ;
  _Bool tmp ;

  {
#line 994
  i = 0U;
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 994
    if (! prednames[i].name) {
#line 994
      goto while_break;
    }
    {
#line 995
    tmp = streq(str, (char const   *)prednames[i].name);
    }
#line 995
    if (tmp) {
#line 996
      return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)(& prednames[i]));
    }
#line 994
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 997
  return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)((void *)0));
}
}
#line 1002 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static token parse_bracket_exp(struct dfa *dfa ) 
{ 
  _Bool known_bracket_exp ;
  int colon_warning_state ;
  charclass ccl ;
  int c ;
  int tmp ;
  _Bool invert ;
  wint_t wc ;
  int c1 ;
  wint_t wc1 ;
  char str[33] ;
  size_t len ;
  size_t tmp___0 ;
  char const   *class ;
  char const   *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  struct dfa_ctype  const  *pred ;
  struct dfa_ctype  const  * __attribute__((__pure__)) tmp___6 ;
  char *tmp___7 ;
  int c2 ;
  int tmp___8 ;
  int c2___0 ;
  int tmp___9 ;
  wint_t wc2 ;
  int ci ;
  unsigned short const   **tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;
  wchar_t folded[33] ;
  unsigned int n ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned int i ;
  void *tmp___17 ;
  ptrdiff_t tmp___18 ;
  _Bool tmp___19 ;
  char *tmp___20 ;
  ptrdiff_t tmp___22 ;
  _Bool tmp___23 ;
  ptrdiff_t tmp___24 ;

  {
  {
#line 1007
  known_bracket_exp = (_Bool)1;
#line 1016
  dfa->lex.brack.nchars = (ptrdiff_t )0;
#line 1018
  zeroset(& ccl);
#line 1019
  tmp = bracket_fetch_wc(dfa);
#line 1019
  c = tmp;
#line 1020
  invert = (_Bool )(c == 94);
  }
#line 1021
  if (invert) {
    {
#line 1023
    c = bracket_fetch_wc(dfa);
#line 1024
    known_bracket_exp = dfa->simple_locale;
    }
  }
#line 1026
  wc = dfa->lex.wctok;
#line 1029
  colon_warning_state = c == 58;
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1032
    c1 = 256;
#line 1033
    colon_warning_state &= -3;
#line 1039
    if (c == 91) {
      {
#line 1041
      c1 = bracket_fetch_wc(dfa);
#line 1042
      wc1 = dfa->lex.wctok;
      }
#line 1044
      if (c1 == 58) {
#line 1044
        if (dfa->syntax.syntax_bits & ((1UL << 1) << 1)) {
#line 1044
          goto _L___0;
        } else {
#line 1044
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1044
      if (c1 == 46) {
#line 1044
        goto _L___0;
      } else
#line 1044
      if (c1 == 61) {
        _L___0: /* CIL Label */ 
#line 1049
        len = (size_t )0;
        {
#line 1050
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1052
          c = bracket_fetch_wc(dfa);
          }
#line 1053
          if (dfa->lex.left == 0UL) {
#line 1055
            goto while_break___0;
          } else
#line 1053
          if (c == c1) {
#line 1053
            if ((int const   )*(dfa->lex.ptr + 0) == 93) {
#line 1055
              goto while_break___0;
            }
          }
#line 1056
          if (len < 32UL) {
#line 1057
            tmp___0 = len;
#line 1057
            len ++;
#line 1057
            str[tmp___0] = (char )c;
          } else {
#line 1060
            str[0] = (char )'\000';
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1062
        str[len] = (char )'\000';
#line 1065
        c = bracket_fetch_wc(dfa);
#line 1066
        wc = dfa->lex.wctok;
        }
#line 1067
        if (c1 == 58) {
#line 1073
          if (dfa->syntax.case_fold) {
            {
#line 1073
            tmp___4 = streq((char const   *)(str), "upper");
            }
#line 1073
            if (tmp___4) {
#line 1073
              tmp___3 = "alpha";
            } else {
              {
#line 1073
              tmp___5 = streq((char const   *)(str), "lower");
              }
#line 1073
              if (tmp___5) {
#line 1073
                tmp___3 = "alpha";
              } else {
#line 1073
                tmp___3 = (char const   *)(str);
              }
            }
          } else {
#line 1073
            tmp___3 = (char const   *)(str);
          }
          {
#line 1073
          class = tmp___3;
#line 1077
          tmp___6 = find_pred(class);
#line 1077
          pred = (struct dfa_ctype  const  *)tmp___6;
          }
#line 1078
          if (! pred) {
            {
#line 1079
            tmp___7 = gettext("invalid character class");
#line 1079
            dfaerror((char const   *)tmp___7);
            }
          }
#line 1081
          if (dfa->localeinfo.multibyte) {
#line 1081
            if (! pred->single_byte_only) {
#line 1082
              known_bracket_exp = (_Bool)0;
            } else {
#line 1081
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 1084
            c2 = 0;
            {
#line 1084
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1084
              if (! (c2 < 256)) {
#line 1084
                goto while_break___1;
              }
              {
#line 1085
              tmp___8 = (*(pred->func))(c2);
              }
#line 1085
              if (tmp___8) {
                {
#line 1086
                setbit((unsigned int )c2, & ccl);
                }
              }
#line 1084
              c2 ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        } else {
#line 1089
          known_bracket_exp = (_Bool)0;
        }
        {
#line 1091
        colon_warning_state |= 8;
#line 1094
        c1 = bracket_fetch_wc(dfa);
#line 1095
        wc1 = dfa->lex.wctok;
        }
#line 1096
        goto __Cont;
      }
    }
#line 1103
    if (c == 92) {
#line 1103
      if (dfa->syntax.syntax_bits & 1UL) {
        {
#line 1106
        c = bracket_fetch_wc(dfa);
#line 1107
        wc = dfa->lex.wctok;
        }
      }
    }
#line 1110
    if (c1 == 256) {
      {
#line 1112
      c1 = bracket_fetch_wc(dfa);
#line 1113
      wc1 = dfa->lex.wctok;
      }
    }
#line 1116
    if (c1 == 45) {
      {
#line 1119
      tmp___9 = bracket_fetch_wc(dfa);
#line 1119
      c2___0 = tmp___9;
#line 1120
      wc2 = dfa->lex.wctok;
      }
#line 1125
      if (c2___0 == 91) {
#line 1125
        if ((int const   )*(dfa->lex.ptr + 0) == 46) {
#line 1127
          known_bracket_exp = (_Bool)0;
#line 1128
          c2___0 = ']';
        }
      }
#line 1131
      if (c2___0 == 93) {
#line 1135
        dfa->lex.ptr -= dfa->lex.cur_mb_len;
#line 1136
        dfa->lex.left += (size_t )dfa->lex.cur_mb_len;
      } else {
#line 1140
        if (c2___0 == 92) {
#line 1140
          if (dfa->syntax.syntax_bits & 1UL) {
            {
#line 1143
            c2___0 = bracket_fetch_wc(dfa);
#line 1144
            wc2 = dfa->lex.wctok;
            }
          }
        }
        {
#line 1147
        colon_warning_state |= 8;
#line 1148
        c1 = bracket_fetch_wc(dfa);
#line 1149
        wc1 = dfa->lex.wctok;
        }
#line 1152
        if (wc != wc2) {
#line 1152
          goto _L___3;
        } else
#line 1152
        if (wc == 4294967295U) {
          _L___3: /* CIL Label */ 
#line 1154
          if (dfa->simple_locale) {
#line 1154
            goto _L___2;
          } else {
            {
#line 1154
            tmp___11 = isasciidigit((char )c);
#line 1154
            tmp___12 = isasciidigit((char )c2___0);
            }
#line 1154
            if ((int )tmp___11 & (int )tmp___12) {
              _L___2: /* CIL Label */ 
#line 1157
              ci = c;
              {
#line 1157
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 1157
                if (! (ci <= c2___0)) {
#line 1157
                  goto while_break___2;
                }
#line 1158
                if (dfa->syntax.case_fold) {
                  {
#line 1158
                  tmp___10 = __ctype_b_loc();
                  }
#line 1158
                  if ((int const   )*(*tmp___10 + ci) & 1024) {
                    {
#line 1159
                    setbit_case_fold_c(ci, & ccl);
                    }
                  } else {
                    {
#line 1161
                    setbit((unsigned int )ci, & ccl);
                    }
                  }
                } else {
                  {
#line 1161
                  setbit((unsigned int )ci, & ccl);
                  }
                }
#line 1157
                ci ++;
              }
              while_break___2: /* CIL Label */ ;
              }
            } else {
#line 1164
              known_bracket_exp = (_Bool)0;
            }
          }
#line 1166
          goto __Cont;
        }
      }
    }
#line 1171
    if (c == 58) {
#line 1171
      tmp___13 = 2;
    } else {
#line 1171
      tmp___13 = 4;
    }
#line 1171
    colon_warning_state |= tmp___13;
#line 1173
    if (! dfa->localeinfo.multibyte) {
#line 1175
      if (dfa->syntax.case_fold) {
        {
#line 1175
        tmp___14 = __ctype_b_loc();
        }
#line 1175
        if ((int const   )*(*tmp___14 + c) & 1024) {
          {
#line 1176
          setbit_case_fold_c(c, & ccl);
          }
        } else {
          {
#line 1178
          setbit((unsigned int )c, & ccl);
          }
        }
      } else {
        {
#line 1178
        setbit((unsigned int )c, & ccl);
        }
      }
#line 1179
      goto __Cont;
    }
#line 1182
    if (wc == 4294967295U) {
#line 1183
      known_bracket_exp = (_Bool)0;
    } else {
#line 1187
      if (dfa->syntax.case_fold) {
        {
#line 1187
        tmp___15 = case_folded_counterparts(wc, (wchar_t *)(folded + 1));
#line 1187
        tmp___16 = tmp___15 + 1;
        }
      } else {
#line 1187
        tmp___16 = 1;
      }
#line 1187
      n = (unsigned int )tmp___16;
#line 1190
      folded[0] = (wchar_t )wc;
#line 1191
      i = 0U;
      {
#line 1191
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1191
        if (! (i < n)) {
#line 1191
          goto while_break___3;
        }
        {
#line 1192
        tmp___19 = setbit_wc((wint_t )folded[i], & ccl);
        }
#line 1192
        if (! tmp___19) {
          {
#line 1194
          tmp___17 = maybe_realloc((void *)dfa->lex.brack.chars, dfa->lex.brack.nchars,
                                   & dfa->lex.brack.nchars_alloc, (ptrdiff_t )-1,
                                   (ptrdiff_t )sizeof(*(dfa->lex.brack.chars)));
#line 1194
          dfa->lex.brack.chars = (wchar_t *)tmp___17;
#line 1198
          tmp___18 = dfa->lex.brack.nchars;
#line 1198
          (dfa->lex.brack.nchars) ++;
#line 1198
          *(dfa->lex.brack.chars + tmp___18) = folded[i];
          }
        }
#line 1191
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1030
    wc = wc1;
#line 1030
    c = c1;
#line 1030
    if (! (c != 93)) {
#line 1030
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1204
  if (colon_warning_state == 7) {
    {
#line 1205
    tmp___20 = gettext("character class syntax is [[:space:]], not [:space:]");
#line 1205
    dfawarn((char const   *)tmp___20);
    }
  }
#line 1207
  if (! known_bracket_exp) {
#line 1208
    return ((token )257);
  }
#line 1210
  if (dfa->localeinfo.multibyte) {
#line 1210
    if (invert) {
#line 1210
      goto _L___4;
    } else
#line 1210
    if (dfa->lex.brack.nchars != 0L) {
      _L___4: /* CIL Label */ 
      {
#line 1212
      dfa->lex.brack.invert = invert;
#line 1213
      tmp___23 = emptyset((charclass const   *)(& ccl));
      }
#line 1213
      if (tmp___23) {
#line 1213
        dfa->lex.brack.cset = (ptrdiff_t )-1;
      } else {
        {
#line 1213
        tmp___22 = charclass_index(dfa, & ccl);
#line 1213
        dfa->lex.brack.cset = tmp___22;
        }
      }
#line 1214
      return ((token )273);
    }
  }
#line 1217
  if (invert) {
    {
#line 1219
    notset(& ccl);
    }
#line 1220
    if (dfa->syntax.syntax_bits & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 1221
      clrbit((unsigned int )'\n', & ccl);
      }
    }
  }
  {
#line 1224
  tmp___24 = charclass_index(dfa, & ccl);
  }
#line 1224
  return (275L + tmp___24);
}
}
#line 1233 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void push_lex_state(struct dfa *dfa , struct lexptr *ls , char const   *s ) 
{ 


  {
  {
#line 1236
  ls->ptr = dfa->lex.ptr;
#line 1237
  ls->left = dfa->lex.left;
#line 1238
  dfa->lex.ptr = s;
#line 1239
  dfa->lex.left = strlen(s);
  }
#line 1240
  return;
}
}
#line 1242 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void pop_lex_state(struct dfa *dfa , struct lexptr  const  *ls ) 
{ 


  {
#line 1245
  dfa->lex.ptr = (char const   *)ls->ptr;
#line 1246
  dfa->lex.left = (size_t )ls->left;
#line 1247
  return;
}
}
#line 1249 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static token lex(struct dfa *dfa ) 
{ 
  _Bool backslash ;
  int i ;
  token tmp ;
  int c ;
  int tmp___0 ;
  char *tmp___1 ;
  token tmp___2 ;
  token tmp___3 ;
  token tmp___4 ;
  token tmp___5 ;
  token tmp___6 ;
  token tmp___7 ;
  token tmp___8 ;
  token tmp___9 ;
  token tmp___10 ;
  token tmp___11 ;
  token tmp___12 ;
  token tmp___13 ;
  char const   *p ;
  char const   *lim ;
  int tmp___14 ;
  int tmp___15 ;
  _Bool tmp___16 ;
  int tmp___17 ;
  _Bool tmp___18 ;
  char *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  token tmp___23 ;
  token tmp___24 ;
  token tmp___25 ;
  token tmp___26 ;
  token tmp___27 ;
  charclass ccl ;
  int c2 ;
  ptrdiff_t tmp___28 ;
  token tmp___29 ;
  charclass ccl___0 ;
  int c2___0 ;
  unsigned short const   **tmp___30 ;
  token tmp___31 ;
  ptrdiff_t tmp___32 ;
  struct lexptr ls ;
  charclass ccl___1 ;
  int c2___1 ;
  token tmp___33 ;
  ptrdiff_t tmp___34 ;
  struct lexptr ls___0 ;
  token tmp___35 ;
  token tmp___36 ;
  charclass ccl___2 ;
  token tmp___37 ;
  ptrdiff_t tmp___38 ;
  unsigned short const   **tmp___39 ;
  token tmp___40 ;

  {
#line 1252
  backslash = (_Bool)0;
#line 1260
  i = 0;
  {
#line 1260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1260
    if (! (i < 2)) {
#line 1260
      goto while_break;
    }
#line 1262
    if (! dfa->lex.left) {
#line 1263
      tmp = (token )-1;
#line 1263
      dfa->lex.lasttok = tmp;
#line 1263
      return (tmp);
    }
    {
#line 1264
    tmp___0 = fetch_wc(dfa);
#line 1264
    c = tmp___0;
    }
    {
#line 1268
    if (c == 92) {
#line 1268
      goto case_92;
    }
#line 1276
    if (c == 94) {
#line 1276
      goto case_94;
    }
#line 1285
    if (c == 36) {
#line 1285
      goto case_36;
    }
#line 1313
    if (c == 57) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 56) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 55) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 54) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 53) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 52) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 51) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 50) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 49) {
#line 1313
      goto case_57;
    }
#line 1321
    if (c == 96) {
#line 1321
      goto case_96;
    }
#line 1329
    if (c == 39) {
#line 1329
      goto case_39;
    }
#line 1337
    if (c == 60) {
#line 1337
      goto case_60;
    }
#line 1342
    if (c == 62) {
#line 1342
      goto case_62;
    }
#line 1347
    if (c == 98) {
#line 1347
      goto case_98;
    }
#line 1352
    if (c == 66) {
#line 1352
      goto case_66;
    }
#line 1357
    if (c == 63) {
#line 1357
      goto case_63;
    }
#line 1367
    if (c == 42) {
#line 1367
      goto case_42;
    }
#line 1375
    if (c == 43) {
#line 1375
      goto case_43;
    }
#line 1385
    if (c == 123) {
#line 1385
      goto case_123;
    }
#line 1443
    if (c == 124) {
#line 1443
      goto case_124;
    }
#line 1451
    if (c == 10) {
#line 1451
      goto case_10;
    }
#line 1458
    if (c == 40) {
#line 1458
      goto case_40;
    }
#line 1465
    if (c == 41) {
#line 1465
      goto case_41;
    }
#line 1475
    if (c == 46) {
#line 1475
      goto case_46;
    }
#line 1498
    if (c == 83) {
#line 1498
      goto case_83;
    }
#line 1498
    if (c == 115) {
#line 1498
      goto case_83;
    }
#line 1531
    if (c == 87) {
#line 1531
      goto case_87;
    }
#line 1531
    if (c == 119) {
#line 1531
      goto case_87;
    }
#line 1564
    if (c == 91) {
#line 1564
      goto case_91;
    }
#line 1570
    goto normal_char;
    case_92: /* CIL Label */ 
#line 1269
    if (backslash) {
#line 1270
      goto normal_char;
    }
#line 1271
    if (dfa->lex.left == 0UL) {
      {
#line 1272
      tmp___1 = gettext("unfinished \\ escape");
#line 1272
      dfaerror((char const   *)tmp___1);
      }
    }
#line 1273
    backslash = (_Bool)1;
#line 1274
    goto switch_break;
    case_94: /* CIL Label */ 
#line 1277
    if (backslash) {
#line 1278
      goto normal_char;
    }
#line 1279
    if (dfa->syntax.syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1282
      tmp___2 = (token )258;
#line 1282
      dfa->lex.lasttok = tmp___2;
#line 1282
      return (tmp___2);
    } else
#line 1279
    if (dfa->lex.lasttok == -1L) {
#line 1282
      tmp___2 = (token )258;
#line 1282
      dfa->lex.lasttok = tmp___2;
#line 1282
      return (tmp___2);
    } else
#line 1279
    if (dfa->lex.lasttok == 270L) {
#line 1282
      tmp___2 = (token )258;
#line 1282
      dfa->lex.lasttok = tmp___2;
#line 1282
      return (tmp___2);
    } else
#line 1279
    if (dfa->lex.lasttok == 269L) {
#line 1282
      tmp___2 = (token )258;
#line 1282
      dfa->lex.lasttok = tmp___2;
#line 1282
      return (tmp___2);
    }
#line 1283
    goto normal_char;
    case_36: /* CIL Label */ 
#line 1286
    if (backslash) {
#line 1287
      goto normal_char;
    }
#line 1288
    if (dfa->syntax.syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1302
      tmp___3 = (token )259;
#line 1302
      dfa->lex.lasttok = tmp___3;
#line 1302
      return (tmp___3);
    } else
#line 1288
    if (dfa->lex.left == 0UL) {
#line 1302
      tmp___3 = (token )259;
#line 1302
      dfa->lex.lasttok = tmp___3;
#line 1302
      return (tmp___3);
    } else
#line 1288
    if (dfa->lex.left > (size_t )(! (dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1288
      if ((int const   )*(dfa->lex.ptr + (! (dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ((int const   )*(dfa->lex.ptr + 0) == 92))) == 41) {
#line 1302
        tmp___3 = (token )259;
#line 1302
        dfa->lex.lasttok = tmp___3;
#line 1302
        return (tmp___3);
      } else {
#line 1288
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1288
    if (dfa->lex.left > (size_t )(! (dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1288
      if ((int const   )*(dfa->lex.ptr + (! (dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ((int const   )*(dfa->lex.ptr + 0) == 92))) == 124) {
#line 1302
        tmp___3 = (token )259;
#line 1302
        dfa->lex.lasttok = tmp___3;
#line 1302
        return (tmp___3);
      } else {
#line 1288
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1288
    if (dfa->syntax.syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1288
      if (dfa->lex.left > 0UL) {
#line 1288
        if ((int const   )*(dfa->lex.ptr + 0) == 10) {
#line 1302
          tmp___3 = (token )259;
#line 1302
          dfa->lex.lasttok = tmp___3;
#line 1302
          return (tmp___3);
        }
      }
    }
#line 1303
    goto normal_char;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1314
    if (backslash) {
#line 1314
      if (! (dfa->syntax.syntax_bits & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1316
        dfa->lex.laststart = (_Bool)0;
#line 1317
        tmp___4 = (token )257;
#line 1317
        dfa->lex.lasttok = tmp___4;
#line 1317
        return (tmp___4);
      }
    }
#line 1319
    goto normal_char;
    case_96: /* CIL Label */ 
#line 1322
    if (backslash) {
#line 1322
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1325
        tmp___5 = (token )258;
#line 1325
        dfa->lex.lasttok = tmp___5;
#line 1325
        return (tmp___5);
      }
    }
#line 1327
    goto normal_char;
    case_39: /* CIL Label */ 
#line 1330
    if (backslash) {
#line 1330
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1333
        tmp___6 = (token )259;
#line 1333
        dfa->lex.lasttok = tmp___6;
#line 1333
        return (tmp___6);
      }
    }
#line 1335
    goto normal_char;
    case_60: /* CIL Label */ 
#line 1338
    if (backslash) {
#line 1338
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1339
        tmp___7 = (token )260;
#line 1339
        dfa->lex.lasttok = tmp___7;
#line 1339
        return (tmp___7);
      }
    }
#line 1340
    goto normal_char;
    case_62: /* CIL Label */ 
#line 1343
    if (backslash) {
#line 1343
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1344
        tmp___8 = (token )261;
#line 1344
        dfa->lex.lasttok = tmp___8;
#line 1344
        return (tmp___8);
      }
    }
#line 1345
    goto normal_char;
    case_98: /* CIL Label */ 
#line 1348
    if (backslash) {
#line 1348
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1349
        tmp___9 = (token )262;
#line 1349
        dfa->lex.lasttok = tmp___9;
#line 1349
        return (tmp___9);
      }
    }
#line 1350
    goto normal_char;
    case_66: /* CIL Label */ 
#line 1353
    if (backslash) {
#line 1353
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1354
        tmp___10 = (token )263;
#line 1354
        dfa->lex.lasttok = tmp___10;
#line 1354
        return (tmp___10);
      }
    }
#line 1355
    goto normal_char;
    case_63: /* CIL Label */ 
#line 1358
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1359
      goto normal_char;
    }
#line 1360
    if ((int )backslash != ((dfa->syntax.syntax_bits & (1UL << 1)) != 0UL)) {
#line 1361
      goto normal_char;
    }
#line 1362
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1362
      if (dfa->lex.laststart) {
#line 1364
        goto normal_char;
      }
    }
#line 1365
    tmp___11 = (token )264;
#line 1365
    dfa->lex.lasttok = tmp___11;
#line 1365
    return (tmp___11);
    case_42: /* CIL Label */ 
#line 1368
    if (backslash) {
#line 1369
      goto normal_char;
    }
#line 1370
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1370
      if (dfa->lex.laststart) {
#line 1372
        goto normal_char;
      }
    }
#line 1373
    tmp___12 = (token )265;
#line 1373
    dfa->lex.lasttok = tmp___12;
#line 1373
    return (tmp___12);
    case_43: /* CIL Label */ 
#line 1376
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1377
      goto normal_char;
    }
#line 1378
    if ((int )backslash != ((dfa->syntax.syntax_bits & (1UL << 1)) != 0UL)) {
#line 1379
      goto normal_char;
    }
#line 1380
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1380
      if (dfa->lex.laststart) {
#line 1382
        goto normal_char;
      }
    }
#line 1383
    tmp___13 = (token )266;
#line 1383
    dfa->lex.lasttok = tmp___13;
#line 1383
    return (tmp___13);
    case_123: /* CIL Label */ 
#line 1386
    if (! (dfa->syntax.syntax_bits & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1387
      goto normal_char;
    }
#line 1388
    if ((int )backslash != ((dfa->syntax.syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1389
      goto normal_char;
    }
#line 1390
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1390
      if (dfa->lex.laststart) {
#line 1392
        goto normal_char;
      }
    }
#line 1401
    p = dfa->lex.ptr;
#line 1402
    lim = p + dfa->lex.left;
#line 1403
    tmp___14 = -1;
#line 1403
    dfa->lex.maxrep = tmp___14;
#line 1403
    dfa->lex.minrep = tmp___14;
    {
#line 1404
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1404
      if ((unsigned long )p != (unsigned long )lim) {
        {
#line 1404
        tmp___16 = isasciidigit((char )*p);
        }
#line 1404
        if (! tmp___16) {
#line 1404
          goto while_break___0;
        }
      } else {
#line 1404
        goto while_break___0;
      }
#line 1405
      if (dfa->lex.minrep < 0) {
#line 1405
        dfa->lex.minrep = (int )((int const   )*p - 48);
      } else {
#line 1405
        if (32768 < (dfa->lex.minrep * 10 + (int )*p) - 48) {
#line 1405
          tmp___15 = 32768;
        } else {
#line 1405
          tmp___15 = (dfa->lex.minrep * 10 + (int )*p) - 48;
        }
#line 1405
        dfa->lex.minrep = tmp___15;
      }
#line 1404
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1409
    if ((unsigned long )p != (unsigned long )lim) {
#line 1411
      if ((int const   )*p != 44) {
#line 1412
        dfa->lex.maxrep = dfa->lex.minrep;
      } else {
#line 1415
        if (dfa->lex.minrep < 0) {
#line 1416
          dfa->lex.minrep = 0;
        }
        {
#line 1417
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1417
          p ++;
#line 1417
          if ((unsigned long )p != (unsigned long )lim) {
            {
#line 1417
            tmp___18 = isasciidigit((char )*p);
            }
#line 1417
            if (! tmp___18) {
#line 1417
              goto while_break___1;
            }
          } else {
#line 1417
            goto while_break___1;
          }
#line 1418
          if (dfa->lex.maxrep < 0) {
#line 1418
            dfa->lex.maxrep = (int )((int const   )*p - 48);
          } else {
#line 1418
            if (32768 < (dfa->lex.maxrep * 10 + (int )*p) - 48) {
#line 1418
              tmp___17 = 32768;
            } else {
#line 1418
              tmp___17 = (dfa->lex.maxrep * 10 + (int )*p) - 48;
            }
#line 1418
            dfa->lex.maxrep = tmp___17;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 1425
    if (! backslash) {
#line 1425
      goto _L___5;
    } else
#line 1425
    if ((unsigned long )p != (unsigned long )lim) {
#line 1425
      tmp___20 = p;
#line 1425
      p ++;
#line 1425
      if ((int const   )*tmp___20 == 92) {
        _L___5: /* CIL Label */ 
#line 1425
        if ((unsigned long )p != (unsigned long )lim) {
#line 1425
          tmp___21 = p;
#line 1425
          p ++;
#line 1425
          if ((int const   )*tmp___21 == 125) {
#line 1425
            if (0 <= dfa->lex.minrep) {
#line 1425
              if (! (dfa->lex.maxrep < 0)) {
#line 1425
                if (! (dfa->lex.minrep <= dfa->lex.maxrep)) {
#line 1425
                  goto _L___6;
                }
              }
            } else {
#line 1425
              goto _L___6;
            }
          } else {
#line 1425
            goto _L___6;
          }
        } else {
#line 1425
          goto _L___6;
        }
      } else {
#line 1425
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
#line 1431
      if (dfa->syntax.syntax_bits & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1432
        goto normal_char;
      }
      {
#line 1433
      tmp___19 = gettext("invalid content of \\{\\}");
#line 1433
      dfaerror((char const   *)tmp___19);
      }
    }
#line 1435
    if (32767 < dfa->lex.maxrep) {
      {
#line 1436
      tmp___22 = gettext("regular expression too big");
#line 1436
      dfaerror((char const   *)tmp___22);
      }
    }
#line 1437
    dfa->lex.ptr = p;
#line 1438
    dfa->lex.left = (size_t )(lim - p);
#line 1440
    dfa->lex.laststart = (_Bool)0;
#line 1441
    tmp___23 = (token )267;
#line 1441
    dfa->lex.lasttok = tmp___23;
#line 1441
    return (tmp___23);
    case_124: /* CIL Label */ 
#line 1444
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1445
      goto normal_char;
    }
#line 1446
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1447
      goto normal_char;
    }
#line 1448
    dfa->lex.laststart = (_Bool)1;
#line 1449
    tmp___24 = (token )269;
#line 1449
    dfa->lex.lasttok = tmp___24;
#line 1449
    return (tmp___24);
    case_10: /* CIL Label */ 
#line 1452
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1454
      goto normal_char;
    } else
#line 1452
    if (backslash) {
#line 1454
      goto normal_char;
    } else
#line 1452
    if (! (dfa->syntax.syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1454
      goto normal_char;
    }
#line 1455
    dfa->lex.laststart = (_Bool)1;
#line 1456
    tmp___25 = (token )269;
#line 1456
    dfa->lex.lasttok = tmp___25;
#line 1456
    return (tmp___25);
    case_40: /* CIL Label */ 
#line 1459
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1460
      goto normal_char;
    }
#line 1461
    (dfa->lex.parens) ++;
#line 1462
    dfa->lex.laststart = (_Bool)1;
#line 1463
    tmp___26 = (token )270;
#line 1463
    dfa->lex.lasttok = tmp___26;
#line 1463
    return (tmp___26);
    case_41: /* CIL Label */ 
#line 1466
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1467
      goto normal_char;
    }
#line 1468
    if (dfa->lex.parens == 0UL) {
#line 1468
      if (dfa->syntax.syntax_bits & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1470
        goto normal_char;
      }
    }
#line 1471
    (dfa->lex.parens) --;
#line 1472
    dfa->lex.laststart = (_Bool)0;
#line 1473
    tmp___27 = (token )271;
#line 1473
    dfa->lex.lasttok = tmp___27;
#line 1473
    return (tmp___27);
    case_46: /* CIL Label */ 
#line 1476
    if (backslash) {
#line 1477
      goto normal_char;
    }
#line 1478
    if (dfa->canychar == 0xffffffffffffffffUL) {
      {
#line 1481
      fillset(& ccl);
      }
#line 1482
      if (! (dfa->syntax.syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
        {
#line 1483
        clrbit((unsigned int )'\n', & ccl);
        }
      }
#line 1484
      if (dfa->syntax.syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
#line 1485
        clrbit((unsigned int )'\000', & ccl);
        }
      }
#line 1486
      if (dfa->localeinfo.multibyte) {
#line 1487
        c2 = 0;
        {
#line 1487
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1487
          if (! (c2 < 256)) {
#line 1487
            goto while_break___2;
          }
#line 1488
          if (dfa->localeinfo.sbctowc[c2] == 4294967295U) {
            {
#line 1489
            clrbit((unsigned int )c2, & ccl);
            }
          }
#line 1487
          c2 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 1490
      tmp___28 = charclass_index(dfa, & ccl);
#line 1490
      dfa->canychar = (size_t )tmp___28;
      }
    }
#line 1492
    dfa->lex.laststart = (_Bool)0;
#line 1493
    if (dfa->localeinfo.multibyte) {
#line 1493
      tmp___29 = (token )272;
    } else {
#line 1493
      tmp___29 = (token )(275UL + dfa->canychar);
    }
#line 1493
    dfa->lex.lasttok = tmp___29;
#line 1493
    return (tmp___29);
    case_83: /* CIL Label */ 
    case_115: /* CIL Label */ 
#line 1499
    if (! backslash) {
#line 1500
      goto normal_char;
    } else
#line 1499
    if (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1500
      goto normal_char;
    }
#line 1501
    if (! dfa->localeinfo.multibyte) {
      {
#line 1504
      zeroset(& ccl___0);
#line 1505
      c2___0 = 0;
      }
      {
#line 1505
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1505
        if (! (c2___0 < 256)) {
#line 1505
          goto while_break___3;
        }
        {
#line 1506
        tmp___30 = __ctype_b_loc();
        }
#line 1506
        if ((int const   )*(*tmp___30 + c2___0) & 8192) {
          {
#line 1507
          setbit((unsigned int )c2___0, & ccl___0);
          }
        }
#line 1505
        c2___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1508
      if (c == 83) {
        {
#line 1509
        notset(& ccl___0);
        }
      }
      {
#line 1510
      dfa->lex.laststart = (_Bool)0;
#line 1511
      tmp___32 = charclass_index(dfa, & ccl___0);
#line 1511
      tmp___31 = 275L + tmp___32;
#line 1511
      dfa->lex.lasttok = tmp___31;
      }
#line 1511
      return (tmp___31);
    }
    {
#line 1522
    push_lex_state(dfa, & ls, "^[:space:]]" + (c == 115));
#line 1523
    dfa->lex.lasttok = parse_bracket_exp(dfa);
#line 1524
    pop_lex_state(dfa, (struct lexptr  const  *)(& ls));
#line 1527
    dfa->lex.laststart = (_Bool)0;
    }
#line 1528
    return (dfa->lex.lasttok);
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
#line 1532
    if (! backslash) {
#line 1533
      goto normal_char;
    } else
#line 1532
    if (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1533
      goto normal_char;
    }
#line 1535
    if (! dfa->localeinfo.multibyte) {
      {
#line 1538
      zeroset(& ccl___1);
#line 1539
      c2___1 = 0;
      }
      {
#line 1539
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1539
        if (! (c2___1 < 256)) {
#line 1539
          goto while_break___4;
        }
#line 1540
        if ((int )dfa->syntax.sbit[c2___1] == 2) {
          {
#line 1541
          setbit((unsigned int )c2___1, & ccl___1);
          }
        }
#line 1539
        c2___1 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1542
      if (c == 87) {
        {
#line 1543
        notset(& ccl___1);
        }
      }
      {
#line 1544
      dfa->lex.laststart = (_Bool)0;
#line 1545
      tmp___34 = charclass_index(dfa, & ccl___1);
#line 1545
      tmp___33 = 275L + tmp___34;
#line 1545
      dfa->lex.lasttok = tmp___33;
      }
#line 1545
      return (tmp___33);
    }
    {
#line 1556
    push_lex_state(dfa, & ls___0, "^_[:alnum:]]" + (c == 119));
#line 1557
    dfa->lex.lasttok = parse_bracket_exp(dfa);
#line 1558
    pop_lex_state(dfa, (struct lexptr  const  *)(& ls___0));
#line 1561
    dfa->lex.laststart = (_Bool)0;
    }
#line 1562
    return (dfa->lex.lasttok);
    case_91: /* CIL Label */ 
#line 1565
    if (backslash) {
#line 1566
      goto normal_char;
    }
    {
#line 1567
    dfa->lex.laststart = (_Bool)0;
#line 1568
    tmp___35 = parse_bracket_exp(dfa);
#line 1568
    dfa->lex.lasttok = tmp___35;
    }
#line 1568
    return (tmp___35);
    normal_char: 
    switch_default: /* CIL Label */ 
#line 1572
    dfa->lex.laststart = (_Bool)0;
#line 1575
    if (dfa->localeinfo.multibyte) {
#line 1576
      tmp___36 = (token )274;
#line 1576
      dfa->lex.lasttok = tmp___36;
#line 1576
      return (tmp___36);
    }
#line 1578
    if (dfa->syntax.case_fold) {
      {
#line 1578
      tmp___39 = __ctype_b_loc();
      }
#line 1578
      if ((int const   )*(*tmp___39 + c) & 1024) {
        {
#line 1581
        zeroset(& ccl___2);
#line 1582
        setbit_case_fold_c(c, & ccl___2);
#line 1583
        tmp___38 = charclass_index(dfa, & ccl___2);
#line 1583
        tmp___37 = 275L + tmp___38;
#line 1583
        dfa->lex.lasttok = tmp___37;
        }
#line 1583
        return (tmp___37);
      }
    }
#line 1586
    tmp___40 = (token )c;
#line 1586
    dfa->lex.lasttok = tmp___40;
#line 1586
    return (tmp___40);
    switch_break: /* CIL Label */ ;
    }
#line 1260
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1592
  abort();
  }
#line 1593
  return ((token )-1);
}
}
#line 1596 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void addtok_mb(struct dfa *dfa , token t , char mbprop ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1599
  if (dfa->talloc == dfa->tindex) {
    {
#line 1601
    tmp = x2nrealloc((void *)dfa->tokens, & dfa->talloc, sizeof(*(dfa->tokens)));
#line 1601
    dfa->tokens = (token *)tmp;
    }
#line 1603
    if (dfa->localeinfo.multibyte) {
      {
#line 1604
      tmp___0 = xnrealloc((void *)dfa->multibyte_prop, dfa->talloc, sizeof(*(dfa->multibyte_prop)));
#line 1604
      dfa->multibyte_prop = (char *)tmp___0;
      }
    }
  }
#line 1607
  if (dfa->localeinfo.multibyte) {
#line 1608
    *(dfa->multibyte_prop + dfa->tindex) = mbprop;
  }
#line 1609
  tmp___1 = dfa->tindex;
#line 1609
  (dfa->tindex) ++;
#line 1609
  *(dfa->tokens + tmp___1) = t;
  {
#line 1615
  if (t == 266L) {
#line 1615
    goto case_266;
  }
#line 1615
  if (t == 265L) {
#line 1615
    goto case_266;
  }
#line 1615
  if (t == 264L) {
#line 1615
    goto case_266;
  }
#line 1619
  if (t == 269L) {
#line 1619
    goto case_269;
  }
#line 1619
  if (t == 268L) {
#line 1619
    goto case_269;
  }
#line 1623
  if (t == 257L) {
#line 1623
    goto case_257;
  }
#line 1629
  if (t == 256L) {
#line 1629
    goto case_256;
  }
#line 1626
  goto switch_default;
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
#line 1616
  goto switch_break;
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
#line 1620
  (dfa->parse.depth) --;
#line 1621
  goto switch_break;
  case_257: /* CIL Label */ 
#line 1624
  dfa->fast = (_Bool)0;
  switch_default: /* CIL Label */ 
#line 1627
  (dfa->nleaves) ++;
  case_256: /* CIL Label */ 
#line 1630
  (dfa->parse.depth) ++;
#line 1631
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1633
  if (dfa->parse.depth > dfa->depth) {
#line 1634
    dfa->depth = dfa->parse.depth;
  }
#line 1635
  return;
}
}
#line 1637
static void addtok_wc(struct dfa *dfa , wint_t wc ) ;
#line 1641 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void addtok(struct dfa *dfa , token t ) 
{ 
  _Bool need_or ;
  ptrdiff_t i ;

  {
#line 1644
  if (dfa->localeinfo.multibyte) {
#line 1644
    if (t == 273L) {
#line 1646
      need_or = (_Bool)0;
#line 1650
      i = (ptrdiff_t )0;
      {
#line 1650
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1650
        if (! (i < dfa->lex.brack.nchars)) {
#line 1650
          goto while_break;
        }
        {
#line 1652
        addtok_wc(dfa, (wint_t )*(dfa->lex.brack.chars + i));
        }
#line 1653
        if (need_or) {
          {
#line 1654
          addtok(dfa, (token )269);
          }
        }
#line 1655
        need_or = (_Bool)1;
#line 1650
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1657
      dfa->lex.brack.nchars = (ptrdiff_t )0;
#line 1661
      if (dfa->lex.brack.cset != -1L) {
        {
#line 1663
        addtok(dfa, 275L + dfa->lex.brack.cset);
        }
#line 1664
        if (need_or) {
          {
#line 1665
          addtok(dfa, (token )269);
          }
        }
      }
    } else {
      {
#line 1670
      addtok_mb(dfa, t, (char)3);
      }
    }
  } else {
    {
#line 1670
    addtok_mb(dfa, t, (char)3);
    }
  }
#line 1672
  return;
}
}
#line 1680 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void addtok_wc(struct dfa *dfa , wint_t wc ) 
{ 
  unsigned char buf[16] ;
  mbstate_t s ;
  size_t stored_bytes ;
  size_t tmp ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 1684
  s.__count = 0;
#line 1684
  s.__value.__wch = 0U;
#line 1685
  tmp = wcrtomb((char */* __restrict  */)((char *)(buf)), (wchar_t )wc, (mbstate_t */* __restrict  */)(& s));
#line 1685
  stored_bytes = tmp;
  }
#line 1687
  if (stored_bytes != 0xffffffffffffffffUL) {
#line 1688
    dfa->lex.cur_mb_len = (int )stored_bytes;
  } else {
#line 1693
    dfa->lex.cur_mb_len = 1;
#line 1694
    buf[0] = (unsigned char)0;
  }
#line 1697
  if (dfa->lex.cur_mb_len == 1) {
#line 1697
    tmp___0 = 3;
  } else {
#line 1697
    tmp___0 = 1;
  }
  {
#line 1697
  addtok_mb(dfa, (token )buf[0], (char )tmp___0);
#line 1698
  i = 1;
  }
  {
#line 1698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1698
    if (! (i < dfa->lex.cur_mb_len)) {
#line 1698
      goto while_break;
    }
#line 1700
    if (i == dfa->lex.cur_mb_len - 1) {
#line 1700
      tmp___1 = 2;
    } else {
#line 1700
      tmp___1 = 0;
    }
    {
#line 1700
    addtok_mb(dfa, (token )buf[i], (char )tmp___1);
#line 1701
    addtok(dfa, (token )268);
#line 1698
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1703
  return;
}
}
#line 1708
static void add_utf8_anychar(struct dfa *dfa ) ;
#line 1708 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static charclass const   utf8_classes[5]  = {      {{0UL, 0UL, (4294967295UL << 32) + 4294967295UL, 0UL}}, 
        {{(4294967295UL << 32) + 4294967295UL, (4294967295UL << 32) + 4294967295UL, 0UL,
       0UL}}, 
        {{0UL, 0UL, 0UL, 4294967292UL}}, 
        {{0UL, 0UL, 0UL, 65535UL << 32}}, 
        {{0UL, 0UL, 0UL, 16711680UL << 32}}};
#line 1705 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void add_utf8_anychar(struct dfa *dfa ) 
{ 
  unsigned int n ;
  unsigned int i ;
  charclass c ;
  ptrdiff_t tmp ;
  unsigned int i___0 ;

  {
#line 1724
  n = (unsigned int )(sizeof(utf8_classes) / sizeof(utf8_classes[0]));
#line 1727
  if (dfa->utf8_anychar_classes[0] == 0L) {
#line 1728
    i = 0U;
    {
#line 1728
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1728
      if (! (i < n)) {
#line 1728
        goto while_break;
      }
#line 1730
      c = utf8_classes[i];
#line 1731
      if (i == 1U) {
#line 1733
        if (! (dfa->syntax.syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
          {
#line 1734
          clrbit((unsigned int )'\n', & c);
          }
        }
#line 1735
        if (dfa->syntax.syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          {
#line 1736
          clrbit((unsigned int )'\000', & c);
          }
        }
      }
      {
#line 1738
      tmp = charclass_index(dfa, & c);
#line 1738
      dfa->utf8_anychar_classes[i] = 275L + tmp;
#line 1728
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1752
  i___0 = 1U;
  {
#line 1752
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1752
    if (! (i___0 < n)) {
#line 1752
      goto while_break___0;
    }
    {
#line 1753
    addtok(dfa, dfa->utf8_anychar_classes[i___0]);
#line 1752
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1754
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1754
    i___0 --;
#line 1754
    if (! (i___0 > 1U)) {
#line 1754
      goto while_break___1;
    }
    {
#line 1756
    addtok(dfa, dfa->utf8_anychar_classes[0]);
#line 1757
    addtok(dfa, (token )268);
#line 1758
    addtok(dfa, (token )269);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1760
  return;
}
}
#line 1797 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void atom(struct dfa *dfa ) 
{ 
  wchar_t folded[32] ;
  unsigned int n ;
  int tmp ;
  unsigned int i ;
  char *tmp___0 ;

  {
#line 1800
  if (dfa->parse.tok == 274L) {
#line 1802
    if (dfa->lex.wctok == 4294967295U) {
      {
#line 1803
      addtok(dfa, (token )257);
      }
    } else {
      {
#line 1806
      addtok_wc(dfa, dfa->lex.wctok);
      }
#line 1808
      if (dfa->syntax.case_fold) {
        {
#line 1811
        tmp = case_folded_counterparts(dfa->lex.wctok, (wchar_t *)(folded));
#line 1811
        n = (unsigned int )tmp;
#line 1813
        i = 0U;
        }
        {
#line 1813
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1813
          if (! (i < n)) {
#line 1813
            goto while_break;
          }
          {
#line 1815
          addtok_wc(dfa, (wint_t )folded[i]);
#line 1816
          addtok(dfa, (token )269);
#line 1813
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 1821
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1823
  if (dfa->parse.tok == 272L) {
#line 1823
    if (dfa->localeinfo.using_utf8) {
      {
#line 1832
      add_utf8_anychar(dfa);
#line 1833
      dfa->parse.tok = lex(dfa);
      }
    } else {
#line 1823
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1835
  if (0L <= dfa->parse.tok) {
#line 1835
    if (dfa->parse.tok < 256L) {
      {
#line 1842
      addtok(dfa, dfa->parse.tok);
#line 1843
      dfa->parse.tok = lex(dfa);
      }
    } else {
#line 1835
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1835
  if (dfa->parse.tok >= 275L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 257L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 258L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 259L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 260L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 272L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 273L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 261L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 262L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 263L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1845
  if (dfa->parse.tok == 270L) {
    {
#line 1847
    dfa->parse.tok = lex(dfa);
#line 1848
    regexp(dfa);
    }
#line 1849
    if (dfa->parse.tok != 271L) {
      {
#line 1850
      tmp___0 = gettext("unbalanced (");
#line 1850
      dfaerror((char const   *)tmp___0);
      }
    }
    {
#line 1851
    dfa->parse.tok = lex(dfa);
    }
  } else {
    {
#line 1854
    addtok(dfa, (token )256);
    }
  }
#line 1855
  return;
}
}
#line 1858 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static size_t __attribute__((__pure__))  nsubtoks(struct dfa  const  *dfa , size_t tindex ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t ntoks1 ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 1867
  if (*(dfa->tokens + (tindex - 1UL)) == 266L) {
#line 1867
    goto case_266;
  }
#line 1867
  if (*(dfa->tokens + (tindex - 1UL)) == 265L) {
#line 1867
    goto case_266;
  }
#line 1867
  if (*(dfa->tokens + (tindex - 1UL)) == 264L) {
#line 1867
    goto case_266;
  }
#line 1870
  if (*(dfa->tokens + (tindex - 1UL)) == 269L) {
#line 1870
    goto case_269;
  }
#line 1870
  if (*(dfa->tokens + (tindex - 1UL)) == 268L) {
#line 1870
    goto case_269;
  }
#line 1863
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1864
  return ((size_t __attribute__((__pure__))  )1);
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
  {
#line 1868
  tmp = nsubtoks(dfa, tindex - 1UL);
  }
#line 1868
  return ((size_t __attribute__((__pure__))  )1 + tmp);
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
  {
#line 1872
  tmp___0 = nsubtoks(dfa, tindex - 1UL);
#line 1872
  ntoks1 = (size_t )tmp___0;
#line 1873
  tmp___1 = nsubtoks(dfa, (tindex - 1UL) - ntoks1);
  }
#line 1873
  return ((size_t __attribute__((__pure__))  )((1UL + ntoks1) + (size_t )tmp___1));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1879 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void copytoks(struct dfa *dfa , size_t tindex , size_t ntokens ) 
{ 
  size_t i ;
  size_t i___0 ;

  {
#line 1882
  if (dfa->localeinfo.multibyte) {
#line 1883
    i = (size_t )0;
    {
#line 1883
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1883
      if (! (i < ntokens)) {
#line 1883
        goto while_break;
      }
      {
#line 1884
      addtok_mb(dfa, *(dfa->tokens + (tindex + i)), *(dfa->multibyte_prop + (tindex + i)));
#line 1883
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1887
    i___0 = (size_t )0;
    {
#line 1887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1887
      if (! (i___0 < ntokens)) {
#line 1887
        goto while_break___0;
      }
      {
#line 1888
      addtok_mb(dfa, *(dfa->tokens + (tindex + i___0)), (char)3);
#line 1887
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1889
  return;
}
}
#line 1891 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void closure(struct dfa *dfa ) 
{ 
  size_t ntokens ;
  size_t __attribute__((__pure__))  tmp ;
  size_t tindex ;
  int i ;
  size_t __attribute__((__pure__))  tmp___0 ;

  {
  {
#line 1894
  atom(dfa);
  }
  {
#line 1895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1895
    if (! (dfa->parse.tok == 264L)) {
#line 1895
      if (! (dfa->parse.tok == 265L)) {
#line 1895
        if (! (dfa->parse.tok == 266L)) {
#line 1895
          if (! (dfa->parse.tok == 267L)) {
#line 1895
            goto while_break;
          }
        }
      }
    }
#line 1897
    if (dfa->parse.tok == 267L) {
#line 1897
      if (dfa->lex.minrep) {
#line 1897
        goto _L___0;
      } else
#line 1897
      if (dfa->lex.maxrep) {
        _L___0: /* CIL Label */ 
        {
#line 1899
        tmp = nsubtoks((struct dfa  const  *)dfa, dfa->tindex);
#line 1899
        ntokens = (size_t )tmp;
#line 1900
        tindex = dfa->tindex - ntokens;
        }
#line 1901
        if (dfa->lex.maxrep < 0) {
          {
#line 1902
          addtok(dfa, (token )266);
          }
        }
#line 1903
        if (dfa->lex.minrep == 0) {
          {
#line 1904
          addtok(dfa, (token )264);
          }
        }
#line 1906
        i = 1;
        {
#line 1906
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1906
          if (! (i < dfa->lex.minrep)) {
#line 1906
            goto while_break___0;
          }
          {
#line 1908
          copytoks(dfa, tindex, ntokens);
#line 1909
          addtok(dfa, (token )268);
#line 1906
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1911
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1911
          if (! (i < dfa->lex.maxrep)) {
#line 1911
            goto while_break___1;
          }
          {
#line 1913
          copytoks(dfa, tindex, ntokens);
#line 1914
          addtok(dfa, (token )264);
#line 1915
          addtok(dfa, (token )268);
#line 1911
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1917
        dfa->parse.tok = lex(dfa);
        }
      } else {
#line 1897
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1919
    if (dfa->parse.tok == 267L) {
      {
#line 1921
      tmp___0 = nsubtoks((struct dfa  const  *)dfa, dfa->tindex);
#line 1921
      dfa->tindex -= (size_t )tmp___0;
#line 1922
      dfa->parse.tok = lex(dfa);
#line 1923
      closure(dfa);
      }
    } else {
      {
#line 1927
      addtok(dfa, dfa->parse.tok);
#line 1928
      dfa->parse.tok = lex(dfa);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1930
  return;
}
}
#line 1932 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void branch(struct dfa *dfa ) 
{ 


  {
  {
#line 1935
  closure(dfa);
  }
  {
#line 1936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1936
    if (dfa->parse.tok != 271L) {
#line 1936
      if (dfa->parse.tok != 269L) {
#line 1936
        if (! (dfa->parse.tok >= 0L)) {
#line 1936
          goto while_break;
        }
      } else {
#line 1936
        goto while_break;
      }
    } else {
#line 1936
      goto while_break;
    }
    {
#line 1939
    closure(dfa);
#line 1940
    addtok(dfa, (token )268);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1942
  return;
}
}
#line 1944 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void regexp(struct dfa *dfa ) 
{ 


  {
  {
#line 1947
  branch(dfa);
  }
  {
#line 1948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1948
    if (! (dfa->parse.tok == 269L)) {
#line 1948
      goto while_break;
    }
    {
#line 1950
    dfa->parse.tok = lex(dfa);
#line 1951
    branch(dfa);
#line 1952
    addtok(dfa, (token )269);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1954
  return;
}
}
#line 1959 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void dfaparse(char const   *s , size_t len , struct dfa *d ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 1962
  d->lex.ptr = s;
#line 1963
  d->lex.left = len;
#line 1964
  d->lex.lasttok = (token )-1;
#line 1965
  d->lex.laststart = (_Bool)1;
#line 1967
  if (! d->syntax.syntax_bits_set) {
    {
#line 1968
    tmp = gettext("no syntax specified");
#line 1968
    dfaerror((char const   *)tmp);
    }
  }
  {
#line 1970
  d->parse.tok = lex(d);
#line 1971
  d->parse.depth = d->depth;
#line 1973
  regexp(d);
  }
#line 1975
  if (d->parse.tok != -1L) {
    {
#line 1976
    tmp___0 = gettext("unbalanced )");
#line 1976
    dfaerror((char const   *)tmp___0);
    }
  }
  {
#line 1978
  addtok(d, (token )(0xffffffffffffffffUL - d->nregexps));
#line 1979
  addtok(d, (token )268);
  }
#line 1981
  if (d->nregexps) {
    {
#line 1982
    addtok(d, (token )269);
    }
  }
#line 1984
  (d->nregexps) ++;
#line 1985
  return;
}
}
#line 1990 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void copy(position_set const   *src , position_set *dst ) 
{ 
  void *tmp ;

  {
#line 1993
  if (dst->alloc < (ptrdiff_t )src->nelem) {
    {
#line 1995
    free((void *)dst->elems);
#line 1996
    tmp = xpalloc((void *)0, & dst->alloc, (ptrdiff_t )(src->nelem - (ptrdiff_t const   )dst->alloc),
                  (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(dst->elems)));
#line 1996
    dst->elems = (position *)tmp;
    }
  }
#line 1999
  dst->nelem = (ptrdiff_t )src->nelem;
#line 2000
  if (src->nelem != 0L) {
    {
#line 2001
    memcpy((void */* __restrict  */)dst->elems, (void const   */* __restrict  */)src->elems,
           (unsigned long )src->nelem * sizeof(*(dst->elems)));
    }
  }
#line 2002
  return;
}
}
#line 2004 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void alloc_position_set(position_set *s , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2007
  tmp = xnmalloc(size, sizeof(*(s->elems)));
#line 2007
  s->elems = (position *)tmp;
#line 2008
  s->alloc = (ptrdiff_t )size;
#line 2009
  s->nelem = (ptrdiff_t )0;
  }
#line 2010
  return;
}
}
#line 2016 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void insert(position p , position_set *s ) 
{ 
  ptrdiff_t count ;
  ptrdiff_t lo ;
  ptrdiff_t hi ;
  ptrdiff_t mid ;
  void *tmp ;
  ptrdiff_t i ;

  {
#line 2019
  count = s->nelem;
#line 2020
  lo = (ptrdiff_t )0;
#line 2020
  hi = count;
  {
#line 2021
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2021
    if (! (lo < hi)) {
#line 2021
      goto while_break;
    }
#line 2023
    mid = (lo + hi) >> 1;
#line 2024
    if ((s->elems + mid)->index > p.index) {
#line 2025
      lo = mid + 1L;
    } else
#line 2026
    if ((s->elems + mid)->index == p.index) {
#line 2028
      (s->elems + mid)->constraint |= p.constraint;
#line 2029
      return;
    } else {
#line 2032
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2035
  tmp = maybe_realloc((void *)s->elems, count, & s->alloc, (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(s->elems)));
#line 2035
  s->elems = (position *)tmp;
#line 2036
  i = count;
  }
  {
#line 2036
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2036
    if (! (i > lo)) {
#line 2036
      goto while_break___0;
    }
#line 2037
    *(s->elems + i) = *(s->elems + (i - 1L));
#line 2036
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2038
  *(s->elems + lo) = p;
#line 2039
  (s->nelem) ++;
#line 2040
  return;
}
}
#line 2045 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void merge_constrained(position_set const   *s1 , position_set const   *s2 ,
                              unsigned int c2 , position_set *m ) 
{ 
  ptrdiff_t i ;
  ptrdiff_t j ;
  void *tmp ;
  unsigned int c ;
  ptrdiff_t tmp___0 ;
  unsigned int tmp___1 ;
  ptrdiff_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  ptrdiff_t tmp___4 ;

  {
#line 2049
  i = (ptrdiff_t )0;
#line 2049
  j = (ptrdiff_t )0;
#line 2051
  if (m->alloc - (ptrdiff_t )s1->nelem < (ptrdiff_t )s2->nelem) {
    {
#line 2053
    free((void *)m->elems);
#line 2054
    m->alloc = (ptrdiff_t )s1->nelem;
#line 2055
    tmp = xpalloc((void *)0, & m->alloc, (ptrdiff_t )s2->nelem, (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(m->elems)));
#line 2055
    m->elems = (position *)tmp;
    }
  }
#line 2057
  m->nelem = (ptrdiff_t )0;
  {
#line 2058
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2058
    if (! (i < (ptrdiff_t )s1->nelem)) {
#line 2058
      if (! (j < (ptrdiff_t )s2->nelem)) {
#line 2058
        goto while_break;
      }
    }
#line 2059
    if (! (j < (ptrdiff_t )s2->nelem)) {
#line 2059
      goto _L;
    } else
#line 2059
    if (i < (ptrdiff_t )s1->nelem) {
#line 2059
      if ((s1->elems + i)->index >= (s2->elems + j)->index) {
        _L: /* CIL Label */ 
#line 2062
        if (i < (ptrdiff_t )s1->nelem) {
#line 2062
          if (j < (ptrdiff_t )s2->nelem) {
#line 2062
            if ((s1->elems + i)->index == (s2->elems + j)->index) {
#line 2062
              tmp___0 = j;
#line 2062
              j ++;
#line 2062
              tmp___1 = (s2->elems + tmp___0)->constraint & c2;
            } else {
#line 2062
              tmp___1 = 0U;
            }
          } else {
#line 2062
            tmp___1 = 0U;
          }
        } else {
#line 2062
          tmp___1 = 0U;
        }
#line 2062
        c = tmp___1;
#line 2066
        (m->elems + m->nelem)->index = (s1->elems + i)->index;
#line 2067
        tmp___2 = m->nelem;
#line 2067
        (m->nelem) ++;
#line 2067
        tmp___3 = i;
#line 2067
        i ++;
#line 2067
        (m->elems + tmp___2)->constraint = (s1->elems + tmp___3)->constraint | c;
      } else {
#line 2059
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2071
      if ((s2->elems + j)->constraint & c2) {
#line 2073
        (m->elems + m->nelem)->index = (s2->elems + j)->index;
#line 2074
        tmp___4 = m->nelem;
#line 2074
        (m->nelem) ++;
#line 2074
        (m->elems + tmp___4)->constraint = (s2->elems + j)->constraint & c2;
      }
#line 2076
      j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2078
  return;
}
}
#line 2082 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void merge(position_set const   *s1 , position_set const   *s2 , position_set *m ) 
{ 


  {
  {
#line 2085
  merge_constrained(s1, s2, 4294967295U, m);
  }
#line 2086
  return;
}
}
#line 2090 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static unsigned int delete(size_t del , position_set *s ) 
{ 
  size_t count ;
  size_t lo ;
  size_t hi ;
  size_t mid ;
  unsigned int c ;
  size_t i ;

  {
#line 2093
  count = (size_t )s->nelem;
#line 2094
  lo = (size_t )0;
#line 2094
  hi = count;
  {
#line 2095
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2095
    if (! (lo < hi)) {
#line 2095
      goto while_break;
    }
#line 2097
    mid = (lo + hi) >> 1;
#line 2098
    if ((s->elems + mid)->index > del) {
#line 2099
      lo = mid + 1UL;
    } else
#line 2100
    if ((s->elems + mid)->index == del) {
#line 2102
      c = (s->elems + mid)->constraint;
#line 2104
      i = mid;
      {
#line 2104
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2104
        if (! (i + 1UL < count)) {
#line 2104
          goto while_break___0;
        }
#line 2105
        *(s->elems + i) = *(s->elems + (i + 1UL));
#line 2104
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2106
      s->nelem = (ptrdiff_t )i;
#line 2107
      return (c);
    } else {
#line 2110
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2112
  return (0U);
}
}
#line 2116 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void replace(position_set *dst , size_t del , position_set *add , unsigned int constraint ,
                    position_set *tmp ) 
{ 
  unsigned int c ;
  unsigned int tmp___0 ;

  {
  {
#line 2120
  tmp___0 = delete(del, dst);
#line 2120
  c = tmp___0 & constraint;
  }
#line 2122
  if (c) {
    {
#line 2124
    copy((position_set const   *)dst, tmp);
#line 2125
    merge_constrained((position_set const   *)tmp, (position_set const   *)add, c,
                      dst);
    }
  }
#line 2127
  return;
}
}
#line 2132 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static state_num state_index(struct dfa *d , position_set const   *s , int context ) 
{ 
  size_t hash ;
  int constraint ;
  state_num i ;
  token first_end ;
  state_num j ;
  state_num j___0 ;
  int c ;
  _Bool tmp ;
  void *tmp___0 ;

  {
#line 2135
  hash = (size_t )0;
#line 2136
  constraint = 0;
#line 2138
  first_end = (token )0;
#line 2140
  i = (state_num )0;
  {
#line 2140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2140
    if (! (i < (state_num )s->nelem)) {
#line 2140
      goto while_break;
    }
#line 2141
    hash ^= (s->elems + i)->index + (size_t )(s->elems + i)->constraint;
#line 2140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2144
  i = (state_num )0;
  {
#line 2144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2144
    if (! (i < d->sindex)) {
#line 2144
      goto while_break___0;
    }
#line 2146
    if (hash != (d->states + i)->hash) {
#line 2148
      goto __Cont;
    } else
#line 2146
    if (s->nelem != (ptrdiff_t const   )(d->states + i)->elems.nelem) {
#line 2148
      goto __Cont;
    } else
#line 2146
    if (context != (int )(d->states + i)->context) {
#line 2148
      goto __Cont;
    }
#line 2150
    j = (state_num )0;
    {
#line 2150
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2150
      if (! (j < (state_num )s->nelem)) {
#line 2150
        goto while_break___1;
      }
#line 2151
      if ((s->elems + j)->constraint != ((d->states + i)->elems.elems + j)->constraint) {
#line 2153
        goto while_break___1;
      } else
#line 2151
      if ((s->elems + j)->index != ((d->states + i)->elems.elems + j)->index) {
#line 2153
        goto while_break___1;
      }
#line 2150
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2154
    if (j == (state_num )s->nelem) {
#line 2155
      return (i);
    }
    __Cont: /* CIL Label */ 
#line 2144
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2180
  j___0 = (state_num )0;
  {
#line 2180
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2180
    if (! (j___0 < (state_num )s->nelem)) {
#line 2180
      goto while_break___2;
    }
#line 2182
    c = (int )(s->elems + j___0)->constraint;
#line 2183
    if (*(d->tokens + (s->elems + j___0)->index) < 0L) {
      {
#line 2185
      tmp = succeeds_in_context(c, context, 7);
      }
#line 2185
      if (tmp) {
#line 2186
        constraint |= c;
      }
#line 2187
      if (! first_end) {
#line 2188
        first_end = *(d->tokens + (s->elems + j___0)->index);
      }
    } else
#line 2190
    if (*(d->tokens + (s->elems + j___0)->index) == 257L) {
#line 2191
      constraint = 511;
    }
#line 2180
    j___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2196
  tmp___0 = maybe_realloc((void *)d->states, d->sindex, & d->salloc, (ptrdiff_t )-1,
                          (ptrdiff_t )sizeof(*(d->states)));
#line 2196
  d->states = (dfa_state *)tmp___0;
#line 2198
  (d->states + i)->hash = hash;
#line 2199
  alloc_position_set(& (d->states + i)->elems, (size_t )s->nelem);
#line 2200
  copy(s, & (d->states + i)->elems);
#line 2201
  (d->states + i)->context = (unsigned char )context;
#line 2202
  (d->states + i)->constraint = (unsigned short )constraint;
#line 2203
  (d->states + i)->first_end = first_end;
#line 2204
  (d->states + i)->mbps.nelem = (ptrdiff_t )0;
#line 2205
  (d->states + i)->mbps.elems = (position *)((void *)0);
#line 2206
  (d->states + i)->mb_trindex = (state_num )-1;
#line 2208
  (d->sindex) ++;
  }
#line 2210
  return (i);
}
}
#line 2218 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void epsclosure(position_set *initial , struct dfa  const  *d ) 
{ 
  position_set tmp ;
  size_t i ;
  unsigned int constraint ;
  size_t j ;

  {
  {
#line 2222
  alloc_position_set(& tmp, (size_t )d->nleaves);
#line 2223
  i = (size_t )0;
  }
  {
#line 2223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2223
    if (! (i < (size_t )d->tindex)) {
#line 2223
      goto while_break;
    }
#line 2224
    if ((d->follows + i)->nelem > 0L) {
#line 2224
      if (*(d->tokens + i) >= 256L) {
#line 2224
        if (*(d->tokens + i) != 257L) {
#line 2224
          if (*(d->tokens + i) != 272L) {
#line 2224
            if (*(d->tokens + i) != 273L) {
#line 2224
              if (*(d->tokens + i) < 275L) {
                {
#line 2231
                if (*(d->tokens + i) == 258L) {
#line 2231
                  goto case_258;
                }
#line 2234
                if (*(d->tokens + i) == 259L) {
#line 2234
                  goto case_259;
                }
#line 2237
                if (*(d->tokens + i) == 260L) {
#line 2237
                  goto case_260;
                }
#line 2240
                if (*(d->tokens + i) == 261L) {
#line 2240
                  goto case_261;
                }
#line 2243
                if (*(d->tokens + i) == 262L) {
#line 2243
                  goto case_262;
                }
#line 2246
                if (*(d->tokens + i) == 263L) {
#line 2246
                  goto case_263;
                }
#line 2249
                goto switch_default;
                case_258: /* CIL Label */ 
#line 2232
                constraint = 292U;
#line 2233
                goto switch_break;
                case_259: /* CIL Label */ 
#line 2235
                constraint = 448U;
#line 2236
                goto switch_break;
                case_260: /* CIL Label */ 
#line 2238
                constraint = 40U;
#line 2239
                goto switch_break;
                case_261: /* CIL Label */ 
#line 2241
                constraint = 130U;
#line 2242
                goto switch_break;
                case_262: /* CIL Label */ 
#line 2244
                constraint = 170U;
#line 2245
                goto switch_break;
                case_263: /* CIL Label */ 
#line 2247
                constraint = 341U;
#line 2248
                goto switch_break;
                switch_default: /* CIL Label */ 
#line 2250
                constraint = 511U;
#line 2251
                goto switch_break;
                switch_break: /* CIL Label */ ;
                }
                {
#line 2254
                delete(i, d->follows + i);
#line 2256
                j = (size_t )0;
                }
                {
#line 2256
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 2256
                  if (! (j < (size_t )d->tindex)) {
#line 2256
                    goto while_break___0;
                  }
#line 2257
                  if (i != j) {
#line 2257
                    if ((d->follows + j)->nelem > 0L) {
                      {
#line 2258
                      replace(d->follows + j, i, d->follows + i, constraint, & tmp);
                      }
                    }
                  }
#line 2256
                  j ++;
                }
                while_break___0: /* CIL Label */ ;
                }
                {
#line 2260
                replace(initial, i, d->follows + i, constraint, & tmp);
                }
              }
            }
          }
        }
      }
    }
#line 2223
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2262
  free((void *)tmp.elems);
  }
#line 2263
  return;
}
}
#line 2268 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static int charclass_context(struct dfa  const  *dfa , charclass const   *c ) 
{ 
  int context ;
  unsigned int j ;

  {
#line 2271
  context = 0;
#line 2273
  j = 0U;
  {
#line 2273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2273
    if (! (j < 4U)) {
#line 2273
      goto while_break;
    }
#line 2275
    if (c->w[j] & dfa->syntax.newline.w[j]) {
#line 2276
      context |= 4;
    }
#line 2277
    if (c->w[j] & dfa->syntax.letters.w[j]) {
#line 2278
      context |= 2;
    }
#line 2279
    if (c->w[j] & ~ (dfa->syntax.letters.w[j] | dfa->syntax.newline.w[j])) {
#line 2280
      context |= 1;
    }
#line 2273
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2283
  return (context);
}
}
#line 2292 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static int __attribute__((__pure__))  state_separate_contexts(position_set const   *s ) 
{ 
  int separate_contexts ;
  size_t j ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 2295
  separate_contexts = 0;
#line 2297
  j = (size_t )0;
  {
#line 2297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2297
    if (! (j < (size_t )s->nelem)) {
#line 2297
      goto while_break;
    }
    {
#line 2299
    tmp = prev_newline_dependent((int )(s->elems + j)->constraint);
    }
#line 2299
    if (tmp) {
#line 2300
      separate_contexts |= 4;
    }
    {
#line 2301
    tmp___0 = prev_letter_dependent((int )(s->elems + j)->constraint);
    }
#line 2301
    if (tmp___0) {
#line 2302
      separate_contexts |= 2;
    }
#line 2297
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2305
  return ((int __attribute__((__pure__))  )separate_contexts);
}
}
#line 2361 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void dfaanalyze(struct dfa *d , _Bool searchflag ) 
{ 
  position *posalloc ;
  void *tmp ;
  position *firstpos ;
  position *lastpos ;
  struct __anonstruct_stkalloc_360611398 *stkalloc ;
  void *tmp___0 ;
  struct __anonstruct_stkalloc_360611398 *stk ;
  position_set merged ;
  void *tmp___1 ;
  size_t i ;
  size_t tmp___2 ;
  position_set tmp___3 ;
  position *pos ;
  size_t j ;
  position_set tmp___4 ;
  position *pos___0 ;
  size_t j___0 ;
  position *pos___1 ;
  size_t j___1 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  unsigned int tmp___8 ;
  size_t i___0 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___9 ;
  int tmp___10 ;
  state_num tmp___11 ;
  state_num tmp___12 ;

  {
  {
#line 2365
  tmp = xnmalloc(d->nleaves, 2UL * sizeof(*posalloc));
#line 2365
  posalloc = (position *)tmp;
#line 2367
  firstpos = posalloc + d->nleaves;
#line 2368
  lastpos = firstpos + d->nleaves;
#line 2371
  tmp___0 = xnmalloc(d->depth, sizeof(*stkalloc));
#line 2371
  stkalloc = (struct __anonstruct_stkalloc_360611398 *)tmp___0;
#line 2371
  stk = stkalloc;
#line 2393
  d->searchflag = searchflag;
#line 2394
  alloc_position_set(& merged, d->nleaves);
#line 2395
  tmp___1 = xcalloc(d->tindex, sizeof(*(d->follows)));
#line 2395
  d->follows = (position_set *)tmp___1;
#line 2397
  i = (size_t )0;
  }
  {
#line 2397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2397
    if (! (i < d->tindex)) {
#line 2397
      goto while_break;
    }
    {
#line 2401
    if (*(d->tokens + i) == 256L) {
#line 2401
      goto case_256;
    }
#line 2411
    if (*(d->tokens + i) == 266L) {
#line 2411
      goto case_266;
    }
#line 2411
    if (*(d->tokens + i) == 265L) {
#line 2411
      goto case_266;
    }
#line 2426
    if (*(d->tokens + i) == 264L) {
#line 2426
      goto case_264;
    }
#line 2432
    if (*(d->tokens + i) == 268L) {
#line 2432
      goto case_268;
    }
#line 2472
    if (*(d->tokens + i) == 269L) {
#line 2472
      goto case_269;
    }
#line 2484
    goto switch_default;
    case_256: /* CIL Label */ 
#line 2403
    stk->nullable = (_Bool)1;
#line 2406
    tmp___2 = (size_t )0;
#line 2406
    stk->nlastpos = tmp___2;
#line 2406
    stk->nfirstpos = tmp___2;
#line 2407
    stk ++;
#line 2408
    goto switch_break;
    case_266: /* CIL Label */ 
    case_265: /* CIL Label */ 
#line 2416
    tmp___3.nelem = (ptrdiff_t )(stk + -1)->nfirstpos;
#line 2417
    tmp___3.elems = firstpos;
#line 2418
    pos = lastpos;
#line 2419
    j = (size_t )0;
    {
#line 2419
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2419
      if (! (j < (stk + -1)->nlastpos)) {
#line 2419
        goto while_break___0;
      }
      {
#line 2421
      merge((position_set const   *)(& tmp___3), (position_set const   *)(d->follows + (pos + j)->index),
            & merged);
#line 2422
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2419
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_264: /* CIL Label */ 
#line 2428
    if (*(d->tokens + i) != 266L) {
#line 2429
      (stk + -1)->nullable = (_Bool)1;
    }
#line 2430
    goto switch_break;
    case_268: /* CIL Label */ 
#line 2437
    tmp___4.nelem = (ptrdiff_t )(stk + -1)->nfirstpos;
#line 2438
    tmp___4.elems = firstpos;
#line 2439
    pos___0 = lastpos + (stk + -1)->nlastpos;
#line 2440
    j___0 = (size_t )0;
    {
#line 2440
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2440
      if (! (j___0 < (stk + -2)->nlastpos)) {
#line 2440
        goto while_break___1;
      }
      {
#line 2442
      merge((position_set const   *)(& tmp___4), (position_set const   *)(d->follows + (pos___0 + j___0)->index),
            & merged);
#line 2443
      copy((position_set const   *)(& merged), d->follows + (pos___0 + j___0)->index);
#line 2440
      j___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2449
    if ((stk + -2)->nullable) {
#line 2450
      (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
    } else {
#line 2452
      firstpos += (stk + -1)->nfirstpos;
    }
#line 2456
    if ((stk + -1)->nullable) {
#line 2457
      (stk + -2)->nlastpos += (stk + -1)->nlastpos;
    } else {
#line 2460
      pos___1 = lastpos + (stk + -2)->nlastpos;
#line 2461
      j___1 = (stk + -1)->nlastpos;
      {
#line 2461
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2461
        tmp___5 = j___1;
#line 2461
        j___1 --;
#line 2461
        if (! (tmp___5 > 0UL)) {
#line 2461
          goto while_break___2;
        }
#line 2462
        *(pos___1 + j___1) = *(lastpos + j___1);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2463
      lastpos += (stk + -2)->nlastpos;
#line 2464
      (stk + -2)->nlastpos = (stk + -1)->nlastpos;
    }
#line 2468
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable & (int )(stk + -1)->nullable);
#line 2469
    stk --;
#line 2470
    goto switch_break;
    case_269: /* CIL Label */ 
#line 2474
    (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
#line 2477
    (stk + -2)->nlastpos += (stk + -1)->nlastpos;
#line 2480
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable | (int )(stk + -1)->nullable);
#line 2481
    stk --;
#line 2482
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2490
    stk->nullable = (_Bool )(*(d->tokens + i) == 257L);
#line 2493
    tmp___6 = (size_t )1;
#line 2493
    stk->nlastpos = tmp___6;
#line 2493
    stk->nfirstpos = tmp___6;
#line 2494
    stk ++;
#line 2496
    firstpos --;
#line 2496
    lastpos --;
#line 2497
    tmp___7 = i;
#line 2497
    lastpos->index = tmp___7;
#line 2497
    firstpos->index = tmp___7;
#line 2498
    tmp___8 = 511U;
#line 2498
    lastpos->constraint = tmp___8;
#line 2498
    firstpos->constraint = tmp___8;
#line 2500
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2397
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2545
  merged.nelem = (ptrdiff_t )0;
#line 2546
  i___0 = (size_t )0;
  {
#line 2546
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2546
    if (! (i___0 < (stk + -1)->nfirstpos)) {
#line 2546
      goto while_break___3;
    }
    {
#line 2547
    insert(*(firstpos + i___0), & merged);
#line 2546
    i___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2551
  epsclosure(& merged, (struct dfa  const  *)d);
#line 2554
  tmp___9 = state_separate_contexts((position_set const   *)(& merged));
#line 2554
  separate_contexts = (int )tmp___9;
  }
#line 2557
  if (separate_contexts & 4) {
    {
#line 2558
    state_index(d, (position_set const   *)(& merged), 4);
    }
  }
  {
#line 2559
  tmp___11 = state_index(d, (position_set const   *)(& merged), separate_contexts ^ 7);
#line 2559
  tmp___10 = (int )tmp___11;
#line 2559
  d->min_trcount = tmp___10;
#line 2559
  d->initstate_notbol = (state_num )tmp___10;
  }
#line 2561
  if (separate_contexts & 2) {
    {
#line 2562
    tmp___12 = state_index(d, (position_set const   *)(& merged), 2);
#line 2562
    d->min_trcount = (int )tmp___12;
    }
  }
  {
#line 2563
  (d->min_trcount) ++;
#line 2564
  d->trcount = 0;
#line 2566
  free((void *)posalloc);
#line 2567
  free((void *)stkalloc);
#line 2568
  free((void *)merged.elems);
  }
#line 2569
  return;
}
}
#line 2572 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void realloc_trans_if_necessary(struct dfa *d ) 
{ 
  state_num oldalloc ;
  state_num **realtrans ;
  state_num **tmp ;
  ptrdiff_t newalloc1 ;
  state_num tmp___0 ;
  void *tmp___1 ;
  state_num *tmp___2 ;
  ptrdiff_t newalloc ;
  state_num tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  state_num *tmp___8 ;

  {
#line 2575
  oldalloc = d->tralloc;
#line 2576
  if (oldalloc < d->sindex) {
#line 2578
    if (d->trans) {
#line 2578
      tmp = d->trans - 2;
    } else {
#line 2578
      tmp = (state_num **)((void *)0);
    }
#line 2578
    realtrans = tmp;
#line 2579
    if (realtrans) {
#line 2579
      tmp___0 = d->tralloc + 2L;
    } else {
#line 2579
      tmp___0 = (state_num )0;
    }
    {
#line 2579
    newalloc1 = tmp___0;
#line 2580
    tmp___1 = xpalloc((void *)realtrans, & newalloc1, d->sindex - oldalloc, (ptrdiff_t )-1,
                      (ptrdiff_t )sizeof(*realtrans));
#line 2580
    realtrans = (state_num **)tmp___1;
#line 2582
    tmp___2 = (state_num *)((void *)0);
#line 2582
    *(realtrans + 1) = tmp___2;
#line 2582
    *(realtrans + 0) = tmp___2;
#line 2583
    d->trans = realtrans + 2;
#line 2584
    tmp___3 = newalloc1 - 2L;
#line 2584
    d->tralloc = tmp___3;
#line 2584
    newalloc = tmp___3;
#line 2585
    tmp___4 = xnrealloc((void *)d->fails, (size_t )newalloc, sizeof(*(d->fails)));
#line 2585
    d->fails = (state_num **)tmp___4;
#line 2586
    tmp___5 = xnrealloc((void *)d->success, (size_t )newalloc, sizeof(*(d->success)));
#line 2586
    d->success = (char *)tmp___5;
#line 2587
    tmp___6 = xnrealloc((void *)d->newlines, (size_t )newalloc, sizeof(*(d->newlines)));
#line 2587
    d->newlines = (state_num *)tmp___6;
    }
#line 2588
    if (d->localeinfo.multibyte) {
#line 2590
      if (d->mb_trans) {
#line 2590
        realtrans = d->mb_trans - 2;
      } else {
#line 2590
        realtrans = (state_num **)((void *)0);
      }
      {
#line 2591
      tmp___7 = xnrealloc((void *)realtrans, (size_t )newalloc1, sizeof(*realtrans));
#line 2591
      realtrans = (state_num **)tmp___7;
      }
#line 2592
      if (oldalloc == 0L) {
#line 2593
        tmp___8 = (state_num *)((void *)0);
#line 2593
        *(realtrans + 1) = tmp___8;
#line 2593
        *(realtrans + 0) = tmp___8;
      }
#line 2594
      d->mb_trans = realtrans + 2;
    }
    {
#line 2596
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2596
      if (! (oldalloc < newalloc)) {
#line 2596
        goto while_break;
      }
#line 2598
      *(d->trans + oldalloc) = (state_num *)((void *)0);
#line 2599
      *(d->fails + oldalloc) = (state_num *)((void *)0);
#line 2600
      if (d->localeinfo.multibyte) {
#line 2601
        *(d->mb_trans + oldalloc) = (state_num *)((void *)0);
      }
#line 2596
      oldalloc ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2604
  return;
}
}
#line 2639 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static state_num build_state(state_num s , struct dfa *d , unsigned char uc ) 
{ 
  position_set follows ;
  position_set tmp ;
  state_num state ;
  state_num state_newline ;
  state_num state_letter ;
  state_num **ptrans ;
  state_num **tmp___1 ;
  _Bool tmp___2 ;
  state_num *trans ;
  state_num i ;
  state_num *tmp___3 ;
  void *tmp___4 ;
  int i___0 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  leaf_set group ;
  void *tmp___8 ;
  charclass label ;
  size_t i___1 ;
  charclass matches ;
  position pos ;
  _Bool matched ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  size_t j ;
  _Bool tmp___11 ;
  size_t j___0 ;
  _Bool tmp___12 ;
  size_t j___1 ;
  _Bool tmp___13 ;
  size_t j___2 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  size_t k ;
  size_t tmp___17 ;
  size_t k___0 ;
  size_t j___3 ;
  size_t k___1 ;
  _Bool mergeit ;
  size_t j___4 ;
  int possible_contexts ;
  int tmp___18 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___19 ;
  size_t i___2 ;
  _Bool tmp___20 ;
  _Bool tmp___21 ;

  {
  {
#line 2653
  tmp___2 = accepting(s, (struct dfa  const  *)d);
  }
#line 2653
  if (tmp___2) {
#line 2653
    tmp___1 = d->fails;
  } else {
#line 2653
    tmp___1 = d->trans;
  }
#line 2653
  ptrans = tmp___1 + s;
#line 2654
  trans = *ptrans;
#line 2656
  if (! trans) {
#line 2662
    if (1024 <= d->trcount) {
#line 2664
      i = (state_num )d->min_trcount;
      {
#line 2664
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2664
        if (! (i < d->tralloc)) {
#line 2664
          goto while_break;
        }
        {
#line 2666
        free((void *)*(d->trans + i));
#line 2667
        free((void *)*(d->fails + i));
#line 2668
        tmp___3 = (state_num *)((void *)0);
#line 2668
        *(d->fails + i) = tmp___3;
#line 2668
        *(d->trans + i) = tmp___3;
#line 2664
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 2670
      d->trcount = 0;
    }
    {
#line 2673
    (d->trcount) ++;
#line 2674
    tmp___4 = xmalloc(256UL * sizeof(*trans));
#line 2674
    trans = (state_num *)tmp___4;
#line 2674
    *ptrans = trans;
#line 2678
    i___0 = 0;
    }
    {
#line 2678
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2678
      if (! (i___0 < 256)) {
#line 2678
        goto while_break___0;
      }
#line 2679
      *(trans + i___0) = (state_num )-2;
#line 2678
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2683
  *(d->success + s) = (char)0;
#line 2684
  tmp___5 = accepts_in_context((int )(d->states + s)->context, 4, s, (struct dfa  const  *)d);
  }
#line 2684
  if (tmp___5) {
#line 2685
    *(d->success + s) = (char )((int )*(d->success + s) | 4);
  }
  {
#line 2686
  tmp___6 = accepts_in_context((int )(d->states + s)->context, 2, s, (struct dfa  const  *)d);
  }
#line 2686
  if (tmp___6) {
#line 2687
    *(d->success + s) = (char )((int )*(d->success + s) | 2);
  }
  {
#line 2688
  tmp___7 = accepts_in_context((int )(d->states + s)->context, 1, s, (struct dfa  const  *)d);
  }
#line 2688
  if (tmp___7) {
#line 2689
    *(d->success + s) = (char )((int )*(d->success + s) | 1);
  }
  {
#line 2693
  tmp___8 = xnmalloc(d->nleaves, sizeof(*(group.elems)));
#line 2693
  group.elems = (size_t *)tmp___8;
#line 2694
  group.nelem = (size_t )0;
#line 2698
  fillset(& label);
#line 2700
  i___1 = (size_t )0;
  }
  {
#line 2700
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2700
    if (! (i___1 < (size_t )(d->states + s)->elems.nelem)) {
#line 2700
      goto while_break___1;
    }
#line 2703
    pos = *((d->states + s)->elems.elems + i___1);
#line 2704
    matched = (_Bool)0;
#line 2705
    if (*(d->tokens + pos.index) >= 0L) {
#line 2705
      if (*(d->tokens + pos.index) < 256L) {
        {
#line 2707
        zeroset(& matches);
#line 2708
        setbit((unsigned int )*(d->tokens + pos.index), & matches);
        }
#line 2709
        if (*(d->tokens + pos.index) == (token )uc) {
#line 2710
          matched = (_Bool)1;
        }
      } else {
#line 2705
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2712
    if (*(d->tokens + pos.index) >= 275L) {
      {
#line 2714
      matches = *(d->charclasses + (*(d->tokens + pos.index) - 275L));
#line 2715
      tmp___9 = tstbit((unsigned int )uc, (charclass const   *)(& matches));
      }
#line 2715
      if (tmp___9) {
#line 2716
        matched = (_Bool)1;
      }
    } else
#line 2718
    if (*(d->tokens + pos.index) == 272L) {
      {
#line 2720
      matches = *(d->charclasses + d->canychar);
#line 2721
      tmp___10 = tstbit((unsigned int )uc, (charclass const   *)(& matches));
      }
#line 2721
      if (tmp___10) {
#line 2722
        matched = (_Bool)1;
      }
      {
#line 2730
      tmp___11 = succeeds_in_context((int )pos.constraint, (int )(d->states + s)->context,
                                     1);
      }
#line 2730
      if (tmp___11) {
#line 2733
        if ((d->states + s)->mbps.nelem == 0L) {
          {
#line 2734
          alloc_position_set(& (d->states + s)->mbps, (size_t )(d->follows + pos.index)->nelem);
          }
        }
#line 2736
        j = (size_t )0;
        {
#line 2736
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2736
          if (! (j < (size_t )(d->follows + pos.index)->nelem)) {
#line 2736
            goto while_break___2;
          }
          {
#line 2737
          insert(*((d->follows + pos.index)->elems + j), & (d->states + s)->mbps);
#line 2736
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
#line 2741
      goto __Cont;
    }
#line 2745
    if (pos.constraint != 511U) {
      {
#line 2747
      tmp___12 = succeeds_in_context((int )pos.constraint, (int )(d->states + s)->context,
                                     4);
      }
#line 2747
      if (! tmp___12) {
#line 2749
        j___0 = (size_t )0;
        {
#line 2749
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2749
          if (! (j___0 < 4UL)) {
#line 2749
            goto while_break___3;
          }
#line 2750
          matches.w[j___0] &= ~ d->syntax.newline.w[j___0];
#line 2749
          j___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 2751
      tmp___13 = succeeds_in_context((int )pos.constraint, (int )(d->states + s)->context,
                                     2);
      }
#line 2751
      if (! tmp___13) {
#line 2753
        j___1 = (size_t )0;
        {
#line 2753
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2753
          if (! (j___1 < 4UL)) {
#line 2753
            goto while_break___4;
          }
#line 2754
          matches.w[j___1] &= ~ d->syntax.letters.w[j___1];
#line 2753
          j___1 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 2755
      tmp___14 = succeeds_in_context((int )pos.constraint, (int )(d->states + s)->context,
                                     1);
      }
#line 2755
      if (! tmp___14) {
#line 2757
        j___2 = (size_t )0;
        {
#line 2757
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2757
          if (! (j___2 < 4UL)) {
#line 2757
            goto while_break___5;
          }
#line 2758
          matches.w[j___2] &= d->syntax.letters.w[j___2] | d->syntax.newline.w[j___2];
#line 2757
          j___2 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      {
#line 2761
      tmp___15 = emptyset((charclass const   *)(& matches));
      }
#line 2761
      if (tmp___15) {
#line 2762
        goto __Cont;
      }
      {
#line 2767
      tmp___16 = tstbit((unsigned int )uc, (charclass const   *)(& matches));
      }
#line 2767
      if (! tmp___16) {
#line 2768
        matched = (_Bool)0;
      }
    }
#line 2781
    if (matched) {
#line 2783
      k = (size_t )0;
      {
#line 2783
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2783
        if (! (k < 4UL)) {
#line 2783
          goto while_break___6;
        }
#line 2784
        label.w[k] &= matches.w[k];
#line 2783
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2785
      tmp___17 = group.nelem;
#line 2785
      (group.nelem) ++;
#line 2785
      *(group.elems + tmp___17) = pos.index;
    } else {
#line 2789
      k___0 = (size_t )0;
      {
#line 2789
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2789
        if (! (k___0 < 4UL)) {
#line 2789
          goto while_break___7;
        }
#line 2790
        label.w[k___0] &= ~ matches.w[k___0];
#line 2789
        k___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 2700
    i___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2794
  alloc_position_set(& follows, d->nleaves);
#line 2795
  alloc_position_set(& tmp, d->nleaves);
  }
#line 2797
  if (group.nelem > 0UL) {
#line 2799
    follows.nelem = (ptrdiff_t )0;
#line 2803
    j___3 = (size_t )0;
    {
#line 2803
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2803
      if (! (j___3 < group.nelem)) {
#line 2803
        goto while_break___8;
      }
#line 2804
      k___1 = (size_t )0;
      {
#line 2804
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 2804
        if (! (k___1 < (size_t )(d->follows + *(group.elems + j___3))->nelem)) {
#line 2804
          goto while_break___9;
        }
        {
#line 2805
        insert(*((d->follows + *(group.elems + j___3))->elems + k___1), & follows);
#line 2804
        k___1 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 2803
      j___3 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 2809
    if (d->searchflag) {
#line 2828
      mergeit = (_Bool )(! d->localeinfo.multibyte);
#line 2829
      if (! mergeit) {
#line 2831
        mergeit = (_Bool)1;
#line 2832
        j___4 = (size_t )0;
        {
#line 2832
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 2832
          if (mergeit) {
#line 2832
            if (! (j___4 < (size_t )follows.nelem)) {
#line 2832
              goto while_break___10;
            }
          } else {
#line 2832
            goto while_break___10;
          }
#line 2833
          mergeit = (_Bool )((int )mergeit & (int )*(d->multibyte_prop + (follows.elems + j___4)->index));
#line 2832
          j___4 ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 2835
      if (mergeit) {
        {
#line 2837
        merge((position_set const   *)(& (d->states + 0)->elems), (position_set const   *)(& follows),
              & tmp);
#line 2838
        copy((position_set const   *)(& tmp), & follows);
        }
      }
    }
    {
#line 2845
    tmp___18 = charclass_context((struct dfa  const  *)d, (charclass const   *)(& label));
#line 2845
    possible_contexts = tmp___18;
#line 2846
    tmp___19 = state_separate_contexts((position_set const   *)(& follows));
#line 2846
    separate_contexts = (int )tmp___19;
    }
#line 2849
    if (possible_contexts & ~ separate_contexts) {
      {
#line 2850
      state = state_index(d, (position_set const   *)(& follows), separate_contexts ^ 7);
      }
    } else {
#line 2852
      state = (state_num )-1;
    }
#line 2853
    if ((separate_contexts & possible_contexts) & 4) {
      {
#line 2854
      state_newline = state_index(d, (position_set const   *)(& follows), 4);
      }
    } else {
#line 2856
      state_newline = state;
    }
#line 2857
    if ((separate_contexts & possible_contexts) & 2) {
      {
#line 2858
      state_letter = state_index(d, (position_set const   *)(& follows), 2);
      }
    } else {
#line 2860
      state_letter = state;
    }
    {
#line 2863
    realloc_trans_if_necessary(d);
    }
  } else
#line 2869
  if (d->searchflag) {
#line 2871
    state_newline = (state_num )0;
#line 2872
    state_letter = (state_num )(d->min_trcount - 1);
#line 2873
    state = d->initstate_notbol;
  } else {
#line 2877
    state_newline = (state_num )-1;
#line 2878
    state_letter = (state_num )-1;
#line 2879
    state = (state_num )-1;
  }
#line 2883
  i___2 = (size_t )0;
  {
#line 2883
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 2883
    if (! (i___2 < 256UL)) {
#line 2883
      goto while_break___11;
    }
    {
#line 2884
    tmp___20 = tstbit((unsigned int )i___2, (charclass const   *)(& label));
    }
#line 2884
    if (tmp___20) {
      {
#line 2887
      if ((int )d->syntax.sbit[i___2] == 4) {
#line 2887
        goto case_4;
      }
#line 2890
      if ((int )d->syntax.sbit[i___2] == 2) {
#line 2890
        goto case_2;
      }
#line 2893
      goto switch_default;
      case_4: /* CIL Label */ 
#line 2888
      *(trans + i___2) = state_newline;
#line 2889
      goto switch_break;
      case_2: /* CIL Label */ 
#line 2891
      *(trans + i___2) = state_letter;
#line 2892
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2894
      *(trans + i___2) = state;
#line 2895
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 2883
    i___2 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 2909
  free((void *)group.elems);
#line 2910
  free((void *)follows.elems);
#line 2911
  free((void *)tmp.elems);
#line 2915
  tmp___21 = tstbit((unsigned int )d->syntax.eolbyte, (charclass const   *)(& label));
  }
#line 2915
  if (tmp___21) {
#line 2917
    *(d->newlines + s) = *(trans + d->syntax.eolbyte);
#line 2918
    *(trans + d->syntax.eolbyte) = (state_num )-1;
  }
#line 2921
  return (*(trans + uc));
}
}
#line 2930 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static state_num transit_state_singlebyte(struct dfa *d , state_num s , unsigned char const   **pp ) 
{ 
  state_num *t ;
  unsigned char const   *tmp___0 ;

  {
#line 2935
  if (*(d->trans + s)) {
#line 2936
    t = *(d->trans + s);
  } else
#line 2937
  if (*(d->fails + s)) {
#line 2938
    t = *(d->fails + s);
  } else {
    {
#line 2941
    build_state(s, d, (unsigned char )*(*pp));
    }
#line 2942
    if (*(d->trans + s)) {
#line 2943
      t = *(d->trans + s);
    } else {
#line 2946
      t = *(d->fails + s);
#line 2947
      if (! t) {
        {
#line 2947
        __assert_fail("t", "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c", 2947U,
                      "transit_state_singlebyte");
        }
      }
    }
  }
#line 2951
  if (*(t + *(*pp)) == -2L) {
    {
#line 2952
    build_state(s, d, (unsigned char )*(*pp));
    }
  }
#line 2954
  tmp___0 = *pp;
#line 2954
  (*pp) ++;
#line 2954
  return (*(t + *tmp___0));
}
}
#line 2960 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static state_num transit_state(struct dfa *d , state_num s , unsigned char const   **pp ,
                               unsigned char const   *end ) 
{ 
  wint_t wc ;
  int mbclen ;
  size_t tmp ;
  state_num s1 ;
  int mbci ;
  state_num s3 ;
  state_num i ;
  state_num tmp___0 ;
  void *tmp___1 ;
  int i___0 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___2 ;
  state_num s2 ;
  state_num tmp___3 ;

  {
  {
#line 2966
  tmp = mbs_to_wchar(& wc, (char const   *)*pp, (size_t )(end - *pp), d);
#line 2966
  mbclen = (int )tmp;
#line 2969
  d->mb_follows.nelem = (ptrdiff_t )0;
#line 2973
  s1 = s;
#line 2975
  mbci = 0;
  }
  {
#line 2975
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2975
    if (mbci < mbclen) {
#line 2975
      if (! (mbci == 0)) {
#line 2975
        if (! ((state_num )d->min_trcount <= s)) {
#line 2975
          goto while_break;
        }
      }
    } else {
#line 2975
      goto while_break;
    }
    {
#line 2976
    s = transit_state_singlebyte(d, s, pp);
#line 2975
    mbci ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2977
  *pp += mbclen - mbci;
#line 2979
  if (wc == 4294967295U) {
#line 2982
    return (s);
  }
#line 2988
  if ((d->states + s1)->mb_trindex < 0L) {
#line 2990
    if (1024L <= d->mb_trcount) {
#line 2993
      s3 = (state_num )-1;
      {
#line 2993
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2993
        if (! (s3 < d->tralloc)) {
#line 2993
          goto while_break___0;
        }
        {
#line 2995
        free((void *)*(d->mb_trans + s3));
#line 2996
        *(d->mb_trans + s3) = (state_num *)((void *)0);
#line 2993
        s3 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2999
      i = (state_num )0;
      {
#line 2999
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2999
        if (! (i < d->sindex)) {
#line 2999
          goto while_break___1;
        }
#line 3000
        (d->states + i)->mb_trindex = (state_num )-1;
#line 2999
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3001
      d->mb_trcount = (state_num )0;
    }
#line 3003
    tmp___0 = d->mb_trcount;
#line 3003
    (d->mb_trcount) ++;
#line 3003
    (d->states + s1)->mb_trindex = tmp___0;
  }
#line 3006
  if (! *(d->mb_trans + s)) {
    {
#line 3010
    tmp___1 = xmalloc((size_t )8192);
#line 3010
    *(d->mb_trans + s) = (state_num *)tmp___1;
#line 3011
    i___0 = 0;
    }
    {
#line 3011
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3011
      if (! (i___0 < 1024)) {
#line 3011
        goto while_break___2;
      }
#line 3012
      *(*(d->mb_trans + s) + i___0) = (state_num )-1;
#line 3011
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 3014
  if (*(*(d->mb_trans + s) + (d->states + s1)->mb_trindex) >= 0L) {
#line 3015
    return (*(*(d->mb_trans + s) + (d->states + s1)->mb_trindex));
  }
#line 3017
  if (s == -1L) {
    {
#line 3018
    copy((position_set const   *)(& (d->states + s1)->mbps), & d->mb_follows);
    }
  } else {
    {
#line 3020
    merge((position_set const   *)(& (d->states + s1)->mbps), (position_set const   *)(& (d->states + s)->elems),
          & d->mb_follows);
    }
  }
  {
#line 3022
  tmp___2 = state_separate_contexts((position_set const   *)(& d->mb_follows));
#line 3022
  separate_contexts = (int )tmp___2;
#line 3023
  tmp___3 = state_index(d, (position_set const   *)(& d->mb_follows), separate_contexts ^ 7);
#line 3023
  s2 = tmp___3;
#line 3024
  realloc_trans_if_necessary(d);
#line 3026
  *(*(d->mb_trans + s) + (d->states + s1)->mb_trindex) = s2;
  }
#line 3028
  return (s2);
}
}
#line 3046 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static unsigned char const   *skip_remains_mb(struct dfa *d , unsigned char const   *p ,
                                              unsigned char const   *mbp , char const   *end ) 
{ 
  wint_t wc ;
  size_t tmp ;

  {
#line 3050
  if (d->syntax.never_trail[*p]) {
#line 3051
    return (p);
  }
  {
#line 3052
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3052
    if (! ((unsigned long )mbp < (unsigned long )p)) {
#line 3052
      goto while_break;
    }
    {
#line 3055
    tmp = mbs_to_wchar(& wc, (char const   *)mbp, (size_t )(end - (char const   *)mbp),
                       d);
#line 3055
    mbp += tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3058
  return (mbp);
}
}
#line 3081 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
__inline static char *dfaexec_main(struct dfa *d , char const   *begin , char *end ,
                                   _Bool allow_nl , size_t *count , _Bool multibyte ) 
{ 
  state_num s ;
  state_num s___0 ;
  state_num *tmp ;
  state_num s___1 ;
  state_num s___2 ;
  state_num s___3 ;
  state_num s1 ;
  unsigned char const   *p ;
  unsigned char const   *mbp ;
  state_num **trans ;
  unsigned char eol ;
  unsigned char saved_end ;
  size_t nlcount ;
  state_num *t ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  state_num tmp___2 ;
  unsigned char const   *tmp___3 ;
  state_num tmp___4 ;
  state_num tmp___5 ;
  _Bool tmp___6 ;
  unsigned char const   *tmp___7 ;

  {
#line 3085
  if (1024L <= d->sindex) {
#line 3087
    s = (state_num )d->min_trcount;
    {
#line 3087
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3087
      if (! (s < d->sindex)) {
#line 3087
        goto while_break;
      }
      {
#line 3089
      free((void *)(d->states + s)->elems.elems);
#line 3090
      free((void *)(d->states + s)->mbps.elems);
#line 3087
      s ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3092
    d->sindex = (state_num )d->min_trcount;
#line 3094
    if (d->trans) {
#line 3096
      s___0 = (state_num )0;
      {
#line 3096
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3096
        if (! (s___0 < d->tralloc)) {
#line 3096
          goto while_break___0;
        }
        {
#line 3098
        free((void *)*(d->trans + s___0));
#line 3099
        free((void *)*(d->fails + s___0));
#line 3100
        tmp = (state_num *)((void *)0);
#line 3100
        *(d->fails + s___0) = tmp;
#line 3100
        *(d->trans + s___0) = tmp;
#line 3096
        s___0 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3102
      d->trcount = 0;
    }
#line 3105
    if (d->localeinfo.multibyte) {
#line 3105
      if (d->mb_trans) {
#line 3107
        s___1 = (state_num )-1;
        {
#line 3107
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3107
          if (! (s___1 < d->tralloc)) {
#line 3107
            goto while_break___1;
          }
          {
#line 3109
          free((void *)*(d->mb_trans + s___1));
#line 3110
          *(d->mb_trans + s___1) = (state_num *)((void *)0);
#line 3107
          s___1 ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3112
        s___2 = (state_num )0;
        {
#line 3112
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3112
          if (! (s___2 < (state_num )d->min_trcount)) {
#line 3112
            goto while_break___2;
          }
#line 3113
          (d->states + s___2)->mb_trindex = (state_num )-1;
#line 3112
          s___2 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3114
        d->mb_trcount = (state_num )0;
      }
    }
  }
#line 3118
  if (! d->tralloc) {
    {
#line 3119
    realloc_trans_if_necessary(d);
    }
  }
#line 3122
  s___3 = (state_num )0;
#line 3122
  s1 = (state_num )0;
#line 3125
  p = (unsigned char const   *)begin;
#line 3126
  mbp = p;
#line 3129
  trans = d->trans;
#line 3130
  eol = d->syntax.eolbyte;
#line 3131
  saved_end = *((unsigned char *)end);
#line 3132
  *end = (char )eol;
#line 3134
  if (multibyte) {
    {
#line 3136
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
#line 3137
    if (d->mb_follows.alloc == 0L) {
      {
#line 3138
      alloc_position_set(& d->mb_follows, d->nleaves);
      }
    }
  }
#line 3141
  nlcount = (size_t )0;
  {
#line 3142
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 3145
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3145
      t = *(trans + s___3);
#line 3145
      if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 3145
        goto while_break___4;
      }
#line 3147
      if (s___3 < (state_num )d->min_trcount) {
#line 3149
        if (! multibyte) {
#line 3149
          goto _L;
        } else
#line 3149
        if ((d->states + s___3)->mbps.nelem == 0L) {
          _L: /* CIL Label */ 
          {
#line 3151
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 3151
            if (! (*(t + *p) == s___3)) {
#line 3151
              goto while_break___5;
            }
#line 3152
            p ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 3154
        if (multibyte) {
          {
#line 3155
          mbp = skip_remains_mb(d, p, mbp, (char const   *)end);
#line 3155
          p = mbp;
          }
        }
      }
#line 3158
      if (multibyte) {
#line 3160
        s1 = s___3;
#line 3162
        if ((d->states + s___3)->mbps.nelem == 0L) {
#line 3167
          tmp___0 = p;
#line 3167
          p ++;
#line 3167
          s___3 = *(t + *tmp___0);
        } else
#line 3162
        if (d->localeinfo.sbctowc[*p] != 4294967295U) {
#line 3167
          tmp___0 = p;
#line 3167
          p ++;
#line 3167
          s___3 = *(t + *tmp___0);
        } else
#line 3162
        if ((unsigned long )((char *)p) >= (unsigned long )end) {
#line 3167
          tmp___0 = p;
#line 3167
          p ++;
#line 3167
          s___3 = *(t + *tmp___0);
        } else {
          {
#line 3171
          s___3 = transit_state(d, s___3, & p, (unsigned char const   *)((unsigned char *)end));
#line 3172
          mbp = p;
#line 3173
          trans = d->trans;
          }
        }
      } else {
#line 3178
        tmp___1 = p;
#line 3178
        p ++;
#line 3178
        s1 = *(t + *tmp___1);
#line 3179
        t = *(trans + s1);
#line 3180
        if (! t) {
#line 3182
          tmp___2 = s___3;
#line 3183
          s___3 = s1;
#line 3184
          s1 = tmp___2;
#line 3185
          goto while_break___4;
        }
#line 3187
        if (s___3 < (state_num )d->min_trcount) {
          {
#line 3189
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 3189
            if (! (*(t + *p) == s1)) {
#line 3189
              goto while_break___6;
            }
#line 3190
            p ++;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 3192
        tmp___3 = p;
#line 3192
        p ++;
#line 3192
        s___3 = *(t + *tmp___3);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3196
    if (s___3 < 0L) {
#line 3198
      if (s___3 == -2L) {
        {
#line 3200
        s___3 = build_state(s1, d, (unsigned char )*(p + -1));
#line 3201
        trans = d->trans;
        }
      } else
#line 3203
      if ((unsigned long )((char *)p) <= (unsigned long )end) {
#line 3203
        if ((int const   )*(p + -1) == (int const   )eol) {
#line 3203
          if (0L <= *(d->newlines + s1)) {
#line 3207
            nlcount ++;
#line 3208
            mbp = p;
#line 3210
            if (allow_nl) {
#line 3210
              s___3 = *(d->newlines + s1);
            } else {
#line 3210
              if ((int )d->syntax.sbit[eol] == 4) {
#line 3210
                tmp___5 = (state_num )0;
              } else {
#line 3210
                if ((int )d->syntax.sbit[eol] == 2) {
#line 3210
                  tmp___4 = (state_num )(d->min_trcount - 1);
                } else {
#line 3210
                  tmp___4 = d->initstate_notbol;
                }
#line 3210
                tmp___5 = tmp___4;
              }
#line 3210
              s___3 = tmp___5;
            }
          } else {
#line 3217
            p = (unsigned char const   *)((void *)0);
#line 3218
            goto done;
          }
        } else {
#line 3217
          p = (unsigned char const   *)((void *)0);
#line 3218
          goto done;
        }
      } else {
#line 3217
        p = (unsigned char const   *)((void *)0);
#line 3218
        goto done;
      }
    } else
#line 3221
    if (*(d->fails + s___3)) {
#line 3223
      if ((int )*(d->success + s___3) & (int )d->syntax.sbit[*p]) {
#line 3227
        goto done;
      } else
#line 3223
      if ((unsigned long )((char *)p) == (unsigned long )end) {
        {
#line 3223
        tmp___6 = accepts_in_context((int )(d->states + s___3)->context, 4, s___3,
                                     (struct dfa  const  *)d);
        }
#line 3223
        if (tmp___6) {
#line 3227
          goto done;
        }
      }
#line 3229
      if (multibyte) {
#line 3229
        if (s___3 < (state_num )d->min_trcount) {
          {
#line 3230
          mbp = skip_remains_mb(d, p, mbp, (char const   *)end);
#line 3230
          p = mbp;
          }
        }
      }
#line 3232
      s1 = s___3;
#line 3233
      if (! multibyte) {
#line 3238
        tmp___7 = p;
#line 3238
        p ++;
#line 3238
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3233
      if ((d->states + s___3)->mbps.nelem == 0L) {
#line 3238
        tmp___7 = p;
#line 3238
        p ++;
#line 3238
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3233
      if (d->localeinfo.sbctowc[*p] != 4294967295U) {
#line 3238
        tmp___7 = p;
#line 3238
        p ++;
#line 3238
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3233
      if ((unsigned long )((char *)p) >= (unsigned long )end) {
#line 3238
        tmp___7 = p;
#line 3238
        p ++;
#line 3238
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else {
        {
#line 3242
        s___3 = transit_state(d, s___3, & p, (unsigned char const   *)((unsigned char *)end));
#line 3243
        mbp = p;
#line 3244
        trans = d->trans;
        }
      }
    } else {
      {
#line 3249
      build_state(s___3, d, (unsigned char )*(p + 0));
#line 3250
      trans = d->trans;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  done: 
#line 3255
  if (count) {
#line 3256
    *count += nlcount;
  }
#line 3257
  *end = (char )saved_end;
#line 3258
  return ((char *)p);
}
}
#line 3264 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static char *dfaexec_mb(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                        size_t *count , _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3268
  tmp = dfaexec_main(d, begin, end, allow_nl, count, (_Bool)1);
  }
#line 3268
  return (tmp);
}
}
#line 3271 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static char *dfaexec_sb(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                        size_t *count , _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3275
  tmp = dfaexec_main(d, begin, end, allow_nl, count, (_Bool)0);
  }
#line 3275
  return (tmp);
}
}
#line 3280 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static char *dfaexec_noop(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                          size_t *count , _Bool *backref ) 
{ 


  {
#line 3284
  *backref = (_Bool)1;
#line 3285
  return ((char *)begin);
}
}
#line 3292 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
char *dfaexec(struct dfa *d , char const   *begin , char *end , _Bool allow_nl , size_t *count ,
              _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3296
  tmp = (*(d->dfaexec))(d, begin, end, allow_nl, count, backref);
  }
#line 3296
  return (tmp);
}
}
#line 3299
struct dfa *dfasuperset(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 3299 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct dfa *dfasuperset(struct dfa  const  *d ) 
{ 


  {
#line 3302
  return ((struct dfa *)d->superset);
}
}
#line 3305
_Bool dfaisfast(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 3305 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
_Bool dfaisfast(struct dfa  const  *d ) 
{ 


  {
#line 3308
  return ((_Bool )d->fast);
}
}
#line 3311 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void free_mbdata(struct dfa *d ) 
{ 
  state_num s ;

  {
  {
#line 3314
  free((void *)d->multibyte_prop);
#line 3315
  free((void *)d->lex.brack.chars);
#line 3316
  free((void *)d->mb_follows.elems);
  }
#line 3318
  if (d->mb_trans) {
#line 3321
    s = (state_num )-1;
    {
#line 3321
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3321
      if (! (s < d->tralloc)) {
#line 3321
        goto while_break;
      }
      {
#line 3322
      free((void *)*(d->mb_trans + s));
#line 3321
      s ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3323
    free((void *)(d->mb_trans - 2));
    }
  }
#line 3325
  return;
}
}
#line 3328 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static _Bool __attribute__((__pure__))  dfa_supported(struct dfa  const  *d ) 
{ 
  size_t i ;

  {
#line 3331
  i = (size_t )0;
  {
#line 3331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3331
    if (! (i < (size_t )d->tindex)) {
#line 3331
      goto while_break;
    }
    {
#line 3338
    if (*(d->tokens + i) == 263L) {
#line 3338
      goto case_263;
    }
#line 3338
    if (*(d->tokens + i) == 262L) {
#line 3338
      goto case_263;
    }
#line 3338
    if (*(d->tokens + i) == 261L) {
#line 3338
      goto case_263;
    }
#line 3338
    if (*(d->tokens + i) == 260L) {
#line 3338
      goto case_263;
    }
#line 3343
    if (*(d->tokens + i) == 273L) {
#line 3343
      goto case_273;
    }
#line 3343
    if (*(d->tokens + i) == 257L) {
#line 3343
      goto case_273;
    }
#line 3333
    goto switch_break;
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 3339
    if (! d->localeinfo.multibyte) {
#line 3340
      goto __Cont;
    }
    case_273: /* CIL Label */ 
    case_257: /* CIL Label */ 
#line 3344
    return ((_Bool __attribute__((__pure__))  )0);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 3331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3347
  return ((_Bool __attribute__((__pure__))  )1);
}
}
#line 3350 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void dfaoptimize(struct dfa *d ) 
{ 
  _Bool have_backref ;
  size_t i ;

  {
#line 3353
  if (! d->localeinfo.using_utf8) {
#line 3354
    return;
  }
#line 3356
  have_backref = (_Bool)0;
#line 3357
  i = (size_t )0;
  {
#line 3357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3357
    if (! (i < d->tindex)) {
#line 3357
      goto while_break;
    }
    {
#line 3361
    if (*(d->tokens + i) == 272L) {
#line 3361
      goto case_272;
    }
#line 3364
    if (*(d->tokens + i) == 257L) {
#line 3364
      goto case_257;
    }
#line 3367
    if (*(d->tokens + i) == 273L) {
#line 3367
      goto case_273;
    }
#line 3370
    goto switch_default;
    case_272: /* CIL Label */ 
    {
#line 3363
    abort();
    }
    case_257: /* CIL Label */ 
#line 3365
    have_backref = (_Bool)1;
#line 3366
    goto switch_break;
    case_273: /* CIL Label */ 
#line 3369
    return;
    switch_default: /* CIL Label */ 
#line 3371
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3357
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3375
  if (! have_backref) {
#line 3375
    if (d->superset) {
      {
#line 3378
      dfafree(d->superset);
#line 3379
      free((void *)d->superset);
#line 3380
      d->superset = (struct dfa *)((void *)0);
      }
    }
  }
  {
#line 3383
  free_mbdata(d);
#line 3384
  d->localeinfo.multibyte = (_Bool)0;
#line 3385
  d->dfaexec = & dfaexec_sb;
#line 3386
  d->fast = (_Bool)1;
  }
#line 3387
  return;
}
}
#line 3389 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void dfassbuild(struct dfa *d ) 
{ 
  struct dfa *sup ;
  struct dfa *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  _Bool have_achar ;
  _Bool have_nchar ;
  size_t j ;
  size_t i ;
  charclass ccl ;
  size_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 3392
  tmp = dfaalloc();
#line 3392
  sup = tmp;
#line 3394
  *sup = *d;
#line 3395
  sup->localeinfo.multibyte = (_Bool)0;
#line 3396
  sup->dfaexec = & dfaexec_sb;
#line 3397
  sup->multibyte_prop = (char *)((void *)0);
#line 3398
  sup->superset = (struct dfa *)((void *)0);
#line 3399
  sup->states = (dfa_state *)((void *)0);
#line 3400
  sup->sindex = (state_num )0;
#line 3401
  sup->follows = (position_set *)((void *)0);
#line 3402
  sup->tralloc = (state_num )0;
#line 3403
  sup->trans = (state_num **)((void *)0);
#line 3404
  sup->fails = (state_num **)((void *)0);
#line 3405
  sup->success = (char *)((void *)0);
#line 3406
  sup->newlines = (state_num *)((void *)0);
#line 3408
  tmp___0 = xnmalloc((size_t )sup->calloc, sizeof(*(sup->charclasses)));
#line 3408
  sup->charclasses = (charclass *)tmp___0;
  }
#line 3409
  if (d->cindex) {
    {
#line 3411
    memcpy((void */* __restrict  */)sup->charclasses, (void const   */* __restrict  */)d->charclasses,
           (unsigned long )d->cindex * sizeof(*(sup->charclasses)));
    }
  }
  {
#line 3415
  tmp___1 = xnmalloc(d->tindex, 2UL * sizeof(*(sup->tokens)));
#line 3415
  sup->tokens = (token *)tmp___1;
#line 3416
  sup->talloc = d->tindex * 2UL;
#line 3418
  have_achar = (_Bool)0;
#line 3419
  have_nchar = (_Bool)0;
#line 3421
  j = (size_t )0;
#line 3421
  i = j;
  }
  {
#line 3421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3421
    if (! (i < d->tindex)) {
#line 3421
      goto while_break;
    }
    {
#line 3427
    if (*(d->tokens + i) == 257L) {
#line 3427
      goto case_257;
    }
#line 3427
    if (*(d->tokens + i) == 273L) {
#line 3427
      goto case_257;
    }
#line 3427
    if (*(d->tokens + i) == 272L) {
#line 3427
      goto case_257;
    }
#line 3442
    if (*(d->tokens + i) == 263L) {
#line 3442
      goto case_263;
    }
#line 3442
    if (*(d->tokens + i) == 262L) {
#line 3442
      goto case_263;
    }
#line 3442
    if (*(d->tokens + i) == 261L) {
#line 3442
      goto case_263;
    }
#line 3442
    if (*(d->tokens + i) == 260L) {
#line 3442
      goto case_263;
    }
#line 3451
    goto switch_default;
    case_257: /* CIL Label */ 
    case_273: /* CIL Label */ 
    case_272: /* CIL Label */ 
    {
#line 3430
    fillset(& ccl);
#line 3431
    tmp___2 = j;
#line 3431
    j ++;
#line 3431
    tmp___3 = charclass_index(sup, & ccl);
#line 3431
    *(sup->tokens + tmp___2) = 275L + tmp___3;
#line 3432
    tmp___4 = j;
#line 3432
    j ++;
#line 3432
    *(sup->tokens + tmp___4) = (token )265;
    }
#line 3433
    if (*(d->tokens + (i + 1UL)) == 264L) {
#line 3435
      i ++;
    } else
#line 3433
    if (*(d->tokens + (i + 1UL)) == 265L) {
#line 3435
      i ++;
    } else
#line 3433
    if (*(d->tokens + (i + 1UL)) == 266L) {
#line 3435
      i ++;
    }
#line 3436
    have_achar = (_Bool)1;
#line 3438
    goto switch_break;
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 3443
    if (d->localeinfo.multibyte) {
#line 3447
      tmp___5 = j;
#line 3447
      j ++;
#line 3447
      *(sup->tokens + tmp___5) = (token )256;
#line 3448
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 3452
    tmp___6 = j;
#line 3452
    j ++;
#line 3452
    *(sup->tokens + tmp___6) = *(d->tokens + i);
#line 3453
    if (0L <= *(d->tokens + i)) {
#line 3453
      if (*(d->tokens + i) < 256L) {
#line 3455
        have_nchar = (_Bool)1;
      } else {
#line 3453
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3453
    if (*(d->tokens + i) >= 275L) {
#line 3455
      have_nchar = (_Bool)1;
    }
#line 3456
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3421
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3459
  sup->tindex = j;
#line 3461
  if (have_nchar) {
#line 3461
    if (have_achar) {
#line 3462
      d->superset = sup;
    } else
#line 3461
    if (d->localeinfo.multibyte) {
#line 3462
      d->superset = sup;
    } else {
      {
#line 3465
      dfafree(sup);
#line 3466
      free((void *)sup);
      }
    }
  } else {
    {
#line 3465
    dfafree(sup);
#line 3466
    free((void *)sup);
    }
  }
#line 3468
  return;
}
}
#line 3471 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
void dfacomp(char const   *s , size_t len , struct dfa *d , _Bool searchflag ) 
{ 
  _Bool __attribute__((__pure__))  tmp ;

  {
  {
#line 3474
  dfaparse(s, len, d);
#line 3475
  dfassbuild(d);
#line 3477
  tmp = dfa_supported((struct dfa  const  *)d);
  }
#line 3477
  if (tmp) {
    {
#line 3479
    dfaoptimize(d);
#line 3480
    dfaanalyze(d, searchflag);
    }
  } else {
#line 3484
    d->dfaexec = & dfaexec_noop;
  }
#line 3487
  if (d->superset) {
    {
#line 3489
    d->fast = (_Bool)1;
#line 3490
    dfaanalyze(d->superset, searchflag);
    }
  }
#line 3492
  return;
}
}
#line 3495 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
void dfafree(struct dfa *d ) 
{ 
  size_t i ;
  size_t i___0 ;
  size_t i___1 ;

  {
  {
#line 3498
  free((void *)d->charclasses);
#line 3499
  free((void *)d->tokens);
  }
#line 3501
  if (d->localeinfo.multibyte) {
    {
#line 3502
    free_mbdata(d);
    }
  }
#line 3504
  i = (size_t )0;
  {
#line 3504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3504
    if (! (i < (size_t )d->sindex)) {
#line 3504
      goto while_break;
    }
    {
#line 3506
    free((void *)(d->states + i)->elems.elems);
#line 3507
    free((void *)(d->states + i)->mbps.elems);
#line 3504
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3509
  free((void *)d->states);
  }
#line 3511
  if (d->follows) {
#line 3513
    i___0 = (size_t )0;
    {
#line 3513
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3513
      if (! (i___0 < d->tindex)) {
#line 3513
        goto while_break___0;
      }
      {
#line 3514
      free((void *)(d->follows + i___0)->elems);
#line 3513
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3515
    free((void *)d->follows);
    }
  }
#line 3518
  if (d->trans) {
#line 3520
    i___1 = (size_t )0;
    {
#line 3520
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3520
      if (! (i___1 < (size_t )d->tralloc)) {
#line 3520
        goto while_break___1;
      }
      {
#line 3522
      free((void *)*(d->trans + i___1));
#line 3523
      free((void *)*(d->fails + i___1));
#line 3520
      i___1 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3526
    free((void *)(d->trans - 2));
#line 3527
    free((void *)d->fails);
#line 3528
    free((void *)d->newlines);
#line 3529
    free((void *)d->success);
    }
  }
#line 3532
  if (d->superset) {
    {
#line 3533
    dfafree(d->superset);
    }
  }
#line 3534
  return;
}
}
#line 3618 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static char *icatalloc(char *old , char const   *new ) 
{ 
  size_t newsize ;
  size_t tmp ;
  size_t oldsize ;
  size_t tmp___0 ;
  char *result ;
  void *tmp___1 ;

  {
  {
#line 3621
  tmp = strlen(new);
#line 3621
  newsize = tmp;
  }
#line 3622
  if (newsize == 0UL) {
#line 3623
    return (old);
  }
  {
#line 3624
  tmp___0 = strlen((char const   *)old);
#line 3624
  oldsize = tmp___0;
#line 3625
  tmp___1 = xrealloc((void *)old, (oldsize + newsize) + 1UL);
#line 3625
  result = (char *)tmp___1;
#line 3626
  memcpy((void */* __restrict  */)(result + oldsize), (void const   */* __restrict  */)new,
         newsize + 1UL);
  }
#line 3627
  return (result);
}
}
#line 3630 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void freelist(char **cpp ) 
{ 
  char **tmp ;

  {
  {
#line 3633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3633
    if (! *cpp) {
#line 3633
      goto while_break;
    }
    {
#line 3634
    tmp = cpp;
#line 3634
    cpp ++;
#line 3634
    free((void *)*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3635
  return;
}
}
#line 3637 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static char **enlist(char **cpp , char *new , size_t len ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  size_t i ;
  char *tmp___1 ;
  size_t j ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3640
  tmp = xmalloc(len + 1UL);
#line 3640
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)new,
                   len);
#line 3640
  new = (char *)tmp___0;
#line 3641
  *(new + len) = (char )'\000';
#line 3644
  i = (size_t )0;
  }
  {
#line 3644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3644
    if (! ((unsigned long )*(cpp + i) != (unsigned long )((void *)0))) {
#line 3644
      goto while_break;
    }
    {
#line 3645
    tmp___1 = strstr((char const   *)*(cpp + i), (char const   *)new);
    }
#line 3645
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 3647
      free((void *)new);
      }
#line 3648
      return (cpp);
    }
#line 3644
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3651
  j = (size_t )0;
  {
#line 3651
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3651
    if (! ((unsigned long )*(cpp + j) != (unsigned long )((void *)0))) {
#line 3651
      goto while_break___0;
    }
    {
#line 3652
    tmp___2 = strstr((char const   *)new, (char const   *)*(cpp + j));
    }
#line 3652
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 3653
      j ++;
    } else {
      {
#line 3656
      free((void *)*(cpp + j));
#line 3657
      i --;
      }
#line 3657
      if (i == j) {
#line 3658
        goto while_break___0;
      }
#line 3659
      *(cpp + j) = *(cpp + i);
#line 3660
      *(cpp + i) = (char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3663
  tmp___3 = xnrealloc((void *)cpp, i + 2UL, sizeof(*cpp));
#line 3663
  cpp = (char **)tmp___3;
#line 3664
  *(cpp + i) = new;
#line 3665
  *(cpp + (i + 1UL)) = (char *)((void *)0);
  }
#line 3666
  return (cpp);
}
}
#line 3671 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static char **comsubs(char *left , char const   *right ) 
{ 
  char **cpp ;
  void *tmp ;
  char *lcp ;
  size_t len ;
  char *rcp ;
  char *tmp___0 ;
  size_t i ;

  {
  {
#line 3674
  tmp = xzalloc(sizeof(*cpp));
#line 3674
  cpp = (char **)tmp;
#line 3676
  lcp = left;
  }
  {
#line 3676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3676
    if (! ((int )*lcp != 0)) {
#line 3676
      goto while_break;
    }
    {
#line 3678
    len = (size_t )0;
#line 3679
    tmp___0 = strchr(right, (int )*lcp);
#line 3679
    rcp = tmp___0;
    }
    {
#line 3680
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3680
      if (! ((unsigned long )rcp != (unsigned long )((void *)0))) {
#line 3680
        goto while_break___0;
      }
#line 3683
      i = (size_t )1;
      {
#line 3683
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3683
        if ((int )*(lcp + i) != 0) {
#line 3683
          if (! ((int )*(lcp + i) == (int )*(rcp + i))) {
#line 3683
            goto while_break___1;
          }
        } else {
#line 3683
          goto while_break___1;
        }
#line 3684
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 3683
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3685
      if (i > len) {
#line 3686
        len = i;
      }
      {
#line 3687
      rcp = strchr((char const   *)(rcp + 1), (int )*lcp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3689
    if (len != 0UL) {
      {
#line 3690
      cpp = enlist(cpp, lcp, len);
      }
    }
#line 3676
    lcp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3692
  return (cpp);
}
}
#line 3695 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static char **addlists(char **old , char **new ) 
{ 
  size_t tmp ;

  {
  {
#line 3698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3698
    if (! *new) {
#line 3698
      goto while_break;
    }
    {
#line 3699
    tmp = strlen((char const   *)*new);
#line 3699
    old = enlist(old, *new, tmp);
#line 3698
    new ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3700
  return (old);
}
}
#line 3705 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static char **inboth(char **left , char **right ) 
{ 
  char **both ;
  void *tmp ;
  size_t lnum ;
  size_t rnum ;
  char **temp ;
  char **tmp___0 ;

  {
  {
#line 3708
  tmp = xzalloc(sizeof(*both));
#line 3708
  both = (char **)tmp;
#line 3710
  lnum = (size_t )0;
  }
  {
#line 3710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3710
    if (! ((unsigned long )*(left + lnum) != (unsigned long )((void *)0))) {
#line 3710
      goto while_break;
    }
#line 3712
    rnum = (size_t )0;
    {
#line 3712
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3712
      if (! ((unsigned long )*(right + rnum) != (unsigned long )((void *)0))) {
#line 3712
        goto while_break___0;
      }
      {
#line 3714
      tmp___0 = comsubs(*(left + lnum), (char const   *)*(right + rnum));
#line 3714
      temp = tmp___0;
#line 3715
      both = addlists(both, temp);
#line 3716
      freelist(temp);
#line 3717
      free((void *)temp);
#line 3712
      rnum ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3710
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3720
  return (both);
}
}
#line 3736 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static must *allocmust(must *mp , size_t size ) 
{ 
  must *new_mp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3739
  tmp = xmalloc(sizeof(*new_mp));
#line 3739
  new_mp = (must *)tmp;
#line 3740
  tmp___0 = xzalloc(sizeof(*(new_mp->in)));
#line 3740
  new_mp->in = (char **)tmp___0;
#line 3741
  tmp___1 = xzalloc(size);
#line 3741
  new_mp->left = (char *)tmp___1;
#line 3742
  tmp___2 = xzalloc(size);
#line 3742
  new_mp->right = (char *)tmp___2;
#line 3743
  tmp___3 = xzalloc(size);
#line 3743
  new_mp->is = (char *)tmp___3;
#line 3744
  new_mp->begline = (_Bool)0;
#line 3745
  new_mp->endline = (_Bool)0;
#line 3746
  new_mp->prev = mp;
  }
#line 3747
  return (new_mp);
}
}
#line 3750 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void resetmust(must *mp ) 
{ 
  char tmp ;
  char tmp___0 ;

  {
  {
#line 3753
  freelist(mp->in);
#line 3754
  *(mp->in + 0) = (char *)((void *)0);
#line 3755
  tmp___0 = (char )'\000';
#line 3755
  *(mp->is + 0) = tmp___0;
#line 3755
  tmp = tmp___0;
#line 3755
  *(mp->right + 0) = tmp;
#line 3755
  *(mp->left + 0) = tmp;
#line 3756
  mp->begline = (_Bool)0;
#line 3757
  mp->endline = (_Bool)0;
  }
#line 3758
  return;
}
}
#line 3760 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
static void freemust(must *mp ) 
{ 


  {
  {
#line 3763
  freelist(mp->in);
#line 3764
  free((void *)mp->in);
#line 3765
  free((void *)mp->left);
#line 3766
  free((void *)mp->right);
#line 3767
  free((void *)mp->is);
#line 3768
  free((void *)mp);
  }
#line 3769
  return;
}
}
#line 3771 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct dfamust *dfamust(struct dfa  const  *d ) 
{ 
  must *mp ;
  char const   *result ;
  _Bool exact ;
  _Bool begline ;
  _Bool endline ;
  _Bool need_begline ;
  _Bool need_endline ;
  _Bool case_fold_unibyte ;
  size_t tmp ;
  int tmp___0 ;
  size_t ri ;
  token t ;
  char **new ;
  must *rmp ;
  must *lmp ;
  size_t j ;
  size_t ln ;
  size_t rn ;
  size_t n ;
  _Bool tmp___1 ;
  size_t i ;
  size_t i___0 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  _Bool tmp___5 ;
  must *rmp___0 ;
  must *lmp___0 ;
  size_t lrlen ;
  size_t tmp___6 ;
  size_t rllen ;
  size_t tmp___7 ;
  char *tp ;
  void *tmp___8 ;
  charclass *ccl ;
  int j___0 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t rj ;
  char tmp___13 ;
  char tmp___14 ;
  int tmp___15 ;
  size_t i___1 ;
  char tmp___16 ;
  char tmp___17 ;
  int tmp___18 ;
  char tmp___19 ;
  char tmp___20 ;
  struct dfamust *dm ;
  void *tmp___21 ;
  must *prev ;

  {
#line 3774
  mp = (must *)((void *)0);
#line 3775
  result = "";
#line 3776
  exact = (_Bool)0;
#line 3777
  begline = (_Bool)0;
#line 3778
  endline = (_Bool)0;
#line 3779
  need_begline = (_Bool)0;
#line 3780
  need_endline = (_Bool)0;
#line 3781
  if (d->syntax.case_fold) {
    {
#line 3781
    tmp = __ctype_get_mb_cur_max();
    }
#line 3781
    if (tmp == 1UL) {
#line 3781
      tmp___0 = 1;
    } else {
#line 3781
      tmp___0 = 0;
    }
  } else {
#line 3781
    tmp___0 = 0;
  }
#line 3781
  case_fold_unibyte = (_Bool )tmp___0;
#line 3783
  ri = (size_t )0;
  {
#line 3783
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3783
    if (! (ri < (size_t )d->tindex)) {
#line 3783
      goto while_break;
    }
#line 3785
    t = *(d->tokens + ri);
    {
#line 3788
    if (t == 258L) {
#line 3788
      goto case_258;
    }
#line 3793
    if (t == 259L) {
#line 3793
      goto case_259;
    }
#line 3799
    if (t == 271L) {
#line 3799
      goto case_271;
    }
#line 3799
    if (t == 270L) {
#line 3799
      goto case_271;
    }
#line 3809
    if (t == 273L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 272L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 257L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 263L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 262L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 261L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 260L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 256L) {
#line 3809
      goto case_273;
    }
#line 3814
    if (t == 264L) {
#line 3814
      goto case_264;
    }
#line 3814
    if (t == 265L) {
#line 3814
      goto case_264;
    }
#line 3818
    if (t == 269L) {
#line 3818
      goto case_269;
    }
#line 3862
    if (t == 266L) {
#line 3862
      goto case_266;
    }
#line 3866
    if (t == -1L) {
#line 3866
      goto case_neg_1;
    }
#line 3881
    if (t == 268L) {
#line 3881
      goto case_268;
    }
#line 3924
    if (t == 0L) {
#line 3924
      goto case_0;
    }
#line 3928
    goto switch_default;
    case_258: /* CIL Label */ 
    {
#line 3789
    mp = allocmust(mp, (size_t )2);
#line 3790
    mp->begline = (_Bool)1;
#line 3791
    need_begline = (_Bool)1;
    }
#line 3792
    goto switch_break;
    case_259: /* CIL Label */ 
    {
#line 3794
    mp = allocmust(mp, (size_t )2);
#line 3795
    mp->endline = (_Bool)1;
#line 3796
    need_endline = (_Bool)1;
    }
#line 3797
    goto switch_break;
    case_271: /* CIL Label */ 
    case_270: /* CIL Label */ 
    {
#line 3800
    __assert_fail("!\"neither LPAREN nor RPAREN may appear here\"", "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c",
                  3800U, "dfamust");
    }
    case_273: /* CIL Label */ 
    case_272: /* CIL Label */ 
    case_257: /* CIL Label */ 
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
    case_256: /* CIL Label */ 
    {
#line 3810
    mp = allocmust(mp, (size_t )2);
    }
#line 3811
    goto switch_break;
    case_264: /* CIL Label */ 
    case_265: /* CIL Label */ 
    {
#line 3815
    resetmust(mp);
    }
#line 3816
    goto switch_break;
    case_269: /* CIL Label */ 
    {
#line 3821
    rmp = mp;
#line 3822
    mp = mp->prev;
#line 3822
    lmp = mp;
#line 3826
    tmp___1 = streq((char const   *)lmp->is, (char const   *)rmp->is);
    }
#line 3826
    if (tmp___1) {
#line 3828
      lmp->begline = (_Bool )((int )lmp->begline & (int )rmp->begline);
#line 3829
      lmp->endline = (_Bool )((int )lmp->endline & (int )rmp->endline);
    } else {
#line 3833
      *(lmp->is + 0) = (char )'\000';
#line 3834
      lmp->begline = (_Bool)0;
#line 3835
      lmp->endline = (_Bool)0;
    }
#line 3838
    i = (size_t )0;
    {
#line 3839
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3839
      if ((int )*(lmp->left + i) != 0) {
#line 3839
        if (! ((int )*(lmp->left + i) == (int )*(rmp->left + i))) {
#line 3839
          goto while_break___0;
        }
      } else {
#line 3839
        goto while_break___0;
      }
#line 3840
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3841
    *(lmp->left + i) = (char )'\000';
#line 3843
    ln = strlen((char const   *)lmp->right);
#line 3844
    rn = strlen((char const   *)rmp->right);
#line 3845
    n = ln;
    }
#line 3846
    if (n > rn) {
#line 3847
      n = rn;
    }
#line 3848
    i = (size_t )0;
    {
#line 3848
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3848
      if (! (i < n)) {
#line 3848
        goto while_break___1;
      }
#line 3849
      if ((int )*(lmp->right + ((ln - i) - 1UL)) != (int )*(rmp->right + ((rn - i) - 1UL))) {
#line 3850
        goto while_break___1;
      }
#line 3848
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3851
    j = (size_t )0;
    {
#line 3851
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3851
      if (! (j < i)) {
#line 3851
        goto while_break___2;
      }
#line 3852
      *(lmp->right + j) = *(lmp->right + ((ln - i) + j));
#line 3851
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3853
    *(lmp->right + j) = (char )'\000';
#line 3854
    new = inboth(lmp->in, rmp->in);
#line 3855
    freelist(lmp->in);
#line 3856
    free((void *)lmp->in);
#line 3857
    lmp->in = new;
#line 3858
    freemust(rmp);
    }
#line 3860
    goto switch_break;
    case_266: /* CIL Label */ 
#line 3863
    *(mp->is + 0) = (char )'\000';
#line 3864
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 3867
    if (! (! mp->prev)) {
      {
#line 3867
      __assert_fail("!mp->prev", "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c",
                    3867U, "dfamust");
      }
    }
#line 3868
    i___0 = (size_t )0;
    {
#line 3868
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3868
      if (! ((unsigned long )*(mp->in + i___0) != (unsigned long )((void *)0))) {
#line 3868
        goto while_break___3;
      }
      {
#line 3869
      tmp___3 = strlen((char const   *)*(mp->in + i___0));
#line 3869
      tmp___4 = strlen(result);
      }
#line 3869
      if (tmp___3 > tmp___4) {
#line 3870
        result = (char const   *)*(mp->in + i___0);
      }
#line 3868
      i___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 3871
    tmp___5 = streq(result, (char const   *)mp->is);
    }
#line 3871
    if (tmp___5) {
#line 3873
      if (! need_begline) {
#line 3873
        goto _L;
      } else
#line 3873
      if (mp->begline) {
        _L: /* CIL Label */ 
#line 3873
        if (! need_endline) {
#line 3875
          exact = (_Bool)1;
        } else
#line 3873
        if (mp->endline) {
#line 3875
          exact = (_Bool)1;
        }
      }
#line 3876
      begline = mp->begline;
#line 3877
      endline = mp->endline;
    }
#line 3879
    goto done;
    case_268: /* CIL Label */ 
    {
#line 3883
    rmp___0 = mp;
#line 3884
    mp = mp->prev;
#line 3884
    lmp___0 = mp;
#line 3889
    lmp___0->in = addlists(lmp___0->in, rmp___0->in);
    }
#line 3890
    if ((int )*(lmp___0->right + 0) != 0) {
#line 3890
      if ((int )*(rmp___0->left + 0) != 0) {
        {
#line 3892
        tmp___6 = strlen((char const   *)lmp___0->right);
#line 3892
        lrlen = tmp___6;
#line 3893
        tmp___7 = strlen((char const   *)rmp___0->left);
#line 3893
        rllen = tmp___7;
#line 3894
        tmp___8 = xmalloc(lrlen + rllen);
#line 3894
        tp = (char *)tmp___8;
#line 3895
        memcpy((void */* __restrict  */)tp, (void const   */* __restrict  */)lmp___0->right,
               lrlen);
#line 3896
        memcpy((void */* __restrict  */)(tp + lrlen), (void const   */* __restrict  */)rmp___0->left,
               rllen);
#line 3897
        lmp___0->in = enlist(lmp___0->in, tp, lrlen + rllen);
#line 3898
        free((void *)tp);
        }
      }
    }
#line 3901
    if ((int )*(lmp___0->is + 0) != 0) {
      {
#line 3902
      lmp___0->left = icatalloc(lmp___0->left, (char const   *)rmp___0->left);
      }
    }
#line 3904
    if ((int )*(rmp___0->is + 0) == 0) {
#line 3905
      *(lmp___0->right + 0) = (char )'\000';
    }
    {
#line 3906
    lmp___0->right = icatalloc(lmp___0->right, (char const   *)rmp___0->right);
    }
#line 3908
    if ((int )*(lmp___0->is + 0) != 0) {
#line 3908
      goto _L___0;
    } else
#line 3908
    if (lmp___0->begline) {
      _L___0: /* CIL Label */ 
#line 3908
      if ((int )*(rmp___0->is + 0) != 0) {
        {
#line 3911
        lmp___0->is = icatalloc(lmp___0->is, (char const   *)rmp___0->is);
#line 3912
        lmp___0->endline = rmp___0->endline;
        }
      } else
#line 3908
      if (rmp___0->endline) {
        {
#line 3911
        lmp___0->is = icatalloc(lmp___0->is, (char const   *)rmp___0->is);
#line 3912
        lmp___0->endline = rmp___0->endline;
        }
      } else {
#line 3916
        *(lmp___0->is + 0) = (char )'\000';
#line 3917
        lmp___0->begline = (_Bool)0;
#line 3918
        lmp___0->endline = (_Bool)0;
      }
    } else {
#line 3916
      *(lmp___0->is + 0) = (char )'\000';
#line 3917
      lmp___0->begline = (_Bool)0;
#line 3918
      lmp___0->endline = (_Bool)0;
    }
    {
#line 3920
    freemust(rmp___0);
    }
#line 3922
    goto switch_break;
    case_0: /* CIL Label */ 
#line 3926
    goto done;
    switch_default: /* CIL Label */ 
#line 3929
    if (275L <= t) {
#line 3935
      ccl = d->charclasses + (t - 275L);
#line 3937
      j___0 = 0;
      {
#line 3937
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3937
        if (! (j___0 < 256)) {
#line 3937
          goto while_break___4;
        }
        {
#line 3938
        tmp___9 = tstbit((unsigned int )j___0, (charclass const   *)ccl);
        }
#line 3938
        if (tmp___9) {
#line 3939
          goto while_break___4;
        }
#line 3937
        j___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 3940
      if (! (j___0 < 256)) {
        {
#line 3942
        mp = allocmust(mp, (size_t )2);
        }
#line 3943
        goto switch_break;
      }
#line 3945
      t = (token )j___0;
      {
#line 3946
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3946
        j___0 ++;
#line 3946
        if (! (j___0 < 256)) {
#line 3946
          goto while_break___5;
        }
        {
#line 3947
        tmp___10 = tstbit((unsigned int )j___0, (charclass const   *)ccl);
        }
#line 3947
        if (tmp___10) {
#line 3947
          if (case_fold_unibyte) {
            {
#line 3947
            tmp___11 = toupper(j___0);
#line 3947
            tmp___12 = toupper((int )t);
            }
#line 3947
            if (! (tmp___11 == tmp___12)) {
#line 3950
              goto while_break___5;
            }
          } else {
#line 3950
            goto while_break___5;
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 3951
      if (j___0 < 256) {
        {
#line 3953
        mp = allocmust(mp, (size_t )2);
        }
#line 3954
        goto switch_break;
      }
    }
#line 3958
    rj = ri + 2UL;
#line 3959
    if (*(d->tokens + (ri + 1UL)) == 268L) {
      {
#line 3961
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 3961
        if (! (rj < (size_t )(d->tindex - 1UL))) {
#line 3961
          goto while_break___6;
        }
#line 3963
        if (rj != ri) {
#line 3963
          if (*(d->tokens + rj) <= 0L) {
#line 3966
            goto while_break___6;
          } else
#line 3963
          if (256L <= *(d->tokens + rj)) {
#line 3966
            goto while_break___6;
          } else {
#line 3963
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 3963
        if (*(d->tokens + (rj + 1UL)) != 268L) {
#line 3966
          goto while_break___6;
        }
#line 3961
        rj += 2UL;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 3969
    mp = allocmust(mp, ((rj - ri) >> 1) + 1UL);
    }
#line 3970
    if (case_fold_unibyte) {
      {
#line 3970
      tmp___15 = toupper((int )t);
#line 3970
      tmp___14 = (char )tmp___15;
      }
    } else {
#line 3970
      tmp___14 = (char )t;
    }
#line 3970
    *(mp->right + 0) = tmp___14;
#line 3970
    tmp___13 = tmp___14;
#line 3970
    *(mp->left + 0) = tmp___13;
#line 3970
    *(mp->is + 0) = tmp___13;
#line 3974
    i___1 = (size_t )1;
    {
#line 3974
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 3974
      if (! (ri + 2UL < rj)) {
#line 3974
        goto while_break___7;
      }
#line 3976
      ri += 2UL;
#line 3977
      t = *(d->tokens + ri);
#line 3978
      if (case_fold_unibyte) {
        {
#line 3978
        tmp___18 = toupper((int )t);
#line 3978
        tmp___17 = (char )tmp___18;
        }
      } else {
#line 3978
        tmp___17 = (char )t;
      }
#line 3978
      *(mp->right + i___1) = tmp___17;
#line 3978
      tmp___16 = tmp___17;
#line 3978
      *(mp->left + i___1) = tmp___16;
#line 3978
      *(mp->is + i___1) = tmp___16;
#line 3974
      i___1 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 3981
    tmp___20 = (char )'\000';
#line 3981
    *(mp->right + i___1) = tmp___20;
#line 3981
    tmp___19 = tmp___20;
#line 3981
    *(mp->left + i___1) = tmp___19;
#line 3981
    *(mp->is + i___1) = tmp___19;
#line 3982
    mp->in = enlist(mp->in, mp->is, i___1);
    }
#line 3983
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3783
    ri ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 3988
  dm = (struct dfamust *)((void *)0);
#line 3989
  if (*result) {
    {
#line 3991
    tmp___21 = xmalloc(sizeof(*dm));
#line 3991
    dm = (struct dfamust *)tmp___21;
#line 3992
    dm->exact = exact;
#line 3993
    dm->begline = begline;
#line 3994
    dm->endline = endline;
#line 3995
    dm->must = xstrdup(result);
    }
  }
  {
#line 3998
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 3998
    if (! mp) {
#line 3998
      goto while_break___8;
    }
    {
#line 4000
    prev = mp->prev;
#line 4001
    freemust(mp);
#line 4002
    mp = prev;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 4005
  return (dm);
}
}
#line 4008 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
void dfamustfree(struct dfamust *dm ) 
{ 


  {
  {
#line 4011
  free((void *)dm->must);
#line 4012
  free((void *)dm);
  }
#line 4013
  return;
}
}
#line 4015
struct dfa *dfaalloc(void)  __attribute__((__malloc__)) ;
#line 4015 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
struct dfa *dfaalloc(void) 
{ 
  void *tmp ;

  {
  {
#line 4018
  tmp = xmalloc(sizeof(struct dfa ));
  }
#line 4018
  return ((struct dfa *)tmp);
}
}
#line 4022 "/home/khheo/project/benchmark/sed-4.5/lib/dfa.c"
void dfasyntax(struct dfa *dfa , struct localeinfo  const  *linfo , reg_syntax_t bits ,
               int dfaopts ) 
{ 
  int i ;
  unsigned char uc ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 4026
  memset((void *)dfa, 0, (unsigned long )(& ((struct dfa *)0)->dfaexec));
  }
#line 4027
  if (linfo->multibyte) {
#line 4027
    dfa->dfaexec = & dfaexec_mb;
  } else {
#line 4027
    dfa->dfaexec = & dfaexec_sb;
  }
  {
#line 4028
  dfa->simple_locale = using_simple_locale((_Bool )linfo->multibyte);
#line 4029
  dfa->localeinfo = (struct localeinfo )*linfo;
#line 4031
  dfa->fast = (_Bool )(! dfa->localeinfo.multibyte);
#line 4033
  dfa->canychar = (size_t )-1;
#line 4034
  dfa->lex.cur_mb_len = 1;
#line 4035
  dfa->syntax.syntax_bits_set = (_Bool)1;
#line 4036
  dfa->syntax.case_fold = (_Bool )((bits & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) != 0UL);
#line 4037
  dfa->syntax.anchor = (_Bool )((dfaopts & 1) != 0);
  }
#line 4038
  if (dfaopts & 2) {
#line 4038
    dfa->syntax.eolbyte = (unsigned char )'\000';
  } else {
#line 4038
    dfa->syntax.eolbyte = (unsigned char )'\n';
  }
#line 4039
  dfa->syntax.syntax_bits = bits;
#line 4041
  i = -128;
  {
#line 4041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4041
    if (! (i <= 127)) {
#line 4041
      goto while_break;
    }
    {
#line 4043
    uc = (unsigned char )i;
#line 4045
    tmp = char_context((struct dfa  const  *)dfa, uc);
#line 4045
    dfa->syntax.sbit[uc] = (char )tmp;
    }
    {
#line 4048
    if ((int )dfa->syntax.sbit[uc] == 2) {
#line 4048
      goto case_2;
    }
#line 4051
    if ((int )dfa->syntax.sbit[uc] == 4) {
#line 4051
      goto case_4;
    }
#line 4046
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 4049
    setbit((unsigned int )uc, & dfa->syntax.letters);
    }
#line 4050
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 4052
    setbit((unsigned int )uc, & dfa->syntax.newline);
    }
#line 4053
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 4058
    if (dfa->localeinfo.using_utf8) {
#line 4058
      dfa->syntax.never_trail[uc] = (_Bool )(((int )uc & 192) != 128);
    } else {
      {
#line 4058
      tmp___0 = strchr("\n\r./", (int )uc);
#line 4058
      dfa->syntax.never_trail[uc] = (_Bool )((unsigned long )tmp___0 != (unsigned long )((void *)0));
      }
    }
#line 4041
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4062
  return;
}
}
#line 32 "/home/khheo/project/benchmark/sed-4.5/lib/acl.h"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) ;
#line 42 "/home/khheo/project/benchmark/sed-4.5/lib/copy-acl.c"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) 
{ 
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 46
  tmp = qcopy_acl(src_name, source_desc, dst_name, dest_desc, mode);
#line 46
  ret = tmp;
  }
  {
#line 49
  if (ret == -2) {
#line 49
    goto case_neg_2;
  }
#line 53
  if (ret == -1) {
#line 53
    goto case_neg_1;
  }
#line 57
  goto switch_default;
  case_neg_2: /* CIL Label */ 
  {
#line 50
  tmp___0 = quote(src_name);
#line 50
  tmp___1 = __errno_location();
#line 50
  error(0, *tmp___1, "%s", tmp___0);
  }
#line 51
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 54
  tmp___2 = quote(dst_name);
#line 54
  tmp___3 = gettext("preserving permissions for %s");
#line 54
  tmp___4 = __errno_location();
#line 54
  error(0, *tmp___4, (char const   *)tmp___3, tmp___2);
  }
#line 55
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 58
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 60
  return (ret);
}
}
#line 28 "/home/khheo/project/benchmark/sed-4.5/lib/closeout.h"
void close_stdout_set_file_name(char const   *file ) ;
#line 29
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
#line 30
void close_stdout(void) ;
#line 606 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 598 "./lib/unistd.h"
#pragma GCC diagnostic push
#line 598
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 598
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2086
#pragma GCC diagnostic pop
#line 2 "/home/khheo/project/benchmark/sed-4.5/lib/close-stream.h"
int close_stream(FILE *stream ) ;
#line 46 "/home/khheo/project/benchmark/sed-4.5/lib/closeout.c"
static char const   *file_name  ;
#line 50 "/home/khheo/project/benchmark/sed-4.5/lib/closeout.c"
void close_stdout_set_file_name(char const   *file ) 
{ 


  {
#line 53
  file_name = file;
#line 54
  return;
}
}
#line 56 "/home/khheo/project/benchmark/sed-4.5/lib/closeout.c"
static _Bool ignore_EPIPE  ;
#line 87 "/home/khheo/project/benchmark/sed-4.5/lib/closeout.c"
void close_stdout_set_ignore_EPIPE(_Bool ignore ) 
{ 


  {
#line 90
  ignore_EPIPE = ignore;
#line 91
  return;
}
}
#line 116 "/home/khheo/project/benchmark/sed-4.5/lib/closeout.c"
void close_stdout(void) 
{ 
  char const   *write_error ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 119
  tmp___3 = close_stream(stdout);
  }
#line 119
  if (tmp___3 != 0) {
#line 119
    if (ignore_EPIPE) {
      {
#line 119
      tmp___4 = __errno_location();
      }
#line 119
      if (! (*tmp___4 == 32)) {
#line 119
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 122
      tmp = gettext("write error");
#line 122
      write_error = (char const   *)tmp;
      }
#line 123
      if (file_name) {
        {
#line 124
        tmp___0 = quotearg_colon(file_name);
#line 124
        tmp___1 = __errno_location();
#line 124
        error(0, *tmp___1, "%s: %s", tmp___0, write_error);
        }
      } else {
        {
#line 127
        tmp___2 = __errno_location();
#line 127
        error(0, *tmp___2, "%s", write_error);
        }
      }
      {
#line 129
      _exit((int )exit_failure);
      }
    }
  }
  {
#line 134
  tmp___5 = close_stream(stderr);
  }
#line 134
  if (tmp___5 != 0) {
    {
#line 135
    _exit((int )exit_failure);
    }
  }
#line 136
  return;
}
}
#line 767 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 75 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __fpending)(FILE *__fp ) ;
#line 55 "/home/khheo/project/benchmark/sed-4.5/lib/close-stream.c"
int close_stream(FILE *stream ) 
{ 
  _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 58
  tmp = __fpending(stream);
#line 58
  some_pending = (_Bool )(tmp != 0UL);
#line 59
  tmp___0 = ferror_unlocked(stream);
#line 59
  prev_fail = (_Bool )(tmp___0 != 0);
#line 60
  tmp___1 = fclose(stream);
#line 60
  fclose_fail = (_Bool )(tmp___1 != 0);
  }
#line 70
  if (prev_fail) {
#line 70
    goto _L___0;
  } else
#line 70
  if (fclose_fail) {
#line 70
    if (some_pending) {
#line 70
      goto _L___0;
    } else {
      {
#line 70
      tmp___3 = __errno_location();
      }
#line 70
      if (*tmp___3 != 9) {
        _L___0: /* CIL Label */ 
#line 72
        if (! fclose_fail) {
          {
#line 73
          tmp___2 = __errno_location();
#line 73
          *tmp___2 = 0;
          }
        }
#line 74
        return (-1);
      }
    }
  }
#line 77
  return (0);
}
}
#line 47 "/home/khheo/project/benchmark/sed-4.5/lib/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 26 "/home/khheo/project/benchmark/sed-4.5/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/sed-4.5/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  } else
#line 33
  if (n == 0UL) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
#line 41
    n --;
    }
#line 41
    if (n == 0UL) {
#line 42
      goto while_break;
    } else
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 31 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 26 "/home/khheo/project/benchmark/sed-4.5/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/sed-4.5/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
    }
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 31 "/home/khheo/project/benchmark/sed-4.5/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/sed-4.5/lib/basename-lgpl.c"
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 29 "/home/khheo/project/benchmark/sed-4.5/lib/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = (_Bool)0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int const   )*base == 47)) {
#line 36
      goto while_break;
    }
#line 37
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  p = base;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! *p) {
#line 39
      goto while_break___0;
    }
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return ((char *)base);
}
}
#line 57
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 57 "/home/khheo/project/benchmark/sed-4.5/lib/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (1UL < len) {
#line 63
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 64
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 63
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (len);
}
}
#line 66 "/home/khheo/project/benchmark/sed-4.5/lib/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 302
#pragma GCC diagnostic pop
#line 478 "/home/khheo/project/benchmark/sed-4.5/lib/acl-internal.c"
void free_permission_context(struct permission_context *ctx )  __attribute__((__const__)) ;
#line 478 "/home/khheo/project/benchmark/sed-4.5/lib/acl-internal.c"
void free_permission_context(struct permission_context *ctx ) 
{ 


  {
#line 507
  return;
}
}
#line 27 "./lib/acl.h"
_Bool acl_errno_valid(int errnum )  __attribute__((__const__)) ;
#line 29 "/home/khheo/project/benchmark/sed-4.5/lib/acl-errno-valid.c"
_Bool acl_errno_valid(int errnum )  __attribute__((__const__)) ;
#line 29 "/home/khheo/project/benchmark/sed-4.5/lib/acl-errno-valid.c"
_Bool acl_errno_valid(int errnum ) 
{ 


  {
  {
#line 36
  if (errnum == 16) {
#line 36
    goto case_16;
  }
#line 37
  if (errnum == 22) {
#line 37
    goto case_22;
  }
#line 41
  if (errnum == 38) {
#line 41
    goto case_38;
  }
#line 49
  if (errnum == 95) {
#line 49
    goto case_95;
  }
#line 50
  goto switch_default;
  case_16: /* CIL Label */ 
#line 36
  return ((_Bool)0);
  case_22: /* CIL Label */ 
#line 37
  return ((_Bool)0);
  case_38: /* CIL Label */ 
#line 41
  return ((_Bool)0);
  case_95: /* CIL Label */ 
#line 49
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 50
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2 "/home/khheo/project/benchmark/sed-4.5/sed/version.c"
char const   *Version  =    "4.5";
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 213
extern int fflush_unlocked(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 320
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 545
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                          int __delimiter , FILE * __restrict  __stream ) ;
#line 673
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n ,
                             FILE * __restrict  __stream ) ;
#line 675
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr_unlocked)(FILE *__stream ) ;
#line 396 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 739 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkostemp)(char *__template , int __flags ) ;
#line 308 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 811 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 598 "./lib/unistd.h"
#pragma GCC diagnostic push
#line 598
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 598
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2086
#pragma GCC diagnostic pop
#line 82 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 61 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ngettext)(char const   *__msgid1 ,
                                                                                 char const   *__msgid2 ,
                                                                                 unsigned long __n )  __attribute__((__format_arg__(2),
__format_arg__(1))) ;
#line 30 "/home/khheo/project/benchmark/sed-4.5/sed/utils.h"
void ( /* format attribute */  panic)(char const   *str  , ...) ;
#line 32
FILE *ck_fopen(char const   *name , char const   *mode , int fail ) ;
#line 33
FILE *ck_fdopen(int fd , char const   *name , char const   *mode , int fail ) ;
#line 34
void ck_fwrite(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) ;
#line 35
size_t ck_fread(void *ptr , size_t size , size_t nmemb , FILE *stream ) ;
#line 36
void ck_fflush(FILE *stream ) ;
#line 37
void ck_fclose(FILE *stream ) ;
#line 38
char const   *follow_symlink(char const   *fname ) ;
#line 39
size_t ck_getdelim(char **text , size_t *buflen , char buffer_delimiter___0 , FILE *stream ) ;
#line 41
FILE *( __attribute__((__nonnull__(1,2,3,4))) ck_mkstemp)(char **p_filename , char const   *tmpdir ,
                                                          char const   *base , char const   *mode ) ;
#line 43
void ck_rename(char const   *from , char const   *to , char const   *unlink_if_fail ) ;
#line 45
void *ck_malloc(size_t size ) ;
#line 47
void *ck_realloc(void *ptr , size_t size ) ;
#line 48
char *ck_strdup(char const   *str ) ;
#line 49
void *ck_memdup(void const   *buf , size_t len ) ;
#line 51
struct buffer *init_buffer(void) ;
#line 52
char *get_buffer(struct buffer  const  *b___0 )  __attribute__((__pure__)) ;
#line 53
size_t size_buffer(struct buffer  const  *b___0 )  __attribute__((__pure__)) ;
#line 54
char *add_buffer(struct buffer *b___0 , char const   *p , size_t n ) ;
#line 55
char *add1_buffer(struct buffer *b___0 , int c ) ;
#line 56
void free_buffer(struct buffer *b___0 ) ;
#line 58 "/home/khheo/project/benchmark/sed-4.5/sed/utils.h"
char const   *myname  ;
#line 56 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __fwriting)(FILE *__fp ) ;
#line 48 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
static struct open_file *open_files  =    (struct open_file *)((void *)0);
#line 49
static void do_ck_fclose(FILE *fp ) ;
#line 53 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
void ( /* format attribute */  panic)(char const   *str  , ...) 
{ 
  va_list ap ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          myname);
#line 59
  __builtin_va_start(ap, str);
#line 60
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)str,
           ap);
#line 61
  __builtin_va_end(ap);
#line 62
  putc_unlocked('\n', stderr);
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! open_files) {
#line 65
      goto while_break;
    }
#line 67
    if (open_files->temp) {
      {
#line 69
      fclose(open_files->fp);
#line 70
      tmp = __errno_location();
#line 70
      *tmp = 0;
#line 71
      unlink((char const   *)open_files->name);
#line 72
      tmp___3 = __errno_location();
      }
#line 72
      if (*tmp___3 != 0) {
        {
#line 73
        tmp___0 = __errno_location();
#line 73
        tmp___1 = strerror(*tmp___0);
#line 73
        tmp___2 = gettext("cannot remove %s: %s");
#line 73
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
                open_files->name, tmp___1);
        }
      }
    }
#line 77
    open_files = open_files->link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  exit(4);
  }
}
}
#line 85 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
static char const   * __attribute__((__pure__)) utils_fp_name(FILE *fp ) 
{ 
  struct open_file *p ;

  {
#line 90
  p = open_files;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! p) {
#line 90
      goto while_break;
    }
#line 91
    if ((unsigned long )p->fp == (unsigned long )fp) {
#line 92
      return ((char const   */* __attribute__((__pure__)) */)p->name);
    }
#line 90
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if ((unsigned long )fp == (unsigned long )stdin) {
#line 94
    return ((char const   */* __attribute__((__pure__)) */)"stdin");
  } else
#line 95
  if ((unsigned long )fp == (unsigned long )stdout) {
#line 96
    return ((char const   */* __attribute__((__pure__)) */)"stdout");
  } else
#line 97
  if ((unsigned long )fp == (unsigned long )stderr) {
#line 98
    return ((char const   */* __attribute__((__pure__)) */)"stderr");
  }
#line 100
  return ((char const   */* __attribute__((__pure__)) */)"<unknown>");
}
}
#line 103 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
static void register_open_file(FILE *fp , char const   *name ) 
{ 
  struct open_file *p ;
  void *tmp ;

  {
#line 107
  p = open_files;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! p) {
#line 107
      goto while_break;
    }
#line 109
    if ((unsigned long )fp == (unsigned long )p->fp) {
      {
#line 111
      free((void *)p->name);
      }
#line 112
      goto while_break;
    }
#line 107
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if (! p) {
    {
#line 117
    tmp = ck_malloc(sizeof(struct open_file ));
#line 117
    p = (struct open_file *)tmp;
#line 118
    p->link = open_files;
#line 119
    open_files = p;
    }
  }
  {
#line 121
  p->name = ck_strdup(name);
#line 122
  p->fp = fp;
#line 123
  p->temp = 0U;
  }
#line 124
  return;
}
}
#line 127 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
FILE *ck_fopen(char const   *name , char const   *mode , int fail ) 
{ 
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 132
  fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)mode);
  }
#line 133
  if (! fp) {
#line 135
    if (fail) {
      {
#line 136
      tmp = __errno_location();
#line 136
      tmp___0 = strerror(*tmp);
#line 136
      tmp___1 = gettext("couldn\'t open file %s: %s");
#line 136
      panic((char const   *)tmp___1, name, tmp___0);
      }
    }
#line 138
    return ((FILE *)((void *)0));
  }
  {
#line 141
  register_open_file(fp, name);
  }
#line 142
  return (fp);
}
}
#line 146 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
FILE *ck_fdopen(int fd , char const   *name , char const   *mode , int fail ) 
{ 
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 151
  fp = fdopen(fd, mode);
  }
#line 152
  if (! fp) {
#line 154
    if (fail) {
      {
#line 155
      tmp = __errno_location();
#line 155
      tmp___0 = strerror(*tmp);
#line 155
      tmp___1 = gettext("couldn\'t attach to %s: %s");
#line 155
      panic((char const   *)tmp___1, name, tmp___0);
      }
    }
#line 157
    return ((FILE *)((void *)0));
  }
  {
#line 160
  register_open_file(fp, name);
  }
#line 161
  return (fp);
}
}
#line 164 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
FILE *( __attribute__((__nonnull__(1,2,3,4))) ck_mkstemp)(char **p_filename , char const   *tmpdir ,
                                                          char const   *base , char const   *mode ) 
{ 
  char *template ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  mode_t save_umask ;
  __mode_t tmp___2 ;
  int fd ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  FILE *fp ;
  FILE *tmp___7 ;

  {
  {
#line 168
  tmp = strlen(tmpdir);
#line 168
  tmp___0 = strlen(base);
#line 168
  tmp___1 = xmalloc((tmp + tmp___0) + 8UL);
#line 168
  template = (char *)tmp___1;
#line 169
  sprintf((char */* __restrict  */)template, (char const   */* __restrict  */)"%s/%sXXXXXX",
          tmpdir, base);
#line 174
  tmp___2 = umask((__mode_t )448);
#line 174
  save_umask = tmp___2;
#line 175
  tmp___3 = mkostemp(template, 0);
#line 175
  fd = tmp___3;
#line 176
  umask(save_umask);
  }
#line 177
  if (fd == -1) {
    {
#line 178
    tmp___4 = __errno_location();
#line 178
    tmp___5 = strerror(*tmp___4);
#line 178
    tmp___6 = gettext("couldn\'t open temporary file %s: %s");
#line 178
    panic((char const   *)tmp___6, template, tmp___5);
    }
  }
  {
#line 180
  *p_filename = template;
#line 181
  tmp___7 = fdopen(fd, mode);
#line 181
  fp = tmp___7;
#line 182
  register_open_file(fp, (char const   *)template);
  }
#line 183
  return (fp);
}
}
#line 187 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
void ck_fwrite(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   * __attribute__((__pure__)) tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 190
  clearerr_unlocked(stream);
  }
#line 191
  if (size) {
    {
#line 191
    tmp___3 = fwrite_unlocked((void const   */* __restrict  */)ptr, size, nmemb, (FILE */* __restrict  */)stream);
    }
#line 191
    if (tmp___3 != nmemb) {
      {
#line 192
      tmp = __errno_location();
#line 192
      tmp___0 = strerror(*tmp);
#line 192
      tmp___1 = utils_fp_name(stream);
#line 192
      tmp___2 = ngettext("couldn\'t write %llu item to %s: %s", "couldn\'t write %llu items to %s: %s",
                         nmemb);
#line 192
      panic((char const   *)tmp___2, (unsigned long long )nmemb, tmp___1, tmp___0);
      }
    }
  }
#line 196
  return;
}
}
#line 199 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
size_t ck_fread(void *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   * __attribute__((__pure__)) tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 202
  clearerr_unlocked(stream);
  }
#line 203
  if (size) {
    {
#line 203
    nmemb = fread_unlocked((void */* __restrict  */)ptr, size, nmemb, (FILE */* __restrict  */)stream);
    }
#line 203
    if (nmemb <= 0UL) {
      {
#line 203
      tmp___3 = ferror_unlocked(stream);
      }
#line 203
      if (tmp___3) {
        {
#line 204
        tmp = __errno_location();
#line 204
        tmp___0 = strerror(*tmp);
#line 204
        tmp___1 = utils_fp_name(stream);
#line 204
        tmp___2 = gettext("read error on %s: %s");
#line 204
        panic((char const   *)tmp___2, tmp___1, tmp___0);
        }
      }
    }
  }
#line 206
  return (nmemb);
}
}
#line 209 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
size_t ck_getdelim(char **text , size_t *buflen , char buffer_delimiter___0 , FILE *stream ) 
{ 
  ssize_t result ;
  _Bool error___0 ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char const   * __attribute__((__pure__)) tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 215
  tmp = ferror_unlocked(stream);
#line 215
  error___0 = (_Bool )tmp;
  }
#line 216
  if (! error___0) {
    {
#line 218
    result = getdelim((char **/* __restrict  */)text, (size_t */* __restrict  */)buflen,
                      (int )buffer_delimiter___0, (FILE */* __restrict  */)stream);
#line 219
    tmp___0 = ferror_unlocked(stream);
#line 219
    error___0 = (_Bool )tmp___0;
    }
  }
#line 222
  if (error___0) {
    {
#line 223
    tmp___1 = __errno_location();
#line 223
    tmp___2 = strerror(*tmp___1);
#line 223
    tmp___3 = utils_fp_name(stream);
#line 223
    tmp___4 = gettext("read error on %s: %s");
#line 223
    panic((char const   *)tmp___4, tmp___3, tmp___2);
    }
  }
#line 225
  return ((size_t )result);
}
}
#line 229 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
void ck_fflush(FILE *stream ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   * __attribute__((__pure__)) tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 232
  tmp = __fwriting(stream);
  }
#line 232
  if (! (tmp != 0)) {
#line 233
    return;
  }
  {
#line 235
  clearerr_unlocked(stream);
#line 236
  tmp___3 = fflush_unlocked(stream);
  }
#line 236
  if (tmp___3 == -1) {
    {
#line 236
    tmp___4 = __errno_location();
    }
#line 236
    if (*tmp___4 != 9) {
      {
#line 237
      tmp___0 = __errno_location();
#line 237
      tmp___1 = strerror(*tmp___0);
#line 237
      tmp___2 = utils_fp_name(stream);
#line 237
      panic("couldn\'t flush %s: %s", tmp___2, tmp___1);
      }
    }
  }
#line 238
  return;
}
}
#line 241 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
void ck_fclose(FILE *stream ) 
{ 
  struct open_file r ;
  struct open_file *prev ;
  struct open_file *cur ;

  {
#line 249
  r.link = open_files;
#line 250
  prev = & r;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    cur = prev->link;
#line 251
    if (! cur) {
#line 251
      goto while_break;
    }
#line 253
    if (! stream) {
      {
#line 255
      do_ck_fclose(cur->fp);
#line 256
      prev->link = cur->link;
#line 257
      free((void *)cur->name);
#line 258
      free((void *)cur);
      }
    } else
#line 253
    if ((unsigned long )stream == (unsigned long )cur->fp) {
      {
#line 255
      do_ck_fclose(cur->fp);
#line 256
      prev->link = cur->link;
#line 257
      free((void *)cur->name);
#line 258
      free((void *)cur);
      }
    } else {
#line 261
      prev = cur;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  open_files = r.link;
#line 269
  if (! stream) {
    {
#line 271
    do_ck_fclose(stdout);
#line 272
    do_ck_fclose(stderr);
    }
  }
#line 274
  return;
}
}
#line 277 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
static void do_ck_fclose(FILE *fp ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   * __attribute__((__pure__)) tmp___1 ;
  int tmp___2 ;

  {
  {
#line 280
  ck_fflush(fp);
#line 281
  clearerr_unlocked(fp);
#line 283
  tmp___2 = fclose(fp);
  }
#line 283
  if (tmp___2 == -1) {
    {
#line 284
    tmp = __errno_location();
#line 284
    tmp___0 = strerror(*tmp);
#line 284
    tmp___1 = utils_fp_name(fp);
#line 284
    panic("couldn\'t close %s: %s", tmp___1, tmp___0);
    }
  }
#line 285
  return;
}
}
#line 295 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
static char *buf1  ;
#line 295 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
static char *buf2  ;
#line 296 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
static int buf_size  ;
#line 291 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
char const   *follow_symlink(char const   *fname ) 
{ 
  struct stat statbuf ;
  char const   *buf ;
  char const   *c ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int len ;
  void *tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 299
  buf = fname;
#line 302
  if (buf_size == 0) {
    {
#line 304
    tmp = ck_malloc((size_t )4097);
#line 304
    buf1 = (char *)tmp;
#line 305
    tmp___0 = ck_malloc((size_t )4097);
#line 305
    buf2 = (char *)tmp___0;
#line 306
    buf_size = 4097;
    }
  }
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 309
    rc = lstat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& statbuf));
    }
#line 309
    if (rc == 0) {
#line 309
      if (! ((statbuf.st_mode & 40960U) == 40960U)) {
#line 309
        goto while_break;
      }
    } else {
#line 309
      goto while_break;
    }
#line 312
    if ((unsigned long )buf == (unsigned long )buf2) {
      {
#line 314
      strcpy((char */* __restrict  */)buf1, (char const   */* __restrict  */)buf2);
#line 315
      buf = (char const   *)buf1;
      }
    }
    {
#line 318
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 318
      tmp___3 = readlink((char const   */* __restrict  */)buf, (char */* __restrict  */)buf2,
                         (size_t )buf_size);
#line 318
      rc = (int )tmp___3;
      }
#line 318
      if (! (rc == buf_size)) {
#line 318
        goto while_break___0;
      }
      {
#line 320
      buf_size *= 2;
#line 321
      tmp___1 = ck_realloc((void *)buf1, (size_t )buf_size);
#line 321
      buf1 = (char *)tmp___1;
#line 322
      tmp___2 = ck_realloc((void *)buf2, (size_t )buf_size);
#line 322
      buf2 = (char *)tmp___2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 324
    if (rc < 0) {
      {
#line 325
      tmp___4 = __errno_location();
#line 325
      tmp___5 = strerror(*tmp___4);
#line 325
      tmp___6 = gettext("couldn\'t follow symlink %s: %s");
#line 325
      panic((char const   *)tmp___6, buf, tmp___5);
      }
    } else {
#line 327
      *(buf2 + rc) = (char )'\000';
    }
#line 329
    if ((int )*(buf2 + 0) != 47) {
      {
#line 329
      tmp___9 = strrchr(buf, '/');
#line 329
      c = (char const   *)tmp___9;
      }
#line 329
      if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 333
        len = (int )((c - buf) + 1L);
#line 334
        if ((len + rc) + 1 > buf_size) {
          {
#line 336
          buf_size = (len + rc) + 1;
#line 337
          tmp___7 = ck_realloc((void *)buf1, (size_t )buf_size);
#line 337
          buf1 = (char *)tmp___7;
#line 338
          tmp___8 = ck_realloc((void *)buf2, (size_t )buf_size);
#line 338
          buf2 = (char *)tmp___8;
          }
        }
#line 342
        if ((unsigned long )buf != (unsigned long )buf1) {
          {
#line 343
          memcpy((void */* __restrict  */)buf1, (void const   */* __restrict  */)buf,
                 (size_t )len);
          }
        }
        {
#line 346
        memcpy((void */* __restrict  */)(buf1 + len), (void const   */* __restrict  */)buf2,
               (size_t )(rc + 1));
#line 347
        buf = (char const   *)buf1;
        }
      } else {
#line 354
        buf = (char const   *)buf2;
      }
    } else {
#line 354
      buf = (char const   *)buf2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  if (rc < 0) {
    {
#line 359
    tmp___10 = __errno_location();
#line 359
    tmp___11 = strerror(*tmp___10);
#line 359
    tmp___12 = gettext("cannot stat %s: %s");
#line 359
    panic((char const   *)tmp___12, buf, tmp___11);
    }
  }
#line 361
  return (buf);
}
}
#line 368 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
void ck_rename(char const   *from , char const   *to , char const   *unlink_if_fail ) 
{ 
  int rd ;
  int tmp ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 371
  tmp = rename(from, to);
#line 371
  rd = tmp;
  }
#line 372
  if (rd != -1) {
#line 373
    return;
  }
#line 375
  if (unlink_if_fail) {
    {
#line 377
    tmp___0 = __errno_location();
#line 377
    save_errno = *tmp___0;
#line 378
    tmp___1 = __errno_location();
#line 378
    *tmp___1 = 0;
#line 379
    unlink(unlink_if_fail);
#line 383
    tmp___5 = __errno_location();
    }
#line 383
    if (*tmp___5 != 0) {
      {
#line 384
      tmp___2 = __errno_location();
#line 384
      tmp___3 = strerror(*tmp___2);
#line 384
      tmp___4 = gettext("cannot remove %s: %s");
#line 384
      panic((char const   *)tmp___4, unlink_if_fail, tmp___3);
      }
    }
    {
#line 386
    tmp___6 = __errno_location();
#line 386
    *tmp___6 = save_errno;
    }
  }
  {
#line 389
  tmp___7 = __errno_location();
#line 389
  tmp___8 = strerror(*tmp___7);
#line 389
  tmp___9 = gettext("cannot rename %s: %s");
#line 389
  panic((char const   *)tmp___9, from, tmp___8);
  }
#line 390
  return;
}
}
#line 396 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
void *ck_malloc(size_t size ) 
{ 
  void *ret ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 399
  if (size) {
#line 399
    tmp = size;
  } else {
#line 399
    tmp = (size_t )1;
  }
  {
#line 399
  tmp___0 = calloc((size_t )1, tmp);
#line 399
  ret = tmp___0;
  }
#line 400
  if (! ret) {
    {
#line 401
    panic("couldn\'t allocate memory");
    }
  }
#line 402
  return (ret);
}
}
#line 406 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
void *ck_realloc(void *ptr , size_t size ) 
{ 
  void *ret ;
  void *tmp ;

  {
#line 411
  if (size == 0UL) {
    {
#line 413
    free(ptr);
    }
#line 414
    return ((void *)0);
  }
#line 416
  if (! ptr) {
    {
#line 417
    tmp = ck_malloc(size);
    }
#line 417
    return (tmp);
  }
  {
#line 418
  ret = realloc(ptr, size);
  }
#line 419
  if (! ret) {
    {
#line 420
    panic("couldn\'t re-allocate memory");
    }
  }
#line 421
  return (ret);
}
}
#line 425 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
char *ck_strdup(char const   *str ) 
{ 
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 428
  tmp = strlen(str);
#line 428
  tmp___0 = ck_malloc((tmp + 1UL) * sizeof(char ));
#line 428
  ret = (char *)tmp___0;
#line 429
  tmp___1 = strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)str);
  }
#line 429
  return (tmp___1);
}
}
#line 433 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
void *ck_memdup(void const   *buf , size_t len ) 
{ 
  void *ret ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 436
  tmp = ck_malloc(len);
#line 436
  ret = tmp;
#line 437
  tmp___0 = memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)buf,
                   len);
  }
#line 437
  return (tmp___0);
}
}
#line 453 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
struct buffer *init_buffer(void) 
{ 
  struct buffer *b___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 456
  tmp = ck_malloc(sizeof(struct buffer ));
#line 456
  b___0 = (struct buffer *)tmp;
#line 457
  tmp___0 = ck_malloc(50UL * sizeof(char ));
#line 457
  b___0->b = (char *)tmp___0;
#line 458
  b___0->allocated = (size_t )50;
#line 459
  b___0->length = (size_t )0;
  }
#line 460
  return (b___0);
}
}
#line 463
char *get_buffer(struct buffer  const  *b___0 )  __attribute__((__pure__)) ;
#line 463 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
char *get_buffer(struct buffer  const  *b___0 ) 
{ 


  {
#line 466
  return ((char *)b___0->b);
}
}
#line 469
size_t size_buffer(struct buffer  const  *b___0 )  __attribute__((__pure__)) ;
#line 469 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
size_t size_buffer(struct buffer  const  *b___0 ) 
{ 


  {
#line 472
  return ((size_t )b___0->length);
}
}
#line 475 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
static void resize_buffer(struct buffer *b___0 , size_t newlen ) 
{ 
  char *try ;
  size_t alen ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 478
  try = (char *)((void *)0);
#line 479
  alen = b___0->allocated;
#line 481
  if (newlen <= alen) {
#line 482
    return;
  }
#line 483
  alen *= 2UL;
#line 484
  if (newlen < alen) {
    {
#line 485
    tmp = realloc((void *)b___0->b, alen);
#line 485
    try = (char *)tmp;
    }
  }
#line 486
  if (! try) {
    {
#line 488
    alen = newlen;
#line 489
    tmp___0 = ck_realloc((void *)b___0->b, alen * sizeof(char ));
#line 489
    try = (char *)tmp___0;
    }
  }
#line 491
  b___0->allocated = alen;
#line 492
  b___0->b = try;
#line 493
  return;
}
}
#line 495 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
char *add_buffer(struct buffer *b___0 , char const   *p , size_t n ) 
{ 
  char *result ;
  void *tmp ;

  {
#line 499
  if (b___0->allocated - b___0->length < n) {
    {
#line 500
    resize_buffer(b___0, b___0->length + n);
    }
  }
  {
#line 501
  tmp = memcpy((void */* __restrict  */)(b___0->b + b___0->length), (void const   */* __restrict  */)p,
               n);
#line 501
  result = (char *)tmp;
#line 502
  b___0->length += n;
  }
#line 503
  return (result);
}
}
#line 506 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
char *add1_buffer(struct buffer *b___0 , int c ) 
{ 
  char *result ;
  size_t tmp ;

  {
#line 515
  if (c != -1) {
#line 518
    if (b___0->allocated - b___0->length < 1UL) {
      {
#line 519
      resize_buffer(b___0, b___0->length + 1UL);
      }
    }
#line 520
    tmp = b___0->length;
#line 520
    (b___0->length) ++;
#line 520
    result = b___0->b + tmp;
#line 521
    *result = (char )c;
#line 522
    return (result);
  }
#line 525
  return ((char *)((void *)0));
}
}
#line 528 "/home/khheo/project/benchmark/sed-4.5/sed/utils.c"
void free_buffer(struct buffer *b___0 ) 
{ 


  {
#line 531
  if (b___0) {
    {
#line 532
    free((void *)b___0->b);
    }
  }
  {
#line 533
  free((void *)b___0);
  }
#line 534
  return;
}
}
#line 82 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 190 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
struct vector *compile_string(struct vector *cur_program , char *str , size_t len ) ;
#line 191
struct vector *compile_file(struct vector *cur_program , char const   *cmdfile ) ;
#line 192
void check_final_program(struct vector *program ) ;
#line 194
void finish_program(void) ;
#line 204
int process_files(struct vector *the_program___0 , char **argv ) ;
#line 206
int main(int argc , char **argv ) ;
#line 208 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
struct localeinfo localeinfo  ;
#line 210
int extended_regexp_flags ;
#line 213
char buffer_delimiter ;
#line 217
_Bool unbuffered ;
#line 220
_Bool no_default_output ;
#line 223
_Bool separate_files ;
#line 226
_Bool follow_symlinks ;
#line 229 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
enum posixicity_types posixicity  ;
#line 232
countT lcmd_out_line_len ;
#line 235
char *in_place_extension ;
#line 238
char const   *read_mode ;
#line 239
char const   *write_mode ;
#line 249
_Bool sandbox ;
#line 271
void initialize_mbcs(void) ;
#line 272
void register_cleanup_file(char const   *file ) ;
#line 273
void cancel_cleanup(void) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 592
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 598 "./lib/unistd.h"
#pragma GCC diagnostic push
#line 598
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 598
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2086
#pragma GCC diagnostic pop
#line 66 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) getopt_long)(int ___argc ,
                                                                                                    char * const  *___argv ,
                                                                                                    char const   *__shortopts ,
                                                                                                    struct option  const  *__longopts ,
                                                                                                    int *__longind ) ;
#line 40 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
int extended_regexp_flags  =    0;
#line 43 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
char buffer_delimiter  =    (char )'\n';
#line 46 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
_Bool unbuffered  =    (_Bool)0;
#line 49 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
_Bool no_default_output  =    (_Bool)0;
#line 52 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
_Bool separate_files  =    (_Bool)0;
#line 55 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
_Bool follow_symlinks  =    (_Bool)0;
#line 58 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
_Bool sandbox  =    (_Bool)0;
#line 61 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
char *in_place_extension  =    (char *)((void *)0);
#line 64 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
char const   *read_mode  =    "r";
#line 65 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
char const   *write_mode  =    "w";
#line 71 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
countT lcmd_out_line_len  =    (countT )70;
#line 74 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
static struct vector *the_program  =    (struct vector *)((void *)0);
#line 80 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
static char const   *G_file_to_unlink  ;
#line 86 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
static void cleanup(void) 
{ 


  {
#line 89
  if (G_file_to_unlink) {
    {
#line 90
    unlink(G_file_to_unlink);
    }
  }
#line 91
  return;
}
}
#line 94 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
void register_cleanup_file(char const   *file ) 
{ 


  {
#line 97
  G_file_to_unlink = file;
#line 98
  return;
}
}
#line 101 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
void cancel_cleanup(void) 
{ 


  {
#line 104
  G_file_to_unlink = (char const   *)((void *)0);
#line 105
  return;
}
}
#line 107
static void usage(int status ) ;
#line 108 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
static void contact(int errmsg ) 
{ 
  FILE *out ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 111
  if (errmsg) {
#line 111
    tmp = stderr;
  } else {
#line 111
    tmp = stdout;
  }
  {
#line 111
  out = tmp;
#line 113
  tmp___0 = gettext("GNU sed home page: <https://www.gnu.org/software/sed/>.\nGeneral help using GNU software: <https://www.gnu.org/gethelp/>.\n");
#line 113
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___0);
  }
#line 119
  if (! errmsg) {
    {
#line 120
    tmp___1 = gettext("E-mail bug reports to: <%s>.\n");
#line 120
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___1,
            "bug-sed@gnu.org");
    }
  }
#line 121
  return;
}
}
#line 123 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
static void usage(int status ) 
{ 
  FILE *out ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
#line 126
  if (status) {
#line 126
    tmp = stderr;
  } else {
#line 126
    tmp = stdout;
  }
  {
#line 126
  out = tmp;
#line 134
  tmp___0 = gettext("Usage: %s [OPTION]... {script-only-if-no-other-script} [input-file]...\n\n");
#line 134
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___0,
          myname);
#line 138
  tmp___1 = gettext("  -n, --quiet, --silent\n                 suppress automatic printing of pattern space\n");
#line 138
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___1);
#line 140
  tmp___2 = gettext("  -e script, --expression=script\n                 add the script to the commands to be executed\n");
#line 140
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___2);
#line 142
  tmp___3 = gettext("  -f script-file, --file=script-file\n                 add the contents of script-file to the commands to be executed\n");
#line 142
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___3);
#line 146
  tmp___4 = gettext("  --follow-symlinks\n                 follow symlinks when processing in place\n");
#line 146
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___4);
#line 149
  tmp___5 = gettext("  -i[SUFFIX], --in-place[=SUFFIX]\n                 edit files in place (makes backup if SUFFIX supplied)\n");
#line 149
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___5);
#line 157
  tmp___6 = gettext("  -l N, --line-length=N\n                 specify the desired line-wrap length for the `l\' command\n");
#line 157
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___6);
#line 159
  tmp___7 = gettext("  --posix\n                 disable all GNU extensions.\n");
#line 159
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___7);
#line 161
  tmp___8 = gettext("  -E, -r, --regexp-extended\n                 use extended regular expressions in the script\n                 (for portability use POSIX -E).\n");
#line 161
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___8);
#line 167
  tmp___9 = gettext("  -s, --separate\n                 consider files as separate rather than as a single,\n                 continuous long stream.\n");
#line 167
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___9);
#line 170
  tmp___10 = gettext("      --sandbox\n                 operate in sandbox mode (disable e/r/w commands).\n");
#line 170
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___10);
#line 172
  tmp___11 = gettext("  -u, --unbuffered\n                 load minimal amounts of data from the input files and flush\n                 the output buffers more often\n");
#line 172
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___11);
#line 175
  tmp___12 = gettext("  -z, --null-data\n                 separate lines by NUL characters\n");
#line 175
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___12);
#line 177
  tmp___13 = gettext("      --help     display this help and exit\n");
#line 177
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___13);
#line 178
  tmp___14 = gettext("      --version  output version information and exit\n");
#line 178
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___14);
#line 179
  tmp___15 = gettext("\nIf no -e, --expression, -f, or --file option is given, then the first\nnon-option argument is taken as the sed script to interpret.  All\nremaining arguments are names of input files; if no input files are\nspecified, then the standard input is read.\n\n");
#line 179
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___15);
#line 185
  contact(status);
#line 187
  ck_fclose((FILE *)((void *)0));
#line 188
  exit(status);
  }
}
}
#line 202 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
static struct option  const  longopts[18]  = 
#line 202
  {      {"binary", 0, (int *)((void *)0), 'b'}, 
        {"regexp-extended", 0, (int *)((void *)0), 'r'}, 
        {"expression", 1, (int *)((void *)0), 'e'}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"in-place", 2, (int *)((void *)0), 'i'}, 
        {"line-length", 1, (int *)((void *)0), 'l'}, 
        {"null-data", 0, (int *)((void *)0), 'z'}, 
        {"zero-terminated", 0, (int *)((void *)0), 'z'}, 
        {"quiet", 0, (int *)((void *)0), 'n'}, 
        {"posix", 0, (int *)((void *)0), 'p'}, 
        {"silent", 0, (int *)((void *)0), 'n'}, 
        {"sandbox", 0, (int *)((void *)0), 128}, 
        {"separate", 0, (int *)((void *)0), 's'}, 
        {"unbuffered", 0, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"follow-symlinks", 0, (int *)((void *)0), 'F'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 191 "/home/khheo/project/benchmark/sed-4.5/sed/sed.c"
int main(int argc , char **argv ) 
{ 
  int opt ;
  int return_code ;
  char const   *cols ;
  char *tmp ;
  char *tmp___0 ;
  countT t ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *arg ;
  int tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 230
  tmp = getenv("COLS");
#line 230
  cols = (char const   *)tmp;
#line 232
  program_name = (char const   *)*(argv + 0);
#line 236
  setlocale(6, "");
#line 238
  set_program_name((char const   *)*(argv + 0));
#line 239
  initialize_mbcs();
#line 240
  init_localeinfo(& localeinfo);
#line 244
  atexit(& cleanup);
#line 249
  bindtextdomain("sed", "/usr/local/share/locale");
#line 250
  textdomain("sed");
#line 253
  tmp___0 = getenv("POSIXLY_CORRECT");
  }
#line 253
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 254
    posixicity = (enum posixicity_types )1;
  } else {
#line 256
    posixicity = (enum posixicity_types )0;
  }
#line 262
  if (cols) {
    {
#line 264
    tmp___1 = atoi(cols);
#line 264
    t = (countT )tmp___1;
    }
#line 265
    if (t > 1UL) {
#line 266
      lcmd_out_line_len = t - 1UL;
    }
  }
#line 269
  myname = (char const   *)*argv;
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 270
    opt = getopt_long(argc, (char * const  *)argv, "bsnrzuEe:f:l:i::V:", longopts,
                      (int *)((void *)0));
    }
#line 270
    if (! (opt != -1)) {
#line 270
      goto while_break;
    }
    {
#line 274
    if (opt == 110) {
#line 274
      goto case_110;
    }
#line 277
    if (opt == 101) {
#line 277
      goto case_101;
    }
#line 280
    if (opt == 102) {
#line 280
      goto case_102;
    }
#line 284
    if (opt == 122) {
#line 284
      goto case_122;
    }
#line 288
    if (opt == 70) {
#line 288
      goto case_70;
    }
#line 292
    if (opt == 105) {
#line 292
      goto case_105;
    }
#line 310
    if (opt == 108) {
#line 310
      goto case_108;
    }
#line 314
    if (opt == 112) {
#line 314
      goto case_112;
    }
#line 318
    if (opt == 98) {
#line 318
      goto case_98;
    }
#line 324
    if (opt == 114) {
#line 324
      goto case_114;
    }
#line 324
    if (opt == 69) {
#line 324
      goto case_114;
    }
#line 340
    if (opt == 115) {
#line 340
      goto case_115;
    }
#line 344
    if (opt == 128) {
#line 344
      goto case_128;
    }
#line 348
    if (opt == 117) {
#line 348
      goto case_117;
    }
#line 352
    if (opt == 118) {
#line 352
      goto case_118;
    }
#line 358
    if (opt == 104) {
#line 358
      goto case_104;
    }
#line 360
    goto switch_default;
    case_110: /* CIL Label */ 
#line 275
    no_default_output = (_Bool)1;
#line 276
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 278
    tmp___2 = strlen((char const   *)optarg);
#line 278
    the_program = compile_string(the_program, optarg, tmp___2);
    }
#line 279
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 281
    the_program = compile_file(the_program, (char const   *)optarg);
    }
#line 282
    goto switch_break;
    case_122: /* CIL Label */ 
#line 285
    buffer_delimiter = (char)0;
#line 286
    goto switch_break;
    case_70: /* CIL Label */ 
#line 289
    follow_symlinks = (_Bool)1;
#line 290
    goto switch_break;
    case_105: /* CIL Label */ 
#line 293
    separate_files = (_Bool)1;
#line 294
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
      {
#line 296
      in_place_extension = ck_strdup("*");
      }
    } else {
      {
#line 298
      tmp___5 = strchr((char const   *)optarg, '*');
      }
#line 298
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
        {
#line 299
        in_place_extension = ck_strdup((char const   *)optarg);
        }
      } else {
        {
#line 303
        tmp___3 = strlen((char const   *)optarg);
#line 303
        tmp___4 = ck_malloc((tmp___3 + 2UL) * sizeof(char ));
#line 303
        in_place_extension = (char *)tmp___4;
#line 304
        *(in_place_extension + 0) = (char )'*';
#line 305
        strcpy((char */* __restrict  */)(in_place_extension + 1), (char const   */* __restrict  */)optarg);
        }
      }
    }
#line 308
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 311
    tmp___6 = atoi((char const   *)optarg);
#line 311
    lcmd_out_line_len = (countT )tmp___6;
    }
#line 312
    goto switch_break;
    case_112: /* CIL Label */ 
#line 315
    posixicity = (enum posixicity_types )2;
#line 316
    goto switch_break;
    case_98: /* CIL Label */ 
#line 319
    read_mode = "rb";
#line 320
    write_mode = "wb";
#line 321
    goto switch_break;
    case_114: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 329
    extended_regexp_flags = 1;
#line 330
    goto switch_break;
    case_115: /* CIL Label */ 
#line 341
    separate_files = (_Bool)1;
#line 342
    goto switch_break;
    case_128: /* CIL Label */ 
#line 345
    sandbox = (_Bool)1;
#line 346
    goto switch_break;
    case_117: /* CIL Label */ 
#line 349
    unbuffered = (_Bool)1;
#line 350
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 353
    tmp___7 = gettext("Paolo Bonzini");
#line 353
    tmp___8 = gettext("Ken Pizzini");
#line 353
    tmp___9 = gettext("Tom Lord");
#line 353
    tmp___10 = gettext("Jay Fenlason");
#line 353
    version_etc(stdout, program_name, "GNU sed", Version, tmp___10, tmp___9, tmp___8,
                tmp___7, (char *)((void *)0));
#line 355
    contact(0);
#line 356
    ck_fclose((FILE *)((void *)0));
#line 357
    exit(0);
    }
    case_104: /* CIL Label */ 
    {
#line 359
    usage(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 361
    usage(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  if (! the_program) {
#line 367
    if (optind < argc) {
      {
#line 369
      tmp___11 = optind;
#line 369
      optind ++;
#line 369
      arg = *(argv + tmp___11);
#line 370
      tmp___12 = strlen((char const   *)arg);
#line 370
      the_program = compile_string(the_program, arg, tmp___12);
      }
    } else {
      {
#line 373
      usage(1);
      }
    }
  }
  {
#line 375
  check_final_program(the_program);
#line 377
  return_code = process_files(the_program, argv + optind);
#line 379
  finish_program();
#line 380
  ck_fclose((FILE *)((void *)0));
  }
#line 382
  return (return_code);
}
}
#line 82 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 114
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                                                int __c ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 529 "./lib/regex.h"
extern reg_syntax_t re_set_syntax(reg_syntax_t __syntax ) ;
#line 539
extern char const   *re_compile_pattern(char const   *__pattern , size_t __length ,
                                        struct re_pattern_buffer *__buffer ) ;
#line 554
extern regoff_t re_search(struct re_pattern_buffer *__buffer , char const   *__String ,
                          regoff_t __length , regoff_t __start , regoff_t __range ,
                          struct re_registers *__regs ) ;
#line 188 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
void bad_prog(char const   *why ) ;
#line 189
size_t normalize_text(char *buf , size_t len , enum text_types buftype ) ;
#line 196
struct regex *compile_regex(struct buffer *b___0 , int flags , int needed_sub ) ;
#line 197
int match_regex(struct regex *regex , char *buf , size_t buflen , size_t buf_start_offset ,
                struct re_registers *regarray , int regsize ) ;
#line 34 "/home/khheo/project/benchmark/sed-4.5/sed/regexp.c"
static char const   errors[72]  = 
#line 34 "/home/khheo/project/benchmark/sed-4.5/sed/regexp.c"
  {      (char const   )'n',      (char const   )'o',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'o',      (char const   )'u',      (char const   )'s',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'\000',      (char const   )'c', 
        (char const   )'a',      (char const   )'n',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'s',      (char const   )'p', 
        (char const   )'e',      (char const   )'c',      (char const   )'i',      (char const   )'f', 
        (char const   )'y',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'i',      (char const   )'f',      (char const   )'i', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )' ', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'e', 
        (char const   )'m',      (char const   )'p',      (char const   )'t',      (char const   )'y', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'\000'};
#line 43 "/home/khheo/project/benchmark/sed-4.5/sed/regexp.c"
void dfaerror(char const   *mesg ) 
{ 


  {
  {
#line 46
  panic("%s", mesg);
  }
#line 47
  return;
}
}
#line 49 "/home/khheo/project/benchmark/sed-4.5/sed/regexp.c"
void dfawarn(char const   *mesg ) 
{ 
  char *tmp ;

  {
  {
#line 52
  tmp = getenv("POSIXLY_CORRECT");
  }
#line 52
  if (! tmp) {
    {
#line 53
    dfaerror(mesg);
    }
  }
#line 54
  return;
}
}
#line 58 "/home/khheo/project/benchmark/sed-4.5/sed/regexp.c"
static void compile_regex_1(struct regex *new_regex , int needed_sub ) 
{ 
  char const   *error___0 ;
  int syntax ;
  unsigned long tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  char buf[200] ;
  char *tmp___3 ;
  int dfaopts ;
  int tmp___4 ;

  {
#line 76
  if (extended_regexp_flags & 1) {
#line 76
    tmp = ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
#line 76
    tmp = (((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
#line 76
  syntax = (int )tmp;
#line 80
  syntax = (int )((unsigned long )syntax & ~ (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 81
  syntax = (int )((unsigned long )syntax | ((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  {
#line 85
  if ((unsigned int )posixicity == 0U) {
#line 85
    goto case_0;
  }
#line 88
  if ((unsigned int )posixicity == 1U) {
#line 88
    goto case_1;
  }
#line 91
  if ((unsigned int )posixicity == 2U) {
#line 91
    goto case_2;
  }
#line 83
  goto switch_break;
  case_0: /* CIL Label */ 
#line 86
  syntax = (int )((unsigned long )syntax & ~ (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 87
  goto switch_break;
  case_1: /* CIL Label */ 
#line 89
  syntax = (int )((unsigned long )syntax | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 90
  goto switch_break;
  case_2: /* CIL Label */ 
#line 92
  syntax = (int )((unsigned long )syntax | ((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
#line 93
  if (! (extended_regexp_flags & 1)) {
#line 94
    syntax = (int )((unsigned long )syntax | ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
#line 95
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 98
  if (new_regex->flags & (1 << 1)) {
#line 99
    syntax = (int )((unsigned long )syntax | ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  } else {
    {
#line 101
    tmp___0 = malloc((size_t )(1 << sizeof(char ) * 8UL));
#line 101
    new_regex->pattern.fastmap = (char *)tmp___0;
    }
  }
#line 102
  if (needed_sub) {
#line 102
    tmp___1 = 0UL;
  } else {
#line 102
    tmp___1 = ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  }
#line 102
  syntax = (int )((unsigned long )syntax | tmp___1);
#line 105
  if (new_regex->flags & (1 << 2)) {
#line 108
    syntax = (int )((unsigned long )syntax & ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1));
#line 109
    syntax = (int )((unsigned long )syntax | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
  {
#line 112
  re_set_syntax((reg_syntax_t )syntax);
#line 113
  error___0 = re_compile_pattern((char const   *)(new_regex->re), new_regex->sz, & new_regex->pattern);
  }
#line 115
  if ((int )buffer_delimiter == 10) {
#line 115
    if ((new_regex->flags & (1 << 2)) != 0) {
#line 115
      tmp___2 = 1;
    } else {
#line 115
      tmp___2 = 0;
    }
  } else {
#line 115
    tmp___2 = 0;
  }
#line 115
  new_regex->pattern.newline_anchor = (unsigned int )tmp___2;
#line 118
  new_regex->pattern.translate = (unsigned char *)((void *)0);
#line 131
  if (error___0) {
    {
#line 132
    bad_prog(error___0);
    }
  }
#line 136
  if (needed_sub) {
#line 136
    if (new_regex->pattern.re_nsub < (size_t )(needed_sub - 1)) {
#line 136
      if ((unsigned int )posixicity == 0U) {
        {
#line 141
        tmp___3 = gettext("invalid reference \\%d on `s\' command\'s RHS");
#line 141
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___3,
                needed_sub - 1);
#line 143
        bad_prog((char const   *)(buf));
        }
      }
    }
  }
#line 146
  if ((int )buffer_delimiter == 10) {
#line 146
    tmp___4 = 0;
  } else {
#line 146
    tmp___4 = 2;
  }
  {
#line 146
  dfaopts = tmp___4;
#line 147
  new_regex->dfa = dfaalloc();
#line 148
  dfasyntax(new_regex->dfa, (struct localeinfo  const  *)(& localeinfo), (reg_syntax_t )syntax,
            dfaopts);
#line 149
  dfacomp((char const   *)(new_regex->re), new_regex->sz, new_regex->dfa, (_Bool)1);
  }
#line 155
  if (new_regex->sz == 1UL) {
#line 157
    if ((int )new_regex->re[0] == 94) {
#line 158
      new_regex->begline = (_Bool)1;
    }
#line 159
    if ((int )new_regex->re[0] == 36) {
#line 160
      new_regex->endline = (_Bool)1;
    }
  }
#line 162
  return;
}
}
#line 164 "/home/khheo/project/benchmark/sed-4.5/sed/regexp.c"
struct regex *compile_regex(struct buffer *b___0 , int flags , int needed_sub ) 
{ 
  struct regex *new_regex ;
  size_t re_len ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 171
  tmp___0 = size_buffer((struct buffer  const  *)b___0);
  }
#line 171
  if (tmp___0 == 0UL) {
#line 173
    if (flags > 0) {
      {
#line 174
      tmp = gettext(errors + sizeof("no previous regular expression"));
#line 174
      bad_prog((char const   *)tmp);
      }
    }
#line 175
    return ((struct regex *)((void *)0));
  }
  {
#line 178
  re_len = size_buffer((struct buffer  const  *)b___0);
#line 179
  tmp___1 = ck_malloc((sizeof(struct regex ) + re_len) - 1UL);
#line 179
  new_regex = (struct regex *)tmp___1;
#line 180
  new_regex->flags = flags;
#line 181
  tmp___2 = get_buffer((struct buffer  const  *)b___0);
#line 181
  memcpy((void */* __restrict  */)(new_regex->re), (void const   */* __restrict  */)tmp___2,
         re_len);
#line 187
  new_regex->sz = normalize_text(new_regex->re, re_len, (enum text_types )2);
#line 190
  compile_regex_1(new_regex, needed_sub);
  }
#line 191
  return (new_regex);
}
}
#line 238 "/home/khheo/project/benchmark/sed-4.5/sed/regexp.c"
static struct regex *regex_last  ;
#line 232 "/home/khheo/project/benchmark/sed-4.5/sed/regexp.c"
int match_regex(struct regex *regex , char *buf , size_t buflen , size_t buf_start_offset ,
                struct re_registers *regarray , int regsize ) 
{ 
  int ret ;
  char *tmp ;
  char *tmp___0 ;
  size_t offset ;
  char const   *p ;
  void *tmp___1 ;
  char const   *p___0 ;
  void *tmp___2 ;
  size_t i ;
  void *tmp___3 ;
  void *tmp___4 ;
  regoff_t tmp___5 ;
  struct dfa *superset ;
  struct dfa *tmp___6 ;
  char *tmp___7 ;
  _Bool backref ;
  char *tmp___8 ;
  _Bool tmp___9 ;
  char const   *beg ;
  char const   *end ;
  char const   *start ;
  char const   *eol ;
  void *tmp___10 ;
  void *tmp___11 ;
  struct re_registers *tmp___12 ;
  size_t i___0 ;
  struct re_registers *tmp___13 ;

  {
#line 248
  if (! regex) {
#line 250
    regex = regex_last;
#line 251
    if (! regex_last) {
      {
#line 252
      tmp = gettext(errors);
#line 252
      bad_prog((char const   *)tmp);
      }
    }
  } else {
#line 255
    regex_last = regex;
  }
#line 258
  if (buflen >= 2147483647UL) {
    {
#line 259
    tmp___0 = gettext("regex input buffer length larger than INT_MAX");
#line 259
    panic((char const   *)tmp___0);
    }
  }
#line 271
  if (regex->pattern.no_sub) {
#line 271
    if (regsize) {
      {
#line 272
      compile_regex_1(regex, regsize);
      }
    }
  }
#line 274
  regex->pattern.regs_allocated = 1U;
#line 277
  if (regex->begline) {
#line 277
    goto _L;
  } else
#line 277
  if (regex->endline) {
    _L: /* CIL Label */ 
#line 281
    if (regex->endline) {
#line 283
      p = (char const   *)((void *)0);
#line 285
      if (regex->flags & (1 << 2)) {
        {
#line 286
        tmp___1 = memchr((void const   *)(buf + buf_start_offset), (int )buffer_delimiter,
                         buflen);
#line 286
        p = (char const   *)tmp___1;
        }
      }
#line 288
      if (p) {
#line 288
        offset = (size_t )(p - (char const   *)buf);
      } else {
#line 288
        offset = buflen;
      }
    } else
#line 290
    if (buf_start_offset == 0UL) {
#line 292
      offset = (size_t )0;
    } else
#line 293
    if (! (regex->flags & (1 << 2))) {
#line 297
      return (0);
    } else
#line 298
    if ((int )*(buf + (buf_start_offset - 1UL)) == (int )buffer_delimiter) {
#line 303
      offset = buf_start_offset;
    } else {
      {
#line 310
      tmp___2 = memchr((void const   *)(buf + buf_start_offset), (int )buffer_delimiter,
                       buflen - buf_start_offset);
#line 310
      p___0 = (char const   *)tmp___2;
      }
#line 313
      if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
#line 314
        return (0);
      }
#line 316
      offset = (size_t )((p___0 - (char const   *)buf) + 1L);
    }
#line 319
    if (regsize) {
#line 323
      if (! regarray->start) {
        {
#line 325
        tmp___3 = ck_malloc(sizeof(regoff_t ));
#line 325
        regarray->start = (regoff_t *)tmp___3;
#line 326
        tmp___4 = ck_malloc(sizeof(regoff_t ));
#line 326
        regarray->end = (regoff_t *)tmp___4;
#line 327
        regarray->num_regs = (__re_size_t )1;
        }
      }
#line 330
      *(regarray->start + 0) = (regoff_t )offset;
#line 331
      *(regarray->end + 0) = (regoff_t )offset;
#line 333
      i = (size_t )1;
      {
#line 333
      while (1) {
        while_continue: /* CIL Label */ ;
#line 333
        if (! (i < (size_t )regarray->num_regs)) {
#line 333
          goto while_break;
        }
#line 334
        tmp___5 = -1;
#line 334
        *(regarray->end + i) = tmp___5;
#line 334
        *(regarray->start + i) = tmp___5;
#line 333
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 337
    return (1);
  }
#line 340
  if (buf_start_offset == 0UL) {
    {
#line 342
    tmp___6 = dfasuperset((struct dfa  const  *)regex->dfa);
#line 342
    superset = tmp___6;
    }
#line 344
    if (superset) {
      {
#line 344
      tmp___7 = dfaexec(superset, (char const   *)buf, buf + buflen, (_Bool)1, (size_t *)((void *)0),
                        (_Bool *)((void *)0));
      }
#line 344
      if (! tmp___7) {
#line 345
        return (0);
      }
    }
#line 347
    if (! regsize) {
#line 347
      if (regex->flags & (1 << 2)) {
#line 347
        goto _L___0;
      } else {
#line 347
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 347
    if (! superset) {
      {
#line 347
      tmp___9 = dfaisfast((struct dfa  const  *)regex->dfa);
      }
#line 347
      if (tmp___9) {
        _L___0: /* CIL Label */ 
        {
#line 350
        backref = (_Bool)0;
#line 352
        tmp___8 = dfaexec(regex->dfa, (char const   *)buf, buf + buflen, (_Bool)1,
                          (size_t *)((void *)0), & backref);
        }
#line 352
        if (! tmp___8) {
#line 353
          return (0);
        }
#line 355
        if (! regsize) {
#line 355
          if (regex->flags & (1 << 2)) {
#line 355
            if (! backref) {
#line 356
              return (1);
            }
          }
        }
      }
    }
  }
#line 363
  if (regex->flags & (1 << 2)) {
#line 363
    if ((int )buffer_delimiter != 10) {
#line 368
      beg = (char const   *)buf;
#line 370
      if (buf_start_offset > 0UL) {
        {
#line 372
        tmp___10 = memrchr((void const   *)buf, (int )buffer_delimiter, buf_start_offset);
#line 372
        eol = (char const   *)tmp___10;
        }
#line 374
        if ((unsigned long )eol != (unsigned long )((void *)0)) {
#line 375
          beg = eol + 1;
        }
      }
#line 378
      start = (char const   *)(buf + buf_start_offset);
      {
#line 380
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 382
        tmp___11 = memchr((void const   *)beg, (int )buffer_delimiter, (size_t )((buf + buflen) - (char *)beg));
#line 382
        end = (char const   *)tmp___11;
        }
#line 384
        if ((unsigned long )end == (unsigned long )((void *)0)) {
#line 385
          end = (char const   *)(buf + buflen);
        }
#line 387
        if (regsize) {
#line 387
          tmp___12 = regarray;
        } else {
#line 387
          tmp___12 = (struct re_registers *)((void *)0);
        }
        {
#line 387
        ret = re_search(& regex->pattern, beg, (regoff_t )(end - beg), (regoff_t )(start - beg),
                        (regoff_t )(end - start), tmp___12);
        }
#line 391
        if (ret > -1) {
#line 395
          ret = (int )((long )ret + (beg - (char const   *)buf));
#line 397
          if (regsize) {
#line 399
            i___0 = (size_t )0;
            {
#line 399
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 399
              if (! (i___0 < (size_t )regarray->num_regs)) {
#line 399
                goto while_break___1;
              }
#line 401
              if (*(regarray->start + i___0) > -1) {
#line 402
                *(regarray->start + i___0) = (regoff_t )((long )*(regarray->start + i___0) + (beg - (char const   *)buf));
              }
#line 403
              if (*(regarray->end + i___0) > -1) {
#line 404
                *(regarray->end + i___0) = (regoff_t )((long )*(regarray->end + i___0) + (beg - (char const   *)buf));
              }
#line 399
              i___0 ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 408
          goto while_break___0;
        }
#line 411
        if ((unsigned long )end == (unsigned long )(buf + buflen)) {
#line 412
          goto while_break___0;
        }
#line 414
        start = end + 1;
#line 414
        beg = start;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 363
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 418
    if (regsize) {
#line 418
      tmp___13 = regarray;
    } else {
#line 418
      tmp___13 = (struct re_registers *)((void *)0);
    }
    {
#line 418
    ret = re_search(& regex->pattern, (char const   *)buf, (regoff_t )buflen, (regoff_t )buf_start_offset,
                    (regoff_t )(buflen - buf_start_offset), tmp___13);
    }
  }
#line 422
  return (ret > -1);
}
}
#line 82 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 245 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
int mb_cur_max  ;
#line 246 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
_Bool is_utf8  ;
#line 270
int is_mb_char(int ch , mbstate_t *cur_stat ) ;
#line 38 "/home/khheo/project/benchmark/sed-4.5/sed/mbcs.c"
int is_mb_char(int ch , mbstate_t *cur_stat ) 
{ 
  char c ;
  int mb_pending ;
  int tmp ;
  int tmp___0 ;
  int result ;
  size_t tmp___1 ;

  {
  {
#line 41
  c = (char )ch;
#line 42
  tmp = mbsinit((mbstate_t const   *)cur_stat);
  }
#line 42
  if (tmp) {
#line 42
    tmp___0 = 0;
  } else {
#line 42
    tmp___0 = 1;
  }
  {
#line 42
  mb_pending = tmp___0;
#line 43
  tmp___1 = rpl_mbrtowc((wchar_t *)((void *)0), (char const   *)(& c), (size_t )1,
                        cur_stat);
#line 43
  result = (int )tmp___1;
  }
  {
#line 47
  if (result == -2) {
#line 47
    goto case_neg_2;
  }
#line 50
  if (result == -1) {
#line 50
    goto case_neg_1;
  }
#line 54
  if (result == 1) {
#line 54
    goto case_1;
  }
#line 57
  if (result == 0) {
#line 57
    goto case_0;
  }
#line 61
  goto switch_default;
  case_neg_2: /* CIL Label */ 
#line 48
  return (1);
  case_neg_1: /* CIL Label */ 
  {
#line 51
  memset((void *)cur_stat, 0, sizeof(mbstate_t ));
  }
#line 52
  return (0);
  case_1: /* CIL Label */ 
#line 55
  return (mb_pending);
  case_0: /* CIL Label */ 
#line 59
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 62
  panic("is_mb_char: mbrtowc (0x%x) returned %d", (unsigned int )ch, result);
  }
  switch_break: /* CIL Label */ ;
  }
#line 65
  return (0);
}
}
#line 67 "/home/khheo/project/benchmark/sed-4.5/sed/mbcs.c"
void initialize_mbcs(void) 
{ 
  char const   *codeset_name ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 73
  codeset_name = locale_charset();
#line 74
  tmp = strcmp(codeset_name, "UTF-8");
#line 74
  is_utf8 = (_Bool )(tmp == 0);
#line 76
  tmp___0 = __ctype_get_mb_cur_max();
#line 76
  mb_cur_max = (int )tmp___0;
  }
#line 77
  return;
}
}
#line 284 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) btowc)(int __c ) ;
#line 294 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 766
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 82 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 193 "/home/khheo/project/benchmark/sed-4.5/sed/sed.h"
void rewind_read_files(void) ;
#line 481 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 782
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 598 "./lib/unistd.h"
#pragma GCC diagnostic push
#line 598
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 598
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2086
#pragma GCC diagnostic pop
#line 210 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 37 "./lib/selinux/selinux.h"
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 37
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 153
#pragma GCC diagnostic pop
#line 10 "./lib/selinux/context.h"
#pragma GCC diagnostic push
#line 10
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 10
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 81
#pragma GCC diagnostic pop
#line 105 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static _Bool replaced  =    (_Bool)0;
#line 108 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static struct output output_file  ;
#line 111 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static struct line line  ;
#line 114 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static struct line s_accum  ;
#line 117 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static struct line hold  ;
#line 121 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static struct line buffer  ;
#line 123 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static struct append_queue *append_head  =    (struct append_queue *)((void *)0);
#line 124 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static struct append_queue *append_tail  =    (struct append_queue *)((void *)0);
#line 129 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void resize_line(struct line *lb , size_t len ) 
{ 
  int inactive ;
  void *tmp ;

  {
#line 133
  inactive = (int )(lb->active - lb->text);
#line 137
  if ((size_t )inactive > lb->alloc * 2UL) {
    {
#line 139
    memmove((void *)lb->text, (void const   *)lb->active, lb->length);
#line 140
    lb->alloc += (size_t )(lb->active - lb->text);
#line 141
    lb->active = lb->text;
#line 142
    inactive = 0;
    }
#line 144
    if (lb->alloc > len) {
#line 145
      return;
    }
  }
#line 148
  lb->alloc *= 2UL;
#line 149
  if (lb->alloc < len) {
#line 150
    lb->alloc = len;
  }
#line 151
  if (lb->alloc < 50UL) {
#line 152
    lb->alloc = (size_t )50;
  }
  {
#line 154
  tmp = ck_realloc((void *)lb->text, (((size_t )inactive + lb->alloc) + 1UL) * sizeof(char ));
#line 154
  lb->text = (char *)tmp;
#line 155
  lb->active = lb->text + inactive;
  }
#line 156
  return;
}
}
#line 159 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void str_append(struct line *to , char const   *string , size_t length ) 
{ 
  size_t new_length ;
  size_t n ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 162
  new_length = to->length + length;
#line 164
  if (to->alloc < new_length) {
    {
#line 165
    resize_line(to, new_length);
    }
  }
  {
#line 166
  memcpy((void */* __restrict  */)(to->active + to->length), (void const   */* __restrict  */)string,
         length);
#line 167
  to->length = new_length;
  }
#line 169
  if (mb_cur_max > 1) {
#line 169
    if (! is_utf8) {
      {
#line 170
      while (1) {
        while_continue: /* CIL Label */ ;
#line 170
        if (! length) {
#line 170
          goto while_break;
        }
#line 172
        if (mb_cur_max == 1) {
#line 172
          tmp___0 = (size_t )1;
        } else {
          {
#line 172
          tmp = rpl_mbrtowc((wchar_t *)((void *)0), string, length, & to->mbstate);
#line 172
          tmp___0 = tmp;
          }
        }
#line 172
        n = tmp___0;
#line 176
        if (n == 0xffffffffffffffffUL) {
          {
#line 178
          memset((void *)(& to->mbstate), 0, sizeof(to->mbstate));
#line 179
          n = (size_t )1;
          }
        } else
#line 176
        if (n == 0xfffffffffffffffeUL) {
          {
#line 178
          memset((void *)(& to->mbstate), 0, sizeof(to->mbstate));
#line 179
          n = (size_t )1;
          }
        }
#line 182
        if (n == 0UL) {
#line 183
          goto while_break;
        }
#line 185
        string += n;
#line 186
        length -= n;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 188
  return;
}
}
#line 190 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void str_append_modified(struct line *to , char const   *string , size_t length ,
                                enum replacement_types type ) 
{ 
  mbstate_t from_stat ;
  wchar_t wc ;
  size_t n ;
  wint_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  wint_t tmp___2 ;
  wint_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  wint_t tmp___7 ;
  wint_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;

  {
#line 196
  if ((unsigned int )type == 0U) {
    {
#line 198
    str_append(to, string, length);
    }
#line 199
    return;
  }
#line 202
  if (to->alloc - to->length < length * (size_t )mb_cur_max) {
    {
#line 203
    resize_line(to, to->length + length * (size_t )mb_cur_max);
    }
  }
  {
#line 205
  memcpy((void */* __restrict  */)(& from_stat), (void const   */* __restrict  */)(& to->mbstate),
         sizeof(mbstate_t ));
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! length) {
#line 206
      goto while_break;
    }
#line 209
    if (mb_cur_max == 1) {
      {
#line 209
      tmp = btowc((int )*((unsigned char *)string));
#line 209
      wc = (wchar_t )tmp;
#line 209
      tmp___1 = (size_t )1;
      }
    } else {
      {
#line 209
      tmp___0 = rpl_mbrtowc(& wc, string, length, & from_stat);
#line 209
      tmp___1 = tmp___0;
      }
    }
#line 209
    n = tmp___1;
#line 212
    if (n == 0xffffffffffffffffUL) {
#line 214
      type = (enum replacement_types )((unsigned int )type & 4294967283U);
#line 215
      if ((unsigned int )type == 0U) {
        {
#line 217
        str_append(to, string, length);
        }
#line 218
        return;
      }
      {
#line 221
      str_append(to, string, (size_t )1);
#line 222
      memset((void *)(& to->mbstate), 0, sizeof(from_stat));
#line 223
      n = (size_t )1;
#line 224
      string += n;
#line 224
      length -= n;
      }
#line 225
      goto while_continue;
    }
#line 228
    if (n == 0UL) {
      {
#line 231
      str_append(to, string, length);
      }
#line 232
      return;
    } else
#line 228
    if (n == 0xfffffffffffffffeUL) {
      {
#line 231
      str_append(to, string, length);
      }
#line 232
      return;
    }
#line 235
    string += n;
#line 235
    length -= n;
#line 238
    if ((unsigned int )type & 12U) {
#line 240
      if ((unsigned int )type & 4U) {
        {
#line 241
        tmp___2 = towupper((wint_t )wc);
#line 241
        wc = (wchar_t )tmp___2;
        }
      } else {
        {
#line 243
        tmp___3 = towlower((wint_t )wc);
#line 243
        wc = (wchar_t )tmp___3;
        }
      }
#line 245
      type = (enum replacement_types )((unsigned int )type & 4294967283U);
#line 246
      if ((unsigned int )type == 0U) {
#line 249
        if (mb_cur_max == 1) {
          {
#line 249
          tmp___4 = wctob((wint_t )wc);
#line 249
          *(to->active + to->length) = (char )tmp___4;
#line 249
          n = (size_t )1;
          }
        } else {
          {
#line 249
          tmp___5 = wcrtomb((char */* __restrict  */)(to->active + to->length), wc,
                            (mbstate_t */* __restrict  */)(& to->mbstate));
#line 249
          n = tmp___5;
          }
        }
#line 250
        to->length += n;
#line 251
        if (n == 0xffffffffffffffffUL) {
          {
#line 253
          tmp___6 = gettext("case conversion produced an invalid character");
#line 253
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6);
#line 255
          abort();
          }
        } else
#line 251
        if (n == 0xfffffffffffffffeUL) {
          {
#line 253
          tmp___6 = gettext("case conversion produced an invalid character");
#line 253
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6);
#line 255
          abort();
          }
        }
        {
#line 257
        str_append(to, string, length);
        }
#line 258
        return;
      }
    } else
#line 261
    if ((unsigned int )type & 1U) {
      {
#line 262
      tmp___7 = towupper((wint_t )wc);
#line 262
      wc = (wchar_t )tmp___7;
      }
    } else {
      {
#line 264
      tmp___8 = towlower((wint_t )wc);
#line 264
      wc = (wchar_t )tmp___8;
      }
    }
#line 267
    if (mb_cur_max == 1) {
      {
#line 267
      tmp___9 = wctob((wint_t )wc);
#line 267
      *(to->active + to->length) = (char )tmp___9;
#line 267
      n = (size_t )1;
      }
    } else {
      {
#line 267
      tmp___10 = wcrtomb((char */* __restrict  */)(to->active + to->length), wc, (mbstate_t */* __restrict  */)(& to->mbstate));
#line 267
      n = tmp___10;
      }
    }
#line 268
    to->length += n;
#line 269
    if (n == 0xffffffffffffffffUL) {
      {
#line 271
      tmp___11 = gettext("case conversion produced an invalid character");
#line 271
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11);
#line 272
      abort();
      }
    } else
#line 269
    if (n == 0xfffffffffffffffeUL) {
      {
#line 271
      tmp___11 = gettext("case conversion produced an invalid character");
#line 271
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11);
#line 272
      abort();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return;
}
}
#line 279 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void line_init(struct line *buf , struct line *state , size_t initial_size ) 
{ 
  void *tmp ;

  {
  {
#line 282
  tmp = ck_malloc((initial_size + 1UL) * sizeof(char ));
#line 282
  buf->text = (char *)tmp;
#line 283
  buf->active = buf->text;
#line 284
  buf->alloc = initial_size;
#line 285
  buf->length = (size_t )0;
#line 286
  buf->chomped = (_Bool)1;
  }
#line 288
  if (state) {
    {
#line 289
    memcpy((void */* __restrict  */)(& buf->mbstate), (void const   */* __restrict  */)(& state->mbstate),
           sizeof(buf->mbstate));
    }
  } else {
    {
#line 291
    memset((void *)(& buf->mbstate), 0, sizeof(buf->mbstate));
    }
  }
#line 292
  return;
}
}
#line 296 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void line_reset(struct line *buf , struct line *state ) 
{ 


  {
#line 299
  if (buf->alloc == 0UL) {
    {
#line 300
    line_init(buf, state, (size_t )50);
    }
  } else {
#line 303
    buf->length = (size_t )0;
#line 304
    if (state) {
      {
#line 305
      memcpy((void */* __restrict  */)(& buf->mbstate), (void const   */* __restrict  */)(& state->mbstate),
             sizeof(buf->mbstate));
      }
    } else {
      {
#line 307
      memset((void *)(& buf->mbstate), 0, sizeof(buf->mbstate));
      }
    }
  }
#line 309
  return;
}
}
#line 314 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void line_copy(struct line *from , struct line *to , int state ) 
{ 
  void *tmp ;

  {
#line 318
  to->alloc += (size_t )(to->active - to->text);
#line 320
  if (to->alloc < from->length) {
#line 322
    to->alloc *= 2UL;
#line 323
    if (to->alloc < from->length) {
#line 324
      to->alloc = from->length;
    }
#line 325
    if (to->alloc < 50UL) {
#line 326
      to->alloc = (size_t )50;
    }
    {
#line 329
    free((void *)to->text);
#line 330
    tmp = ck_malloc((to->alloc + 1UL) * sizeof(char ));
#line 330
    to->text = (char *)tmp;
    }
  }
  {
#line 333
  to->active = to->text;
#line 334
  to->length = from->length;
#line 335
  to->chomped = from->chomped;
#line 336
  memcpy((void */* __restrict  */)to->active, (void const   */* __restrict  */)from->active,
         from->length);
  }
#line 338
  if (state) {
    {
#line 339
    memcpy((void */* __restrict  */)(& to->mbstate), (void const   */* __restrict  */)(& from->mbstate),
           sizeof(from->mbstate));
    }
  }
#line 340
  return;
}
}
#line 344 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void line_append(struct line *from , struct line *to , int state ) 
{ 


  {
  {
#line 347
  str_append(to, (char const   *)(& buffer_delimiter), (size_t )1);
#line 348
  str_append(to, (char const   *)from->active, from->length);
#line 349
  to->chomped = from->chomped;
  }
#line 351
  if (state) {
    {
#line 352
    memcpy((void */* __restrict  */)(& to->mbstate), (void const   */* __restrict  */)(& from->mbstate),
           sizeof(from->mbstate));
    }
  }
#line 353
  return;
}
}
#line 357 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void line_exchange(struct line *a , struct line *b___0 , int state ) 
{ 
  struct line t ;

  {
#line 362
  if (state) {
    {
#line 364
    memcpy((void */* __restrict  */)(& t), (void const   */* __restrict  */)a, sizeof(struct line ));
#line 365
    memcpy((void */* __restrict  */)a, (void const   */* __restrict  */)b___0, sizeof(struct line ));
#line 366
    memcpy((void */* __restrict  */)b___0, (void const   */* __restrict  */)(& t),
           sizeof(struct line ));
    }
  } else {
    {
#line 370
    memcpy((void */* __restrict  */)(& t), (void const   */* __restrict  */)a, (unsigned long )(& ((struct line *)0)->mbstate));
#line 371
    memcpy((void */* __restrict  */)a, (void const   */* __restrict  */)b___0, (unsigned long )(& ((struct line *)0)->mbstate));
#line 372
    memcpy((void */* __restrict  */)b___0, (void const   */* __restrict  */)(& t),
           (unsigned long )(& ((struct line *)0)->mbstate));
    }
  }
#line 374
  return;
}
}
#line 378 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static _Bool read_always_fail(struct input *input  __attribute__((__unused__)) ) 
{ 


  {
#line 381
  return ((_Bool)0);
}
}
#line 387 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static char *b  ;
#line 388 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static size_t blen  ;
#line 384 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static _Bool read_file_line(struct input *input ) 
{ 
  long result ;
  size_t tmp ;

  {
  {
#line 390
  tmp = ck_getdelim(& b, & blen, buffer_delimiter, input->fp);
#line 390
  result = (long )tmp;
  }
#line 391
  if (result <= 0L) {
#line 392
    return ((_Bool)0);
  }
#line 395
  if ((int )*(b + (result - 1L)) == (int )buffer_delimiter) {
#line 396
    result --;
  } else {
#line 398
    line.chomped = (_Bool)0;
  }
  {
#line 400
  str_append(& line, (char const   *)b, (size_t )result);
  }
#line 401
  return ((_Bool)1);
}
}
#line 405 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
__inline static void output_missing_newline(struct output *outf ) 
{ 


  {
#line 408
  if (outf->missing_newline) {
    {
#line 410
    ck_fwrite((void const   *)(& buffer_delimiter), (size_t )1, (size_t )1, outf->fp);
#line 411
    outf->missing_newline = (_Bool)0;
    }
  }
#line 413
  return;
}
}
#line 415 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
__inline static void flush_output(FILE *fp ) 
{ 


  {
#line 418
  if ((unsigned long )fp != (unsigned long )stdout) {
    {
#line 419
    ck_fflush(fp);
    }
  } else
#line 418
  if (unbuffered) {
    {
#line 419
    ck_fflush(fp);
    }
  }
#line 420
  return;
}
}
#line 422 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void output_line(char const   *text , size_t length , int nl , struct output *outf ) 
{ 


  {
#line 425
  if (! text) {
#line 426
    return;
  }
  {
#line 428
  output_missing_newline(outf);
  }
#line 429
  if (length) {
    {
#line 430
    ck_fwrite((void const   *)text, (size_t )1, length, outf->fp);
    }
  }
#line 431
  if (nl) {
    {
#line 432
    ck_fwrite((void const   *)(& buffer_delimiter), (size_t )1, (size_t )1, outf->fp);
    }
  } else {
#line 434
    outf->missing_newline = (_Bool)1;
  }
  {
#line 436
  flush_output(outf->fp);
  }
#line 437
  return;
}
}
#line 439 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static struct append_queue *next_append_slot(void) 
{ 
  struct append_queue *n ;
  void *tmp ;

  {
  {
#line 442
  tmp = ck_malloc(sizeof(struct append_queue ));
#line 442
  n = (struct append_queue *)tmp;
#line 444
  n->fname = (char const   *)((void *)0);
#line 445
  n->text = (char *)((void *)0);
#line 446
  n->textlen = (size_t )0;
#line 447
  n->next = (struct append_queue *)((void *)0);
#line 448
  n->free = (_Bool)0;
  }
#line 450
  if (append_tail) {
#line 451
    append_tail->next = n;
  } else {
#line 453
    append_head = n;
  }
#line 454
  append_tail = n;
#line 454
  return (append_tail);
}
}
#line 457 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void release_append_queue(void) 
{ 
  struct append_queue *p ;
  struct append_queue *q ;

  {
#line 462
  p = append_head;
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! p) {
#line 462
      goto while_break;
    }
#line 464
    if (p->free) {
      {
#line 465
      free((void *)p->text);
      }
    }
    {
#line 467
    q = p->next;
#line 468
    free((void *)p);
#line 462
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  append_tail = (struct append_queue *)((void *)0);
#line 470
  append_head = append_tail;
#line 471
  return;
}
}
#line 473 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void dump_append_queue(void) 
{ 
  struct append_queue *p ;
  char buf[8192] ;
  size_t cnt ;
  FILE *fp ;

  {
  {
#line 478
  output_missing_newline(& output_file);
#line 479
  p = append_head;
  }
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! p) {
#line 479
      goto while_break;
    }
#line 481
    if (p->text) {
      {
#line 482
      ck_fwrite((void const   *)p->text, (size_t )1, p->textlen, output_file.fp);
      }
    }
#line 484
    if (p->fname) {
      {
#line 494
      fp = ck_fopen(p->fname, read_mode, 0);
      }
#line 495
      if (fp) {
        {
#line 497
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 497
          cnt = ck_fread((void *)(buf), (size_t )1, sizeof(buf), fp);
          }
#line 497
          if (! (cnt > 0UL)) {
#line 497
            goto while_break___0;
          }
          {
#line 498
          ck_fwrite((void const   *)(buf), (size_t )1, cnt, output_file.fp);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 499
        ck_fclose(fp);
        }
      }
    }
#line 479
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 504
  flush_output(output_file.fp);
#line 505
  release_append_queue();
  }
#line 506
  return;
}
}
#line 510 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static char *get_backup_file_name(char const   *name ) 
{ 
  char *old_asterisk ;
  char *asterisk ;
  char *backup ;
  char *p ;
  int name_length ;
  size_t tmp ;
  int backup_length ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 514
  tmp = strlen(name);
#line 514
  name_length = (int )tmp;
#line 514
  tmp___0 = strlen((char const   *)in_place_extension);
#line 514
  backup_length = (int )tmp___0;
#line 517
  asterisk = in_place_extension - 1;
#line 517
  old_asterisk = asterisk + 1;
  }
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 517
    asterisk = strchr((char const   *)old_asterisk, '*');
    }
#line 517
    if (! asterisk) {
#line 517
      goto while_break;
    }
#line 520
    backup_length += name_length - 1;
#line 517
    old_asterisk = asterisk + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 522
  tmp___1 = xmalloc((size_t )(backup_length + 1));
#line 522
  backup = (char *)tmp___1;
#line 522
  p = backup;
#line 525
  asterisk = in_place_extension - 1;
#line 525
  old_asterisk = asterisk + 1;
  }
  {
#line 525
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 525
    asterisk = strchr((char const   *)old_asterisk, '*');
    }
#line 525
    if (! asterisk) {
#line 525
      goto while_break___0;
    }
    {
#line 529
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)old_asterisk,
           (size_t )(asterisk - old_asterisk));
#line 530
    p += asterisk - old_asterisk;
#line 531
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)name);
#line 532
    p += name_length;
#line 525
    old_asterisk = asterisk + 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 536
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)old_asterisk);
  }
#line 537
  return (backup);
}
}
#line 541 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void open_next_file(char const   *name , struct input *input ) 
{ 
  char const   *ptr ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  FILE *tmp___2 ;
  int input_fd ;
  char *tmpdir ;
  char *p ;
  security_context_t old_fscreatecon ;
  int reset_fscreatecon ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
#line 544
  buffer.length = (size_t )0;
#line 546
  input->in_file_name = name;
#line 547
  if ((int const   )*(name + 0) == 45) {
#line 547
    if ((int const   )*(name + 1) == 0) {
#line 547
      if (! in_place_extension) {
        {
#line 549
        clearerr_unlocked(stdin);
#line 554
        input->fp = stdin;
        }
      } else {
#line 547
        goto _L___0;
      }
    } else {
#line 547
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 559
    if (follow_symlinks) {
      {
#line 560
      input->in_file_name = follow_symlink(name);
      }
    }
    {
#line 562
    tmp___2 = ck_fopen(name, read_mode, 0);
#line 562
    input->fp = tmp___2;
    }
#line 562
    if (! tmp___2) {
      {
#line 564
      tmp = __errno_location();
#line 564
      tmp___0 = strerror(*tmp);
#line 564
      ptr = (char const   *)tmp___0;
#line 565
      tmp___1 = gettext("%s: can\'t read %s: %s\n");
#line 565
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              myname, name, ptr);
#line 566
      input->read_fn = & read_always_fail;
#line 567
      (input->bad_count) ++;
      }
#line 568
      return;
    }
  }
#line 572
  input->read_fn = & read_file_line;
#line 574
  if (in_place_extension) {
    {
#line 579
    reset_fscreatecon = 0;
#line 580
    memset((void *)(& old_fscreatecon), 0, sizeof(old_fscreatecon));
#line 583
    tmpdir = ck_strdup(input->in_file_name);
#line 584
    p = strrchr((char const   *)tmpdir, '/');
    }
#line 584
    if (p) {
#line 585
      *p = (char)0;
    } else {
      {
#line 587
      strcpy((char */* __restrict  */)tmpdir, (char const   */* __restrict  */)".");
      }
    }
    {
#line 589
    tmp___4 = fileno(input->fp);
#line 589
    tmp___5 = isatty(tmp___4);
    }
#line 589
    if (tmp___5) {
      {
#line 590
      tmp___3 = gettext("couldn\'t edit %s: is a terminal");
#line 590
      panic((char const   *)tmp___3, input->in_file_name);
      }
    }
    {
#line 592
    input_fd = fileno(input->fp);
#line 593
    fstat(input_fd, & input->st);
    }
#line 594
    if (! ((input->st.st_mode & 61440U) == 32768U)) {
      {
#line 595
      tmp___6 = gettext("couldn\'t edit %s: not a regular file");
#line 595
      panic((char const   *)tmp___6, input->in_file_name);
      }
    }
    {
#line 620
    output_file.fp = ck_mkstemp(& input->out_file_name, (char const   *)tmpdir, "sed",
                                write_mode);
#line 622
    register_cleanup_file((char const   *)input->out_file_name);
#line 623
    output_file.missing_newline = (_Bool)0;
#line 624
    free((void *)tmpdir);
    }
#line 626
    if (reset_fscreatecon) {
      {
#line 628
      setfscreatecon(old_fscreatecon);
#line 629
      freecon(old_fscreatecon);
      }
    }
#line 632
    if (! output_file.fp) {
      {
#line 633
      tmp___17 = __errno_location();
#line 633
      tmp___18 = strerror(*tmp___17);
#line 633
      tmp___19 = gettext("couldn\'t open temporary file %s: %s");
#line 633
      panic((char const   *)tmp___19, input->out_file_name, tmp___18);
      }
    }
  } else {
#line 638
    if (input->fp) {
#line 638
      if (unbuffered) {
        {
#line 639
        setvbuf((FILE */* __restrict  */)input->fp, (char */* __restrict  */)((void *)0),
                2, (size_t )0);
        }
      }
    }
#line 640
    output_file.fp = stdout;
  }
#line 642
  return;
}
}
#line 646 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void closedown(struct input *input ) 
{ 
  char const   *target_name ;
  int input_fd ;
  int output_fd ;
  int __x ;
  int tmp ;
  int tmp___0 ;
  char *backup_file_name ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 649
  input->read_fn = & read_always_fail;
#line 650
  if (! input->fp) {
#line 651
    return;
  }
#line 653
  if (in_place_extension) {
#line 653
    if ((unsigned long )output_file.fp != (unsigned long )((void *)0)) {
      {
#line 658
      target_name = input->in_file_name;
#line 659
      input_fd = fileno(input->fp);
#line 660
      output_fd = fileno(output_file.fp);
#line 664
      tmp___0 = fchown(output_fd, input->st.st_uid, input->st.st_gid);
      }
#line 664
      if (tmp___0 == -1) {
        {
#line 665
        tmp = fchown(output_fd, (__uid_t )-1, input->st.st_gid);
#line 665
        __x = tmp;
        }
      }
      {
#line 667
      copy_acl(input->in_file_name, input_fd, (char const   *)input->out_file_name,
               output_fd, input->st.st_mode);
#line 671
      ck_fclose(input->fp);
#line 672
      ck_fclose(output_file.fp);
#line 673
      tmp___2 = strcmp((char const   *)in_place_extension, "*");
      }
#line 673
      if (tmp___2 != 0) {
        {
#line 675
        tmp___1 = get_backup_file_name(target_name);
#line 675
        backup_file_name = tmp___1;
#line 676
        ck_rename(target_name, (char const   *)backup_file_name, (char const   *)input->out_file_name);
#line 677
        free((void *)backup_file_name);
        }
      }
      {
#line 680
      ck_rename((char const   *)input->out_file_name, target_name, (char const   *)input->out_file_name);
#line 681
      cancel_cleanup();
#line 682
      free((void *)input->out_file_name);
      }
    } else {
      {
#line 685
      ck_fclose(input->fp);
      }
    }
  } else {
    {
#line 685
    ck_fclose(input->fp);
    }
  }
#line 687
  input->fp = (FILE *)((void *)0);
#line 688
  return;
}
}
#line 691 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void reset_addresses(struct vector *vec ) 
{ 
  struct sed_cmd *cur_cmd ;
  int n ;
  int tmp ;

  {
#line 697
  cur_cmd = vec->v;
#line 697
  n = (int )vec->v_length;
  {
#line 697
  while (1) {
    while_continue: /* CIL Label */ ;
#line 697
    tmp = n;
#line 697
    n --;
#line 697
    if (! tmp) {
#line 697
      goto while_break;
    }
#line 698
    if (cur_cmd->a1) {
#line 698
      if ((unsigned int )(cur_cmd->a1)->addr_type == 2U) {
#line 698
        if ((cur_cmd->a1)->addr_number == 0UL) {
#line 701
          cur_cmd->range_state = (enum addr_state )1;
        } else {
#line 703
          cur_cmd->range_state = (enum addr_state )0;
        }
      } else {
#line 703
        cur_cmd->range_state = (enum addr_state )0;
      }
    } else {
#line 703
      cur_cmd->range_state = (enum addr_state )0;
    }
#line 697
    cur_cmd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  return;
}
}
#line 708 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static _Bool read_pattern_space(struct input *input , struct vector *the_program___0 ,
                                int append ) 
{ 
  char **tmp ;
  _Bool tmp___0 ;

  {
#line 711
  if (append_head) {
    {
#line 712
    dump_append_queue();
    }
  }
#line 713
  replaced = (_Bool)0;
#line 714
  if (! append) {
#line 715
    line.length = (size_t )0;
  }
#line 716
  line.chomped = (_Bool)1;
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 718
    tmp___0 = (*(input->read_fn))(input);
    }
#line 718
    if (tmp___0) {
#line 718
      goto while_break;
    }
    {
#line 720
    closedown(input);
    }
#line 722
    if (! *(input->file_list)) {
#line 723
      return ((_Bool)0);
    }
#line 725
    if (input->reset_at_next_file) {
      {
#line 727
      input->line_number = (countT )0;
#line 728
      hold.length = (size_t )0;
#line 729
      reset_addresses(the_program___0);
#line 730
      rewind_read_files();
      }
#line 735
      if (in_place_extension) {
#line 736
        output_file.missing_newline = (_Bool)0;
      }
#line 738
      input->reset_at_next_file = separate_files;
    }
    {
#line 741
    tmp = input->file_list;
#line 741
    (input->file_list) ++;
#line 741
    open_next_file((char const   *)*tmp, input);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 744
  (input->line_number) ++;
#line 745
  return ((_Bool)1);
}
}
#line 749 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static _Bool last_file_with_data_p(struct input *input ) 
{ 
  int ch ;
  char **tmp ;

  {
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 756
    closedown(input);
    }
#line 757
    if (! *(input->file_list)) {
#line 758
      return ((_Bool)1);
    }
    {
#line 759
    tmp = input->file_list;
#line 759
    (input->file_list) ++;
#line 759
    open_next_file((char const   *)*tmp, input);
    }
#line 760
    if (input->fp) {
      {
#line 762
      ch = getc_unlocked(input->fp);
      }
#line 762
      if (ch != -1) {
        {
#line 764
        ungetc(ch, input->fp);
        }
#line 765
        return ((_Bool)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 772 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static _Bool test_eof(struct input *input ) 
{ 
  int ch ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
#line 777
  if (buffer.length) {
#line 778
    return ((_Bool)0);
  }
#line 779
  if (! input->fp) {
#line 780
    if (separate_files) {
#line 780
      tmp___0 = 1;
    } else {
      {
#line 780
      tmp = last_file_with_data_p(input);
      }
#line 780
      if (tmp) {
#line 780
        tmp___0 = 1;
      } else {
#line 780
        tmp___0 = 0;
      }
    }
#line 780
    return ((_Bool )tmp___0);
  }
  {
#line 781
  tmp___3 = feof_unlocked(input->fp);
  }
#line 781
  if (tmp___3) {
#line 782
    if (separate_files) {
#line 782
      tmp___2 = 1;
    } else {
      {
#line 782
      tmp___1 = last_file_with_data_p(input);
      }
#line 782
      if (tmp___1) {
#line 782
        tmp___2 = 1;
      } else {
#line 782
        tmp___2 = 0;
      }
    }
#line 782
    return ((_Bool )tmp___2);
  }
  {
#line 783
  ch = getc_unlocked(input->fp);
  }
#line 783
  if (ch == -1) {
#line 784
    if (separate_files) {
#line 784
      tmp___5 = 1;
    } else {
      {
#line 784
      tmp___4 = last_file_with_data_p(input);
      }
#line 784
      if (tmp___4) {
#line 784
        tmp___5 = 1;
      } else {
#line 784
        tmp___5 = 0;
      }
    }
#line 784
    return ((_Bool )tmp___5);
  }
  {
#line 785
  ungetc(ch, input->fp);
  }
#line 786
  return ((_Bool)0);
}
}
#line 791 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static _Bool match_an_address_p(struct addr *addr , struct input *input ) 
{ 
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 796
  if ((unsigned int )addr->addr_type == 0U) {
#line 796
    goto case_0;
  }
#line 799
  if ((unsigned int )addr->addr_type == 1U) {
#line 799
    goto case_1;
  }
#line 803
  if ((unsigned int )addr->addr_type == 3U) {
#line 803
    goto case_3;
  }
#line 809
  if ((unsigned int )addr->addr_type == 5U) {
#line 809
    goto case_5;
  }
#line 809
  if ((unsigned int )addr->addr_type == 4U) {
#line 809
    goto case_5;
  }
#line 815
  if ((unsigned int )addr->addr_type == 6U) {
#line 815
    goto case_6;
  }
#line 818
  if ((unsigned int )addr->addr_type == 2U) {
#line 818
    goto case_2;
  }
#line 822
  goto switch_default;
  case_0: /* CIL Label */ 
#line 797
  return ((_Bool)1);
  case_1: /* CIL Label */ 
  {
#line 800
  tmp = match_regex(addr->addr_regex, line.active, line.length, (size_t )0, (struct re_registers *)((void *)0),
                    0);
  }
#line 800
  return ((_Bool )tmp);
  case_3: /* CIL Label */ 
#line 804
  if (input->line_number >= addr->addr_number) {
#line 804
    if ((input->line_number - addr->addr_number) % addr->addr_step == 0UL) {
#line 804
      tmp___0 = 1;
    } else {
#line 804
      tmp___0 = 0;
    }
  } else {
#line 804
    tmp___0 = 0;
  }
#line 804
  return ((_Bool )tmp___0);
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 813
  return ((_Bool )(addr->addr_number <= input->line_number));
  case_6: /* CIL Label */ 
  {
#line 816
  tmp___1 = test_eof(input);
  }
#line 816
  return (tmp___1);
  case_2: /* CIL Label */ 
#line 820
  return ((_Bool )(addr->addr_number == input->line_number));
  switch_default: /* CIL Label */ 
  {
#line 823
  panic("INTERNAL ERROR: bad address type");
  }
  switch_break: /* CIL Label */ ;
  }
#line 826
  return ((_Bool)0);
}
}
#line 830 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static _Bool match_address_p(struct sed_cmd *cmd , struct input *input ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
#line 833
  if (! cmd->a1) {
#line 834
    return ((_Bool)1);
  }
#line 836
  if ((unsigned int )cmd->range_state != 1U) {
#line 838
    if (! cmd->a2) {
      {
#line 839
      tmp = match_an_address_p(cmd->a1, input);
      }
#line 839
      return (tmp);
    }
#line 844
    if ((unsigned int )(cmd->a1)->addr_type == 2U) {
#line 846
      if ((unsigned int )cmd->range_state == 2U) {
#line 848
        return ((_Bool)0);
      } else
#line 846
      if (input->line_number < (cmd->a1)->addr_number) {
#line 848
        return ((_Bool)0);
      }
    } else {
      {
#line 852
      tmp___0 = match_an_address_p(cmd->a1, input);
      }
#line 852
      if (! tmp___0) {
#line 853
        return ((_Bool)0);
      }
    }
#line 857
    cmd->range_state = (enum addr_state )1;
    {
#line 860
    if ((unsigned int )(cmd->a2)->addr_type == 1U) {
#line 860
      goto case_1;
    }
#line 863
    if ((unsigned int )(cmd->a2)->addr_type == 2U) {
#line 863
      goto case_2;
    }
#line 869
    if ((unsigned int )(cmd->a2)->addr_type == 4U) {
#line 869
      goto case_4;
    }
#line 872
    if ((unsigned int )(cmd->a2)->addr_type == 5U) {
#line 872
      goto case_5;
    }
#line 876
    goto switch_default;
    case_1: /* CIL Label */ 
#line 862
    return ((_Bool)1);
    case_2: /* CIL Label */ 
#line 865
    if (input->line_number >= (cmd->a2)->addr_number) {
#line 866
      cmd->range_state = (enum addr_state )2;
    }
#line 867
    if (input->line_number <= (cmd->a2)->addr_number) {
#line 867
      tmp___2 = 1;
    } else {
      {
#line 867
      tmp___1 = match_an_address_p(cmd->a1, input);
      }
#line 867
      if (tmp___1) {
#line 867
        tmp___2 = 1;
      } else {
#line 867
        tmp___2 = 0;
      }
    }
#line 867
    return ((_Bool )tmp___2);
    case_4: /* CIL Label */ 
#line 870
    (cmd->a2)->addr_number = input->line_number + (cmd->a2)->addr_step;
#line 871
    return ((_Bool)1);
    case_5: /* CIL Label */ 
#line 873
    (cmd->a2)->addr_number = (input->line_number + (cmd->a2)->addr_step) - input->line_number % (cmd->a2)->addr_step;
#line 875
    return ((_Bool)1);
    switch_default: /* CIL Label */ 
#line 877
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 884
  if ((unsigned int )(cmd->a2)->addr_type == 2U) {
#line 890
    if (input->line_number >= (cmd->a2)->addr_number) {
#line 891
      cmd->range_state = (enum addr_state )2;
    }
#line 893
    return ((_Bool )(input->line_number <= (cmd->a2)->addr_number));
  }
  {
#line 897
  tmp___3 = match_an_address_p(cmd->a2, input);
  }
#line 897
  if (tmp___3) {
#line 898
    cmd->range_state = (enum addr_state )2;
  }
#line 900
  return ((_Bool)1);
}
}
#line 904 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void do_list(int line_len ) 
{ 
  unsigned char *p ;
  countT len ;
  countT width ;
  char obuf[180] ;
  char *o ;
  size_t olen ;
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  countT tmp___11 ;

  {
  {
#line 907
  p = (unsigned char *)line.active;
#line 908
  len = line.length;
#line 909
  width = (countT )0;
#line 913
  fp = output_file.fp;
#line 915
  output_missing_newline(& output_file);
  }
  {
#line 916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 916
    tmp___11 = len;
#line 916
    len --;
#line 916
    if (! tmp___11) {
#line 916
      goto while_break;
    }
#line 917
    o = obuf;
#line 923
    if (((int )*p & -128) == 0) {
      {
#line 923
      tmp___10 = __ctype_b_loc();
      }
#line 923
      if ((int const   )*(*tmp___10 + (int )*p) & 16384) {
#line 927
        tmp = o;
#line 927
        o ++;
#line 927
        *tmp = (char )*p;
#line 928
        if ((int )*p == 92) {
#line 929
          tmp___0 = o;
#line 929
          o ++;
#line 929
          *tmp___0 = (char )'\\';
        }
      } else {
#line 923
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 931
      tmp___1 = o;
#line 931
      o ++;
#line 931
      *tmp___1 = (char )'\\';
      {
#line 934
      if ((int )*p == 7) {
#line 934
        goto case_7;
      }
#line 938
      if ((int )*p == 8) {
#line 938
        goto case_8;
      }
#line 939
      if ((int )*p == 12) {
#line 939
        goto case_12;
      }
#line 940
      if ((int )*p == 10) {
#line 940
        goto case_10;
      }
#line 941
      if ((int )*p == 13) {
#line 941
        goto case_13;
      }
#line 942
      if ((int )*p == 9) {
#line 942
        goto case_9;
      }
#line 943
      if ((int )*p == 11) {
#line 943
        goto case_11;
      }
#line 944
      goto switch_default;
      case_7: /* CIL Label */ 
#line 934
      tmp___2 = o;
#line 934
      o ++;
#line 934
      *tmp___2 = (char )'a';
#line 934
      goto switch_break;
      case_8: /* CIL Label */ 
#line 938
      tmp___3 = o;
#line 938
      o ++;
#line 938
      *tmp___3 = (char )'b';
#line 938
      goto switch_break;
      case_12: /* CIL Label */ 
#line 939
      tmp___4 = o;
#line 939
      o ++;
#line 939
      *tmp___4 = (char )'f';
#line 939
      goto switch_break;
      case_10: /* CIL Label */ 
#line 940
      tmp___5 = o;
#line 940
      o ++;
#line 940
      *tmp___5 = (char )'n';
#line 940
      goto switch_break;
      case_13: /* CIL Label */ 
#line 941
      tmp___6 = o;
#line 941
      o ++;
#line 941
      *tmp___6 = (char )'r';
#line 941
      goto switch_break;
      case_9: /* CIL Label */ 
#line 942
      tmp___7 = o;
#line 942
      o ++;
#line 942
      *tmp___7 = (char )'t';
#line 942
      goto switch_break;
      case_11: /* CIL Label */ 
#line 943
      tmp___8 = o;
#line 943
      o ++;
#line 943
      *tmp___8 = (char )'v';
#line 943
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 945
      sprintf((char */* __restrict  */)o, (char const   */* __restrict  */)"%03o",
              (int )*p);
#line 946
      tmp___9 = strlen((char const   *)o);
#line 946
      o += tmp___9;
      }
#line 947
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 950
    olen = (size_t )(o - obuf);
#line 951
    if (width + olen >= (countT )line_len) {
#line 951
      if (line_len > 0) {
        {
#line 952
        ck_fwrite((void const   *)"\\", (size_t )1, (size_t )1, fp);
#line 953
        ck_fwrite((void const   *)(& buffer_delimiter), (size_t )1, (size_t )1, fp);
#line 954
        width = (countT )0;
        }
      }
    }
    {
#line 956
    ck_fwrite((void const   *)(obuf), (size_t )1, olen, fp);
#line 957
    width += olen;
#line 916
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 959
  ck_fwrite((void const   *)"$", (size_t )1, (size_t )1, fp);
#line 960
  ck_fwrite((void const   *)(& buffer_delimiter), (size_t )1, (size_t )1, fp);
#line 961
  flush_output(fp);
  }
#line 962
  return;
}
}
#line 965 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void append_replacement(struct line *buf , struct replacement *p , struct re_registers *regs___0 ) 
{ 
  enum replacement_types repl_mod ;
  int i ;
  enum replacement_types curr_type ;

  {
#line 968
  repl_mod = (enum replacement_types )0;
  {
#line 970
  while (1) {
    while_continue: /* CIL Label */ ;
#line 970
    if (! p) {
#line 970
      goto while_break;
    }
#line 972
    i = p->subst_id;
#line 978
    if ((unsigned int )p->repl_type & 12U) {
#line 978
      curr_type = p->repl_type;
    } else {
#line 978
      curr_type = (enum replacement_types )((unsigned int )p->repl_type | (unsigned int )repl_mod);
    }
#line 982
    repl_mod = (enum replacement_types )0;
#line 983
    if (p->prefix_length) {
      {
#line 985
      str_append_modified(buf, (char const   *)p->prefix, p->prefix_length, curr_type);
#line 987
      curr_type = (enum replacement_types )((unsigned int )curr_type & 4294967283U);
      }
    }
#line 990
    if (0 <= i) {
#line 992
      if (*(regs___0->end + i) == *(regs___0->start + i)) {
#line 992
        if ((unsigned int )p->repl_type & 12U) {
#line 996
          repl_mod = (enum replacement_types )((unsigned int )curr_type & 12U);
        } else {
#line 992
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 998
      if (*(regs___0->end + i) != *(regs___0->start + i)) {
        {
#line 999
        str_append_modified(buf, (char const   *)(line.active + *(regs___0->start + i)),
                            (size_t )(*(regs___0->end + i) - *(regs___0->start + i)),
                            curr_type);
        }
      }
    }
#line 970
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1004
  return;
}
}
#line 1014 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static struct re_registers regs  ;
#line 1006 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void do_subst(struct subst *sub ) 
{ 
  size_t start ;
  size_t last_end ;
  countT count ;
  _Bool again ;
  int tmp ;
  size_t offset ;
  size_t matched ;
  int tmp___0 ;
  FILE *pipe_fp ;
  char buf[4096] ;
  int n ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1009
  start = (size_t )0;
#line 1010
  last_end = (size_t )0;
#line 1011
  count = (countT )0;
#line 1012
  again = (_Bool)1;
#line 1016
  line_reset(& s_accum, & line);
#line 1020
  tmp = match_regex(sub->regx, line.active, line.length, start, & regs, (int )(sub->max_id + 1U));
  }
#line 1020
  if (! tmp) {
#line 1022
    return;
  }
#line 1024
  if (! sub->replacement) {
#line 1024
    if (sub->numb <= 1UL) {
#line 1026
      if (*(regs.start + 0) == 0) {
#line 1026
        if (! sub->global) {
#line 1029
          replaced = (_Bool)1;
#line 1031
          line.active += *(regs.end + 0);
#line 1032
          line.length -= (size_t )*(regs.end + 0);
#line 1033
          line.alloc -= (size_t )*(regs.end + 0);
#line 1034
          goto post_subst;
        } else {
#line 1026
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1036
      if ((size_t )*(regs.end + 0) == line.length) {
#line 1039
        replaced = (_Bool)1;
#line 1041
        line.length = (size_t )*(regs.start + 0);
#line 1042
        goto post_subst;
      }
    }
  }
  {
#line 1046
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1048
    offset = (size_t )*(regs.start + 0);
#line 1049
    matched = (size_t )(*(regs.end + 0) - *(regs.start + 0));
#line 1052
    if (start < offset) {
      {
#line 1053
      str_append(& s_accum, (char const   *)(line.active + start), offset - start);
      }
    }
#line 1064
    if (matched > 0UL) {
#line 1064
      goto _L___1;
    } else
#line 1064
    if (count == 0UL) {
#line 1064
      goto _L___1;
    } else
#line 1064
    if (offset > last_end) {
      _L___1: /* CIL Label */ 
#line 1064
      count ++;
#line 1064
      if (count >= sub->numb) {
        {
#line 1068
        replaced = (_Bool)1;
#line 1071
        append_replacement(& s_accum, sub->replacement, & regs);
#line 1072
        again = (_Bool )sub->global;
        }
      } else {
#line 1064
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1079
      if (matched == 0UL) {
#line 1081
        if (start < line.length) {
#line 1082
          matched = (size_t )1;
        } else {
#line 1084
          goto while_break;
        }
      }
      {
#line 1087
      str_append(& s_accum, (char const   *)(line.active + offset), matched);
      }
    }
#line 1093
    start = offset + matched;
#line 1094
    last_end = (size_t )*(regs.end + 0);
#line 1046
    if (again) {
#line 1046
      if (start <= line.length) {
        {
#line 1046
        tmp___0 = match_regex(sub->regx, line.active, line.length, start, & regs,
                              (int )(sub->max_id + 1U));
        }
#line 1046
        if (! tmp___0) {
#line 1046
          goto while_break;
        }
      } else {
#line 1046
        goto while_break;
      }
    } else {
#line 1046
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1102
  if (start < line.length) {
    {
#line 1103
    str_append(& s_accum, (char const   *)(line.active + start), line.length - start);
    }
  }
  {
#line 1104
  s_accum.chomped = line.chomped;
#line 1108
  line_exchange(& line, & s_accum, 0);
  }
#line 1111
  if (count < sub->numb) {
#line 1112
    return;
  }
  post_subst: 
#line 1115
  if (sub->print & 1U) {
    {
#line 1116
    output_line((char const   *)line.active, line.length, (int )line.chomped, & output_file);
    }
  }
#line 1118
  if (sub->eval) {
    {
#line 1122
    line_reset(& s_accum, (struct line *)((void *)0));
#line 1124
    str_append(& line, "", (size_t )1);
#line 1125
    pipe_fp = popen((char const   *)line.active, "r");
    }
#line 1127
    if ((unsigned long )pipe_fp != (unsigned long )((void *)0)) {
      {
#line 1129
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1129
        tmp___2 = feof_unlocked(pipe_fp);
        }
#line 1129
        if (tmp___2) {
#line 1129
          goto while_break___0;
        }
        {
#line 1132
        tmp___1 = fread_unlocked((void */* __restrict  */)(buf), sizeof(char ), (size_t )4096,
                                 (FILE */* __restrict  */)pipe_fp);
#line 1132
        n = (int )tmp___1;
        }
#line 1133
        if (n > 0) {
          {
#line 1134
          str_append(& s_accum, (char const   *)(buf), (size_t )n);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1137
      pclose(pipe_fp);
#line 1142
      line_exchange(& line, & s_accum, 1);
      }
#line 1143
      if (line.length) {
#line 1143
        if ((int )*(line.active + (line.length - 1UL)) == (int )buffer_delimiter) {
#line 1145
          (line.length) --;
        }
      }
    } else {
      {
#line 1148
      tmp___3 = gettext("error in subprocess");
#line 1148
      panic((char const   *)tmp___3);
      }
    }
  }
#line 1154
  if (sub->print & 2U) {
    {
#line 1155
    output_line((char const   *)line.active, line.length, (int )line.chomped, & output_file);
    }
  }
#line 1156
  if (sub->outf) {
    {
#line 1157
    output_line((char const   *)line.active, line.length, (int )line.chomped, sub->outf);
    }
  }
#line 1158
  return;
}
}
#line 1213 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static void translate_mb(char * const  *trans ) 
{ 
  size_t idx ;
  mbstate_t mbstate ;
  unsigned int i ;
  size_t mbclen ;
  size_t tmp ;
  size_t tmp___0 ;
  _Bool move_remain_buffer ;
  char const   *tr ;
  size_t trans_len ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t new_len ;
  size_t prev_idx ;
  char const   *move_from ;
  char *move_to ;
  size_t move_len ;
  size_t move_offset ;
  int tmp___3 ;

  {
#line 1217
  mbstate.__count = 0;
#line 1217
  mbstate.__value.__wch = 0U;
#line 1218
  idx = (size_t )0;
  {
#line 1218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1218
    if (! (idx < line.length)) {
#line 1218
      goto while_break;
    }
#line 1221
    if (mb_cur_max == 1) {
#line 1221
      tmp___0 = (size_t )1;
    } else {
      {
#line 1221
      tmp = rpl_mbrtowc((wchar_t *)((void *)0), (char const   *)(line.active + idx),
                        line.length - idx, & mbstate);
#line 1221
      tmp___0 = tmp;
      }
    }
#line 1221
    mbclen = tmp___0;
#line 1225
    if (mbclen == 0xffffffffffffffffUL) {
#line 1226
      mbclen = (size_t )1;
    } else
#line 1225
    if (mbclen == 0xfffffffffffffffeUL) {
#line 1226
      mbclen = (size_t )1;
    } else
#line 1225
    if (mbclen == 0UL) {
#line 1226
      mbclen = (size_t )1;
    }
#line 1229
    i = 0U;
    {
#line 1229
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1229
      if (! ((unsigned long )*(trans + 2U * i) != (unsigned long )((void *)0))) {
#line 1229
        goto while_break___0;
      }
      {
#line 1231
      tmp___3 = strncmp((char const   *)(line.active + idx), (char const   *)*(trans + 2U * i),
                        mbclen);
      }
#line 1231
      if (tmp___3 == 0) {
#line 1233
        move_remain_buffer = (_Bool)0;
#line 1234
        tr = (char const   *)*(trans + (2U * i + 1U));
#line 1235
        if ((int const   )*tr == 0) {
#line 1235
          tmp___2 = (size_t )1;
        } else {
          {
#line 1235
          tmp___1 = strlen(tr);
#line 1235
          tmp___2 = tmp___1;
          }
        }
#line 1235
        trans_len = tmp___2;
#line 1237
        if (mbclen < trans_len) {
#line 1239
          new_len = ((line.length + 1UL) + trans_len) - mbclen;
#line 1242
          if (line.alloc < new_len) {
            {
#line 1245
            resize_line(& line, new_len);
            }
          }
#line 1247
          move_remain_buffer = (_Bool)1;
        } else
#line 1249
        if (mbclen > trans_len) {
#line 1252
          move_remain_buffer = (_Bool)1;
        }
#line 1254
        prev_idx = idx;
#line 1255
        if (move_remain_buffer) {
          {
#line 1258
          move_from = (char const   *)((line.active + idx) + mbclen);
#line 1259
          move_to = (line.active + idx) + trans_len;
#line 1260
          move_len = ((line.length + 1UL) - idx) - mbclen;
#line 1261
          move_offset = trans_len - mbclen;
#line 1262
          memmove((void *)move_to, (void const   *)move_from, move_len);
#line 1263
          line.length += move_offset;
#line 1264
          idx += move_offset;
          }
        }
        {
#line 1266
        memcpy((void */* __restrict  */)(line.active + prev_idx), (void const   */* __restrict  */)*(trans + (2U * i + 1U)),
               trans_len);
        }
#line 1268
        goto while_break___0;
      }
#line 1229
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1271
    idx += mbclen;
  }
  while_break: /* CIL Label */ ;
  }
#line 1273
  return;
}
}
#line 1277 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static int execute_program(struct vector *vec , struct input *input ) 
{ 
  struct sed_cmd *cur_cmd ;
  struct sed_cmd *end_cmd ;
  struct append_queue *aq ;
  struct append_queue *tmp ;
  char *p ;
  void *tmp___0 ;
  FILE *pipe_fp ;
  int cmd_length ;
  char *tmp___1 ;
  char buf[4096] ;
  int n ;
  size_t tmp___2 ;
  int tmp___3 ;
  countT tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  char *p___0 ;
  void *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  struct append_queue *aq___0 ;
  struct append_queue *tmp___13 ;
  struct append_queue *aq___1 ;
  size_t buflen ;
  char *text ;
  int result ;
  size_t tmp___14 ;
  int tmp___15 ;
  char *p___1 ;
  void *tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  unsigned char *p___2 ;
  unsigned char *e ;
  _Bool tmp___19 ;

  {
#line 1283
  cur_cmd = vec->v;
#line 1284
  end_cmd = vec->v + vec->v_length;
  {
#line 1285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1285
    if (! ((unsigned long )cur_cmd < (unsigned long )end_cmd)) {
#line 1285
      goto while_break;
    }
    {
#line 1287
    tmp___19 = match_address_p(cur_cmd, input);
    }
#line 1287
    if ((int )tmp___19 != (int )cur_cmd->addr_bang) {
      {
#line 1291
      if ((int )cur_cmd->cmd == 97) {
#line 1291
        goto case_97;
      }
#line 1300
      if ((int )cur_cmd->cmd == 98) {
#line 1300
        goto case_98;
      }
#line 1300
      if ((int )cur_cmd->cmd == 123) {
#line 1300
        goto case_98;
      }
#line 1306
      if ((int )cur_cmd->cmd == 58) {
#line 1306
        goto case_58;
      }
#line 1306
      if ((int )cur_cmd->cmd == 35) {
#line 1306
        goto case_58;
      }
#line 1306
      if ((int )cur_cmd->cmd == 125) {
#line 1306
        goto case_58;
      }
#line 1310
      if ((int )cur_cmd->cmd == 99) {
#line 1310
        goto case_99;
      }
#line 1318
      if ((int )cur_cmd->cmd == 100) {
#line 1318
        goto case_100;
      }
#line 1321
      if ((int )cur_cmd->cmd == 68) {
#line 1321
        goto case_68;
      }
#line 1337
      if ((int )cur_cmd->cmd == 101) {
#line 1337
        goto case_101;
      }
#line 1393
      if ((int )cur_cmd->cmd == 103) {
#line 1393
        goto case_103;
      }
#line 1404
      if ((int )cur_cmd->cmd == 71) {
#line 1404
        goto case_71;
      }
#line 1413
      if ((int )cur_cmd->cmd == 104) {
#line 1413
        goto case_104;
      }
#line 1418
      if ((int )cur_cmd->cmd == 72) {
#line 1418
        goto case_72;
      }
#line 1423
      if ((int )cur_cmd->cmd == 105) {
#line 1423
        goto case_105;
      }
#line 1429
      if ((int )cur_cmd->cmd == 108) {
#line 1429
        goto case_108;
      }
#line 1435
      if ((int )cur_cmd->cmd == 110) {
#line 1435
        goto case_110;
      }
#line 1443
      if ((int )cur_cmd->cmd == 78) {
#line 1443
        goto case_78;
      }
#line 1456
      if ((int )cur_cmd->cmd == 112) {
#line 1456
        goto case_112;
      }
#line 1460
      if ((int )cur_cmd->cmd == 80) {
#line 1460
        goto case_80;
      }
#line 1468
      if ((int )cur_cmd->cmd == 113) {
#line 1468
        goto case_113;
      }
#line 1475
      if ((int )cur_cmd->cmd == 81) {
#line 1475
        goto case_81;
      }
#line 1478
      if ((int )cur_cmd->cmd == 114) {
#line 1478
        goto case_114;
      }
#line 1486
      if ((int )cur_cmd->cmd == 82) {
#line 1486
        goto case_82;
      }
#line 1506
      if ((int )cur_cmd->cmd == 115) {
#line 1506
        goto case_115;
      }
#line 1510
      if ((int )cur_cmd->cmd == 116) {
#line 1510
        goto case_116;
      }
#line 1519
      if ((int )cur_cmd->cmd == 84) {
#line 1519
        goto case_84;
      }
#line 1529
      if ((int )cur_cmd->cmd == 119) {
#line 1529
        goto case_119;
      }
#line 1535
      if ((int )cur_cmd->cmd == 87) {
#line 1535
        goto case_87;
      }
#line 1544
      if ((int )cur_cmd->cmd == 120) {
#line 1544
        goto case_120;
      }
#line 1549
      if ((int )cur_cmd->cmd == 121) {
#line 1549
        goto case_121;
      }
#line 1561
      if ((int )cur_cmd->cmd == 122) {
#line 1561
        goto case_122;
      }
#line 1565
      if ((int )cur_cmd->cmd == 61) {
#line 1565
        goto case_61;
      }
#line 1573
      if ((int )cur_cmd->cmd == 70) {
#line 1573
        goto case_70;
      }
#line 1581
      goto switch_default;
      case_97: /* CIL Label */ 
      {
#line 1293
      tmp = next_append_slot();
#line 1293
      aq = tmp;
#line 1294
      aq->text = cur_cmd->x.cmd_txt.text;
#line 1295
      aq->textlen = cur_cmd->x.cmd_txt.text_length;
      }
#line 1297
      goto switch_break;
      case_98: /* CIL Label */ 
      case_123: /* CIL Label */ 
#line 1301
      cur_cmd = vec->v + cur_cmd->x.jump_index;
#line 1302
      goto while_continue;
      case_58: /* CIL Label */ 
      case_35: /* CIL Label */ 
      case_125: /* CIL Label */ 
#line 1308
      goto switch_break;
      case_99: /* CIL Label */ 
#line 1311
      if ((unsigned int )cur_cmd->range_state != 1U) {
        {
#line 1312
        output_line((char const   *)cur_cmd->x.cmd_txt.text, cur_cmd->x.cmd_txt.text_length - 1UL,
                    1, & output_file);
        }
      }
      case_100: /* CIL Label */ 
#line 1319
      return (-1);
      case_68: /* CIL Label */ 
      {
#line 1323
      tmp___0 = memchr((void const   *)line.active, (int )buffer_delimiter, line.length);
#line 1323
      p = (char *)tmp___0;
      }
#line 1324
      if (! p) {
#line 1325
        return (-1);
      }
#line 1327
      p ++;
#line 1328
      line.alloc -= (size_t )(p - line.active);
#line 1329
      line.length -= (size_t )(p - line.active);
#line 1330
      line.active += p - line.active;
#line 1333
      cur_cmd = vec->v;
#line 1334
      goto while_continue;
      case_101: /* CIL Label */ 
      {
#line 1342
      cmd_length = (int )cur_cmd->x.cmd_txt.text_length;
#line 1343
      line_reset(& s_accum, (struct line *)((void *)0));
      }
#line 1345
      if (! cmd_length) {
        {
#line 1347
        str_append(& line, "", (size_t )1);
#line 1348
        pipe_fp = popen((char const   *)line.active, "r");
        }
      } else {
        {
#line 1352
        *(cur_cmd->x.cmd_txt.text + (cmd_length - 1)) = (char)0;
#line 1353
        pipe_fp = popen((char const   *)cur_cmd->x.cmd_txt.text, "r");
#line 1354
        output_missing_newline(& output_file);
        }
      }
#line 1357
      if ((unsigned long )pipe_fp == (unsigned long )((void *)0)) {
        {
#line 1358
        tmp___1 = gettext("error in subprocess");
#line 1358
        panic((char const   *)tmp___1);
        }
      }
      {
#line 1363
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1363
        tmp___3 = feof_unlocked(pipe_fp);
        }
#line 1363
        if (tmp___3) {
#line 1363
          goto while_break___0;
        }
        {
#line 1364
        tmp___2 = fread_unlocked((void */* __restrict  */)(buf), sizeof(char ), (size_t )4096,
                                 (FILE */* __restrict  */)pipe_fp);
#line 1364
        n = (int )tmp___2;
        }
#line 1364
        if (n > 0) {
#line 1366
          if (! cmd_length) {
            {
#line 1367
            str_append(& s_accum, (char const   *)(buf), (size_t )n);
            }
          } else {
            {
#line 1369
            ck_fwrite((void const   *)(buf), (size_t )1, (size_t )n, output_file.fp);
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1372
      pclose(pipe_fp);
      }
#line 1373
      if (! cmd_length) {
#line 1376
        if (s_accum.length) {
#line 1376
          if ((int )*(s_accum.active + (s_accum.length - 1UL)) == (int )buffer_delimiter) {
#line 1378
            (s_accum.length) --;
          }
        }
        {
#line 1384
        line_exchange(& line, & s_accum, 1);
        }
      } else {
        {
#line 1387
        flush_output(output_file.fp);
        }
      }
#line 1390
      goto switch_break;
      case_103: /* CIL Label */ 
      {
#line 1401
      line_copy(& hold, & line, 1);
      }
#line 1402
      goto switch_break;
      case_71: /* CIL Label */ 
      {
#line 1410
      line_append(& hold, & line, 1);
      }
#line 1411
      goto switch_break;
      case_104: /* CIL Label */ 
      {
#line 1415
      line_copy(& line, & hold, 1);
      }
#line 1416
      goto switch_break;
      case_72: /* CIL Label */ 
      {
#line 1420
      line_append(& line, & hold, 1);
      }
#line 1421
      goto switch_break;
      case_105: /* CIL Label */ 
      {
#line 1424
      output_line((char const   *)cur_cmd->x.cmd_txt.text, cur_cmd->x.cmd_txt.text_length - 1UL,
                  1, & output_file);
      }
#line 1427
      goto switch_break;
      case_108: /* CIL Label */ 
#line 1430
      if (cur_cmd->x.int_arg == -1) {
#line 1430
        tmp___4 = lcmd_out_line_len;
      } else {
#line 1430
        tmp___4 = (countT )cur_cmd->x.int_arg;
      }
      {
#line 1430
      do_list((int )tmp___4);
      }
#line 1433
      goto switch_break;
      case_110: /* CIL Label */ 
#line 1436
      if (! no_default_output) {
        {
#line 1437
        output_line((char const   *)line.active, line.length, (int )line.chomped,
                    & output_file);
        }
      }
      {
#line 1439
      tmp___5 = test_eof(input);
      }
#line 1439
      if (tmp___5) {
#line 1440
        return (-1);
      } else {
        {
#line 1439
        tmp___6 = read_pattern_space(input, vec, 0);
        }
#line 1439
        if (! tmp___6) {
#line 1440
          return (-1);
        }
      }
#line 1441
      goto switch_break;
      case_78: /* CIL Label */ 
      {
#line 1444
      str_append(& line, (char const   *)(& buffer_delimiter), (size_t )1);
#line 1446
      tmp___7 = test_eof(input);
      }
#line 1446
      if (tmp___7) {
#line 1446
        goto _L;
      } else {
        {
#line 1446
        tmp___8 = read_pattern_space(input, vec, 1);
        }
#line 1446
        if (! tmp___8) {
          _L: /* CIL Label */ 
#line 1448
          (line.length) --;
#line 1449
          if ((unsigned int )posixicity == 0U) {
#line 1449
            if (! no_default_output) {
              {
#line 1450
              output_line((char const   *)line.active, line.length, (int )line.chomped,
                          & output_file);
              }
            }
          }
#line 1452
          return (-1);
        }
      }
#line 1454
      goto switch_break;
      case_112: /* CIL Label */ 
      {
#line 1457
      output_line((char const   *)line.active, line.length, (int )line.chomped, & output_file);
      }
#line 1458
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 1462
      tmp___9 = memchr((void const   *)line.active, (int )buffer_delimiter, line.length);
#line 1462
      p___0 = (char *)tmp___9;
      }
#line 1463
      if (p___0) {
#line 1463
        tmp___10 = 1;
      } else {
#line 1463
        tmp___10 = (int )line.chomped;
      }
#line 1463
      if (p___0) {
#line 1463
        tmp___11 = (size_t )(p___0 - line.active);
      } else {
#line 1463
        tmp___11 = line.length;
      }
      {
#line 1463
      output_line((char const   *)line.active, tmp___11, tmp___10, & output_file);
      }
#line 1466
      goto switch_break;
      case_113: /* CIL Label */ 
#line 1469
      if (! no_default_output) {
        {
#line 1470
        output_line((char const   *)line.active, line.length, (int )line.chomped,
                    & output_file);
        }
      }
      {
#line 1472
      dump_append_queue();
      }
      case_81: /* CIL Label */ 
#line 1476
      if (cur_cmd->x.int_arg == -1) {
#line 1476
        tmp___12 = 0;
      } else {
#line 1476
        tmp___12 = cur_cmd->x.int_arg;
      }
#line 1476
      return (tmp___12);
      case_114: /* CIL Label */ 
#line 1479
      if (cur_cmd->x.fname) {
        {
#line 1481
        tmp___13 = next_append_slot();
#line 1481
        aq___0 = tmp___13;
#line 1482
        aq___0->fname = (char const   *)cur_cmd->x.fname;
        }
      }
#line 1484
      goto switch_break;
      case_82: /* CIL Label */ 
#line 1487
      if (cur_cmd->x.fp) {
        {
#line 1487
        tmp___15 = feof_unlocked(cur_cmd->x.fp);
        }
#line 1487
        if (! tmp___15) {
          {
#line 1491
          text = (char *)((void *)0);
#line 1494
          tmp___14 = ck_getdelim(& text, & buflen, buffer_delimiter, cur_cmd->x.fp);
#line 1494
          result = (int )tmp___14;
          }
#line 1496
          if (result != -1) {
            {
#line 1498
            aq___1 = next_append_slot();
#line 1499
            aq___1->free = (_Bool)1;
#line 1500
            aq___1->text = text;
#line 1501
            aq___1->textlen = (size_t )result;
            }
          }
        }
      }
#line 1504
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 1507
      do_subst(cur_cmd->x.cmd_subst);
      }
#line 1508
      goto switch_break;
      case_116: /* CIL Label */ 
#line 1511
      if (replaced) {
#line 1513
        replaced = (_Bool)0;
#line 1514
        cur_cmd = vec->v + cur_cmd->x.jump_index;
#line 1515
        goto while_continue;
      }
#line 1517
      goto switch_break;
      case_84: /* CIL Label */ 
#line 1520
      if (! replaced) {
#line 1522
        cur_cmd = vec->v + cur_cmd->x.jump_index;
#line 1523
        goto while_continue;
      } else {
#line 1526
        replaced = (_Bool)0;
      }
#line 1527
      goto switch_break;
      case_119: /* CIL Label */ 
#line 1530
      if (cur_cmd->x.fp) {
        {
#line 1531
        output_line((char const   *)line.active, line.length, (int )line.chomped,
                    cur_cmd->x.outf);
        }
      }
#line 1533
      goto switch_break;
      case_87: /* CIL Label */ 
#line 1536
      if (cur_cmd->x.fp) {
        {
#line 1538
        tmp___16 = memchr((void const   *)line.active, (int )buffer_delimiter, line.length);
#line 1538
        p___1 = (char *)tmp___16;
        }
#line 1539
        if (p___1) {
#line 1539
          tmp___17 = 1;
        } else {
#line 1539
          tmp___17 = (int )line.chomped;
        }
#line 1539
        if (p___1) {
#line 1539
          tmp___18 = (size_t )(p___1 - line.active);
        } else {
#line 1539
          tmp___18 = line.length;
        }
        {
#line 1539
        output_line((char const   *)line.active, tmp___18, tmp___17, cur_cmd->x.outf);
        }
      }
#line 1542
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 1546
      line_exchange(& line, & hold, 0);
      }
#line 1547
      goto switch_break;
      case_121: /* CIL Label */ 
#line 1550
      if (mb_cur_max > 1) {
        {
#line 1551
        translate_mb((char * const  *)cur_cmd->x.translatemb);
        }
      } else {
#line 1555
        p___2 = (unsigned char *)line.active;
#line 1556
        e = p___2 + line.length;
        {
#line 1556
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1556
          if (! ((unsigned long )p___2 < (unsigned long )e)) {
#line 1556
            goto while_break___1;
          }
#line 1557
          *p___2 = *(cur_cmd->x.translate + *p___2);
#line 1556
          p___2 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1559
      goto switch_break;
      case_122: /* CIL Label */ 
#line 1562
      line.length = (size_t )0;
#line 1563
      goto switch_break;
      case_61: /* CIL Label */ 
      {
#line 1566
      output_missing_newline(& output_file);
#line 1567
      fprintf((FILE */* __restrict  */)output_file.fp, (char const   */* __restrict  */)"%lu%c",
              input->line_number, (int )buffer_delimiter);
#line 1570
      flush_output(output_file.fp);
      }
#line 1571
      goto switch_break;
      case_70: /* CIL Label */ 
      {
#line 1574
      output_missing_newline(& output_file);
#line 1575
      fprintf((FILE */* __restrict  */)output_file.fp, (char const   */* __restrict  */)"%s%c",
              input->in_file_name, (int )buffer_delimiter);
#line 1578
      flush_output(output_file.fp);
      }
#line 1579
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1582
      panic("INTERNAL ERROR: Bad cmd %c", (int )cur_cmd->cmd);
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 1635
    cur_cmd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1638
  if (! no_default_output) {
    {
#line 1639
    output_line((char const   *)line.active, line.length, (int )line.chomped, & output_file);
    }
  }
#line 1640
  return (-1);
}
}
#line 1649 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static char dash[2]  = {      (char )'-',      (char )'\000'};
#line 1650 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
static char *stdin_argv[2]  = {      dash,      (char *)((void *)0)};
#line 1646 "/home/khheo/project/benchmark/sed-4.5/sed/execute.c"
int process_files(struct vector *the_program___0 , char **argv ) 
{ 
  struct input input ;
  int status ;
  char *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 1654
  line_init(& line, (struct line *)((void *)0), (size_t )50);
#line 1655
  line_init(& hold, (struct line *)((void *)0), (size_t )0);
#line 1656
  line_init(& buffer, (struct line *)((void *)0), (size_t )0);
#line 1661
  input.reset_at_next_file = (_Bool)1;
  }
#line 1662
  if (argv) {
#line 1662
    if (*argv) {
#line 1663
      input.file_list = argv;
    } else {
#line 1662
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1664
  if (in_place_extension) {
    {
#line 1665
    tmp = gettext("no input files");
#line 1665
    panic((char const   *)tmp);
    }
  } else {
#line 1667
    input.file_list = stdin_argv;
  }
#line 1669
  input.bad_count = (countT )0;
#line 1670
  input.line_number = (countT )0;
#line 1671
  input.read_fn = & read_always_fail;
#line 1672
  input.fp = (FILE *)((void *)0);
#line 1674
  status = 0;
  {
#line 1675
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1675
    tmp___0 = read_pattern_space(& input, the_program___0, 0);
    }
#line 1675
    if (! tmp___0) {
#line 1675
      goto while_break;
    }
    {
#line 1677
    status = execute_program(the_program___0, & input);
    }
#line 1678
    if (status == -1) {
#line 1679
      status = 0;
    } else {
#line 1681
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1683
  closedown(& input);
  }
#line 1698
  if (input.bad_count) {
#line 1699
    status = 2;
  }
#line 1701
  return (status);
}
}
#line 689 "/usr/include/stdio.h"
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 82 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 466 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strverscmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 80 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static FILE *my_stdin  ;
#line 80 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static FILE *my_stdout  ;
#line 80 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static FILE *my_stderr  ;
#line 81 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct special_files special_files[4]  = {      {{(char *)"/dev/stdin", (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      & my_stdin}, 
        {{(char *)"/dev/stdout", (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      & my_stdout}, 
        {{(char *)"/dev/stderr", (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      & my_stderr}, 
        {{(char *)((void *)0), (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      (FILE **)((void *)0)}};
#line 90 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct prog_info prog  ;
#line 91 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct error_info cur_input  ;
#line 95 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct sed_label *jumps  =    (struct sed_label *)((void *)0);
#line 96 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct sed_label *labels  =    (struct sed_label *)((void *)0);
#line 100 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static _Bool first_script  =    (_Bool)1;
#line 103 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct buffer *pending_text  =    (struct buffer *)((void *)0);
#line 104 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct text_buf *old_text_buf  =    (struct text_buf *)((void *)0);
#line 108 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct sed_label *blocks  =    (struct sed_label *)((void *)0);
#line 111 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct obstack obs  ;
#line 114 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static char const   errors___0[860]  = 
#line 114
  {      (char const   )'m',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )'i',      (char const   )'p',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'`',      (char const   )'!',      (char const   )'\'', 
        (char const   )'s',      (char const   )'\000',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'`',      (char const   )',',      (char const   )'\'', 
        (char const   )'\000',      (char const   )'i',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'+',      (char const   )'N', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'~',      (char const   )'N',      (char const   )' ',      (char const   )'a', 
        (char const   )'s',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'r',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000', 
        (char const   )'u',      (char const   )'n',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'`',      (char const   )'{', 
        (char const   )'\'',      (char const   )'\000',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'`',      (char const   )'}',      (char const   )'\'', 
        (char const   )'\000',      (char const   )'e',      (char const   )'x',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )' ',      (char const   )'c', 
        (char const   )'h',      (char const   )'a',      (char const   )'r',      (char const   )'a', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )' ',      (char const   )'a',      (char const   )'f', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'\000', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'\\',      (char const   )' ',      (char const   )'a', 
        (char const   )'f',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'`',      (char const   )'a',      (char const   )'\'', 
        (char const   )',',      (char const   )' ',      (char const   )'`',      (char const   )'c', 
        (char const   )'\'',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'`',      (char const   )'i',      (char const   )'\'', 
        (char const   )'\000',      (char const   )'`',      (char const   )'}',      (char const   )'\'', 
        (char const   )' ',      (char const   )'d',      (char const   )'o',      (char const   )'e', 
        (char const   )'s',      (char const   )'n',      (char const   )'\'',      (char const   )'t', 
        (char const   )' ',      (char const   )'w',      (char const   )'a',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'y',      (char const   )' ',      (char const   )'a',      (char const   )'d', 
        (char const   )'d',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'s',      (char const   )'e',      (char const   )'s',      (char const   )'\000', 
        (char const   )':',      (char const   )' ',      (char const   )'d',      (char const   )'o', 
        (char const   )'e',      (char const   )'s',      (char const   )'n',      (char const   )'\'', 
        (char const   )'t',      (char const   )' ',      (char const   )'w',      (char const   )'a', 
        (char const   )'n',      (char const   )'t',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'y',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'e',      (char const   )'s', 
        (char const   )'\000',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )'s',      (char const   )' ',      (char const   )'d',      (char const   )'o', 
        (char const   )'n',      (char const   )'\'',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'c',      (char const   )'c',      (char const   )'e', 
        (char const   )'p',      (char const   )'t',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'y',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'e',      (char const   )'s', 
        (char const   )'\000',      (char const   )'m',      (char const   )'i',      (char const   )'s', 
        (char const   )'s',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'\000',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )'l', 
        (char const   )'y',      (char const   )' ',      (char const   )'u',      (char const   )'s', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'o', 
        (char const   )'n',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'\000',      (char const   )'u', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'i',      (char const   )'n',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'e', 
        (char const   )'x',      (char const   )'\000',      (char const   )'u',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'m', 
        (char const   )'i',      (char const   )'n',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'`', 
        (char const   )'s',      (char const   )'\'',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'m',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )'\000',      (char const   )'u', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'i',      (char const   )'n',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'`',      (char const   )'y',      (char const   )'\'',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'\000', 
        (char const   )'u',      (char const   )'n',      (char const   )'k',      (char const   )'n', 
        (char const   )'o',      (char const   )'w',      (char const   )'n',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )'\000',      (char const   )'m',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'`', 
        (char const   )'p',      (char const   )'\'',      (char const   )' ',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'m',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'`', 
        (char const   )'g',      (char const   )'\'',      (char const   )' ',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'m',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'n', 
        (char const   )'u',      (char const   )'m',      (char const   )'b',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'`',      (char const   )'s',      (char const   )'\'', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'\000',      (char const   )'n',      (char const   )'u',      (char const   )'m', 
        (char const   )'b',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'b',      (char const   )'e', 
        (char const   )' ',      (char const   )'z',      (char const   )'e',      (char const   )'r', 
        (char const   )'o',      (char const   )'\000',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )'s',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'`',      (char const   )'y', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'f',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'l',      (char const   )'e',      (char const   )'n',      (char const   )'g', 
        (char const   )'t',      (char const   )'h',      (char const   )'s',      (char const   )'\000', 
        (char const   )'d',      (char const   )'e',      (char const   )'l',      (char const   )'i', 
        (char const   )'m',      (char const   )'i',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'n', 
        (char const   )'o',      (char const   )'t',      (char const   )' ',      (char const   )'a', 
        (char const   )' ',      (char const   )'s',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )'l',      (char const   )'e',      (char const   )'-', 
        (char const   )'b',      (char const   )'y',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'c',      (char const   )'h',      (char const   )'a', 
        (char const   )'r',      (char const   )'a',      (char const   )'c',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'\000',      (char const   )'e', 
        (char const   )'x',      (char const   )'p',      (char const   )'e',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'n',      (char const   )'e',      (char const   )'w',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'d', 
        (char const   )'\000',      (char const   )'i',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )' ',      (char const   )'0', 
        (char const   )'\000',      (char const   )'u',      (char const   )'n',      (char const   )'k', 
        (char const   )'n',      (char const   )'o',      (char const   )'w',      (char const   )'n', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )':',      (char const   )' ',      (char const   )'`',      (char const   )'%', 
        (char const   )'c',      (char const   )'\'',      (char const   )'\000',      (char const   )'i', 
        (char const   )'n',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'p',      (char const   )'l',      (char const   )'e',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'\"',      (char const   )':', 
        (char const   )'\"',      (char const   )' ',      (char const   )'l',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )' ', 
        (char const   )'a',      (char const   )' ',      (char const   )'l',      (char const   )'a', 
        (char const   )'b',      (char const   )'e',      (char const   )'l',      (char const   )'\000', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'u', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'s', 
        (char const   )'c',      (char const   )'a',      (char const   )'p',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )' ',      (char const   )'a', 
        (char const   )'f',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'\\',      (char const   )'c',      (char const   )' ', 
        (char const   )'n',      (char const   )'o',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'l',      (char const   )'l',      (char const   )'o', 
        (char const   )'w',      (char const   )'e',      (char const   )'d',      (char const   )'\000', 
        (char const   )'e',      (char const   )'/',      (char const   )'r',      (char const   )'/', 
        (char const   )'w',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'s',      (char const   )' ',      (char const   )'d', 
        (char const   )'i',      (char const   )'s',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'s', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'b', 
        (char const   )'o',      (char const   )'x',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'e',      (char const   )'\000'};
#line 194 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct output *file_read  =    (struct output *)((void *)0);
#line 195 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct output *file_write  =    (struct output *)((void *)0);
#line 199 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static void bad_command(char ch ) 
{ 
  char const   *msg ;
  char *tmp ;
  char *unknown_cmd ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 202
  tmp = gettext((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0"));
#line 202
  msg = (char const   *)tmp;
#line 203
  tmp___0 = strlen(msg);
#line 203
  tmp___1 = xmalloc(tmp___0);
#line 203
  unknown_cmd = (char *)tmp___1;
#line 204
  sprintf((char */* __restrict  */)unknown_cmd, (char const   */* __restrict  */)msg,
          (int )ch);
#line 205
  bad_prog((char const   *)unknown_cmd);
  }
#line 206
  return;
}
}
#line 209 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
void bad_prog(char const   *why ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 212
  if (cur_input.name) {
    {
#line 213
    tmp = gettext("%s: file %s line %lu: %s\n");
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            myname, cur_input.name, cur_input.line, why);
    }
  } else {
    {
#line 216
    tmp___0 = gettext("%s: -e expression #%lu, char %lu: %s\n");
#line 216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            myname, cur_input.string_expr_count, (unsigned long )(prog.cur - prog.base),
            why);
    }
  }
  {
#line 221
  exit(1);
  }
}
}
#line 228 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static int inchar(void) 
{ 
  int ch ;
  unsigned char const   *tmp ;
  int tmp___0 ;

  {
#line 231
  ch = -1;
#line 233
  if (prog.cur) {
#line 235
    if ((unsigned long )prog.cur < (unsigned long )prog.end) {
#line 236
      tmp = prog.cur;
#line 236
      (prog.cur) ++;
#line 236
      ch = (int )*tmp;
    }
  } else
#line 238
  if (prog.file) {
    {
#line 240
    tmp___0 = feof_unlocked(prog.file);
    }
#line 240
    if (! tmp___0) {
      {
#line 241
      ch = getc_unlocked(prog.file);
      }
    }
  }
#line 243
  if (ch == 10) {
#line 244
    (cur_input.line) ++;
  }
#line 245
  return (ch);
}
}
#line 249 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static void savchar(int ch ) 
{ 


  {
#line 252
  if (ch == -1) {
#line 253
    return;
  }
#line 254
  if (ch == 10) {
#line 254
    if (cur_input.line > 0UL) {
#line 255
      (cur_input.line) --;
    }
  }
#line 256
  if (prog.cur) {
#line 258
    if ((unsigned long )prog.cur <= (unsigned long )prog.base) {
      {
#line 259
      panic("Called savchar() with unexpected pushback (%x)", (unsigned int )ch);
      }
    } else {
#line 258
      (prog.cur) --;
#line 258
      if ((int const   )*(prog.cur) != (int const   )ch) {
        {
#line 259
        panic("Called savchar() with unexpected pushback (%x)", (unsigned int )ch);
        }
      }
    }
  } else {
    {
#line 263
    ungetc(ch, prog.file);
    }
  }
#line 264
  return;
}
}
#line 267 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static int in_nonblank(void) 
{ 
  int ch ;
  unsigned short const   **tmp ;

  {
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 272
    ch = inchar();
#line 271
    tmp = __ctype_b_loc();
    }
#line 271
    if (! ((int const   )*(*tmp + ch) & 1)) {
#line 271
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return (ch);
}
}
#line 282 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static void read_end_of_cmd(void) 
{ 
  int ch ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 285
  tmp = in_nonblank();
#line 285
  ch = tmp;
  }
#line 286
  if (ch == 125) {
    {
#line 287
    savchar(ch);
    }
  } else
#line 286
  if (ch == 35) {
    {
#line 287
    savchar(ch);
    }
  } else
#line 288
  if (ch != -1) {
#line 288
    if (ch != 10) {
#line 288
      if (ch != 59) {
        {
#line 289
        tmp___0 = gettext(((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'"));
#line 289
        bad_prog((char const   *)tmp___0);
        }
      }
    }
  }
#line 290
  return;
}
}
#line 293 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static countT in_integer(int ch ) 
{ 
  countT num ;
  unsigned short const   **tmp ;

  {
#line 296
  num = (countT )0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 298
    tmp = __ctype_b_loc();
    }
#line 298
    if (! ((int const   )*(*tmp + (int )((unsigned char )ch)) & 2048)) {
#line 298
      goto while_break;
    }
    {
#line 300
    num = (num * 10UL + (countT )ch) - 48UL;
#line 301
    ch = inchar();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 303
  savchar(ch);
  }
#line 304
  return (num);
}
}
#line 307 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static int add_then_next(struct buffer *b___0 , int ch ) 
{ 
  int tmp ;

  {
  {
#line 310
  add1_buffer(b___0, ch);
#line 311
  tmp = inchar();
  }
#line 311
  return (tmp);
}
}
#line 314 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static char *convert_number(char *result , char *buf , char const   *bufend , int base ) 
{ 
  int n ;
  int max ;
  char *p ;
  int d ;

  {
#line 317
  n = 0;
#line 318
  max = 1;
#line 321
  p = buf + 1;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if ((unsigned long )p < (unsigned long )bufend) {
#line 321
      if (! (max <= 255)) {
#line 321
        goto while_break;
      }
    } else {
#line 321
      goto while_break;
    }
#line 323
    d = -1;
    {
#line 326
    if ((int )*p == 48) {
#line 326
      goto case_48;
    }
#line 327
    if ((int )*p == 49) {
#line 327
      goto case_49;
    }
#line 328
    if ((int )*p == 50) {
#line 328
      goto case_50;
    }
#line 329
    if ((int )*p == 51) {
#line 329
      goto case_51;
    }
#line 330
    if ((int )*p == 52) {
#line 330
      goto case_52;
    }
#line 331
    if ((int )*p == 53) {
#line 331
      goto case_53;
    }
#line 332
    if ((int )*p == 54) {
#line 332
      goto case_54;
    }
#line 333
    if ((int )*p == 55) {
#line 333
      goto case_55;
    }
#line 334
    if ((int )*p == 56) {
#line 334
      goto case_56;
    }
#line 335
    if ((int )*p == 57) {
#line 335
      goto case_57;
    }
#line 336
    if ((int )*p == 97) {
#line 336
      goto case_97;
    }
#line 336
    if ((int )*p == 65) {
#line 336
      goto case_97;
    }
#line 337
    if ((int )*p == 98) {
#line 337
      goto case_98;
    }
#line 337
    if ((int )*p == 66) {
#line 337
      goto case_98;
    }
#line 338
    if ((int )*p == 99) {
#line 338
      goto case_99;
    }
#line 338
    if ((int )*p == 67) {
#line 338
      goto case_99;
    }
#line 339
    if ((int )*p == 100) {
#line 339
      goto case_100;
    }
#line 339
    if ((int )*p == 68) {
#line 339
      goto case_100;
    }
#line 340
    if ((int )*p == 101) {
#line 340
      goto case_101;
    }
#line 340
    if ((int )*p == 69) {
#line 340
      goto case_101;
    }
#line 341
    if ((int )*p == 102) {
#line 341
      goto case_102;
    }
#line 341
    if ((int )*p == 70) {
#line 341
      goto case_102;
    }
#line 324
    goto switch_break;
    case_48: /* CIL Label */ 
#line 326
    d = 0;
#line 326
    goto switch_break;
    case_49: /* CIL Label */ 
#line 327
    d = 1;
#line 327
    goto switch_break;
    case_50: /* CIL Label */ 
#line 328
    d = 2;
#line 328
    goto switch_break;
    case_51: /* CIL Label */ 
#line 329
    d = 3;
#line 329
    goto switch_break;
    case_52: /* CIL Label */ 
#line 330
    d = 4;
#line 330
    goto switch_break;
    case_53: /* CIL Label */ 
#line 331
    d = 5;
#line 331
    goto switch_break;
    case_54: /* CIL Label */ 
#line 332
    d = 6;
#line 332
    goto switch_break;
    case_55: /* CIL Label */ 
#line 333
    d = 7;
#line 333
    goto switch_break;
    case_56: /* CIL Label */ 
#line 334
    d = 8;
#line 334
    goto switch_break;
    case_57: /* CIL Label */ 
#line 335
    d = 9;
#line 335
    goto switch_break;
    case_97: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 336
    d = 10;
#line 336
    goto switch_break;
    case_98: /* CIL Label */ 
    case_66: /* CIL Label */ 
#line 337
    d = 11;
#line 337
    goto switch_break;
    case_99: /* CIL Label */ 
    case_67: /* CIL Label */ 
#line 338
    d = 12;
#line 338
    goto switch_break;
    case_100: /* CIL Label */ 
    case_68: /* CIL Label */ 
#line 339
    d = 13;
#line 339
    goto switch_break;
    case_101: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 340
    d = 14;
#line 340
    goto switch_break;
    case_102: /* CIL Label */ 
    case_70: /* CIL Label */ 
#line 341
    d = 15;
#line 341
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 343
    if (d < 0) {
#line 344
      goto while_break;
    } else
#line 343
    if (base <= d) {
#line 344
      goto while_break;
    }
#line 345
    n = n * base + d;
#line 321
    p ++;
#line 321
    max *= base;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  if ((unsigned long )p == (unsigned long )(buf + 1)) {
#line 348
    *result = *buf;
  } else {
#line 350
    *result = (char )n;
  }
#line 351
  return (p);
}
}
#line 356 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct buffer *read_filename(void) 
{ 
  struct buffer *b___0 ;
  int ch ;
  char *tmp ;

  {
#line 362
  if (sandbox) {
    {
#line 363
    tmp = gettext((((((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0")) + sizeof("unknown command: `%c\'")) + sizeof("incomplete command")) + sizeof("\":\" lacks a label")) + sizeof("recursive escaping after \\c not allowed"));
#line 363
    bad_prog((char const   *)tmp);
    }
  }
  {
#line 365
  b___0 = init_buffer();
#line 366
  ch = in_nonblank();
  }
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (ch != -1) {
#line 367
      if (! (ch != 10)) {
#line 367
        goto while_break;
      }
    } else {
#line 367
      goto while_break;
    }
    {
#line 377
    ch = add_then_next(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 379
  add1_buffer(b___0, '\000');
  }
#line 380
  return (b___0);
}
}
#line 383 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct output *get_openfile(struct output **file_ptrs , char const   *mode ,
                                   int fail ) 
{ 
  struct buffer *b___0 ;
  char *file_name___0 ;
  struct output *p ;
  int tmp ;
  struct special_files *special ;
  int tmp___0 ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 390
  b___0 = read_filename();
#line 391
  file_name___0 = get_buffer((struct buffer  const  *)b___0);
#line 392
  p = *file_ptrs;
  }
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! p) {
#line 392
      goto while_break;
    }
    {
#line 393
    tmp = strcmp((char const   *)p->name, (char const   *)file_name___0);
    }
#line 393
    if (tmp == 0) {
#line 394
      goto while_break;
    }
#line 392
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  if ((unsigned int )posixicity == 0U) {
#line 399
    special = special_files;
#line 403
    my_stdin = stdin;
#line 403
    my_stdout = stdout;
#line 403
    my_stderr = stderr;
#line 404
    special = special_files;
    {
#line 404
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 404
      if (! special->outf.name) {
#line 404
        goto while_break___0;
      }
      {
#line 405
      tmp___0 = strcmp((char const   *)special->outf.name, (char const   *)file_name___0);
      }
#line 405
      if (tmp___0 == 0) {
        {
#line 407
        special->outf.fp = *(special->pfp);
#line 408
        free_buffer(b___0);
        }
#line 409
        return (& special->outf);
      }
#line 404
      special ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 413
  if (! p) {
#line 415
    __h = & obs;
#line 415
    __o = __h;
#line 415
    __len = sizeof(struct output );
#line 415
    __o1 = (struct obstack  const  *)__o;
#line 415
    if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
      {
#line 415
      _obstack_newchunk(__o, __len);
      }
    }
#line 415
    __o->next_free += __len;
#line 415
    __o1___0 = __h;
#line 415
    __value = (void *)__o1___0->object_base;
#line 415
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 415
      __o1___0->maybe_empty_object = 1U;
    }
#line 415
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 415
      tmp___1 = __o1___0->object_base;
    } else {
#line 415
      tmp___1 = (char *)0;
    }
#line 415
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 415
      tmp___2 = __o1___0->object_base;
    } else {
#line 415
      tmp___2 = (char *)0;
    }
#line 415
    __o1___0->next_free = tmp___1 + (((size_t )(__o1___0->next_free - tmp___2) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 415
    if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 415
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 415
    __o1___0->object_base = __o1___0->next_free;
#line 415
    p = (struct output *)__value;
#line 416
    p->name = ck_strdup((char const   *)file_name___0);
#line 417
    p->fp = ck_fopen((char const   *)p->name, mode, fail);
#line 418
    p->missing_newline = (_Bool)0;
#line 419
    p->link = *file_ptrs;
#line 420
    *file_ptrs = p;
    }
  }
  {
#line 422
  free_buffer(b___0);
  }
#line 423
  return (p);
}
}
#line 427 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct sed_cmd *next_cmd_entry(struct vector **vectorp ) 
{ 
  struct sed_cmd *cmd ;
  struct vector *v ;
  void *tmp ;

  {
#line 433
  v = *vectorp;
#line 434
  if (v->v_length == v->v_allocated) {
    {
#line 436
    v->v_allocated += 40UL;
#line 437
    tmp = ck_realloc((void *)v->v, v->v_allocated * sizeof(struct sed_cmd ));
#line 437
    v->v = (struct sed_cmd *)tmp;
    }
  }
#line 440
  cmd = v->v + v->v_length;
#line 441
  cmd->a1 = (struct addr *)((void *)0);
#line 442
  cmd->a2 = (struct addr *)((void *)0);
#line 443
  cmd->range_state = (enum addr_state )0;
#line 444
  cmd->addr_bang = (char)0;
#line 445
  cmd->cmd = (char )'\000';
#line 447
  *vectorp = v;
#line 448
  return (cmd);
}
}
#line 451 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static int snarf_char_class(struct buffer *b___0 , mbstate_t *cur_stat ) 
{ 
  int ch ;
  int state ;
  int delim ;
  int mb_char ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 455
  state = 0;
#line 458
  ch = inchar();
  }
#line 459
  if (ch == 94) {
    {
#line 460
    ch = add_then_next(b___0, ch);
    }
  }
#line 461
  if (ch == 93) {
    {
#line 462
    ch = add_then_next(b___0, ch);
    }
  }
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (mb_cur_max == 1) {
#line 472
      tmp___0 = 0;
    } else {
      {
#line 472
      tmp = is_mb_char(ch, cur_stat);
#line 472
      tmp___0 = tmp;
      }
    }
#line 472
    mb_char = tmp___0;
    {
#line 477
    if (ch == 10) {
#line 477
      goto case_10;
    }
#line 477
    if (ch == -1) {
#line 477
      goto case_10;
    }
#line 482
    if (ch == 61) {
#line 482
      goto case_61;
    }
#line 482
    if (ch == 58) {
#line 482
      goto case_61;
    }
#line 482
    if (ch == 46) {
#line 482
      goto case_61;
    }
#line 498
    if (ch == 91) {
#line 498
      goto case_91;
    }
#line 506
    if (ch == 93) {
#line 506
      goto case_93;
    }
#line 517
    goto switch_default;
    case_10: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 478
    return (ch);
    case_61: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 483
    if (mb_char) {
#line 484
      goto __Cont;
    }
#line 486
    if (state == 1) {
#line 488
      delim = ch;
#line 489
      state = 2;
    } else
#line 491
    if (state == 2) {
#line 491
      if (ch == delim) {
#line 492
        state = 3;
      } else {
#line 494
        goto switch_break;
      }
    } else {
#line 494
      goto switch_break;
    }
#line 496
    goto __Cont;
    case_91: /* CIL Label */ 
#line 499
    if (mb_char) {
#line 500
      goto __Cont;
    }
#line 502
    if (state == 0) {
#line 503
      state = 1;
    }
#line 504
    goto __Cont;
    case_93: /* CIL Label */ 
#line 507
    if (mb_char) {
#line 508
      goto __Cont;
    }
#line 510
    if (state == 0) {
#line 511
      return (ch);
    } else
#line 510
    if (state == 1) {
#line 511
      return (ch);
    } else
#line 512
    if (state == 3) {
#line 513
      state = 0;
    }
#line 515
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 518
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 524
    state &= -2;
    __Cont: /* CIL Label */ 
    {
#line 470
    ch = add_then_next(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 528 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct buffer *match_slash(int slash , int regex ) 
{ 
  struct buffer *b___0 ;
  int ch ;
  mbstate_t cur_stat ;
  int tmp ;
  int tmp___0 ;
  int mb_char ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 533
  cur_stat.__count = 0;
#line 533
  cur_stat.__value.__wch = 0U;
#line 536
  if (mb_cur_max == 1) {
#line 536
    tmp___0 = 0;
  } else {
    {
#line 536
    tmp = is_mb_char(slash, & cur_stat);
#line 536
    tmp___0 = tmp;
    }
  }
#line 536
  if (tmp___0) {
    {
#line 537
    bad_prog(((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths"));
    }
  }
  {
#line 539
  memset((void *)(& cur_stat), 0, sizeof(cur_stat));
#line 541
  b___0 = init_buffer();
  }
  {
#line 542
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 542
    ch = inchar();
    }
#line 542
    if (ch != -1) {
#line 542
      if (! (ch != 10)) {
#line 542
        goto while_break;
      }
    } else {
#line 542
      goto while_break;
    }
#line 544
    if (mb_cur_max == 1) {
#line 544
      tmp___2 = 0;
    } else {
      {
#line 544
      tmp___1 = is_mb_char(ch, & cur_stat);
#line 544
      tmp___2 = tmp___1;
      }
    }
#line 544
    mb_char = tmp___2;
#line 546
    if (! mb_char) {
#line 548
      if (ch == slash) {
#line 549
        return (b___0);
      } else
#line 550
      if (ch == 92) {
        {
#line 552
        ch = inchar();
        }
#line 553
        if (ch == -1) {
#line 554
          goto while_break;
        } else
#line 556
        if (ch == 110) {
#line 556
          if (regex) {
#line 557
            ch = '\n';
          } else {
#line 556
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 559
        if (ch != 10) {
#line 559
          if (ch != slash) {
            {
#line 560
            add1_buffer(b___0, '\\');
            }
          } else
#line 559
          if (! regex) {
#line 559
            if (ch == 38) {
              {
#line 560
              add1_buffer(b___0, '\\');
              }
            }
          }
        }
      } else
#line 562
      if (ch == 91) {
#line 562
        if (regex) {
          {
#line 564
          add1_buffer(b___0, ch);
#line 565
          ch = snarf_char_class(b___0, & cur_stat);
          }
#line 566
          if (ch != 93) {
#line 567
            goto while_break;
          }
        }
      }
    }
    {
#line 571
    add1_buffer(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  if (ch == 10) {
    {
#line 575
    savchar(ch);
    }
  }
  {
#line 576
  free_buffer(b___0);
  }
#line 577
  return ((struct buffer *)((void *)0));
}
}
#line 580 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static int mark_subst_opts(struct subst *cmd ) 
{ 
  int flags ;
  int ch ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 583
  flags = 0;
#line 586
  cmd->global = 0U;
#line 587
  cmd->print = 0U;
#line 588
  cmd->eval = 0U;
#line 589
  cmd->numb = (countT )0;
#line 590
  cmd->outf = (struct output *)((void *)0);
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 593
    ch = in_nonblank();
    }
    {
#line 596
    if (ch == 73) {
#line 596
      goto case_73;
    }
#line 596
    if (ch == 105) {
#line 596
      goto case_73;
    }
#line 621
    if (ch == 77) {
#line 621
      goto case_77;
    }
#line 621
    if (ch == 109) {
#line 621
      goto case_77;
    }
#line 627
    if (ch == 101) {
#line 627
      goto case_101;
    }
#line 633
    if (ch == 112) {
#line 633
      goto case_112;
    }
#line 639
    if (ch == 103) {
#line 639
      goto case_103;
    }
#line 645
    if (ch == 119) {
#line 645
      goto case_119;
    }
#line 650
    if (ch == 57) {
#line 650
      goto case_57;
    }
#line 650
    if (ch == 56) {
#line 650
      goto case_57;
    }
#line 650
    if (ch == 55) {
#line 650
      goto case_57;
    }
#line 650
    if (ch == 54) {
#line 650
      goto case_57;
    }
#line 650
    if (ch == 53) {
#line 650
      goto case_57;
    }
#line 650
    if (ch == 52) {
#line 650
      goto case_57;
    }
#line 650
    if (ch == 51) {
#line 650
      goto case_57;
    }
#line 650
    if (ch == 50) {
#line 650
      goto case_57;
    }
#line 650
    if (ch == 49) {
#line 650
      goto case_57;
    }
#line 650
    if (ch == 48) {
#line 650
      goto case_57;
    }
#line 659
    if (ch == 35) {
#line 659
      goto case_35;
    }
#line 659
    if (ch == 125) {
#line 659
      goto case_35;
    }
#line 664
    if (ch == 59) {
#line 664
      goto case_59;
    }
#line 664
    if (ch == 10) {
#line 664
      goto case_59;
    }
#line 664
    if (ch == -1) {
#line 664
      goto case_59;
    }
#line 667
    if (ch == 13) {
#line 667
      goto case_13;
    }
#line 672
    goto switch_default;
    case_73: /* CIL Label */ 
    case_105: /* CIL Label */ 
#line 597
    if ((unsigned int )posixicity == 2U) {
      {
#line 598
      tmp = gettext(((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command"));
#line 598
      bad_prog((char const   *)tmp);
      }
    }
#line 599
    flags |= 1 << 1;
#line 600
    goto switch_break;
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
#line 622
    if ((unsigned int )posixicity == 2U) {
      {
#line 623
      tmp___0 = gettext(((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command"));
#line 623
      bad_prog((char const   *)tmp___0);
      }
    }
#line 624
    flags |= 1 << 2;
#line 625
    goto switch_break;
    case_101: /* CIL Label */ 
#line 628
    if ((unsigned int )posixicity == 2U) {
      {
#line 629
      tmp___1 = gettext(((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command"));
#line 629
      bad_prog((char const   *)tmp___1);
      }
    }
#line 630
    cmd->eval = 1U;
#line 631
    goto switch_break;
    case_112: /* CIL Label */ 
#line 634
    if (cmd->print) {
      {
#line 635
      tmp___2 = gettext((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'"));
#line 635
      bad_prog((char const   *)tmp___2);
      }
    }
#line 636
    cmd->print |= (unsigned int )(1 << cmd->eval);
#line 637
    goto switch_break;
    case_103: /* CIL Label */ 
#line 640
    if (cmd->global) {
      {
#line 641
      tmp___3 = gettext(((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command"));
#line 641
      bad_prog((char const   *)tmp___3);
      }
    }
#line 642
    cmd->global = 1U;
#line 643
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 646
    cmd->outf = get_openfile(& file_write, write_mode, 1);
    }
#line 647
    return (flags);
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 651
    if (cmd->numb) {
      {
#line 652
      tmp___4 = gettext((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command"));
#line 652
      bad_prog((char const   *)tmp___4);
      }
    }
    {
#line 653
    cmd->numb = in_integer(ch);
    }
#line 654
    if (! cmd->numb) {
      {
#line 655
      tmp___5 = gettext(((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command"));
#line 655
      bad_prog((char const   *)tmp___5);
      }
    }
#line 656
    goto switch_break;
    case_35: /* CIL Label */ 
    case_125: /* CIL Label */ 
    {
#line 660
    savchar(ch);
    }
    case_59: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 665
    return (flags);
    case_13: /* CIL Label */ 
    {
#line 668
    tmp___6 = inchar();
    }
#line 668
    if (tmp___6 == 10) {
#line 669
      return (flags);
    }
    switch_default: /* CIL Label */ 
    {
#line 673
    tmp___7 = gettext(((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command"));
#line 673
    bad_prog((char const   *)tmp___7);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 680 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static char *read_label(void) 
{ 
  struct buffer *b___0 ;
  int ch ;
  char *ret ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
  {
#line 687
  b___0 = init_buffer();
#line 688
  ch = in_nonblank();
  }
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 690
    if (ch != -1) {
#line 690
      if (ch != 10) {
        {
#line 690
        tmp = __ctype_b_loc();
        }
#line 690
        if ((int const   )*(*tmp + ch) & 1) {
#line 690
          goto while_break;
        } else
#line 690
        if (ch != 59) {
#line 690
          if (ch != 125) {
#line 690
            if (! (ch != 35)) {
#line 690
              goto while_break;
            }
          } else {
#line 690
            goto while_break;
          }
        } else {
#line 690
          goto while_break;
        }
      } else {
#line 690
        goto while_break;
      }
    } else {
#line 690
      goto while_break;
    }
    {
#line 692
    ch = add_then_next(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 694
  savchar(ch);
#line 695
  add1_buffer(b___0, '\000');
#line 696
  tmp___0 = get_buffer((struct buffer  const  *)b___0);
#line 696
  ret = ck_strdup((char const   *)tmp___0);
#line 697
  free_buffer(b___0);
  }
#line 698
  return (ret);
}
}
#line 705 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct sed_label *setup_label(struct sed_label *list , countT idx , char *name ,
                                     struct error_info  const  *err_info ) 
{ 
  struct sed_label *ret ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 709
  __h = & obs;
#line 709
  __o = __h;
#line 709
  __len = sizeof(struct sed_label );
#line 709
  __o1 = (struct obstack  const  *)__o;
#line 709
  if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
    {
#line 709
    _obstack_newchunk(__o, __len);
    }
  }
#line 709
  __o->next_free += __len;
#line 709
  __o1___0 = __h;
#line 709
  __value = (void *)__o1___0->object_base;
#line 709
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 709
    __o1___0->maybe_empty_object = 1U;
  }
#line 709
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 709
    tmp = __o1___0->object_base;
  } else {
#line 709
    tmp = (char *)0;
  }
#line 709
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 709
    tmp___0 = __o1___0->object_base;
  } else {
#line 709
    tmp___0 = (char *)0;
  }
#line 709
  __o1___0->next_free = tmp + (((size_t )(__o1___0->next_free - tmp___0) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 709
  if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 709
    __o1___0->next_free = __o1___0->chunk_limit;
  }
#line 709
  __o1___0->object_base = __o1___0->next_free;
#line 709
  ret = (struct sed_label *)__value;
#line 710
  ret->v_index = idx;
#line 711
  ret->name = name;
#line 712
  if (err_info) {
    {
#line 713
    memcpy((void */* __restrict  */)(& ret->err_info), (void const   */* __restrict  */)err_info,
           sizeof(ret->err_info));
    }
  }
#line 714
  ret->next = list;
#line 715
  return (ret);
}
}
#line 718 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct sed_label *release_label(struct sed_label *list_head ) 
{ 
  struct sed_label *ret ;

  {
#line 723
  if (! list_head) {
#line 724
    return ((struct sed_label *)((void *)0));
  }
  {
#line 725
  ret = list_head->next;
#line 727
  free((void *)list_head->name);
  }
#line 733
  return (ret);
}
}
#line 736 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct replacement *new_replacement(char *text , size_t length , enum replacement_types type ) 
{ 
  struct replacement *r ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 739
  __h = & obs;
#line 739
  __o = __h;
#line 739
  __len = sizeof(struct replacement );
#line 739
  __o1 = (struct obstack  const  *)__o;
#line 739
  if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
    {
#line 739
    _obstack_newchunk(__o, __len);
    }
  }
#line 739
  __o->next_free += __len;
#line 739
  __o1___0 = __h;
#line 739
  __value = (void *)__o1___0->object_base;
#line 739
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 739
    __o1___0->maybe_empty_object = 1U;
  }
#line 739
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 739
    tmp = __o1___0->object_base;
  } else {
#line 739
    tmp = (char *)0;
  }
#line 739
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 739
    tmp___0 = __o1___0->object_base;
  } else {
#line 739
    tmp___0 = (char *)0;
  }
#line 739
  __o1___0->next_free = tmp + (((size_t )(__o1___0->next_free - tmp___0) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 739
  if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 739
    __o1___0->next_free = __o1___0->chunk_limit;
  }
#line 739
  __o1___0->object_base = __o1___0->next_free;
#line 739
  r = (struct replacement *)__value;
#line 741
  r->prefix = text;
#line 742
  r->prefix_length = length;
#line 743
  r->subst_id = -1;
#line 744
  r->repl_type = type;
#line 747
  return (r);
}
}
#line 750 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static void setup_replacement(struct subst *sub , char const   *text , size_t length ) 
{ 
  char *base ;
  char *p ;
  char *text_end ;
  enum replacement_types repl_type ;
  enum replacement_types save_type ;
  struct replacement root ;
  struct replacement *tail ;
  void *tmp ;
  struct replacement *tmp___0 ;
  unsigned short const   **tmp___1 ;
  struct replacement *tmp___2 ;
  struct replacement *tmp___3 ;

  {
  {
#line 756
  repl_type = (enum replacement_types )0;
#line 756
  save_type = (enum replacement_types )0;
#line 760
  sub->max_id = 0U;
#line 761
  tmp = ck_memdup((void const   *)((void *)text), length * sizeof(char ));
#line 761
  base = (char *)tmp;
#line 762
  length = normalize_text(base, length, (enum text_types )1);
#line 764
  text_end = base + length;
#line 765
  tail = & root;
#line 767
  p = base;
  }
  {
#line 767
  while (1) {
    while_continue: /* CIL Label */ ;
#line 767
    if (! ((unsigned long )p < (unsigned long )text_end)) {
#line 767
      goto while_break;
    }
#line 769
    if ((int )*p == 92) {
      {
#line 772
      tmp___0 = new_replacement(base, (size_t )(p - base), repl_type);
#line 772
      tail->next = tmp___0;
#line 772
      tail = tmp___0;
#line 775
      repl_type = save_type;
#line 779
      p ++;
      }
#line 780
      if ((unsigned long )p == (unsigned long )text_end) {
#line 781
        (tail->prefix_length) ++;
      } else
#line 783
      if ((unsigned int )posixicity == 2U) {
        {
#line 783
        tmp___1 = __ctype_b_loc();
        }
#line 783
        if ((int const   )*(*tmp___1 + (int )((unsigned char )*p)) & 2048) {
#line 783
          goto _L;
        } else {
#line 785
          *(p + -1) = *p;
#line 786
          (tail->prefix_length) ++;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 793
        if ((int )*p == 57) {
#line 793
          goto case_57;
        }
#line 793
        if ((int )*p == 56) {
#line 793
          goto case_57;
        }
#line 793
        if ((int )*p == 55) {
#line 793
          goto case_57;
        }
#line 793
        if ((int )*p == 54) {
#line 793
          goto case_57;
        }
#line 793
        if ((int )*p == 53) {
#line 793
          goto case_57;
        }
#line 793
        if ((int )*p == 52) {
#line 793
          goto case_57;
        }
#line 793
        if ((int )*p == 51) {
#line 793
          goto case_57;
        }
#line 793
        if ((int )*p == 50) {
#line 793
          goto case_57;
        }
#line 793
        if ((int )*p == 49) {
#line 793
          goto case_57;
        }
#line 793
        if ((int )*p == 48) {
#line 793
          goto case_57;
        }
#line 799
        if ((int )*p == 76) {
#line 799
          goto case_76;
        }
#line 804
        if ((int )*p == 85) {
#line 804
          goto case_85;
        }
#line 809
        if ((int )*p == 69) {
#line 809
          goto case_69;
        }
#line 814
        if ((int )*p == 108) {
#line 814
          goto case_108;
        }
#line 819
        if ((int )*p == 117) {
#line 819
          goto case_117;
        }
#line 824
        goto switch_default;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 794
        tail->subst_id = (int )*p - 48;
#line 795
        if (sub->max_id < (unsigned int )tail->subst_id) {
#line 796
          sub->max_id = (unsigned int )tail->subst_id;
        }
#line 797
        goto switch_break;
        case_76: /* CIL Label */ 
#line 800
        repl_type = (enum replacement_types )2;
#line 801
        save_type = (enum replacement_types )2;
#line 802
        goto switch_break;
        case_85: /* CIL Label */ 
#line 805
        repl_type = (enum replacement_types )1;
#line 806
        save_type = (enum replacement_types )1;
#line 807
        goto switch_break;
        case_69: /* CIL Label */ 
#line 810
        repl_type = (enum replacement_types )0;
#line 811
        save_type = (enum replacement_types )0;
#line 812
        goto switch_break;
        case_108: /* CIL Label */ 
#line 815
        save_type = repl_type;
#line 816
        repl_type = (enum replacement_types )((unsigned int )repl_type | 8U);
#line 817
        goto switch_break;
        case_117: /* CIL Label */ 
#line 820
        save_type = repl_type;
#line 821
        repl_type = (enum replacement_types )((unsigned int )repl_type | 4U);
#line 822
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 825
        *(p + -1) = *p;
#line 826
        (tail->prefix_length) ++;
        switch_break: /* CIL Label */ ;
        }
      }
#line 829
      base = p + 1;
    } else
#line 831
    if ((int )*p == 38) {
      {
#line 834
      tmp___2 = new_replacement(base, (size_t )(p - base), repl_type);
#line 834
      tail->next = tmp___2;
#line 834
      tail = tmp___2;
#line 837
      repl_type = save_type;
#line 838
      tail->subst_id = 0;
#line 839
      base = p + 1;
      }
    }
#line 767
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 843
  if ((unsigned long )base < (unsigned long )text_end) {
    {
#line 844
    tmp___3 = new_replacement(base, (size_t )(text_end - base), repl_type);
#line 844
    tail->next = tmp___3;
#line 844
    tail = tmp___3;
    }
  }
#line 847
  tail->next = (struct replacement *)((void *)0);
#line 848
  sub->replacement = root.next;
#line 849
  return;
}
}
#line 851 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static void read_text(struct text_buf *buf , int leadin_ch ) 
{ 
  int ch ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
#line 857
  if (buf) {
#line 859
    if (pending_text) {
      {
#line 860
      free_buffer(pending_text);
      }
    }
    {
#line 861
    pending_text = init_buffer();
#line 862
    buf->text = (char *)((void *)0);
#line 863
    buf->text_length = (size_t )0;
#line 864
    old_text_buf = buf;
    }
  }
#line 868
  if (leadin_ch == -1) {
#line 869
    return;
  }
#line 871
  if (leadin_ch != 10) {
    {
#line 872
    add1_buffer(pending_text, leadin_ch);
    }
  }
  {
#line 874
  ch = inchar();
  }
  {
#line 875
  while (1) {
    while_continue: /* CIL Label */ ;
#line 875
    if (ch != -1) {
#line 875
      if (! (ch != 10)) {
#line 875
        goto while_break;
      }
    } else {
#line 875
      goto while_break;
    }
#line 877
    if (ch == 92) {
      {
#line 879
      ch = inchar();
      }
#line 880
      if (ch != -1) {
        {
#line 881
        add1_buffer(pending_text, '\\');
        }
      }
    }
#line 884
    if (ch == -1) {
      {
#line 886
      add1_buffer(pending_text, '\n');
      }
#line 887
      return;
    }
    {
#line 890
    ch = add_then_next(pending_text, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 893
  add1_buffer(pending_text, '\n');
  }
#line 894
  if (! buf) {
#line 895
    buf = old_text_buf;
  }
  {
#line 896
  tmp = size_buffer((struct buffer  const  *)pending_text);
#line 896
  tmp___0 = get_buffer((struct buffer  const  *)pending_text);
#line 896
  buf->text_length = normalize_text(tmp___0, tmp, (enum text_types )0);
#line 898
  tmp___1 = get_buffer((struct buffer  const  *)pending_text);
#line 898
  tmp___2 = ck_memdup((void const   *)((void *)tmp___1), buf->text_length * sizeof(char ));
#line 898
  buf->text = (char *)tmp___2;
#line 899
  free_buffer(pending_text);
#line 900
  pending_text = (struct buffer *)((void *)0);
  }
#line 901
  return;
}
}
#line 908 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static _Bool compile_address(struct addr *addr , int ch ) 
{ 
  int flags ;
  struct buffer *b___0 ;
  char *tmp ;
  countT step ;
  int tmp___0 ;
  countT tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 911
  addr->addr_type = (enum addr_types )0;
#line 912
  addr->addr_step = (countT )0;
#line 913
  addr->addr_number = ~ ((countT )0);
#line 914
  addr->addr_regex = (struct regex *)((void *)0);
#line 916
  if (ch == 47) {
#line 916
    goto _L___1;
  } else
#line 916
  if (ch == 92) {
    _L___1: /* CIL Label */ 
#line 918
    flags = 0;
#line 920
    addr->addr_type = (enum addr_types )1;
#line 921
    if (ch == 92) {
      {
#line 922
      ch = inchar();
      }
    }
    {
#line 923
    b___0 = match_slash(ch, 1);
    }
#line 923
    if (! b___0) {
      {
#line 924
      tmp = gettext((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address"));
#line 924
      bad_prog((char const   *)tmp);
      }
    }
    {
#line 926
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 928
      ch = in_nonblank();
      }
#line 929
      if ((unsigned int )posixicity == 2U) {
#line 930
        goto posix_address_modifier;
      }
      {
#line 933
      if (ch == 73) {
#line 933
        goto case_73;
      }
#line 949
      if (ch == 77) {
#line 949
        goto case_77;
      }
#line 953
      goto posix_address_modifier;
      case_73: /* CIL Label */ 
#line 934
      flags |= 1 << 1;
#line 935
      goto switch_break;
      case_77: /* CIL Label */ 
#line 950
      flags |= 1 << 2;
#line 951
      goto switch_break;
      posix_address_modifier: 
      switch_default: /* CIL Label */ 
      {
#line 955
      savchar(ch);
#line 956
      addr->addr_regex = compile_regex(b___0, flags, 0);
#line 957
      free_buffer(b___0);
      }
#line 958
      return ((_Bool)1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 962
    tmp___3 = __ctype_b_loc();
    }
#line 962
    if ((int const   )*(*tmp___3 + (int )((unsigned char )ch)) & 2048) {
      {
#line 964
      addr->addr_number = in_integer(ch);
#line 965
      addr->addr_type = (enum addr_types )2;
#line 966
      ch = in_nonblank();
      }
#line 967
      if (ch != 126) {
        {
#line 969
        savchar(ch);
        }
      } else
#line 967
      if ((unsigned int )posixicity == 2U) {
        {
#line 969
        savchar(ch);
        }
      } else {
        {
#line 973
        tmp___0 = in_nonblank();
#line 973
        tmp___1 = in_integer(tmp___0);
#line 973
        step = tmp___1;
        }
#line 974
        if (step > 0UL) {
#line 976
          addr->addr_step = step;
#line 977
          addr->addr_type = (enum addr_types )3;
        }
      }
    } else
#line 981
    if (ch == 43) {
#line 981
      goto _L___0;
    } else
#line 981
    if (ch == 126) {
      _L___0: /* CIL Label */ 
#line 981
      if ((unsigned int )posixicity != 2U) {
        {
#line 983
        tmp___2 = in_nonblank();
#line 983
        addr->addr_step = in_integer(tmp___2);
        }
#line 984
        if (! (addr->addr_step == 0UL)) {
#line 986
          if (ch == 43) {
#line 987
            addr->addr_type = (enum addr_types )4;
          } else {
#line 989
            addr->addr_type = (enum addr_types )5;
          }
        }
      } else {
#line 981
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 991
    if (ch == 36) {
#line 993
      addr->addr_type = (enum addr_types )6;
    } else {
#line 996
      return ((_Bool)0);
    }
  }
#line 998
  return ((_Bool)1);
}
}
#line 1003 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static struct vector *compile_program(struct vector *vector ) 
{ 
  struct sed_cmd *cur_cmd ;
  struct buffer *b___0 ;
  int ch ;
  void *tmp ;
  struct addr a ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  long tmp___12 ;
  char *version ;
  char *tmp___13 ;
  char const   *compared_version ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *label ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  countT tmp___26 ;
  unsigned short const   **tmp___27 ;
  char *tmp___28 ;
  struct output *tmp___29 ;
  struct buffer *b2 ;
  int flags ;
  int slash ;
  char *tmp___30 ;
  char *tmp___31 ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___32 ;
  char *tmp___33 ;
  size_t tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  size_t len ;
  size_t dest_len ;
  int slash___0 ;
  struct buffer *b2___0 ;
  char *src_buf ;
  char *dest_buf ;
  char *tmp___37 ;
  size_t tmp___38 ;
  char *tmp___39 ;
  size_t tmp___40 ;
  size_t i ;
  size_t j ;
  size_t idx ;
  size_t src_char_num ;
  size_t *src_lens ;
  void *tmp___41 ;
  char **trans_pairs ;
  size_t mbclen ;
  mbstate_t cur_stat ;
  size_t tmp___42 ;
  size_t tmp___43 ;
  void *tmp___44 ;
  char *tmp___45 ;
  void *tmp___46 ;
  size_t tmp___47 ;
  void *tmp___48 ;
  char *tmp___49 ;
  unsigned char *translate ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  size_t __len___0 ;
  struct obstack  const  *__o1___1 ;
  struct obstack *__o1___2 ;
  void *__value___0 ;
  char *tmp___50 ;
  char *tmp___51 ;
  unsigned char *ustring ;
  char *tmp___52 ;
  unsigned char *tmp___53 ;
  char *tmp___54 ;
  size_t tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;

  {
#line 1010
  if (! vector) {
    {
#line 1012
    tmp = ck_malloc(sizeof(struct vector ));
#line 1012
    vector = (struct vector *)tmp;
#line 1013
    vector->v = (struct sed_cmd *)((void *)0);
#line 1014
    vector->v_allocated = (size_t )0;
#line 1015
    vector->v_length = (size_t )0;
#line 1017
    _obstack_begin(& obs, (size_t )0, (size_t )0, & ck_malloc, (void (*)(void * ))(& free));
    }
  }
#line 1019
  if (pending_text) {
    {
#line 1020
    read_text((struct text_buf *)((void *)0), '\n');
    }
  }
  {
#line 1022
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1026
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1026
      ch = inchar();
      }
#line 1026
      if (! (ch == 59)) {
        {
#line 1026
        tmp___0 = __ctype_b_loc();
        }
#line 1026
        if (! ((int const   )*(*tmp___0 + ch) & 8192)) {
#line 1026
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1028
    if (ch == -1) {
#line 1029
      goto while_break;
    }
    {
#line 1031
    cur_cmd = next_cmd_entry(& vector);
#line 1032
    tmp___8 = compile_address(& a, ch);
    }
#line 1032
    if (tmp___8) {
#line 1034
      if ((unsigned int )a.addr_type == 4U) {
        {
#line 1036
        tmp___1 = gettext((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'"));
#line 1036
        bad_prog((char const   *)tmp___1);
        }
      } else
#line 1034
      if ((unsigned int )a.addr_type == 5U) {
        {
#line 1036
        tmp___1 = gettext((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'"));
#line 1036
        bad_prog((char const   *)tmp___1);
        }
      }
      {
#line 1038
      tmp___2 = ck_memdup((void const   *)((void *)(& a)), sizeof(struct addr ));
#line 1038
      cur_cmd->a1 = (struct addr *)tmp___2;
#line 1039
      ch = in_nonblank();
      }
#line 1040
      if (ch == 44) {
        {
#line 1042
        tmp___4 = in_nonblank();
#line 1042
        tmp___5 = compile_address(& a, tmp___4);
        }
#line 1042
        if (! tmp___5) {
          {
#line 1043
          tmp___3 = gettext(errors___0 + sizeof("multiple `!\'s"));
#line 1043
          bad_prog((char const   *)tmp___3);
          }
        }
        {
#line 1045
        tmp___6 = ck_memdup((void const   *)((void *)(& a)), sizeof(struct addr ));
#line 1045
        cur_cmd->a2 = (struct addr *)tmp___6;
#line 1046
        ch = in_nonblank();
        }
      }
#line 1049
      if ((unsigned int )(cur_cmd->a1)->addr_type == 2U) {
#line 1049
        if ((cur_cmd->a1)->addr_number == 0UL) {
#line 1049
          if (! cur_cmd->a2) {
            {
#line 1053
            tmp___7 = gettext(((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed"));
#line 1053
            bad_prog((char const   *)tmp___7);
            }
          } else
#line 1049
          if ((unsigned int )(cur_cmd->a2)->addr_type != 1U) {
            {
#line 1053
            tmp___7 = gettext(((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed"));
#line 1053
            bad_prog((char const   *)tmp___7);
            }
          } else
#line 1049
          if ((unsigned int )posixicity == 2U) {
            {
#line 1053
            tmp___7 = gettext(((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed"));
#line 1053
            bad_prog((char const   *)tmp___7);
            }
          }
        }
      }
    }
#line 1055
    if (ch == 33) {
      {
#line 1057
      cur_cmd->addr_bang = (char)1;
#line 1058
      ch = in_nonblank();
      }
#line 1059
      if (ch == 33) {
        {
#line 1060
        tmp___9 = gettext(errors___0);
#line 1060
        bad_prog((char const   *)tmp___9);
        }
      }
    }
#line 1065
    if ((unsigned int )posixicity == 2U) {
      {
#line 1069
      if (ch == 87) {
#line 1069
        goto case_87;
      }
#line 1069
      if (ch == 82) {
#line 1069
        goto case_87;
      }
#line 1069
      if (ch == 84) {
#line 1069
        goto case_87;
      }
#line 1069
      if (ch == 81) {
#line 1069
        goto case_87;
      }
#line 1069
      if (ch == 76) {
#line 1069
        goto case_87;
      }
#line 1069
      if (ch == 122) {
#line 1069
        goto case_87;
      }
#line 1069
      if (ch == 118) {
#line 1069
        goto case_87;
      }
#line 1069
      if (ch == 70) {
#line 1069
        goto case_87;
      }
#line 1069
      if (ch == 101) {
#line 1069
        goto case_87;
      }
#line 1074
      if (ch == 114) {
#line 1074
        goto case_114;
      }
#line 1074
      if (ch == 61) {
#line 1074
        goto case_114;
      }
#line 1074
      if (ch == 108) {
#line 1074
        goto case_114;
      }
#line 1074
      if (ch == 105) {
#line 1074
        goto case_114;
      }
#line 1074
      if (ch == 97) {
#line 1074
        goto case_114;
      }
#line 1066
      goto switch_break;
      case_87: /* CIL Label */ 
      case_82: /* CIL Label */ 
      case_84: /* CIL Label */ 
      case_81: /* CIL Label */ 
      case_76: /* CIL Label */ 
      case_122: /* CIL Label */ 
      case_118: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_101: /* CIL Label */ 
      {
#line 1070
      bad_command((char )ch);
      }
      case_114: /* CIL Label */ 
      case_61: /* CIL Label */ 
      case_108: /* CIL Label */ 
      case_105: /* CIL Label */ 
      case_97: /* CIL Label */ 
#line 1075
      if (cur_cmd->a2) {
        {
#line 1076
        tmp___10 = gettext(((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command"));
#line 1076
        bad_prog((char const   *)tmp___10);
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 1079
    cur_cmd->cmd = (char )ch;
    {
#line 1082
    if (ch == 35) {
#line 1082
      goto case_35;
    }
#line 1094
    if (ch == 118) {
#line 1094
      goto case_118___0;
    }
#line 1111
    if (ch == 123) {
#line 1111
      goto case_123;
    }
#line 1116
    if (ch == 125) {
#line 1116
      goto case_125;
    }
#line 1128
    if (ch == 101) {
#line 1128
      goto case_101___0;
    }
#line 1143
    if (ch == 99) {
#line 1143
      goto case_99;
    }
#line 1143
    if (ch == 105) {
#line 1143
      goto case_99;
    }
#line 1143
    if (ch == 97) {
#line 1143
      goto case_99;
    }
#line 1163
    if (ch == 58) {
#line 1163
      goto case_58;
    }
#line 1176
    if (ch == 116) {
#line 1176
      goto case_116;
    }
#line 1176
    if (ch == 98) {
#line 1176
      goto case_116;
    }
#line 1176
    if (ch == 84) {
#line 1176
      goto case_116;
    }
#line 1181
    if (ch == 113) {
#line 1181
      goto case_113;
    }
#line 1181
    if (ch == 81) {
#line 1181
      goto case_113;
    }
#line 1187
    if (ch == 108) {
#line 1187
      goto case_108___0;
    }
#line 1187
    if (ch == 76) {
#line 1187
      goto case_108___0;
    }
#line 1215
    if (ch == 120) {
#line 1215
      goto case_120;
    }
#line 1215
    if (ch == 122) {
#line 1215
      goto case_120;
    }
#line 1215
    if (ch == 80) {
#line 1215
      goto case_120;
    }
#line 1215
    if (ch == 112) {
#line 1215
      goto case_120;
    }
#line 1215
    if (ch == 78) {
#line 1215
      goto case_120;
    }
#line 1215
    if (ch == 110) {
#line 1215
      goto case_120;
    }
#line 1215
    if (ch == 72) {
#line 1215
      goto case_120;
    }
#line 1215
    if (ch == 104) {
#line 1215
      goto case_120;
    }
#line 1215
    if (ch == 71) {
#line 1215
      goto case_120;
    }
#line 1215
    if (ch == 103) {
#line 1215
      goto case_120;
    }
#line 1215
    if (ch == 70) {
#line 1215
      goto case_120;
    }
#line 1215
    if (ch == 68) {
#line 1215
      goto case_120;
    }
#line 1215
    if (ch == 100) {
#line 1215
      goto case_120;
    }
#line 1215
    if (ch == 61) {
#line 1215
      goto case_120;
    }
#line 1219
    if (ch == 114) {
#line 1219
      goto case_114___0;
    }
#line 1225
    if (ch == 82) {
#line 1225
      goto case_82___0;
    }
#line 1230
    if (ch == 119) {
#line 1230
      goto case_119;
    }
#line 1230
    if (ch == 87) {
#line 1230
      goto case_119;
    }
#line 1234
    if (ch == 115) {
#line 1234
      goto case_115;
    }
#line 1261
    if (ch == 121) {
#line 1261
      goto case_121;
    }
#line 1364
    if (ch == -1) {
#line 1364
      goto case_neg_1;
    }
#line 1368
    goto switch_default;
    case_35: /* CIL Label */ 
#line 1083
    if (cur_cmd->a1) {
      {
#line 1084
      tmp___11 = gettext(((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses"));
#line 1084
      bad_prog((char const   *)tmp___11);
      }
    }
    {
#line 1085
    ch = inchar();
    }
#line 1086
    if (ch == 110) {
#line 1086
      if (first_script) {
#line 1086
        if (cur_input.line < 2UL) {
#line 1087
          if (prog.base) {
#line 1087
            if ((unsigned long )prog.cur == (unsigned long )(prog.base + 2)) {
#line 1089
              no_default_output = (_Bool)1;
            } else {
#line 1087
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1087
          if (prog.file) {
#line 1087
            if (! prog.base) {
              {
#line 1087
              tmp___12 = ftell(prog.file);
              }
#line 1087
              if (2L == tmp___12) {
#line 1089
                no_default_output = (_Bool)1;
              }
            }
          }
        }
      }
    }
    {
#line 1090
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1090
      if (ch != -1) {
#line 1090
        if (! (ch != 10)) {
#line 1090
          goto while_break___1;
        }
      } else {
#line 1090
        goto while_break___1;
      }
      {
#line 1091
      ch = inchar();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1092
    goto __Cont;
    case_118___0: /* CIL Label */ 
    {
#line 1100
    tmp___13 = read_label();
#line 1100
    version = tmp___13;
    }
#line 1102
    if ((int )*version == 0) {
#line 1102
      compared_version = "4.0";
    } else {
#line 1102
      compared_version = (char const   *)version;
    }
    {
#line 1103
    tmp___15 = strverscmp(compared_version, "4.5");
    }
#line 1103
    if (tmp___15 > 0) {
      {
#line 1104
      tmp___14 = gettext((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character"));
#line 1104
      bad_prog((char const   *)tmp___14);
      }
    }
    {
#line 1106
    free((void *)version);
#line 1107
    posixicity = (enum posixicity_types )0;
    }
#line 1109
    goto __Cont;
    case_123: /* CIL Label */ 
    {
#line 1112
    blocks = setup_label(blocks, vector->v_length, (char *)((void *)0), (struct error_info  const  *)(& cur_input));
#line 1113
    cur_cmd->addr_bang = (char )(! cur_cmd->addr_bang);
    }
#line 1114
    goto switch_break___0;
    case_125: /* CIL Label */ 
#line 1117
    if (! blocks) {
      {
#line 1118
      tmp___16 = gettext((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'"));
#line 1118
      bad_prog((char const   *)tmp___16);
      }
    }
#line 1119
    if (cur_cmd->a1) {
      {
#line 1120
      tmp___17 = gettext(((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'"));
#line 1120
      bad_prog((char const   *)tmp___17);
      }
    }
    {
#line 1122
    read_end_of_cmd();
#line 1124
    (vector->v + blocks->v_index)->x.jump_index = vector->v_length;
#line 1125
    blocks = release_label(blocks);
    }
#line 1126
    goto switch_break___0;
    case_101___0: /* CIL Label */ 
#line 1129
    if (sandbox) {
      {
#line 1130
      tmp___18 = gettext((((((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0")) + sizeof("unknown command: `%c\'")) + sizeof("incomplete command")) + sizeof("\":\" lacks a label")) + sizeof("recursive escaping after \\c not allowed"));
#line 1130
      bad_prog((char const   *)tmp___18);
      }
    }
    {
#line 1132
    ch = in_nonblank();
    }
#line 1133
    if (ch == -1) {
#line 1135
      cur_cmd->x.cmd_txt.text_length = (size_t )0;
#line 1136
      goto switch_break___0;
    } else
#line 1133
    if (ch == 10) {
#line 1135
      cur_cmd->x.cmd_txt.text_length = (size_t )0;
#line 1136
      goto switch_break___0;
    } else {
#line 1139
      goto read_text_to_slash;
    }
    case_99: /* CIL Label */ 
    case_105___0: /* CIL Label */ 
    case_97___0: /* CIL Label */ 
    {
#line 1144
    ch = in_nonblank();
    }
    read_text_to_slash: 
#line 1147
    if (ch == -1) {
      {
#line 1148
      tmp___19 = gettext((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command"));
#line 1148
      bad_prog((char const   *)tmp___19);
      }
    }
#line 1150
    if (ch == 92) {
      {
#line 1151
      ch = inchar();
      }
    } else {
#line 1154
      if ((unsigned int )posixicity == 2U) {
        {
#line 1155
        tmp___20 = gettext((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command"));
#line 1155
        bad_prog((char const   *)tmp___20);
        }
      }
      {
#line 1156
      savchar(ch);
#line 1157
      ch = '\n';
      }
    }
    {
#line 1160
    read_text(& cur_cmd->x.cmd_txt, ch);
    }
#line 1161
    goto switch_break___0;
    case_58: /* CIL Label */ 
#line 1164
    if (cur_cmd->a1) {
      {
#line 1165
      tmp___21 = gettext((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses"));
#line 1165
      bad_prog((char const   *)tmp___21);
      }
    }
    {
#line 1167
    tmp___22 = read_label();
#line 1167
    label = tmp___22;
    }
#line 1168
    if (! *label) {
      {
#line 1169
      tmp___23 = gettext((((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0")) + sizeof("unknown command: `%c\'")) + sizeof("incomplete command"));
#line 1169
      bad_prog((char const   *)tmp___23);
      }
    }
    {
#line 1170
    labels = setup_label(labels, vector->v_length, label, (struct error_info  const  *)((void *)0));
    }
#line 1172
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_84___0: /* CIL Label */ 
    {
#line 1177
    tmp___24 = read_label();
#line 1177
    jumps = setup_label(jumps, vector->v_length, tmp___24, (struct error_info  const  *)((void *)0));
    }
#line 1178
    goto switch_break___0;
    case_113: /* CIL Label */ 
    case_81___0: /* CIL Label */ 
#line 1182
    if (cur_cmd->a2) {
      {
#line 1183
      tmp___25 = gettext(((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command"));
#line 1183
      bad_prog((char const   *)tmp___25);
      }
    }
    case_108___0: /* CIL Label */ 
    case_76___0: /* CIL Label */ 
    {
#line 1188
    ch = in_nonblank();
#line 1189
    tmp___27 = __ctype_b_loc();
    }
#line 1189
    if ((int const   )*(*tmp___27 + (int )((unsigned char )ch)) & 2048) {
#line 1189
      if ((unsigned int )posixicity != 2U) {
        {
#line 1191
        tmp___26 = in_integer(ch);
#line 1191
        cur_cmd->x.int_arg = (int )tmp___26;
        }
      } else {
        {
#line 1195
        cur_cmd->x.int_arg = -1;
#line 1196
        savchar(ch);
        }
      }
    } else {
      {
#line 1195
      cur_cmd->x.int_arg = -1;
#line 1196
      savchar(ch);
      }
    }
    {
#line 1199
    read_end_of_cmd();
    }
#line 1200
    goto switch_break___0;
    case_120: /* CIL Label */ 
    case_122___0: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_70___0: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    {
#line 1216
    read_end_of_cmd();
    }
#line 1217
    goto switch_break___0;
    case_114___0: /* CIL Label */ 
    {
#line 1220
    b___0 = read_filename();
#line 1221
    tmp___28 = get_buffer((struct buffer  const  *)b___0);
#line 1221
    cur_cmd->x.fname = ck_strdup((char const   *)tmp___28);
#line 1222
    free_buffer(b___0);
    }
#line 1223
    goto switch_break___0;
    case_82___0: /* CIL Label */ 
    {
#line 1226
    tmp___29 = get_openfile(& file_read, read_mode, 0);
#line 1226
    cur_cmd->x.fp = tmp___29->fp;
    }
#line 1227
    goto switch_break___0;
    case_119: /* CIL Label */ 
    case_87___0: /* CIL Label */ 
    {
#line 1231
    cur_cmd->x.outf = get_openfile(& file_write, write_mode, 1);
    }
#line 1232
    goto switch_break___0;
    case_115: /* CIL Label */ 
    {
#line 1240
    slash = inchar();
#line 1241
    b___0 = match_slash(slash, 1);
    }
#line 1241
    if (! b___0) {
      {
#line 1242
      tmp___30 = gettext(((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex"));
#line 1242
      bad_prog((char const   *)tmp___30);
      }
    }
    {
#line 1243
    b2 = match_slash(slash, 0);
    }
#line 1243
    if (! b2) {
      {
#line 1244
      tmp___31 = gettext(((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex"));
#line 1244
      bad_prog((char const   *)tmp___31);
      }
    }
#line 1246
    __h = & obs;
#line 1246
    __o = __h;
#line 1246
    __len = sizeof(struct subst );
#line 1246
    __o1 = (struct obstack  const  *)__o;
#line 1246
    if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
      {
#line 1246
      _obstack_newchunk(__o, __len);
      }
    }
#line 1246
    __o->next_free += __len;
#line 1246
    __o1___0 = __h;
#line 1246
    __value = (void *)__o1___0->object_base;
#line 1246
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 1246
      __o1___0->maybe_empty_object = 1U;
    }
#line 1246
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1246
      tmp___32 = __o1___0->object_base;
    } else {
#line 1246
      tmp___32 = (char *)0;
    }
#line 1246
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1246
      tmp___33 = __o1___0->object_base;
    } else {
#line 1246
      tmp___33 = (char *)0;
    }
#line 1246
    __o1___0->next_free = tmp___32 + (((size_t )(__o1___0->next_free - tmp___33) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 1246
    if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 1246
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 1246
    __o1___0->object_base = __o1___0->next_free;
#line 1246
    cur_cmd->x.cmd_subst = (struct subst *)__value;
#line 1247
    tmp___34 = size_buffer((struct buffer  const  *)b2);
#line 1247
    tmp___35 = get_buffer((struct buffer  const  *)b2);
#line 1247
    setup_replacement(cur_cmd->x.cmd_subst, (char const   *)tmp___35, tmp___34);
#line 1249
    free_buffer(b2);
#line 1251
    flags = mark_subst_opts(cur_cmd->x.cmd_subst);
#line 1252
    (cur_cmd->x.cmd_subst)->regx = compile_regex(b___0, flags, (int )((cur_cmd->x.cmd_subst)->max_id + 1U));
#line 1254
    free_buffer(b___0);
    }
#line 1256
    if ((cur_cmd->x.cmd_subst)->eval) {
#line 1256
      if (sandbox) {
        {
#line 1257
        tmp___36 = gettext((((((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0")) + sizeof("unknown command: `%c\'")) + sizeof("incomplete command")) + sizeof("\":\" lacks a label")) + sizeof("recursive escaping after \\c not allowed"));
#line 1257
        bad_prog((char const   *)tmp___36);
        }
      }
    }
#line 1259
    goto switch_break___0;
    case_121: /* CIL Label */ 
    {
#line 1268
    slash___0 = inchar();
#line 1269
    b___0 = match_slash(slash___0, 0);
    }
#line 1269
    if (! b___0) {
      {
#line 1270
      tmp___37 = gettext((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command"));
#line 1270
      bad_prog((char const   *)tmp___37);
      }
    }
    {
#line 1271
    src_buf = get_buffer((struct buffer  const  *)b___0);
#line 1272
    tmp___38 = size_buffer((struct buffer  const  *)b___0);
#line 1272
    len = normalize_text(src_buf, tmp___38, (enum text_types )0);
#line 1274
    b2___0 = match_slash(slash___0, 0);
    }
#line 1274
    if (! b2___0) {
      {
#line 1275
      tmp___39 = gettext((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command"));
#line 1275
      bad_prog((char const   *)tmp___39);
      }
    }
    {
#line 1276
    dest_buf = get_buffer((struct buffer  const  *)b2___0);
#line 1277
    tmp___40 = size_buffer((struct buffer  const  *)b2___0);
#line 1277
    dest_len = normalize_text(dest_buf, tmp___40, (enum text_types )0);
    }
#line 1279
    if (mb_cur_max > 1) {
      {
#line 1282
      tmp___41 = ck_malloc(len * sizeof(size_t ));
#line 1282
      src_lens = (size_t *)tmp___41;
#line 1285
      cur_stat.__count = 0;
#line 1285
      cur_stat.__value.__wch = 0U;
#line 1288
      i = (size_t )0;
#line 1288
      j = (size_t )0;
      }
      {
#line 1288
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1288
        if (! (i < len)) {
#line 1288
          goto while_break___2;
        }
#line 1290
        if (mb_cur_max == 1) {
#line 1290
          mbclen = (size_t )1;
        } else {
          {
#line 1290
          tmp___42 = rpl_mbrtowc((wchar_t *)((void *)0), (char const   *)(src_buf + i),
                                 len - i, & cur_stat);
#line 1290
          mbclen = tmp___42;
          }
        }
#line 1293
        if (mbclen == 0xffffffffffffffffUL) {
#line 1295
          mbclen = (size_t )1;
        } else
#line 1293
        if (mbclen == 0xfffffffffffffffeUL) {
#line 1295
          mbclen = (size_t )1;
        } else
#line 1293
        if (mbclen == 0UL) {
#line 1295
          mbclen = (size_t )1;
        }
#line 1296
        tmp___43 = j;
#line 1296
        j ++;
#line 1296
        *(src_lens + tmp___43) = mbclen;
#line 1297
        i += mbclen;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1299
      src_char_num = j;
#line 1301
      memset((void *)(& cur_stat), 0, sizeof(cur_stat));
#line 1302
      idx = (size_t )0;
#line 1308
      tmp___44 = ck_malloc((2UL * src_char_num + 1UL) * sizeof(char *));
#line 1308
      trans_pairs = (char **)tmp___44;
#line 1309
      cur_cmd->x.translatemb = trans_pairs;
#line 1310
      i = (size_t )0;
      }
      {
#line 1310
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1310
        if (! (i < src_char_num)) {
#line 1310
          goto while_break___3;
        }
#line 1312
        if (idx >= dest_len) {
          {
#line 1313
          tmp___45 = gettext((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"));
#line 1313
          bad_prog((char const   *)tmp___45);
          }
        }
        {
#line 1316
        tmp___46 = ck_malloc((*(src_lens + i) + 1UL) * sizeof(char ));
#line 1316
        *(trans_pairs + 2UL * i) = (char *)tmp___46;
#line 1317
        memcpy((void */* __restrict  */)*(trans_pairs + 2UL * i), (void const   */* __restrict  */)src_buf,
               *(src_lens + i));
#line 1318
        *(*(trans_pairs + 2UL * i) + *(src_lens + i)) = (char )'\000';
#line 1319
        src_buf += *(src_lens + i);
        }
#line 1322
        if (mb_cur_max == 1) {
#line 1322
          mbclen = (size_t )1;
        } else {
          {
#line 1322
          tmp___47 = rpl_mbrtowc((wchar_t *)((void *)0), (char const   *)(dest_buf + idx),
                                 dest_len - idx, & cur_stat);
#line 1322
          mbclen = tmp___47;
          }
        }
#line 1325
        if (mbclen == 0xffffffffffffffffUL) {
#line 1327
          mbclen = (size_t )1;
        } else
#line 1325
        if (mbclen == 0xfffffffffffffffeUL) {
#line 1327
          mbclen = (size_t )1;
        } else
#line 1325
        if (mbclen == 0UL) {
#line 1327
          mbclen = (size_t )1;
        }
        {
#line 1330
        tmp___48 = ck_malloc((mbclen + 1UL) * sizeof(char ));
#line 1330
        *(trans_pairs + (2UL * i + 1UL)) = (char *)tmp___48;
#line 1331
        memcpy((void */* __restrict  */)*(trans_pairs + (2UL * i + 1UL)), (void const   */* __restrict  */)(dest_buf + idx),
               mbclen);
#line 1332
        *(*(trans_pairs + (2UL * i + 1UL)) + mbclen) = (char )'\000';
#line 1333
        idx += mbclen;
#line 1310
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1335
      *(trans_pairs + 2UL * i) = (char *)((void *)0);
#line 1336
      if (idx != dest_len) {
        {
#line 1337
        tmp___49 = gettext((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"));
#line 1337
        bad_prog((char const   *)tmp___49);
        }
      }
    } else {
#line 1342
      __h___0 = & obs;
#line 1342
      __o___0 = __h___0;
#line 1342
      __len___0 = 256UL * sizeof(unsigned char );
#line 1342
      __o1___1 = (struct obstack  const  *)__o___0;
#line 1342
      if ((size_t )(__o1___1->chunk_limit - __o1___1->next_free) < __len___0) {
        {
#line 1342
        _obstack_newchunk(__o___0, __len___0);
        }
      }
#line 1342
      __o___0->next_free += __len___0;
#line 1342
      __o1___2 = __h___0;
#line 1342
      __value___0 = (void *)__o1___2->object_base;
#line 1342
      if ((unsigned long )__o1___2->next_free == (unsigned long )__value___0) {
#line 1342
        __o1___2->maybe_empty_object = 1U;
      }
#line 1342
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1342
        tmp___50 = __o1___2->object_base;
      } else {
#line 1342
        tmp___50 = (char *)0;
      }
#line 1342
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1342
        tmp___51 = __o1___2->object_base;
      } else {
#line 1342
        tmp___51 = (char *)0;
      }
#line 1342
      __o1___2->next_free = tmp___50 + (((size_t )(__o1___2->next_free - tmp___51) + __o1___2->alignment_mask) & ~ __o1___2->alignment_mask);
#line 1342
      if ((size_t )(__o1___2->next_free - (char *)__o1___2->chunk) > (size_t )(__o1___2->chunk_limit - (char *)__o1___2->chunk)) {
#line 1342
        __o1___2->next_free = __o1___2->chunk_limit;
      }
#line 1342
      __o1___2->object_base = __o1___2->next_free;
#line 1342
      translate = (unsigned char *)__value___0;
#line 1343
      ustring = (unsigned char *)src_buf;
#line 1345
      if (len != dest_len) {
        {
#line 1346
        tmp___52 = gettext((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"));
#line 1346
        bad_prog((char const   *)tmp___52);
        }
      }
#line 1348
      len = (size_t )0;
      {
#line 1348
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1348
        if (! (len < 256UL)) {
#line 1348
          goto while_break___4;
        }
#line 1349
        *(translate + len) = (unsigned char )len;
#line 1348
        len ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1351
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1351
        tmp___55 = dest_len;
#line 1351
        dest_len --;
#line 1351
        if (! tmp___55) {
#line 1351
          goto while_break___5;
        }
#line 1352
        tmp___53 = ustring;
#line 1352
        ustring ++;
#line 1352
        tmp___54 = dest_buf;
#line 1352
        dest_buf ++;
#line 1352
        *(translate + *tmp___53) = (unsigned char )*tmp___54;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1354
      cur_cmd->x.translate = translate;
    }
    {
#line 1357
    read_end_of_cmd();
#line 1359
    free_buffer(b___0);
#line 1360
    free_buffer(b2___0);
    }
#line 1362
    goto switch_break___0;
    case_neg_1: /* CIL Label */ 
    {
#line 1365
    tmp___56 = gettext((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses"));
#line 1365
    bad_prog((char const   *)tmp___56);
    }
    switch_default: /* CIL Label */ 
    {
#line 1369
    bad_command((char )ch);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 1374
    (vector->v_length) ++;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1376
  if ((unsigned int )posixicity == 2U) {
#line 1376
    if (pending_text) {
      {
#line 1377
      tmp___57 = gettext(((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0")) + sizeof("unknown command: `%c\'"));
#line 1377
      bad_prog((char const   *)tmp___57);
      }
    }
  }
#line 1378
  return (vector);
}
}
#line 1383 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
size_t normalize_text(char *buf , size_t len , enum text_types buftype ) 
{ 
  char const   *bufend ;
  char *p ;
  char *q ;
  char ch ;
  int base ;
  int bracket_state ;
  int mbclen ;
  mbstate_t cur_stat ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 1386
  bufend = (char const   *)(buf + len);
#line 1387
  p = buf;
#line 1388
  q = buf;
#line 1398
  bracket_state = 0;
#line 1401
  cur_stat.__count = 0;
#line 1401
  cur_stat.__value.__wch = 0U;
  {
#line 1403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1403
    if (! ((unsigned long )p < (unsigned long )bufend)) {
#line 1403
      goto while_break;
    }
#line 1405
    if (mb_cur_max == 1) {
#line 1405
      mbclen = 1;
    } else {
      {
#line 1405
      tmp = rpl_mbrtowc((wchar_t *)((void *)0), (char const   *)p, (size_t )(bufend - (char const   *)p),
                        & cur_stat);
#line 1405
      mbclen = (int )tmp;
      }
    }
#line 1406
    if (mbclen != 1) {
#line 1410
      if ((size_t )mbclen == 0xffffffffffffffffUL) {
#line 1411
        mbclen = 1;
      } else
#line 1410
      if ((size_t )mbclen == 0xfffffffffffffffeUL) {
#line 1411
        mbclen = 1;
      } else
#line 1410
      if (mbclen == 0) {
#line 1411
        mbclen = 1;
      }
      {
#line 1413
      memmove((void *)q, (void const   *)p, (size_t )mbclen);
#line 1414
      q += mbclen;
#line 1415
      p += mbclen;
      }
#line 1416
      goto while_continue;
    }
#line 1419
    if ((int )*p == 92) {
#line 1419
      if ((unsigned long )(p + 1) < (unsigned long )bufend) {
#line 1419
        if (bracket_state == 0) {
#line 1420
          p ++;
          {
#line 1423
          if ((int )*p == 97) {
#line 1423
            goto case_97;
          }
#line 1428
          if ((int )*p == 102) {
#line 1428
            goto case_102;
          }
#line 1430
          if ((int )*p == 110) {
#line 1430
            goto case_110;
          }
#line 1430
          if ((int )*p == 10) {
#line 1430
            goto case_110;
          }
#line 1431
          if ((int )*p == 114) {
#line 1431
            goto case_114;
          }
#line 1432
          if ((int )*p == 116) {
#line 1432
            goto case_116;
          }
#line 1433
          if ((int )*p == 118) {
#line 1433
            goto case_118;
          }
#line 1435
          if ((int )*p == 100) {
#line 1435
            goto case_100;
          }
#line 1439
          if ((int )*p == 120) {
#line 1439
            goto case_120;
          }
#line 1477
          if ((int )*p == 111) {
#line 1477
            goto case_111;
          }
#line 1489
          if ((int )*p == 99) {
#line 1489
            goto case_99;
          }
#line 1510
          goto switch_default;
          case_97: /* CIL Label */ 
#line 1423
          tmp___0 = q;
#line 1423
          q ++;
#line 1423
          *tmp___0 = (char )'\a';
#line 1423
          p ++;
#line 1423
          goto while_continue;
          case_102: /* CIL Label */ 
#line 1428
          tmp___1 = q;
#line 1428
          q ++;
#line 1428
          *tmp___1 = (char )'\f';
#line 1428
          p ++;
#line 1428
          goto while_continue;
          case_110: /* CIL Label */ 
          case_10: /* CIL Label */ 
#line 1430
          tmp___2 = q;
#line 1430
          q ++;
#line 1430
          *tmp___2 = (char )'\n';
#line 1430
          p ++;
#line 1430
          goto while_continue;
          case_114: /* CIL Label */ 
#line 1431
          tmp___3 = q;
#line 1431
          q ++;
#line 1431
          *tmp___3 = (char )'\r';
#line 1431
          p ++;
#line 1431
          goto while_continue;
          case_116: /* CIL Label */ 
#line 1432
          tmp___4 = q;
#line 1432
          q ++;
#line 1432
          *tmp___4 = (char )'\t';
#line 1432
          p ++;
#line 1432
          goto while_continue;
          case_118: /* CIL Label */ 
#line 1433
          tmp___5 = q;
#line 1433
          q ++;
#line 1433
          *tmp___5 = (char )'\v';
#line 1433
          p ++;
#line 1433
          goto while_continue;
          case_100: /* CIL Label */ 
#line 1436
          base = 10;
#line 1437
          goto convert;
          case_120: /* CIL Label */ 
#line 1440
          base = 16;
#line 1441
          goto convert;
          case_111: /* CIL Label */ 
#line 1478
          base = 8;
          convert: 
          {
#line 1481
          p = convert_number(& ch, p, bufend, base);
          }
#line 1484
          if ((unsigned int )buftype == 1U) {
#line 1484
            if ((int )ch == 38) {
#line 1485
              tmp___6 = q;
#line 1485
              q ++;
#line 1485
              *tmp___6 = (char )'\\';
            } else
#line 1484
            if ((int )ch == 92) {
#line 1485
              tmp___6 = q;
#line 1485
              q ++;
#line 1485
              *tmp___6 = (char )'\\';
            }
          }
#line 1486
          tmp___7 = q;
#line 1486
          q ++;
#line 1486
          *tmp___7 = ch;
#line 1487
          goto while_continue;
          case_99: /* CIL Label */ 
#line 1490
          p ++;
#line 1490
          if ((unsigned long )p < (unsigned long )bufend) {
            {
#line 1492
            tmp___8 = q;
#line 1492
            q ++;
#line 1492
            tmp___9 = toupper((int )((unsigned char )*p));
#line 1492
            *tmp___8 = (char )(tmp___9 ^ 64);
            }
#line 1493
            if ((int )*p == 92) {
#line 1495
              p ++;
#line 1496
              if ((int )*p != 92) {
                {
#line 1497
                bad_prog(((((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0")) + sizeof("unknown command: `%c\'")) + sizeof("incomplete command")) + sizeof("\":\" lacks a label"));
                }
              }
            }
#line 1499
            p ++;
#line 1500
            goto while_continue;
          } else {
#line 1505
            if ((unsigned int )buftype != 0U) {
#line 1506
              tmp___10 = q;
#line 1506
              q ++;
#line 1506
              *tmp___10 = (char )'\\';
            }
#line 1507
            goto while_continue;
          }
          switch_default: /* CIL Label */ 
#line 1512
          if ((unsigned int )buftype != 0U) {
#line 1513
            tmp___11 = q;
#line 1513
            q ++;
#line 1513
            *tmp___11 = (char )'\\';
          }
#line 1514
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        } else {
#line 1419
          goto _L___0;
        }
      } else {
#line 1419
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1516
    if ((unsigned int )buftype == 2U) {
#line 1516
      if ((unsigned int )posixicity != 0U) {
        {
#line 1519
        if ((int )*p == 91) {
#line 1519
          goto case_91;
        }
#line 1526
        if ((int )*p == 61) {
#line 1526
          goto case_61;
        }
#line 1526
        if ((int )*p == 46) {
#line 1526
          goto case_61;
        }
#line 1526
        if ((int )*p == 58) {
#line 1526
          goto case_61;
        }
#line 1531
        if ((int )*p == 93) {
#line 1531
          goto case_93;
        }
#line 1517
        goto switch_break___0;
        case_91: /* CIL Label */ 
#line 1520
        if (! bracket_state) {
#line 1521
          bracket_state = -1;
        }
#line 1522
        goto switch_break___0;
        case_61: /* CIL Label */ 
        case_46: /* CIL Label */ 
        case_58: /* CIL Label */ 
#line 1527
        if (bracket_state == -1) {
#line 1527
          if ((int )*(p + -1) == 91) {
#line 1528
            bracket_state = (int )*p;
          }
        }
#line 1529
        goto switch_break___0;
        case_93: /* CIL Label */ 
#line 1532
        if (! (bracket_state == 0)) {
#line 1534
          if (bracket_state == -1) {
#line 1535
            bracket_state = 0;
          } else
#line 1536
          if ((int )*(p + -2) != bracket_state) {
#line 1536
            if ((int )*(p + -1) == bracket_state) {
#line 1537
              bracket_state = -1;
            }
          }
        }
#line 1538
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1541
    tmp___12 = q;
#line 1541
    q ++;
#line 1541
    tmp___13 = p;
#line 1541
    p ++;
#line 1541
    *tmp___12 = *tmp___13;
  }
  while_break: /* CIL Label */ ;
  }
#line 1543
  return ((size_t )(q - buf));
}
}
#line 1552 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
static countT string_expr_count  =    (countT )0;
#line 1549 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
struct vector *compile_string(struct vector *cur_program , char *str , size_t len ) 
{ 
  struct vector *ret ;

  {
  {
#line 1555
  prog.file = (FILE *)((void *)0);
#line 1556
  prog.base = (unsigned char const   *)((unsigned char *)str);
#line 1557
  prog.cur = prog.base;
#line 1558
  prog.end = prog.cur + len;
#line 1560
  cur_input.line = (countT )0;
#line 1561
  cur_input.name = (char const   *)((void *)0);
#line 1562
  string_expr_count ++;
#line 1562
  cur_input.string_expr_count = string_expr_count;
#line 1564
  ret = compile_program(cur_program);
#line 1565
  prog.base = (unsigned char const   *)((void *)0);
#line 1566
  prog.cur = (unsigned char const   *)((void *)0);
#line 1567
  prog.end = (unsigned char const   *)((void *)0);
#line 1569
  first_script = (_Bool)0;
  }
#line 1570
  return (ret);
}
}
#line 1576 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
struct vector *compile_file(struct vector *cur_program , char const   *cmdfile ) 
{ 
  struct vector *ret ;

  {
#line 1581
  prog.file = stdin;
#line 1582
  if ((int const   )*(cmdfile + 0) != 45) {
    {
#line 1585
    prog.file = ck_fopen(cmdfile, "rt", 1);
    }
  } else
#line 1582
  if ((int const   )*(cmdfile + 1) != 0) {
    {
#line 1585
    prog.file = ck_fopen(cmdfile, "rt", 1);
    }
  }
  {
#line 1591
  cur_input.line = (countT )1;
#line 1592
  cur_input.name = cmdfile;
#line 1593
  cur_input.string_expr_count = (countT )0;
#line 1595
  ret = compile_program(cur_program);
  }
#line 1596
  if ((unsigned long )prog.file != (unsigned long )stdin) {
    {
#line 1597
    ck_fclose(prog.file);
    }
  }
#line 1598
  prog.file = (FILE *)((void *)0);
#line 1600
  first_script = (_Bool)0;
#line 1601
  return (ret);
}
}
#line 1607 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
void check_final_program(struct vector *program ) 
{ 
  struct sed_label *go ;
  struct sed_label *lbl ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  struct output *p ;

  {
#line 1614
  if (blocks) {
    {
#line 1617
    memcpy((void */* __restrict  */)(& cur_input), (void const   */* __restrict  */)(& blocks->err_info),
           sizeof(cur_input));
#line 1618
    tmp = gettext(((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address"));
#line 1618
    bad_prog((char const   *)tmp);
    }
  }
#line 1622
  if (pending_text) {
    {
#line 1624
    old_text_buf->text_length = size_buffer((struct buffer  const  *)pending_text);
    }
#line 1625
    if (old_text_buf->text_length) {
      {
#line 1626
      tmp___0 = get_buffer((struct buffer  const  *)pending_text);
#line 1626
      tmp___1 = ck_memdup((void const   *)((void *)tmp___0), old_text_buf->text_length * sizeof(char ));
#line 1626
      old_text_buf->text = (char *)tmp___1;
      }
    }
    {
#line 1628
    free_buffer(pending_text);
#line 1629
    pending_text = (struct buffer *)((void *)0);
    }
  }
#line 1632
  go = jumps;
  {
#line 1632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1632
    if (! go) {
#line 1632
      goto while_break;
    }
#line 1634
    lbl = labels;
    {
#line 1634
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1634
      if (! lbl) {
#line 1634
        goto while_break___0;
      }
      {
#line 1635
      tmp___2 = strcmp((char const   *)lbl->name, (char const   *)go->name);
      }
#line 1635
      if (tmp___2 == 0) {
#line 1636
        goto while_break___0;
      }
#line 1634
      lbl = lbl->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1637
    if (lbl) {
#line 1639
      (program->v + go->v_index)->x.jump_index = lbl->v_index;
    } else {
#line 1643
      if (*(go->name)) {
        {
#line 1644
        tmp___3 = gettext("can\'t find label for jump to `%s\'");
#line 1644
        panic((char const   *)tmp___3, go->name);
        }
      }
#line 1645
      (program->v + go->v_index)->x.jump_index = program->v_length;
    }
    {
#line 1632
    go = release_label(go);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1648
  jumps = (struct sed_label *)((void *)0);
#line 1650
  lbl = labels;
  {
#line 1650
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1650
    if (! lbl) {
#line 1650
      goto while_break___1;
    }
    {
#line 1650
    lbl = release_label(lbl);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1652
  labels = (struct sed_label *)((void *)0);
#line 1658
  p = file_read;
  {
#line 1658
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1658
    if (! p) {
#line 1658
      goto while_break___2;
    }
#line 1659
    if (p->name) {
      {
#line 1661
      free((void *)p->name);
#line 1662
      p->name = (char *)((void *)0);
      }
    }
#line 1658
    p = p->link;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1665
  p = file_write;
  {
#line 1665
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1665
    if (! p) {
#line 1665
      goto while_break___3;
    }
#line 1666
    if (p->name) {
      {
#line 1668
      free((void *)p->name);
#line 1669
      p->name = (char *)((void *)0);
      }
    }
#line 1665
    p = p->link;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1672
  return;
}
}
#line 1675 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
void rewind_read_files(void) 
{ 
  struct output *p ;

  {
#line 1680
  p = file_read;
  {
#line 1680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1680
    if (! p) {
#line 1680
      goto while_break;
    }
#line 1681
    if (p->fp) {
      {
#line 1682
      rewind(p->fp);
      }
    }
#line 1680
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 1683
  return;
}
}
#line 1686 "/home/khheo/project/benchmark/sed-4.5/sed/compile.c"
void finish_program(void) 
{ 
  struct output *p ;
  struct output *q ;

  {
#line 1693
  p = file_read;
  {
#line 1693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1693
    if (! p) {
#line 1693
      goto while_break;
    }
#line 1695
    if (p->fp) {
      {
#line 1696
      ck_fclose(p->fp);
      }
    }
#line 1697
    q = p->link;
#line 1693
    p = q;
  }
  while_break: /* CIL Label */ ;
  }
#line 1704
  p = file_write;
  {
#line 1704
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1704
    if (! p) {
#line 1704
      goto while_break___0;
    }
#line 1706
    if (p->fp) {
      {
#line 1707
      ck_fclose(p->fp);
      }
    }
#line 1708
    q = p->link;
#line 1704
    p = q;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1714
  file_write = (struct output *)((void *)0);
#line 1714
  file_read = file_write;
#line 1720
  return;
}
}
