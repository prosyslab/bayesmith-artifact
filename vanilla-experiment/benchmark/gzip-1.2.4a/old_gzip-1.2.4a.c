/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 43 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 173 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 179 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 264 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 328 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 213 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int size_t;
#line 14 "gzip.h"
typedef void *voidp;
#line 44 "gzip.h"
typedef unsigned char uch;
#line 45 "gzip.h"
typedef unsigned short ush;
#line 46 "gzip.h"
typedef unsigned long ulg;
#line 41 "/usr/include/bits/types.h"
typedef unsigned char __uint8_t;
#line 182 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 28 "unlzw.c"
typedef unsigned char char_type;
#line 29 "unlzw.c"
typedef long code_int;
#line 32 "unlzw.c"
typedef unsigned long cmp_code_int;
#line 241 "unlzw.c"
union __anonunion___u_20 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 294 "unlzw.c"
union __anonunion___u_21 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 121 "inflate.c"
union __anonunion_v_18 {
   ush n ;
   struct huft *t ;
};
#line 121 "inflate.c"
struct huft {
   uch e ;
   uch b ;
   union __anonunion_v_18 v ;
};
#line 307 "inflate.c"
union __anonunion___u_19 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 151 "gzip.h"
typedef int file_t;
#line 160 "trees.c"
union __anonunion_fc_11 {
   ush freq ;
   ush code ;
};
#line 160 "trees.c"
union __anonunion_dl_12 {
   ush dad ;
   ush len ;
};
#line 160 "trees.c"
struct ct_data {
   union __anonunion_fc_11 fc ;
   union __anonunion_dl_12 dl ;
};
#line 160 "trees.c"
typedef struct ct_data ct_data;
#line 197 "trees.c"
struct tree_desc {
   ct_data *dyn_tree ;
   ct_data *static_tree ;
   int *extra_bits ;
   int extra_base ;
   int elems ;
   int max_length ;
   int max_code ;
};
#line 197 "trees.c"
typedef struct tree_desc tree_desc;
#line 128 "deflate.c"
typedef ush Pos;
#line 129 "deflate.c"
typedef unsigned int IPos;
#line 212 "deflate.c"
struct config {
   ush good_length ;
   ush max_lazy ;
   ush nice_length ;
   ush max_chain ;
};
#line 212 "deflate.c"
typedef struct config config;
#line 299 "deflate.c"
union __anonunion___u_10 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 136 "/usr/include/bits/types.h"
typedef unsigned long long __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 171 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_3 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_3 __sigset_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 73 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 77 "getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 87 "gzip.c"
typedef struct dirent dir_type;
#line 38 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 404 "/usr/include/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 405
extern int __overflow(_IO_FILE * , int  ) ;
#line 433
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 434
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 143
extern struct _IO_FILE *stdout ;
#line 336
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 342
__inline extern int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) ;
#line 442
__inline extern int getchar(void) ;
#line 454
__inline extern int getc_unlocked(FILE *__fp ) ;
#line 455
__inline extern int getchar_unlocked(void) ;
#line 484
__inline extern int putchar(int __c ) ;
#line 498
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 506
__inline extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 507
__inline extern int putchar_unlocked(int __c ) ;
#line 730
__inline extern int feof_unlocked(FILE *__stream ) ;
#line 731
__inline extern int ferror_unlocked(FILE *__stream ) ;
#line 33 "/usr/include/bits/stdio.h"
__inline extern int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  {
  {
#line 36
  tmp = vfprintf((FILE */* __restrict  */)stdout, __fmt, __arg);
  }
  }
#line 36
  return (tmp);
}
}
#line 40 "/usr/include/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int tmp ;

  {
  {
  {
#line 43
  tmp = _IO_getc(stdin);
  }
  }
#line 43
  return (tmp);
}
}
#line 49 "/usr/include/bits/stdio.h"
__inline extern int getc_unlocked(FILE *__fp ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 52
  if ((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end) {
    {
    {
#line 52
    tmp = __uflow(__fp);
    }
#line 52
    tmp___1 = tmp;
    }
  } else {
#line 52
    tmp___0 = __fp->_IO_read_ptr;
#line 52
    (__fp->_IO_read_ptr) ++;
#line 52
    tmp___1 = (int )*((unsigned char *)tmp___0);
  }
#line 52
  return (tmp___1);
}
}
#line 56 "/usr/include/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 59
  if ((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end) {
    {
    {
#line 59
    tmp = __uflow(stdin);
    }
#line 59
    tmp___1 = tmp;
    }
  } else {
#line 59
    tmp___0 = stdin->_IO_read_ptr;
#line 59
    (stdin->_IO_read_ptr) ++;
#line 59
    tmp___1 = (int )*((unsigned char *)tmp___0);
  }
#line 59
  return (tmp___1);
}
}
#line 65 "/usr/include/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int tmp ;

  {
  {
  {
#line 68
  tmp = _IO_putc(__c, stdout);
  }
  }
#line 68
  return (tmp);
}
}
#line 74 "/usr/include/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;

  {
#line 77
  if ((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end) {
    {
    {
#line 77
    tmp = __overflow(__stream, (int )((unsigned char )__c));
    }
#line 77
    tmp___2 = tmp;
    }
  } else {
#line 77
    tmp___0 = __stream->_IO_write_ptr;
#line 77
    (__stream->_IO_write_ptr) ++;
#line 77
    tmp___1 = (char )__c;
#line 77
    *tmp___0 = tmp___1;
#line 77
    tmp___2 = (int )((unsigned char )tmp___1);
  }
#line 77
  return (tmp___2);
}
}
#line 91 "/usr/include/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;

  {
#line 94
  if ((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end) {
    {
    {
#line 94
    tmp = __overflow(stdout, (int )((unsigned char )__c));
    }
#line 94
    tmp___2 = tmp;
    }
  } else {
#line 94
    tmp___0 = stdout->_IO_write_ptr;
#line 94
    (stdout->_IO_write_ptr) ++;
#line 94
    tmp___1 = (char )__c;
#line 94
    *tmp___0 = tmp___1;
#line 94
    tmp___2 = (int )((unsigned char )tmp___1);
  }
#line 94
  return (tmp___2);
}
}
#line 111 "/usr/include/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 114
  return ((__stream->_flags & 16) != 0);
}
}
#line 118 "/usr/include/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 121
  return ((__stream->_flags & 32) != 0);
}
}
#line 162 "/usr/include/string.h"
extern char *strchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 919 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) ;
#line 920 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) 
{ 
  register size_t __result ;

  {
#line 923
  __result = (size_t )0;
  {
  {
#line 924
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 924
    if ((int const   )*(__s + __result) != 0) {
#line 924
      if (! ((int const   )*(__s + __result) != (int const   )__reject)) {
#line 924
        goto while_break;
      }
    } else {
#line 924
      goto while_break;
    }
#line 925
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 926
  return (__result);
}
}
#line 929
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) ;
#line 931 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) 
{ 
  register size_t __result ;

  {
#line 934
  __result = (size_t )0;
  {
  {
#line 935
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 935
    if ((int const   )*(__s + __result) != 0) {
#line 935
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 935
        if (! ((int const   )*(__s + __result) != (int const   )__reject2)) {
#line 935
          goto while_break;
        }
      } else {
#line 935
        goto while_break;
      }
    } else {
#line 935
      goto while_break;
    }
#line 937
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 938
  return (__result);
}
}
#line 941
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
#line 943 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) 
{ 
  register size_t __result ;

  {
#line 947
  __result = (size_t )0;
  {
  {
#line 948
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 948
    if ((int const   )*(__s + __result) != 0) {
#line 948
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 948
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
#line 948
          if (! ((int const   )*(__s + __result) != (int const   )__reject3)) {
#line 948
            goto while_break;
          }
        } else {
#line 948
          goto while_break;
        }
      } else {
#line 948
        goto while_break;
      }
    } else {
#line 948
      goto while_break;
    }
#line 950
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 951
  return (__result);
}
}
#line 976
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) ;
#line 977 "/usr/include/bits/string2.h"
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) 
{ 
  register size_t __result ;

  {
#line 980
  __result = (size_t )0;
  {
  {
#line 982
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 982
    if (! ((int const   )*(__s + __result) == (int const   )__accept)) {
#line 982
      goto while_break;
    }
#line 983
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 984
  return (__result);
}
}
#line 987
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 989 "/usr/include/bits/string2.h"
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  register size_t __result ;

  {
#line 992
  __result = (size_t )0;
  {
  {
#line 994
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 994
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 994
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 994
        goto while_break;
      }
    }
#line 995
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 996
  return (__result);
}
}
#line 999
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1001 "/usr/include/bits/string2.h"
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  register size_t __result ;

  {
#line 1004
  __result = (size_t )0;
  {
  {
#line 1006
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1006
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1006
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1006
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
#line 1006
          goto while_break;
        }
      }
    }
#line 1008
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1009
  return (__result);
}
}
#line 1033
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1035 "/usr/include/bits/string2.h"
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  char *tmp ;

  {
  {
  {
#line 1039
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1039
    if ((int const   )*__s != 0) {
#line 1039
      if ((int const   )*__s != (int const   )__accept1) {
#line 1039
        if (! ((int const   )*__s != (int const   )__accept2)) {
#line 1039
          goto while_break;
        }
      } else {
#line 1039
        goto while_break;
      }
    } else {
#line 1039
      goto while_break;
    }
#line 1040
    __s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1041
  if ((int const   )*__s == 0) {
#line 1041
    tmp = (char *)((void *)0);
  } else {
#line 1041
    tmp = (char *)((size_t )__s);
  }
#line 1041
  return (tmp);
}
}
#line 1044
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1046 "/usr/include/bits/string2.h"
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  char *tmp ;

  {
  {
  {
#line 1051
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1051
    if ((int const   )*__s != 0) {
#line 1051
      if ((int const   )*__s != (int const   )__accept1) {
#line 1051
        if ((int const   )*__s != (int const   )__accept2) {
#line 1051
          if (! ((int const   )*__s != (int const   )__accept3)) {
#line 1051
            goto while_break;
          }
        } else {
#line 1051
          goto while_break;
        }
      } else {
#line 1051
        goto while_break;
      }
    } else {
#line 1051
      goto while_break;
    }
#line 1053
    __s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1054
  if ((int const   )*__s == 0) {
#line 1054
    tmp = (char *)((void *)0);
  } else {
#line 1054
    tmp = (char *)((size_t )__s);
  }
#line 1054
  return (tmp);
}
}
#line 1085
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
#line 1086 "/usr/include/bits/string2.h"
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) 
{ 
  char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1090
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
#line 1091
    __s = *__nextp;
  }
  {
  {
#line 1092
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1092
    if (! ((int )*__s == (int )__sep)) {
#line 1092
      goto while_break;
    }
#line 1093
    __s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1094
  __result = (char *)((void *)0);
#line 1095
  if ((int )*__s != 0) {
#line 1097
    tmp = __s;
#line 1097
    __s ++;
#line 1097
    __result = tmp;
    {
    {
#line 1098
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1098
      if (! ((int )*__s != 0)) {
#line 1098
        goto while_break___0;
      }
#line 1099
      tmp___0 = __s;
#line 1099
      __s ++;
#line 1099
      if ((int )*tmp___0 == (int )__sep) {
#line 1101
        *(__s + -1) = (char )'\000';
#line 1102
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1104
    *__nextp = __s;
  }
#line 1106
  return (__result);
}
}
#line 1135
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
#line 1136 "/usr/include/bits/string2.h"
__inline extern char *__strsep_1c(char **__s , char __reject ) 
{ 
  register char *__retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;

  {
#line 1139
  __retval = *__s;
#line 1140
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
    {
    {
#line 1140
    tmp___2 = strchr((char const   *)__retval, (int )__reject);
    }
#line 1140
    tmp___0 = tmp___2;
#line 1140
    *__s = tmp___0;
    }
#line 1140
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1141
      tmp = *__s;
#line 1141
      (*__s) ++;
#line 1141
      *tmp = (char )'\000';
    }
  }
#line 1142
  return (__retval);
}
}
#line 1145
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
#line 1146 "/usr/include/bits/string2.h"
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1149
  __retval = *__s;
#line 1150
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1152
    __cp = __retval;
    {
    {
#line 1153
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1155
      if ((int )*__cp == 0) {
#line 1157
        __cp = (char *)((void *)0);
#line 1158
        goto while_break;
      }
#line 1160
      if ((int )*__cp == (int )__reject1) {
#line 1162
        tmp = __cp;
#line 1162
        __cp ++;
#line 1162
        *tmp = (char )'\000';
#line 1163
        goto while_break;
      } else
#line 1160
      if ((int )*__cp == (int )__reject2) {
#line 1162
        tmp = __cp;
#line 1162
        __cp ++;
#line 1162
        *tmp = (char )'\000';
#line 1163
        goto while_break;
      }
#line 1165
      __cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1167
    *__s = __cp;
  }
#line 1169
  return (__retval);
}
}
#line 1172
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
#line 1174 "/usr/include/bits/string2.h"
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1177
  __retval = *__s;
#line 1178
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1180
    __cp = __retval;
    {
    {
#line 1181
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1183
      if ((int )*__cp == 0) {
#line 1185
        __cp = (char *)((void *)0);
#line 1186
        goto while_break;
      }
#line 1188
      if ((int )*__cp == (int )__reject1) {
#line 1190
        tmp = __cp;
#line 1190
        __cp ++;
#line 1190
        *tmp = (char )'\000';
#line 1191
        goto while_break;
      } else
#line 1188
      if ((int )*__cp == (int )__reject2) {
#line 1190
        tmp = __cp;
#line 1190
        __cp ++;
#line 1190
        *tmp = (char )'\000';
#line 1191
        goto while_break;
      } else
#line 1188
      if ((int )*__cp == (int )__reject3) {
#line 1190
        tmp = __cp;
#line 1190
        __cp ++;
#line 1190
        *tmp = (char )'\000';
#line 1191
        goto while_break;
      }
#line 1193
      __cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1195
    *__s = __cp;
  }
#line 1197
  return (__retval);
}
}
#line 115 "gzip.h"
uch inbuf[32832] ;
#line 116
uch outbuf[18432] ;
#line 117
ush d_buf[32768] ;
#line 118
uch window[65536L] ;
#line 123
ush prev[1L << 16] ;
#line 131
unsigned int insize ;
#line 132
unsigned int inptr ;
#line 142
int ifd ;
#line 143
int ofd ;
#line 198
int test ;
#line 273
int unlzh(int in , int out ) ;
#line 299
int fill_inbuf(int eof_ok ) ;
#line 302
void write_buf(int fd , voidp buf , unsigned int cnt ) ;
#line 307
void error(char *m ) ;
#line 18 "unlzh.c"
static unsigned int decode(unsigned int count , uch *buffer ) ;
#line 19
static void decode_start(void) ;
#line 22
static void huf_decode_start(void) ;
#line 23
static unsigned int decode_c(void) ;
#line 24
static unsigned int decode_p(void) ;
#line 25
static void read_pt_len(int nn , int nbit , int i_special ) ;
#line 26
static void read_c_len(void) ;
#line 29
static void fillbuf(int n ) ;
#line 30
static unsigned int getbits(int n ) ;
#line 31
static void init_getbits(void) ;
#line 35
static void make_table(int nchar , uch *bitlen , int tablebits , ush *table ) ;
#line 91 "unlzh.c"
static uch pt_len[19]  ;
#line 92 "unlzh.c"
static unsigned int blocksize  ;
#line 93 "unlzh.c"
static ush pt_table[256]  ;
#line 105 "unlzh.c"
static ush bitbuf  ;
#line 106 "unlzh.c"
static unsigned int subbitbuf  ;
#line 107 "unlzh.c"
static int bitcount  ;
#line 109 "unlzh.c"
static void fillbuf(int n ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 112
  bitbuf = (ush )((int )bitbuf << n);
  {
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 113
    if (! (n > bitcount)) {
#line 113
      goto while_break;
    }
#line 114
    n -= bitcount;
#line 114
    bitbuf = (ush )((unsigned int )bitbuf | (subbitbuf << n));
#line 115
    if (inptr < insize) {
#line 115
      tmp = inptr;
#line 115
      inptr ++;
#line 115
      tmp___1 = (int )inbuf[tmp];
    } else {
      {
      {
#line 115
      tmp___0 = fill_inbuf(1);
      }
#line 115
      tmp___1 = tmp___0;
      }
    }
#line 115
    subbitbuf = (unsigned int )tmp___1;
#line 116
    if ((int )subbitbuf == -1) {
#line 116
      subbitbuf = 0U;
    }
#line 117
    bitcount = 8;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  bitcount -= n;
#line 119
  bitbuf = (ush )((unsigned int )bitbuf | (subbitbuf >> bitcount));
#line 120
  return;
}
}
#line 122 "unlzh.c"
static unsigned int getbits(int n ) 
{ 
  unsigned int x ;

  {
  {
#line 127
  x = (unsigned int )((int )bitbuf >> (16UL * sizeof(char ) - (unsigned long )n));
  {
#line 127
  fillbuf(n);
  }
  }
#line 128
  return (x);
}
}
#line 131 "unlzh.c"
static void init_getbits(void) 
{ 


  {
  {
#line 133
  bitbuf = (ush )0;
#line 133
  subbitbuf = 0U;
#line 133
  bitcount = 0;
  {
#line 134
  fillbuf((int )(16UL * sizeof(char )));
  }
  }
#line 135
  return;
}
}
#line 141 "unlzh.c"
static void make_table(int nchar , uch *bitlen , int tablebits , ush *table ) 
{ 
  ush count[17] ;
  ush weight[17] ;
  ush start[18] ;
  ush *p ;
  unsigned int i___0 ;
  unsigned int k ;
  unsigned int len ;
  unsigned int ch ;
  unsigned int jutbits ;
  unsigned int avail ;
  unsigned int nextcode ;
  unsigned int mask ;
  unsigned int tmp ;
  ush tmp___0 ;
  unsigned int tmp___1 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 150
  i___0 = 1U;
  {
  {
#line 150
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i___0 <= 16U)) {
#line 150
      goto while_break;
    }
#line 150
    count[i___0] = (ush )0;
#line 150
    i___0 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  i___0 = 0U;
  {
  {
#line 151
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 151
    if (! (i___0 < (unsigned int )nchar)) {
#line 151
      goto while_break___0;
    }
#line 151
    count[*(bitlen + i___0)] = (ush )((int )count[*(bitlen + i___0)] + 1);
#line 151
    i___0 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  start[1] = (ush )0;
#line 154
  i___0 = 1U;
  {
  {
#line 154
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 154
    if (! (i___0 <= 16U)) {
#line 154
      goto while_break___1;
    }
#line 155
    start[i___0 + 1U] = (ush )((int )start[i___0] + ((int )count[i___0] << (16U - i___0)));
#line 154
    i___0 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 156
  if (((int )start[17] & 65535) != 0) {
    {
    {
#line 157
    error((char *)"Bad table\n");
    }
    }
  }
#line 159
  jutbits = (unsigned int )(16 - tablebits);
#line 160
  i___0 = 1U;
  {
  {
#line 160
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 160
    if (! (i___0 <= (unsigned int )tablebits)) {
#line 160
      goto while_break___2;
    }
#line 161
    start[i___0] = (ush )((int )start[i___0] >> jutbits);
#line 162
    weight[i___0] = (ush )(1U << ((unsigned int )tablebits - i___0));
#line 160
    i___0 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 164
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 164
    if (! (i___0 <= 16U)) {
#line 164
      goto while_break___3;
    }
#line 165
    weight[i___0] = (ush )(1U << (16U - i___0));
#line 166
    i___0 ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 169
  i___0 = (unsigned int )((int )start[tablebits + 1] >> jutbits);
#line 170
  if (i___0 != 0U) {
#line 171
    k = (unsigned int )(1 << tablebits);
    {
    {
#line 172
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 172
      if (! (i___0 != k)) {
#line 172
        goto while_break___4;
      }
#line 172
      tmp = i___0;
#line 172
      i___0 ++;
#line 172
      *(table + tmp) = (ush )0;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 175
  avail = (unsigned int )nchar;
#line 176
  mask = 1U << (15 - tablebits);
#line 177
  ch = 0U;
  {
  {
#line 177
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 177
    if (! (ch < (unsigned int )nchar)) {
#line 177
      goto while_break___5;
    }
#line 178
    len = (unsigned int )*(bitlen + ch);
#line 178
    if (len == 0U) {
#line 178
      goto __Cont;
    }
#line 179
    nextcode = (unsigned int )((int )start[len] + (int )weight[len]);
#line 180
    if (len <= (unsigned int )tablebits) {
#line 181
      i___0 = (unsigned int )start[len];
      {
      {
#line 181
      while (1) {
        while_continue___15: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 181
        if (! (i___0 < nextcode)) {
#line 181
          goto while_break___6;
        }
#line 181
        *(table + i___0) = (ush )ch;
#line 181
        i___0 ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {
#line 183
      k = (unsigned int )start[len];
#line 184
      p = table + (k >> jutbits);
#line 185
      i___0 = len - (unsigned int )tablebits;
      {
      {
#line 186
      while (1) {
        while_continue___16: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 186
        if (! (i___0 != 0U)) {
#line 186
          goto while_break___7;
        }
#line 187
        if ((int )*p == 0) {
#line 188
          tmp___0 = (ush )0;
#line 188
          prev[avail] = tmp___0;
#line 188
          *((prev + 32768) + avail) = tmp___0;
#line 189
          tmp___1 = avail;
#line 189
          avail ++;
#line 189
          *p = (ush )tmp___1;
        }
#line 191
        if (k & mask) {
#line 191
          p = (prev + 32768) + *p;
        } else {
#line 192
          p = & prev[*p];
        }
#line 193
        k <<= 1;
#line 193
        i___0 --;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 195
      *p = (ush )ch;
    }
#line 197
    start[len] = (ush )nextcode;
    __Cont: /* CIL Label */ 
#line 177
    ch ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 199
  return;
}
}
#line 205 "unlzh.c"
static void read_pt_len(int nn , int nbit , int i_special ) 
{ 
  int i___0 ;
  int c ;
  int n ;
  unsigned int mask ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  {
#line 213
  tmp = getbits(nbit);
  }
#line 213
  n = (int )tmp;
  }
#line 214
  if (n == 0) {
    {
    {
#line 215
    tmp___0 = getbits(nbit);
    }
#line 215
    c = (int )tmp___0;
#line 216
    i___0 = 0;
    }
    {
    {
#line 216
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 216
      if (! (i___0 < nn)) {
#line 216
        goto while_break;
      }
#line 216
      pt_len[i___0] = (uch )0;
#line 216
      i___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 217
    i___0 = 0;
    {
    {
#line 217
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 217
      if (! (i___0 < 256)) {
#line 217
        goto while_break___0;
      }
#line 217
      pt_table[i___0] = (ush )c;
#line 217
      i___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 219
    i___0 = 0;
    {
    {
#line 220
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 220
      if (! (i___0 < n)) {
#line 220
        goto while_break___1;
      }
#line 221
      c = (int )bitbuf >> (16UL * sizeof(char ) - 3UL);
#line 222
      if (c == 7) {
#line 223
        mask = 1U << ((16UL * sizeof(char ) - 1UL) - 3UL);
        {
        {
#line 224
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 224
          if (! (mask & (unsigned int )bitbuf)) {
#line 224
            goto while_break___2;
          }
#line 224
          mask >>= 1;
#line 224
          c ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 226
      if (c < 7) {
#line 226
        tmp___1 = 3;
      } else {
#line 226
        tmp___1 = c - 3;
      }
      {
      {
#line 226
      fillbuf(tmp___1);
      }
#line 227
      tmp___2 = i___0;
#line 227
      i___0 ++;
#line 227
      pt_len[tmp___2] = (uch )c;
      }
#line 228
      if (i___0 == i_special) {
        {
        {
#line 229
        tmp___3 = getbits(2);
        }
#line 229
        c = (int )tmp___3;
        }
        {
        {
#line 230
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 230
          c --;
#line 230
          if (! (c >= 0)) {
#line 230
            goto while_break___3;
          }
#line 230
          tmp___4 = i___0;
#line 230
          i___0 ++;
#line 230
          pt_len[tmp___4] = (uch )0;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 233
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 233
      if (! (i___0 < nn)) {
#line 233
        goto while_break___4;
      }
#line 233
      tmp___5 = i___0;
#line 233
      i___0 ++;
#line 233
      pt_len[tmp___5] = (uch )0;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
    {
#line 234
    make_table(nn, pt_len, 8, pt_table);
    }
    }
  }
#line 236
  return;
}
}
#line 238 "unlzh.c"
static void read_c_len(void) 
{ 
  int i___0 ;
  int c ;
  int n ;
  unsigned int mask ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  {
#line 243
  tmp = getbits(9);
  }
#line 243
  n = (int )tmp;
  }
#line 244
  if (n == 0) {
    {
    {
#line 245
    tmp___0 = getbits(9);
    }
#line 245
    c = (int )tmp___0;
#line 246
    i___0 = 0;
    }
    {
    {
#line 246
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 246
      if (! (i___0 < 510)) {
#line 246
        goto while_break;
      }
#line 246
      outbuf[i___0] = (uch )0;
#line 246
      i___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 247
    i___0 = 0;
    {
    {
#line 247
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 247
      if (! (i___0 < 4096)) {
#line 247
        goto while_break___0;
      }
#line 247
      d_buf[i___0] = (ush )c;
#line 247
      i___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 249
    i___0 = 0;
    {
    {
#line 250
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 250
      if (! (i___0 < n)) {
#line 250
        goto while_break___1;
      }
#line 251
      c = (int )pt_table[(int )bitbuf >> (16UL * sizeof(char ) - 8UL)];
#line 252
      if (c >= 19) {
#line 253
        mask = 1U << ((16UL * sizeof(char ) - 1UL) - 8UL);
        {
        {
#line 254
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 255
          if ((unsigned int )bitbuf & mask) {
#line 255
            c = (int )*((prev + 32768) + c);
          } else {
#line 256
            c = (int )prev[c];
          }
#line 257
          mask >>= 1;
#line 254
          if (! (c >= 19)) {
#line 254
            goto while_break___2;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
      {
#line 260
      fillbuf((int )pt_len[c]);
      }
      }
#line 261
      if (c <= 2) {
#line 262
        if (c == 0) {
#line 262
          c = 1;
        } else
#line 263
        if (c == 1) {
          {
          {
#line 263
          tmp___1 = getbits(4);
          }
#line 263
          c = (int )(tmp___1 + 3U);
          }
        } else {
          {
          {
#line 264
          tmp___2 = getbits(9);
          }
#line 264
          c = (int )(tmp___2 + 20U);
          }
        }
        {
        {
#line 265
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 265
          c --;
#line 265
          if (! (c >= 0)) {
#line 265
            goto while_break___3;
          }
#line 265
          tmp___3 = i___0;
#line 265
          i___0 ++;
#line 265
          outbuf[tmp___3] = (uch )0;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 266
        tmp___4 = i___0;
#line 266
        i___0 ++;
#line 266
        outbuf[tmp___4] = (uch )(c - 2);
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 268
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 268
      if (! (i___0 < 510)) {
#line 268
        goto while_break___4;
      }
#line 268
      tmp___5 = i___0;
#line 268
      i___0 ++;
#line 268
      outbuf[tmp___5] = (uch )0;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
    {
#line 269
    make_table(510, outbuf, 12, d_buf);
    }
    }
  }
#line 271
  return;
}
}
#line 273 "unlzh.c"
static unsigned int decode_c(void) 
{ 
  unsigned int j___0 ;
  unsigned int mask ;

  {
#line 277
  if (blocksize == 0U) {
    {
    {
#line 278
    blocksize = getbits(16);
    }
    }
#line 279
    if (blocksize == 0U) {
#line 280
      return (510U);
    }
    {
    {
#line 282
    read_pt_len(19, 5, 3);
    }
    {
#line 283
    read_c_len();
    }
    {
#line 284
    read_pt_len(14, 4, -1);
    }
    }
  }
#line 286
  blocksize --;
#line 287
  j___0 = (unsigned int )d_buf[(int )bitbuf >> (16UL * sizeof(char ) - 12UL)];
#line 288
  if (j___0 >= 510U) {
#line 289
    mask = 1U << ((16UL * sizeof(char ) - 1UL) - 12UL);
    {
    {
#line 290
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 291
      if ((unsigned int )bitbuf & mask) {
#line 291
        j___0 = (unsigned int )*((prev + 32768) + j___0);
      } else {
#line 292
        j___0 = (unsigned int )prev[j___0];
      }
#line 293
      mask >>= 1;
#line 290
      if (! (j___0 >= 510U)) {
#line 290
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 296
  fillbuf((int )outbuf[j___0]);
  }
  }
#line 297
  return (j___0);
}
}
#line 300 "unlzh.c"
static unsigned int decode_p(void) 
{ 
  unsigned int j___0 ;
  unsigned int mask ;
  unsigned int tmp ;

  {
#line 304
  j___0 = (unsigned int )pt_table[(int )bitbuf >> (16UL * sizeof(char ) - 8UL)];
#line 305
  if (j___0 >= 14U) {
#line 306
    mask = 1U << ((16UL * sizeof(char ) - 1UL) - 8UL);
    {
    {
#line 307
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 308
      if ((unsigned int )bitbuf & mask) {
#line 308
        j___0 = (unsigned int )*((prev + 32768) + j___0);
      } else {
#line 309
        j___0 = (unsigned int )prev[j___0];
      }
#line 310
      mask >>= 1;
#line 307
      if (! (j___0 >= 14U)) {
#line 307
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 313
  fillbuf((int )pt_len[j___0]);
  }
  }
#line 314
  if (j___0 != 0U) {
    {
    {
#line 314
    tmp = getbits((int )(j___0 - 1U));
    }
#line 314
    j___0 = (1U << (j___0 - 1U)) + tmp;
    }
  }
#line 315
  return (j___0);
}
}
#line 318 "unlzh.c"
static void huf_decode_start(void) 
{ 


  {
  {
  {
#line 320
  init_getbits();
  }
#line 320
  blocksize = 0U;
  }
#line 321
  return;
}
}
#line 327 "unlzh.c"
static int j  ;
#line 328 "unlzh.c"
static int done  ;
#line 330 "unlzh.c"
static void decode_start(void) 
{ 


  {
  {
  {
#line 332
  huf_decode_start();
  }
#line 333
  j = 0;
#line 334
  done = 0;
  }
#line 335
  return;
}
}
#line 351 "unlzh.c"
static unsigned int i  ;
#line 339 "unlzh.c"
static unsigned int decode(unsigned int count , uch *buffer ) 
{ 
  unsigned int r ;
  unsigned int c ;
  unsigned int tmp ;

  {
#line 354
  r = 0U;
  {
  {
#line 355
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 355
    j --;
#line 355
    if (! (j >= 0)) {
#line 355
      goto while_break;
    }
#line 356
    *(buffer + r) = *(buffer + i);
#line 357
    i = (i + 1U) & ((1U << 13) - 1U);
#line 358
    r ++;
#line 358
    if (r == count) {
#line 358
      return (r);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 360
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 361
    c = decode_c();
    }
    }
#line 362
    if (c == 510U) {
#line 363
      done = 1;
#line 364
      return (r);
    }
#line 366
    if (c <= 255U) {
#line 367
      *(buffer + r) = (uch )c;
#line 368
      r ++;
#line 368
      if (r == count) {
#line 368
        return (r);
      }
    } else {
      {
#line 370
      j = (int )(c - 253U);
      {
#line 371
      tmp = decode_p();
      }
#line 371
      i = ((r - tmp) - 1U) & ((1U << 13) - 1U);
      }
      {
      {
#line 372
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 372
        j --;
#line 372
        if (! (j >= 0)) {
#line 372
          goto while_break___1;
        }
#line 373
        *(buffer + r) = *(buffer + i);
#line 374
        i = (i + 1U) & ((1U << 13) - 1U);
#line 375
        r ++;
#line 375
        if (r == count) {
#line 375
          return (r);
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 385 "unlzh.c"
int unlzh(int in , int out ) 
{ 
  unsigned int n ;

  {
  {
#line 390
  ifd = in;
#line 391
  ofd = out;
  {
#line 393
  decode_start();
  }
  }
  {
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 394
    if (! (! done)) {
#line 394
      goto while_break;
    }
    {
    {
#line 395
    n = decode(1U << 13, window);
    }
    }
#line 396
    if (! test) {
#line 396
      if (n > 0U) {
        {
        {
#line 397
        write_buf(out, (voidp )((char *)(window)), n);
        }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return (0);
}
}
#line 133 "gzip.h"
unsigned int outcnt ;
#line 136
long bytes_out ;
#line 270
int unpack(int in , int out ) ;
#line 301
void flush_window(void) ;
#line 32 "unpack.c"
static ulg orig_len  ;
#line 33 "unpack.c"
static int max_len  ;
#line 35 "unpack.c"
static uch literal[256]  ;
#line 40 "unpack.c"
static int lit_base[26]  ;
#line 46 "unpack.c"
static int leaves[26]  ;
#line 47 "unpack.c"
static int parents[26]  ;
#line 49 "unpack.c"
static int peek_bits  ;
#line 64 "unpack.c"
static ulg bitbuf___0  ;
#line 67 "unpack.c"
static int valid  ;
#line 88
static void read_tree(void) ;
#line 89
static void build_tree(void) ;
#line 94 "unpack.c"
static void read_tree(void) 
{ 
  int len ;
  int base ;
  int n ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 101
  orig_len = (ulg )0;
#line 102
  n = 1;
  {
  {
#line 102
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 102
    if (! (n <= 4)) {
#line 102
      goto while_break;
    }
#line 102
    if (inptr < insize) {
#line 102
      tmp = inptr;
#line 102
      inptr ++;
#line 102
      tmp___1 = (int )inbuf[tmp];
    } else {
      {
      {
#line 102
      tmp___0 = fill_inbuf(0);
      }
#line 102
      tmp___1 = tmp___0;
      }
    }
#line 102
    orig_len = (orig_len << 8) | (ulg )tmp___1;
#line 102
    n ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (inptr < insize) {
#line 104
    tmp___2 = inptr;
#line 104
    inptr ++;
#line 104
    tmp___4 = (int )inbuf[tmp___2];
  } else {
    {
    {
#line 104
    tmp___3 = fill_inbuf(0);
    }
#line 104
    tmp___4 = tmp___3;
    }
  }
#line 104
  max_len = tmp___4;
#line 105
  if (max_len > 25) {
    {
    {
#line 106
    error((char *)"invalid compressed data -- Huffman code > 32 bits");
    }
    }
  }
#line 110
  n = 0;
#line 111
  len = 1;
  {
  {
#line 111
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! (len <= max_len)) {
#line 111
      goto while_break___0;
    }
#line 112
    if (inptr < insize) {
#line 112
      tmp___5 = inptr;
#line 112
      inptr ++;
#line 112
      tmp___7 = (int )inbuf[tmp___5];
    } else {
      {
      {
#line 112
      tmp___6 = fill_inbuf(0);
      }
#line 112
      tmp___7 = tmp___6;
      }
    }
#line 112
    leaves[len] = tmp___7;
#line 113
    n += leaves[len];
#line 111
    len ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 115
  if (n > 256) {
    {
    {
#line 116
    error((char *)"too many leaves in Huffman tree");
    }
    }
  }
#line 127
  (leaves[max_len]) ++;
#line 130
  base = 0;
#line 131
  len = 1;
  {
  {
#line 131
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 131
    if (! (len <= max_len)) {
#line 131
      goto while_break___1;
    }
#line 133
    lit_base[len] = base;
#line 135
    n = leaves[len];
    {
    {
#line 135
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 135
      if (! (n > 0)) {
#line 135
        goto while_break___2;
      }
#line 136
      tmp___8 = base;
#line 136
      base ++;
#line 136
      if (inptr < insize) {
#line 136
        tmp___9 = inptr;
#line 136
        inptr ++;
#line 136
        tmp___11 = (int )inbuf[tmp___9];
      } else {
        {
        {
#line 136
        tmp___10 = fill_inbuf(0);
        }
#line 136
        tmp___11 = tmp___10;
        }
      }
#line 136
      literal[tmp___8] = (uch )tmp___11;
#line 135
      n --;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 131
    len ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 139
  (leaves[max_len]) ++;
#line 140
  return;
}
}
#line 145 "unpack.c"
static void build_tree(void) 
{ 
  int nodes ;
  int len ;
  uch *prefixp ;
  int prefixes ;
  int tmp ;

  {
#line 147
  nodes = 0;
#line 151
  len = max_len;
  {
  {
#line 151
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 151
    if (! (len >= 1)) {
#line 151
      goto while_break;
    }
#line 152
    nodes >>= 1;
#line 153
    parents[len] = nodes;
#line 154
    lit_base[len] -= nodes;
#line 155
    nodes += leaves[len];
#line 151
    len --;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  if (max_len <= 12) {
#line 158
    peek_bits = max_len;
  } else {
#line 158
    peek_bits = 12;
  }
#line 159
  prefixp = & outbuf[1 << peek_bits];
#line 160
  len = 1;
  {
  {
#line 160
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 160
    if (! (len <= peek_bits)) {
#line 160
      goto while_break___0;
    }
#line 161
    prefixes = leaves[len] << (peek_bits - len);
    {
    {
#line 162
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 162
      tmp = prefixes;
#line 162
      prefixes --;
#line 162
      if (! tmp) {
#line 162
        goto while_break___1;
      }
#line 162
      prefixp --;
#line 162
      *prefixp = (uch )len;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 160
    len ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 165
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 165
    if (! ((unsigned long )prefixp > (unsigned long )(outbuf))) {
#line 165
      goto while_break___2;
    }
#line 165
    prefixp --;
#line 165
    *prefixp = (uch )0;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 166
  return;
}
}
#line 185 "unpack.c"
int unpack(int in , int out ) 
{ 
  int len ;
  unsigned int eob ;
  register unsigned int peek ;
  unsigned int peek_mask ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ulg mask ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  char *__cil_tmp15 ;

  {
  {
#line 193
  ifd = in;
#line 194
  ofd = out;
  {
#line 196
  read_tree();
  }
  {
#line 197
  build_tree();
  }
#line 198
  valid = 0;
#line 198
  bitbuf___0 = (ulg )0;
#line 199
  peek_mask = (unsigned int )((1 << peek_bits) - 1);
#line 200
  eob = (unsigned int )(leaves[max_len] - 1);
  }
  {
  {
#line 202
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 203
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 203
      if (! (valid < peek_bits)) {
#line 203
        goto while_break___0;
      }
#line 203
      if (inptr < insize) {
#line 203
        tmp = inptr;
#line 203
        inptr ++;
#line 203
        tmp___1 = (int )inbuf[tmp];
      } else {
        {
        {
#line 203
        tmp___0 = fill_inbuf(0);
        }
#line 203
        tmp___1 = tmp___0;
        }
      }
#line 203
      bitbuf___0 = (bitbuf___0 << 8) | (ulg )tmp___1;
#line 203
      valid += 8;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 203
    peek = (unsigned int )((bitbuf___0 >> (valid - peek_bits)) & (unsigned long )peek_mask);
#line 204
    len = (int )outbuf[peek];
#line 205
    if (len > 0) {
#line 206
      peek >>= peek_bits - len;
    } else {
#line 208
      mask = (ulg )peek_mask;
#line 209
      len = peek_bits;
      {
      {
#line 210
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 211
        len ++;
#line 211
        mask = (mask << 1) + 1UL;
        {
        {
#line 212
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 212
          if (! (valid < len)) {
#line 212
            goto while_break___2;
          }
#line 212
          if (inptr < insize) {
#line 212
            tmp___2 = inptr;
#line 212
            inptr ++;
#line 212
            tmp___4 = (int )inbuf[tmp___2];
          } else {
            {
            {
#line 212
            tmp___3 = fill_inbuf(0);
            }
#line 212
            tmp___4 = tmp___3;
            }
          }
#line 212
          bitbuf___0 = (bitbuf___0 << 8) | (ulg )tmp___4;
#line 212
          valid += 8;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 212
        peek = (unsigned int )((bitbuf___0 >> (valid - len)) & mask);
#line 210
        if (! (peek < (unsigned int )parents[len])) {
#line 210
          goto while_break___1;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 217
    if (peek == eob) {
#line 217
      if (len == max_len) {
#line 217
        goto while_break;
      }
    }
#line 218
    tmp___5 = outcnt;
#line 218
    outcnt ++;
#line 218
    window[tmp___5] = literal[peek + (unsigned int )lit_base[len]];
#line 218
    if (outcnt == 32768U) {
      {
      {
#line 218
      flush_window();
      }
      }
    }
#line 221
    valid -= len;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 224
  flush_window();
  }
  }
#line 226
  if (orig_len != (ulg )bytes_out) {
    {
    {
#line 227
    error((char *)"invalid compressed data--length error");
    }
    }
  }
#line 229
  return (0);
}
}
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
#line 312 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 38 "/usr/include/string.h"
extern void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                    size_t __n ) ;
#line 135 "gzip.h"
long bytes_in ;
#line 144
char ifname[1024] ;
#line 146
char *progname ;
#line 194
int exit_code ;
#line 196
int quiet ;
#line 199
int to_stdout ;
#line 309
void read_error(void) ;
#line 38 "lzw.h"
int maxbits ;
#line 39
int block_mode ;
#line 42
int unlzw(int in , int out ) ;
#line 181 "unlzw.c"
int block_mode  =    128;
#line 192 "unlzw.c"
int unlzw(int in , int out ) 
{ 
  register char_type *stackp ;
  code_int code ;
  int finchar ;
  code_int oldcode ;
  code_int incode ;
  long inbits ;
  long posbits ;
  int outpos ;
  unsigned int bitmask ;
  code_int free_ent ;
  code_int maxcode ;
  code_int maxmaxcode ;
  int n_bits ;
  int rsize ;
  unsigned int tmp ;
  int tmp___0 ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_20 *__u ;
  __uint8_t __c ;
  register int i___0 ;
  int e ;
  int o ;
  register char_type *p ;
  int tmp___1 ;
  void *__s___2 ;
  void *__s___3 ;
  union __anonunion___u_21 *__u___0 ;
  __uint8_t __c___0 ;
  char const   *tmp___2 ;
  register int i___1 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 215
  if (inptr < insize) {
#line 215
    tmp = inptr;
#line 215
    inptr ++;
#line 215
    maxbits = (int )inbuf[tmp];
  } else {
    {
    {
#line 215
    tmp___0 = fill_inbuf(0);
    }
#line 215
    maxbits = tmp___0;
    }
  }
#line 216
  block_mode = maxbits & 128;
#line 217
  if ((maxbits & 96) != 0) {
#line 218
    if (! quiet) {
      {
      {
#line 218
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: warning, unknown flags 0x%x\n",
              progname, ifname, maxbits & 96);
      }
      }
    }
#line 218
    if (exit_code == 0) {
#line 218
      exit_code = 2;
    }
  }
#line 221
  maxbits &= 31;
#line 222
  maxmaxcode = 1L << maxbits;
#line 224
  if (maxbits > 16) {
    {
    {
#line 225
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: compressed with %d bits, can only handle %d bits\n",
            progname, ifname, maxbits, 16);
    }
#line 228
    exit_code = 1;
    }
#line 229
    return (1);
  }
#line 231
  rsize = (int )insize;
#line 232
  n_bits = 9;
#line 232
  maxcode = (1L << n_bits) - 1L;
#line 233
  bitmask = (unsigned int )((1 << n_bits) - 1);
#line 234
  oldcode = (code_int )-1;
#line 235
  finchar = 0;
#line 236
  outpos = 0;
#line 237
  posbits = (long )(inptr << 3);
#line 239
  if (block_mode) {
#line 239
    free_ent = (code_int )257;
  } else {
#line 239
    free_ent = (code_int )256;
  }
#line 241
  if (0) {
#line 241
    __s___0 = (voidp )(prev);
#line 241
    __u = (union __anonunion___u_20 *)__s___0;
#line 241
    __c = (__uint8_t )0;
    {
#line 241
    if (256U == 15U) {
#line 241
      goto case_15;
    }
#line 241
    if (256U == 11U) {
#line 241
      goto case_11;
    }
#line 241
    if (256U == 7U) {
#line 241
      goto case_7;
    }
#line 241
    if (256U == 3U) {
#line 241
      goto case_3;
    }
#line 241
    if (256U == 14U) {
#line 241
      goto case_14;
    }
#line 241
    if (256U == 10U) {
#line 241
      goto case_10;
    }
#line 241
    if (256U == 6U) {
#line 241
      goto case_6;
    }
#line 241
    if (256U == 2U) {
#line 241
      goto case_2;
    }
#line 241
    if (256U == 13U) {
#line 241
      goto case_13;
    }
#line 241
    if (256U == 9U) {
#line 241
      goto case_9;
    }
#line 241
    if (256U == 5U) {
#line 241
      goto case_5;
    }
#line 241
    if (256U == 1U) {
#line 241
      goto case_1;
    }
#line 241
    if (256U == 16U) {
#line 241
      goto case_16;
    }
#line 241
    if (256U == 12U) {
#line 241
      goto case_12;
    }
#line 241
    if (256U == 8U) {
#line 241
      goto case_8;
    }
#line 241
    if (256U == 4U) {
#line 241
      goto case_4;
    }
#line 241
    if (256U == 0U) {
#line 241
      goto case_0;
    }
#line 241
    goto switch_break;
    case_15: /* CIL Label */ 
#line 241
    __u->__ui = (unsigned int )((int )__c * 16843009);
#line 241
    __u = (union __anonunion___u_20 *)((void *)__u + 4);
    case_11: /* CIL Label */ 
#line 241
    __u->__ui = (unsigned int )((int )__c * 16843009);
#line 241
    __u = (union __anonunion___u_20 *)((void *)__u + 4);
    case_7: /* CIL Label */ 
#line 241
    __u->__ui = (unsigned int )((int )__c * 16843009);
#line 241
    __u = (union __anonunion___u_20 *)((void *)__u + 4);
    case_3: /* CIL Label */ 
#line 241
    __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 241
    __u = (union __anonunion___u_20 *)((void *)__u + 2);
#line 241
    __u->__uc = __c;
#line 241
    goto switch_break;
    case_14: /* CIL Label */ 
#line 241
    __u->__ui = (unsigned int )((int )__c * 16843009);
#line 241
    __u = (union __anonunion___u_20 *)((void *)__u + 4);
    case_10: /* CIL Label */ 
#line 241
    __u->__ui = (unsigned int )((int )__c * 16843009);
#line 241
    __u = (union __anonunion___u_20 *)((void *)__u + 4);
    case_6: /* CIL Label */ 
#line 241
    __u->__ui = (unsigned int )((int )__c * 16843009);
#line 241
    __u = (union __anonunion___u_20 *)((void *)__u + 4);
    case_2: /* CIL Label */ 
#line 241
    __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 241
    goto switch_break;
    case_13: /* CIL Label */ 
#line 241
    __u->__ui = (unsigned int )((int )__c * 16843009);
#line 241
    __u = (union __anonunion___u_20 *)((void *)__u + 4);
    case_9: /* CIL Label */ 
#line 241
    __u->__ui = (unsigned int )((int )__c * 16843009);
#line 241
    __u = (union __anonunion___u_20 *)((void *)__u + 4);
    case_5: /* CIL Label */ 
#line 241
    __u->__ui = (unsigned int )((int )__c * 16843009);
#line 241
    __u = (union __anonunion___u_20 *)((void *)__u + 4);
    case_1: /* CIL Label */ 
#line 241
    __u->__uc = __c;
#line 241
    goto switch_break;
    case_16: /* CIL Label */ 
#line 241
    __u->__ui = (unsigned int )((int )__c * 16843009);
#line 241
    __u = (union __anonunion___u_20 *)((void *)__u + 4);
    case_12: /* CIL Label */ 
#line 241
    __u->__ui = (unsigned int )((int )__c * 16843009);
#line 241
    __u = (union __anonunion___u_20 *)((void *)__u + 4);
    case_8: /* CIL Label */ 
#line 241
    __u->__ui = (unsigned int )((int )__c * 16843009);
#line 241
    __u = (union __anonunion___u_20 *)((void *)__u + 4);
    case_4: /* CIL Label */ 
#line 241
    __u->__ui = (unsigned int )((int )__c * 16843009);
    case_0: /* CIL Label */ 
#line 241
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 241
    __s = (voidp )(prev);
    {
#line 241
    __builtin_memset(__s, '\000', 256);
    }
    }
  }
#line 243
  code = (code_int )255;
  {
  {
#line 243
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 243
    if (! (code >= 0L)) {
#line 243
      goto while_break;
    }
#line 244
    window[code] = (char_type )code;
#line 243
    code --;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 246
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    resetbuf: 
#line 252
    o = (int )(posbits >> 3);
#line 252
    e = (int )(insize - (unsigned int )o);
#line 254
    i___0 = 0;
    {
    {
#line 254
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 254
      if (! (i___0 < e)) {
#line 254
        goto while_break___1;
      }
#line 255
      inbuf[i___0] = inbuf[i___0 + o];
#line 254
      i___0 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 257
    insize = (unsigned int )e;
#line 258
    posbits = 0L;
#line 260
    if (insize < 64U) {
      {
      {
#line 261
      rsize = read(in, (void *)((char *)(inbuf) + insize), (size_t )32768);
      }
      }
#line 261
      if (rsize == -1) {
        {
        {
#line 262
        read_error();
        }
        }
      }
#line 264
      insize += (unsigned int )rsize;
#line 265
      bytes_in = (long )((ulg )bytes_in + (ulg )rsize);
    }
#line 267
    if (rsize != 0) {
#line 267
      inbits = ((long )insize - (long )(insize % (unsigned int )n_bits)) << 3;
    } else {
#line 267
      inbits = ((long )insize << 3) - (long )(n_bits - 1);
    }
    {
    {
#line 270
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 270
      if (! (inbits > posbits)) {
#line 270
        goto while_break___2;
      }
#line 271
      if (free_ent > maxcode) {
#line 272
        posbits = (posbits - 1L) + ((long )(n_bits << 3) - ((posbits - 1L) + (long )(n_bits << 3)) % (long )(n_bits << 3));
#line 274
        n_bits ++;
#line 275
        if (n_bits == maxbits) {
#line 276
          maxcode = maxmaxcode;
        } else {
#line 278
          maxcode = (1L << n_bits) - 1L;
        }
#line 280
        bitmask = (unsigned int )((1 << n_bits) - 1);
#line 281
        goto resetbuf;
      }
#line 283
      p = & inbuf[posbits >> 3];
#line 284
      code = ((((long )*(p + 0) | ((long )*(p + 1) << 8)) | ((long )*(p + 2) << 16)) >> (posbits & 7L)) & (long )bitmask;
#line 285
      posbits += (long )n_bits;
#line 288
      if (oldcode == -1L) {
#line 289
        if (code >= 256L) {
          {
          {
#line 289
          error((char *)"corrupt input.");
          }
          }
        }
#line 290
        tmp___1 = outpos;
#line 290
        outpos ++;
#line 290
        oldcode = code;
#line 290
        finchar = (int )oldcode;
#line 290
        outbuf[tmp___1] = (char_type )finchar;
#line 291
        goto while_continue___2;
      }
#line 293
      if (code == 256L) {
#line 293
        if (block_mode) {
#line 294
          if (0) {
#line 294
            __s___3 = (voidp )(prev);
#line 294
            __u___0 = (union __anonunion___u_21 *)__s___3;
#line 294
            __c___0 = (__uint8_t )0;
            {
#line 294
            if (256U == 15U) {
#line 294
              goto case_15___0;
            }
#line 294
            if (256U == 11U) {
#line 294
              goto case_11___0;
            }
#line 294
            if (256U == 7U) {
#line 294
              goto case_7___0;
            }
#line 294
            if (256U == 3U) {
#line 294
              goto case_3___0;
            }
#line 294
            if (256U == 14U) {
#line 294
              goto case_14___0;
            }
#line 294
            if (256U == 10U) {
#line 294
              goto case_10___0;
            }
#line 294
            if (256U == 6U) {
#line 294
              goto case_6___0;
            }
#line 294
            if (256U == 2U) {
#line 294
              goto case_2___0;
            }
#line 294
            if (256U == 13U) {
#line 294
              goto case_13___0;
            }
#line 294
            if (256U == 9U) {
#line 294
              goto case_9___0;
            }
#line 294
            if (256U == 5U) {
#line 294
              goto case_5___0;
            }
#line 294
            if (256U == 1U) {
#line 294
              goto case_1___0;
            }
#line 294
            if (256U == 16U) {
#line 294
              goto case_16___0;
            }
#line 294
            if (256U == 12U) {
#line 294
              goto case_12___0;
            }
#line 294
            if (256U == 8U) {
#line 294
              goto case_8___0;
            }
#line 294
            if (256U == 4U) {
#line 294
              goto case_4___0;
            }
#line 294
            if (256U == 0U) {
#line 294
              goto case_0___0;
            }
#line 294
            goto switch_break___0;
            case_15___0: /* CIL Label */ 
#line 294
            __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 294
            __u___0 = (union __anonunion___u_21 *)((void *)__u___0 + 4);
            case_11___0: /* CIL Label */ 
#line 294
            __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 294
            __u___0 = (union __anonunion___u_21 *)((void *)__u___0 + 4);
            case_7___0: /* CIL Label */ 
#line 294
            __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 294
            __u___0 = (union __anonunion___u_21 *)((void *)__u___0 + 4);
            case_3___0: /* CIL Label */ 
#line 294
            __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 294
            __u___0 = (union __anonunion___u_21 *)((void *)__u___0 + 2);
#line 294
            __u___0->__uc = __c___0;
#line 294
            goto switch_break___0;
            case_14___0: /* CIL Label */ 
#line 294
            __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 294
            __u___0 = (union __anonunion___u_21 *)((void *)__u___0 + 4);
            case_10___0: /* CIL Label */ 
#line 294
            __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 294
            __u___0 = (union __anonunion___u_21 *)((void *)__u___0 + 4);
            case_6___0: /* CIL Label */ 
#line 294
            __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 294
            __u___0 = (union __anonunion___u_21 *)((void *)__u___0 + 4);
            case_2___0: /* CIL Label */ 
#line 294
            __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 294
            goto switch_break___0;
            case_13___0: /* CIL Label */ 
#line 294
            __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 294
            __u___0 = (union __anonunion___u_21 *)((void *)__u___0 + 4);
            case_9___0: /* CIL Label */ 
#line 294
            __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 294
            __u___0 = (union __anonunion___u_21 *)((void *)__u___0 + 4);
            case_5___0: /* CIL Label */ 
#line 294
            __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 294
            __u___0 = (union __anonunion___u_21 *)((void *)__u___0 + 4);
            case_1___0: /* CIL Label */ 
#line 294
            __u___0->__uc = __c___0;
#line 294
            goto switch_break___0;
            case_16___0: /* CIL Label */ 
#line 294
            __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 294
            __u___0 = (union __anonunion___u_21 *)((void *)__u___0 + 4);
            case_12___0: /* CIL Label */ 
#line 294
            __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 294
            __u___0 = (union __anonunion___u_21 *)((void *)__u___0 + 4);
            case_8___0: /* CIL Label */ 
#line 294
            __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 294
            __u___0 = (union __anonunion___u_21 *)((void *)__u___0 + 4);
            case_4___0: /* CIL Label */ 
#line 294
            __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
            case_0___0: /* CIL Label */ 
#line 294
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          } else {
            {
#line 294
            __s___2 = (voidp )(prev);
            {
#line 294
            __builtin_memset(__s___2, '\000', 256);
            }
            }
          }
#line 295
          free_ent = (code_int )256;
#line 296
          posbits = (posbits - 1L) + ((long )(n_bits << 3) - ((posbits - 1L) + (long )(n_bits << 3)) % (long )(n_bits << 3));
#line 298
          n_bits = 9;
#line 298
          maxcode = (1L << n_bits) - 1L;
#line 299
          bitmask = (unsigned int )((1 << n_bits) - 1);
#line 300
          goto resetbuf;
        }
      }
#line 302
      incode = code;
#line 303
      stackp = (char_type *)(& d_buf[32767]);
#line 305
      if (code >= free_ent) {
#line 306
        if (code > free_ent) {
#line 317
          if (! test) {
#line 317
            if (outpos > 0) {
              {
              {
#line 318
              write_buf(out, (voidp )((char *)(outbuf)), (unsigned int )outpos);
              }
#line 319
              bytes_out = (long )((ulg )bytes_out + (ulg )outpos);
              }
            }
          }
#line 321
          if (to_stdout) {
#line 321
            tmp___2 = "corrupt input.";
          } else {
#line 321
            tmp___2 = "corrupt input. Use zcat to recover some data.";
          }
          {
          {
#line 321
          error((char *)tmp___2);
          }
          }
        }
#line 324
        stackp --;
#line 324
        *stackp = (char_type )finchar;
#line 325
        code = oldcode;
      }
      {
      {
#line 328
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 328
        if (! ((cmp_code_int )code >= 256UL)) {
#line 328
          goto while_break___3;
        }
#line 330
        stackp --;
#line 330
        *stackp = window[code];
#line 331
        code = (code_int )prev[code];
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 333
      stackp --;
#line 333
      finchar = (int )window[code];
#line 333
      *stackp = (char_type )finchar;
#line 339
      i___1 = (int )((char_type *)(& d_buf[32767]) - stackp);
#line 339
      if (outpos + i___1 >= 16384) {
        {
        {
#line 340
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 341
          if (i___1 > 16384 - outpos) {
#line 341
            i___1 = 16384 - outpos;
          }
#line 343
          if (i___1 > 0) {
            {
            {
#line 344
            memcpy((void */* __restrict  */)(outbuf + outpos), (void const   */* __restrict  */)stackp,
                   (size_t )i___1);
            }
#line 345
            outpos += i___1;
            }
          }
#line 347
          if (outpos >= 16384) {
#line 348
            if (! test) {
              {
              {
#line 349
              write_buf(out, (voidp )((char *)(outbuf)), (unsigned int )outpos);
              }
#line 350
              bytes_out = (long )((ulg )bytes_out + (ulg )outpos);
              }
            }
#line 352
            outpos = 0;
          }
#line 354
          stackp += i___1;
#line 340
          i___1 = (int )((char_type *)(& d_buf[32767]) - stackp);
#line 340
          if (! (i___1 > 0)) {
#line 340
            goto while_break___4;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 357
        memcpy((void */* __restrict  */)(outbuf + outpos), (void const   */* __restrict  */)stackp,
               (size_t )i___1);
        }
#line 358
        outpos += i___1;
        }
      }
#line 362
      code = free_ent;
#line 362
      if (code < maxmaxcode) {
#line 364
        prev[code] = (unsigned short )oldcode;
#line 365
        window[code] = (char_type )finchar;
#line 366
        free_ent = code + 1L;
      }
#line 368
      oldcode = incode;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 246
    if (! (rsize != 0)) {
#line 246
      goto while_break___0;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  if (! test) {
#line 372
    if (outpos > 0) {
      {
      {
#line 373
      write_buf(out, (voidp )((char *)(outbuf)), (unsigned int )outpos);
      }
#line 374
      bytes_out = (long )((ulg )bytes_out + (ulg )outpos);
      }
    }
  }
#line 376
  return (0);
}
}
#line 41 "lzw.h"
int lzw(int in , int out ) ;
#line 13 "lzw.c"
static int msg_done  =    0;
#line 16 "lzw.c"
int lzw(int in , int out ) 
{ 
  char *__cil_tmp3 ;

  {
#line 19
  if (msg_done) {
#line 19
    return (1);
  }
  {
#line 20
  msg_done = 1;
  {
#line 21
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output in compress .Z format not supported\n");
  }
  }
#line 22
  if (in != out) {
#line 23
    exit_code = 1;
  }
#line 25
  return (1);
}
}
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 116
__inline extern int tolower(int __c ) ;
#line 119
__inline extern int toupper(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
      {
      {
#line 193
      tmp = __ctype_tolower_loc();
      }
#line 193
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 193
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 193
    tmp___0 = (__int32_t const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 196 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
      {
      {
#line 199
      tmp = __ctype_toupper_loc();
      }
#line 199
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 199
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 199
    tmp___0 = (__int32_t const   )__c;
  }
#line 199
  return ((int )tmp___0);
}
}
#line 38 "/usr/include/bits/errno.h"
extern int *__errno_location(void)  __attribute__((__const__)) ;
#line 318 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 142 "/usr/include/stdlib.h"
__inline extern double atof(char const   *__nptr )  __attribute__((__pure__)) ;
#line 144
__inline extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
#line 146
__inline extern long atol(char const   *__nptr )  __attribute__((__pure__)) ;
#line 152
__inline extern long long atoll(char const   *__nptr )  __attribute__((__pure__)) ;
#line 159
__inline extern double strtod(char const   * __restrict  __nptr , char ** __restrict  __endptr ) ;
#line 176
__inline extern long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) ;
#line 179
__inline extern unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                      int __base ) ;
#line 187
__inline extern long long strtoq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                 int __base ) ;
#line 191
__inline extern unsigned long long strtouq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                           int __base ) ;
#line 200
__inline extern long long strtoll(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                  int __base ) ;
#line 204
__inline extern unsigned long long strtoull(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                            int __base ) ;
#line 264
extern double __strtod_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                int __group ) ;
#line 274
extern long __strtol_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                              int __base , int __group ) ;
#line 280
extern unsigned long __strtoul_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                        int __base , int __group ) ;
#line 288
extern long long __strtoll_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                    int __base , int __group ) ;
#line 295
extern unsigned long long __strtoull_internal(char const   * __restrict  __nptr ,
                                              char ** __restrict  __endptr , int __base ,
                                              int __group ) ;
#line 308 "/usr/include/stdlib.h"
__inline extern double strtod(char const   * __restrict  __nptr , char ** __restrict  __endptr ) 
{ 
  double tmp ;

  {
  {
  {
#line 311
  tmp = __strtod_internal(__nptr, __endptr, 0);
  }
  }
#line 311
  return (tmp);
}
}
#line 313 "/usr/include/stdlib.h"
__inline extern long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ 
  long tmp ;

  {
  {
  {
#line 317
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 317
  return (tmp);
}
}
#line 319 "/usr/include/stdlib.h"
__inline extern unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                      int __base ) 
{ 
  unsigned long tmp ;

  {
  {
  {
#line 323
  tmp = __strtoul_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 323
  return (tmp);
}
}
#line 343 "/usr/include/stdlib.h"
__inline extern long long strtoq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                 int __base ) 
{ 
  long long tmp ;

  {
  {
  {
#line 347
  tmp = __strtoll_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 347
  return (tmp);
}
}
#line 349 "/usr/include/stdlib.h"
__inline extern unsigned long long strtouq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                           int __base ) 
{ 
  unsigned long long tmp ;

  {
  {
  {
#line 353
  tmp = __strtoull_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 353
  return (tmp);
}
}
#line 375
__inline extern double atof(char const   *__nptr )  __attribute__((__pure__)) ;
#line 375 "/usr/include/stdlib.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double tmp ;

  {
  {
  {
#line 378
  tmp = strtod((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)));
  }
  }
#line 378
  return (tmp);
}
}
#line 380
__inline extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
#line 380 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
  {
#line 383
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
  }
#line 383
  return ((int )tmp);
}
}
#line 385
__inline extern long atol(char const   *__nptr )  __attribute__((__pure__)) ;
#line 385 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
  {
#line 388
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
  }
#line 388
  return (tmp);
}
}
#line 394
__inline extern long long atoll(char const   *__nptr )  __attribute__((__pure__)) ;
#line 394 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  {
  {
#line 397
  tmp = strtoq((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
  }
#line 397
  return (tmp);
}
}
#line 556
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 558
extern void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 569
extern void free(void *__ptr ) ;
#line 626
extern char *getenv(char const   *__name ) ;
#line 740 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 82 "/usr/include/string.h"
extern char *strcpy(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 164
extern char *strrchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 176
extern size_t strcspn(char const   *__s , char const   *__reject )  __attribute__((__pure__)) ;
#line 180
extern size_t strspn(char const   *__s , char const   *__accept )  __attribute__((__pure__)) ;
#line 230
extern size_t strlen(char const   *__s )  __attribute__((__pure__)) ;
#line 145 "gzip.h"
char ofname[1024] ;
#line 276
void abort_gzip(void) ;
#line 296
int copy(int in , int out ) ;
#line 297
ulg updcrc(uch *s , unsigned int n ) ;
#line 298
void clear_bufs(void) ;
#line 300
void flush_outbuf(void) ;
#line 303
char *strlwr(char *s ) ;
#line 304
char *basename(char *fname ) ;
#line 305
void make_simple_name(char *name ) ;
#line 306
char *add_envopt(int *argcp , char ***argvp , char *env___0 ) ;
#line 308
void warn(char *a , char *b ) ;
#line 310
void write_error(void) ;
#line 311
void display_ratio(long num , long den , FILE *file ) ;
#line 312
voidp xmalloc(unsigned int size ) ;
#line 33 "util.c"
ulg crc_32_tab[256] ;
#line 39 "util.c"
int copy(int in , int out ) 
{ 
  int *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;

  {
  {
  {
#line 42
  tmp = __errno_location();
  }
#line 42
  *tmp = 0;
  }
  {
  {
#line 43
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 43
    if (insize != 0U) {
#line 43
      if (! ((int )insize != -1)) {
#line 43
        goto while_break;
      }
    } else {
#line 43
      goto while_break;
    }
    {
    {
#line 44
    write_buf(out, (voidp )((char *)(inbuf)), insize);
    }
#line 45
    bytes_out += (long )insize;
    {
#line 46
    tmp___0 = read(in, (void *)((char *)(inbuf)), (size_t )32768);
    }
#line 46
    insize = (unsigned int )tmp___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  if ((int )insize == -1) {
    {
    {
#line 48
    tmp___1 = __errno_location();
    }
    }
#line 48
    if (*tmp___1 != 0) {
      {
      {
#line 49
      read_error();
      }
      }
    }
  }
#line 51
  bytes_in = bytes_out;
#line 52
  return (0);
}
}
#line 66 "util.c"
static ulg crc  =    (ulg )4294967295L;
#line 60 "util.c"
ulg updcrc(uch *s , unsigned int n ) 
{ 
  register ulg c ;
  uch *tmp ;

  {
#line 68
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 69
    c = (ulg )4294967295L;
  } else {
#line 71
    c = crc;
#line 72
    if (n) {
      {
      {
#line 72
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 73
        tmp = s;
#line 73
        s ++;
#line 73
        c = crc_32_tab[((int )c ^ (int )*tmp) & 255] ^ (c >> 8);
#line 72
        n --;
#line 72
        if (! n) {
#line 72
          goto while_break;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 76
  crc = c;
#line 77
  return (c ^ 4294967295UL);
}
}
#line 83 "util.c"
void clear_bufs(void) 
{ 


  {
#line 85
  outcnt = 0U;
#line 86
  inptr = 0U;
#line 86
  insize = inptr;
#line 87
  bytes_out = 0L;
#line 87
  bytes_in = bytes_out;
#line 88
  return;
}
}
#line 93 "util.c"
int fill_inbuf(int eof_ok ) 
{ 
  int len ;
  int *tmp ;

  {
  {
#line 99
  insize = 0U;
  {
#line 100
  tmp = __errno_location();
  }
#line 100
  *tmp = 0;
  }
  {
  {
#line 101
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 102
    len = read(ifd, (void *)((char *)(inbuf) + insize), 32768U - insize);
    }
    }
#line 103
    if (len == 0) {
#line 103
      goto while_break;
    } else
#line 103
    if (len == -1) {
#line 103
      goto while_break;
    }
#line 104
    insize += (unsigned int )len;
#line 101
    if (! (insize < 32768U)) {
#line 101
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if (insize == 0U) {
#line 108
    if (eof_ok) {
#line 108
      return (-1);
    }
    {
    {
#line 109
    read_error();
    }
    }
  }
#line 111
  bytes_in = (long )((ulg )bytes_in + (ulg )insize);
#line 112
  inptr = 1U;
#line 113
  return ((int )inbuf[0]);
}
}
#line 120 "util.c"
void flush_outbuf(void) 
{ 


  {
#line 122
  if (outcnt == 0U) {
#line 122
    return;
  }
  {
  {
#line 124
  write_buf(ofd, (voidp )((char *)(outbuf)), outcnt);
  }
#line 125
  bytes_out = (long )((ulg )bytes_out + (ulg )outcnt);
#line 126
  outcnt = 0U;
  }
#line 127
  return;
}
}
#line 133 "util.c"
void flush_window(void) 
{ 


  {
#line 135
  if (outcnt == 0U) {
#line 135
    return;
  }
  {
  {
#line 136
  updcrc(window, outcnt);
  }
  }
#line 138
  if (! test) {
    {
    {
#line 139
    write_buf(ofd, (voidp )((char *)(window)), outcnt);
    }
    }
  }
#line 141
  bytes_out = (long )((ulg )bytes_out + (ulg )outcnt);
#line 142
  outcnt = 0U;
#line 143
  return;
}
}
#line 149 "util.c"
void write_buf(int fd , voidp buf , unsigned int cnt ) 
{ 
  unsigned int n ;
  ssize_t tmp ;

  {
  {
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 156
    tmp = write(fd, (void const   *)buf, cnt);
    }
#line 156
    n = (unsigned int )tmp;
    }
#line 156
    if (! (n != cnt)) {
#line 156
      goto while_break;
    }
#line 157
    if (n == 4294967295U) {
      {
      {
#line 158
      write_error();
      }
      }
    }
#line 160
    cnt -= n;
#line 161
    buf = (voidp )((char *)buf + n);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return;
}
}
#line 168 "util.c"
char *strlwr(char *s ) 
{ 
  char *t ;
  unsigned short const   **tmp___0 ;

  {
#line 172
  t = s;
  {
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 172
    if (! *t) {
#line 172
      goto while_break;
    }
    {
    {
#line 172
    tmp___0 = __ctype_b_loc();
    }
    }
#line 172
    if ((int const   )*(*tmp___0 + (int )*t) & 256) {
#line 172
      *t = (char )(((int )*t - 65) + 97);
    } else {
#line 172
      *t = *t;
    }
#line 172
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (s);
}
}
#line 181 "util.c"
char *basename(char *fname ) 
{ 
  char *p ;

  {
  {
  {
#line 186
  p = strrchr((char const   *)fname, '/');
  }
  }
#line 186
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 186
    fname = p + 1;
  }
#line 197
  return (fname);
}
}
#line 208 "util.c"
void make_simple_name(char *name ) 
{ 
  char *p ;
  char *tmp ;

  {
  {
  {
#line 211
  tmp = strrchr((char const   *)name, '.');
  }
#line 211
  p = tmp;
  }
#line 212
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 212
    return;
  }
#line 213
  if ((unsigned long )p == (unsigned long )name) {
#line 213
    p ++;
  }
  {
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 215
    p --;
#line 215
    if ((int )*p == 46) {
#line 215
      *p = (char )'_';
    }
#line 214
    if (! ((unsigned long )p != (unsigned long )name)) {
#line 214
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 279 "util.c"
char *add_envopt(int *argcp , char ***argvp , char *env___0 ) 
{ 
  char *p ;
  char **oargv ;
  char **nargv ;
  int oargc ;
  int nargc ;
  char *tmp ;
  size_t tmp___0 ;
  voidp tmp___1 ;
  size_t tmp___10 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  char **tmp___24 ;
  char **tmp___25 ;
  size_t tmp___34 ;
  char **tmp___35 ;
  char *tmp___36 ;
  char **tmp___37 ;
  char **tmp___38 ;
  int tmp___39 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
  {
#line 287
  oargc = *argcp;
#line 288
  nargc = 0;
  {
#line 290
  tmp = getenv((char const   *)env___0);
  }
#line 290
  env___0 = tmp;
  }
#line 291
  if ((unsigned long )env___0 == (unsigned long )((void *)0)) {
#line 291
    return ((char *)((void *)0));
  }
  {
  {
#line 293
  tmp___0 = strlen((char const   *)env___0);
  }
  {
#line 293
  tmp___1 = xmalloc(tmp___0 + 1U);
  }
#line 293
  p = (char *)tmp___1;
  {
#line 294
  env___0 = strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)env___0);
  }
#line 296
  p = env___0;
  }
  {
  {
#line 296
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 296
    if (! *p) {
#line 296
      goto while_break;
    }
    {
    {
#line 297
    tmp___10 = strspn((char const   *)p, " \t");
    }
#line 297
    p += tmp___10;
    }
#line 298
    if ((int )*p == 0) {
#line 298
      goto while_break;
    }
    {
    {
#line 300
    tmp___20 = strcspn((char const   *)p, " \t");
    }
#line 300
    p += tmp___20;
    }
#line 301
    if (*p) {
#line 301
      tmp___21 = p;
#line 301
      p ++;
#line 301
      *tmp___21 = (char )'\000';
    }
#line 296
    nargc ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  if (nargc == 0) {
    {
    {
#line 304
    free((void *)env___0);
    }
    }
#line 305
    return ((char *)((void *)0));
  }
  {
#line 307
  *argcp += nargc;
  {
#line 309
  tmp___22 = calloc((size_t )(*argcp + 1), (size_t )sizeof(char *));
  }
#line 309
  nargv = (char **)tmp___22;
  }
#line 310
  if ((unsigned long )nargv == (unsigned long )((void *)0)) {
    {
    {
#line 310
    error((char *)"out of memory");
    }
    }
  }
#line 311
  oargv = *argvp;
#line 312
  *argvp = nargv;
#line 314
  tmp___23 = oargc;
#line 314
  oargc --;
#line 314
  if (tmp___23 < 0) {
    {
    {
#line 314
    error((char *)"argc<=0");
    }
    }
  }
#line 315
  tmp___24 = nargv;
#line 315
  nargv ++;
#line 315
  tmp___25 = oargv;
#line 315
  oargv ++;
#line 315
  *tmp___24 = *tmp___25;
#line 317
  p = env___0;
  {
  {
#line 317
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 317
    if (! (nargc > 0)) {
#line 317
      goto while_break___0;
    }
    {
    {
#line 318
    tmp___34 = strspn((char const   *)p, " \t");
    }
#line 318
    p += tmp___34;
#line 319
    tmp___35 = nargv;
#line 319
    nargv ++;
#line 319
    *tmp___35 = p;
    }
    {
    {
#line 320
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 320
      tmp___36 = p;
#line 320
      p ++;
#line 320
      if (! *tmp___36) {
#line 320
        goto while_break___1;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 317
    nargc --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 323
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 323
    tmp___39 = oargc;
#line 323
    oargc --;
#line 323
    if (! tmp___39) {
#line 323
      goto while_break___2;
    }
#line 323
    tmp___37 = nargv;
#line 323
    nargv ++;
#line 323
    tmp___38 = oargv;
#line 323
    oargv ++;
#line 323
    *tmp___37 = *tmp___38;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 324
  *nargv = (char *)((void *)0);
#line 325
  return (env___0);
}
}
#line 331 "util.c"
void error(char *m ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 334
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: %s\n",
          progname, ifname, m);
  }
  {
#line 335
  abort_gzip();
  }
  }
#line 336
  return;
}
}
#line 338 "util.c"
void warn(char *a , char *b ) 
{ 
  char *__cil_tmp3 ;

  {
#line 341
  if (! quiet) {
    {
    {
#line 341
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: warning: %s%s\n",
            progname, ifname, a, b);
    }
    }
  }
#line 341
  if (exit_code == 0) {
#line 341
    exit_code = 2;
  }
#line 342
  return;
}
}
#line 344 "util.c"
void read_error(void) 
{ 
  int *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 346
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: ",
          progname);
  }
  {
#line 347
  tmp = __errno_location();
  }
  }
#line 347
  if (*tmp != 0) {
    {
    {
#line 348
    perror((char const   *)(ifname));
    }
    }
  } else {
    {
    {
#line 350
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unexpected end of file\n",
            ifname);
    }
    }
  }
  {
  {
#line 352
  abort_gzip();
  }
  }
#line 353
  return;
}
}
#line 355 "util.c"
void write_error(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 357
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: ",
          progname);
  }
  {
#line 358
  perror((char const   *)(ofname));
  }
  {
#line 359
  abort_gzip();
  }
  }
#line 360
  return;
}
}
#line 365 "util.c"
void display_ratio(long num , long den , FILE *file ) 
{ 
  long ratio ;
  char *__cil_tmp5 ;

  {
#line 372
  if (den == 0L) {
#line 373
    ratio = 0L;
  } else
#line 374
  if (den < 2147483L) {
#line 375
    ratio = (1000L * num) / den;
  } else {
#line 377
    ratio = num / (den / 1000L);
  }
#line 379
  if (ratio < 0L) {
    {
    {
#line 380
    _IO_putc('-', file);
    }
#line 381
    ratio = - ratio;
    }
  } else {
    {
    {
#line 383
    _IO_putc(' ', file);
    }
    }
  }
  {
  {
#line 385
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%2ld.%1ld%%",
          ratio / 10L, ratio % 10L);
  }
  }
#line 386
  return;
}
}
#line 392 "util.c"
voidp xmalloc(unsigned int size ) 
{ 
  voidp cp ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 395
  tmp = malloc(size);
  }
#line 395
  cp = tmp;
  }
#line 397
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
    {
#line 397
    error((char *)"out of memory");
    }
    }
  }
#line 398
  return (cp);
}
}
#line 404 "util.c"
ulg crc_32_tab[256]  = 
#line 404
  {      (ulg )0L,      (ulg )1996959894L,      (ulg )3993919788L,      (ulg )2567524794L, 
        (ulg )124634137L,      (ulg )1886057615L,      (ulg )3915621685L,      (ulg )2657392035L, 
        (ulg )249268274L,      (ulg )2044508324L,      (ulg )3772115230L,      (ulg )2547177864L, 
        (ulg )162941995L,      (ulg )2125561021L,      (ulg )3887607047L,      (ulg )2428444049L, 
        (ulg )498536548L,      (ulg )1789927666L,      (ulg )4089016648L,      (ulg )2227061214L, 
        (ulg )450548861L,      (ulg )1843258603L,      (ulg )4107580753L,      (ulg )2211677639L, 
        (ulg )325883990L,      (ulg )1684777152L,      (ulg )4251122042L,      (ulg )2321926636L, 
        (ulg )335633487L,      (ulg )1661365465L,      (ulg )4195302755L,      (ulg )2366115317L, 
        (ulg )997073096L,      (ulg )1281953886L,      (ulg )3579855332L,      (ulg )2724688242L, 
        (ulg )1006888145L,      (ulg )1258607687L,      (ulg )3524101629L,      (ulg )2768942443L, 
        (ulg )901097722L,      (ulg )1119000684L,      (ulg )3686517206L,      (ulg )2898065728L, 
        (ulg )853044451L,      (ulg )1172266101L,      (ulg )3705015759L,      (ulg )2882616665L, 
        (ulg )651767980L,      (ulg )1373503546L,      (ulg )3369554304L,      (ulg )3218104598L, 
        (ulg )565507253L,      (ulg )1454621731L,      (ulg )3485111705L,      (ulg )3099436303L, 
        (ulg )671266974L,      (ulg )1594198024L,      (ulg )3322730930L,      (ulg )2970347812L, 
        (ulg )795835527L,      (ulg )1483230225L,      (ulg )3244367275L,      (ulg )3060149565L, 
        (ulg )1994146192L,      (ulg )31158534L,      (ulg )2563907772L,      (ulg )4023717930L, 
        (ulg )1907459465L,      (ulg )112637215L,      (ulg )2680153253L,      (ulg )3904427059L, 
        (ulg )2013776290L,      (ulg )251722036L,      (ulg )2517215374L,      (ulg )3775830040L, 
        (ulg )2137656763L,      (ulg )141376813L,      (ulg )2439277719L,      (ulg )3865271297L, 
        (ulg )1802195444L,      (ulg )476864866L,      (ulg )2238001368L,      (ulg )4066508878L, 
        (ulg )1812370925L,      (ulg )453092731L,      (ulg )2181625025L,      (ulg )4111451223L, 
        (ulg )1706088902L,      (ulg )314042704L,      (ulg )2344532202L,      (ulg )4240017532L, 
        (ulg )1658658271L,      (ulg )366619977L,      (ulg )2362670323L,      (ulg )4224994405L, 
        (ulg )1303535960L,      (ulg )984961486L,      (ulg )2747007092L,      (ulg )3569037538L, 
        (ulg )1256170817L,      (ulg )1037604311L,      (ulg )2765210733L,      (ulg )3554079995L, 
        (ulg )1131014506L,      (ulg )879679996L,      (ulg )2909243462L,      (ulg )3663771856L, 
        (ulg )1141124467L,      (ulg )855842277L,      (ulg )2852801631L,      (ulg )3708648649L, 
        (ulg )1342533948L,      (ulg )654459306L,      (ulg )3188396048L,      (ulg )3373015174L, 
        (ulg )1466479909L,      (ulg )544179635L,      (ulg )3110523913L,      (ulg )3462522015L, 
        (ulg )1591671054L,      (ulg )702138776L,      (ulg )2966460450L,      (ulg )3352799412L, 
        (ulg )1504918807L,      (ulg )783551873L,      (ulg )3082640443L,      (ulg )3233442989L, 
        (ulg )3988292384L,      (ulg )2596254646L,      (ulg )62317068L,      (ulg )1957810842L, 
        (ulg )3939845945L,      (ulg )2647816111L,      (ulg )81470997L,      (ulg )1943803523L, 
        (ulg )3814918930L,      (ulg )2489596804L,      (ulg )225274430L,      (ulg )2053790376L, 
        (ulg )3826175755L,      (ulg )2466906013L,      (ulg )167816743L,      (ulg )2097651377L, 
        (ulg )4027552580L,      (ulg )2265490386L,      (ulg )503444072L,      (ulg )1762050814L, 
        (ulg )4150417245L,      (ulg )2154129355L,      (ulg )426522225L,      (ulg )1852507879L, 
        (ulg )4275313526L,      (ulg )2312317920L,      (ulg )282753626L,      (ulg )1742555852L, 
        (ulg )4189708143L,      (ulg )2394877945L,      (ulg )397917763L,      (ulg )1622183637L, 
        (ulg )3604390888L,      (ulg )2714866558L,      (ulg )953729732L,      (ulg )1340076626L, 
        (ulg )3518719985L,      (ulg )2797360999L,      (ulg )1068828381L,      (ulg )1219638859L, 
        (ulg )3624741850L,      (ulg )2936675148L,      (ulg )906185462L,      (ulg )1090812512L, 
        (ulg )3747672003L,      (ulg )2825379669L,      (ulg )829329135L,      (ulg )1181335161L, 
        (ulg )3412177804L,      (ulg )3160834842L,      (ulg )628085408L,      (ulg )1382605366L, 
        (ulg )3423369109L,      (ulg )3138078467L,      (ulg )570562233L,      (ulg )1426400815L, 
        (ulg )3317316542L,      (ulg )2998733608L,      (ulg )733239954L,      (ulg )1555261956L, 
        (ulg )3268935591L,      (ulg )3050360625L,      (ulg )752459403L,      (ulg )1541320221L, 
        (ulg )2607071920L,      (ulg )3965973030L,      (ulg )1969922972L,      (ulg )40735498L, 
        (ulg )2617837225L,      (ulg )3943577151L,      (ulg )1913087877L,      (ulg )83908371L, 
        (ulg )2512341634L,      (ulg )3803740692L,      (ulg )2075208622L,      (ulg )213261112L, 
        (ulg )2463272603L,      (ulg )3855990285L,      (ulg )2094854071L,      (ulg )198958881L, 
        (ulg )2262029012L,      (ulg )4057260610L,      (ulg )1759359992L,      (ulg )534414190L, 
        (ulg )2176718541L,      (ulg )4139329115L,      (ulg )1873836001L,      (ulg )414664567L, 
        (ulg )2282248934L,      (ulg )4279200368L,      (ulg )1711684554L,      (ulg )285281116L, 
        (ulg )2405801727L,      (ulg )4167216745L,      (ulg )1634467795L,      (ulg )376229701L, 
        (ulg )2685067896L,      (ulg )3608007406L,      (ulg )1308918612L,      (ulg )956543938L, 
        (ulg )2808555105L,      (ulg )3495958263L,      (ulg )1231636301L,      (ulg )1047427035L, 
        (ulg )2932959818L,      (ulg )3654703836L,      (ulg )1088359270L,      (ulg )936918000L, 
        (ulg )2847714899L,      (ulg )3736837829L,      (ulg )1202900863L,      (ulg )817233897L, 
        (ulg )3183342108L,      (ulg )3401237130L,      (ulg )1404277552L,      (ulg )615818150L, 
        (ulg )3134207493L,      (ulg )3453421203L,      (ulg )1423857449L,      (ulg )601450431L, 
        (ulg )3009837614L,      (ulg )3294710456L,      (ulg )1567103746L,      (ulg )711928724L, 
        (ulg )3020668471L,      (ulg )3272380065L,      (ulg )1510334235L,      (ulg )755167117L};
#line 315 "gzip.h"
int inflate(void) ;
#line 132 "inflate.c"
int huft_build(unsigned int *b , unsigned int n , unsigned int s , ush *d , ush *e ,
               struct huft **t , int *m ) ;
#line 134
int huft_free(struct huft *t ) ;
#line 135
int inflate_codes(struct huft *tl , struct huft *td , int bl , int bd ) ;
#line 136
int inflate_stored(void) ;
#line 137
int inflate_fixed(void) ;
#line 138
int inflate_dynamic(void) ;
#line 139
int inflate_block(int *e ) ;
#line 156 "inflate.c"
static unsigned int border[19]  = 
#line 156
  {      16U,      17U,      18U,      0U, 
        8U,      7U,      9U,      6U, 
        10U,      5U,      11U,      4U, 
        12U,      3U,      13U,      2U, 
        14U,      1U,      15U};
#line 158 "inflate.c"
static ush cplens[31]  = 
#line 158
  {      (ush )3,      (ush )4,      (ush )5,      (ush )6, 
        (ush )7,      (ush )8,      (ush )9,      (ush )10, 
        (ush )11,      (ush )13,      (ush )15,      (ush )17, 
        (ush )19,      (ush )23,      (ush )27,      (ush )31, 
        (ush )35,      (ush )43,      (ush )51,      (ush )59, 
        (ush )67,      (ush )83,      (ush )99,      (ush )115, 
        (ush )131,      (ush )163,      (ush )195,      (ush )227, 
        (ush )258,      (ush )0,      (ush )0};
#line 162 "inflate.c"
static ush cplext[31]  = 
#line 162
  {      (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        (ush )1,      (ush )1,      (ush )1,      (ush )1, 
        (ush )2,      (ush )2,      (ush )2,      (ush )2, 
        (ush )3,      (ush )3,      (ush )3,      (ush )3, 
        (ush )4,      (ush )4,      (ush )4,      (ush )4, 
        (ush )5,      (ush )5,      (ush )5,      (ush )5, 
        (ush )0,      (ush )99,      (ush )99};
#line 165 "inflate.c"
static ush cpdist[30]  = 
#line 165
  {      (ush )1,      (ush )2,      (ush )3,      (ush )4, 
        (ush )5,      (ush )7,      (ush )9,      (ush )13, 
        (ush )17,      (ush )25,      (ush )33,      (ush )49, 
        (ush )65,      (ush )97,      (ush )129,      (ush )193, 
        (ush )257,      (ush )385,      (ush )513,      (ush )769, 
        (ush )1025,      (ush )1537,      (ush )2049,      (ush )3073, 
        (ush )4097,      (ush )6145,      (ush )8193,      (ush )12289, 
        (ush )16385,      (ush )24577};
#line 169 "inflate.c"
static ush cpdext[30]  = 
#line 169
  {      (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        (ush )1,      (ush )1,      (ush )2,      (ush )2, 
        (ush )3,      (ush )3,      (ush )4,      (ush )4, 
        (ush )5,      (ush )5,      (ush )6,      (ush )6, 
        (ush )7,      (ush )7,      (ush )8,      (ush )8, 
        (ush )9,      (ush )9,      (ush )10,      (ush )10, 
        (ush )11,      (ush )11,      (ush )12,      (ush )12, 
        (ush )13,      (ush )13};
#line 206 "inflate.c"
ulg bb  ;
#line 207 "inflate.c"
unsigned int bk  ;
#line 209 "inflate.c"
ush mask_bits[17]  = 
#line 209
  {      (ush )0,      (ush )1,      (ush )3,      (ush )7, 
        (ush )15,      (ush )31,      (ush )63,      (ush )127, 
        (ush )255,      (ush )511,      (ush )1023,      (ush )2047, 
        (ush )4095,      (ush )8191,      (ush )16383,      (ush )32767, 
        (ush )65535};
#line 259 "inflate.c"
int lbits  =    9;
#line 260 "inflate.c"
int dbits  =    6;
#line 268 "inflate.c"
unsigned int hufts  ;
#line 271 "inflate.c"
int huft_build(unsigned int *b , unsigned int n , unsigned int s , ush *d , ush *e ,
               struct huft **t , int *m ) 
{ 
  unsigned int a ;
  unsigned int c[17] ;
  unsigned int f ;
  int g ;
  int h ;
  register unsigned int i___0 ;
  register unsigned int j___0 ;
  register int k ;
  int l ;
  register unsigned int *p ;
  register struct huft *q ;
  struct huft r ;
  struct huft *u[16] ;
  unsigned int v[288] ;
  register int w ;
  unsigned int x[17] ;
  unsigned int *xp ;
  int y ;
  unsigned int z ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_19 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  unsigned int *tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;

  {
#line 307
  if (sizeof(c) <= 16UL) {
#line 307
    if (sizeof(c) == 1UL) {
#line 307
      __s___1 = (voidp )(c);
#line 307
      *((__uint8_t *)__s___1) = (__uint8_t )0;
    } else {
#line 307
      __s___0 = (voidp )(c);
#line 307
      __u = (union __anonunion___u_19 *)__s___0;
#line 307
      __c = (__uint8_t )0;
      {
#line 307
      if ((unsigned int )sizeof(c) == 15U) {
#line 307
        goto case_15;
      }
#line 307
      if ((unsigned int )sizeof(c) == 11U) {
#line 307
        goto case_11;
      }
#line 307
      if ((unsigned int )sizeof(c) == 7U) {
#line 307
        goto case_7;
      }
#line 307
      if ((unsigned int )sizeof(c) == 3U) {
#line 307
        goto case_3;
      }
#line 307
      if ((unsigned int )sizeof(c) == 14U) {
#line 307
        goto case_14;
      }
#line 307
      if ((unsigned int )sizeof(c) == 10U) {
#line 307
        goto case_10;
      }
#line 307
      if ((unsigned int )sizeof(c) == 6U) {
#line 307
        goto case_6;
      }
#line 307
      if ((unsigned int )sizeof(c) == 2U) {
#line 307
        goto case_2;
      }
#line 307
      if ((unsigned int )sizeof(c) == 13U) {
#line 307
        goto case_13;
      }
#line 307
      if ((unsigned int )sizeof(c) == 9U) {
#line 307
        goto case_9;
      }
#line 307
      if ((unsigned int )sizeof(c) == 5U) {
#line 307
        goto case_5;
      }
#line 307
      if ((unsigned int )sizeof(c) == 1U) {
#line 307
        goto case_1;
      }
#line 307
      if ((unsigned int )sizeof(c) == 16U) {
#line 307
        goto case_16;
      }
#line 307
      if ((unsigned int )sizeof(c) == 12U) {
#line 307
        goto case_12;
      }
#line 307
      if ((unsigned int )sizeof(c) == 8U) {
#line 307
        goto case_8;
      }
#line 307
      if ((unsigned int )sizeof(c) == 4U) {
#line 307
        goto case_4;
      }
#line 307
      if ((unsigned int )sizeof(c) == 0U) {
#line 307
        goto case_0;
      }
#line 307
      goto switch_break;
      case_15: /* CIL Label */ 
#line 307
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 307
      __u = (union __anonunion___u_19 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 307
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 307
      __u = (union __anonunion___u_19 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 307
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 307
      __u = (union __anonunion___u_19 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 307
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 307
      __u = (union __anonunion___u_19 *)((void *)__u + 2);
#line 307
      __u->__uc = __c;
#line 307
      goto switch_break;
      case_14: /* CIL Label */ 
#line 307
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 307
      __u = (union __anonunion___u_19 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 307
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 307
      __u = (union __anonunion___u_19 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 307
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 307
      __u = (union __anonunion___u_19 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 307
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 307
      goto switch_break;
      case_13: /* CIL Label */ 
#line 307
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 307
      __u = (union __anonunion___u_19 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 307
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 307
      __u = (union __anonunion___u_19 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 307
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 307
      __u = (union __anonunion___u_19 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 307
      __u->__uc = __c;
#line 307
      goto switch_break;
      case_16: /* CIL Label */ 
#line 307
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 307
      __u = (union __anonunion___u_19 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 307
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 307
      __u = (union __anonunion___u_19 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 307
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 307
      __u = (union __anonunion___u_19 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 307
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 307
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 307
    __s = (voidp )(c);
    {
#line 307
    __builtin_memset(__s, '\000', (int )sizeof(c));
    }
    }
  }
#line 308
  p = b;
#line 308
  i___0 = n;
  {
  {
#line 309
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 312
    (c[*p]) ++;
#line 313
    p ++;
#line 309
    i___0 --;
#line 309
    if (! i___0) {
#line 309
      goto while_break;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  if (c[0] == n) {
#line 317
    *t = (struct huft *)((void *)0);
#line 318
    *m = 0;
#line 319
    return (0);
  }
#line 324
  l = *m;
#line 325
  j___0 = 1U;
  {
  {
#line 325
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 325
    if (! (j___0 <= 16U)) {
#line 325
      goto while_break___0;
    }
#line 326
    if (c[j___0]) {
#line 327
      goto while_break___0;
    }
#line 325
    j___0 ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  k = (int )j___0;
#line 329
  if ((unsigned int )l < j___0) {
#line 330
    l = (int )j___0;
  }
#line 331
  i___0 = 16U;
  {
  {
#line 331
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 331
    if (! i___0) {
#line 331
      goto while_break___1;
    }
#line 332
    if (c[i___0]) {
#line 333
      goto while_break___1;
    }
#line 331
    i___0 --;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  g = (int )i___0;
#line 335
  if ((unsigned int )l > i___0) {
#line 336
    l = (int )i___0;
  }
#line 337
  *m = l;
#line 341
  y = 1 << j___0;
  {
  {
#line 341
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 341
    if (! (j___0 < i___0)) {
#line 341
      goto while_break___2;
    }
#line 342
    y = (int )((unsigned int )y - c[j___0]);
#line 342
    if (y < 0) {
#line 343
      return (2);
    }
#line 341
    j___0 ++;
#line 341
    y <<= 1;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 344
  y = (int )((unsigned int )y - c[i___0]);
#line 344
  if (y < 0) {
#line 345
    return (2);
  }
#line 346
  c[i___0] += (unsigned int )y;
#line 350
  j___0 = 0U;
#line 350
  x[1] = j___0;
#line 351
  p = c + 1;
#line 351
  xp = x + 2;
  {
  {
#line 352
  while (1) {
    while_continue___16: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 352
    i___0 --;
#line 352
    if (! i___0) {
#line 352
      goto while_break___3;
    }
#line 353
    tmp = xp;
#line 353
    xp ++;
#line 353
    tmp___0 = p;
#line 353
    p ++;
#line 353
    j___0 += *tmp___0;
#line 353
    *tmp = j___0;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 358
  p = b;
#line 358
  i___0 = 0U;
  {
  {
#line 359
  while (1) {
    while_continue___17: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 360
    tmp___2 = p;
#line 360
    p ++;
#line 360
    j___0 = *tmp___2;
#line 360
    if (j___0 != 0U) {
#line 361
      tmp___1 = x[j___0];
#line 361
      (x[j___0]) ++;
#line 361
      v[tmp___1] = i___0;
    }
#line 359
    i___0 ++;
#line 359
    if (! (i___0 < n)) {
#line 359
      goto while_break___4;
    }
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 366
  i___0 = 0U;
#line 366
  x[0] = i___0;
#line 367
  p = v;
#line 368
  h = -1;
#line 369
  w = - l;
#line 370
  u[0] = (struct huft *)((void *)0);
#line 371
  q = (struct huft *)((void *)0);
#line 372
  z = 0U;
  {
  {
#line 375
  while (1) {
    while_continue___18: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 375
    if (! (k <= g)) {
#line 375
      goto while_break___5;
    }
#line 377
    a = c[k];
    {
    {
#line 378
    while (1) {
      while_continue___19: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 378
      tmp___6 = a;
#line 378
      a --;
#line 378
      if (! tmp___6) {
#line 378
        goto while_break___6;
      }
      {
      {
#line 382
      while (1) {
        while_continue___20: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 382
        if (! (k > w + l)) {
#line 382
          goto while_break___7;
        }
#line 384
        h ++;
#line 385
        w += l;
#line 388
        z = (unsigned int )(g - w);
#line 388
        if (z > (unsigned int )l) {
#line 388
          z = (unsigned int )l;
        } else {
#line 388
          z = z;
        }
#line 389
        j___0 = (unsigned int )(k - w);
#line 389
        f = (unsigned int )(1 << j___0);
#line 389
        if (f > a + 1U) {
#line 391
          f -= a + 1U;
#line 392
          xp = c + k;
          {
          {
#line 393
          while (1) {
            while_continue___21: /* CIL Label */ ;
            while_continue___8: /* CIL Label */ ;
#line 393
            j___0 ++;
#line 393
            if (! (j___0 < z)) {
#line 393
              goto while_break___8;
            }
#line 395
            f <<= 1;
#line 395
            xp ++;
#line 395
            if (f <= *xp) {
#line 396
              goto while_break___8;
            }
#line 397
            f -= *xp;
          }
          while_break___21: /* CIL Label */ ;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
        {
#line 400
        z = (unsigned int )(1 << j___0);
        {
#line 403
        tmp___3 = malloc((size_t )((unsigned long )(z + 1U) * sizeof(struct huft )));
        }
#line 403
        q = (struct huft *)tmp___3;
        }
#line 403
        if ((unsigned long )q == (unsigned long )((struct huft *)((void *)0))) {
#line 406
          if (h) {
            {
            {
#line 407
            huft_free(u[0]);
            }
            }
          }
#line 408
          return (3);
        }
#line 410
        hufts += z + 1U;
#line 411
        *t = q + 1;
#line 412
        t = & q->v.t;
#line 412
        *t = (struct huft *)((void *)0);
#line 413
        q ++;
#line 413
        u[h] = q;
#line 416
        if (h) {
#line 418
          x[h] = i___0;
#line 419
          r.b = (uch )l;
#line 420
          r.e = (uch )(16U + j___0);
#line 421
          r.v.t = q;
#line 422
          j___0 = i___0 >> (w - l);
#line 423
          *(u[h - 1] + j___0) = r;
        }
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 428
      r.b = (uch )(k - w);
#line 429
      if ((unsigned long )p >= (unsigned long )(v + n)) {
#line 430
        r.e = (uch )99;
      } else
#line 431
      if (*p < s) {
#line 433
        if (*p < 256U) {
#line 433
          tmp___4 = 16;
        } else {
#line 433
          tmp___4 = 15;
        }
#line 433
        r.e = (uch )tmp___4;
#line 434
        r.v.n = (ush )*p;
#line 435
        p ++;
      } else {
#line 439
        r.e = (uch )*(e + (*p - s));
#line 440
        tmp___5 = p;
#line 440
        p ++;
#line 440
        r.v.n = *(d + (*tmp___5 - s));
      }
#line 444
      f = (unsigned int )(1 << (k - w));
#line 445
      j___0 = i___0 >> w;
      {
      {
#line 445
      while (1) {
        while_continue___22: /* CIL Label */ ;
        while_continue___9: /* CIL Label */ ;
#line 445
        if (! (j___0 < z)) {
#line 445
          goto while_break___9;
        }
#line 446
        *(q + j___0) = r;
#line 445
        j___0 += f;
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 449
      j___0 = (unsigned int )(1 << (k - 1));
      {
      {
#line 449
      while (1) {
        while_continue___23: /* CIL Label */ ;
        while_continue___10: /* CIL Label */ ;
#line 449
        if (! (i___0 & j___0)) {
#line 449
          goto while_break___10;
        }
#line 450
        i___0 ^= j___0;
#line 449
        j___0 >>= 1;
      }
      while_break___23: /* CIL Label */ ;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 451
      i___0 ^= j___0;
      {
      {
#line 454
      while (1) {
        while_continue___24: /* CIL Label */ ;
        while_continue___11: /* CIL Label */ ;
#line 454
        if (! ((i___0 & (unsigned int )((1 << w) - 1)) != x[h])) {
#line 454
          goto while_break___11;
        }
#line 456
        h --;
#line 457
        w -= l;
      }
      while_break___24: /* CIL Label */ ;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 375
    k ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 464
  if (y != 0) {
#line 464
    if (g != 1) {
#line 464
      tmp___7 = 1;
    } else {
#line 464
      tmp___7 = 0;
    }
  } else {
#line 464
    tmp___7 = 0;
  }
#line 464
  return (tmp___7);
}
}
#line 469 "inflate.c"
int huft_free(struct huft *t ) 
{ 
  register struct huft *p ;
  register struct huft *q ;

  {
#line 479
  p = t;
  {
  {
#line 480
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 480
    if (! ((unsigned long )p != (unsigned long )((struct huft *)((void *)0)))) {
#line 480
      goto while_break;
    }
    {
#line 482
    p --;
#line 482
    q = p->v.t;
    {
#line 483
    free((void *)((char *)p));
    }
#line 484
    p = q;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  return (0);
}
}
#line 490 "inflate.c"
int inflate_codes(struct huft *tl , struct huft *td , int bl , int bd ) 
{ 
  register unsigned int e ;
  unsigned int n ;
  unsigned int d ;
  unsigned int w ;
  struct huft *t ;
  unsigned int ml ;
  unsigned int md ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;

  {
#line 506
  b = bb;
#line 507
  k = bk;
#line 508
  w = outcnt;
#line 511
  ml = (unsigned int )mask_bits[bl];
#line 512
  md = (unsigned int )mask_bits[bd];
  {
  {
#line 513
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 515
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 515
      if (! (k < (unsigned int )bl)) {
#line 515
        goto while_break___0;
      }
#line 515
      if (inptr < insize) {
#line 515
        tmp = inptr;
#line 515
        inptr ++;
#line 515
        tmp___1 = (int )inbuf[tmp];
      } else {
        {
        {
#line 515
        tmp___0 = fill_inbuf(0);
        }
#line 515
        tmp___1 = tmp___0;
        }
      }
#line 515
      b |= (ulg )((uch )tmp___1) << k;
#line 515
      k += 8U;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 516
    t = tl + ((unsigned int )b & ml);
#line 516
    e = (unsigned int )t->e;
#line 516
    if (e > 16U) {
      {
      {
#line 517
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 518
        if (e == 99U) {
#line 519
          return (1);
        }
#line 520
        b >>= (int )t->b;
#line 520
        k -= (unsigned int )t->b;
#line 521
        e -= 16U;
        {
        {
#line 522
        while (1) {
          while_continue___13: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 522
          if (! (k < e)) {
#line 522
            goto while_break___2;
          }
#line 522
          if (inptr < insize) {
#line 522
            tmp___2 = inptr;
#line 522
            inptr ++;
#line 522
            tmp___4 = (int )inbuf[tmp___2];
          } else {
            {
            {
#line 522
            tmp___3 = fill_inbuf(0);
            }
#line 522
            tmp___4 = tmp___3;
            }
          }
#line 522
          b |= (ulg )((uch )tmp___4) << k;
#line 522
          k += 8U;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 517
        t = t->v.t + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 517
        e = (unsigned int )t->e;
#line 517
        if (! (e > 16U)) {
#line 517
          goto while_break___1;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 524
    b >>= (int )t->b;
#line 524
    k -= (unsigned int )t->b;
#line 525
    if (e == 16U) {
#line 527
      tmp___5 = w;
#line 527
      w ++;
#line 527
      window[tmp___5] = (uch )t->v.n;
#line 529
      if (w == 32768U) {
        {
#line 531
        outcnt = w;
        {
#line 531
        flush_window();
        }
#line 532
        w = 0U;
        }
      }
    } else {
#line 538
      if (e == 15U) {
#line 539
        goto while_break;
      }
      {
      {
#line 542
      while (1) {
        while_continue___14: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 542
        if (! (k < e)) {
#line 542
          goto while_break___3;
        }
#line 542
        if (inptr < insize) {
#line 542
          tmp___6 = inptr;
#line 542
          inptr ++;
#line 542
          tmp___8 = (int )inbuf[tmp___6];
        } else {
          {
          {
#line 542
          tmp___7 = fill_inbuf(0);
          }
#line 542
          tmp___8 = tmp___7;
          }
        }
#line 542
        b |= (ulg )((uch )tmp___8) << k;
#line 542
        k += 8U;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 543
      n = (unsigned int )t->v.n + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 544
      b >>= e;
#line 544
      k -= e;
      {
      {
#line 547
      while (1) {
        while_continue___15: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 547
        if (! (k < (unsigned int )bd)) {
#line 547
          goto while_break___4;
        }
#line 547
        if (inptr < insize) {
#line 547
          tmp___9 = inptr;
#line 547
          inptr ++;
#line 547
          tmp___11 = (int )inbuf[tmp___9];
        } else {
          {
          {
#line 547
          tmp___10 = fill_inbuf(0);
          }
#line 547
          tmp___11 = tmp___10;
          }
        }
#line 547
        b |= (ulg )((uch )tmp___11) << k;
#line 547
        k += 8U;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 548
      t = td + ((unsigned int )b & md);
#line 548
      e = (unsigned int )t->e;
#line 548
      if (e > 16U) {
        {
        {
#line 549
        while (1) {
          while_continue___16: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
#line 550
          if (e == 99U) {
#line 551
            return (1);
          }
#line 552
          b >>= (int )t->b;
#line 552
          k -= (unsigned int )t->b;
#line 553
          e -= 16U;
          {
          {
#line 554
          while (1) {
            while_continue___17: /* CIL Label */ ;
            while_continue___6: /* CIL Label */ ;
#line 554
            if (! (k < e)) {
#line 554
              goto while_break___6;
            }
#line 554
            if (inptr < insize) {
#line 554
              tmp___12 = inptr;
#line 554
              inptr ++;
#line 554
              tmp___14 = (int )inbuf[tmp___12];
            } else {
              {
              {
#line 554
              tmp___13 = fill_inbuf(0);
              }
#line 554
              tmp___14 = tmp___13;
              }
            }
#line 554
            b |= (ulg )((uch )tmp___14) << k;
#line 554
            k += 8U;
          }
          while_break___17: /* CIL Label */ ;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 549
          t = t->v.t + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 549
          e = (unsigned int )t->e;
#line 549
          if (! (e > 16U)) {
#line 549
            goto while_break___5;
          }
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 556
      b >>= (int )t->b;
#line 556
      k -= (unsigned int )t->b;
      {
      {
#line 557
      while (1) {
        while_continue___18: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 557
        if (! (k < e)) {
#line 557
          goto while_break___7;
        }
#line 557
        if (inptr < insize) {
#line 557
          tmp___15 = inptr;
#line 557
          inptr ++;
#line 557
          tmp___17 = (int )inbuf[tmp___15];
        } else {
          {
          {
#line 557
          tmp___16 = fill_inbuf(0);
          }
#line 557
          tmp___17 = tmp___16;
          }
        }
#line 557
        b |= (ulg )((uch )tmp___17) << k;
#line 557
        k += 8U;
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 558
      d = (w - (unsigned int )t->v.n) - ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 559
      b >>= e;
#line 559
      k -= e;
      {
      {
#line 563
      while (1) {
        while_continue___19: /* CIL Label */ ;
        while_continue___8: /* CIL Label */ ;
#line 564
        d &= 32767U;
#line 564
        if (d > w) {
#line 564
          tmp___19 = d;
        } else {
#line 564
          tmp___19 = w;
        }
#line 564
        e = 32768U - tmp___19;
#line 564
        if (e > n) {
#line 564
          e = n;
        } else {
#line 564
          e = e;
        }
#line 564
        n -= e;
#line 566
        if (w - d >= e) {
          {
          {
#line 568
          memcpy((void */* __restrict  */)(window + w), (void const   */* __restrict  */)(window + d),
                 e);
          }
#line 569
          w += e;
#line 570
          d += e;
          }
        } else {
          {
          {
#line 574
          while (1) {
            while_continue___20: /* CIL Label */ ;
            while_continue___9: /* CIL Label */ ;
#line 575
            tmp___20 = w;
#line 575
            w ++;
#line 575
            tmp___21 = d;
#line 575
            d ++;
#line 575
            window[tmp___20] = window[tmp___21];
#line 574
            e --;
#line 574
            if (! e) {
#line 574
              goto while_break___9;
            }
          }
          while_break___20: /* CIL Label */ ;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
#line 578
        if (w == 32768U) {
          {
#line 580
          outcnt = w;
          {
#line 580
          flush_window();
          }
#line 581
          w = 0U;
          }
        }
#line 563
        if (! n) {
#line 563
          goto while_break___8;
        }
      }
      while_break___19: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  outcnt = w;
#line 590
  bb = b;
#line 591
  bk = k;
#line 594
  return (0);
}
}
#line 599 "inflate.c"
int inflate_stored(void) 
{ 
  unsigned int n ;
  unsigned int w ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 609
  b = bb;
#line 610
  k = bk;
#line 611
  w = outcnt;
#line 615
  n = k & 7U;
#line 616
  b >>= n;
#line 616
  k -= n;
  {
  {
#line 620
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 620
    if (! (k < 16U)) {
#line 620
      goto while_break;
    }
#line 620
    if (inptr < insize) {
#line 620
      tmp = inptr;
#line 620
      inptr ++;
#line 620
      tmp___1 = (int )inbuf[tmp];
    } else {
      {
      {
#line 620
      tmp___0 = fill_inbuf(0);
      }
#line 620
      tmp___1 = tmp___0;
      }
    }
#line 620
    b |= (ulg )((uch )tmp___1) << k;
#line 620
    k += 8U;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  n = (unsigned int )b & 65535U;
#line 622
  b >>= 16;
#line 622
  k -= 16U;
  {
  {
#line 623
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 623
    if (! (k < 16U)) {
#line 623
      goto while_break___0;
    }
#line 623
    if (inptr < insize) {
#line 623
      tmp___2 = inptr;
#line 623
      inptr ++;
#line 623
      tmp___4 = (int )inbuf[tmp___2];
    } else {
      {
      {
#line 623
      tmp___3 = fill_inbuf(0);
      }
#line 623
      tmp___4 = tmp___3;
      }
    }
#line 623
    b |= (ulg )((uch )tmp___4) << k;
#line 623
    k += 8U;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 624
  if (n != (unsigned int )(~ b & 65535UL)) {
#line 625
    return (1);
  }
#line 626
  b >>= 16;
#line 626
  k -= 16U;
  {
  {
#line 630
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 630
    tmp___9 = n;
#line 630
    n --;
#line 630
    if (! tmp___9) {
#line 630
      goto while_break___1;
    }
    {
    {
#line 632
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 632
      if (! (k < 8U)) {
#line 632
        goto while_break___2;
      }
#line 632
      if (inptr < insize) {
#line 632
        tmp___5 = inptr;
#line 632
        inptr ++;
#line 632
        tmp___7 = (int )inbuf[tmp___5];
      } else {
        {
        {
#line 632
        tmp___6 = fill_inbuf(0);
        }
#line 632
        tmp___7 = tmp___6;
        }
      }
#line 632
      b |= (ulg )((uch )tmp___7) << k;
#line 632
      k += 8U;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 633
    tmp___8 = w;
#line 633
    w ++;
#line 633
    window[tmp___8] = (uch )b;
#line 634
    if (w == 32768U) {
      {
#line 636
      outcnt = w;
      {
#line 636
      flush_window();
      }
#line 637
      w = 0U;
      }
    }
#line 639
    b >>= 8;
#line 639
    k -= 8U;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 644
  outcnt = w;
#line 645
  bb = b;
#line 646
  bk = k;
#line 647
  return (0);
}
}
#line 652 "inflate.c"
int inflate_fixed(void) 
{ 
  int i___0 ;
  struct huft *tl ;
  struct huft *td ;
  int bl ;
  int bd ;
  unsigned int l[288] ;
  int tmp ;
  void *__cil_tmp8 ;

  {
#line 666
  i___0 = 0;
  {
  {
#line 666
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 666
    if (! (i___0 < 144)) {
#line 666
      goto while_break;
    }
#line 667
    l[i___0] = 8U;
#line 666
    i___0 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 668
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 668
    if (! (i___0 < 256)) {
#line 668
      goto while_break___0;
    }
#line 669
    l[i___0] = 9U;
#line 668
    i___0 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 670
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 670
    if (! (i___0 < 280)) {
#line 670
      goto while_break___1;
    }
#line 671
    l[i___0] = 7U;
#line 670
    i___0 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 672
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 672
    if (! (i___0 < 288)) {
#line 672
      goto while_break___2;
    }
#line 673
    l[i___0] = 8U;
#line 672
    i___0 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 674
  bl = 7;
  {
#line 675
  i___0 = huft_build(l, 288U, 257U, cplens, cplext, & tl, & bl);
  }
  }
#line 675
  if (i___0 != 0) {
#line 676
    return (i___0);
  }
#line 680
  i___0 = 0;
  {
  {
#line 680
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 680
    if (! (i___0 < 30)) {
#line 680
      goto while_break___3;
    }
#line 681
    l[i___0] = 5U;
#line 680
    i___0 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 682
  bd = 5;
  {
#line 683
  i___0 = huft_build(l, 30U, 0U, cpdist, cpdext, & td, & bd);
  }
  }
#line 683
  if (i___0 > 1) {
    {
    {
#line 685
    huft_free(tl);
    }
    }
#line 686
    return (i___0);
  }
  {
  {
#line 691
  tmp = inflate_codes(tl, td, bl, bd);
  }
  }
#line 691
  if (tmp) {
#line 692
    return (1);
  }
  {
  {
#line 696
  huft_free(tl);
  }
  {
#line 697
  huft_free(td);
  }
  }
#line 698
  return (0);
}
}
#line 703 "inflate.c"
int inflate_dynamic(void) 
{ 
  int i___0 ;
  unsigned int j___0 ;
  unsigned int l ;
  unsigned int m ;
  unsigned int n ;
  struct huft *tl ;
  struct huft *td ;
  int bl ;
  int bd ;
  unsigned int nb ;
  unsigned int nl ;
  unsigned int nd ;
  unsigned int ll[316] ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  unsigned int tmp___29 ;
  int tmp___30 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
#line 728
  b = bb;
#line 729
  k = bk;
  {
  {
#line 733
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 733
    if (! (k < 5U)) {
#line 733
      goto while_break;
    }
#line 733
    if (inptr < insize) {
#line 733
      tmp = inptr;
#line 733
      inptr ++;
#line 733
      tmp___1 = (int )inbuf[tmp];
    } else {
      {
      {
#line 733
      tmp___0 = fill_inbuf(0);
      }
#line 733
      tmp___1 = tmp___0;
      }
    }
#line 733
    b |= (ulg )((uch )tmp___1) << k;
#line 733
    k += 8U;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 734
  nl = 257U + ((unsigned int )b & 31U);
#line 735
  b >>= 5;
#line 735
  k -= 5U;
  {
  {
#line 736
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 736
    if (! (k < 5U)) {
#line 736
      goto while_break___0;
    }
#line 736
    if (inptr < insize) {
#line 736
      tmp___2 = inptr;
#line 736
      inptr ++;
#line 736
      tmp___4 = (int )inbuf[tmp___2];
    } else {
      {
      {
#line 736
      tmp___3 = fill_inbuf(0);
      }
#line 736
      tmp___4 = tmp___3;
      }
    }
#line 736
    b |= (ulg )((uch )tmp___4) << k;
#line 736
    k += 8U;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 737
  nd = 1U + ((unsigned int )b & 31U);
#line 738
  b >>= 5;
#line 738
  k -= 5U;
  {
  {
#line 739
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 739
    if (! (k < 4U)) {
#line 739
      goto while_break___1;
    }
#line 739
    if (inptr < insize) {
#line 739
      tmp___5 = inptr;
#line 739
      inptr ++;
#line 739
      tmp___7 = (int )inbuf[tmp___5];
    } else {
      {
      {
#line 739
      tmp___6 = fill_inbuf(0);
      }
#line 739
      tmp___7 = tmp___6;
      }
    }
#line 739
    b |= (ulg )((uch )tmp___7) << k;
#line 739
    k += 8U;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 740
  nb = 4U + ((unsigned int )b & 15U);
#line 741
  b >>= 4;
#line 741
  k -= 4U;
#line 745
  if (nl > 286U) {
#line 747
    return (1);
  } else
#line 745
  if (nd > 30U) {
#line 747
    return (1);
  }
#line 751
  j___0 = 0U;
  {
  {
#line 751
  while (1) {
    while_continue___16: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 751
    if (! (j___0 < nb)) {
#line 751
      goto while_break___2;
    }
    {
    {
#line 753
    while (1) {
      while_continue___17: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 753
      if (! (k < 3U)) {
#line 753
        goto while_break___3;
      }
#line 753
      if (inptr < insize) {
#line 753
        tmp___8 = inptr;
#line 753
        inptr ++;
#line 753
        tmp___10 = (int )inbuf[tmp___8];
      } else {
        {
        {
#line 753
        tmp___9 = fill_inbuf(0);
        }
#line 753
        tmp___10 = tmp___9;
        }
      }
#line 753
      b |= (ulg )((uch )tmp___10) << k;
#line 753
      k += 8U;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 754
    ll[border[j___0]] = (unsigned int )b & 7U;
#line 755
    b >>= 3;
#line 755
    k -= 3U;
#line 751
    j___0 ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 757
  while (1) {
    while_continue___18: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 757
    if (! (j___0 < 19U)) {
#line 757
      goto while_break___4;
    }
#line 758
    ll[border[j___0]] = 0U;
#line 757
    j___0 ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 762
  bl = 7;
  {
#line 763
  i___0 = huft_build(ll, 19U, 19U, (ush *)((void *)0), (ush *)((void *)0), & tl, & bl);
  }
  }
#line 763
  if (i___0 != 0) {
#line 765
    if (i___0 == 1) {
      {
      {
#line 766
      huft_free(tl);
      }
      }
    }
#line 767
    return (i___0);
  }
#line 772
  n = nl + nd;
#line 773
  m = (unsigned int )mask_bits[bl];
#line 774
  l = 0U;
#line 774
  i___0 = (int )l;
  {
  {
#line 775
  while (1) {
    while_continue___19: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 775
    if (! ((unsigned int )i___0 < n)) {
#line 775
      goto while_break___5;
    }
    {
    {
#line 777
    while (1) {
      while_continue___20: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 777
      if (! (k < (unsigned int )bl)) {
#line 777
        goto while_break___6;
      }
#line 777
      if (inptr < insize) {
#line 777
        tmp___11 = inptr;
#line 777
        inptr ++;
#line 777
        tmp___13 = (int )inbuf[tmp___11];
      } else {
        {
        {
#line 777
        tmp___12 = fill_inbuf(0);
        }
#line 777
        tmp___13 = tmp___12;
        }
      }
#line 777
      b |= (ulg )((uch )tmp___13) << k;
#line 777
      k += 8U;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 778
    td = tl + ((unsigned int )b & m);
#line 778
    j___0 = (unsigned int )td->b;
#line 779
    b >>= j___0;
#line 779
    k -= j___0;
#line 780
    j___0 = (unsigned int )td->v.n;
#line 781
    if (j___0 < 16U) {
#line 782
      tmp___14 = i___0;
#line 782
      i___0 ++;
#line 782
      l = j___0;
#line 782
      ll[tmp___14] = l;
    } else
#line 783
    if (j___0 == 16U) {
      {
      {
#line 785
      while (1) {
        while_continue___21: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 785
        if (! (k < 2U)) {
#line 785
          goto while_break___7;
        }
#line 785
        if (inptr < insize) {
#line 785
          tmp___15 = inptr;
#line 785
          inptr ++;
#line 785
          tmp___17 = (int )inbuf[tmp___15];
        } else {
          {
          {
#line 785
          tmp___16 = fill_inbuf(0);
          }
#line 785
          tmp___17 = tmp___16;
          }
        }
#line 785
        b |= (ulg )((uch )tmp___17) << k;
#line 785
        k += 8U;
      }
      while_break___21: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 786
      j___0 = 3U + ((unsigned int )b & 3U);
#line 787
      b >>= 2;
#line 787
      k -= 2U;
#line 788
      if ((unsigned int )i___0 + j___0 > n) {
#line 789
        return (1);
      }
      {
      {
#line 790
      while (1) {
        while_continue___22: /* CIL Label */ ;
        while_continue___8: /* CIL Label */ ;
#line 790
        tmp___19 = j___0;
#line 790
        j___0 --;
#line 790
        if (! tmp___19) {
#line 790
          goto while_break___8;
        }
#line 791
        tmp___18 = i___0;
#line 791
        i___0 ++;
#line 791
        ll[tmp___18] = l;
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else
#line 793
    if (j___0 == 17U) {
      {
      {
#line 795
      while (1) {
        while_continue___23: /* CIL Label */ ;
        while_continue___9: /* CIL Label */ ;
#line 795
        if (! (k < 3U)) {
#line 795
          goto while_break___9;
        }
#line 795
        if (inptr < insize) {
#line 795
          tmp___20 = inptr;
#line 795
          inptr ++;
#line 795
          tmp___22 = (int )inbuf[tmp___20];
        } else {
          {
          {
#line 795
          tmp___21 = fill_inbuf(0);
          }
#line 795
          tmp___22 = tmp___21;
          }
        }
#line 795
        b |= (ulg )((uch )tmp___22) << k;
#line 795
        k += 8U;
      }
      while_break___23: /* CIL Label */ ;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 796
      j___0 = 3U + ((unsigned int )b & 7U);
#line 797
      b >>= 3;
#line 797
      k -= 3U;
#line 798
      if ((unsigned int )i___0 + j___0 > n) {
#line 799
        return (1);
      }
      {
      {
#line 800
      while (1) {
        while_continue___24: /* CIL Label */ ;
        while_continue___10: /* CIL Label */ ;
#line 800
        tmp___24 = j___0;
#line 800
        j___0 --;
#line 800
        if (! tmp___24) {
#line 800
          goto while_break___10;
        }
#line 801
        tmp___23 = i___0;
#line 801
        i___0 ++;
#line 801
        ll[tmp___23] = 0U;
      }
      while_break___24: /* CIL Label */ ;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 802
      l = 0U;
    } else {
      {
      {
#line 806
      while (1) {
        while_continue___25: /* CIL Label */ ;
        while_continue___11: /* CIL Label */ ;
#line 806
        if (! (k < 7U)) {
#line 806
          goto while_break___11;
        }
#line 806
        if (inptr < insize) {
#line 806
          tmp___25 = inptr;
#line 806
          inptr ++;
#line 806
          tmp___27 = (int )inbuf[tmp___25];
        } else {
          {
          {
#line 806
          tmp___26 = fill_inbuf(0);
          }
#line 806
          tmp___27 = tmp___26;
          }
        }
#line 806
        b |= (ulg )((uch )tmp___27) << k;
#line 806
        k += 8U;
      }
      while_break___25: /* CIL Label */ ;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 807
      j___0 = 11U + ((unsigned int )b & 127U);
#line 808
      b >>= 7;
#line 808
      k -= 7U;
#line 809
      if ((unsigned int )i___0 + j___0 > n) {
#line 810
        return (1);
      }
      {
      {
#line 811
      while (1) {
        while_continue___26: /* CIL Label */ ;
        while_continue___12: /* CIL Label */ ;
#line 811
        tmp___29 = j___0;
#line 811
        j___0 --;
#line 811
        if (! tmp___29) {
#line 811
          goto while_break___12;
        }
#line 812
        tmp___28 = i___0;
#line 812
        i___0 ++;
#line 812
        ll[tmp___28] = 0U;
      }
      while_break___26: /* CIL Label */ ;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 813
      l = 0U;
    }
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
  {
#line 819
  huft_free(tl);
  }
#line 823
  bb = b;
#line 824
  bk = k;
#line 828
  bl = lbits;
  {
#line 829
  i___0 = huft_build(ll, nl, 257U, cplens, cplext, & tl, & bl);
  }
  }
#line 829
  if (i___0 != 0) {
#line 831
    if (i___0 == 1) {
      {
      {
#line 832
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" incomplete literal tree\n");
      }
      {
#line 833
      huft_free(tl);
      }
      }
    }
#line 835
    return (i___0);
  }
  {
#line 837
  bd = dbits;
  {
#line 838
  i___0 = huft_build(ll + nl, nd, 0U, cpdist, cpdext, & td, & bd);
  }
  }
#line 838
  if (i___0 != 0) {
#line 840
    if (i___0 == 1) {
      {
      {
#line 841
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" incomplete distance tree\n");
      }
      {
#line 846
      huft_free(td);
      }
      }
    }
    {
    {
#line 848
    huft_free(tl);
    }
    }
#line 849
    return (i___0);
  }
  {
  {
#line 855
  tmp___30 = inflate_codes(tl, td, bl, bd);
  }
  }
#line 855
  if (tmp___30) {
#line 856
    return (1);
  }
  {
  {
#line 860
  huft_free(tl);
  }
  {
#line 861
  huft_free(td);
  }
  }
#line 862
  return (0);
}
}
#line 867 "inflate.c"
int inflate_block(int *e ) 
{ 
  unsigned int t ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 877
  b = bb;
#line 878
  k = bk;
  {
  {
#line 882
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 882
    if (! (k < 1U)) {
#line 882
      goto while_break;
    }
#line 882
    if (inptr < insize) {
#line 882
      tmp = inptr;
#line 882
      inptr ++;
#line 882
      tmp___1 = (int )inbuf[tmp];
    } else {
      {
      {
#line 882
      tmp___0 = fill_inbuf(0);
      }
#line 882
      tmp___1 = tmp___0;
      }
    }
#line 882
    b |= (ulg )((uch )tmp___1) << k;
#line 882
    k += 8U;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 883
  *e = (int )b & 1;
#line 884
  b >>= 1;
#line 884
  k --;
  {
  {
#line 888
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 888
    if (! (k < 2U)) {
#line 888
      goto while_break___0;
    }
#line 888
    if (inptr < insize) {
#line 888
      tmp___2 = inptr;
#line 888
      inptr ++;
#line 888
      tmp___4 = (int )inbuf[tmp___2];
    } else {
      {
      {
#line 888
      tmp___3 = fill_inbuf(0);
      }
#line 888
      tmp___4 = tmp___3;
      }
    }
#line 888
    b |= (ulg )((uch )tmp___4) << k;
#line 888
    k += 8U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 889
  t = (unsigned int )b & 3U;
#line 890
  b >>= 2;
#line 890
  k -= 2U;
#line 894
  bb = b;
#line 895
  bk = k;
#line 899
  if (t == 2U) {
    {
    {
#line 900
    tmp___5 = inflate_dynamic();
    }
    }
#line 900
    return (tmp___5);
  }
#line 901
  if (t == 0U) {
    {
    {
#line 902
    tmp___6 = inflate_stored();
    }
    }
#line 902
    return (tmp___6);
  }
#line 903
  if (t == 1U) {
    {
    {
#line 904
    tmp___7 = inflate_fixed();
    }
    }
#line 904
    return (tmp___7);
  }
#line 908
  return (2);
}
}
#line 913 "inflate.c"
int inflate(void) 
{ 
  int e ;
  int r ;
  unsigned int h ;

  {
#line 922
  outcnt = 0U;
#line 923
  bk = 0U;
#line 924
  bb = (ulg )0;
#line 928
  h = 0U;
  {
  {
#line 929
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
#line 930
    hufts = 0U;
    {
#line 931
    r = inflate_block(& e);
    }
    }
#line 931
    if (r != 0) {
#line 932
      return (r);
    }
#line 933
    if (hufts > h) {
#line 934
      h = hufts;
    }
#line 929
    if (! (! e)) {
#line 929
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 940
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 940
    if (! (bk >= 8U)) {
#line 940
      goto while_break___0;
    }
#line 941
    bk -= 8U;
#line 942
    inptr --;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 946
  outcnt = outcnt;
  {
#line 946
  flush_window();
  }
  }
#line 953
  return (0);
}
}
#line 61 "gzip.h"
int method ;
#line 193 "gzip.h"
int decrypt  ;
#line 266
int unzip(int in , int out ) ;
#line 267
int check_zipfile(int in ) ;
#line 43 "unzip.c"
char *key  ;
#line 44 "unzip.c"
int pkzip  =    0;
#line 45 "unzip.c"
int ext_header  =    0;
#line 51 "unzip.c"
int check_zipfile(int in ) 
{ 
  uch *h ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 54
  h = inbuf + inptr;
#line 56
  ifd = in;
#line 59
  inptr += (unsigned int )((30 + ((int )((ush )*((h + 26) + 0)) | ((int )((ush )*((h + 26) + 1)) << 8))) + ((int )((ush )*((h + 28) + 0)) | ((int )((ush )*((h + 28) + 1)) << 8)));
#line 61
  if (inptr > insize) {
    {
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: not a valid zip file\n",
            progname, ifname);
    }
#line 64
    exit_code = 1;
    }
#line 65
    return (1);
  } else
#line 61
  if (((ulg )((int )((ush )*(h + 0)) | ((int )((ush )*(h + 1)) << 8)) | ((ulg )((int )((ush )*((h + 2) + 0)) | ((int )((ush )*((h + 2) + 1)) << 8)) << 16)) != 67324752UL) {
    {
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: not a valid zip file\n",
            progname, ifname);
    }
#line 64
    exit_code = 1;
    }
#line 65
    return (1);
  }
#line 67
  method = (int )*(h + 8);
#line 68
  if (method != 0) {
#line 68
    if (method != 8) {
      {
      {
#line 69
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: first entry not deflated or stored -- use unzip\n",
              progname, ifname);
      }
#line 72
      exit_code = 1;
      }
#line 73
      return (1);
    }
  }
#line 77
  decrypt = (int )*(h + 6) & 1;
#line 77
  if (decrypt != 0) {
    {
    {
#line 78
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: encrypted file -- use unzip\n",
            progname, ifname);
    }
#line 80
    exit_code = 1;
    }
#line 81
    return (1);
  }
#line 85
  ext_header = ((int )*(h + 6) & 8) != 0;
#line 86
  pkzip = 1;
#line 89
  return (0);
}
}
#line 99 "unzip.c"
int unzip(int in , int out ) 
{ 
  ulg orig_crc ;
  ulg orig_len___0 ;
  int n ;
  uch buf[16] ;
  int res ;
  int tmp ;
  register ulg n___0 ;
  int tmp___0 ;
  uch c ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  ulg tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  ulg tmp___12 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
#line 102
  orig_crc = (ulg )0;
#line 103
  orig_len___0 = (ulg )0;
#line 107
  ifd = in;
#line 108
  ofd = out;
  {
#line 110
  updcrc((uch *)((void *)0), 0U);
  }
  }
#line 112
  if (pkzip) {
#line 112
    if (! ext_header) {
#line 113
      orig_crc = (ulg )((int )((ush )*((inbuf + 14) + 0)) | ((int )((ush )*((inbuf + 14) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 14) + 2) + 0)) | ((int )((ush )*(((inbuf + 14) + 2) + 1)) << 8)) << 16);
#line 114
      orig_len___0 = (ulg )((int )((ush )*((inbuf + 22) + 0)) | ((int )((ush )*((inbuf + 22) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 22) + 2) + 0)) | ((int )((ush )*(((inbuf + 22) + 2) + 1)) << 8)) << 16);
    }
  }
#line 118
  if (method == 8) {
    {
    {
#line 120
    tmp = inflate();
    }
#line 120
    res = tmp;
    }
#line 122
    if (res == 3) {
      {
      {
#line 123
      error((char *)"out of memory");
      }
      }
    } else
#line 124
    if (res != 0) {
      {
      {
#line 125
      error((char *)"invalid compressed data--format violated");
      }
      }
    }
  } else
#line 128
  if (pkzip) {
#line 128
    if (method == 0) {
#line 130
      n___0 = (ulg )((int )((ush )*((inbuf + 22) + 0)) | ((int )((ush )*((inbuf + 22) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 22) + 2) + 0)) | ((int )((ush )*(((inbuf + 22) + 2) + 1)) << 8)) << 16);
#line 132
      if (decrypt) {
#line 132
        tmp___0 = 12;
      } else {
#line 132
        tmp___0 = 0;
      }
#line 132
      if (n___0 != ((ulg )((int )((ush )*((inbuf + 18) + 0)) | ((int )((ush )*((inbuf + 18) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 18) + 2) + 0)) | ((int )((ush )*(((inbuf + 18) + 2) + 1)) << 8)) << 16)) - (unsigned long )tmp___0) {
        {
        {
#line 134
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"len %ld, siz %ld\n",
                n___0, (ulg )((int )((ush )*((inbuf + 18) + 0)) | ((int )((ush )*((inbuf + 18) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 18) + 2) + 0)) | ((int )((ush )*(((inbuf + 18) + 2) + 1)) << 8)) << 16));
        }
        {
#line 135
        error((char *)"invalid compressed data--length mismatch");
        }
        }
      }
      {
      {
#line 137
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 137
        tmp___5 = n___0;
#line 137
        n___0 --;
#line 137
        if (! tmp___5) {
#line 137
          goto while_break;
        }
#line 138
        if (inptr < insize) {
#line 138
          tmp___1 = inptr;
#line 138
          inptr ++;
#line 138
          tmp___3 = (int )inbuf[tmp___1];
        } else {
          {
          {
#line 138
          tmp___2 = fill_inbuf(0);
          }
#line 138
          tmp___3 = tmp___2;
          }
        }
#line 138
        c = (uch )tmp___3;
#line 142
        tmp___4 = outcnt;
#line 142
        outcnt ++;
#line 142
        window[tmp___4] = c;
#line 142
        if (outcnt == 32768U) {
          {
          {
#line 142
          flush_window();
          }
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 144
      flush_window();
      }
      }
    } else {
      {
      {
#line 146
      error((char *)"internal error, invalid method");
      }
      }
    }
  } else {
    {
    {
#line 146
    error((char *)"internal error, invalid method");
    }
    }
  }
#line 150
  if (! pkzip) {
#line 154
    n = 0;
    {
    {
#line 154
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 154
      if (! (n < 8)) {
#line 154
        goto while_break___0;
      }
#line 155
      if (inptr < insize) {
#line 155
        tmp___6 = inptr;
#line 155
        inptr ++;
#line 155
        tmp___8 = (int )inbuf[tmp___6];
      } else {
        {
        {
#line 155
        tmp___7 = fill_inbuf(0);
        }
#line 155
        tmp___8 = tmp___7;
        }
      }
#line 155
      buf[n] = (uch )tmp___8;
#line 154
      n ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 157
    orig_crc = (ulg )((int )((ush )buf[0]) | ((int )((ush )buf[1]) << 8)) | ((ulg )((int )((ush )*((buf + 2) + 0)) | ((int )((ush )*((buf + 2) + 1)) << 8)) << 16);
#line 158
    orig_len___0 = (ulg )((int )((ush )*((buf + 4) + 0)) | ((int )((ush )*((buf + 4) + 1)) << 8)) | ((ulg )((int )((ush )*(((buf + 4) + 2) + 0)) | ((int )((ush )*(((buf + 4) + 2) + 1)) << 8)) << 16);
  } else
#line 160
  if (ext_header) {
#line 166
    n = 0;
    {
    {
#line 166
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 166
      if (! (n < 16)) {
#line 166
        goto while_break___1;
      }
#line 167
      if (inptr < insize) {
#line 167
        tmp___9 = inptr;
#line 167
        inptr ++;
#line 167
        tmp___11 = (int )inbuf[tmp___9];
      } else {
        {
        {
#line 167
        tmp___10 = fill_inbuf(0);
        }
#line 167
        tmp___11 = tmp___10;
        }
      }
#line 167
      buf[n] = (uch )tmp___11;
#line 166
      n ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 169
    orig_crc = (ulg )((int )((ush )*((buf + 4) + 0)) | ((int )((ush )*((buf + 4) + 1)) << 8)) | ((ulg )((int )((ush )*(((buf + 4) + 2) + 0)) | ((int )((ush )*(((buf + 4) + 2) + 1)) << 8)) << 16);
#line 170
    orig_len___0 = (ulg )((int )((ush )*((buf + 12) + 0)) | ((int )((ush )*((buf + 12) + 1)) << 8)) | ((ulg )((int )((ush )*(((buf + 12) + 2) + 0)) | ((int )((ush )*(((buf + 12) + 2) + 1)) << 8)) << 16);
  }
  {
  {
#line 174
  tmp___12 = updcrc(outbuf, 0U);
  }
  }
#line 174
  if (orig_crc != tmp___12) {
    {
    {
#line 175
    error((char *)"invalid compressed data--crc error");
    }
    }
  }
#line 177
  if (orig_len___0 != (ulg )bytes_out) {
    {
    {
#line 178
    error((char *)"invalid compressed data--length error");
    }
    }
  }
#line 182
  if (pkzip) {
#line 182
    if (inptr + 4U < insize) {
#line 182
      if (((ulg )((int )((ush )*((inbuf + inptr) + 0)) | ((int )((ush )*((inbuf + inptr) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + inptr) + 2) + 0)) | ((int )((ush )*(((inbuf + inptr) + 2) + 1)) << 8)) << 16)) == 67324752UL) {
#line 183
        if (to_stdout) {
#line 184
          if (! quiet) {
            {
            {
#line 184
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s has more than one entry--rest ignored\n",
                    progname, ifname);
            }
            }
          }
#line 184
          if (exit_code == 0) {
#line 184
            exit_code = 2;
          }
        } else {
          {
          {
#line 189
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s has more than one entry -- unchanged\n",
                  progname, ifname);
          }
#line 192
          exit_code = 1;
#line 193
          pkzip = 0;
#line 193
          ext_header = pkzip;
          }
#line 194
          return (1);
        }
      }
    }
  }
#line 197
  pkzip = 0;
#line 197
  ext_header = pkzip;
#line 198
  return (0);
}
}
#line 263 "gzip.h"
int file_read(char *buf , unsigned int size ) ;
#line 288
void bi_init(file_t zipfile ) ;
#line 289
void send_bits(int value , int length ) ;
#line 290
unsigned int bi_reverse(unsigned int code , int len ) ;
#line 291
void bi_windup(void) ;
#line 292
void copy_block(char *buf , unsigned int len , int header ) ;
#line 293 "gzip.h"
int (*read_buf)(char *buf , unsigned int size )  ;
#line 70 "bits.c"
static file_t zfile  ;
#line 72 "bits.c"
static unsigned short bi_buf  ;
#line 82 "bits.c"
static int bi_valid  ;
#line 97 "bits.c"
void bi_init(file_t zipfile ) 
{ 


  {
#line 100
  zfile = zipfile;
#line 101
  bi_buf = (unsigned short)0;
#line 102
  bi_valid = 0;
#line 110
  if (zfile != -1) {
#line 111
    read_buf = & file_read;
  }
#line 113
  return;
}
}
#line 119 "bits.c"
void send_bits(int value , int length ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 132
  if (bi_valid > (int )(16UL * sizeof(char )) - length) {
#line 133
    bi_buf = (unsigned short )((int )bi_buf | (value << bi_valid));
#line 134
    if (outcnt < 16382U) {
#line 135
      tmp = outcnt;
#line 135
      outcnt ++;
#line 135
      outbuf[tmp] = (uch )((int )bi_buf & 255);
#line 136
      tmp___0 = outcnt;
#line 136
      outcnt ++;
#line 136
      outbuf[tmp___0] = (uch )((int )bi_buf >> 8);
    } else {
#line 138
      tmp___1 = outcnt;
#line 138
      outcnt ++;
#line 138
      outbuf[tmp___1] = (uch )((int )bi_buf & 255);
#line 139
      if (outcnt == 16384U) {
        {
        {
#line 139
        flush_outbuf();
        }
        }
      }
#line 140
      tmp___2 = outcnt;
#line 140
      outcnt ++;
#line 140
      outbuf[tmp___2] = (uch )((int )bi_buf >> 8);
#line 140
      if (outcnt == 16384U) {
        {
        {
#line 140
        flush_outbuf();
        }
        }
      }
    }
#line 141
    bi_buf = (unsigned short )((int )((ush )value) >> (16UL * sizeof(char ) - (unsigned long )bi_valid));
#line 142
    bi_valid = (int )((unsigned long )bi_valid + ((unsigned long )length - 16UL * sizeof(char )));
  } else {
#line 144
    bi_buf = (unsigned short )((int )bi_buf | (value << bi_valid));
#line 145
    bi_valid += length;
  }
#line 147
  return;
}
}
#line 154 "bits.c"
unsigned int bi_reverse(unsigned int code , int len ) 
{ 
  register unsigned int res ;

  {
#line 158
  res = 0U;
  {
  {
#line 159
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 160
    res |= code & 1U;
#line 161
    code >>= 1;
#line 161
    res <<= 1;
#line 159
    len --;
#line 159
    if (! (len > 0)) {
#line 159
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return (res >> 1);
}
}
#line 169 "bits.c"
void bi_windup(void) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 171
  if (bi_valid > 8) {
#line 172
    if (outcnt < 16382U) {
#line 172
      tmp = outcnt;
#line 172
      outcnt ++;
#line 172
      outbuf[tmp] = (uch )((int )bi_buf & 255);
#line 172
      tmp___0 = outcnt;
#line 172
      outcnt ++;
#line 172
      outbuf[tmp___0] = (uch )((int )bi_buf >> 8);
    } else {
#line 172
      tmp___1 = outcnt;
#line 172
      outcnt ++;
#line 172
      outbuf[tmp___1] = (uch )((int )bi_buf & 255);
#line 172
      if (outcnt == 16384U) {
        {
        {
#line 172
        flush_outbuf();
        }
        }
      }
#line 172
      tmp___2 = outcnt;
#line 172
      outcnt ++;
#line 172
      outbuf[tmp___2] = (uch )((int )bi_buf >> 8);
#line 172
      if (outcnt == 16384U) {
        {
        {
#line 172
        flush_outbuf();
        }
        }
      }
    }
  } else
#line 173
  if (bi_valid > 0) {
#line 174
    tmp___3 = outcnt;
#line 174
    outcnt ++;
#line 174
    outbuf[tmp___3] = (uch )bi_buf;
#line 174
    if (outcnt == 16384U) {
      {
      {
#line 174
      flush_outbuf();
      }
      }
    }
  }
#line 176
  bi_buf = (unsigned short)0;
#line 177
  bi_valid = 0;
#line 181
  return;
}
}
#line 187 "bits.c"
void copy_block(char *buf , unsigned int len , int header ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  char *tmp___8 ;
  unsigned int tmp___9 ;

  {
  {
  {
#line 192
  bi_windup();
  }
  }
#line 194
  if (header) {
#line 195
    if (outcnt < 16382U) {
#line 195
      tmp = outcnt;
#line 195
      outcnt ++;
#line 195
      outbuf[tmp] = (uch )((int )((ush )len) & 255);
#line 195
      tmp___0 = outcnt;
#line 195
      outcnt ++;
#line 195
      outbuf[tmp___0] = (uch )((int )((ush )len) >> 8);
    } else {
#line 195
      tmp___1 = outcnt;
#line 195
      outcnt ++;
#line 195
      outbuf[tmp___1] = (uch )((int )((ush )len) & 255);
#line 195
      if (outcnt == 16384U) {
        {
        {
#line 195
        flush_outbuf();
        }
        }
      }
#line 195
      tmp___2 = outcnt;
#line 195
      outcnt ++;
#line 195
      outbuf[tmp___2] = (uch )((int )((ush )len) >> 8);
#line 195
      if (outcnt == 16384U) {
        {
        {
#line 195
        flush_outbuf();
        }
        }
      }
    }
#line 196
    if (outcnt < 16382U) {
#line 196
      tmp___3 = outcnt;
#line 196
      outcnt ++;
#line 196
      outbuf[tmp___3] = (uch )((int )((ush )(~ len)) & 255);
#line 196
      tmp___4 = outcnt;
#line 196
      outcnt ++;
#line 196
      outbuf[tmp___4] = (uch )((int )((ush )(~ len)) >> 8);
    } else {
#line 196
      tmp___5 = outcnt;
#line 196
      outcnt ++;
#line 196
      outbuf[tmp___5] = (uch )((int )((ush )(~ len)) & 255);
#line 196
      if (outcnt == 16384U) {
        {
        {
#line 196
        flush_outbuf();
        }
        }
      }
#line 196
      tmp___6 = outcnt;
#line 196
      outcnt ++;
#line 196
      outbuf[tmp___6] = (uch )((int )((ush )(~ len)) >> 8);
#line 196
      if (outcnt == 16384U) {
        {
        {
#line 196
        flush_outbuf();
        }
        }
      }
    }
  }
  {
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 199
    tmp___9 = len;
#line 199
    len --;
#line 199
    if (! tmp___9) {
#line 199
      goto while_break;
    }
#line 200
    tmp___7 = outcnt;
#line 200
    outcnt ++;
#line 200
    tmp___8 = buf;
#line 200
    buf ++;
#line 200
    outbuf[tmp___7] = (uch )*tmp___8;
#line 200
    if (outcnt == 16384U) {
      {
      {
#line 200
      flush_outbuf();
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return;
}
}
#line 197 "gzip.h"
int level ;
#line 283
void ct_init(ush *attr , int *methodp ) ;
#line 284
int ct_tally(int dist , int lc ) ;
#line 285
ulg flush_block(char *buf , ulg stored_len , int eof ) ;
#line 94 "trees.c"
static int extra_lbits[29]  = 
#line 94 "trees.c"
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        1,      1,      1,      1, 
        2,      2,      2,      2, 
        3,      3,      3,      3, 
        4,      4,      4,      4, 
        5,      5,      5,      5, 
        0};
#line 97 "trees.c"
static int extra_dbits[30]  = 
#line 97
  {      0,      0,      0,      0, 
        1,      1,      2,      2, 
        3,      3,      4,      4, 
        5,      5,      6,      6, 
        7,      7,      8,      8, 
        9,      9,      10,      10, 
        11,      11,      12,      12, 
        13,      13};
#line 100 "trees.c"
static int extra_blbits[19]  = 
#line 100
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        2,      3,      7};
#line 179 "trees.c"
static ct_data dyn_ltree[573]  ;
#line 180 "trees.c"
static ct_data dyn_dtree[61]  ;
#line 182 "trees.c"
static ct_data static_ltree[288]  ;
#line 189 "trees.c"
static ct_data static_dtree[30]  ;
#line 194 "trees.c"
static ct_data bl_tree[39]  ;
#line 207 "trees.c"
static tree_desc l_desc  =    {dyn_ltree, static_ltree, extra_lbits, 257, 286, 15, 0};
#line 210 "trees.c"
static tree_desc d_desc  =    {dyn_dtree, static_dtree, extra_dbits, 0, 30, 15, 0};
#line 213 "trees.c"
static tree_desc bl_desc  =    {bl_tree, (ct_data *)0, extra_blbits, 0, 19, 7, 0};
#line 217 "trees.c"
static ush bl_count[16]  ;
#line 220 "trees.c"
static uch bl_order[19]  = 
#line 220
  {      (uch )16,      (uch )17,      (uch )18,      (uch )0, 
        (uch )8,      (uch )7,      (uch )9,      (uch )6, 
        (uch )10,      (uch )5,      (uch )11,      (uch )4, 
        (uch )12,      (uch )3,      (uch )13,      (uch )2, 
        (uch )14,      (uch )1,      (uch )15};
#line 226 "trees.c"
static int heap[573]  ;
#line 227 "trees.c"
static int heap_len  ;
#line 228 "trees.c"
static int heap_max  ;
#line 233 "trees.c"
static uch depth[573]  ;
#line 236 "trees.c"
static uch length_code[256]  ;
#line 239 "trees.c"
static uch dist_code[512]  ;
#line 245 "trees.c"
static int base_length[29]  ;
#line 248 "trees.c"
static int base_dist[30]  ;
#line 256 "trees.c"
static uch flag_buf[4096]  ;
#line 261 "trees.c"
static unsigned int last_lit  ;
#line 262 "trees.c"
static unsigned int last_dist  ;
#line 263 "trees.c"
static unsigned int last_flags  ;
#line 264 "trees.c"
static uch flags  ;
#line 265 "trees.c"
static uch flag_bit  ;
#line 271 "trees.c"
static ulg opt_len  ;
#line 272 "trees.c"
static ulg static_len  ;
#line 274 "trees.c"
static ulg compressed_len  ;
#line 276 "trees.c"
static ulg input_len  ;
#line 279 "trees.c"
ush *file_type  ;
#line 280 "trees.c"
int *file_method  ;
#line 287
long block_start ;
#line 288
unsigned int strstart ;
#line 294
static void init_block(void) ;
#line 295
static void pqdownheap(ct_data *tree , int k ) ;
#line 296
static void gen_bitlen(tree_desc *desc ) ;
#line 297
static void gen_codes(ct_data *tree , int max_code ) ;
#line 298
static void build_tree___0(tree_desc *desc ) ;
#line 299
static void scan_tree(ct_data *tree , int max_code ) ;
#line 300
static void send_tree(ct_data *tree , int max_code ) ;
#line 301
static int build_bl_tree(void) ;
#line 302
static void send_all_trees(int lcodes , int dcodes , int blcodes ) ;
#line 303
static void compress_block(ct_data *ltree , ct_data *dtree ) ;
#line 304
static void set_file_type(void) ;
#line 332 "trees.c"
void ct_init(ush *attr , int *methodp ) 
{ 
  int n ;
  int bits ;
  int length ;
  int code ;
  int dist ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 342
  file_type = attr;
#line 343
  file_method = methodp;
#line 344
  input_len = (ulg )0L;
#line 344
  compressed_len = input_len;
#line 346
  if ((int )static_dtree[0].dl.len != 0) {
#line 346
    return;
  }
#line 349
  length = 0;
#line 350
  code = 0;
  {
  {
#line 350
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 350
    if (! (code < 28)) {
#line 350
      goto while_break;
    }
#line 351
    base_length[code] = length;
#line 352
    n = 0;
    {
    {
#line 352
    while (1) {
      while_continue___12: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 352
      if (! (n < 1 << extra_lbits[code])) {
#line 352
        goto while_break___0;
      }
#line 353
      tmp = length;
#line 353
      length ++;
#line 353
      length_code[tmp] = (uch )code;
#line 352
      n ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 350
    code ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  length_code[length - 1] = (uch )code;
#line 364
  dist = 0;
#line 365
  code = 0;
  {
  {
#line 365
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 365
    if (! (code < 16)) {
#line 365
      goto while_break___1;
    }
#line 366
    base_dist[code] = dist;
#line 367
    n = 0;
    {
    {
#line 367
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 367
      if (! (n < 1 << extra_dbits[code])) {
#line 367
        goto while_break___2;
      }
#line 368
      tmp___0 = dist;
#line 368
      dist ++;
#line 368
      dist_code[tmp___0] = (uch )code;
#line 367
      n ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 365
    code ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 372
  dist >>= 7;
  {
  {
#line 373
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 373
    if (! (code < 30)) {
#line 373
      goto while_break___3;
    }
#line 374
    base_dist[code] = dist << 7;
#line 375
    n = 0;
    {
    {
#line 375
    while (1) {
      while_continue___16: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 375
      if (! (n < 1 << (extra_dbits[code] - 7))) {
#line 375
        goto while_break___4;
      }
#line 376
      tmp___1 = dist;
#line 376
      dist ++;
#line 376
      dist_code[256 + tmp___1] = (uch )code;
#line 375
      n ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 373
    code ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 382
  bits = 0;
  {
  {
#line 382
  while (1) {
    while_continue___17: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 382
    if (! (bits <= 15)) {
#line 382
      goto while_break___5;
    }
#line 382
    bl_count[bits] = (ush )0;
#line 382
    bits ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 383
  n = 0;
  {
  {
#line 384
  while (1) {
    while_continue___18: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;
#line 384
    if (! (n <= 143)) {
#line 384
      goto while_break___6;
    }
#line 384
    tmp___2 = n;
#line 384
    n ++;
#line 384
    static_ltree[tmp___2].dl.len = (ush )8;
#line 384
    bl_count[8] = (ush )((int )bl_count[8] + 1);
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
  {
#line 385
  while (1) {
    while_continue___19: /* CIL Label */ ;
    while_continue___7: /* CIL Label */ ;
#line 385
    if (! (n <= 255)) {
#line 385
      goto while_break___7;
    }
#line 385
    tmp___3 = n;
#line 385
    n ++;
#line 385
    static_ltree[tmp___3].dl.len = (ush )9;
#line 385
    bl_count[9] = (ush )((int )bl_count[9] + 1);
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
  {
#line 386
  while (1) {
    while_continue___20: /* CIL Label */ ;
    while_continue___8: /* CIL Label */ ;
#line 386
    if (! (n <= 279)) {
#line 386
      goto while_break___8;
    }
#line 386
    tmp___4 = n;
#line 386
    n ++;
#line 386
    static_ltree[tmp___4].dl.len = (ush )7;
#line 386
    bl_count[7] = (ush )((int )bl_count[7] + 1);
  }
  while_break___20: /* CIL Label */ ;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
  {
#line 387
  while (1) {
    while_continue___21: /* CIL Label */ ;
    while_continue___9: /* CIL Label */ ;
#line 387
    if (! (n <= 287)) {
#line 387
      goto while_break___9;
    }
#line 387
    tmp___5 = n;
#line 387
    n ++;
#line 387
    static_ltree[tmp___5].dl.len = (ush )8;
#line 387
    bl_count[8] = (ush )((int )bl_count[8] + 1);
  }
  while_break___21: /* CIL Label */ ;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
  {
#line 392
  gen_codes(static_ltree, 287);
  }
#line 395
  n = 0;
  }
  {
  {
#line 395
  while (1) {
    while_continue___22: /* CIL Label */ ;
    while_continue___10: /* CIL Label */ ;
#line 395
    if (! (n < 30)) {
#line 395
      goto while_break___10;
    }
    {
#line 396
    static_dtree[n].dl.len = (ush )5;
    {
#line 397
    tmp___6 = bi_reverse((unsigned int )n, 5);
    }
#line 397
    static_dtree[n].fc.code = (ush )tmp___6;
#line 395
    n ++;
    }
  }
  while_break___22: /* CIL Label */ ;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
  {
#line 401
  init_block();
  }
  }
#line 402
  return;
}
}
#line 407 "trees.c"
static void init_block(void) 
{ 
  int n ;

  {
#line 412
  n = 0;
  {
  {
#line 412
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 412
    if (! (n < 286)) {
#line 412
      goto while_break;
    }
#line 412
    dyn_ltree[n].fc.freq = (ush )0;
#line 412
    n ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  n = 0;
  {
  {
#line 413
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 413
    if (! (n < 30)) {
#line 413
      goto while_break___0;
    }
#line 413
    dyn_dtree[n].fc.freq = (ush )0;
#line 413
    n ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 414
  n = 0;
  {
  {
#line 414
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 414
    if (! (n < 19)) {
#line 414
      goto while_break___1;
    }
#line 414
    bl_tree[n].fc.freq = (ush )0;
#line 414
    n ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 416
  dyn_ltree[256].fc.freq = (ush )1;
#line 417
  static_len = (ulg )0L;
#line 417
  opt_len = static_len;
#line 418
  last_flags = 0U;
#line 418
  last_dist = last_flags;
#line 418
  last_lit = last_dist;
#line 419
  flags = (uch )0;
#line 419
  flag_bit = (uch )1;
#line 420
  return;
}
}
#line 451 "trees.c"
static void pqdownheap(ct_data *tree , int k ) 
{ 
  int v ;
  int j___0 ;

  {
#line 455
  v = heap[k];
#line 456
  j___0 = k << 1;
  {
  {
#line 457
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 457
    if (! (j___0 <= heap_len)) {
#line 457
      goto while_break;
    }
#line 459
    if (j___0 < heap_len) {
#line 459
      if ((int )(tree + heap[j___0 + 1])->fc.freq < (int )(tree + heap[j___0])->fc.freq) {
#line 459
        j___0 ++;
      } else
#line 459
      if ((int )(tree + heap[j___0 + 1])->fc.freq == (int )(tree + heap[j___0])->fc.freq) {
#line 459
        if ((int )depth[heap[j___0 + 1]] <= (int )depth[heap[j___0]]) {
#line 459
          j___0 ++;
        }
      }
    }
#line 462
    if ((int )(tree + v)->fc.freq < (int )(tree + heap[j___0])->fc.freq) {
#line 462
      goto while_break;
    } else
#line 462
    if ((int )(tree + v)->fc.freq == (int )(tree + heap[j___0])->fc.freq) {
#line 462
      if ((int )depth[v] <= (int )depth[heap[j___0]]) {
#line 462
        goto while_break;
      }
    }
#line 465
    heap[k] = heap[j___0];
#line 465
    k = j___0;
#line 468
    j___0 <<= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  heap[k] = v;
#line 471
  return;
}
}
#line 483 "trees.c"
static void gen_bitlen(tree_desc *desc ) 
{ 
  ct_data *tree ;
  int *extra ;
  int base ;
  int max_code ;
  int max_length ;
  ct_data *stree ;
  int h ;
  int n ;
  int m ;
  int bits ;
  int xbits ;
  ush f ;
  int overflow ;

  {
#line 486
  tree = desc->dyn_tree;
#line 487
  extra = desc->extra_bits;
#line 488
  base = desc->extra_base;
#line 489
  max_code = desc->max_code;
#line 490
  max_length = desc->max_length;
#line 491
  stree = desc->static_tree;
#line 497
  overflow = 0;
#line 499
  bits = 0;
  {
  {
#line 499
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 499
    if (! (bits <= 15)) {
#line 499
      goto while_break;
    }
#line 499
    bl_count[bits] = (ush )0;
#line 499
    bits ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  (tree + heap[heap_max])->dl.len = (ush )0;
#line 506
  h = heap_max + 1;
  {
  {
#line 506
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 506
    if (! (h < 573)) {
#line 506
      goto while_break___0;
    }
#line 507
    n = heap[h];
#line 508
    bits = (int )(tree + (tree + n)->dl.dad)->dl.len + 1;
#line 509
    if (bits > max_length) {
#line 509
      bits = max_length;
#line 509
      overflow ++;
    }
#line 510
    (tree + n)->dl.len = (ush )bits;
#line 513
    if (n > max_code) {
#line 513
      goto __Cont;
    }
#line 515
    bl_count[bits] = (ush )((int )bl_count[bits] + 1);
#line 516
    xbits = 0;
#line 517
    if (n >= base) {
#line 517
      xbits = *(extra + (n - base));
    }
#line 518
    f = (tree + n)->fc.freq;
#line 519
    opt_len += (ulg )f * (ulg )(bits + xbits);
#line 520
    if (stree) {
#line 520
      static_len += (ulg )f * (ulg )((int )(stree + n)->dl.len + xbits);
    }
    __Cont: /* CIL Label */ 
#line 506
    h ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 522
  if (overflow == 0) {
#line 522
    return;
  }
  {
  {
#line 528
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 529
    bits = max_length - 1;
    {
    {
#line 530
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 530
      if (! ((int )bl_count[bits] == 0)) {
#line 530
        goto while_break___2;
      }
#line 530
      bits --;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 531
    bl_count[bits] = (ush )((int )bl_count[bits] - 1);
#line 532
    bl_count[bits + 1] = (ush )((int )bl_count[bits + 1] + 2);
#line 533
    bl_count[max_length] = (ush )((int )bl_count[max_length] - 1);
#line 537
    overflow -= 2;
#line 528
    if (! (overflow > 0)) {
#line 528
      goto while_break___1;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 545
  bits = max_length;
  {
  {
#line 545
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 545
    if (! (bits != 0)) {
#line 545
      goto while_break___3;
    }
#line 546
    n = (int )bl_count[bits];
    {
    {
#line 547
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 547
      if (! (n != 0)) {
#line 547
        goto while_break___4;
      }
#line 548
      h --;
#line 548
      m = heap[h];
#line 549
      if (m > max_code) {
#line 549
        goto while_continue___4;
      }
#line 550
      if ((unsigned int )(tree + m)->dl.len != (unsigned int )bits) {
#line 552
        opt_len += (ulg )(((long )bits - (long )(tree + m)->dl.len) * (long )(tree + m)->fc.freq);
#line 553
        (tree + m)->dl.len = (ush )bits;
      }
#line 555
      n --;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 545
    bits --;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 558
  return;
}
}
#line 568 "trees.c"
static void gen_codes(ct_data *tree , int max_code ) 
{ 
  ush next_code[16] ;
  ush code ;
  int bits ;
  int n ;
  int len ;
  ush tmp ;
  unsigned int tmp___0 ;
  void *__cil_tmp10 ;

  {
#line 573
  code = (ush )0;
#line 580
  bits = 1;
  {
  {
#line 580
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 580
    if (! (bits <= 15)) {
#line 580
      goto while_break;
    }
#line 581
    code = (ush )(((int )code + (int )bl_count[bits - 1]) << 1);
#line 581
    next_code[bits] = code;
#line 580
    bits ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 590
  n = 0;
  {
  {
#line 590
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 590
    if (! (n <= max_code)) {
#line 590
      goto while_break___0;
    }
#line 591
    len = (int )(tree + n)->dl.len;
#line 592
    if (len == 0) {
#line 592
      goto __Cont;
    }
    {
#line 594
    tmp = next_code[len];
#line 594
    next_code[len] = (ush )((int )next_code[len] + 1);
    {
#line 594
    tmp___0 = bi_reverse((unsigned int )tmp, len);
    }
#line 594
    (tree + n)->fc.code = (ush )tmp___0;
    }
    __Cont: /* CIL Label */ 
#line 590
    n ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 599
  return;
}
}
#line 609 "trees.c"
static void build_tree___0(tree_desc *desc ) 
{ 
  ct_data *tree ;
  ct_data *stree ;
  int elems ;
  int n ;
  int m ;
  int max_code ;
  int node ;
  int new ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ush tmp___2 ;
  int tmp___3 ;

  {
#line 612
  tree = desc->dyn_tree;
#line 613
  stree = desc->static_tree;
#line 614
  elems = desc->elems;
#line 616
  max_code = -1;
#line 617
  node = elems;
#line 619
  heap_len = 0;
#line 619
  heap_max = 573;
#line 621
  n = 0;
  {
  {
#line 621
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 621
    if (! (n < elems)) {
#line 621
      goto while_break;
    }
#line 622
    if ((int )(tree + n)->fc.freq != 0) {
#line 623
      heap_len ++;
#line 623
      max_code = n;
#line 623
      heap[heap_len] = max_code;
#line 624
      depth[n] = (uch )0;
    } else {
#line 626
      (tree + n)->dl.len = (ush )0;
    }
#line 621
    n ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 630
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 630
    if (! (heap_len < 2)) {
#line 630
      goto while_break___0;
    }
#line 631
    heap_len ++;
#line 631
    if (max_code < 2) {
#line 631
      max_code ++;
#line 631
      tmp = max_code;
    } else {
#line 631
      tmp = 0;
    }
#line 631
    heap[heap_len] = tmp;
#line 631
    new = tmp;
#line 632
    (tree + new)->fc.freq = (ush )1;
#line 633
    depth[new] = (uch )0;
#line 634
    opt_len --;
#line 634
    if (stree) {
#line 634
      static_len -= (ulg )(stree + new)->dl.len;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 637
  desc->max_code = max_code;
#line 639
  n = heap_len / 2;
  {
  {
#line 639
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 639
    if (! (n >= 1)) {
#line 639
      goto while_break___1;
    }
    {
    {
#line 639
    pqdownheap(tree, n);
    }
#line 639
    n --;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 640
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
    {
#line 641
    n = heap[1];
#line 641
    tmp___0 = heap_len;
#line 641
    heap_len --;
#line 641
    heap[1] = heap[tmp___0];
    {
#line 641
    pqdownheap(tree, 1);
    }
#line 642
    m = heap[1];
#line 643
    heap_max --;
#line 643
    heap[heap_max] = n;
#line 644
    heap_max --;
#line 644
    heap[heap_max] = m;
#line 645
    (tree + node)->fc.freq = (ush )((int )(tree + n)->fc.freq + (int )(tree + m)->fc.freq);
    }
#line 646
    if ((int )depth[n] >= (int )depth[m]) {
#line 646
      tmp___1 = (int )depth[n];
    } else {
#line 646
      tmp___1 = (int )depth[m];
    }
    {
#line 646
    depth[node] = (uch )(tmp___1 + 1);
#line 647
    tmp___2 = (ush )node;
#line 647
    (tree + m)->dl.dad = tmp___2;
#line 647
    (tree + n)->dl.dad = tmp___2;
#line 649
    tmp___3 = node;
#line 649
    node ++;
#line 649
    heap[1] = tmp___3;
    {
#line 650
    pqdownheap(tree, 1);
    }
    }
#line 640
    if (! (heap_len >= 2)) {
#line 640
      goto while_break___2;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 654
  heap_max --;
#line 654
  heap[heap_max] = heap[1];
  {
#line 659
  gen_bitlen(desc);
  }
  {
#line 662
  gen_codes(tree, max_code);
  }
  }
#line 663
  return;
}
}
#line 671 "trees.c"
static void scan_tree(ct_data *tree , int max_code ) 
{ 
  int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;

  {
#line 676
  prevlen = -1;
#line 678
  nextlen = (int )(tree + 0)->dl.len;
#line 679
  count = 0;
#line 680
  max_count = 7;
#line 681
  min_count = 4;
#line 683
  if (nextlen == 0) {
#line 683
    max_count = 138;
#line 683
    min_count = 3;
  }
#line 684
  (tree + (max_code + 1))->dl.len = (ush )65535;
#line 686
  n = 0;
  {
  {
#line 686
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 686
    if (! (n <= max_code)) {
#line 686
      goto while_break;
    }
#line 687
    curlen = nextlen;
#line 687
    nextlen = (int )(tree + (n + 1))->dl.len;
#line 688
    count ++;
#line 688
    if (count < max_count) {
#line 688
      if (curlen == nextlen) {
#line 689
        goto __Cont;
      } else {
#line 688
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 690
    if (count < min_count) {
#line 691
      bl_tree[curlen].fc.freq = (ush )((int )bl_tree[curlen].fc.freq + count);
    } else
#line 692
    if (curlen != 0) {
#line 693
      if (curlen != prevlen) {
#line 693
        bl_tree[curlen].fc.freq = (ush )((int )bl_tree[curlen].fc.freq + 1);
      }
#line 694
      bl_tree[16].fc.freq = (ush )((int )bl_tree[16].fc.freq + 1);
    } else
#line 695
    if (count <= 10) {
#line 696
      bl_tree[17].fc.freq = (ush )((int )bl_tree[17].fc.freq + 1);
    } else {
#line 698
      bl_tree[18].fc.freq = (ush )((int )bl_tree[18].fc.freq + 1);
    }
#line 700
    count = 0;
#line 700
    prevlen = curlen;
#line 701
    if (nextlen == 0) {
#line 702
      max_count = 138;
#line 702
      min_count = 3;
    } else
#line 703
    if (curlen == nextlen) {
#line 704
      max_count = 6;
#line 704
      min_count = 3;
    } else {
#line 706
      max_count = 7;
#line 706
      min_count = 4;
    }
    __Cont: /* CIL Label */ 
#line 686
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  return;
}
}
#line 715 "trees.c"
static void send_tree(ct_data *tree , int max_code ) 
{ 
  int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;

  {
#line 720
  prevlen = -1;
#line 722
  nextlen = (int )(tree + 0)->dl.len;
#line 723
  count = 0;
#line 724
  max_count = 7;
#line 725
  min_count = 4;
#line 728
  if (nextlen == 0) {
#line 728
    max_count = 138;
#line 728
    min_count = 3;
  }
#line 730
  n = 0;
  {
  {
#line 730
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 730
    if (! (n <= max_code)) {
#line 730
      goto while_break;
    }
#line 731
    curlen = nextlen;
#line 731
    nextlen = (int )(tree + (n + 1))->dl.len;
#line 732
    count ++;
#line 732
    if (count < max_count) {
#line 732
      if (curlen == nextlen) {
#line 733
        goto __Cont;
      } else {
#line 732
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 734
    if (count < min_count) {
      {
      {
#line 735
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 735
        send_bits((int )bl_tree[curlen].fc.code, (int )bl_tree[curlen].dl.len);
        }
#line 735
        count --;
        }
#line 735
        if (! (count != 0)) {
#line 735
          goto while_break___0;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 737
    if (curlen != 0) {
#line 738
      if (curlen != prevlen) {
        {
        {
#line 739
        send_bits((int )bl_tree[curlen].fc.code, (int )bl_tree[curlen].dl.len);
        }
#line 739
        count --;
        }
      }
      {
      {
#line 742
      send_bits((int )bl_tree[16].fc.code, (int )bl_tree[16].dl.len);
      }
      {
#line 742
      send_bits(count - 3, 2);
      }
      }
    } else
#line 744
    if (count <= 10) {
      {
      {
#line 745
      send_bits((int )bl_tree[17].fc.code, (int )bl_tree[17].dl.len);
      }
      {
#line 745
      send_bits(count - 3, 3);
      }
      }
    } else {
      {
      {
#line 748
      send_bits((int )bl_tree[18].fc.code, (int )bl_tree[18].dl.len);
      }
      {
#line 748
      send_bits(count - 11, 7);
      }
      }
    }
#line 750
    count = 0;
#line 750
    prevlen = curlen;
#line 751
    if (nextlen == 0) {
#line 752
      max_count = 138;
#line 752
      min_count = 3;
    } else
#line 753
    if (curlen == nextlen) {
#line 754
      max_count = 6;
#line 754
      min_count = 3;
    } else {
#line 756
      max_count = 7;
#line 756
      min_count = 4;
    }
    __Cont: /* CIL Label */ 
#line 730
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 759
  return;
}
}
#line 765 "trees.c"
static int build_bl_tree(void) 
{ 
  int max_blindex ;

  {
  {
  {
#line 770
  scan_tree(dyn_ltree, l_desc.max_code);
  }
  {
#line 771
  scan_tree(dyn_dtree, d_desc.max_code);
  }
  {
#line 774
  build_tree___0(& bl_desc);
  }
#line 808
  max_blindex = 18;
  }
  {
  {
#line 808
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 808
    if (! (max_blindex >= 3)) {
#line 808
      goto while_break;
    }
#line 809
    if ((int )bl_tree[bl_order[max_blindex]].dl.len != 0) {
#line 809
      goto while_break;
    }
#line 808
    max_blindex --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 812
  opt_len += (ulg )(((3 * (max_blindex + 1) + 5) + 5) + 4);
#line 815
  return (max_blindex);
}
}
#line 823 "trees.c"
static void send_all_trees(int lcodes , int dcodes , int blcodes ) 
{ 
  int rank ;

  {
  {
  {
#line 832
  send_bits(lcodes - 257, 5);
  }
  {
#line 833
  send_bits(dcodes - 1, 5);
  }
  {
#line 834
  send_bits(blcodes - 4, 4);
  }
#line 835
  rank = 0;
  }
  {
  {
#line 835
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 835
    if (! (rank < blcodes)) {
#line 835
      goto while_break;
    }
    {
    {
#line 837
    send_bits((int )bl_tree[bl_order[rank]].dl.len, 3);
    }
#line 835
    rank ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 841
  send_tree(dyn_ltree, lcodes - 1);
  }
  {
#line 844
  send_tree(dyn_dtree, dcodes - 1);
  }
  }
#line 846
  return;
}
}
#line 853 "trees.c"
ulg flush_block(char *buf , ulg stored_len , int eof ) 
{ 
  ulg opt_lenb ;
  ulg static_lenb ;
  int max_blindex ;

  {
#line 861
  flag_buf[last_flags] = flags;
#line 864
  if ((int )*file_type == 65535) {
    {
    {
#line 864
    set_file_type();
    }
    }
  }
  {
  {
#line 867
  build_tree___0(& l_desc);
  }
  {
#line 870
  build_tree___0(& d_desc);
  }
  {
#line 879
  max_blindex = build_bl_tree();
  }
#line 882
  opt_lenb = ((opt_len + 3UL) + 7UL) >> 3;
#line 883
  static_lenb = ((static_len + 3UL) + 7UL) >> 3;
#line 884
  input_len += stored_len;
  }
#line 890
  if (static_lenb <= opt_lenb) {
#line 890
    opt_lenb = static_lenb;
  }
#line 899
  if (stored_len <= opt_lenb) {
#line 899
    if (eof) {
#line 899
      if (compressed_len == 0UL) {
#line 899
        goto _L___2;
      } else {
#line 899
        goto _L___2;
      }
    } else {
#line 899
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 911
  if (stored_len + 4UL <= opt_lenb) {
#line 911
    if ((unsigned long )buf != (unsigned long )((char *)0)) {
      {
      {
#line 920
      send_bits(eof, 3);
      }
#line 921
      compressed_len = ((compressed_len + 3UL) + 7UL) & 0xfffffffffffffff8UL;
#line 922
      compressed_len += (stored_len + 4UL) << 3;
      {
#line 924
      copy_block(buf, (unsigned int )stored_len, 1);
      }
      }
    } else {
#line 911
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 929
  if (static_lenb == opt_lenb) {
    {
    {
#line 931
    send_bits((1 << 1) + eof, 3);
    }
    {
#line 932
    compress_block(static_ltree, static_dtree);
    }
#line 933
    compressed_len += 3UL + static_len;
    }
  } else {
    {
    {
#line 935
    send_bits((2 << 1) + eof, 3);
    }
    {
#line 936
    send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
    }
    {
#line 937
    compress_block(dyn_ltree, dyn_dtree);
    }
#line 938
    compressed_len += 3UL + opt_len;
    }
  }
  {
  {
#line 941
  init_block();
  }
  }
#line 943
  if (eof) {
    {
    {
#line 945
    bi_windup();
    }
#line 946
    compressed_len += 7UL;
    }
  }
#line 951
  return (compressed_len >> 3);
}
}
#line 958 "trees.c"
int ct_tally(int dist , int lc ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  ulg out_length ;
  ulg in_length ;
  int dcode ;
  int tmp___3 ;

  {
#line 962
  tmp = last_lit;
#line 962
  last_lit ++;
#line 962
  inbuf[tmp] = (uch )lc;
#line 963
  if (dist == 0) {
#line 965
    dyn_ltree[lc].fc.freq = (ush )((int )dyn_ltree[lc].fc.freq + 1);
  } else {
#line 968
    dist --;
#line 973
    dyn_ltree[((int )length_code[lc] + 256) + 1].fc.freq = (ush )((int )dyn_ltree[((int )length_code[lc] + 256) + 1].fc.freq + 1);
#line 974
    if (dist < 256) {
#line 974
      tmp___0 = (int )dist_code[dist];
    } else {
#line 974
      tmp___0 = (int )dist_code[256 + (dist >> 7)];
    }
#line 974
    dyn_dtree[tmp___0].fc.freq = (ush )((int )dyn_dtree[tmp___0].fc.freq + 1);
#line 976
    tmp___1 = last_dist;
#line 976
    last_dist ++;
#line 976
    d_buf[tmp___1] = (ush )dist;
#line 977
    flags = (uch )((int )flags | (int )flag_bit);
  }
#line 979
  flag_bit = (uch )((int )flag_bit << 1);
#line 982
  if ((last_lit & 7U) == 0U) {
#line 983
    tmp___2 = last_flags;
#line 983
    last_flags ++;
#line 983
    flag_buf[tmp___2] = flags;
#line 984
    flags = (uch )0;
#line 984
    flag_bit = (uch )1;
  }
#line 987
  if (level > 2) {
#line 987
    if ((last_lit & 4095U) == 0U) {
#line 989
      out_length = (ulg )last_lit * 8UL;
#line 990
      in_length = (ulg )strstart - (ulg )block_start;
#line 992
      dcode = 0;
      {
      {
#line 992
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 992
        if (! (dcode < 30)) {
#line 992
          goto while_break;
        }
#line 993
        out_length += (ulg )dyn_dtree[dcode].fc.freq * (ulg )(5L + (long )extra_dbits[dcode]);
#line 992
        dcode ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 995
      out_length >>= 3;
#line 999
      if (last_dist < last_lit / 2U) {
#line 999
        if (out_length < in_length / 2UL) {
#line 999
          return (1);
        }
      }
    }
  }
#line 1001
  if (last_lit == 32767U) {
#line 1001
    tmp___3 = 1;
  } else
#line 1001
  if (last_dist == 32768U) {
#line 1001
    tmp___3 = 1;
  } else {
#line 1001
    tmp___3 = 0;
  }
#line 1001
  return (tmp___3);
}
}
#line 1011 "trees.c"
static void compress_block(ct_data *ltree , ct_data *dtree ) 
{ 
  unsigned int dist ;
  int lc ;
  unsigned int lx ;
  unsigned int dx ;
  unsigned int fx ;
  uch flag ;
  unsigned int code ;
  int extra ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1017
  lx = 0U;
#line 1018
  dx = 0U;
#line 1019
  fx = 0U;
#line 1020
  flag = (uch )0;
#line 1024
  if (last_lit != 0U) {
    {
    {
#line 1024
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1025
      if ((lx & 7U) == 0U) {
#line 1025
        tmp = fx;
#line 1025
        fx ++;
#line 1025
        flag = flag_buf[tmp];
      }
#line 1026
      tmp___0 = lx;
#line 1026
      lx ++;
#line 1026
      lc = (int )inbuf[tmp___0];
#line 1027
      if (((int )flag & 1) == 0) {
        {
        {
#line 1028
        send_bits((int )(ltree + lc)->fc.code, (int )(ltree + lc)->dl.len);
        }
        }
      } else {
        {
#line 1032
        code = (unsigned int )length_code[lc];
        {
#line 1033
        send_bits((int )(ltree + ((code + 256U) + 1U))->fc.code, (int )(ltree + ((code + 256U) + 1U))->dl.len);
        }
#line 1034
        extra = extra_lbits[code];
        }
#line 1035
        if (extra != 0) {
          {
#line 1036
          lc -= base_length[code];
          {
#line 1037
          send_bits(lc, extra);
          }
          }
        }
#line 1039
        tmp___1 = dx;
#line 1039
        dx ++;
#line 1039
        dist = (unsigned int )d_buf[tmp___1];
#line 1041
        if (dist < 256U) {
#line 1041
          code = (unsigned int )dist_code[dist];
        } else {
#line 1041
          code = (unsigned int )dist_code[256U + (dist >> 7)];
        }
        {
        {
#line 1044
        send_bits((int )(dtree + code)->fc.code, (int )(dtree + code)->dl.len);
        }
#line 1045
        extra = extra_dbits[code];
        }
#line 1046
        if (extra != 0) {
          {
#line 1047
          dist -= (unsigned int )base_dist[code];
          {
#line 1048
          send_bits((int )dist, extra);
          }
          }
        }
      }
#line 1051
      flag = (uch )((int )flag >> 1);
#line 1024
      if (! (lx < last_lit)) {
#line 1024
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 1054
  send_bits((int )(ltree + 256)->fc.code, (int )(ltree + 256)->dl.len);
  }
  }
#line 1055
  return;
}
}
#line 1063 "trees.c"
static void set_file_type(void) 
{ 
  int n ;
  unsigned int ascii_freq ;
  unsigned int bin_freq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1065
  n = 0;
#line 1066
  ascii_freq = 0U;
#line 1067
  bin_freq = 0U;
  {
  {
#line 1068
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1068
    if (! (n < 7)) {
#line 1068
      goto while_break;
    }
#line 1068
    tmp = n;
#line 1068
    n ++;
#line 1068
    bin_freq += (unsigned int )dyn_ltree[tmp].fc.freq;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1069
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1069
    if (! (n < 128)) {
#line 1069
      goto while_break___0;
    }
#line 1069
    tmp___0 = n;
#line 1069
    n ++;
#line 1069
    ascii_freq += (unsigned int )dyn_ltree[tmp___0].fc.freq;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 1070
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1070
    if (! (n < 256)) {
#line 1070
      goto while_break___1;
    }
#line 1070
    tmp___1 = n;
#line 1070
    n ++;
#line 1070
    bin_freq += (unsigned int )dyn_ltree[tmp___1].fc.freq;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1071
  if (bin_freq > ascii_freq >> 2) {
#line 1071
    *file_type = (ush )0;
  } else {
#line 1071
    *file_type = (ush )1;
  }
#line 1072
  if ((int )*file_type == 0) {

  }
#line 1075
  return;
}
}
#line 279 "gzip.h"
void lm_init(int pack_level , ush *flags___0 ) ;
#line 280
ulg deflate(void) ;
#line 154 "deflate.c"
ulg window_size  =    65536UL;
#line 159 "deflate.c"
long block_start  ;
#line 164 "deflate.c"
static unsigned int ins_h  ;
#line 173 "deflate.c"
unsigned int prev_length  ;
#line 178 "deflate.c"
unsigned int strstart  ;
#line 179 "deflate.c"
unsigned int match_start  ;
#line 180 "deflate.c"
static int eofile  ;
#line 181 "deflate.c"
static unsigned int lookahead  ;
#line 183 "deflate.c"
unsigned int max_chain_length  ;
#line 188 "deflate.c"
static unsigned int max_lazy_match  ;
#line 199 "deflate.c"
static int compr_level  ;
#line 202 "deflate.c"
unsigned int good_match  ;
#line 222 "deflate.c"
int nice_match  ;
#line 225 "deflate.c"
static config configuration_table[10]  = 
#line 225
  {      {(ush )0, (ush )0, (ush )0, (ush )0}, 
        {(ush )4, (ush )4, (ush )8, (ush )4}, 
        {(ush )4, (ush )5, (ush )16, (ush )8}, 
        {(ush )4, (ush )6, (ush )32, (ush )32}, 
        {(ush )4, (ush )4, (ush )16, (ush )16}, 
        {(ush )8, (ush )16, (ush )32, (ush )32}, 
        {(ush )8, (ush )16, (ush )128, (ush )128}, 
        {(ush )8, (ush )32, (ush )128, (ush )256}, 
        {(ush )32, (ush )128, (ush )258, (ush )1024}, 
        {(ush )32, (ush )258, (ush )258, (ush )4096}};
#line 250
static void fill_window(void) ;
#line 251
static ulg deflate_fast(void) ;
#line 253
extern int longest_match(IPos cur_match ) ;
#line 255
extern void match_init(void) ;
#line 286 "deflate.c"
void lm_init(int pack_level , ush *flags___0 ) 
{ 
  register unsigned int j___0 ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_10 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  unsigned int tmp ;
  int tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 292
  if (pack_level < 1) {
    {
    {
#line 292
    error((char *)"bad pack level");
    }
    }
  } else
#line 292
  if (pack_level > 9) {
    {
    {
#line 292
    error((char *)"bad pack level");
    }
    }
  }
#line 293
  compr_level = pack_level;
#line 299
  if ((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768)) <= 16UL) {
#line 299
    if ((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768)) == 1UL) {
#line 299
      __s___1 = (voidp )((char *)(prev + 32768));
#line 299
      *((__uint8_t *)__s___1) = (__uint8_t )0;
    } else {
#line 299
      __s___0 = (voidp )((char *)(prev + 32768));
#line 299
      __u = (union __anonunion___u_10 *)__s___0;
#line 299
      __c = (__uint8_t )0;
      {
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 15U) {
#line 299
        goto case_15;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 11U) {
#line 299
        goto case_11;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 7U) {
#line 299
        goto case_7;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 3U) {
#line 299
        goto case_3;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 14U) {
#line 299
        goto case_14;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 10U) {
#line 299
        goto case_10;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 6U) {
#line 299
        goto case_6;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 2U) {
#line 299
        goto case_2;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 13U) {
#line 299
        goto case_13;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 9U) {
#line 299
        goto case_9;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 5U) {
#line 299
        goto case_5;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 1U) {
#line 299
        goto case_1;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 16U) {
#line 299
        goto case_16;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 12U) {
#line 299
        goto case_12;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 8U) {
#line 299
        goto case_8;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 4U) {
#line 299
        goto case_4;
      }
#line 299
      if ((unsigned int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))) == 0U) {
#line 299
        goto case_0;
      }
#line 299
      goto switch_break;
      case_15: /* CIL Label */ 
#line 299
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 299
      __u = (union __anonunion___u_10 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 299
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 299
      __u = (union __anonunion___u_10 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 299
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 299
      __u = (union __anonunion___u_10 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 299
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 299
      __u = (union __anonunion___u_10 *)((void *)__u + 2);
#line 299
      __u->__uc = __c;
#line 299
      goto switch_break;
      case_14: /* CIL Label */ 
#line 299
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 299
      __u = (union __anonunion___u_10 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 299
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 299
      __u = (union __anonunion___u_10 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 299
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 299
      __u = (union __anonunion___u_10 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 299
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 299
      goto switch_break;
      case_13: /* CIL Label */ 
#line 299
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 299
      __u = (union __anonunion___u_10 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 299
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 299
      __u = (union __anonunion___u_10 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 299
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 299
      __u = (union __anonunion___u_10 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 299
      __u->__uc = __c;
#line 299
      goto switch_break;
      case_16: /* CIL Label */ 
#line 299
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 299
      __u = (union __anonunion___u_10 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 299
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 299
      __u = (union __anonunion___u_10 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 299
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 299
      __u = (union __anonunion___u_10 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 299
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 299
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 299
    __s = (voidp )((char *)(prev + 32768));
    {
#line 299
    __builtin_memset(__s, '\000', (int )((unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768))));
    }
    }
  }
#line 305
  max_lazy_match = (unsigned int )configuration_table[pack_level].max_lazy;
#line 306
  good_match = (unsigned int )configuration_table[pack_level].good_length;
#line 308
  nice_match = (int )configuration_table[pack_level].nice_length;
#line 310
  max_chain_length = (unsigned int )configuration_table[pack_level].max_chain;
#line 311
  if (pack_level == 1) {
#line 312
    *flags___0 = (ush )((int )*flags___0 | 4);
  } else
#line 313
  if (pack_level == 9) {
#line 314
    *flags___0 = (ush )((int )*flags___0 | 2);
  }
  {
#line 318
  strstart = 0U;
#line 319
  block_start = 0L;
  {
#line 321
  match_init();
  }
  }
#line 324
  if (sizeof(int ) <= 2UL) {
#line 324
    tmp = 32768U;
  } else {
#line 324
    tmp = 65536U;
  }
  {
  {
#line 324
  tmp___0 = (*read_buf)((char *)(window), tmp);
  }
#line 324
  lookahead = (unsigned int )tmp___0;
  }
#line 327
  if (lookahead == 0U) {
#line 328
    eofile = 1;
#line 328
    lookahead = 0U;
#line 329
    return;
  } else
#line 327
  if (lookahead == 4294967295U) {
#line 328
    eofile = 1;
#line 328
    lookahead = 0U;
#line 329
    return;
  }
#line 331
  eofile = 0;
  {
  {
#line 335
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 335
    if (lookahead < 262U) {
#line 335
      if (! (! eofile)) {
#line 335
        goto while_break;
      }
    } else {
#line 335
      goto while_break;
    }
    {
    {
#line 335
    fill_window();
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  ins_h = 0U;
#line 338
  j___0 = 0U;
  {
  {
#line 338
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 338
    if (! (j___0 < 2U)) {
#line 338
      goto while_break___0;
    }
#line 338
    ins_h = ((ins_h << 5) ^ (unsigned int )window[j___0]) & ((unsigned int )(1 << 15) - 1U);
#line 338
    j___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 342
  return;
}
}
#line 516 "deflate.c"
static void fill_window(void) 
{ 
  register unsigned int n ;
  register unsigned int m ;
  unsigned int more ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 519
  more = (unsigned int )((window_size - (ulg )lookahead) - (ulg )strstart);
#line 525
  if (more == 4294967295U) {
#line 529
    more --;
  } else
#line 530
  if (strstart >= 65274U) {
    {
    {
#line 536
    memcpy((void */* __restrict  */)((char *)(window)), (void const   */* __restrict  */)((char *)(window) + 32768),
           32768U);
    }
#line 537
    match_start -= 32768U;
#line 538
    strstart -= 32768U;
#line 540
    block_start -= 32768L;
#line 542
    n = 0U;
    }
    {
    {
#line 542
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 542
      if (! (n < (unsigned int )(1 << 15))) {
#line 542
        goto while_break;
      }
#line 543
      m = (unsigned int )*((prev + 32768) + n);
#line 544
      if (m >= 32768U) {
#line 544
        tmp = m - 32768U;
      } else {
#line 544
        tmp = 0U;
      }
#line 544
      *((prev + 32768) + n) = (Pos )tmp;
#line 542
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 546
    n = 0U;
    {
    {
#line 546
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 546
      if (! (n < 32768U)) {
#line 546
        goto while_break___0;
      }
#line 547
      m = (unsigned int )prev[n];
#line 548
      if (m >= 32768U) {
#line 548
        tmp___0 = m - 32768U;
      } else {
#line 548
        tmp___0 = 0U;
      }
#line 548
      prev[n] = (Pos )tmp___0;
#line 546
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 553
    more += 32768U;
  }
#line 556
  if (! eofile) {
    {
    {
#line 557
    tmp___1 = (*read_buf)(((char *)(window) + strstart) + lookahead, more);
    }
#line 557
    n = (unsigned int )tmp___1;
    }
#line 558
    if (n == 0U) {
#line 559
      eofile = 1;
    } else
#line 558
    if (n == 4294967295U) {
#line 559
      eofile = 1;
    } else {
#line 561
      lookahead += n;
    }
  }
#line 564
  return;
}
}
#line 580 "deflate.c"
static ulg deflate_fast(void) 
{ 
  IPos hash_head ;
  int flush ;
  unsigned int match_length ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  ulg tmp___2 ;

  {
#line 584
  match_length = 0U;
#line 586
  prev_length = 2U;
  {
  {
#line 587
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 587
    if (! (lookahead != 0U)) {
#line 587
      goto while_break;
    }
#line 591
    ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 591
    hash_head = (IPos )*((prev + 32768) + ins_h);
#line 591
    prev[strstart & 32767U] = (ush )hash_head;
#line 591
    *((prev + 32768) + ins_h) = (ush )strstart;
#line 596
    if (hash_head != 0U) {
#line 596
      if (strstart - hash_head <= 32506U) {
        {
        {
#line 601
        tmp = longest_match(hash_head);
        }
#line 601
        match_length = (unsigned int )tmp;
        }
#line 603
        if (match_length > lookahead) {
#line 603
          match_length = lookahead;
        }
      }
    }
#line 605
    if (match_length >= 3U) {
      {
      {
#line 608
      flush = ct_tally((int )(strstart - match_start), (int )(match_length - 3U));
      }
#line 610
      lookahead -= match_length;
      }
#line 615
      if (match_length <= max_lazy_match) {
#line 616
        match_length --;
        {
        {
#line 617
        while (1) {
          while_continue___3: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 618
          strstart ++;
#line 619
          ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 619
          hash_head = (IPos )*((prev + 32768) + ins_h);
#line 619
          prev[strstart & 32767U] = (ush )hash_head;
#line 619
          *((prev + 32768) + ins_h) = (ush )strstart;
#line 617
          match_length --;
#line 617
          if (! (match_length != 0U)) {
#line 617
            goto while_break___0;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 626
        strstart ++;
      } else {
#line 628
        strstart += match_length;
#line 629
        match_length = 0U;
#line 630
        ins_h = (unsigned int )window[strstart];
#line 631
        ins_h = ((ins_h << 5) ^ (unsigned int )window[strstart + 1U]) & ((unsigned int )(1 << 15) - 1U);
      }
    } else {
      {
      {
#line 639
      flush = ct_tally(0, (int )window[strstart]);
      }
#line 640
      lookahead --;
#line 641
      strstart ++;
      }
    }
#line 643
    if (flush) {
#line 643
      if (block_start >= 0L) {
#line 643
        tmp___0 = (char *)(& window[(unsigned int )block_start]);
      } else {
#line 643
        tmp___0 = (char *)((void *)0);
      }
      {
      {
#line 643
      flush_block(tmp___0, (ulg )((long )strstart - block_start), 0);
      }
#line 643
      block_start = (long )strstart;
      }
    }
    {
    {
#line 650
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 650
      if (lookahead < 262U) {
#line 650
        if (! (! eofile)) {
#line 650
          goto while_break___1;
        }
      } else {
#line 650
        goto while_break___1;
      }
      {
      {
#line 650
      fill_window();
      }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 653
  if (block_start >= 0L) {
#line 653
    tmp___1 = (char *)(& window[(unsigned int )block_start]);
  } else {
#line 653
    tmp___1 = (char *)((void *)0);
  }
  {
  {
#line 653
  tmp___2 = flush_block(tmp___1, (ulg )((long )strstart - block_start), 1);
  }
  }
#line 653
  return (tmp___2);
}
}
#line 661 "deflate.c"
ulg deflate(void) 
{ 
  IPos hash_head ;
  IPos prev_match ;
  int flush ;
  int match_available ;
  register unsigned int match_length ;
  ulg tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  ulg tmp___5 ;

  {
#line 666
  match_available = 0;
#line 667
  match_length = 2U;
#line 669
  if (compr_level <= 3) {
    {
    {
#line 669
    tmp = deflate_fast();
    }
    }
#line 669
    return (tmp);
  }
  {
  {
#line 671
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 671
    if (! (lookahead != 0U)) {
#line 671
      goto while_break;
    }
#line 672
    ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 672
    hash_head = (IPos )*((prev + 32768) + ins_h);
#line 672
    prev[strstart & 32767U] = (ush )hash_head;
#line 672
    *((prev + 32768) + ins_h) = (ush )strstart;
#line 673
    prev_length = match_length;
#line 673
    prev_match = match_start;
#line 674
    match_length = 2U;
#line 676
    if (hash_head != 0U) {
#line 676
      if (prev_length < max_lazy_match) {
#line 676
        if (strstart - hash_head <= 32506U) {
          {
          {
#line 678
          tmp___0 = longest_match(hash_head);
          }
#line 678
          match_length = (unsigned int )tmp___0;
          }
#line 679
          if (match_length > lookahead) {
#line 679
            match_length = lookahead;
          }
#line 680
          if (match_length == 3U) {
#line 680
            if (strstart - match_start > 4096U) {
#line 681
              match_length --;
            }
          }
        }
      }
    }
#line 685
    if (prev_length >= 3U) {
#line 685
      if (match_length <= prev_length) {
        {
        {
#line 689
        flush = ct_tally((int )((strstart - 1U) - prev_match), (int )(prev_length - 3U));
        }
#line 691
        lookahead -= prev_length - 1U;
#line 692
        prev_length -= 2U;
        }
        {
        {
#line 693
        while (1) {
          while_continue___3: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 694
          strstart ++;
#line 695
          ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 695
          hash_head = (IPos )*((prev + 32768) + ins_h);
#line 695
          prev[strstart & 32767U] = (ush )hash_head;
#line 695
          *((prev + 32768) + ins_h) = (ush )strstart;
#line 693
          prev_length --;
#line 693
          if (! (prev_length != 0U)) {
#line 693
            goto while_break___0;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 697
        match_available = 0;
#line 698
        match_length = 2U;
#line 699
        strstart ++;
#line 700
        if (flush) {
#line 700
          if (block_start >= 0L) {
#line 700
            tmp___1 = (char *)(& window[(unsigned int )block_start]);
          } else {
#line 700
            tmp___1 = (char *)((void *)0);
          }
          {
          {
#line 700
          flush_block(tmp___1, (ulg )((long )strstart - block_start), 0);
          }
#line 700
          block_start = (long )strstart;
          }
        }
      } else {
#line 685
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 702
    if (match_available) {
      {
      {
#line 708
      tmp___3 = ct_tally(0, (int )window[strstart - 1U]);
      }
      }
#line 708
      if (tmp___3) {
#line 709
        if (block_start >= 0L) {
#line 709
          tmp___2 = (char *)(& window[(unsigned int )block_start]);
        } else {
#line 709
          tmp___2 = (char *)((void *)0);
        }
        {
        {
#line 709
        flush_block(tmp___2, (ulg )((long )strstart - block_start), 0);
        }
#line 709
        block_start = (long )strstart;
        }
      }
#line 711
      strstart ++;
#line 712
      lookahead --;
    } else {
#line 717
      match_available = 1;
#line 718
      strstart ++;
#line 719
      lookahead --;
    }
    {
    {
#line 728
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 728
      if (lookahead < 262U) {
#line 728
        if (! (! eofile)) {
#line 728
          goto while_break___1;
        }
      } else {
#line 728
        goto while_break___1;
      }
      {
      {
#line 728
      fill_window();
      }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 730
  if (match_available) {
    {
    {
#line 730
    ct_tally(0, (int )window[strstart - 1U]);
    }
    }
  }
#line 732
  if (block_start >= 0L) {
#line 732
    tmp___4 = (char *)(& window[(unsigned int )block_start]);
  } else {
#line 732
    tmp___4 = (char *)((void *)0);
  }
  {
  {
#line 732
  tmp___5 = flush_block(tmp___4, (ulg )((long )strstart - block_start), 1);
  }
  }
#line 732
  return (tmp___5);
}
}
#line 137 "gzip.h"
long header_bytes  ;
#line 148
long time_stamp ;
#line 200
int save_orig_name ;
#line 262
int zip(int in , int out ) ;
#line 25 "zip.c"
static ulg crc___0  ;
#line 33 "zip.c"
int zip(int in , int out ) 
{ 
  uch flags___0 ;
  ush attr ;
  ush deflate_flags ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  char *p ;
  char *tmp___13 ;
  unsigned int tmp___14 ;
  char *tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 36
  flags___0 = (uch )0;
#line 37
  attr = (ush )0;
#line 38
  deflate_flags = (ush )0;
#line 40
  ifd = in;
#line 41
  ofd = out;
#line 42
  outcnt = 0U;
#line 46
  method = 8;
#line 47
  tmp = outcnt;
#line 47
  outcnt ++;
#line 47
  outbuf[tmp] = (uch )*("\037\213" + 0);
#line 47
  if (outcnt == 16384U) {
    {
    {
#line 47
    flush_outbuf();
    }
    }
  }
#line 48
  tmp___0 = outcnt;
#line 48
  outcnt ++;
#line 48
  outbuf[tmp___0] = (uch )*("\037\213" + 1);
#line 48
  if (outcnt == 16384U) {
    {
    {
#line 48
    flush_outbuf();
    }
    }
  }
#line 49
  tmp___1 = outcnt;
#line 49
  outcnt ++;
#line 49
  outbuf[tmp___1] = (uch )8;
#line 49
  if (outcnt == 16384U) {
    {
    {
#line 49
    flush_outbuf();
    }
    }
  }
#line 51
  if (save_orig_name) {
#line 52
    flags___0 = (uch )((int )flags___0 | 8);
  }
#line 54
  tmp___2 = outcnt;
#line 54
  outcnt ++;
#line 54
  outbuf[tmp___2] = flags___0;
#line 54
  if (outcnt == 16384U) {
    {
    {
#line 54
    flush_outbuf();
    }
    }
  }
#line 55
  if (outcnt < 16382U) {
#line 55
    tmp___3 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___3] = (uch )((time_stamp & 65535L) & 255L);
#line 55
    tmp___4 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___4] = (uch )((int )((ush )(time_stamp & 65535L)) >> 8);
  } else {
#line 55
    tmp___5 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___5] = (uch )((time_stamp & 65535L) & 255L);
#line 55
    if (outcnt == 16384U) {
      {
      {
#line 55
      flush_outbuf();
      }
      }
    }
#line 55
    tmp___6 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___6] = (uch )((int )((ush )(time_stamp & 65535L)) >> 8);
#line 55
    if (outcnt == 16384U) {
      {
      {
#line 55
      flush_outbuf();
      }
      }
    }
  }
#line 55
  if (outcnt < 16382U) {
#line 55
    tmp___7 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___7] = (uch )(((ulg )time_stamp >> 16) & 255UL);
#line 55
    tmp___8 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___8] = (uch )((int )((ush )((ulg )time_stamp >> 16)) >> 8);
  } else {
#line 55
    tmp___9 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___9] = (uch )(((ulg )time_stamp >> 16) & 255UL);
#line 55
    if (outcnt == 16384U) {
      {
      {
#line 55
      flush_outbuf();
      }
      }
    }
#line 55
    tmp___10 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___10] = (uch )((int )((ush )((ulg )time_stamp >> 16)) >> 8);
#line 55
    if (outcnt == 16384U) {
      {
      {
#line 55
      flush_outbuf();
      }
      }
    }
  }
  {
  {
#line 58
  crc___0 = updcrc((uch *)0, 0U);
  }
  {
#line 60
  bi_init(out);
  }
  {
#line 61
  ct_init(& attr, & method);
  }
  {
#line 62
  lm_init(level, & deflate_flags);
  }
#line 64
  tmp___11 = outcnt;
#line 64
  outcnt ++;
#line 64
  outbuf[tmp___11] = (uch )deflate_flags;
  }
#line 64
  if (outcnt == 16384U) {
    {
    {
#line 64
    flush_outbuf();
    }
    }
  }
#line 65
  tmp___12 = outcnt;
#line 65
  outcnt ++;
#line 65
  outbuf[tmp___12] = (uch )3;
#line 65
  if (outcnt == 16384U) {
    {
    {
#line 65
    flush_outbuf();
    }
    }
  }
#line 67
  if (save_orig_name) {
    {
    {
#line 68
    tmp___13 = basename(ifname);
    }
#line 68
    p = tmp___13;
    }
    {
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 70
      tmp___14 = outcnt;
#line 70
      outcnt ++;
#line 70
      outbuf[tmp___14] = (uch )*p;
#line 70
      if (outcnt == 16384U) {
        {
        {
#line 70
        flush_outbuf();
        }
        }
      }
#line 69
      tmp___15 = p;
#line 69
      p ++;
#line 69
      if (! *tmp___15) {
#line 69
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 73
  header_bytes = (long )outcnt;
  {
#line 75
  deflate();
  }
  }
#line 89
  if (outcnt < 16382U) {
#line 89
    tmp___16 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___16] = (uch )((crc___0 & 65535UL) & 255UL);
#line 89
    tmp___17 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___17] = (uch )((int )((ush )(crc___0 & 65535UL)) >> 8);
  } else {
#line 89
    tmp___18 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___18] = (uch )((crc___0 & 65535UL) & 255UL);
#line 89
    if (outcnt == 16384U) {
      {
      {
#line 89
      flush_outbuf();
      }
      }
    }
#line 89
    tmp___19 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___19] = (uch )((int )((ush )(crc___0 & 65535UL)) >> 8);
#line 89
    if (outcnt == 16384U) {
      {
      {
#line 89
      flush_outbuf();
      }
      }
    }
  }
#line 89
  if (outcnt < 16382U) {
#line 89
    tmp___20 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___20] = (uch )((crc___0 >> 16) & 255UL);
#line 89
    tmp___21 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___21] = (uch )((int )((ush )(crc___0 >> 16)) >> 8);
  } else {
#line 89
    tmp___22 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___22] = (uch )((crc___0 >> 16) & 255UL);
#line 89
    if (outcnt == 16384U) {
      {
      {
#line 89
      flush_outbuf();
      }
      }
    }
#line 89
    tmp___23 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___23] = (uch )((int )((ush )(crc___0 >> 16)) >> 8);
#line 89
    if (outcnt == 16384U) {
      {
      {
#line 89
      flush_outbuf();
      }
      }
    }
  }
#line 90
  if (outcnt < 16382U) {
#line 90
    tmp___24 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___24] = (uch )((bytes_in & 65535L) & 255L);
#line 90
    tmp___25 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___25] = (uch )((int )((ush )(bytes_in & 65535L)) >> 8);
  } else {
#line 90
    tmp___26 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___26] = (uch )((bytes_in & 65535L) & 255L);
#line 90
    if (outcnt == 16384U) {
      {
      {
#line 90
      flush_outbuf();
      }
      }
    }
#line 90
    tmp___27 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___27] = (uch )((int )((ush )(bytes_in & 65535L)) >> 8);
#line 90
    if (outcnt == 16384U) {
      {
      {
#line 90
      flush_outbuf();
      }
      }
    }
  }
#line 90
  if (outcnt < 16382U) {
#line 90
    tmp___28 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___28] = (uch )(((ulg )bytes_in >> 16) & 255UL);
#line 90
    tmp___29 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___29] = (uch )((int )((ush )((ulg )bytes_in >> 16)) >> 8);
  } else {
#line 90
    tmp___30 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___30] = (uch )(((ulg )bytes_in >> 16) & 255UL);
#line 90
    if (outcnt == 16384U) {
      {
      {
#line 90
      flush_outbuf();
      }
      }
    }
#line 90
    tmp___31 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___31] = (uch )((int )((ush )((ulg )bytes_in >> 16)) >> 8);
#line 90
    if (outcnt == 16384U) {
      {
      {
#line 90
      flush_outbuf();
      }
      }
    }
  }
  {
#line 91
  header_bytes = (long )((unsigned long )header_bytes + 2UL * sizeof(long ));
  {
#line 93
  flush_outbuf();
  }
  }
#line 94
  return (0);
}
}
#line 103 "zip.c"
int file_read(char *buf , unsigned int size ) 
{ 
  unsigned int len ;
  ssize_t tmp ;

  {
  {
  {
#line 111
  tmp = read(ifd, (void *)buf, size);
  }
#line 111
  len = (unsigned int )tmp;
  }
#line 112
  if (len == 4294967295U) {
#line 112
    return ((int )len);
  } else
#line 112
  if (len == 0U) {
#line 112
    return ((int )len);
  }
  {
  {
#line 114
  crc___0 = updcrc((uch *)buf, len);
  }
#line 115
  bytes_in = (long )((ulg )bytes_in + (ulg )len);
  }
#line 116
  return ((int )len);
}
}
#line 12 "gzip.c"
static char *license_msg[15]  = 
#line 12 "gzip.c"
  {      (char *)"   Copyright (C) 1992-1993 Jean-loup Gailly",      (char *)"   This program is free software; you can redistribute it and/or modify",      (char *)"   it under the terms of the GNU General Public License as published by",      (char *)"   the Free Software Foundation; either version 2, or (at your option)", 
        (char *)"   any later version.",      (char *)"",      (char *)"   This program is distributed in the hope that it will be useful,",      (char *)"   but WITHOUT ANY WARRANTY; without even the implied warranty of", 
        (char *)"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",      (char *)"   GNU General Public License for more details.",      (char *)"",      (char *)"   You should have received a copy of the GNU General Public License", 
        (char *)"   along with this program; if not, write to the Free Software",      (char *)"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",      (char *)0};
#line 103 "/usr/include/bits/sigset.h"
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) ;
#line 104
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) ;
#line 105
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) ;
#line 117 "/usr/include/bits/sigset.h"
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) 
{ 
  unsigned long __mask ;
  unsigned long __word ;
  int tmp ;

  {
#line 117
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 117
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 117
  if (__set->__val[__word] & __mask) {
#line 117
    tmp = 1;
  } else {
#line 117
    tmp = 0;
  }
#line 117
  return (tmp);
}
}
#line 118 "/usr/include/bits/sigset.h"
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) 
{ 
  unsigned long __mask ;
  unsigned long __word ;

  {
#line 118
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 118
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 118
  __set->__val[__word] |= __mask;
#line 118
  return (0);
}
}
#line 119 "/usr/include/bits/sigset.h"
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) 
{ 
  unsigned long __mask ;
  unsigned long __word ;

  {
#line 119
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 119
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 119
  __set->__val[__word] &= ~ __mask;
#line 119
  return (0);
}
}
#line 90 "/usr/include/signal.h"
extern __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 207 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 212
__inline extern int fstat(int __fd , struct stat *__statbuf ) ;
#line 235
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 255
extern int chmod(char const   *__file , __mode_t __mode ) ;
#line 287
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 319
extern int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 320
extern int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf ) ;
#line 322
extern int __lxstat(int __ver , char const   *__filename , struct stat *__stat_buf ) ;
#line 350
extern int __xmknod(int __ver , char const   *__path , __mode_t __mode , __dev_t *__dev ) ;
#line 356 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
  {
#line 359
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
  }
#line 359
  return (tmp);
}
}
#line 363 "/usr/include/sys/stat.h"
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
  {
#line 366
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
  }
#line 366
  return (tmp);
}
}
#line 370 "/usr/include/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
  {
#line 372
  tmp = __fxstat(3, __fd, __statbuf);
  }
  }
#line 372
  return (tmp);
}
}
#line 376 "/usr/include/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
  {
#line 379
  tmp = __xmknod(1, __path, __mode, & __dev);
  }
  }
#line 379
  return (tmp);
}
}
#line 211 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 327
extern int printf(char const   * __restrict  __format  , ...) ;
#line 526
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 752
extern int fileno(FILE *__stream ) ;
#line 61 "/usr/include/string.h"
extern int memcmp(void const   *__s1 , void const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 85
extern char *strncpy(char * __restrict  __dest , char const   * __restrict  __src ,
                     size_t __n ) ;
#line 89
extern char *strcat(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 96
extern int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 99
extern int strncmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 115 "gzip.h"
uch inbuf[32832]  ;
#line 116 "gzip.h"
uch outbuf[18432]  ;
#line 117 "gzip.h"
ush d_buf[32768]  ;
#line 118 "gzip.h"
uch window[65536L]  ;
#line 123 "gzip.h"
ush prev[1L << 16]  ;
#line 131 "gzip.h"
unsigned int insize  ;
#line 132 "gzip.h"
unsigned int inptr  ;
#line 133 "gzip.h"
unsigned int outcnt  ;
#line 135 "gzip.h"
long bytes_in  ;
#line 136 "gzip.h"
long bytes_out  ;
#line 142 "gzip.h"
int ifd  ;
#line 143 "gzip.h"
int ofd  ;
#line 144 "gzip.h"
char ifname[1024]  ;
#line 145 "gzip.h"
char ofname[1024]  ;
#line 146 "gzip.h"
char *progname  ;
#line 148 "gzip.h"
long time_stamp  ;
#line 149 "gzip.h"
long ifile_size  ;
#line 195
int verbose ;
#line 200 "gzip.h"
int save_orig_name  ;
#line 31 "getopt.h"
extern char *optarg ;
#line 45
extern int optind ;
#line 104
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 254 "/usr/include/time.h"
extern char *ctime(time_t const   *__timer ) ;
#line 72 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...) ;
#line 286 "/usr/include/unistd.h"
extern __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 305
extern int close(int __fd ) ;
#line 418
extern int chown(char const   *__file , __uid_t __owner , __gid_t __group ) ;
#line 711
extern int isatty(int __fd ) ;
#line 736
extern int unlink(char const   *__name ) ;
#line 612 "/usr/include/stdlib.h"
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 142
extern int closedir(DIR *__dirp ) ;
#line 155
extern struct dirent *readdir(DIR *__dirp ) ;
#line 46 "/usr/include/utime.h"
extern int utime(char const   *__file , struct utimbuf  const  *__file_times ) ;
#line 201 "gzip.c"
int ascii  =    0;
#line 202 "gzip.c"
int to_stdout  =    0;
#line 203 "gzip.c"
int decompress  =    0;
#line 204 "gzip.c"
int force  =    0;
#line 205 "gzip.c"
int no_name  =    -1;
#line 206 "gzip.c"
int no_time  =    -1;
#line 207 "gzip.c"
int recursive  =    0;
#line 208 "gzip.c"
int list  =    0;
#line 209 "gzip.c"
int verbose  =    0;
#line 210 "gzip.c"
int quiet  =    0;
#line 211 "gzip.c"
int do_lzw  =    0;
#line 212 "gzip.c"
int test  =    0;
#line 213 "gzip.c"
int foreground  ;
#line 215 "gzip.c"
int maxbits  =    16;
#line 216 "gzip.c"
int method  =    8;
#line 217 "gzip.c"
int level  =    6;
#line 218 "gzip.c"
int exit_code  =    0;
#line 220 "gzip.c"
int last_member  ;
#line 221 "gzip.c"
int part_nb  ;
#line 224 "gzip.c"
char *env  ;
#line 225 "gzip.c"
char **args  =    (char **)((void *)0);
#line 226 "gzip.c"
char z_suffix[31]  ;
#line 227 "gzip.c"
int z_len  ;
#line 231 "gzip.c"
long total_in  =    0L;
#line 232 "gzip.c"
long total_out  =    0L;
#line 235 "gzip.c"
int remove_ofname  =    0;
#line 236 "gzip.c"
struct stat istat  ;
#line 243 "gzip.c"
struct option longopts[24]  = 
#line 243
  {      {"ascii", 0, (int *)0, 'a'}, 
        {"to-stdout", 0, (int *)0, 'c'}, 
        {"stdout", 0, (int *)0, 'c'}, 
        {"decompress", 0, (int *)0, 'd'}, 
        {"uncompress", 0, (int *)0, 'd'}, 
        {"force", 0, (int *)0, 'f'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"list", 0, (int *)0, 'l'}, 
        {"license", 0, (int *)0, 'L'}, 
        {"no-name", 0, (int *)0, 'n'}, 
        {"name", 0, (int *)0, 'N'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"silent", 0, (int *)0, 'q'}, 
        {"recursive", 0, (int *)0, 'r'}, 
        {"suffix", 1, (int *)0, 'S'}, 
        {"test", 0, (int *)0, 't'}, 
        {"no-time", 0, (int *)0, 'T'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"fast", 0, (int *)0, '1'}, 
        {"best", 0, (int *)0, '9'}, 
        {"lzw", 0, (int *)0, 'Z'}, 
        {"bits", 1, (int *)0, 'b'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 276
static void usage(void) ;
#line 277
static void help(void) ;
#line 278
static void license(void) ;
#line 279
static void version(void) ;
#line 280
static void treat_stdin(void) ;
#line 281
static void treat_file(char *iname ) ;
#line 282
static int create_outfile(void) ;
#line 283
static int do_stat(char *name , struct stat *sbuf ) ;
#line 284
static char *get_suffix(char *name ) ;
#line 285
static int get_istat(char *iname , struct stat *sbuf ) ;
#line 286
static int make_ofname(void) ;
#line 287
static int same_file(struct stat *stat1 , struct stat *stat2 ) ;
#line 288
static int name_too_long(char *name , struct stat *statb ) ;
#line 289
static void shorten_name(char *name ) ;
#line 290
static int get_method(int in ) ;
#line 291
static void do_list(int ifd___0 , int method___0 ) ;
#line 292
static int check_ofname(void) ;
#line 293
static void copy_stat(struct stat *ifstat ) ;
#line 294
static void do_exit(int exitcode ) ;
#line 295
int main(int argc , char **argv ) ;
#line 296 "gzip.c"
int (*work)(int infile , int outfile )  =    & zip;
#line 299
static void treat_dir(char *dir ) ;
#line 302
static void reset_times(char *name , struct stat *statb ) ;
#line 308 "gzip.c"
static void usage(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 310
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-%scdfhlLnN%stvV19] [-S suffix] [file ...]\n",
          progname, "", "r");
  }
  }
#line 323
  return;
}
}
#line 328 "gzip.c"
static char *help_msg[18]  = 
#line 328
  {      (char *)" -c --stdout      write on standard output, keep original files unchanged",      (char *)" -d --decompress  decompress",      (char *)" -f --force       force overwrite of output file and compress links",      (char *)" -h --help        give this help", 
        (char *)" -l --list        list compressed file contents",      (char *)" -L --license     display software license",      (char *)" -n --no-name     do not save or restore the original name and time stamp",      (char *)" -N --name        save or restore the original name and time stamp", 
        (char *)" -q --quiet       suppress all warnings",      (char *)" -r --recursive   operate recursively on directories",      (char *)" -S .suf  --suffix .suf     use suffix .suf on compressed files",      (char *)" -t --test        test compressed file integrity", 
        (char *)" -v --verbose     verbose mode",      (char *)" -V --version     display version number",      (char *)" -1 --fast        compress faster",      (char *)" -9 --best        compress better", 
        (char *)" file...          files to (de)compress. If none given, use standard input.",      (char *)0};
#line 326 "gzip.c"
static void help(void) 
{ 
  char **p ;
  char **tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 362
  p = help_msg;
  {
#line 364
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s (%s)\n",
          progname, "1.2.4", "18 Aug 93");
  }
  {
#line 365
  usage();
  }
  }
  {
  {
#line 366
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 366
    if (! *p) {
#line 366
      goto while_break;
    }
    {
#line 366
    tmp = p;
#line 366
    p ++;
    {
#line 366
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            *tmp);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  return;
}
}
#line 370 "gzip.c"
static void license(void) 
{ 
  char **p ;
  char **tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 372
  p = license_msg;
  {
#line 374
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s (%s)\n",
          progname, "1.2.4", "18 Aug 93");
  }
  }
  {
  {
#line 375
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 375
    if (! *p) {
#line 375
      goto while_break;
    }
    {
#line 375
    tmp = p;
#line 375
    p ++;
    {
#line 375
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            *tmp);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  return;
}
}
#line 379 "gzip.c"
static void version(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 381
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s (%s)\n",
          progname, "1.2.4", "18 Aug 93");
  }
  {
#line 383
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Compilation options:\n%s %s ",
          "DIRENT", "UTIME");
  }
  {
#line 385
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"STDC_HEADERS ");
  }
  {
#line 388
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"HAVE_UNISTD_H ");
  }
  {
#line 409
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ASMV ");
  }
  {
#line 420
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
  }
#line 421
  return;
}
}
#line 424 "gzip.c"
int main(int argc , char **argv ) 
{ 
  int file_count ;
  int proglen ;
  int optc ;
  size_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __sighandler_t tmp___6 ;
  __sighandler_t tmp___7 ;
  __sighandler_t tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  size_t tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  size_t tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  size_t tmp___46 ;
  size_t tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;

  {
  {
  {
#line 432
  progname = basename(*(argv + 0));
  }
  {
#line 433
  tmp = strlen((char const   *)progname);
  }
#line 433
  proglen = (int )tmp;
  }
#line 435
  if (proglen > 4) {
#line 435
    if (0) {
      {
      {
#line 435
      __s1_len = strlen((char const   *)((progname + proglen) - 4));
      }
      {
#line 435
      __s2_len = strlen(".exe");
      }
      }
#line 435
      if (! ((size_t )((void const   *)(((progname + proglen) - 4) + 1)) - (size_t )((void const   *)((progname + proglen) - 4)) == 1U)) {
#line 435
        goto _L___0;
      } else
#line 435
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 435
        if (! ((size_t )((void const   *)(".exe" + 1)) - (size_t )((void const   *)".exe") == 1U)) {
#line 435
          tmp___5 = 1;
        } else
#line 435
        if (__s2_len >= 4U) {
#line 435
          tmp___5 = 1;
        } else {
#line 435
          tmp___5 = 0;
        }
      } else {
#line 435
        tmp___5 = 0;
      }
#line 435
      if (tmp___5) {
#line 435
        if (__s1_len < __s2_len) {
#line 435
          tmp___1 = __s1_len;
        } else {
#line 435
          tmp___1 = __s2_len;
        }
        {
        {
#line 435
        tmp___2 = memcmp((void const   *)((char const   *)((progname + proglen) - 4)),
                         (void const   *)".exe", tmp___1 + 1U);
        }
#line 435
        tmp___4 = tmp___2;
        }
      } else {
        {
        {
#line 435
        tmp___3 = strcmp((char const   *)((progname + proglen) - 4), ".exe");
        }
#line 435
        tmp___4 = tmp___3;
        }
      }
    } else {
      {
      {
#line 435
      tmp___3 = strcmp((char const   *)((progname + proglen) - 4), ".exe");
      }
#line 435
      tmp___4 = tmp___3;
      }
    }
#line 435
    if (tmp___4 == 0) {
#line 436
      *(progname + (proglen - 4)) = (char )'\000';
    }
  }
  {
  {
#line 439
  env = add_envopt(& argc, & argv, (char *)"GZIP");
  }
  }
#line 440
  if ((unsigned long )env != (unsigned long )((void *)0)) {
#line 440
    args = argv;
  }
  {
  {
#line 442
  tmp___6 = signal(2, (void (*)(int  ))1);
  }
#line 442
  foreground = (unsigned long )tmp___6 != (unsigned long )((void (*)(int  ))1);
  }
#line 443
  if (foreground) {
    {
    {
#line 444
    signal(2, (void (*)(int  ))(& abort_gzip));
    }
    }
  }
  {
  {
#line 447
  tmp___7 = signal(15, (void (*)(int  ))1);
  }
  }
#line 447
  if ((unsigned long )tmp___7 != (unsigned long )((void (*)(int  ))1)) {
    {
    {
#line 448
    signal(15, (void (*)(int  ))(& abort_gzip));
    }
    }
  }
  {
  {
#line 452
  tmp___8 = signal(1, (void (*)(int  ))1);
  }
  }
#line 452
  if ((unsigned long )tmp___8 != (unsigned long )((void (*)(int  ))1)) {
    {
    {
#line 453
    signal(1, (void (*)(int  ))(& abort_gzip));
    }
    }
  }
#line 469
  if (0) {
#line 469
    if (0) {
      {
      {
#line 469
      __s1_len___2 = strlen((char const   *)progname);
      }
      {
#line 469
      __s2_len___2 = strlen("un");
      }
      }
#line 469
      if (! ((size_t )((void const   *)(progname + 1)) - (size_t )((void const   *)progname) == 1U)) {
#line 469
        goto _L___6;
      } else
#line 469
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 469
        if (! ((size_t )((void const   *)("un" + 1)) - (size_t )((void const   *)"un") == 1U)) {
#line 469
          tmp___28 = 1;
        } else
#line 469
        if (__s2_len___2 >= 4U) {
#line 469
          tmp___28 = 1;
        } else {
#line 469
          tmp___28 = 0;
        }
      } else {
#line 469
        tmp___28 = 0;
      }
#line 469
      if (tmp___28) {
#line 469
        if (__s1_len___2 < __s2_len___2) {
#line 469
          tmp___24 = __s1_len___2;
        } else {
#line 469
          tmp___24 = __s2_len___2;
        }
        {
        {
#line 469
        tmp___25 = memcmp((void const   *)((char const   *)progname), (void const   *)"un",
                          tmp___24 + 1U);
        }
#line 469
        tmp___27 = tmp___25;
        }
      } else {
        {
        {
#line 469
        tmp___26 = strcmp((char const   *)progname, "un");
        }
#line 469
        tmp___27 = tmp___26;
        }
      }
    } else {
      {
      {
#line 469
      tmp___26 = strcmp((char const   *)progname, "un");
      }
#line 469
      tmp___27 = tmp___26;
      }
    }
#line 469
    tmp___30 = tmp___27;
  } else {
    {
    {
#line 469
    tmp___29 = strncmp((char const   *)progname, "un", (size_t )2);
    }
#line 469
    tmp___30 = tmp___29;
    }
  }
#line 470
  if (tmp___30 == 0) {
#line 471
    decompress = 1;
  } else {
#line 470
    if (0) {
#line 470
      if (0) {
        {
        {
#line 470
        __s1_len___3 = strlen((char const   *)progname);
        }
        {
#line 470
        __s2_len___3 = strlen("gun");
        }
        }
#line 470
        if (! ((size_t )((void const   *)(progname + 1)) - (size_t )((void const   *)progname) == 1U)) {
#line 470
          goto _L___8;
        } else
#line 470
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 470
          if (! ((size_t )((void const   *)("gun" + 1)) - (size_t )((void const   *)"gun") == 1U)) {
#line 470
            tmp___40 = 1;
          } else
#line 470
          if (__s2_len___3 >= 4U) {
#line 470
            tmp___40 = 1;
          } else {
#line 470
            tmp___40 = 0;
          }
        } else {
#line 470
          tmp___40 = 0;
        }
#line 470
        if (tmp___40) {
#line 470
          if (__s1_len___3 < __s2_len___3) {
#line 470
            tmp___36 = __s1_len___3;
          } else {
#line 470
            tmp___36 = __s2_len___3;
          }
          {
          {
#line 470
          tmp___37 = memcmp((void const   *)((char const   *)progname), (void const   *)"gun",
                            tmp___36 + 1U);
          }
#line 470
          tmp___39 = tmp___37;
          }
        } else {
          {
          {
#line 470
          tmp___38 = strcmp((char const   *)progname, "gun");
          }
#line 470
          tmp___39 = tmp___38;
          }
        }
      } else {
        {
        {
#line 470
        tmp___38 = strcmp((char const   *)progname, "gun");
        }
#line 470
        tmp___39 = tmp___38;
        }
      }
#line 470
      tmp___42 = tmp___39;
    } else {
      {
      {
#line 470
      tmp___41 = strncmp((char const   *)progname, "gun", (size_t )3);
      }
#line 470
      tmp___42 = tmp___41;
      }
    }
#line 470
    if (tmp___42 == 0) {
#line 471
      decompress = 1;
    } else {
#line 472
      if (0) {
        {
        {
#line 472
        __s1_len___0 = strlen((char const   *)(progname + 1));
        }
        {
#line 472
        __s2_len___0 = strlen("cat");
        }
        }
#line 472
        if (! ((size_t )((void const   *)((progname + 1) + 1)) - (size_t )((void const   *)(progname + 1)) == 1U)) {
#line 472
          goto _L___2;
        } else
#line 472
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 472
          if (! ((size_t )((void const   *)("cat" + 1)) - (size_t )((void const   *)"cat") == 1U)) {
#line 472
            tmp___14 = 1;
          } else
#line 472
          if (__s2_len___0 >= 4U) {
#line 472
            tmp___14 = 1;
          } else {
#line 472
            tmp___14 = 0;
          }
        } else {
#line 472
          tmp___14 = 0;
        }
#line 472
        if (tmp___14) {
#line 472
          if (__s1_len___0 < __s2_len___0) {
#line 472
            tmp___10 = __s1_len___0;
          } else {
#line 472
            tmp___10 = __s2_len___0;
          }
          {
          {
#line 472
          tmp___11 = memcmp((void const   *)((char const   *)(progname + 1)), (void const   *)"cat",
                            tmp___10 + 1U);
          }
#line 472
          tmp___13 = tmp___11;
          }
        } else {
          {
          {
#line 472
          tmp___12 = strcmp((char const   *)(progname + 1), "cat");
          }
#line 472
          tmp___13 = tmp___12;
          }
        }
      } else {
        {
        {
#line 472
        tmp___12 = strcmp((char const   *)(progname + 1), "cat");
        }
#line 472
        tmp___13 = tmp___12;
        }
      }
#line 473
      if (tmp___13 == 0) {
#line 474
        to_stdout = 1;
#line 474
        decompress = to_stdout;
      } else {
#line 473
        if (0) {
          {
          {
#line 473
          __s1_len___1 = strlen((char const   *)progname);
          }
          {
#line 473
          __s2_len___1 = strlen("gzcat");
          }
          }
#line 473
          if (! ((size_t )((void const   *)(progname + 1)) - (size_t )((void const   *)progname) == 1U)) {
#line 473
            goto _L___4;
          } else
#line 473
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 473
            if (! ((size_t )((void const   *)("gzcat" + 1)) - (size_t )((void const   *)"gzcat") == 1U)) {
#line 473
              tmp___20 = 1;
            } else
#line 473
            if (__s2_len___1 >= 4U) {
#line 473
              tmp___20 = 1;
            } else {
#line 473
              tmp___20 = 0;
            }
          } else {
#line 473
            tmp___20 = 0;
          }
#line 473
          if (tmp___20) {
#line 473
            if (__s1_len___1 < __s2_len___1) {
#line 473
              tmp___16 = __s1_len___1;
            } else {
#line 473
              tmp___16 = __s2_len___1;
            }
            {
            {
#line 473
            tmp___17 = memcmp((void const   *)((char const   *)progname), (void const   *)"gzcat",
                              tmp___16 + 1U);
            }
#line 473
            tmp___19 = tmp___17;
            }
          } else {
            {
            {
#line 473
            tmp___18 = strcmp((char const   *)progname, "gzcat");
            }
#line 473
            tmp___19 = tmp___18;
            }
          }
        } else {
          {
          {
#line 473
          tmp___18 = strcmp((char const   *)progname, "gzcat");
          }
#line 473
          tmp___19 = tmp___18;
          }
        }
#line 473
        if (tmp___19 == 0) {
#line 474
          to_stdout = 1;
#line 474
          decompress = to_stdout;
        }
      }
    }
  }
  {
  {
#line 478
  strncpy((char */* __restrict  */)(z_suffix), (char const   */* __restrict  */)".gz",
          (size_t )(sizeof(z_suffix) - 1UL));
  }
  {
#line 479
  tmp___46 = strlen((char const   *)(z_suffix));
  }
#line 479
  z_len = (int )tmp___46;
  }
  {
  {
#line 481
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 481
    optc = getopt_long(argc, (char * const  *)argv, "ab:cdfhH?lLmMnNqrS:tvVZ123456789",
                       (struct option  const  *)(longopts), (int *)0);
    }
    }
#line 481
    if (! (optc != -1)) {
#line 481
      goto while_break;
    }
    {
#line 484
    if (optc == 97) {
#line 484
      goto case_97;
    }
#line 486
    if (optc == 98) {
#line 486
      goto case_98;
    }
#line 489
    if (optc == 99) {
#line 489
      goto case_99;
    }
#line 491
    if (optc == 100) {
#line 491
      goto case_100;
    }
#line 493
    if (optc == 102) {
#line 493
      goto case_102;
    }
#line 495
    if (optc == 63) {
#line 495
      goto case_63;
    }
#line 495
    if (optc == 72) {
#line 495
      goto case_63;
    }
#line 495
    if (optc == 104) {
#line 495
      goto case_63;
    }
#line 497
    if (optc == 108) {
#line 497
      goto case_108;
    }
#line 499
    if (optc == 76) {
#line 499
      goto case_76;
    }
#line 501
    if (optc == 109) {
#line 501
      goto case_109;
    }
#line 503
    if (optc == 77) {
#line 503
      goto case_77;
    }
#line 505
    if (optc == 110) {
#line 505
      goto case_110;
    }
#line 507
    if (optc == 78) {
#line 507
      goto case_78;
    }
#line 509
    if (optc == 113) {
#line 509
      goto case_113;
    }
#line 511
    if (optc == 114) {
#line 511
      goto case_114;
    }
#line 513
    if (optc == 83) {
#line 513
      goto case_83;
    }
#line 517
    if (optc == 116) {
#line 517
      goto case_116;
    }
#line 520
    if (optc == 118) {
#line 520
      goto case_118;
    }
#line 522
    if (optc == 86) {
#line 522
      goto case_86;
    }
#line 524
    if (optc == 90) {
#line 524
      goto case_90;
    }
#line 531
    if (optc == 57) {
#line 531
      goto case_57;
    }
#line 531
    if (optc == 56) {
#line 531
      goto case_57;
    }
#line 531
    if (optc == 55) {
#line 531
      goto case_57;
    }
#line 531
    if (optc == 54) {
#line 531
      goto case_57;
    }
#line 531
    if (optc == 53) {
#line 531
      goto case_57;
    }
#line 531
    if (optc == 52) {
#line 531
      goto case_57;
    }
#line 531
    if (optc == 51) {
#line 531
      goto case_57;
    }
#line 531
    if (optc == 50) {
#line 531
      goto case_57;
    }
#line 531
    if (optc == 49) {
#line 531
      goto case_57;
    }
#line 534
    goto switch_default;
    case_97: /* CIL Label */ 
#line 485
    ascii = 1;
#line 485
    goto switch_break;
    case_98: /* CIL Label */ 
    {
    {
#line 487
    maxbits = atoi((char const   *)optarg);
    }
    }
#line 488
    goto switch_break;
    case_99: /* CIL Label */ 
#line 490
    to_stdout = 1;
#line 490
    goto switch_break;
    case_100: /* CIL Label */ 
#line 492
    decompress = 1;
#line 492
    goto switch_break;
    case_102: /* CIL Label */ 
#line 494
    force ++;
#line 494
    goto switch_break;
    case_63: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_104: /* CIL Label */ 
    {
    {
#line 496
    help();
    }
    {
#line 496
    do_exit(0);
    }
    }
#line 496
    goto switch_break;
    case_108: /* CIL Label */ 
#line 498
    to_stdout = 1;
#line 498
    decompress = to_stdout;
#line 498
    list = decompress;
#line 498
    goto switch_break;
    case_76: /* CIL Label */ 
    {
    {
#line 500
    license();
    }
    {
#line 500
    do_exit(0);
    }
    }
#line 500
    goto switch_break;
    case_109: /* CIL Label */ 
#line 502
    no_time = 1;
#line 502
    goto switch_break;
    case_77: /* CIL Label */ 
#line 504
    no_time = 0;
#line 504
    goto switch_break;
    case_110: /* CIL Label */ 
#line 506
    no_time = 1;
#line 506
    no_name = no_time;
#line 506
    goto switch_break;
    case_78: /* CIL Label */ 
#line 508
    no_time = 0;
#line 508
    no_name = no_time;
#line 508
    goto switch_break;
    case_113: /* CIL Label */ 
#line 510
    quiet = 1;
#line 510
    verbose = 0;
#line 510
    goto switch_break;
    case_114: /* CIL Label */ 
#line 512
    recursive = 1;
#line 512
    goto switch_break;
    case_83: /* CIL Label */ 
    {
    {
#line 514
    tmp___47 = strlen((char const   *)optarg);
    }
#line 514
    z_len = (int )tmp___47;
    {
#line 515
    strcpy((char */* __restrict  */)(z_suffix), (char const   */* __restrict  */)optarg);
    }
    }
#line 516
    goto switch_break;
    case_116: /* CIL Label */ 
#line 518
    to_stdout = 1;
#line 518
    decompress = to_stdout;
#line 518
    test = decompress;
#line 519
    goto switch_break;
    case_118: /* CIL Label */ 
#line 521
    verbose ++;
#line 521
    quiet = 0;
#line 521
    goto switch_break;
    case_86: /* CIL Label */ 
    {
    {
#line 523
    version();
    }
    {
#line 523
    do_exit(0);
    }
    }
#line 523
    goto switch_break;
    case_90: /* CIL Label */ 
    {
    {
#line 525
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -Z not supported in this version\n",
            progname);
    }
    {
#line 527
    usage();
    }
    {
#line 528
    do_exit(1);
    }
    }
#line 528
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 532
    level = optc - 48;
#line 533
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 535
    usage();
    }
    {
#line 536
    do_exit(1);
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  if (no_time < 0) {
#line 540
    no_time = decompress;
  }
#line 541
  if (no_name < 0) {
#line 541
    no_name = decompress;
  }
#line 543
  file_count = argc - optind;
#line 545
  if (ascii) {
#line 545
    if (! quiet) {
      {
      {
#line 546
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option --ascii ignored on this system\n",
              progname);
      }
      }
    }
  }
#line 550
  if (z_len == 0) {
#line 550
    if (! decompress) {
      {
      {
#line 551
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: incorrect suffix \'%s\'\n",
              progname, optarg);
      }
      {
#line 553
      do_exit(1);
      }
      }
    } else {
#line 550
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 550
  if (z_len > 30) {
    {
    {
#line 551
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: incorrect suffix \'%s\'\n",
            progname, optarg);
    }
    {
#line 553
    do_exit(1);
    }
    }
  }
#line 555
  if (do_lzw) {
#line 555
    if (! decompress) {
#line 555
      work = & lzw;
    }
  }
#line 557
  if (file_count != 0) {
#line 558
    if (to_stdout) {
#line 558
      if (! test) {
#line 558
        if (! list) {
#line 558
          if (! decompress) {
#line 558
            tmp___48 = 1;
          } else
#line 558
          if (! ascii) {
#line 558
            tmp___48 = 1;
          } else {
#line 558
            tmp___48 = 0;
          }
        } else {
#line 558
          tmp___48 = 0;
        }
      } else {
#line 558
        tmp___48 = 0;
      }
    } else {
#line 558
      tmp___48 = 0;
    }
    {
    {
#line 561
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 561
      if (! (optind < argc)) {
#line 561
        goto while_break___0;
      }
      {
#line 562
      tmp___49 = optind;
#line 562
      optind ++;
      {
#line 562
      treat_file(*(argv + tmp___49));
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 565
    treat_stdin();
    }
    }
  }
#line 567
  if (list) {
#line 567
    if (! quiet) {
#line 567
      if (file_count > 1) {
        {
        {
#line 568
        do_list(-1, -1);
        }
        }
      }
    }
  }
  {
  {
#line 570
  do_exit(exit_code);
  }
  }
#line 571
  return (exit_code);
}
}
#line 577 "gzip.c"
static void treat_stdin(void) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  struct _IO_FILE *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 579
  if (! force) {
#line 579
    if (! list) {
#line 579
      if (decompress) {
#line 579
        tmp___1 = stdin;
      } else {
#line 579
        tmp___1 = stdout;
      }
      {
      {
#line 579
      tmp___2 = fileno(tmp___1);
      }
      {
#line 579
      tmp___3 = isatty(tmp___2);
      }
      }
#line 579
      if (tmp___3) {
#line 624
        if (decompress) {
#line 624
          tmp = "de";
        } else {
#line 624
          tmp = "";
        }
#line 624
        if (decompress) {
#line 624
          tmp___0 = "read from";
        } else {
#line 624
          tmp___0 = "written to";
        }
        {
        {
#line 624
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: compressed data not %s a terminal. Use -f to force %scompression.\n",
                progname, tmp___0, tmp);
        }
        {
#line 628
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"For help, type: %s -h\n",
                progname);
        }
        {
#line 629
        do_exit(1);
        }
        }
      }
    }
  }
#line 632
  if (decompress) {
#line 632
    tmp___4 = 1;
  } else
#line 632
  if (! ascii) {
#line 632
    tmp___4 = 1;
  } else {
#line 632
    tmp___4 = 0;
  }
#line 635
  if (! test) {
#line 635
    if (! list) {
#line 635
      if (! decompress) {
#line 635
        tmp___5 = 1;
      } else
#line 635
      if (! ascii) {
#line 635
        tmp___5 = 1;
      } else {
#line 635
        tmp___5 = 0;
      }
    } else {
#line 635
      tmp___5 = 0;
    }
  } else {
#line 635
    tmp___5 = 0;
  }
  {
  {
#line 638
  strcpy((char */* __restrict  */)(ifname), (char const   */* __restrict  */)"stdin");
  }
  {
#line 639
  strcpy((char */* __restrict  */)(ofname), (char const   */* __restrict  */)"stdout");
  }
#line 642
  time_stamp = 0L;
  }
#line 645
  if (list) {
#line 645
    goto _L;
  } else
#line 645
  if (! no_time) {
    _L: /* CIL Label */ 
    {
    {
#line 646
    tmp___6 = fileno(stdin);
    }
    {
#line 646
    tmp___7 = fstat(tmp___6, & istat);
    }
    }
#line 646
    if (tmp___7 != 0) {
      {
      {
#line 647
      error((char *)"fstat(stdin)");
      }
      }
    }
#line 652
    time_stamp = istat.st_mtim.tv_sec;
  }
  {
#line 655
  ifile_size = -1L;
  {
#line 657
  clear_bufs();
  }
#line 658
  to_stdout = 1;
#line 659
  part_nb = 0;
  }
#line 661
  if (decompress) {
    {
    {
#line 662
    method = get_method(ifd);
    }
    }
#line 663
    if (method < 0) {
      {
      {
#line 664
      do_exit(exit_code);
      }
      }
    }
  }
#line 667
  if (list) {
    {
    {
#line 668
    do_list(ifd, method);
    }
    }
#line 669
    return;
  }
  {
  {
#line 674
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 675
    tmp___8 = fileno(stdout);
    }
    {
#line 675
    tmp___9 = fileno(stdin);
    }
    {
#line 675
    tmp___10 = (*work)(tmp___9, tmp___8);
    }
    }
#line 675
    if (tmp___10 != 0) {
#line 675
      return;
    }
#line 677
    if (! decompress) {
#line 677
      goto while_break;
    } else
#line 677
    if (last_member) {
#line 677
      goto while_break;
    } else
#line 677
    if (inptr == insize) {
#line 677
      goto while_break;
    }
    {
    {
#line 680
    method = get_method(ifd);
    }
    }
#line 681
    if (method < 0) {
#line 681
      return;
    }
#line 682
    bytes_out = 0L;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  if (verbose) {
#line 686
    if (test) {
      {
      {
#line 687
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" OK\n");
      }
      }
    } else
#line 689
    if (! decompress) {
      {
      {
#line 690
      display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, stderr);
      }
      {
#line 691
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
      }
    }
  }
#line 699
  return;
}
}
#line 704 "gzip.c"
static void treat_file(char *iname ) 
{ 
  int cflag ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct stat st ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___12 ;
  size_t tmp___13 ;
  char const   *tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
#line 707
  if (0) {
    {
    {
#line 707
    __s1_len = strlen((char const   *)iname);
    }
    {
#line 707
    __s2_len = strlen("-");
    }
    }
#line 707
    if (! ((size_t )((void const   *)(iname + 1)) - (size_t )((void const   *)iname) == 1U)) {
#line 707
      goto _L___0;
    } else
#line 707
    if (__s1_len >= 4U) {
      _L___0: /* CIL Label */ 
#line 707
      if (! ((size_t )((void const   *)("-" + 1)) - (size_t )((void const   *)"-") == 1U)) {
#line 707
        tmp___4 = 1;
      } else
#line 707
      if (__s2_len >= 4U) {
#line 707
        tmp___4 = 1;
      } else {
#line 707
        tmp___4 = 0;
      }
    } else {
#line 707
      tmp___4 = 0;
    }
#line 707
    if (tmp___4) {
#line 707
      if (__s1_len < __s2_len) {
#line 707
        tmp___0 = __s1_len;
      } else {
#line 707
        tmp___0 = __s2_len;
      }
      {
      {
#line 707
      tmp___1 = memcmp((void const   *)((char const   *)iname), (void const   *)"-",
                       tmp___0 + 1U);
      }
#line 707
      tmp___3 = tmp___1;
      }
    } else {
      {
      {
#line 707
      tmp___2 = strcmp((char const   *)iname, "-");
      }
#line 707
      tmp___3 = tmp___2;
      }
    }
  } else {
    {
    {
#line 707
    tmp___2 = strcmp((char const   *)iname, "-");
    }
#line 707
    tmp___3 = tmp___2;
    }
  }
#line 707
  if (tmp___3 == 0) {
    {
#line 708
    cflag = to_stdout;
    {
#line 709
    treat_stdin();
    }
#line 710
    to_stdout = cflag;
    }
#line 711
    return;
  }
  {
  {
#line 714
  tmp___5 = get_istat(iname, & istat);
  }
  }
#line 714
  if (tmp___5 != 0) {
#line 714
    return;
  }
#line 715
  if ((istat.st_mode & 61440U) == 16384U) {
#line 716
    if (recursive) {
      {
#line 718
      st = istat;
      {
#line 719
      treat_dir(iname);
      }
      {
#line 720
      reset_times(iname, & st);
      }
      }
    } else {
#line 722
      if (! quiet) {
        {
        {
#line 722
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is a directory -- ignored\n",
                progname, ifname);
        }
        }
      }
#line 722
      if (exit_code == 0) {
#line 722
        exit_code = 2;
      }
    }
#line 723
    return;
  }
#line 725
  if (! ((istat.st_mode & 61440U) == 32768U)) {
#line 726
    if (! quiet) {
      {
      {
#line 726
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is not a directory or a regular file - ignored\n",
              progname, ifname);
      }
      }
    }
#line 726
    if (exit_code == 0) {
#line 726
      exit_code = 2;
    }
#line 727
    return;
  }
#line 729
  if (istat.st_nlink > 1U) {
#line 729
    if (! to_stdout) {
#line 729
      if (! force) {
#line 730
        if (! quiet) {
#line 730
          if (istat.st_nlink > 2U) {
#line 730
            tmp___6 = 's';
          } else {
#line 730
            tmp___6 = ' ';
          }
          {
          {
#line 730
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s has %d other link%c -- unchanged\n",
                  progname, ifname, (int )istat.st_nlink - 1, tmp___6);
          }
          }
        }
#line 730
        if (exit_code == 0) {
#line 730
          exit_code = 2;
        }
#line 731
        return;
      }
    }
  }
#line 733
  ifile_size = istat.st_size;
#line 734
  if (no_time) {
#line 734
    if (! list) {
#line 734
      time_stamp = 0L;
    } else {
#line 734
      time_stamp = istat.st_mtim.tv_sec;
    }
  } else {
#line 734
    time_stamp = istat.st_mtim.tv_sec;
  }
#line 736
  if (to_stdout) {
#line 736
    if (! list) {
#line 736
      if (! test) {
        {
        {
#line 737
        strcpy((char */* __restrict  */)(ofname), (char const   */* __restrict  */)"stdout");
        }
        }
      } else {
#line 736
        goto _L___2;
      }
    } else {
#line 736
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
    {
#line 739
    tmp___7 = make_ofname();
    }
    }
#line 739
    if (tmp___7 != 0) {
#line 740
      return;
    }
  }
#line 743
  if (ascii) {
#line 743
    if (! decompress) {
#line 743
      tmp___8 = 0;
    } else {
#line 743
      tmp___8 = 0;
    }
  } else {
#line 743
    tmp___8 = 0;
  }
  {
  {
#line 743
  ifd = open((char const   *)(ifname), tmp___8, 384);
  }
  }
#line 745
  if (ifd == -1) {
    {
    {
#line 746
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
    }
    {
#line 747
    perror((char const   *)(ifname));
    }
#line 748
    exit_code = 1;
    }
#line 749
    return;
  }
  {
  {
#line 751
  clear_bufs();
  }
#line 752
  part_nb = 0;
  }
#line 754
  if (decompress) {
    {
    {
#line 755
    method = get_method(ifd);
    }
    }
#line 756
    if (method < 0) {
      {
      {
#line 757
      close(ifd);
      }
      }
#line 758
      return;
    }
  }
#line 761
  if (list) {
    {
    {
#line 762
    do_list(ifd, method);
    }
    {
#line 763
    close(ifd);
    }
    }
#line 764
    return;
  }
#line 767
  if (to_stdout) {
    {
    {
#line 768
    ofd = fileno(stdout);
    }
    }
  } else {
    {
    {
#line 770
    tmp___9 = create_outfile();
    }
    }
#line 770
    if (tmp___9 != 0) {
#line 770
      return;
    }
#line 772
    if (! decompress) {
#line 772
      if (save_orig_name) {
#line 772
        if (! verbose) {
#line 772
          if (! quiet) {
            {
            {
#line 773
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s compressed to %s\n",
                    progname, ifname, ofname);
            }
            }
          }
        }
      }
    }
  }
#line 778
  if (! save_orig_name) {
#line 778
    save_orig_name = ! no_name;
  }
#line 779
  if (verbose) {
    {
    {
#line 780
    tmp___15 = strlen((char const   *)(ifname));
    }
    }
#line 780
    if ((int )tmp___15 >= 15) {
#line 780
      tmp___14 = "";
    } else {
      {
      {
#line 780
      tmp___13 = strlen((char const   *)(ifname));
      }
      }
#line 780
      if ((int )tmp___13 >= 7) {
#line 780
        tmp___12 = "\t";
      } else {
#line 780
        tmp___12 = "\t\t";
      }
#line 780
      tmp___14 = tmp___12;
    }
    {
    {
#line 780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:\t%s",
            ifname, tmp___14);
    }
    }
  }
  {
  {
#line 784
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 785
    tmp___16 = (*work)(ifd, ofd);
    }
    }
#line 785
    if (tmp___16 != 0) {
#line 786
      method = -1;
#line 787
      goto while_break;
    }
#line 789
    if (! decompress) {
#line 789
      goto while_break;
    } else
#line 789
    if (last_member) {
#line 789
      goto while_break;
    } else
#line 789
    if (inptr == insize) {
#line 789
      goto while_break;
    }
    {
    {
#line 792
    method = get_method(ifd);
    }
    }
#line 793
    if (method < 0) {
#line 793
      goto while_break;
    }
#line 794
    bytes_out = 0L;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 797
  close(ifd);
  }
  }
#line 798
  if (! to_stdout) {
    {
    {
#line 798
    tmp___17 = close(ofd);
    }
    }
#line 798
    if (tmp___17) {
      {
      {
#line 799
      write_error();
      }
      }
    }
  }
#line 801
  if (method == -1) {
#line 802
    if (! to_stdout) {
      {
      {
#line 802
      unlink((char const   *)(ofname));
      }
      }
    }
#line 803
    return;
  }
#line 806
  if (verbose) {
#line 807
    if (test) {
      {
      {
#line 808
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" OK");
      }
      }
    } else
#line 809
    if (decompress) {
      {
      {
#line 810
      display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, stderr);
      }
      }
    } else {
      {
      {
#line 812
      display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, stderr);
      }
      }
    }
#line 814
    if (! test) {
#line 814
      if (! to_stdout) {
        {
        {
#line 815
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -- replaced with %s",
                ofname);
        }
        }
      }
    }
    {
    {
#line 817
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
    }
  }
#line 820
  if (! to_stdout) {
    {
    {
#line 821
    copy_stat(& istat);
    }
    }
  }
#line 823
  return;
}
}
#line 863 "gzip.c"
static int create_outfile(void) 
{ 
  struct stat ostat ;
  int flags___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 866
  flags___0 = 193;
#line 868
  if (ascii) {
#line 868
    if (decompress) {
#line 869
      flags___0 &= -1;
    }
  }
  {
  {
#line 871
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 873
    tmp = check_ofname();
    }
    }
#line 873
    if (tmp != 0) {
      {
      {
#line 874
      close(ifd);
      }
      }
#line 875
      return (1);
    }
    {
#line 878
    remove_ofname = 1;
    {
#line 879
    ofd = open((char const   *)(ofname), flags___0, 384);
    }
    }
#line 880
    if (ofd == -1) {
      {
      {
#line 881
      perror((char const   *)(ofname));
      }
      {
#line 882
      close(ifd);
      }
#line 883
      exit_code = 1;
      }
#line 884
      return (1);
    }
    {
    {
#line 891
    tmp___0 = fstat(ofd, & ostat);
    }
    }
#line 891
    if (tmp___0 != 0) {
      {
      {
#line 893
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              progname);
      }
      {
#line 894
      perror((char const   *)(ofname));
      }
      {
#line 895
      close(ifd);
      }
      {
#line 895
      close(ofd);
      }
      {
#line 896
      unlink((char const   *)(ofname));
      }
#line 897
      exit_code = 1;
      }
#line 898
      return (1);
    }
    {
    {
#line 900
    tmp___1 = name_too_long(ofname, & ostat);
    }
    }
#line 900
    if (! tmp___1) {
#line 900
      return (0);
    }
#line 902
    if (decompress) {
#line 904
      if (! quiet) {
        {
        {
#line 904
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: warning, name truncated\n",
                progname, ofname);
        }
        }
      }
#line 904
      if (exit_code == 0) {
#line 904
        exit_code = 2;
      }
#line 906
      return (0);
    }
    {
    {
#line 908
    close(ofd);
    }
    {
#line 909
    unlink((char const   *)(ofname));
    }
    {
#line 915
    shorten_name(ofname);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 923 "gzip.c"
static int do_stat(char *name , struct stat *sbuf ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 927
  tmp = __errno_location();
  }
#line 927
  *tmp = 0;
  }
#line 929
  if (! to_stdout) {
#line 929
    if (! force) {
      {
      {
#line 930
      tmp___0 = lstat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)sbuf);
      }
      }
#line 930
      return (tmp___0);
    }
  }
  {
  {
#line 933
  tmp___1 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)sbuf);
  }
  }
#line 933
  return (tmp___1);
}
}
#line 953 "gzip.c"
static char *known_suffixes[9]  = 
#line 953
  {      z_suffix,      (char *)".gz",      (char *)".z",      (char *)".taz", 
        (char *)".tgz",      (char *)"-gz",      (char *)"-z",      (char *)"_z", 
        (char *)((void *)0)};
#line 948 "gzip.c"
static char *get_suffix(char *name ) 
{ 
  int nlen ;
  int slen ;
  char suffix[33] ;
  char **suf ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int s ;
  size_t tmp___7 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
#line 955
  suf = known_suffixes;
#line 957
  if (0) {
    {
    {
#line 957
    __s1_len = strlen((char const   *)(z_suffix));
    }
    {
#line 957
    __s2_len = strlen("z");
    }
    }
#line 957
    if (! ((size_t )((void const   *)(z_suffix + 1)) - (size_t )((void const   *)(z_suffix)) == 1U)) {
#line 957
      goto _L___0;
    } else
#line 957
    if (__s1_len >= 4U) {
      _L___0: /* CIL Label */ 
#line 957
      if (! ((size_t )((void const   *)("z" + 1)) - (size_t )((void const   *)"z") == 1U)) {
#line 957
        tmp___4 = 1;
      } else
#line 957
      if (__s2_len >= 4U) {
#line 957
        tmp___4 = 1;
      } else {
#line 957
        tmp___4 = 0;
      }
    } else {
#line 957
      tmp___4 = 0;
    }
#line 957
    if (tmp___4) {
#line 957
      if (__s1_len < __s2_len) {
#line 957
        tmp___0 = __s1_len;
      } else {
#line 957
        tmp___0 = __s2_len;
      }
      {
      {
#line 957
      tmp___1 = memcmp((void const   *)((char const   *)(z_suffix)), (void const   *)"z",
                       tmp___0 + 1U);
      }
#line 957
      tmp___3 = tmp___1;
      }
    } else {
      {
      {
#line 957
      tmp___2 = strcmp((char const   *)(z_suffix), "z");
      }
#line 957
      tmp___3 = tmp___2;
      }
    }
  } else {
    {
    {
#line 957
    tmp___2 = strcmp((char const   *)(z_suffix), "z");
    }
#line 957
    tmp___3 = tmp___2;
    }
  }
#line 957
  if (tmp___3 == 0) {
#line 957
    suf ++;
  }
  {
  {
#line 970
  tmp___5 = strlen((char const   *)name);
  }
#line 970
  nlen = (int )tmp___5;
  }
#line 971
  if (nlen <= 32) {
    {
    {
#line 972
    strcpy((char */* __restrict  */)(suffix), (char const   */* __restrict  */)name);
    }
    }
  } else {
    {
    {
#line 974
    strcpy((char */* __restrict  */)(suffix), (char const   */* __restrict  */)(((name + nlen) - 30) - 2));
    }
    }
  }
  {
  {
#line 976
  strlwr(suffix);
  }
  {
#line 977
  tmp___6 = strlen((char const   *)(suffix));
  }
#line 977
  slen = (int )tmp___6;
  }
  {
  {
#line 978
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 979
    tmp___7 = strlen((char const   *)*suf);
    }
#line 979
    s = (int )tmp___7;
    }
#line 981
    if (slen > s) {
#line 981
      if ((int )suffix[(slen - s) - 1] != 47) {
#line 981
        if (0) {
          {
          {
#line 981
          __s1_len___0 = strlen((char const   *)((suffix + slen) - s));
          }
          {
#line 981
          __s2_len___0 = strlen((char const   *)*suf);
          }
          }
#line 981
          if (! ((size_t )((void const   *)(((suffix + slen) - s) + 1)) - (size_t )((void const   *)((suffix + slen) - s)) == 1U)) {
#line 981
            goto _L___2;
          } else
#line 981
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 981
            if (! ((size_t )((void const   *)(*suf + 1)) - (size_t )((void const   *)*suf) == 1U)) {
#line 981
              tmp___13 = 1;
            } else
#line 981
            if (__s2_len___0 >= 4U) {
#line 981
              tmp___13 = 1;
            } else {
#line 981
              tmp___13 = 0;
            }
          } else {
#line 981
            tmp___13 = 0;
          }
#line 981
          if (tmp___13) {
#line 981
            if (__s1_len___0 < __s2_len___0) {
#line 981
              tmp___9 = __s1_len___0;
            } else {
#line 981
              tmp___9 = __s2_len___0;
            }
            {
            {
#line 981
            tmp___10 = memcmp((void const   *)((char const   *)((suffix + slen) - s)),
                              (void const   *)((char const   *)*suf), tmp___9 + 1U);
            }
#line 981
            tmp___12 = tmp___10;
            }
          } else {
            {
            {
#line 981
            tmp___11 = strcmp((char const   *)((suffix + slen) - s), (char const   *)*suf);
            }
#line 981
            tmp___12 = tmp___11;
            }
          }
        } else {
          {
          {
#line 981
          tmp___11 = strcmp((char const   *)((suffix + slen) - s), (char const   *)*suf);
          }
#line 981
          tmp___12 = tmp___11;
          }
        }
#line 981
        if (tmp___12 == 0) {
#line 982
          return ((name + nlen) - s);
        }
      }
    }
#line 978
    suf ++;
#line 978
    if (! ((unsigned long )*suf != (unsigned long )((void *)0))) {
#line 978
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 986
  return ((char *)((void *)0));
}
}
#line 1002 "gzip.c"
static char *suffixes[6]  = {      z_suffix,      (char *)".gz",      (char *)".z",      (char *)"-z", 
        (char *)".Z",      (char *)((void *)0)};
#line 997 "gzip.c"
static int get_istat(char *iname , struct stat *sbuf ) 
{ 
  int ilen ;
  char **suf ;
  char *s ;
  int tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 1003
  suf = suffixes;
  {
#line 1005
  strcpy((char */* __restrict  */)(ifname), (char const   */* __restrict  */)iname);
  }
  {
#line 1006
  tmp = do_stat(ifname, sbuf);
  }
  }
#line 1006
  if (tmp == 0) {
#line 1006
    return (0);
  }
#line 1008
  if (! decompress) {
    {
    {
#line 1009
    perror((char const   *)(ifname));
    }
#line 1010
    exit_code = 1;
    }
#line 1011
    return (1);
  } else {
    {
    {
#line 1008
    tmp___0 = __errno_location();
    }
    }
#line 1008
    if (*tmp___0 != 2) {
      {
      {
#line 1009
      perror((char const   *)(ifname));
      }
#line 1010
      exit_code = 1;
      }
#line 1011
      return (1);
    }
  }
  {
  {
#line 1013
  s = get_suffix(ifname);
  }
  }
#line 1014
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
    {
#line 1015
    perror((char const   *)(ifname));
    }
#line 1016
    exit_code = 1;
    }
#line 1017
    return (1);
  }
  {
  {
#line 1019
  tmp___1 = strlen((char const   *)(ifname));
  }
#line 1019
  ilen = (int )tmp___1;
  }
#line 1020
  if (0) {
    {
    {
#line 1020
    __s1_len = strlen((char const   *)(z_suffix));
    }
    {
#line 1020
    __s2_len = strlen(".gz");
    }
    }
#line 1020
    if (! ((size_t )((void const   *)(z_suffix + 1)) - (size_t )((void const   *)(z_suffix)) == 1U)) {
#line 1020
      goto _L___0;
    } else
#line 1020
    if (__s1_len >= 4U) {
      _L___0: /* CIL Label */ 
#line 1020
      if (! ((size_t )((void const   *)(".gz" + 1)) - (size_t )((void const   *)".gz") == 1U)) {
#line 1020
        tmp___7 = 1;
      } else
#line 1020
      if (__s2_len >= 4U) {
#line 1020
        tmp___7 = 1;
      } else {
#line 1020
        tmp___7 = 0;
      }
    } else {
#line 1020
      tmp___7 = 0;
    }
#line 1020
    if (tmp___7) {
#line 1020
      if (__s1_len < __s2_len) {
#line 1020
        tmp___3 = __s1_len;
      } else {
#line 1020
        tmp___3 = __s2_len;
      }
      {
      {
#line 1020
      tmp___4 = memcmp((void const   *)((char const   *)(z_suffix)), (void const   *)".gz",
                       tmp___3 + 1U);
      }
#line 1020
      tmp___6 = tmp___4;
      }
    } else {
      {
      {
#line 1020
      tmp___5 = strcmp((char const   *)(z_suffix), ".gz");
      }
#line 1020
      tmp___6 = tmp___5;
      }
    }
  } else {
    {
    {
#line 1020
    tmp___5 = strcmp((char const   *)(z_suffix), ".gz");
    }
#line 1020
    tmp___6 = tmp___5;
    }
  }
#line 1020
  if (tmp___6 == 0) {
#line 1020
    suf ++;
  }
  {
  {
#line 1022
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
#line 1023
    s = *suf;
    {
#line 1051
    strcat((char */* __restrict  */)(ifname), (char const   */* __restrict  */)s);
    }
    {
#line 1052
    tmp___8 = do_stat(ifname, sbuf);
    }
    }
#line 1052
    if (tmp___8 == 0) {
#line 1052
      return (0);
    }
#line 1053
    ifname[ilen] = (char )'\000';
#line 1022
    suf ++;
#line 1022
    if (! ((unsigned long )*suf != (unsigned long )((void *)0))) {
#line 1022
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1056
  strcat((char */* __restrict  */)(ifname), (char const   */* __restrict  */)(z_suffix));
  }
  {
#line 1057
  perror((char const   *)(ifname));
  }
#line 1058
  exit_code = 1;
  }
#line 1059
  return (1);
}
}
#line 1066 "gzip.c"
static int make_ofname(void) 
{ 
  char *suff ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
  {
  {
#line 1070
  strcpy((char */* __restrict  */)(ofname), (char const   */* __restrict  */)(ifname));
  }
  {
#line 1072
  suff = get_suffix(ofname);
  }
  }
#line 1074
  if (decompress) {
#line 1075
    if ((unsigned long )suff == (unsigned long )((void *)0)) {
#line 1079
      if (! recursive) {
#line 1079
        if (list) {
#line 1079
          return (0);
        } else
#line 1079
        if (test) {
#line 1079
          return (0);
        }
      }
#line 1082
      if (verbose) {
#line 1082
        goto _L;
      } else
#line 1082
      if (! recursive) {
#line 1082
        if (! quiet) {
          _L: /* CIL Label */ 
#line 1083
          if (! quiet) {
            {
            {
#line 1083
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: unknown suffix -- ignored\n",
                    progname, ifname);
            }
            }
          }
#line 1083
          if (exit_code == 0) {
#line 1083
            exit_code = 2;
          }
        }
      }
#line 1086
      return (2);
    }
    {
    {
#line 1089
    strlwr(suff);
    }
    }
#line 1090
    if (0) {
      {
      {
#line 1090
      __s1_len = strlen((char const   *)suff);
      }
      {
#line 1090
      __s2_len = strlen(".tgz");
      }
      }
#line 1090
      if (! ((size_t )((void const   *)(suff + 1)) - (size_t )((void const   *)suff) == 1U)) {
#line 1090
        goto _L___1;
      } else
#line 1090
      if (__s1_len >= 4U) {
        _L___1: /* CIL Label */ 
#line 1090
        if (! ((size_t )((void const   *)(".tgz" + 1)) - (size_t )((void const   *)".tgz") == 1U)) {
#line 1090
          tmp___4 = 1;
        } else
#line 1090
        if (__s2_len >= 4U) {
#line 1090
          tmp___4 = 1;
        } else {
#line 1090
          tmp___4 = 0;
        }
      } else {
#line 1090
        tmp___4 = 0;
      }
#line 1090
      if (tmp___4) {
#line 1090
        if (__s1_len < __s2_len) {
#line 1090
          tmp___0 = __s1_len;
        } else {
#line 1090
          tmp___0 = __s2_len;
        }
        {
        {
#line 1090
        tmp___1 = memcmp((void const   *)((char const   *)suff), (void const   *)".tgz",
                         tmp___0 + 1U);
        }
#line 1090
        tmp___3 = tmp___1;
        }
      } else {
        {
        {
#line 1090
        tmp___2 = strcmp((char const   *)suff, ".tgz");
        }
#line 1090
        tmp___3 = tmp___2;
        }
      }
    } else {
      {
      {
#line 1090
      tmp___2 = strcmp((char const   *)suff, ".tgz");
      }
#line 1090
      tmp___3 = tmp___2;
      }
    }
#line 1090
    if (tmp___3 == 0) {
      {
      {
#line 1091
      strcpy((char */* __restrict  */)suff, (char const   */* __restrict  */)".tar");
      }
      }
    } else {
#line 1090
      if (0) {
        {
        {
#line 1090
        __s1_len___0 = strlen((char const   *)suff);
        }
        {
#line 1090
        __s2_len___0 = strlen(".taz");
        }
        }
#line 1090
        if (! ((size_t )((void const   *)(suff + 1)) - (size_t )((void const   *)suff) == 1U)) {
#line 1090
          goto _L___3;
        } else
#line 1090
        if (__s1_len___0 >= 4U) {
          _L___3: /* CIL Label */ 
#line 1090
          if (! ((size_t )((void const   *)(".taz" + 1)) - (size_t )((void const   *)".taz") == 1U)) {
#line 1090
            tmp___10 = 1;
          } else
#line 1090
          if (__s2_len___0 >= 4U) {
#line 1090
            tmp___10 = 1;
          } else {
#line 1090
            tmp___10 = 0;
          }
        } else {
#line 1090
          tmp___10 = 0;
        }
#line 1090
        if (tmp___10) {
#line 1090
          if (__s1_len___0 < __s2_len___0) {
#line 1090
            tmp___6 = __s1_len___0;
          } else {
#line 1090
            tmp___6 = __s2_len___0;
          }
          {
          {
#line 1090
          tmp___7 = memcmp((void const   *)((char const   *)suff), (void const   *)".taz",
                           tmp___6 + 1U);
          }
#line 1090
          tmp___9 = tmp___7;
          }
        } else {
          {
          {
#line 1090
          tmp___8 = strcmp((char const   *)suff, ".taz");
          }
#line 1090
          tmp___9 = tmp___8;
          }
        }
      } else {
        {
        {
#line 1090
        tmp___8 = strcmp((char const   *)suff, ".taz");
        }
#line 1090
        tmp___9 = tmp___8;
        }
      }
#line 1090
      if (tmp___9 == 0) {
        {
        {
#line 1091
        strcpy((char */* __restrict  */)suff, (char const   */* __restrict  */)".tar");
        }
        }
      } else {
#line 1093
        *suff = (char )'\000';
      }
    }
  } else
#line 1097
  if ((unsigned long )suff != (unsigned long )((void *)0)) {
#line 1099
    if (verbose) {
      {
      {
#line 1100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s already has %s suffix -- unchanged\n",
              progname, ifname, suff);
      }
      }
    } else
#line 1099
    if (! recursive) {
#line 1099
      if (! quiet) {
        {
        {
#line 1100
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s already has %s suffix -- unchanged\n",
                progname, ifname, suff);
        }
        }
      }
    }
#line 1103
    if (exit_code == 0) {
#line 1103
      exit_code = 2;
    }
#line 1104
    return (2);
  } else {
    {
#line 1106
    save_orig_name = 0;
    {
#line 1133
    strcat((char */* __restrict  */)(ofname), (char const   */* __restrict  */)(z_suffix));
    }
    }
  }
#line 1136
  return (0);
}
}
#line 1151 "gzip.c"
static int get_method(int in ) 
{ 
  uch flags___0 ;
  char magic[2] ;
  ulg stamp ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  unsigned int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int part ;
  unsigned int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  unsigned int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  unsigned int len ;
  unsigned int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  unsigned int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  char c ;
  unsigned int tmp___45 ;
  int tmp___46 ;
  char *p ;
  char *tmp___47 ;
  char *base ;
  unsigned int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;
  unsigned int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  void *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;

  {
#line 1161
  if (force) {
#line 1161
    if (to_stdout) {
#line 1162
      if (inptr < insize) {
#line 1162
        tmp = inptr;
#line 1162
        inptr ++;
#line 1162
        tmp___1 = (int )inbuf[tmp];
      } else {
        {
        {
#line 1162
        tmp___0 = fill_inbuf(1);
        }
#line 1162
        tmp___1 = tmp___0;
        }
      }
#line 1162
      magic[0] = (char )tmp___1;
#line 1163
      if (inptr < insize) {
#line 1163
        tmp___2 = inptr;
#line 1163
        inptr ++;
#line 1163
        tmp___4 = (int )inbuf[tmp___2];
      } else {
        {
        {
#line 1163
        tmp___3 = fill_inbuf(1);
        }
#line 1163
        tmp___4 = tmp___3;
        }
      }
#line 1163
      magic[1] = (char )tmp___4;
    } else {
#line 1161
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1166
    if (inptr < insize) {
#line 1166
      tmp___5 = inptr;
#line 1166
      inptr ++;
#line 1166
      tmp___7 = (int )inbuf[tmp___5];
    } else {
      {
      {
#line 1166
      tmp___6 = fill_inbuf(0);
      }
#line 1166
      tmp___7 = tmp___6;
      }
    }
#line 1166
    magic[0] = (char )tmp___7;
#line 1167
    if (inptr < insize) {
#line 1167
      tmp___8 = inptr;
#line 1167
      inptr ++;
#line 1167
      tmp___10 = (int )inbuf[tmp___8];
    } else {
      {
      {
#line 1167
      tmp___9 = fill_inbuf(0);
      }
#line 1167
      tmp___10 = tmp___9;
      }
    }
#line 1167
    magic[1] = (char )tmp___10;
  }
  {
#line 1169
  method = -1;
#line 1170
  part_nb ++;
#line 1171
  header_bytes = 0L;
#line 1172
  last_member = 0;
  {
#line 1175
  tmp___61 = memcmp((void const   *)(magic), (void const   *)"\037\213", (size_t )2);
  }
  }
#line 1175
  if (tmp___61 == 0) {
#line 1175
    goto _L___4;
  } else {
    {
    {
#line 1175
    tmp___62 = memcmp((void const   *)(magic), (void const   *)"\037\236", (size_t )2);
    }
    }
#line 1175
    if (tmp___62 == 0) {
      _L___4: /* CIL Label */ 
#line 1178
      if (inptr < insize) {
#line 1178
        tmp___11 = inptr;
#line 1178
        inptr ++;
#line 1178
        tmp___13 = (int )inbuf[tmp___11];
      } else {
        {
        {
#line 1178
        tmp___12 = fill_inbuf(0);
        }
#line 1178
        tmp___13 = tmp___12;
        }
      }
#line 1178
      method = tmp___13;
#line 1179
      if (method != 8) {
        {
        {
#line 1180
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: unknown method %d -- get newer version of gzip\n",
                progname, ifname, method);
        }
#line 1183
        exit_code = 1;
        }
#line 1184
        return (-1);
      }
#line 1186
      work = & unzip;
#line 1187
      if (inptr < insize) {
#line 1187
        tmp___14 = inptr;
#line 1187
        inptr ++;
#line 1187
        tmp___16 = (int )inbuf[tmp___14];
      } else {
        {
        {
#line 1187
        tmp___15 = fill_inbuf(0);
        }
#line 1187
        tmp___16 = tmp___15;
        }
      }
#line 1187
      flags___0 = (uch )tmp___16;
#line 1189
      if (((int )flags___0 & 32) != 0) {
        {
        {
#line 1190
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is encrypted -- get newer version of gzip\n",
                progname, ifname);
        }
#line 1193
        exit_code = 1;
        }
#line 1194
        return (-1);
      }
#line 1196
      if (((int )flags___0 & 2) != 0) {
        {
        {
#line 1197
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is a a multi-part gzip file -- get newer version of gzip\n",
                progname, ifname);
        }
#line 1200
        exit_code = 1;
        }
#line 1201
        if (force <= 1) {
#line 1201
          return (-1);
        }
      }
#line 1203
      if (((int )flags___0 & 192) != 0) {
        {
        {
#line 1204
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s has flags 0x%x -- get newer version of gzip\n",
                progname, ifname, (int )flags___0);
        }
#line 1207
        exit_code = 1;
        }
#line 1208
        if (force <= 1) {
#line 1208
          return (-1);
        }
      }
#line 1210
      if (inptr < insize) {
#line 1210
        tmp___17 = inptr;
#line 1210
        inptr ++;
#line 1210
        tmp___19 = (int )inbuf[tmp___17];
      } else {
        {
        {
#line 1210
        tmp___18 = fill_inbuf(0);
        }
#line 1210
        tmp___19 = tmp___18;
        }
      }
#line 1210
      stamp = (ulg )tmp___19;
#line 1211
      if (inptr < insize) {
#line 1211
        tmp___20 = inptr;
#line 1211
        inptr ++;
#line 1211
        tmp___22 = (int )inbuf[tmp___20];
      } else {
        {
        {
#line 1211
        tmp___21 = fill_inbuf(0);
        }
#line 1211
        tmp___22 = tmp___21;
        }
      }
#line 1211
      stamp |= (ulg )tmp___22 << 8;
#line 1212
      if (inptr < insize) {
#line 1212
        tmp___23 = inptr;
#line 1212
        inptr ++;
#line 1212
        tmp___25 = (int )inbuf[tmp___23];
      } else {
        {
        {
#line 1212
        tmp___24 = fill_inbuf(0);
        }
#line 1212
        tmp___25 = tmp___24;
        }
      }
#line 1212
      stamp |= (ulg )tmp___25 << 16;
#line 1213
      if (inptr < insize) {
#line 1213
        tmp___26 = inptr;
#line 1213
        inptr ++;
#line 1213
        tmp___28 = (int )inbuf[tmp___26];
      } else {
        {
        {
#line 1213
        tmp___27 = fill_inbuf(0);
        }
#line 1213
        tmp___28 = tmp___27;
        }
      }
#line 1213
      stamp |= (ulg )tmp___28 << 24;
#line 1214
      if (stamp != 0UL) {
#line 1214
        if (! no_time) {
#line 1214
          time_stamp = (long )stamp;
        }
      }
#line 1216
      if (inptr < insize) {
#line 1216
        tmp___29 = inptr;
#line 1216
        inptr ++;
      } else {
        {
        {
#line 1216
        fill_inbuf(0);
        }
        }
      }
#line 1217
      if (inptr < insize) {
#line 1217
        tmp___30 = inptr;
#line 1217
        inptr ++;
      } else {
        {
        {
#line 1217
        fill_inbuf(0);
        }
        }
      }
#line 1219
      if (((int )flags___0 & 2) != 0) {
#line 1220
        if (inptr < insize) {
#line 1220
          tmp___31 = inptr;
#line 1220
          inptr ++;
#line 1220
          tmp___33 = (int )inbuf[tmp___31];
        } else {
          {
          {
#line 1220
          tmp___32 = fill_inbuf(0);
          }
#line 1220
          tmp___33 = tmp___32;
          }
        }
#line 1220
        part = (unsigned int )tmp___33;
#line 1221
        if (inptr < insize) {
#line 1221
          tmp___34 = inptr;
#line 1221
          inptr ++;
#line 1221
          tmp___36 = (int )inbuf[tmp___34];
        } else {
          {
          {
#line 1221
          tmp___35 = fill_inbuf(0);
          }
#line 1221
          tmp___36 = tmp___35;
          }
        }
#line 1221
        part |= (unsigned int )tmp___36 << 8;
#line 1222
        if (verbose) {
          {
          {
#line 1223
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: part number %u\n",
                  progname, ifname, part);
          }
          }
        }
      }
#line 1227
      if (((int )flags___0 & 4) != 0) {
#line 1228
        if (inptr < insize) {
#line 1228
          tmp___37 = inptr;
#line 1228
          inptr ++;
#line 1228
          tmp___39 = (int )inbuf[tmp___37];
        } else {
          {
          {
#line 1228
          tmp___38 = fill_inbuf(0);
          }
#line 1228
          tmp___39 = tmp___38;
          }
        }
#line 1228
        len = (unsigned int )tmp___39;
#line 1229
        if (inptr < insize) {
#line 1229
          tmp___40 = inptr;
#line 1229
          inptr ++;
#line 1229
          tmp___42 = (int )inbuf[tmp___40];
        } else {
          {
          {
#line 1229
          tmp___41 = fill_inbuf(0);
          }
#line 1229
          tmp___42 = tmp___41;
          }
        }
#line 1229
        len |= (unsigned int )tmp___42 << 8;
#line 1230
        if (verbose) {
          {
          {
#line 1231
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: extra field of %u bytes ignored\n",
                  progname, ifname, len);
          }
          }
        }
        {
        {
#line 1234
        while (1) {
          while_continue___3: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
#line 1234
          tmp___44 = len;
#line 1234
          len --;
#line 1234
          if (! tmp___44) {
#line 1234
            goto while_break;
          }
#line 1234
          if (inptr < insize) {
#line 1234
            tmp___43 = inptr;
#line 1234
            inptr ++;
          } else {
            {
            {
#line 1234
            fill_inbuf(0);
            }
            }
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 1238
      if (((int )flags___0 & 8) != 0) {
#line 1239
        if (no_name) {
#line 1239
          goto _L___0;
        } else
#line 1239
        if (to_stdout) {
#line 1239
          if (! list) {
#line 1239
            goto _L___0;
          } else {
#line 1239
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1239
        if (part_nb > 1) {
          _L___0: /* CIL Label */ 
          {
          {
#line 1242
          while (1) {
            while_continue___4: /* CIL Label */ ;
            while_continue___0: /* CIL Label */ ;
#line 1242
            if (inptr < insize) {
#line 1242
              tmp___45 = inptr;
#line 1242
              inptr ++;
#line 1242
              c = (char )inbuf[tmp___45];
            } else {
              {
              {
#line 1242
              tmp___46 = fill_inbuf(0);
              }
#line 1242
              c = (char )tmp___46;
              }
            }
#line 1242
            if (! ((int )c != 0)) {
#line 1242
              goto while_break___0;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
          {
#line 1245
          tmp___47 = basename(ofname);
          }
#line 1245
          p = tmp___47;
#line 1246
          base = p;
          }
          {
          {
#line 1247
          while (1) {
            while_continue___5: /* CIL Label */ ;
            while_continue___1: /* CIL Label */ ;
#line 1248
            if (inptr < insize) {
#line 1248
              tmp___48 = inptr;
#line 1248
              inptr ++;
#line 1248
              tmp___50 = (int )inbuf[tmp___48];
            } else {
              {
              {
#line 1248
              tmp___49 = fill_inbuf(0);
              }
#line 1248
              tmp___50 = tmp___49;
              }
            }
#line 1248
            *p = (char )tmp___50;
#line 1249
            tmp___51 = p;
#line 1249
            p ++;
#line 1249
            if ((int )*tmp___51 == 0) {
#line 1249
              goto while_break___1;
            }
#line 1250
            if ((unsigned long )p >= (unsigned long )(ofname + sizeof(ofname))) {
              {
              {
#line 1251
              error((char *)"corrupted input -- file name too large");
              }
              }
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1255
          if (! list) {
#line 1257
            if (base) {
#line 1257
              list = 0;
            }
          }
        }
      }
#line 1263
      if (((int )flags___0 & 16) != 0) {
        {
        {
#line 1264
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 1264
          if (inptr < insize) {
#line 1264
            tmp___52 = inptr;
#line 1264
            inptr ++;
#line 1264
            tmp___54 = (int )inbuf[tmp___52];
          } else {
            {
            {
#line 1264
            tmp___53 = fill_inbuf(0);
            }
#line 1264
            tmp___54 = tmp___53;
            }
          }
#line 1264
          if (! (tmp___54 != 0)) {
#line 1264
            goto while_break___2;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 1266
      if (part_nb == 1) {
#line 1267
        header_bytes = (long )((unsigned long )inptr + 2UL * sizeof(long ));
      }
    } else {
      {
      {
#line 1270
      tmp___59 = memcmp((void const   *)(magic), (void const   *)"PK\003\004", (size_t )2);
      }
      }
#line 1270
      if (tmp___59 == 0) {
#line 1270
        if (inptr == 2U) {
          {
          {
#line 1270
          tmp___60 = memcmp((void const   *)((char *)(inbuf)), (void const   *)"PK\003\004",
                            (size_t )4);
          }
          }
#line 1270
          if (tmp___60 == 0) {
            {
#line 1275
            inptr = 0U;
#line 1276
            work = & unzip;
            {
#line 1277
            tmp___55 = check_zipfile(in);
            }
            }
#line 1277
            if (tmp___55 != 0) {
#line 1277
              return (-1);
            }
#line 1279
            last_member = 1;
          } else {
#line 1270
            goto _L___3;
          }
        } else {
#line 1270
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
        {
        {
#line 1281
        tmp___58 = memcmp((void const   *)(magic), (void const   *)"\037\036", (size_t )2);
        }
        }
#line 1281
        if (tmp___58 == 0) {
#line 1282
          work = & unpack;
#line 1283
          method = 2;
        } else {
          {
          {
#line 1285
          tmp___57 = memcmp((void const   *)(magic), (void const   *)"\037\235", (size_t )2);
          }
          }
#line 1285
          if (tmp___57 == 0) {
#line 1286
            work = & unlzw;
#line 1287
            method = 1;
#line 1288
            last_member = 1;
          } else {
            {
            {
#line 1290
            tmp___56 = memcmp((void const   *)(magic), (void const   *)"\037\240",
                              (size_t )2);
            }
            }
#line 1290
            if (tmp___56 == 0) {
#line 1291
              work = & unlzh;
#line 1292
              method = 3;
#line 1293
              last_member = 1;
            } else
#line 1295
            if (force) {
#line 1295
              if (to_stdout) {
#line 1295
                if (! list) {
#line 1296
                  method = 0;
#line 1297
                  work = & copy;
#line 1298
                  inptr = 0U;
#line 1299
                  last_member = 1;
                }
              }
            }
          }
        }
      }
    }
  }
#line 1301
  if (method >= 0) {
#line 1301
    return (method);
  }
#line 1303
  if (part_nb == 1) {
    {
    {
#line 1304
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: not in gzip format\n",
            progname, ifname);
    }
#line 1305
    exit_code = 1;
    }
#line 1306
    return (-1);
  } else {
#line 1308
    if (! quiet) {
      {
      {
#line 1308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: decompression OK, trailing garbage ignored\n",
              progname, ifname);
      }
      }
    }
#line 1308
    if (exit_code == 0) {
#line 1308
      exit_code = 2;
    }
#line 1310
    return (-2);
  }
}
}
#line 1324 "gzip.c"
static int first_time  =    1;
#line 1325 "gzip.c"
static char *methods[9]  = 
#line 1325
  {      (char *)"store",      (char *)"compr",      (char *)"pack ",      (char *)"lzh  ", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"defla"};
#line 1319 "gzip.c"
static void do_list(int ifd___0 , int method___0 ) 
{ 
  ulg crc___1 ;
  char *date ;
  __off_t tmp ;
  uch buf[8] ;
  ssize_t tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 1334
  if (first_time) {
#line 1334
    if (method___0 >= 0) {
#line 1335
      first_time = 0;
#line 1336
      if (verbose) {
        {
        {
#line 1337
        printf((char const   */* __restrict  */)"method  crc     date  time  ");
        }
        }
      }
#line 1339
      if (! quiet) {
        {
        {
#line 1340
        printf((char const   */* __restrict  */)"compressed  uncompr. ratio uncompressed_name\n");
        }
        }
      }
    } else {
#line 1334
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1342
  if (method___0 < 0) {
#line 1343
    if (total_in <= 0L) {
#line 1343
      return;
    } else
#line 1343
    if (total_out <= 0L) {
#line 1343
      return;
    }
#line 1344
    if (verbose) {
      {
      {
#line 1345
      printf((char const   */* __restrict  */)"                            %9lu %9lu ",
             total_in, total_out);
      }
      }
    } else
#line 1347
    if (! quiet) {
      {
      {
#line 1348
      printf((char const   */* __restrict  */)"%9ld %9ld ", total_in, total_out);
      }
      }
    }
    {
    {
#line 1350
    display_ratio(total_out - (total_in - header_bytes), total_out, stdout);
    }
    {
#line 1354
    printf((char const   */* __restrict  */)" (totals)\n");
    }
    }
#line 1355
    return;
  }
#line 1357
  crc___1 = (ulg )(~ 0);
#line 1358
  bytes_out = -1L;
#line 1359
  bytes_in = ifile_size;
#line 1362
  if (method___0 == 8) {
#line 1362
    if (! last_member) {
      {
      {
#line 1369
      tmp = lseek(ifd___0, (off_t )-8, 2);
      }
#line 1369
      bytes_in = tmp;
      }
#line 1370
      if (bytes_in != -1L) {
        {
#line 1372
        bytes_in += 8L;
        {
#line 1373
        tmp___0 = read(ifd___0, (void *)((char *)(buf)), (size_t )sizeof(buf));
        }
        }
#line 1373
        if ((unsigned long )tmp___0 != sizeof(buf)) {
          {
          {
#line 1374
          read_error();
          }
          }
        }
#line 1376
        crc___1 = (ulg )((int )((ush )buf[0]) | ((int )((ush )buf[1]) << 8)) | ((ulg )((int )((ush )*((buf + 2) + 0)) | ((int )((ush )*((buf + 2) + 1)) << 8)) << 16);
#line 1377
        bytes_out = (long )((ulg )((int )((ush )*((buf + 4) + 0)) | ((int )((ush )*((buf + 4) + 1)) << 8)) | ((ulg )((int )((ush )*(((buf + 4) + 2) + 0)) | ((int )((ush )*(((buf + 4) + 2) + 1)) << 8)) << 16));
      }
    }
  }
  {
  {
#line 1380
  tmp___1 = ctime((time_t const   *)(& time_stamp));
  }
#line 1380
  date = tmp___1 + 4;
#line 1381
  *(date + 12) = (char )'\000';
  }
#line 1382
  if (verbose) {
    {
    {
#line 1383
    printf((char const   */* __restrict  */)"%5s %08lx %11s ", methods[method___0],
           crc___1, date);
    }
    }
  }
  {
  {
#line 1385
  printf((char const   */* __restrict  */)"%9ld %9ld ", bytes_in, bytes_out);
  }
  }
#line 1386
  if (bytes_in == -1L) {
#line 1387
    total_in = -1L;
#line 1388
    header_bytes = 0L;
#line 1388
    bytes_out = header_bytes;
#line 1388
    bytes_in = bytes_out;
  } else
#line 1389
  if (total_in >= 0L) {
#line 1390
    total_in += bytes_in;
  }
#line 1392
  if (bytes_out == -1L) {
#line 1393
    total_out = -1L;
#line 1394
    header_bytes = 0L;
#line 1394
    bytes_out = header_bytes;
#line 1394
    bytes_in = bytes_out;
  } else
#line 1395
  if (total_out >= 0L) {
#line 1396
    total_out += bytes_out;
  }
  {
  {
#line 1398
  display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, stdout);
  }
  {
#line 1399
  printf((char const   */* __restrict  */)" %s\n", ofname);
  }
  }
#line 1400
  return;
}
}
#line 1405 "gzip.c"
static int same_file(struct stat *stat1 , struct stat *stat2 ) 
{ 
  int tmp ;

  {
#line 1409
  if (stat1->st_ino == stat2->st_ino) {
#line 1409
    if (stat1->st_dev == stat2->st_dev) {
#line 1409
      tmp = 1;
    } else {
#line 1409
      tmp = 0;
    }
  } else {
#line 1409
    tmp = 0;
  }
#line 1409
  return (tmp);
}
}
#line 1429 "gzip.c"
static int name_too_long(char *name , struct stat *statb ) 
{ 
  int s ;
  size_t tmp ;
  char c ;
  struct stat tstat ;
  int res ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 1433
  tmp = strlen((char const   *)name);
  }
#line 1433
  s = (int )tmp;
#line 1434
  c = *(name + (s - 1));
#line 1438
  tstat = *statb;
#line 1439
  *(name + (s - 1)) = (char )'\000';
  {
#line 1440
  tmp___0 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& tstat));
  }
  }
#line 1440
  if (tmp___0 == 0) {
    {
    {
#line 1440
    tmp___1 = same_file(statb, & tstat);
    }
    }
#line 1440
    if (tmp___1) {
#line 1440
      tmp___2 = 1;
    } else {
#line 1440
      tmp___2 = 0;
    }
  } else {
#line 1440
    tmp___2 = 0;
  }
#line 1440
  res = tmp___2;
#line 1441
  *(name + (s - 1)) = c;
#line 1443
  return (res);
}
}
#line 1455 "gzip.c"
static void shorten_name(char *name ) 
{ 
  int len ;
  char *trunc ;
  int plen ;
  int min_part ;
  char *p ;
  size_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
#line 1459
  trunc = (char *)((void *)0);
#line 1461
  min_part = 3;
  {
#line 1464
  tmp = strlen((char const   *)name);
  }
#line 1464
  len = (int )tmp;
  }
#line 1465
  if (decompress) {
#line 1466
    if (len <= 1) {
      {
      {
#line 1466
      error((char *)"name too short");
      }
      }
    }
#line 1467
    *(name + (len - 1)) = (char )'\000';
#line 1468
    return;
  }
  {
  {
#line 1470
  p = get_suffix(name);
  }
  }
#line 1471
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
    {
#line 1471
    error((char *)"can\'t recover suffix\n");
    }
    }
  }
#line 1472
  *p = (char )'\000';
#line 1473
  save_orig_name = 1;
#line 1476
  if (len > 4) {
#line 1476
    if (0) {
      {
      {
#line 1476
      __s1_len = strlen((char const   *)(p - 4));
      }
      {
#line 1476
      __s2_len = strlen(".tar");
      }
      }
#line 1476
      if (! ((size_t )((void const   *)((p - 4) + 1)) - (size_t )((void const   *)(p - 4)) == 1U)) {
#line 1476
        goto _L___0;
      } else
#line 1476
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1476
        if (! ((size_t )((void const   *)(".tar" + 1)) - (size_t )((void const   *)".tar") == 1U)) {
#line 1476
          tmp___5 = 1;
        } else
#line 1476
        if (__s2_len >= 4U) {
#line 1476
          tmp___5 = 1;
        } else {
#line 1476
          tmp___5 = 0;
        }
      } else {
#line 1476
        tmp___5 = 0;
      }
#line 1476
      if (tmp___5) {
#line 1476
        if (__s1_len < __s2_len) {
#line 1476
          tmp___1 = __s1_len;
        } else {
#line 1476
          tmp___1 = __s2_len;
        }
        {
        {
#line 1476
        tmp___2 = memcmp((void const   *)((char const   *)(p - 4)), (void const   *)".tar",
                         tmp___1 + 1U);
        }
#line 1476
        tmp___4 = tmp___2;
        }
      } else {
        {
        {
#line 1476
        tmp___3 = strcmp((char const   *)(p - 4), ".tar");
        }
#line 1476
        tmp___4 = tmp___3;
        }
      }
    } else {
      {
      {
#line 1476
      tmp___3 = strcmp((char const   *)(p - 4), ".tar");
      }
#line 1476
      tmp___4 = tmp___3;
      }
    }
#line 1476
    if (tmp___4 == 0) {
      {
      {
#line 1477
      strcpy((char */* __restrict  */)(p - 4), (char const   */* __restrict  */)".tgz");
      }
      }
#line 1478
      return;
    }
  }
  {
  {
#line 1483
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1484
    p = strrchr((char const   *)name, '/');
    }
    }
#line 1485
    if (p) {
#line 1485
      p ++;
    } else {
#line 1485
      p = name;
    }
    {
    {
#line 1486
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1486
      if (! *p) {
#line 1486
        goto while_break___0;
      }
      {
      {
#line 1487
      tmp___15 = strcspn((char const   *)p, ".");
      }
#line 1487
      plen = (int )tmp___15;
#line 1488
      p += plen;
      }
#line 1489
      if (plen > min_part) {
#line 1489
        trunc = p - 1;
      }
#line 1490
      if (*p) {
#line 1490
        p ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1483
    if ((unsigned long )trunc == (unsigned long )((void *)0)) {
#line 1483
      min_part --;
#line 1483
      if (! (min_part != 0)) {
#line 1483
        goto while_break;
      }
    } else {
#line 1483
      goto while_break;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1494
  if ((unsigned long )trunc != (unsigned long )((void *)0)) {
    {
    {
#line 1495
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1496
      *(trunc + 0) = *(trunc + 1);
#line 1495
      tmp___16 = trunc;
#line 1495
      trunc ++;
#line 1495
      if (! *tmp___16) {
#line 1495
        goto while_break___1;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1498
    trunc --;
  } else {
    {
    {
#line 1500
    trunc = strrchr((char const   *)name, (int )*("." + 0));
    }
    }
#line 1501
    if ((unsigned long )trunc == (unsigned long )((void *)0)) {
      {
      {
#line 1501
      error((char *)"internal error in shorten_name");
      }
      }
    }
#line 1502
    if ((int )*(trunc + 1) == 0) {
#line 1502
      trunc --;
    }
  }
  {
  {
#line 1504
  strcpy((char */* __restrict  */)trunc, (char const   */* __restrict  */)(z_suffix));
  }
  }
#line 1505
  return;
}
}
#line 1521 "gzip.c"
static int check_ofname(void) 
{ 
  struct stat ostat ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char response[80] ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___15 ;
  unsigned short const   **tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
  {
#line 1524
  tmp = __errno_location();
  }
#line 1524
  *tmp = 0;
  }
  {
  {
#line 1525
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1525
    tmp___1 = stat((char const   */* __restrict  */)(ofname), (struct stat */* __restrict  */)(& ostat));
    }
    }
#line 1525
    if (! (tmp___1 != 0)) {
#line 1525
      goto while_break;
    }
    {
    {
#line 1526
    tmp___0 = __errno_location();
    }
    }
#line 1526
    if (*tmp___0 != 36) {
#line 1526
      return (0);
    }
    {
    {
#line 1527
    shorten_name(ofname);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1530
  if (! decompress) {
    {
    {
#line 1530
    tmp___3 = name_too_long(ofname, & ostat);
    }
    }
#line 1530
    if (tmp___3) {
      {
      {
#line 1531
      shorten_name(ofname);
      }
      {
#line 1532
      tmp___2 = stat((char const   */* __restrict  */)(ofname), (struct stat */* __restrict  */)(& ostat));
      }
      }
#line 1532
      if (tmp___2 != 0) {
#line 1532
        return (0);
      }
    }
  }
  {
  {
#line 1535
  tmp___11 = same_file(& istat, & ostat);
  }
  }
#line 1535
  if (tmp___11) {
#line 1536
    if (0) {
      {
      {
#line 1536
      __s1_len = strlen((char const   *)(ifname));
      }
      {
#line 1536
      __s2_len = strlen((char const   *)(ofname));
      }
      }
#line 1536
      if (! ((size_t )((void const   *)(ifname + 1)) - (size_t )((void const   *)(ifname)) == 1U)) {
#line 1536
        goto _L___0;
      } else
#line 1536
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1536
        if (! ((size_t )((void const   *)(ofname + 1)) - (size_t )((void const   *)(ofname)) == 1U)) {
#line 1536
          tmp___10 = 1;
        } else
#line 1536
        if (__s2_len >= 4U) {
#line 1536
          tmp___10 = 1;
        } else {
#line 1536
          tmp___10 = 0;
        }
      } else {
#line 1536
        tmp___10 = 0;
      }
#line 1536
      if (tmp___10) {
#line 1536
        if (__s1_len < __s2_len) {
#line 1536
          tmp___6 = __s1_len;
        } else {
#line 1536
          tmp___6 = __s2_len;
        }
        {
        {
#line 1536
        tmp___7 = memcmp((void const   *)((char const   *)(ifname)), (void const   *)((char const   *)(ofname)),
                         tmp___6 + 1U);
        }
#line 1536
        tmp___9 = tmp___7;
        }
      } else {
        {
        {
#line 1536
        tmp___8 = strcmp((char const   *)(ifname), (char const   *)(ofname));
        }
#line 1536
        tmp___9 = tmp___8;
        }
      }
    } else {
      {
      {
#line 1536
      tmp___8 = strcmp((char const   *)(ifname), (char const   *)(ofname));
      }
#line 1536
      tmp___9 = tmp___8;
      }
    }
#line 1536
    if (tmp___9 == 0) {
#line 1537
      if (decompress) {
#line 1537
        tmp___4 = "de";
      } else {
#line 1537
        tmp___4 = "";
      }
      {
      {
#line 1537
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot %scompress onto itself\n",
              progname, ifname, tmp___4);
      }
      }
    } else {
      {
      {
#line 1540
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s and %s are the same file\n",
              progname, ifname, ofname);
      }
      }
    }
#line 1543
    exit_code = 1;
#line 1544
    return (1);
  }
#line 1547
  if (! force) {
    {
    {
#line 1549
    strcpy((char */* __restrict  */)(response), (char const   */* __restrict  */)"n");
    }
    {
#line 1550
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s already exists;",
            progname, ofname);
    }
    }
#line 1551
    if (foreground) {
      {
      {
#line 1551
      tmp___12 = fileno(stdin);
      }
      {
#line 1551
      tmp___13 = isatty(tmp___12);
      }
      }
#line 1551
      if (tmp___13) {
        {
        {
#line 1552
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" do you wish to overwrite (y or n)? ");
        }
        {
#line 1553
        fflush(stderr);
        }
        {
#line 1554
        fgets((char */* __restrict  */)(response), (int )(sizeof(response) - 1UL),
              (FILE */* __restrict  */)stdin);
        }
        }
      }
    }
    {
    {
#line 1556
    tmp___16 = __ctype_b_loc();
    }
    }
#line 1556
    if ((int const   )*(*tmp___16 + (int )response[0]) & 256) {
#line 1556
      tmp___15 = ((int )response[0] - 65) + 97;
    } else {
#line 1556
      tmp___15 = (int )response[0];
    }
#line 1556
    if (tmp___15 != 121) {
      {
      {
#line 1557
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tnot overwritten\n");
      }
      }
#line 1558
      if (exit_code == 0) {
#line 1558
        exit_code = 2;
      }
#line 1559
      return (1);
    }
  }
  {
  {
#line 1562
  chmod((char const   *)(ofname), (__mode_t )511);
  }
  {
#line 1563
  tmp___17 = unlink((char const   *)(ofname));
  }
  }
#line 1563
  if (tmp___17) {
    {
    {
#line 1564
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
    }
    {
#line 1565
    perror((char const   *)(ofname));
    }
#line 1566
    exit_code = 1;
    }
#line 1567
    return (1);
  }
#line 1569
  return (0);
}
}
#line 1572 "gzip.c"
static void reset_times(char *name , struct stat *statb ) 
{ 
  struct utimbuf timep ;
  int tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 1579
  timep.actime = statb->st_atim.tv_sec;
#line 1580
  timep.modtime = statb->st_mtim.tv_sec;
  {
#line 1583
  tmp = utime((char const   *)name, (struct utimbuf  const  *)(& timep));
  }
  }
#line 1583
  if (tmp) {
#line 1583
    if (! ((statb->st_mode & 61440U) == 16384U)) {
#line 1584
      if (! quiet) {
        {
        {
#line 1584
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                progname);
        }
        }
      }
#line 1584
      if (exit_code == 0) {
#line 1584
        exit_code = 2;
      }
#line 1585
      if (! quiet) {
        {
        {
#line 1585
        perror((char const   *)(ofname));
        }
        }
      }
    }
  }
#line 1587
  return;
}
}
#line 1595 "gzip.c"
static void copy_stat(struct stat *ifstat ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1599
  if (decompress) {
#line 1599
    if (time_stamp != 0L) {
#line 1599
      if (ifstat->st_mtim.tv_sec != time_stamp) {
#line 1600
        ifstat->st_mtim.tv_sec = time_stamp;
#line 1601
        if (verbose > 1) {
          {
          {
#line 1602
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: time stamp restored\n",
                  ofname);
          }
          }
        }
      }
    }
  }
  {
  {
#line 1605
  reset_times(ofname, ifstat);
  }
  {
#line 1608
  tmp = chmod((char const   *)(ofname), ifstat->st_mode & 4095U);
  }
  }
#line 1608
  if (tmp) {
#line 1609
    if (! quiet) {
      {
      {
#line 1609
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              progname);
      }
      }
    }
#line 1609
    if (exit_code == 0) {
#line 1609
      exit_code = 2;
    }
#line 1610
    if (! quiet) {
      {
      {
#line 1610
      perror((char const   *)(ofname));
      }
      }
    }
  }
  {
  {
#line 1613
  chown((char const   *)(ofname), ifstat->st_uid, ifstat->st_gid);
  }
#line 1615
  remove_ofname = 0;
  {
#line 1617
  chmod((char const   *)(ifname), (__mode_t )511);
  }
  {
#line 1618
  tmp___0 = unlink((char const   *)(ifname));
  }
  }
#line 1618
  if (tmp___0) {
#line 1619
    if (! quiet) {
      {
      {
#line 1619
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              progname);
      }
      }
    }
#line 1619
    if (exit_code == 0) {
#line 1619
      exit_code = 2;
    }
#line 1620
    if (! quiet) {
      {
      {
#line 1620
      perror((char const   *)(ifname));
      }
      }
    }
  }
#line 1622
  return;
}
}
#line 1629 "gzip.c"
static void treat_dir(char *dir ) 
{ 
  dir_type *dp ;
  DIR *dirp ;
  char nbuf[1024] ;
  int len ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
  {
  {
#line 1637
  dirp = opendir((char const   *)dir);
  }
  }
#line 1639
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
    {
    {
#line 1640
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s unreadable\n",
            progname, dir);
    }
#line 1641
    exit_code = 1;
    }
#line 1642
    return;
  }
  {
  {
#line 1679
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1679
    dp = readdir(dirp);
    }
    }
#line 1679
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 1679
      goto while_break;
    }
#line 1680
    if (0) {
      {
      {
#line 1680
      __s1_len = strlen((char const   *)(dp->d_name));
      }
      {
#line 1680
      __s2_len = strlen(".");
      }
      }
#line 1680
      if (! ((size_t )((void const   *)(dp->d_name + 1)) - (size_t )((void const   *)(dp->d_name)) == 1U)) {
#line 1680
        goto _L___0;
      } else
#line 1680
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1680
        if (! ((size_t )((void const   *)("." + 1)) - (size_t )((void const   *)".") == 1U)) {
#line 1680
          tmp___4 = 1;
        } else
#line 1680
        if (__s2_len >= 4U) {
#line 1680
          tmp___4 = 1;
        } else {
#line 1680
          tmp___4 = 0;
        }
      } else {
#line 1680
        tmp___4 = 0;
      }
#line 1680
      if (tmp___4) {
#line 1680
        if (__s1_len < __s2_len) {
#line 1680
          tmp___0 = __s1_len;
        } else {
#line 1680
          tmp___0 = __s2_len;
        }
        {
        {
#line 1680
        tmp___1 = memcmp((void const   *)((char const   *)(dp->d_name)), (void const   *)".",
                         tmp___0 + 1U);
        }
#line 1680
        tmp___3 = tmp___1;
        }
      } else {
        {
        {
#line 1680
        tmp___2 = strcmp((char const   *)(dp->d_name), ".");
        }
#line 1680
        tmp___3 = tmp___2;
        }
      }
    } else {
      {
      {
#line 1680
      tmp___2 = strcmp((char const   *)(dp->d_name), ".");
      }
#line 1680
      tmp___3 = tmp___2;
      }
    }
#line 1680
    if (tmp___3 == 0) {
#line 1681
      goto while_continue;
    } else {
#line 1680
      if (0) {
        {
        {
#line 1680
        __s1_len___0 = strlen((char const   *)(dp->d_name));
        }
        {
#line 1680
        __s2_len___0 = strlen("..");
        }
        }
#line 1680
        if (! ((size_t )((void const   *)(dp->d_name + 1)) - (size_t )((void const   *)(dp->d_name)) == 1U)) {
#line 1680
          goto _L___2;
        } else
#line 1680
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1680
          if (! ((size_t )((void const   *)(".." + 1)) - (size_t )((void const   *)"..") == 1U)) {
#line 1680
            tmp___10 = 1;
          } else
#line 1680
          if (__s2_len___0 >= 4U) {
#line 1680
            tmp___10 = 1;
          } else {
#line 1680
            tmp___10 = 0;
          }
        } else {
#line 1680
          tmp___10 = 0;
        }
#line 1680
        if (tmp___10) {
#line 1680
          if (__s1_len___0 < __s2_len___0) {
#line 1680
            tmp___6 = __s1_len___0;
          } else {
#line 1680
            tmp___6 = __s2_len___0;
          }
          {
          {
#line 1680
          tmp___7 = memcmp((void const   *)((char const   *)(dp->d_name)), (void const   *)"..",
                           tmp___6 + 1U);
          }
#line 1680
          tmp___9 = tmp___7;
          }
        } else {
          {
          {
#line 1680
          tmp___8 = strcmp((char const   *)(dp->d_name), "..");
          }
#line 1680
          tmp___9 = tmp___8;
          }
        }
      } else {
        {
        {
#line 1680
        tmp___8 = strcmp((char const   *)(dp->d_name), "..");
        }
#line 1680
        tmp___9 = tmp___8;
        }
      }
#line 1680
      if (tmp___9 == 0) {
#line 1681
        goto while_continue;
      }
    }
    {
    {
#line 1683
    tmp___11 = strlen((char const   *)dir);
    }
#line 1683
    len = (int )tmp___11;
    {
#line 1684
    tmp___13 = strlen((char const   *)(dp->d_name));
    }
    }
#line 1684
    if ((len + (int )tmp___13) + 1 < 1023) {
      {
      {
#line 1685
      strcpy((char */* __restrict  */)(nbuf), (char const   */* __restrict  */)dir);
      }
      }
#line 1686
      if (len != 0) {
#line 1688
        tmp___12 = len;
#line 1688
        len ++;
#line 1688
        nbuf[tmp___12] = (char )'/';
      }
      {
      {
#line 1690
      strcpy((char */* __restrict  */)(nbuf + len), (char const   */* __restrict  */)(dp->d_name));
      }
      {
#line 1691
      treat_file(nbuf);
      }
      }
    } else {
      {
      {
#line 1693
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s/%s: pathname too long\n",
              progname, dir, dp->d_name);
      }
#line 1695
      exit_code = 1;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1698
  closedir(dirp);
  }
  }
#line 1699
  return;
}
}
#line 1708 "gzip.c"
static int in_exit  =    0;
#line 1705 "gzip.c"
static void do_exit(int exitcode ) 
{ 


  {
#line 1710
  if (in_exit) {
    {
    {
#line 1710
    exit(exitcode);
    }
    }
  }
#line 1711
  in_exit = 1;
#line 1712
  if ((unsigned long )env != (unsigned long )((void *)0)) {
    {
    {
#line 1712
    free((void *)env);
    }
#line 1712
    env = (char *)((void *)0);
    }
  }
#line 1713
  if ((unsigned long )args != (unsigned long )((void *)0)) {
    {
    {
#line 1713
    free((void *)((char *)args));
    }
#line 1713
    args = (char **)((void *)0);
    }
  }
  {
  {
#line 1714
  exit(exitcode);
  }
  }
}
}
#line 1720 "gzip.c"
void abort_gzip(void) 
{ 


  {
#line 1722
  if (remove_ofname) {
    {
    {
#line 1723
    close(ofd);
    }
    {
#line 1724
    unlink((char const   *)(ofname));
    }
    }
  }
  {
  {
#line 1726
  do_exit(1);
  }
  }
#line 1727
  return;
}
}
