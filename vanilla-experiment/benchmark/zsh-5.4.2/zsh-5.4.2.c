/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 137 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 62 "/usr/lib/llvm-6.0/lib/clang/6.0.0/include/stddef.h"
typedef unsigned long size_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_973126068 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_973126068 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 90 "/usr/lib/llvm-6.0/lib/clang/6.0.0/include/stddef.h"
typedef int wchar_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_423627550 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_423627550 __mbstate_t;
#line 48 "/usr/lib/llvm-6.0/lib/clang/6.0.0/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 533 "./zsh.h"
struct options ;
#line 533 "./zsh.h"
typedef struct options *Options;
#line 538
struct patprog ;
#line 538 "./zsh.h"
typedef struct patprog *Patprog;
#line 1358 "./zsh.h"
struct options {
   unsigned char ind[128] ;
   char **args ;
   int argscount ;
   int argsalloc ;
};
#line 1535 "./zsh.h"
struct patprog {
   long startoff ;
   long size ;
   long mustoff ;
   long patmlen ;
   int globflags ;
   int globend ;
   int flags ;
   int patnpar ;
   char patstartch ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __exit_status {
   short e_termination ;
   short e_exit ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __anonstruct_ut_tv_415302911 {
   __int32_t tv_sec ;
   __int32_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct utmpx {
   short ut_type ;
   __pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct __exit_status ut_exit ;
   __int32_t ut_session ;
   struct __anonstruct_ut_tv_415302911 ut_tv ;
   __int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_356711149 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_356711149 fd_set;
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list___0;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 55 "./zsh.h"
typedef long zlong;
#line 56 "./zsh.h"
typedef unsigned long zulong;
#line 509
struct cmdnam ;
#line 509 "./zsh.h"
typedef struct cmdnam *Cmdnam;
#line 512
struct dirsav ;
#line 512 "./zsh.h"
typedef struct dirsav *Dirsav;
#line 513
struct emulation_options ;
#line 513 "./zsh.h"
typedef struct emulation_options *Emulation_options;
#line 519
struct hashnode ;
#line 519 "./zsh.h"
typedef struct hashnode *HashNode;
#line 520
struct hashtable ;
#line 520 "./zsh.h"
typedef struct hashtable *HashTable;
#line 529
struct linknode ;
#line 529 "./zsh.h"
typedef struct linknode *LinkNode;
#line 530
union linkroot ;
#line 530 "./zsh.h"
typedef union linkroot *LinkList;
#line 532
struct nameddir ;
#line 532 "./zsh.h"
typedef struct nameddir *Nameddir;
#line 535
struct param ;
#line 535 "./zsh.h"
typedef struct param *Param;
#line 539
struct prepromptfn ;
#line 539 "./zsh.h"
typedef struct prepromptfn *Prepromptfn;
#line 543
struct shfunc ;
#line 543 "./zsh.h"
typedef struct shfunc *Shfunc;
#line 544
struct timedfn ;
#line 544 "./zsh.h"
typedef struct timedfn *Timedfn;
#line 553 "./zsh.h"
struct linknode {
   LinkNode next ;
   LinkNode prev ;
   void *dat ;
};
#line 559 "./zsh.h"
struct linklist {
   LinkNode first ;
   LinkNode last ;
   int flags ;
};
#line 565 "./zsh.h"
union linkroot {
   struct linklist list ;
   struct linknode node ;
};
#line 622 "./zsh.h"
struct prepromptfn {
   void (*func)(void) ;
};
#line 630 "./zsh.h"
struct timedfn {
   void (*func)(void) ;
   time_t when ;
};
#line 761 "./zsh.h"
typedef unsigned int wordcode;
#line 762 "./zsh.h"
typedef wordcode *Wordcode;
#line 764
struct funcdump ;
#line 764 "./zsh.h"
typedef struct funcdump *FuncDump;
#line 765
struct eprog ;
#line 765 "./zsh.h"
typedef struct eprog *Eprog;
#line 767 "./zsh.h"
struct funcdump {
   FuncDump next ;
   dev_t dev ;
   ino_t ino ;
   int fd ;
   Wordcode map ;
   Wordcode addr ;
   int len ;
   int count ;
   char *filename ;
};
#line 796 "./zsh.h"
struct eprog {
   int flags ;
   int len ;
   int npats ;
   int nref ;
   Patprog *pats ;
   Wordcode prog ;
   char *strs ;
   Shfunc shf ;
   FuncDump dump ;
};
#line 1008
struct ttyinfo ;
#line 1108 "./zsh.h"
struct dirsav {
   int dirfd ;
   int level ;
   char *dirname ;
   dev_t dev ;
   ino_t ino ;
};
#line 1146 "./zsh.h"
struct hashtable {
   int hsize ;
   int ct ;
   HashNode *nodes ;
   void *tmpdata ;
   unsigned int (*hash)(char const   * ) ;
   void (*emptytable)(HashTable  ) ;
   void (*filltable)(HashTable  ) ;
   int (*cmpnodes)(char const   * , char const   * ) ;
   void (*addnode)(HashTable  , char * , void * ) ;
   HashNode (*getnode)(HashTable  , char const   * ) ;
   HashNode (*getnode2)(HashTable  , char const   * ) ;
   HashNode (*removenode)(HashTable  , char const   * ) ;
   void (*disablenode)(HashNode  , int  ) ;
   void (*enablenode)(HashNode  , int  ) ;
   void (*freenode)(HashNode  ) ;
   void (*printnode)(HashNode  , int  ) ;
   void (*scantab)(HashTable  , void (*)(HashNode  , int  ) , int  ) ;
};
#line 1176 "./zsh.h"
struct hashnode {
   HashNode next ;
   char *nam ;
   int flags ;
};
#line 1243 "./zsh.h"
union __anonunion_u_476363767 {
   char **name ;
   char *cmd ;
};
#line 1243 "./zsh.h"
struct cmdnam {
   struct hashnode node ;
   union __anonunion_u_476363767 u ;
};
#line 1258 "./zsh.h"
struct shfunc {
   struct hashnode node ;
   char *filename ;
   zlong lineno ;
   Eprog funcdef ;
   Eprog redir ;
   Emulation_options sticky ;
};
#line 1724
struct gsu_scalar ;
#line 1724 "./zsh.h"
typedef struct gsu_scalar  const  *GsuScalar;
#line 1725
struct gsu_integer ;
#line 1725 "./zsh.h"
typedef struct gsu_integer  const  *GsuInteger;
#line 1726
struct gsu_float ;
#line 1726 "./zsh.h"
typedef struct gsu_float  const  *GsuFloat;
#line 1727
struct gsu_array ;
#line 1727 "./zsh.h"
typedef struct gsu_array  const  *GsuArray;
#line 1728
struct gsu_hash ;
#line 1728 "./zsh.h"
typedef struct gsu_hash  const  *GsuHash;
#line 1730 "./zsh.h"
struct gsu_scalar {
   char *(*getfn)(Param  ) ;
   void (*setfn)(Param  , char * ) ;
   void (*unsetfn)(Param  , int  ) ;
};
#line 1736 "./zsh.h"
struct gsu_integer {
   zlong (*getfn)(Param  ) ;
   void (*setfn)(Param  , zlong  ) ;
   void (*unsetfn)(Param  , int  ) ;
};
#line 1742 "./zsh.h"
struct gsu_float {
   double (*getfn)(Param  ) ;
   void (*setfn)(Param  , double  ) ;
   void (*unsetfn)(Param  , int  ) ;
};
#line 1748 "./zsh.h"
struct gsu_array {
   char **(*getfn)(Param  ) ;
   void (*setfn)(Param  , char ** ) ;
   void (*unsetfn)(Param  , int  ) ;
};
#line 1754 "./zsh.h"
struct gsu_hash {
   HashTable (*getfn)(Param  ) ;
   void (*setfn)(Param  , HashTable  ) ;
   void (*unsetfn)(Param  , int  ) ;
};
#line 1763 "./zsh.h"
union __anonunion_u_319297010 {
   void *data ;
   char **arr ;
   char *str ;
   zlong val ;
   zlong *valptr ;
   double dval ;
   HashTable hash ;
};
#line 1763 "./zsh.h"
union __anonunion_gsu_448494373 {
   GsuScalar s ;
   GsuInteger i ;
   GsuFloat f ;
   GsuArray a ;
   GsuHash h ;
};
#line 1763 "./zsh.h"
struct param {
   struct hashnode node ;
   union __anonunion_u_319297010 u ;
   union __anonunion_gsu_448494373 gsu ;
   int base ;
   int width ;
   char *env ;
   char *ename ;
   Param old ;
   int level ;
};
#line 2059 "./zsh.h"
struct nameddir {
   struct hashnode node ;
   char *dir ;
   int diff ;
};
#line 2458 "./zsh.h"
typedef unsigned char OptIndex;
#line 2472 "./zsh.h"
struct emulation_options {
   int emulation ;
   int n_on_opts ;
   int n_off_opts ;
   OptIndex *on_opts ;
   OptIndex *off_opts ;
};
#line 2495 "./zsh.h"
struct ttyinfo {
   struct termios tio ;
   struct winsize winsize ;
};
#line 3165 "./zsh.h"
typedef wint_t convchar_t;
#line 49 "/tmp/zsh-5.4.2/Src/utils.c"
struct widechar_array {
   wchar_t *chars ;
   size_t len ;
};
#line 53 "/tmp/zsh-5.4.2/Src/utils.c"
typedef struct widechar_array *Widechar_array;
#line 541 "./zsh.h"
struct redir ;
#line 541 "./zsh.h"
typedef struct redir *Redir;
#line 709 "./zsh.h"
struct redir {
   int type ;
   int flags ;
   int fd1 ;
   int fd2 ;
   char *name ;
   char *varid ;
   char *here_terminator ;
   char *munged_here_terminator ;
};
#line 813
struct estate ;
#line 813 "./zsh.h"
typedef struct estate *Estate;
#line 815 "./zsh.h"
struct estate {
   Eprog prog ;
   Wordcode pc ;
   char *strs ;
};
#line 360 "/tmp/zsh-5.4.2/Src/text.c"
struct tstack ;
#line 360 "/tmp/zsh-5.4.2/Src/text.c"
typedef struct tstack *Tstack;
#line 362 "/tmp/zsh-5.4.2/Src/text.c"
struct __anonstruct__redir_963178695 {
   LinkList list ;
};
#line 362 "/tmp/zsh-5.4.2/Src/text.c"
struct __anonstruct__funcdef_945666934 {
   char *strs ;
   Wordcode end ;
   int nargs ;
};
#line 362 "/tmp/zsh-5.4.2/Src/text.c"
struct __anonstruct__case_739586875 {
   Wordcode end ;
};
#line 362 "/tmp/zsh-5.4.2/Src/text.c"
struct __anonstruct__if_901634643 {
   int cond ;
   Wordcode end ;
};
#line 362 "/tmp/zsh-5.4.2/Src/text.c"
struct __anonstruct__cond_1054712252 {
   int par ;
};
#line 362 "/tmp/zsh-5.4.2/Src/text.c"
struct __anonstruct__subsh_1054712253 {
   Wordcode end ;
};
#line 362 "/tmp/zsh-5.4.2/Src/text.c"
union __anonunion_u_366086045 {
   struct __anonstruct__redir_963178695 _redir ;
   struct __anonstruct__funcdef_945666934 _funcdef ;
   struct __anonstruct__case_739586875 _case ;
   struct __anonstruct__if_901634643 _if ;
   struct __anonstruct__cond_1054712252 _cond ;
   struct __anonstruct__subsh_1054712253 _subsh ;
};
#line 362 "/tmp/zsh-5.4.2/Src/text.c"
struct tstack {
   Tstack prev ;
   wordcode code ;
   int pop ;
   union __anonunion_u_366086045 u ;
};
#line 95 "./zsh.h"
union __anonunion_u_156354585 {
   zlong l ;
   double d ;
};
#line 95 "./zsh.h"
struct __anonstruct_mnumber_542856327 {
   union __anonunion_u_156354585 u ;
   int type ;
};
#line 95 "./zsh.h"
typedef struct __anonstruct_mnumber_542856327 mnumber;
#line 545
struct value ;
#line 545 "./zsh.h"
typedef struct value *Value;
#line 740 "./zsh.h"
struct value {
   int isarr ;
   Param pm ;
   int flags ;
   int start ;
   int end ;
   char **arr ;
};
#line 2917 "./zsh.h"
struct sortelt {
   char *orig ;
   char const   *cmp ;
   int origlen ;
   int len ;
};
#line 2934 "./zsh.h"
typedef struct sortelt *SortElt;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__bounds_856836741 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigfault_350509334 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_856836741 _bounds ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigsys_243330693 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__sifields_745812133 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_350509334 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_243330693 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_siginfo_t_793559826 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_745812133 _sifields ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_siginfo_t_793559826 siginfo_t;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 58 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 129 "/usr/include/x86_64-linux-gnu/sys/wait.h"
struct rusage ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346496 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346497 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346498 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346499 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346500 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346501 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346502 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346503 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346504 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346505 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346506 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346507 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346508 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346509 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_1036346496 __annonCompField4 ;
   union __anonunion____missing_field_name_1036346497 __annonCompField5 ;
   union __anonunion____missing_field_name_1036346498 __annonCompField6 ;
   union __anonunion____missing_field_name_1036346499 __annonCompField7 ;
   union __anonunion____missing_field_name_1036346500 __annonCompField8 ;
   union __anonunion____missing_field_name_1036346501 __annonCompField9 ;
   union __anonunion____missing_field_name_1036346502 __annonCompField10 ;
   union __anonunion____missing_field_name_1036346503 __annonCompField11 ;
   union __anonunion____missing_field_name_1036346504 __annonCompField12 ;
   union __anonunion____missing_field_name_1036346505 __annonCompField13 ;
   union __anonunion____missing_field_name_1036346506 __annonCompField14 ;
   union __anonunion____missing_field_name_1036346507 __annonCompField15 ;
   union __anonunion____missing_field_name_1036346508 __annonCompField16 ;
   union __anonunion____missing_field_name_1036346509 __annonCompField17 ;
};
#line 524 "./zsh.h"
struct hookdef ;
#line 524 "./zsh.h"
typedef struct hookdef *Hookdef;
#line 527
struct job ;
#line 527 "./zsh.h"
typedef struct job *Job;
#line 540
struct process ;
#line 540 "./zsh.h"
typedef struct process *Process;
#line 1008 "./zsh.h"
struct job {
   pid_t gleader ;
   pid_t other ;
   int stat ;
   char *pwd ;
   struct process *procs ;
   struct process *auxprocs ;
   LinkList filelist ;
   int stty_in_env ;
   struct ttyinfo *ty ;
};
#line 1062 "./zsh.h"
typedef struct rusage child_times_t;
#line 1067 "./zsh.h"
struct process {
   struct process *next ;
   pid_t pid ;
   char text[80] ;
   int status ;
   child_times_t ti ;
   struct timeval bgtime ;
   struct timeval endtime ;
};
#line 1077 "./zsh.h"
struct execstack {
   struct execstack *next ;
   pid_t list_pipe_pid ;
   int nowait ;
   int pline_level ;
   int list_pipe_child ;
   int list_pipe_job ;
   char list_pipe_text[80] ;
   int lastval ;
   int noeval ;
   int badcshglob ;
   pid_t cmdoutpid ;
   int cmdoutval ;
   int use_cmdoutval ;
   int trap_return ;
   int trap_state ;
   int trapisfunc ;
   int traplocallevel ;
   int noerrs ;
   int this_noerrexit ;
   char *underscore ;
};
#line 1518 "./zsh.h"
struct hookdef {
   Hookdef next ;
   char *name ;
   int (*def)(Hookdef  , void * ) ;
   int flags ;
   LinkList funcs ;
};
#line 791 "/tmp/zsh-5.4.2/Src/signals.c"
struct savetrap {
   int sig ;
   int flags ;
   int local ;
   int posix ;
   void *list ;
};
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 51 "/usr/lib/llvm-6.0/lib/clang/6.0.0/include/stddef.h"
typedef long ptrdiff_t;
#line 517 "./zsh.h"
struct funcstack ;
#line 517 "./zsh.h"
typedef struct funcstack *Funcstack;
#line 1290 "./zsh.h"
struct funcstack {
   Funcstack prev ;
   char *name ;
   char *filename ;
   char *caller ;
   zlong flineno ;
   zlong lineno ;
   int tp ;
};
#line 59 "/tmp/zsh-5.4.2/Src/prompt.c"
struct buf_vars ;
#line 61 "/tmp/zsh-5.4.2/Src/prompt.c"
struct buf_vars {
   struct buf_vars *last ;
   char *buf ;
   int bufspc ;
   char *bp ;
   char *bufline ;
   char *bp1 ;
   char *fm ;
   int truncwidth ;
   int dontcount ;
   int trunccount ;
   char *rstring ;
   char *Rstring ;
};
#line 108 "/tmp/zsh-5.4.2/Src/prompt.c"
typedef struct buf_vars *Buf_vars;
#line 1569 "/tmp/zsh-5.4.2/Src/prompt.c"
struct highlight {
   char const   *name ;
   int mask_on ;
   int mask_off ;
};
#line 1836 "/tmp/zsh-5.4.2/Src/prompt.c"
struct colour_sequences {
   char *start ;
   char *end ;
   char *def ;
};
#line 537 "./zsh.h"
struct patstralloc ;
#line 537 "./zsh.h"
typedef struct patstralloc *Patstralloc;
#line 1547 "./zsh.h"
struct patstralloc {
   int unmetalen ;
   int unmetalenp ;
   char *alloced ;
   char *progstrunmeta ;
   int progstrunmetalen ;
};
#line 1615 "./zsh.h"
struct zpc_disables_save {
   struct zpc_disables_save *next ;
   unsigned int disables ;
};
#line 1625 "./zsh.h"
typedef struct zpc_disables_save *Zpc_disables_save;
#line 84 "/tmp/zsh-5.4.2/Src/pattern.c"
union upat {
   long l ;
   unsigned char *p ;
};
#line 89 "/tmp/zsh-5.4.2/Src/pattern.c"
typedef union upat *Upat;
#line 221 "/tmp/zsh-5.4.2/Src/pattern.c"
typedef zlong zrange_t;
#line 310 "/tmp/zsh-5.4.2/Src/pattern.c"
typedef wint_t patint_t;
#line 1856 "/tmp/zsh-5.4.2/Src/pattern.c"
struct rpat {
   char *patinstart ;
   char *patinend ;
   char *patinput ;
   char *patinpath ;
   int patinlen ;
   char *patbeginp[9] ;
   char *patendp[9] ;
   int parsfound ;
   int globdots ;
};
#line 307 "./zsh.h"
enum lextok {
    NULLTOK = 0,
    SEPER = 1,
    NEWLIN = 2,
    SEMI = 3,
    DSEMI = 4,
    AMPER = 5,
    INPAR = 6,
    OUTPAR = 7,
    DBAR = 8,
    DAMPER = 9,
    OUTANG = 10,
    OUTANGBANG = 11,
    DOUTANG = 12,
    DOUTANGBANG = 13,
    INANG = 14,
    INOUTANG = 15,
    DINANG = 16,
    DINANGDASH = 17,
    INANGAMP = 18,
    OUTANGAMP = 19,
    AMPOUTANG = 20,
    OUTANGAMPBANG = 21,
    DOUTANGAMP = 22,
    DOUTANGAMPBANG = 23,
    TRINANG = 24,
    BAR = 25,
    BARAMP = 26,
    INOUTPAR = 27,
    DINPAR = 28,
    DOUTPAR = 29,
    AMPERBANG = 30,
    SEMIAMP = 31,
    SEMIBAR = 32,
    DOUTBRACK = 33,
    STRING = 34,
    ENVSTRING = 35,
    ENVARRAY = 36,
    ENDINPUT = 37,
    LEXERR = 38,
    BANG = 39,
    DINBRACK = 40,
    INBRACE = 41,
    OUTBRACE = 42,
    CASE = 43,
    COPROC = 44,
    DOLOOP = 45,
    DONE = 46,
    ELIF = 47,
    ELSE = 48,
    ZEND = 49,
    ESAC = 50,
    FI = 51,
    FOR = 52,
    FOREACH = 53,
    FUNC = 54,
    IF = 55,
    NOCORRECT = 56,
    REPEAT = 57,
    SELECT = 58,
    THEN = 59,
    TIME = 60,
    UNTIL = 61,
    WHILE = 62,
    TYPESET = 63
} ;
#line 821
struct eccstr ;
#line 821 "./zsh.h"
typedef struct eccstr *Eccstr;
#line 823 "./zsh.h"
struct eccstr {
   Eccstr left ;
   Eccstr right ;
   char *str ;
   wordcode offs ;
   wordcode aoffs ;
   int nfunc ;
   int hashval ;
};
#line 1101 "./zsh.h"
struct heredocs {
   struct heredocs *next ;
   int type ;
   int pc ;
   char *str ;
};
#line 3001 "./zsh.h"
struct parse_stack {
   struct heredocs *hdocs ;
   int incmdpos ;
   int aliasspaceflag ;
   int incond ;
   int inredir ;
   int incasepat ;
   int isnewlin ;
   int infor ;
   int inrepeat_ ;
   int intypeset ;
   int eclen ;
   int ecused ;
   int ecnpats ;
   Wordcode ecbuf ;
   Eccstr ecstrs ;
   int ecsoffs ;
   int ecssub ;
   int ecnfunc ;
};
#line 3016 "/tmp/zsh-5.4.2/Src/parse.c"
struct fdhead ;
#line 3016 "/tmp/zsh-5.4.2/Src/parse.c"
typedef struct fdhead *FDHead;
#line 3018 "/tmp/zsh-5.4.2/Src/parse.c"
struct fdhead {
   wordcode start ;
   wordcode len ;
   wordcode npats ;
   wordcode strs ;
   wordcode hlen ;
   wordcode flags ;
};
#line 3058
struct wcfunc ;
#line 3058 "/tmp/zsh-5.4.2/Src/parse.c"
typedef struct wcfunc *WCFunc;
#line 3060 "/tmp/zsh-5.4.2/Src/parse.c"
struct wcfunc {
   char *name ;
   Eprog prog ;
   int flags ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
#line 1803 "./zsh.h"
struct tieddata {
   char ***arrptr ;
   int joinchar ;
};
#line 256 "/tmp/zsh-5.4.2/Src/params.c"
typedef struct param initparam;
#line 4346 "/tmp/zsh-5.4.2/Src/params.c"
struct localename {
   char *name ;
   int category ;
};
#line 5469 "/tmp/zsh-5.4.2/Src/params.c"
struct paramtypes {
   int binflag ;
   char const   *string ;
   int typeflag ;
   int flags ;
};
#line 534 "./zsh.h"
struct optname ;
#line 534 "./zsh.h"
typedef struct optname *Optname;
#line 1189 "./zsh.h"
struct optname {
   struct hashnode node ;
   int optno ;
};
#line 107
struct mathfunc ;
#line 107 "./zsh.h"
typedef struct mathfunc *MathFunc;
#line 111 "./zsh.h"
struct mathfunc {
   MathFunc next ;
   char *name ;
   int flags ;
   mnumber (*nfunc)(char * , int  , mnumber * , int  ) ;
   mnumber (*sfunc)(char * , char * , int  ) ;
   char *module ;
   int minargs ;
   int maxargs ;
   int funcid ;
};
#line 508
struct builtin ;
#line 508 "./zsh.h"
typedef struct builtin *Builtin;
#line 511
struct conddef ;
#line 511 "./zsh.h"
typedef struct conddef *Conddef;
#line 515
struct features ;
#line 515 "./zsh.h"
typedef struct features *Features;
#line 516
struct feature_enables ;
#line 516 "./zsh.h"
typedef struct feature_enables *Feature_enables;
#line 518
struct funcwrap ;
#line 518 "./zsh.h"
typedef struct funcwrap *FuncWrap;
#line 528
struct linkedmod ;
#line 528 "./zsh.h"
typedef struct linkedmod *Linkedmod;
#line 531
struct module ;
#line 531 "./zsh.h"
typedef struct module *Module;
#line 536
struct paramdef ;
#line 536 "./zsh.h"
typedef struct paramdef *Paramdef;
#line 679 "./zsh.h"
struct conddef {
   Conddef next ;
   char *name ;
   int flags ;
   int (*handler)(char ** , int  ) ;
   int min ;
   int max ;
   int condid ;
   char *module ;
};
#line 1304 "./zsh.h"
struct funcwrap {
   FuncWrap next ;
   int flags ;
   int (*handler)(Eprog  , FuncWrap  , char * ) ;
   Module module ;
};
#line 1374 "./zsh.h"
struct builtin {
   struct hashnode node ;
   int (*handlerfunc)(char * , char ** , Options  , int  ) ;
   int minargs ;
   int maxargs ;
   int funcid ;
   char *optstr ;
   char *defopts ;
};
#line 1437 "./zsh.h"
union __anonunion_u_607535418 {
   void *handle ;
   Linkedmod linked ;
   char *alias ;
};
#line 1437 "./zsh.h"
struct module {
   struct hashnode node ;
   union __anonunion_u_607535418 u ;
   LinkList autoloads ;
   LinkList deps ;
   int wrapper ;
};
#line 1468 "./zsh.h"
typedef int (*Module_generic_func)(void);
#line 1473 "./zsh.h"
struct linkedmod {
   char *name ;
   int (*setup)(Module  ) ;
   int (*features)(Module  , char *** ) ;
   int (*enables)(Module  , int ** ) ;
   int (*boot)(Module  ) ;
   int (*cleanup)(Module  ) ;
   int (*finish)(Module  ) ;
};
#line 1487 "./zsh.h"
struct features {
   Builtin bn_list ;
   int bn_size ;
   Conddef cd_list ;
   int cd_size ;
   MathFunc mf_list ;
   int mf_size ;
   Paramdef pd_list ;
   int pd_size ;
   int n_abstract ;
};
#line 1507 "./zsh.h"
struct feature_enables {
   char *str ;
   Patprog pat ;
};
#line 1997 "./zsh.h"
struct paramdef {
   char *name ;
   int flags ;
   void *var ;
   void const   *gsu ;
   HashNode (*getnfn)(HashTable  , char const   * ) ;
   void (*scantfn)(HashTable  , void (*)(HashNode  , int  ) , int  ) ;
   Param pm ;
};
#line 521
struct heap ;
#line 521 "./zsh.h"
typedef struct heap *Heap;
#line 522
struct heapstack ;
#line 522 "./zsh.h"
typedef struct heapstack *Heapstack;
#line 2776 "./zsh.h"
struct heapstack {
   struct heapstack *next ;
   size_t used ;
};
#line 2786 "./zsh.h"
struct heap {
   struct heap *next ;
   size_t size ;
   size_t used ;
   struct heapstack *sp ;
};
#line 113 "/tmp/zsh-5.4.2/Src/mem.c"
union mem_align {
   zlong l ;
   double d ;
};
#line 30 "/tmp/zsh-5.4.2/Src/math.c"
struct mathvalue ;
#line 308 "/tmp/zsh-5.4.2/Src/math.c"
struct mathvalue {
   char *lval ;
   Value pval ;
   mnumber val ;
};
#line 324
enum prec_type {
    MPREC_TOP = 0,
    MPREC_ARG = 1
} ;
#line 506 "./zsh.h"
struct alias ;
#line 506 "./zsh.h"
typedef struct alias *Alias;
#line 542
struct reswd ;
#line 542 "./zsh.h"
typedef struct reswd *Reswd;
#line 1196 "./zsh.h"
struct reswd {
   struct hashnode node ;
   int token ;
};
#line 1203 "./zsh.h"
struct alias {
   struct hashnode node ;
   char *text ;
   int inuse ;
};
#line 2971 "./zsh.h"
struct lexbufstate {
   char *ptr ;
   int siz ;
   int len ;
};
#line 2984 "./zsh.h"
struct lex_stack {
   int dbparens ;
   int isfirstln ;
   int isfirstch ;
   int lexflags ;
   enum lextok tok ;
   char *tokstr ;
   char *zshlextext ;
   struct lexbufstate lexbuf ;
   int lex_add_raw ;
   char *tokstr_raw ;
   struct lexbufstate lexbuf_raw ;
   int lexstop ;
   zlong toklineno ;
};
#line 158 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1,
    RUSAGE_THREAD = 1
} ;
#line 39 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rusage_who __rusage_who_t;
#line 526 "./zsh.h"
struct jobfile ;
#line 526 "./zsh.h"
typedef struct jobfile *Jobfile;
#line 996 "./zsh.h"
union __anonunion_u_1036346510 {
   char *name ;
   int fd ;
};
#line 996 "./zsh.h"
struct jobfile {
   union __anonunion_u_1036346510 u ;
   int is_fd ;
};
#line 2011 "/tmp/zsh-5.4.2/Src/jobs.c"
struct bgstatus {
   pid_t pid ;
   int status ;
};
#line 2015 "/tmp/zsh-5.4.2/Src/jobs.c"
typedef struct bgstatus *Bgstatus;
#line 2425 "/tmp/zsh-5.4.2/Src/jobs.c"
struct __anonstruct_alt_sigs_713894858 {
   char const   *name ;
   int num ;
};
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 114 "/tmp/zsh-5.4.2/Src/input.c"
struct instacks {
   char *buf ;
   char *bufptr ;
   Alias alias ;
   int bufleft ;
   int bufct ;
   int flags ;
};
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 523 "./zsh.h"
struct histent ;
#line 523 "./zsh.h"
typedef struct histent *Histent;
#line 2105
enum loop_return {
    LOOP_OK = 0,
    LOOP_EMPTY = 1,
    LOOP_ERROR = 2
} ;
#line 2116
enum source_return {
    SOURCE_OK = 0,
    SOURCE_NOT_FOUND = 1,
    SOURCE_ERROR = 2
} ;
#line 2142 "./zsh.h"
struct histent {
   struct hashnode node ;
   Histent up ;
   Histent down ;
   char *zle_text ;
   time_t stim ;
   time_t ftim ;
   short *words ;
   int nwords ;
   zlong histnum ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 2941 "./zsh.h"
struct hist_stack {
   int histactive ;
   int histdone ;
   int stophist ;
   int hlinesz ;
   zlong defev ;
   char *hline ;
   char *hptr ;
   short *chwords ;
   int chwordlen ;
   int chwordpos ;
   int (*hgetc)(void) ;
   void (*hungetc)(int  ) ;
   void (*hwaddc)(int  ) ;
   void (*hwbegin)(int  ) ;
   void (*hwend)(void) ;
   void (*addtoline)(int  ) ;
   unsigned char *cstack ;
   int csp ;
};
#line 205 "/tmp/zsh-5.4.2/Src/hist.c"
struct histfile_stats {
   char *text ;
   time_t stim ;
   time_t mtim ;
   off_t fpos ;
   off_t fsiz ;
   zlong next_write_ev ;
};
#line 212 "/tmp/zsh-5.4.2/Src/hist.c"
struct histsave {
   struct histfile_stats lasthist ;
   char *histfile ;
   HashTable histtab ;
   Histent hist_ring ;
   zlong curhist ;
   zlong histlinect ;
   zlong histsiz ;
   zlong savehistsiz ;
   int locallevel ;
};
#line 46 "/tmp/zsh-5.4.2/Src/hashtable.c"
struct scanstatus ;
#line 46 "/tmp/zsh-5.4.2/Src/hashtable.c"
typedef struct scanstatus *ScanStatus;
#line 520 "./zsh.h"
typedef struct hashtable___0 *HashTable___0;
#line 1146 "./zsh.h"
struct hashtable___0 {
   int hsize ;
   int ct ;
   HashNode *nodes ;
   void *tmpdata ;
   unsigned int (*hash)(char const   * ) ;
   void (*emptytable)(HashTable___0  ) ;
   void (*filltable)(HashTable___0  ) ;
   int (*cmpnodes)(char const   * , char const   * ) ;
   void (*addnode)(HashTable___0  , char * , void * ) ;
   HashNode (*getnode)(HashTable___0  , char const   * ) ;
   HashNode (*getnode2)(HashTable___0  , char const   * ) ;
   HashNode (*removenode)(HashTable___0  , char const   * ) ;
   void (*disablenode)(HashNode  , int  ) ;
   void (*enablenode)(HashNode  , int  ) ;
   void (*freenode)(HashNode  ) ;
   void (*printnode)(HashNode  , int  ) ;
   void (*scantab)(HashTable___0  , void (*)(HashNode  , int  ) , int  ) ;
   ScanStatus scan ;
};
#line 58 "/tmp/zsh-5.4.2/Src/hashtable.c"
struct __anonstruct_s_184222293 {
   HashNode *hashtab ;
   int ct ;
};
#line 58 "/tmp/zsh-5.4.2/Src/hashtable.c"
union __anonunion_u_735369789 {
   struct __anonstruct_s_184222293 s ;
   HashNode u ;
};
#line 58 "/tmp/zsh-5.4.2/Src/hashtable.c"
struct scanstatus {
   int sorted ;
   union __anonunion_u_735369789 u ;
};
#line 1488 "/tmp/zsh-5.4.2/Src/hashtable.c"
struct dircache_entry {
   char *name ;
   int refs ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 510 "./zsh.h"
struct complist ;
#line 510 "./zsh.h"
typedef struct complist *Complist;
#line 525
struct imatchdata ;
#line 525 "./zsh.h"
typedef struct imatchdata *Imatchdata;
#line 1674 "./zsh.h"
struct imatchdata {
   char *mstr ;
   int mlen ;
   char *ustr ;
   int ulen ;
   int flags ;
   char *replstr ;
   LinkList repllist ;
};
#line 1925 "./zsh.h"
struct repldata {
   int b ;
   int e ;
   char *replstr ;
};
#line 1929 "./zsh.h"
typedef struct repldata *Repldata;
#line 41 "/tmp/zsh-5.4.2/Src/glob.c"
struct gmatch ;
#line 41 "/tmp/zsh-5.4.2/Src/glob.c"
typedef struct gmatch *Gmatch;
#line 43 "/tmp/zsh-5.4.2/Src/glob.c"
struct gmatch {
   char *name ;
   char *uname ;
   char **sortstrs ;
   off_t size ;
   long atime ;
   long mtime ;
   long ctime ;
   long links ;
   off_t _size ;
   long _atime ;
   long _mtime ;
   long _ctime ;
   long _links ;
   long ansec ;
   long _ansec ;
   long mnsec ;
   long _mnsec ;
   long cnsec ;
   long _cnsec ;
};
#line 117 "/tmp/zsh-5.4.2/Src/glob.c"
typedef struct stat *Statptr;
#line 138 "/tmp/zsh-5.4.2/Src/glob.c"
struct qual {
   struct qual *next ;
   struct qual *or ;
   int (*func)(char * , struct stat * , off_t  , char * ) ;
   off_t data ;
   int sense ;
   int amc ;
   int range ;
   int units ;
   char *sdata ;
};
#line 156 "/tmp/zsh-5.4.2/Src/glob.c"
struct globsort {
   int tp ;
   char *exec ;
};
#line 168 "/tmp/zsh-5.4.2/Src/glob.c"
struct globdata {
   int gd_pathpos ;
   char *gd_pathbuf ;
   int gd_matchsz ;
   int gd_matchct ;
   int gd_pathbufsz ;
   int gd_pathbufcwd ;
   Gmatch gd_matchbuf ;
   Gmatch gd_matchptr ;
   char *gd_colonmod ;
   struct qual *gd_quals ;
   int gd_qualct ;
   int gd_qualorct ;
   int gd_range ;
   int gd_amc ;
   int gd_units ;
   int gd_gf_nullglob ;
   int gd_gf_markdirs ;
   int gd_gf_noglobdots ;
   int gd_gf_listtypes ;
   int gd_gf_numsort ;
   int gd_gf_follow ;
   int gd_gf_sorts ;
   int gd_gf_nsorts ;
   struct globsort gd_gf_sortlist[12] ;
   LinkList gd_gf_pre_words ;
   LinkList gd_gf_post_words ;
   char *gd_glob_pre ;
   char *gd_glob_suf ;
};
#line 252 "/tmp/zsh-5.4.2/Src/glob.c"
struct complist {
   Complist next ;
   Patprog pat ;
   int closure ;
   int follow ;
};
#line 507 "./zsh.h"
struct asgment ;
#line 507 "./zsh.h"
typedef struct asgment *Asgment;
#line 514
struct execcmd_params ;
#line 514 "./zsh.h"
typedef struct execcmd_params *Execcmd_params;
#line 731 "./zsh.h"
struct multio {
   int ct ;
   int rflag ;
   int pipe ;
   int fds[8] ;
};
#line 1217 "./zsh.h"
union __anonunion_value_486633993 {
   char *scalar ;
   LinkList array ;
};
#line 1217 "./zsh.h"
struct asgment {
   struct linknode node ;
   char *name ;
   int is_array ;
   union __anonunion_value_486633993 value ;
};
#line 1426 "./zsh.h"
struct execcmd_params {
   LinkList args ;
   LinkList redir ;
   Wordcode beg ;
   Wordcode varspc ;
   Wordcode assignspc ;
   int type ;
   int postassigns ;
   int htok ;
};
#line 38 "/tmp/zsh-5.4.2/Src/context.c"
struct context_stack {
   struct context_stack *next ;
   struct hist_stack hist_stack ;
   struct lex_stack lex_stack ;
   struct parse_stack parse_stack ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 32 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 73 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_major)(__dev_t __dev )  __attribute__((__const__)) ;
#line 74
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_minor)(__dev_t __dev )  __attribute__((__const__)) ;
#line 75
__inline extern  __attribute__((__nothrow__)) __dev_t ( __attribute__((__gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                         unsigned int __minor )  __attribute__((__const__)) ;
#line 79
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_major)(__dev_t __dev )  __attribute__((__const__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_major)(__dev_t __dev ) 
{ 
  unsigned int __major ;

  {
#line 79
  __major = (unsigned int )((__dev & 1048320UL) >> 8);
#line 79
  __major = (unsigned int )((unsigned long )__major | ((__dev & 0xfffff00000000000UL) >> 32));
#line 79
  return (__major);
}
}
#line 80
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_minor)(__dev_t __dev )  __attribute__((__const__)) ;
#line 80 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_minor)(__dev_t __dev ) 
{ 
  unsigned int __minor ;

  {
#line 80
  __minor = (unsigned int )(__dev & 255UL);
#line 80
  __minor = (unsigned int )((unsigned long )__minor | ((__dev & 17592184995840UL) >> 12));
#line 80
  return (__minor);
}
}
#line 81
__inline extern  __attribute__((__nothrow__)) __dev_t ( __attribute__((__gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                         unsigned int __minor )  __attribute__((__const__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern __dev_t ( __attribute__((__gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                           unsigned int __minor ) 
{ 
  __dev_t __dev ;

  {
#line 81
  __dev = (__dev_t )(__major & 4095U) << 8;
#line 81
  __dev |= (__dev_t )(__major & 4294963200U) << 32;
#line 81
  __dev |= (__dev_t )(__minor & 255U);
#line 81
  __dev |= (__dev_t )(__minor & 4294967040U) << 12;
#line 81
  return (__dev);
}
}
#line 390 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 391
extern int __overflow(_IO_FILE * , int  ) ;
#line 433
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 434
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 136
extern struct _IO_FILE *stdout ;
#line 199
extern int fclose(FILE *__stream ) ;
#line 204
extern int fflush(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 333
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
#line 484
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 495
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 496
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 506
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 524
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 545
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 603
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
#line 616
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
#line 646
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  {
#line 38
  tmp = vfprintf((FILE */* __restrict  */)stdout, __fmt, __arg);
  }
#line 38
  return (tmp);
}
}
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  {
#line 46
  tmp = _IO_getc(stdin);
  }
#line 46
  return (tmp);
}
}
#line 52 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 55
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  }
#line 55
  if (tmp___3) {
    {
#line 55
    tmp___0 = __uflow(__fp);
#line 55
    tmp___2 = tmp___0;
    }
  } else {
#line 55
    tmp___1 = __fp->_IO_read_ptr;
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 55
  return (tmp___2);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 72
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  }
#line 72
  if (tmp___3) {
    {
#line 72
    tmp___0 = __uflow(stdin);
#line 72
    tmp___2 = tmp___0;
    }
  } else {
#line 72
    tmp___1 = stdin->_IO_read_ptr;
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 72
  return (tmp___2);
}
}
#line 78 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  {
#line 81
  tmp = _IO_putc(__c, stdout);
  }
#line 81
  return (tmp);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 90
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  }
#line 90
  if (tmp___4) {
    {
#line 90
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp___3 = tmp___0;
    }
  } else {
#line 90
    tmp___1 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    tmp___2 = (char )__c;
#line 90
    *tmp___1 = tmp___2;
#line 90
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 90
  return (tmp___3);
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 107
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  }
#line 107
  if (tmp___4) {
    {
#line 107
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp___3 = tmp___0;
    }
  } else {
#line 107
    tmp___1 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    tmp___2 = (char )__c;
#line 107
    *tmp___1 = tmp___2;
#line 107
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 107
  return (tmp___3);
}
}
#line 114 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  {
#line 117
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 117
  return (tmp);
}
}
#line 124
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 131
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 206
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 206 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 209
  if (__c >= -128) {
#line 209
    if (__c < 256) {
      {
#line 209
      tmp = __ctype_tolower_loc();
#line 209
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 209
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 209
    tmp___0 = (__int32_t const   )__c;
  }
#line 209
  return ((int )tmp___0);
}
}
#line 212
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 212 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 215
  if (__c >= -128) {
#line 215
    if (__c < 256) {
      {
#line 215
      tmp = __ctype_toupper_loc();
#line 215
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 215
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 215
    tmp___0 = (__int32_t const   )__c;
  }
#line 215
  return ((int )tmp___0);
}
}
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 210
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
#line 224
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 226
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
#line 234
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
#line 249
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
#line 259
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 272
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 332
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 339
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 395
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
#line 397
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
#line 399
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
#line 401
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
#line 428
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver ,
                                                                                       int __fildes ,
                                                                                       struct stat64 *__stat_buf ) ;
#line 430
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver ,
                                                                                        char const   *__filename ,
                                                                                        struct stat64 *__stat_buf ) ;
#line 432
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver ,
                                                                                         char const   *__filename ,
                                                                                         struct stat64 *__stat_buf ) ;
#line 434
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat64)(int __ver ,
                                                                                           int __fildes ,
                                                                                           char const   *__filename ,
                                                                                           struct stat64 *__stat_buf ,
                                                                                           int __flag ) ;
#line 438
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
#line 441
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
#line 448
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 448 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 451
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 451
  return (tmp);
}
}
#line 455
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 455 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 458
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 458
  return (tmp);
}
}
#line 462
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
#line 462 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 465
  tmp = __fxstat(1, __fd, __statbuf);
  }
#line 465
  return (tmp);
}
}
#line 469
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
#line 469 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  {
#line 473
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  }
#line 473
  return (tmp);
}
}
#line 478
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 478 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 481
  tmp = __xmknod(0, __path, __mode, & __dev);
  }
#line 481
  return (tmp);
}
}
#line 486
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 486 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 490
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 490
  return (tmp);
}
}
#line 497
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 497 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat64)(char const   * __restrict  __path ,
                                                                                struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 500
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  }
#line 500
  return (tmp);
}
}
#line 504
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 504 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat64)(char const   * __restrict  __path ,
                                                                                 struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 507
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  }
#line 507
  return (tmp);
}
}
#line 511
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
#line 511 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat64)(int __fd ,
                                                                               struct stat64 *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 514
  tmp = __fxstat64(1, __fd, __statbuf);
  }
#line 514
  return (tmp);
}
}
#line 518
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
#line 518 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat64)(int __fd ,
                                                                                   char const   * __restrict  __filename ,
                                                                                   struct stat64 * __restrict  __statbuf ,
                                                                                   int __flag ) 
{ 
  int tmp ;

  {
  {
#line 522
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  }
#line 522
  return (tmp);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 117
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
#line 360
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 360 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
#line 363
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
#line 363
  return ((int )tmp);
}
}
#line 365
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 365 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
#line 368
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
#line 368
  return (tmp);
}
}
#line 372
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 372 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  {
#line 375
  tmp = strtoll((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
                10);
  }
#line 375
  return (tmp);
}
}
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 817
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
#line 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 827 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  {
#line 27
  tmp = strtod((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)));
  }
#line 27
  return (tmp);
}
}
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 63
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 136
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 139
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 284 "/usr/include/wchar.h"
__inline extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__gnu_inline__)) btowc)(int __c ) ;
#line 288
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctob)(wint_t __wc ) ;
#line 296
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t * __restrict  __p ) ;
#line 305
extern  __attribute__((__nothrow__)) size_t __mbrlen(char const   * __restrict  __s ,
                                                     size_t __n , mbstate_t * __restrict  __ps ) ;
#line 307
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbrlen)(char const   * __restrict  __s ,
                                                                                               size_t __n ,
                                                                                               mbstate_t * __restrict  __ps ) ;
#line 316
extern wint_t __btowc_alias(int __c )  __asm__("btowc")  ;
#line 317
__inline extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__gnu_inline__)) btowc)(int __c ) ;
#line 317 "/usr/include/wchar.h"
__inline extern wint_t ( __attribute__((__gnu_inline__)) btowc)(int __c ) 
{ 
  wint_t tmp ;

  {
  {
#line 319
  tmp = __btowc_alias(__c);
  }
#line 319
  return (tmp);
}
}
#line 322
extern int __wctob_alias(wint_t __c )  __asm__("wctob")  ;
#line 323
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctob)(wint_t __wc ) ;
#line 323 "/usr/include/wchar.h"
__inline extern int ( __attribute__((__gnu_inline__)) wctob)(wint_t __wc ) 
{ 
  int tmp ;

  {
  {
#line 325
  tmp = __wctob_alias(__wc);
  }
#line 325
  return (tmp);
}
}
#line 328
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbrlen)(char const   * __restrict  __s ,
                                                                                               size_t __n ,
                                                                                               mbstate_t * __restrict  __ps ) ;
#line 328 "/usr/include/wchar.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) mbrlen)(char const   * __restrict  __s ,
                                                                 size_t __n , mbstate_t * __restrict  __ps ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 331
  if ((unsigned long )__ps != (unsigned long )((void *)0)) {
    {
#line 331
    tmp = mbrtowc((wchar_t */* __restrict  */)((void *)0), __s, __n, __ps);
#line 331
    tmp___1 = tmp;
    }
  } else {
    {
#line 331
    tmp___0 = __mbrlen(__s, __n, (mbstate_t */* __restrict  */)((void *)0));
#line 331
    tmp___1 = tmp___0;
    }
  }
#line 331
  return (tmp___1);
}
}
#line 9 "./exec.epro"
int errflag ;
#line 24 "./glob.epro"
void tokenize(char *s ) ;
#line 21 "./mem.epro"
void *zalloc(size_t size ) ;
#line 12 "./params.epro"
char **watch ;
#line 95
char *getsparam_u(char *s ) ;
#line 9 "./pattern.epro"
Patprog patcompile(char *exp , int inflags , char **endexp ) ;
#line 17
int pattry(Patprog prog , char *string ) ;
#line 5 "./prompt.epro"
unsigned int txtattrmask ;
#line 10
void tsetcap(int cap , int flags ) ;
#line 9 "./signals.epro"
int queueing_enabled ;
#line 10
int queue_front ;
#line 11
int queue_rear ;
#line 12
int signal_queue[128] ;
#line 13
sigset_t signal_mask_queue[128] ;
#line 21
void holdintr(void) ;
#line 22
void noholdintr(void) ;
#line 28
sigset_t signal_setmask(sigset_t set ) ;
#line 32
void zhandler(int sig ) ;
#line 5 "./string.epro"
char *dupstring(char const   *s ) ;
#line 36 "./utils.epro"
char *get_username(void) ;
#line 46
time_t lastwatch ;
#line 92
int ztrftime(char *buf___7 , int bufsize , char *fmt , struct tm *tm , long usec ) ;
#line 108
short typtab[256] ;
#line 126
char *metafy(char *buf___7 , int len , int heap ) ;
#line 5 "./watch.epro"
char const   * const  default_watchfmt ;
#line 6
void dowatch(void) ;
#line 7
int bin_log(char *nam  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
            Options ops  __attribute__((__unused__)) , int func  __attribute__((__unused__)) ) ;
#line 53 "/usr/include/utmpx.h"
extern void setutxent(void) ;
#line 59
extern void endutxent(void) ;
#line 65
extern struct utmpx *getutxent(void) ;
#line 143 "/tmp/zsh-5.4.2/Src/watch.c"
char const   * const  default_watchfmt  =    (char const   */* const  */)"%n has %a %l from %m.";
#line 2 "./watch.pro"
static time_t getlogtime(struct utmpx *u , int inout ) ;
#line 3
static char *watch3ary(int inout , struct utmpx *u , char *fmt , int prnt ) ;
#line 4
static char *watchlog2(int inout , struct utmpx *u , char *fmt , int prnt , int fini ) ;
#line 5
static void watchlog(int inout , struct utmpx *u , char **w , char *fmt ) ;
#line 6
static int ucmp(struct utmpx *u , struct utmpx *v ) ;
#line 7
static int readwtab(struct utmpx **head , int initial_sz ) ;
#line 153 "/tmp/zsh-5.4.2/Src/watch.c"
static int wtabsz  =    0;
#line 154 "/tmp/zsh-5.4.2/Src/watch.c"
static struct utmpx *wtab  =    (struct utmpx *)((void *)0);
#line 155 "/tmp/zsh-5.4.2/Src/watch.c"
static time_t lastutmpcheck  =    (time_t )0;
#line 160 "/tmp/zsh-5.4.2/Src/watch.c"
static time_t getlogtime(struct utmpx *u , int inout ) 
{ 
  FILE *in ;
  struct utmpx uu ;
  int first ;
  int srchlimit ;
  time_t tmp ;
  time_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  time_t tmp___3 ;
  size_t tmp___4 ;
  time_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  time_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
#line 165
  first = 1;
#line 166
  srchlimit = 50;
#line 168
  if (inout) {
#line 169
    return ((time_t )u->ut_tv.tv_sec);
  }
  {
#line 170
  in = fopen((char const   */* __restrict  */)"/var/log/wtmp", (char const   */* __restrict  */)"r");
  }
#line 170
  if (! in) {
    {
#line 171
    tmp = time((time_t *)((void *)0));
    }
#line 171
    return (tmp);
  }
  {
#line 172
  fseeko(in, (__off_t )0, 2);
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (first) {
#line 174
      tmp___1 = -1;
    } else {
#line 174
      tmp___1 = -2;
    }
    {
#line 174
    tmp___2 = fseeko(in, (__off_t )((unsigned long )tmp___1 * sizeof(struct utmpx )),
                     1);
    }
#line 174
    if (tmp___2) {
      {
#line 175
      fclose(in);
#line 176
      tmp___0 = time((time_t *)((void *)0));
      }
#line 176
      return (tmp___0);
    }
    {
#line 178
    first = 0;
#line 179
    tmp___4 = fread((void */* __restrict  */)(& uu), sizeof(struct utmpx ), (size_t )1,
                    (FILE */* __restrict  */)in);
    }
#line 179
    if (! tmp___4) {
      {
#line 180
      fclose(in);
#line 181
      tmp___3 = time((time_t *)((void *)0));
      }
#line 181
      return (tmp___3);
    }
#line 183
    if ((time_t )uu.ut_tv.tv_sec < lastwatch) {
      {
#line 184
      fclose(in);
#line 185
      tmp___5 = time((time_t *)((void *)0));
      }
#line 185
      return (tmp___5);
    } else {
#line 183
      tmp___6 = srchlimit;
#line 183
      srchlimit --;
#line 183
      if (! tmp___6) {
        {
#line 184
        fclose(in);
#line 185
        tmp___5 = time((time_t *)((void *)0));
        }
#line 185
        return (tmp___5);
      }
    }
    {
#line 173
    tmp___7 = memcmp((void const   *)(& uu), (void const   *)u, sizeof(uu));
    }
#line 173
    if (! tmp___7) {
#line 173
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 190
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 191
    tmp___9 = fread((void */* __restrict  */)(& uu), sizeof(struct utmpx ), (size_t )1,
                    (FILE */* __restrict  */)in);
    }
#line 191
    if (! tmp___9) {
      {
#line 192
      fclose(in);
#line 193
      tmp___8 = time((time_t *)((void *)0));
      }
#line 193
      return (tmp___8);
    }
    {
#line 190
    tmp___10 = strncmp((char const   *)(uu.ut_line), (char const   *)(u->ut_line),
                       sizeof(u->ut_line));
    }
#line 190
    if (! tmp___10) {
#line 190
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 196
  fclose(in);
  }
#line 197
  return ((time_t )uu.ut_tv.tv_sec);
}
}
#line 206 "/tmp/zsh-5.4.2/Src/watch.c"
static char *watch3ary(int inout , struct utmpx *u , char *fmt , int prnt ) 
{ 
  int truth ;
  int sep ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 209
  truth = 1;
#line 211
  tmp = fmt;
#line 211
  fmt ++;
  {
#line 212
  if ((int )*tmp == 110) {
#line 212
    goto case_110;
  }
#line 215
  if ((int )*tmp == 97) {
#line 215
    goto case_97;
  }
#line 218
  if ((int )*tmp == 108) {
#line 218
    goto case_108;
  }
#line 226
  if ((int )*tmp == 77) {
#line 226
    goto case_77;
  }
#line 226
  if ((int )*tmp == 109) {
#line 226
    goto case_77;
  }
#line 230
  goto switch_default;
  case_110: /* CIL Label */ 
#line 213
  truth = (int )u->ut_user[0] != 0;
#line 214
  goto switch_break;
  case_97: /* CIL Label */ 
#line 216
  truth = inout;
#line 217
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 219
  tmp___0 = strncmp((char const   *)(u->ut_line), "tty", (size_t )3);
  }
#line 219
  if (tmp___0) {
#line 222
    truth = (int )u->ut_line[0] != 0;
  } else {
#line 220
    truth = (int )u->ut_line[3] != 0;
  }
#line 223
  goto switch_break;
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
#line 227
  truth = (int )u->ut_host[0] != 0;
#line 228
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 231
  prnt = 0;
#line 232
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 234
  tmp___1 = fmt;
#line 234
  fmt ++;
#line 234
  sep = (int )*tmp___1;
#line 235
  if (truth) {
#line 235
    if (prnt) {
#line 235
      tmp___2 = 1;
    } else {
#line 235
      tmp___2 = 0;
    }
  } else {
#line 235
    tmp___2 = 0;
  }
  {
#line 235
  fmt = watchlog2(inout, u, fmt, tmp___2, sep);
  }
#line 236
  if (! truth) {
#line 236
    if (prnt) {
#line 236
      tmp___3 = 1;
    } else {
#line 236
      tmp___3 = 0;
    }
  } else {
#line 236
    tmp___3 = 0;
  }
  {
#line 236
  tmp___4 = watchlog2(inout, u, fmt, tmp___3, ')');
  }
#line 236
  return (tmp___4);
}
}
#line 242 "/tmp/zsh-5.4.2/Src/watch.c"
static char *watchlog2(int inout , struct utmpx *u , char *fmt , int prnt , int fini ) 
{ 
  char buf___7[40] ;
  char buf2[80] ;
  time_t timet ;
  struct tm *tm ;
  char *fm2 ;
  int len ;
  char *p ;
  int i ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *dd ;
  char *ss ;
  int n ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! *fmt) {
#line 255
      goto while_break;
    }
#line 256
    if ((int )*fmt == 92) {
#line 257
      fmt ++;
#line 257
      if (*fmt) {
#line 258
        if (prnt) {
          {
#line 259
          putchar((int )*fmt);
          }
        }
#line 260
        fmt ++;
      } else
#line 261
      if (fini) {
#line 262
        return (fmt);
      } else {
#line 264
        goto while_break;
      }
    } else
#line 266
    if ((int )*fmt == fini) {
#line 267
      fmt ++;
#line 267
      return (fmt);
    } else
#line 268
    if ((int )*fmt != 37) {
#line 269
      if (prnt) {
        {
#line 270
        putchar((int )*fmt);
        }
      }
#line 271
      fmt ++;
    } else {
#line 273
      fmt ++;
#line 273
      if ((int )*fmt == 40) {
        {
#line 274
        fmt ++;
#line 274
        fmt = watch3ary(inout, u, fmt, prnt);
        }
      } else
#line 275
      if (! prnt) {
#line 276
        fmt ++;
      } else {
#line 278
        tmp = fmt;
#line 278
        fmt ++;
#line 278
        fm2 = tmp;
        {
#line 279
        if ((int )*fm2 == 110) {
#line 279
          goto case_110;
        }
#line 282
        if ((int )*fm2 == 97) {
#line 282
          goto case_97;
        }
#line 285
        if ((int )*fm2 == 108) {
#line 285
          goto case_108;
        }
#line 292
        if ((int )*fm2 == 109) {
#line 292
          goto case_109;
        }
#line 299
        if ((int )*fm2 == 77) {
#line 299
          goto case_77;
        }
#line 308
        if ((int )*fm2 == 68) {
#line 308
          goto case_68;
        }
#line 308
        if ((int )*fm2 == 119) {
#line 308
          goto case_68;
        }
#line 308
        if ((int )*fm2 == 87) {
#line 308
          goto case_68;
        }
#line 308
        if ((int )*fm2 == 64) {
#line 308
          goto case_68;
        }
#line 308
        if ((int )*fm2 == 116) {
#line 308
          goto case_68;
        }
#line 308
        if ((int )*fm2 == 84) {
#line 308
          goto case_68;
        }
#line 348
        if ((int )*fm2 == 37) {
#line 348
          goto case_37;
        }
#line 351
        if ((int )*fm2 == 83) {
#line 351
          goto case_83;
        }
#line 355
        if ((int )*fm2 == 115) {
#line 355
          goto case_115;
        }
#line 359
        if ((int )*fm2 == 66) {
#line 359
          goto case_66;
        }
#line 363
        if ((int )*fm2 == 98) {
#line 363
          goto case_98;
        }
#line 367
        if ((int )*fm2 == 85) {
#line 367
          goto case_85;
        }
#line 371
        if ((int )*fm2 == 117) {
#line 371
          goto case_117;
        }
#line 375
        goto switch_default;
        case_110: /* CIL Label */ 
        {
#line 280
        printf((char const   */* __restrict  */)"%.*s", (int )sizeof(u->ut_user),
               u->ut_user);
        }
#line 281
        goto switch_break;
        case_97: /* CIL Label */ 
#line 283
        if (! inout) {
#line 283
          tmp___0 = "logged off";
        } else {
#line 283
          tmp___0 = "logged on";
        }
        {
#line 283
        printf((char const   */* __restrict  */)"%s", tmp___0);
        }
#line 284
        goto switch_break;
        case_108: /* CIL Label */ 
        {
#line 286
        tmp___1 = strncmp((char const   *)(u->ut_line), "tty", (size_t )3);
        }
#line 286
        if (tmp___1) {
          {
#line 289
          printf((char const   */* __restrict  */)"%.*s", (int )sizeof(u->ut_line),
                 u->ut_line);
          }
        } else {
          {
#line 287
          printf((char const   */* __restrict  */)"%.*s", (int )sizeof(u->ut_line) - 3,
                 u->ut_line + 3);
          }
        }
#line 290
        goto switch_break;
        case_109: /* CIL Label */ 
#line 293
        p = u->ut_host;
#line 293
        i = (int )sizeof(u->ut_host);
        {
#line 293
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 293
          if (i) {
#line 293
            if (! *p) {
#line 293
              goto while_break___0;
            }
          } else {
#line 293
            goto while_break___0;
          }
#line 294
          if ((int )*p == 46) {
#line 294
            if (! ((int )typtab[(unsigned char )*(p + 1)] & 1)) {
#line 295
              goto while_break___0;
            }
          }
          {
#line 296
          putchar((int )*p);
#line 293
          i --;
#line 293
          p ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 298
        goto switch_break;
        case_77: /* CIL Label */ 
        {
#line 300
        printf((char const   */* __restrict  */)"%.*s", (int )sizeof(u->ut_host),
               u->ut_host);
        }
#line 301
        goto switch_break;
        case_68: /* CIL Label */ 
        case_119: /* CIL Label */ 
        case_87: /* CIL Label */ 
        case_64: /* CIL Label */ 
        case_116: /* CIL Label */ 
        case_84: /* CIL Label */ 
        {
#line 311
        if ((int )*fm2 == 116) {
#line 311
          goto case_116___0;
        }
#line 311
        if ((int )*fm2 == 64) {
#line 311
          goto case_116___0;
        }
#line 314
        if ((int )*fm2 == 84) {
#line 314
          goto case_84___0;
        }
#line 317
        if ((int )*fm2 == 119) {
#line 317
          goto case_119___0;
        }
#line 320
        if ((int )*fm2 == 87) {
#line 320
          goto case_87___0;
        }
#line 323
        if ((int )*fm2 == 68) {
#line 323
          goto case_68___0;
        }
#line 309
        goto switch_break___0;
        case_116___0: /* CIL Label */ 
        case_64___0: /* CIL Label */ 
#line 312
        fm2 = (char *)"%l:%M%p";
#line 313
        goto switch_break___0;
        case_84___0: /* CIL Label */ 
#line 315
        fm2 = (char *)"%K:%M";
#line 316
        goto switch_break___0;
        case_119___0: /* CIL Label */ 
#line 318
        fm2 = (char *)"%a %f";
#line 319
        goto switch_break___0;
        case_87___0: /* CIL Label */ 
#line 321
        fm2 = (char *)"%m/%d/%y";
#line 322
        goto switch_break___0;
        case_68___0: /* CIL Label */ 
#line 324
        if ((int )*(fm2 + 1) == 123) {
#line 326
          n = 79;
#line 328
          ss = fm2 + 2;
#line 328
          dd = buf2;
          {
#line 328
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 328
            tmp___3 = n;
#line 328
            n --;
#line 328
            if (tmp___3) {
#line 328
              if (*ss) {
#line 328
                if (! ((int )*ss != 125)) {
#line 328
                  goto while_break___1;
                }
              } else {
#line 328
                goto while_break___1;
              }
            } else {
#line 328
              goto while_break___1;
            }
#line 330
            if ((int )*ss == 92) {
#line 330
              if (*(ss + 1)) {
#line 330
                ss ++;
#line 330
                tmp___2 = ss;
              } else {
#line 330
                tmp___2 = ss;
              }
            } else {
#line 330
              tmp___2 = ss;
            }
#line 330
            *dd = *tmp___2;
#line 328
            ss ++;
#line 328
            dd ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 331
          if ((int )*ss == 125) {
#line 332
            *dd = (char )'\000';
#line 333
            fmt = ss + 1;
#line 334
            fm2 = buf2;
          } else {
#line 336
            fm2 = (char *)"%y-%m-%d";
          }
        } else {
#line 338
          fm2 = (char *)"%y-%m-%d";
        }
#line 339
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 341
        timet = getlogtime(u, inout);
#line 342
        tm = localtime((time_t const   *)(& timet));
#line 343
        len = ztrftime(buf___7, 40, fm2, tm, 0L);
        }
#line 344
        if (len > 0) {
          {
#line 345
          metafy(buf___7, len, 5);
          }
        }
#line 346
        if ((int )buf___7[0] == 32) {
#line 346
          tmp___4 = buf___7 + 1;
        } else {
#line 346
          tmp___4 = buf___7;
        }
        {
#line 346
        printf((char const   */* __restrict  */)"%s", tmp___4);
        }
#line 347
        goto switch_break;
        case_37: /* CIL Label */ 
        {
#line 349
        putchar('%');
        }
#line 350
        goto switch_break;
        case_83: /* CIL Label */ 
        {
#line 352
        txtattrmask |= 2U;
#line 353
        tsetcap(19, 1);
        }
#line 354
        goto switch_break;
        case_115: /* CIL Label */ 
        {
#line 356
        txtattrmask &= 4294967293U;
#line 357
        tsetcap(22, 5);
        }
#line 358
        goto switch_break;
        case_66: /* CIL Label */ 
        {
#line 360
        txtattrmask |= 1U;
#line 361
        tsetcap(18, 5);
        }
#line 362
        goto switch_break;
        case_98: /* CIL Label */ 
        {
#line 364
        txtattrmask &= 4294967294U;
#line 365
        tsetcap(21, 5);
        }
#line 366
        goto switch_break;
        case_85: /* CIL Label */ 
        {
#line 368
        txtattrmask |= 4U;
#line 369
        tsetcap(20, 1);
        }
#line 370
        goto switch_break;
        case_117: /* CIL Label */ 
        {
#line 372
        txtattrmask &= 4294967291U;
#line 373
        tsetcap(23, 5);
        }
#line 374
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 376
        putchar('%');
#line 377
        putchar((int )*fm2);
        }
#line 378
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  if (prnt) {
    {
#line 382
    putchar('\n');
    }
  }
#line 384
  return (fmt);
}
}
#line 389 "/tmp/zsh-5.4.2/Src/watch.c"
static int watchlog_match(char *teststr , char *actual , int len ) 
{ 
  int ret ;
  Patprog pprog ;
  char *str ;
  char *tmp ;
  int tmp___0 ;
  sigset_t oset ;
  int tmp___1 ;

  {
  {
#line 392
  ret = 0;
#line 394
  tmp = dupstring((char const   *)teststr);
#line 394
  str = tmp;
#line 396
  tokenize(str);
#line 398
  pprog = patcompile(str, 64, (char **)0);
  }
#line 398
  if (pprog) {
    {
#line 399
    queueing_enabled ++;
#line 400
    tmp___0 = pattry(pprog, actual);
    }
#line 400
    if (tmp___0) {
#line 401
      ret = 1;
    }
    {
#line 402
    while (1) {
      while_continue: /* CIL Label */ ;
#line 402
      queueing_enabled --;
#line 402
      if (! queueing_enabled) {
        {
#line 402
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 402
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 402
            if (! (queue_front != queue_rear)) {
#line 402
              goto while_break___1;
            }
            {
#line 402
            queue_front = (queue_front + 1) % 128;
#line 402
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 402
            zhandler(signal_queue[queue_front]);
#line 402
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 402
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 402
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 403
    tmp___1 = strncmp((char const   *)actual, (char const   *)teststr, (size_t )len);
    }
#line 403
    if (! tmp___1) {
#line 404
      ret = 1;
    }
  }
#line 405
  return (ret);
}
}
#line 411 "/tmp/zsh-5.4.2/Src/watch.c"
static void watchlog(int inout , struct utmpx *u , char **w , char *fmt ) 
{ 
  char *v ;
  char *vv ;
  char sav ;
  int bad ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 417
  if (! u->ut_user[0]) {
#line 418
    return;
  }
#line 420
  if (*w) {
    {
#line 420
    tmp = strcmp((char const   *)*w, "all");
    }
#line 420
    if (! tmp) {
      {
#line 421
      watchlog2(inout, u, fmt, 1, 0);
      }
#line 422
      return;
    }
  }
#line 424
  if (*w) {
    {
#line 424
    tmp___0 = strcmp((char const   *)*w, "notme");
    }
#line 424
    if (! tmp___0) {
      {
#line 424
      tmp___1 = get_username();
#line 424
      tmp___2 = strncmp((char const   *)(u->ut_user), (char const   *)tmp___1, sizeof(u->ut_user));
      }
#line 424
      if (tmp___2) {
        {
#line 426
        watchlog2(inout, u, fmt, 1, 0);
        }
#line 427
        return;
      }
    }
  }
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! *w) {
#line 429
      goto while_break;
    }
#line 430
    bad = 0;
#line 431
    v = *w;
#line 432
    if ((int )*v != 64) {
#line 432
      if ((int )*v != 37) {
#line 433
        vv = v;
        {
#line 433
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 433
          if (*vv) {
#line 433
            if ((int )*vv != 64) {
#line 433
              if (! ((int )*vv != 37)) {
#line 433
                goto while_break___0;
              }
            } else {
#line 433
              goto while_break___0;
            }
          } else {
#line 433
            goto while_break___0;
          }
#line 433
          vv ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 434
        sav = *vv;
#line 435
        *vv = (char )'\000';
#line 436
        tmp___3 = watchlog_match(v, u->ut_user, (int )sizeof(u->ut_user));
        }
#line 436
        if (! tmp___3) {
#line 437
          bad = 1;
        }
#line 438
        *vv = sav;
#line 439
        v = vv;
      }
    }
    {
#line 441
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 442
      if ((int )*v == 37) {
#line 443
        v ++;
#line 443
        vv = v;
        {
#line 443
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 443
          if (*vv) {
#line 443
            if (! ((int )*vv != 64)) {
#line 443
              goto while_break___2;
            }
          } else {
#line 443
            goto while_break___2;
          }
#line 443
          vv ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 444
        sav = *vv;
#line 445
        *vv = (char )'\000';
#line 446
        tmp___4 = watchlog_match(v, u->ut_line, (int )sizeof(u->ut_line));
        }
#line 446
        if (! tmp___4) {
#line 447
          bad = 1;
        }
#line 448
        *vv = sav;
#line 449
        v = vv;
      } else
#line 452
      if ((int )*v == 64) {
#line 453
        v ++;
#line 453
        vv = v;
        {
#line 453
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 453
          if (*vv) {
#line 453
            if (! ((int )*vv != 37)) {
#line 453
              goto while_break___3;
            }
          } else {
#line 453
            goto while_break___3;
          }
#line 453
          vv ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 454
        sav = *vv;
#line 455
        *vv = (char )'\000';
#line 456
        tmp___5 = strlen((char const   *)v);
#line 456
        tmp___6 = watchlog_match(v, u->ut_host, (int )tmp___5);
        }
#line 456
        if (! tmp___6) {
#line 457
          bad = 1;
        }
#line 458
        *vv = sav;
#line 459
        v = vv;
      } else {
#line 463
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 464
    if (! bad) {
      {
#line 465
      watchlog2(inout, u, fmt, 1, 0);
      }
#line 466
      return;
    }
#line 429
    w ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 469
  return;
}
}
#line 474 "/tmp/zsh-5.4.2/Src/watch.c"
static int ucmp(struct utmpx *u , struct utmpx *v ) 
{ 
  int tmp ;

  {
#line 477
  if (u->ut_tv.tv_sec == v->ut_tv.tv_sec) {
    {
#line 478
    tmp = strncmp((char const   *)(u->ut_line), (char const   *)(v->ut_line), sizeof(u->ut_line));
    }
#line 478
    return (tmp);
  }
#line 479
  return (u->ut_tv.tv_sec - v->ut_tv.tv_sec);
}
}
#line 485 "/tmp/zsh-5.4.2/Src/watch.c"
static int readwtab(struct utmpx **head , int initial_sz ) 
{ 
  struct utmpx *uptr ;
  int wtabmax ;
  int tmp ;
  int sz___0 ;
  struct utmpx *tmp___0 ;
  struct utmpx *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 489
  if (initial_sz < 2) {
#line 489
    tmp = 32;
  } else {
#line 489
    tmp = initial_sz;
  }
  {
#line 489
  wtabmax = tmp;
#line 490
  sz___0 = 0;
#line 497
  tmp___2 = zalloc((unsigned long )wtabmax * sizeof(struct utmpx ));
#line 497
  tmp___1 = (struct utmpx *)tmp___2;
#line 497
  *head = tmp___1;
#line 497
  uptr = tmp___1;
#line 500
  setutxent();
  }
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 501
    tmp___0 = getutxent();
    }
#line 501
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 501
      goto while_break;
    }
    {
#line 502
    memcpy((void */* __restrict  */)uptr, (void const   */* __restrict  */)tmp___0,
           sizeof(struct utmpx ));
    }
#line 509
    if ((int )uptr->ut_type == 7) {
#line 514
      uptr ++;
#line 515
      sz___0 ++;
#line 515
      if (sz___0 == wtabmax) {
        {
#line 516
        wtabmax *= 2;
#line 516
        tmp___3 = realloc((void *)*head, (unsigned long )wtabmax * sizeof(struct utmpx ));
#line 516
        uptr = (struct utmpx *)tmp___3;
        }
#line 518
        if ((unsigned long )uptr == (unsigned long )((void *)0)) {
#line 521
          sz___0 --;
#line 522
          goto while_break;
        }
#line 524
        *head = uptr;
#line 525
        uptr += sz___0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 530
  endutxent();
  }
#line 535
  if (sz___0) {
    {
#line 536
    qsort((void *)*head, (size_t )sz___0, sizeof(struct utmpx ), (int (*)(void const   * ,
                                                                          void const   * ))(& ucmp));
    }
  }
#line 538
  return (sz___0);
}
}
#line 545 "/tmp/zsh-5.4.2/Src/watch.c"
void dowatch(void) 
{ 
  struct utmpx *utab ;
  struct utmpx *uptr ;
  struct utmpx *wptr ;
  struct stat st___0 ;
  char **s ;
  char *fmt ;
  int utabsz ;
  int uct ;
  int wct ;
  int tmp ;
  struct utmpx *tmp___0 ;
  struct utmpx *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  sigset_t oset ;

  {
  {
#line 554
  s = watch;
#line 556
  holdintr();
  }
#line 557
  if (! wtab) {
    {
#line 558
    wtabsz = readwtab(& wtab, 32);
    }
  }
  {
#line 559
  tmp = stat((char const   */* __restrict  */)"/var/run/utmp", (struct stat */* __restrict  */)(& st___0));
  }
#line 559
  if (tmp == -1) {
    {
#line 560
    noholdintr();
    }
#line 561
    return;
  } else
#line 559
  if (st___0.st_mtim.tv_sec <= lastutmpcheck) {
    {
#line 560
    noholdintr();
    }
#line 561
    return;
  }
  {
#line 563
  lastutmpcheck = st___0.st_mtim.tv_sec;
#line 564
  utabsz = readwtab(& utab, wtabsz + 4);
#line 565
  noholdintr();
  }
#line 566
  if (errflag) {
    {
#line 567
    free((void *)utab);
    }
#line 568
    return;
  }
#line 571
  wct = wtabsz;
#line 572
  uct = utabsz;
#line 573
  uptr = utab;
#line 574
  wptr = wtab;
#line 575
  if (errflag) {
    {
#line 576
    free((void *)utab);
    }
#line 577
    return;
  }
  {
#line 579
  queueing_enabled ++;
#line 580
  fmt = getsparam_u((char *)"WATCHFMT");
  }
#line 580
  if (! fmt) {
#line 581
    fmt = (char *)"%n has %a %l from %m.";
  }
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    if (uct) {
#line 582
      goto _L___0;
    } else
#line 582
    if (wct) {
      _L___0: /* CIL Label */ 
#line 582
      if (! (! errflag)) {
#line 582
        goto while_break;
      }
    } else {
#line 582
      goto while_break;
    }
#line 583
    if (! uct) {
      {
#line 584
      wct --;
#line 584
      tmp___0 = wptr;
#line 584
      wptr ++;
#line 584
      watchlog(0, tmp___0, s, fmt);
      }
    } else
#line 583
    if (wct) {
      {
#line 583
      tmp___3 = ucmp(uptr, wptr);
      }
#line 583
      if (tmp___3 > 0) {
        {
#line 584
        wct --;
#line 584
        tmp___0 = wptr;
#line 584
        wptr ++;
#line 584
        watchlog(0, tmp___0, s, fmt);
        }
      } else {
#line 583
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 585
    if (! wct) {
      {
#line 586
      uct --;
#line 586
      tmp___1 = uptr;
#line 586
      uptr ++;
#line 586
      watchlog(1, tmp___1, s, fmt);
      }
    } else
#line 585
    if (uct) {
      {
#line 585
      tmp___2 = ucmp(uptr, wptr);
      }
#line 585
      if (tmp___2 < 0) {
        {
#line 586
        uct --;
#line 586
        tmp___1 = uptr;
#line 586
        uptr ++;
#line 586
        watchlog(1, tmp___1, s, fmt);
        }
      } else {
#line 588
        uptr ++;
#line 588
        wptr ++;
#line 588
        wct --;
#line 588
        uct --;
      }
    } else {
#line 588
      uptr ++;
#line 588
      wptr ++;
#line 588
      wct --;
#line 588
      uct --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 590
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 590
    queueing_enabled --;
#line 590
    if (! queueing_enabled) {
      {
#line 590
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 590
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 590
          if (! (queue_front != queue_rear)) {
#line 590
            goto while_break___2;
          }
          {
#line 590
          queue_front = (queue_front + 1) % 128;
#line 590
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 590
          zhandler(signal_queue[queue_front]);
#line 590
          signal_setmask(oset);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 590
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 590
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 591
  free((void *)wtab);
#line 592
  wtab = utab;
#line 593
  wtabsz = utabsz;
#line 594
  fflush(stdout);
  }
#line 595
  return;
}
}
#line 598 "/tmp/zsh-5.4.2/Src/watch.c"
int bin_log(char *nam  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
            Options ops  __attribute__((__unused__)) , int func  __attribute__((__unused__)) ) 
{ 
  void *tmp ;

  {
#line 601
  if (! watch) {
#line 602
    return (1);
  }
#line 603
  if (wtab) {
    {
#line 604
    free((void *)wtab);
    }
  }
  {
#line 605
  tmp = zalloc((size_t )1);
#line 605
  wtab = (struct utmpx *)tmp;
#line 606
  wtabsz = 0;
#line 607
  lastutmpcheck = (time_t )0;
#line 608
  dowatch();
  }
#line 609
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 290 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 356
extern int close(int __fd ) ;
#line 363
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 369
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 447
extern unsigned int sleep(unsigned int __seconds ) ;
#line 500
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 504
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 537
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 681
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 782
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 811
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2))) readlink)(char const   * __restrict  __path ,
                                                                                           char * __restrict  __buf ,
                                                                                           size_t __len ) ;
#line 841
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 844
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 320
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 517
extern int fputc(int __c , FILE *__stream ) ;
#line 626
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 652
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 112 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 109 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 115
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 672
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) mktemp)(char *__template ) ;
#line 685
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 926
extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 78 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 )  __attribute__((__const__)) ;
#line 88
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 211
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 121
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 124
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 225
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 396
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 157
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 253 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) wchar_t *wmemchr(wchar_t const   *__s , wchar_t __c ,
                                                      size_t __n )  __attribute__((__pure__)) ;
#line 262
extern  __attribute__((__nothrow__)) wchar_t *wmemcpy(wchar_t * __restrict  __s1 ,
                                                      wchar_t const   * __restrict  __s2 ,
                                                      size_t __n ) ;
#line 301
extern  __attribute__((__nothrow__)) size_t wcrtomb(char * __restrict  __s , wchar_t __wc ,
                                                    mbstate_t * __restrict  __ps ) ;
#line 367
extern  __attribute__((__nothrow__)) int wcwidth(wchar_t __c ) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int iswalnum(wint_t __wc ) ;
#line 120
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
#line 130
extern  __attribute__((__nothrow__)) int iswspace(wint_t __wc ) ;
#line 139 "./signals.h"
sigset_t signal_block(sigset_t set ) ;
#line 142
sigset_t signal_unblock(sigset_t set ) ;
#line 5 "./builtin.epro"
HashTable builtintab ;
#line 41
int stopmsg ;
#line 24 "./compat.epro"
char *zgetdir(struct dirsav *d___0 ) ;
#line 26
int zchdir(char *dir ) ;
#line 7 "./exec.epro"
int noerrs ;
#line 13
int retflag ;
#line 15
unsigned char *fdtable ;
#line 16
int fdtable_size ;
#line 17
int max_zsh_fd ;
#line 18
int coprocin ;
#line 19
int coprocout ;
#line 20
int fdtable_flocks ;
#line 21
int zleactive ;
#line 25
int sfcontext ;
#line 41
Cmdnam hashcmd(char *arg0 , char **pp ) ;
#line 46
void untokenize(char *s ) ;
#line 48
void setunderscore(char *str ) ;
#line 60
int doshfunc(Shfunc shfunc , LinkList doshargs , int noreturnval ) ;
#line 26 "./glob.epro"
void remnulargs(char *s ) ;
#line 16 "./hashtable.epro"
extern int scanhashtable(HashTable ht , int sorted , int flags1 , int flags2 , void (*scanfunc)(HashNode  ,
                                                                                                int  ) ,
                         int scanflags ) ;
#line 21
extern HashTable cmdnamtab ;
#line 22
char **pathchecked ;
#line 25
extern HashTable shfunctab ;
#line 31
extern HashTable reswdtab ;
#line 33
extern HashTable aliastab ;
#line 5 "./hashnameddir.epro"
HashTable nameddirtab ;
#line 22 "./hist.epro"
int histdone ;
#line 56
void hwrep(char *rep ) ;
#line 6 "./init.epro"
char *zunderscore ;
#line 8
int underscoreused ;
#line 10
int SHTTY ;
#line 11
FILE *shout ;
#line 14
int tclines ;
#line 15
int tccolumns ;
#line 18
int hasxn ;
#line 40
char *zleentry(int cmd  , ...) ;
#line 43
int use_exit_printed ;
#line 6 "./jobs.epro"
pid_t mypgrp ;
#line 46
void scanjobs(void) ;
#line 5 "./lex.epro"
char ztokens[30] ;
#line 36
int parsestr(char **s ) ;
#line 5 "./linklist.epro"
LinkList newlinklist(void) ;
#line 6
LinkList znewlinklist(void) ;
#line 7
LinkNode insertlinknode(LinkList list , LinkNode node , void *dat ) ;
#line 8
LinkNode zinsertlinknode(LinkList list , LinkNode node , void *dat ) ;
#line 12
void *ugetnode(LinkList list ) ;
#line 13
void *remnode(LinkList list , LinkNode nd ) ;
#line 6 "./loop.epro"
int contflag ;
#line 7
int breaks ;
#line 11 "./mem.epro"
void pushheap(void) ;
#line 13
void popheap(void) ;
#line 15
void *zhalloc(size_t size ) ;
#line 16
void *hrealloc(char *p , size_t old , size_t new ) ;
#line 20
void *hcalloc(size_t size ) ;
#line 22
void *zshcalloc(size_t size ) ;
#line 23
void *zrealloc(void *ptr___0 , size_t size ) ;
#line 29
void zfree(void *p , int sz___0  __attribute__((__unused__)) ) ;
#line 30
void zsfree(char *p ) ;
#line 5 "./options.epro"
int emulation ;
#line 7
char opts[180] ;
#line 5 "./params.epro"
int locallevel ;
#line 7
char **cdpath ;
#line 9
char **mailpath ;
#line 14
char **path ;
#line 16
char *argzero ;
#line 18
char *home ;
#line 25
char *prompt4 ;
#line 29
char *sprompt ;
#line 30
char *wordchars ;
#line 31
char *ifs ;
#line 33
char *term ;
#line 37
char *pwd ;
#line 41
zlong zterm_columns ;
#line 42
zlong zterm_lines ;
#line 46
zlong lineno ;
#line 49
unsigned char bangchar ;
#line 54
int termflags ;
#line 66
HashTable paramtab ;
#line 92
zlong getiparam(char *s ) ;
#line 94
char *getsparam(char *s ) ;
#line 96
char **getaparam(char *s ) ;
#line 107
Param setiparam(char *s , zlong val ) ;
#line 190
char *zgetenv(char *name ) ;
#line 8 "./prompt.epro"
char *promptexpand(char *s , int ns , char *rs , char *Rs , unsigned int *txtchangep ) ;
#line 12
void countprompt(char *str , int *wp , int *hp , int overf ) ;
#line 23 "./signals.epro"
sigset_t signal_mask(int sig ) ;
#line 8 "./string.epro"
char *ztrdup(char const   *s ) ;
#line 10
wchar_t *wcs_ztrdup(wchar_t const   *s ) ;
#line 12
char *tricat(char const   *s1 , char const   *s2 , char const   *s3 ) ;
#line 13
char *zhtricat(char const   *s1 , char const   *s2 , char const   *s3 ) ;
#line 14
char *dyncat(char const   *s1 , char const   *s2 ) ;
#line 15
char *bicat(char const   *s1 , char const   *s2 ) ;
#line 16
char *dupstrpfx(char const   *s , int len ) ;
#line 17
char *ztrduppfx(char const   *s , int len ) ;
#line 5 "./subst.epro"
char nulstring[2] ;
#line 9
void singsub(char **s ) ;
#line 5 "./utils.epro"
char *scriptname  ;
#line 6 "./utils.epro"
char *scriptfilename  ;
#line 7 "./utils.epro"
int incompfunc  ;
#line 8
void zerr(char const   *fmt  , ...) ;
#line 9
void zerrnam(char const   *cmd , char const   *fmt  , ...) ;
#line 10
void zwarn(char const   *fmt  , ...) ;
#line 11
void zwarnnam(char const   *cmd , char const   *fmt  , ...) ;
#line 13
void zerrmsg(FILE *file , char const   *fmt , va_list___0 ap ) ;
#line 14
int putraw(int c ) ;
#line 15
int putshout(int c ) ;
#line 16
char *nicechar_sel(int c , int quotable ) ;
#line 17
char *nicechar(int c ) ;
#line 19
int is_nicechar(int c ) ;
#line 21
void mb_charinit(void) ;
#line 22
char *wcs_nicechar_sel(wchar_t c , size_t *widthp , char **swidep , int quotable ) ;
#line 23
char *wcs_nicechar(wchar_t c , size_t *widthp , char **swidep ) ;
#line 24
int is_wcs_nicechar(wchar_t c ) ;
#line 25
int zwcwidth(wint_t wc ) ;
#line 27
char *pathprog(char *prog , char **namep ) ;
#line 28
char *findpwd(char *s ) ;
#line 29
int ispwd(char *s ) ;
#line 30
char *xsymlink(char *s , int heap ) ;
#line 31
void print_if_link(char *s , int all ) ;
#line 32
void fprintdir(char *s , FILE *f ) ;
#line 33
char *substnamedir(char *s ) ;
#line 34 "./utils.epro"
uid_t cached_uid  ;
#line 35 "./utils.epro"
char *cached_username  ;
#line 37
Nameddir finddir(char *s ) ;
#line 38
void adduserdir(char *s , char *t , int flags , int always ) ;
#line 39
char *getnameddir(char *name ) ;
#line 40
void addprepromptfn(void (*func)(void) ) ;
#line 41
void delprepromptfn(void (*func)(void) ) ;
#line 42 "./utils.epro"
LinkList timedfns  ;
#line 43
void addtimedfn(void (*func)(void) , time_t when ) ;
#line 44
void deltimedfn(void (*func)(void) ) ;
#line 45 "./utils.epro"
time_t lastmailcheck  ;
#line 46 "./utils.epro"
time_t lastwatch  ;
#line 47
int callhookfunc(char *name , LinkList lnklst , int arrayp , int *retval ) ;
#line 48
void preprompt(void) ;
#line 49
FILE *xtrerr ;
#line 50
void printprompt4(void) ;
#line 51
void freestr(void *a ) ;
#line 52
void gettyinfo(struct ttyinfo *ti ) ;
#line 53
void settyinfo(struct ttyinfo *ti ) ;
#line 54 "./utils.epro"
struct ttyinfo shttyinfo  ;
#line 55 "./utils.epro"
int resetneeded  ;
#line 56 "./utils.epro"
int winchanged  ;
#line 57
void adjustwinsize(int from ) ;
#line 58
int movefd(int fd ) ;
#line 59
int redup(int x , int y ) ;
#line 60
void addmodulefd(int fd , int fdt ) ;
#line 61
void addlockfd(int fd , int cloexec ) ;
#line 62
int zclose(int fd ) ;
#line 63
int zcloselockfd(int fd ) ;
#line 64
char *gettempname(char const   *prefix , int use_heap ) ;
#line 65
int gettempfile(char const   *prefix , int use_heap , char **tempname ) ;
#line 66
int has_token(char const   *s ) ;
#line 67
void chuck(char *str ) ;
#line 68
int tulower(int c ) ;
#line 69
int tuupper(int c ) ;
#line 70
void ztrncpy(char *s , char *t , int len ) ;
#line 71
void strucpy(char **s , char *t ) ;
#line 72
void struncpy(char **s , char *t , int n ) ;
#line 73
int arrlen(char **s ) ;
#line 74
char arrlen_ge(char **s , unsigned int lower_bound ) ;
#line 75
char arrlen_gt(char **s , unsigned int lower_bound ) ;
#line 76
char arrlen_le(char **s , unsigned int upper_bound ) ;
#line 77
char arrlen_lt(char **s , unsigned int upper_bound ) ;
#line 78
int skipparens(char inpar , char outpar , char **s ) ;
#line 79
zlong zstrtol(char const   *s , char **t , int base ) ;
#line 80
zlong zstrtol_underscore(char const   *s , char **t , int base , int underscore ) ;
#line 81
int setblock_fd(int turnonblocking , int fd , long *modep ) ;
#line 82
int setblock_stdin(void) ;
#line 83
int read_poll(int fd , int *readchar , int polltty , zlong microseconds ) ;
#line 84
int zsleep(long us ) ;
#line 85
int zsleep_random(long max_us , time_t end_time ) ;
#line 86
int checkrmall(char *s ) ;
#line 87
ssize_t read_loop(int fd , char *buf___7 , size_t len ) ;
#line 88
ssize_t write_loop(int fd , char const   *buf___7 , size_t len ) ;
#line 89
int noquery(int purge ) ;
#line 90
int getquery(char *valid_chars , int purge ) ;
#line 91
void spckword(char **s , int hist , int cmd , int ask ) ;
#line 93
char *zjoin(char **arr , int delim , int heap ) ;
#line 94
char **colonsplit(char *s , int uniq ) ;
#line 95
char **spacesplit(char *s , int allownull , int heap , int quote___0 ) ;
#line 96
char *findword(char **s , char *sep ) ;
#line 97
int wordcount(char *s , char *sep , int mul ) ;
#line 98
char *sepjoin(char **s , char *sep , int heap ) ;
#line 99
char **sepsplit(char *s , char *sep , int allownull , int heap ) ;
#line 100
Shfunc getshfunc(char *nam ) ;
#line 101
char **subst_string_by_func(Shfunc func , char *arg1 , char *orig ) ;
#line 102
char **subst_string_by_hook(char *name , char *arg1 , char *orig ) ;
#line 103
char **mkarray(char *s ) ;
#line 104
char **hmkarray(char *s ) ;
#line 105
void zbeep(void) ;
#line 106
void freearray(char **s ) ;
#line 107
int equalsplit(char *s , char **t ) ;
#line 108 "./utils.epro"
short typtab[256]  ;
#line 109
void inittyptab(void) ;
#line 110
void makecommaspecial(int yesno ) ;
#line 111
void makebangspecial(int yesno ) ;
#line 113
int wcsiblank(wint_t wc ) ;
#line 114
int wcsitype(wchar_t c , int itype ) ;
#line 116
char *itype_end(char const   *ptr___0 , int itype , int once ) ;
#line 117
char **arrdup(char **s ) ;
#line 118
char **arrdup_max(char **s , unsigned int max ) ;
#line 119
char **zarrdup(char **s ) ;
#line 121
wchar_t **wcs_zarrdup(wchar_t **s ) ;
#line 123
void setcbreak(void) ;
#line 124
void attachtty(pid_t pgrp ) ;
#line 125
pid_t gettygrp(void) ;
#line 127
char *ztrdup_metafy(char const   *s ) ;
#line 128
char *unmetafy(char *s , int *len ) ;
#line 129
int metalen(char const   *s , int len ) ;
#line 130
char *unmeta(char const   *file_name ) ;
#line 131
convchar_t unmeta_one(char const   *in , int *sz___0 ) ;
#line 132
int ztrcmp(char const   *s1 , char const   *s2 ) ;
#line 133
int ztrlen(char const   *s ) ;
#line 135
int ztrsub(char const   *t , char const   *s ) ;
#line 136
char *zreaddir(DIR *dir , int ignoredots ) ;
#line 137
int zputs(char const   *s , FILE *stream ) ;
#line 138
char *nicedup(char const   *s , int heap ) ;
#line 139
char *nicedupstring(char const   *s ) ;
#line 143
size_t mb_niceformat(char const   *s , FILE *stream , char **outstrp , int flags ) ;
#line 144
int is_mb_niceformat(char const   *s ) ;
#line 146
int mb_metacharlenconv_r(char const   *s , wint_t *wcp , mbstate_t *mbsp ) ;
#line 147
int mb_metacharlenconv(char const   *s , wint_t *wcp ) ;
#line 148
int mb_metastrlenend(char *ptr___0 , int width , char *eptr ) ;
#line 149
int mb_charlenconv_r(char const   *s , int slen , wint_t *wcp , mbstate_t *mbsp ) ;
#line 150
int mb_charlenconv(char const   *s , int slen , wint_t *wcp ) ;
#line 155
int zexpandtabs(char const   *s , int len , int width , int startpos , FILE *fout ,
                int all ) ;
#line 156
int hasspecial(char const   *s ) ;
#line 157
char *quotestring(char const   *s , int instring ) ;
#line 158
char *quotedzputs(char const   *s , FILE *stream ) ;
#line 159
char *dquotedztrdup(char const   *s ) ;
#line 160
char *getkeystring(char *s , int *len , int how , int *misc ) ;
#line 161
int strpfx(char const   *s , char const   *t ) ;
#line 162
int strsfx(char *s , char *t ) ;
#line 163
void init_dirsav(Dirsav d___0 ) ;
#line 164
int lchdir(char const   *path___0 , struct dirsav *d___0 , int hard ) ;
#line 165
int restoredir(struct dirsav *d___0 ) ;
#line 166
int privasserted(void) ;
#line 167
int mode_to_octal(mode_t mode ) ;
#line 4 "./utils.pro"
static char **slashsplit(char *s ) ;
#line 5
static int xsymlinks(char *s , int full ) ;
#line 6
static void finddir_scan(HashNode hn , int flags  __attribute__((__unused__)) ) ;
#line 7
static int dircmp(char *s , char *t ) ;
#line 8
static void checkmailpath(char **s ) ;
#line 9
static void spscan(HashNode hn , int scanflags  __attribute__((__unused__)) ) ;
#line 10
static int skipwsep(char **s ) ;
#line 11
static int findsep(char **s , char *sep , int quote___0 ) ;
#line 16
static char *spname(char *oldname ) ;
#line 17
static int mindist(char *dir , char *mindistguess , char *mindistbest , int wantdir ) ;
#line 18
static int spdist(char *s , char *t , int thresh ) ;
#line 22
static int upchdir(int n ) ;
#line 59 "/tmp/zsh-5.4.2/Src/utils.c"
static struct widechar_array wordchars_wide  ;
#line 64 "/tmp/zsh-5.4.2/Src/utils.c"
static struct widechar_array ifs_wide  ;
#line 68 "/tmp/zsh-5.4.2/Src/utils.c"
static void set_widearray(char *mb_array , Widechar_array wca ) 
{ 
  wchar_t *tmpwcs ;
  size_t tmp ;
  void *tmp___0 ;
  wchar_t *wcptr ;
  wint_t wci ;
  int mblen___0 ;
  wchar_t *tmp___1 ;
  wchar_t *tmp___2 ;
  void *tmp___3 ;

  {
#line 71
  if (wca->chars) {
    {
#line 72
    free((void *)wca->chars);
#line 73
    wca->chars = (wchar_t *)((void *)0);
    }
  }
#line 75
  wca->len = (size_t )0;
#line 77
  if (! opts[117]) {
#line 78
    return;
  }
#line 80
  if (mb_array) {
    {
#line 81
    tmp = strlen((char const   *)mb_array);
#line 81
    tmp___0 = zhalloc(sizeof(wchar_t ) * tmp);
#line 81
    tmpwcs = (wchar_t *)tmp___0;
#line 82
    wcptr = tmpwcs;
#line 85
    mb_charinit();
    }
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
#line 86
      if (! *mb_array) {
#line 86
        goto while_break;
      }
#line 89
      if ((int )((unsigned char )*mb_array) <= 127) {
#line 90
        mb_array ++;
#line 91
        tmp___1 = wcptr;
#line 91
        wcptr ++;
#line 91
        *tmp___1 = (wchar_t )*mb_array;
#line 92
        goto while_continue;
      }
      {
#line 95
      mblen___0 = mb_metacharlenconv((char const   *)mb_array, & wci);
      }
#line 97
      if (! mblen___0) {
#line 98
        goto while_break;
      }
#line 100
      if (wci == 4294967295U) {
#line 101
        return;
      }
#line 102
      tmp___2 = wcptr;
#line 102
      wcptr ++;
#line 102
      *tmp___2 = (wchar_t )wci;
#line 112
      mb_array += mblen___0;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 115
    wca->len = (size_t )(wcptr - tmpwcs);
#line 116
    tmp___3 = zalloc(wca->len * sizeof(wchar_t ));
#line 116
    wca->chars = (wchar_t *)tmp___3;
#line 117
    wmemcpy((wchar_t */* __restrict  */)wca->chars, (wchar_t const   */* __restrict  */)tmpwcs,
            wca->len);
    }
  }
#line 119
  return;
}
}
#line 138 "/tmp/zsh-5.4.2/Src/utils.c"
static void zwarning(char const   *cmd , char const   *fmt , va_list___0 ap ) 
{ 
  int tmp ;
  char *prefix ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 141
  tmp = isatty(2);
  }
#line 141
  if (tmp) {
    {
#line 142
    zleentry(3);
    }
  }
#line 144
  if (scriptname) {
#line 144
    tmp___1 = (char const   *)scriptname;
  } else {
#line 144
    if (argzero) {
#line 144
      tmp___0 = (char const   *)argzero;
    } else {
#line 144
      tmp___0 = "";
    }
#line 144
    tmp___1 = tmp___0;
  }
#line 144
  prefix = (char *)tmp___1;
#line 146
  if (cmd) {
#line 147
    if (! opts[160]) {
      {
#line 148
      mb_niceformat((char const   *)prefix, stderr, (char **)((void *)0), 0);
#line 149
      fputc((int )((unsigned char )':'), stderr);
      }
    } else
#line 147
    if (locallevel) {
      {
#line 148
      mb_niceformat((char const   *)prefix, stderr, (char **)((void *)0), 0);
#line 149
      fputc((int )((unsigned char )':'), stderr);
      }
    }
    {
#line 151
    mb_niceformat(cmd, stderr, (char **)((void *)0), 0);
#line 152
    fputc((int )((unsigned char )':'), stderr);
    }
  } else {
#line 160
    if (opts[160]) {
#line 160
      if (! locallevel) {
#line 160
        tmp___2 = "zsh";
      } else {
#line 160
        tmp___2 = (char const   *)prefix;
      }
    } else {
#line 160
      tmp___2 = (char const   *)prefix;
    }
    {
#line 160
    mb_niceformat(tmp___2, stderr, (char **)((void *)0), 0);
#line 161
    fputc((int )((unsigned char )':'), stderr);
    }
  }
  {
#line 164
  zerrmsg(stderr, fmt, ap);
  }
#line 165
  return;
}
}
#line 169 "/tmp/zsh-5.4.2/Src/utils.c"
void zerr(char const   *fmt  , ...) 
{ 
  va_list___0 ap ;

  {
#line 176
  if (errflag) {
#line 176
    goto _L;
  } else
#line 176
  if (noerrs) {
    _L: /* CIL Label */ 
#line 177
    if (noerrs < 2) {
#line 178
      errflag |= 1;
    }
#line 179
    return;
  }
  {
#line 181
  errflag |= 1;
#line 183
  __builtin_va_start(ap, fmt);
#line 185
  zwarning((char const   *)((void *)0), fmt, ap);
#line 186
  __builtin_va_end(ap);
  }
#line 187
  return;
}
}
#line 190 "/tmp/zsh-5.4.2/Src/utils.c"
void zerrnam(char const   *cmd , char const   *fmt  , ...) 
{ 
  va_list___0 ap ;

  {
#line 198
  if (errflag) {
#line 199
    return;
  } else
#line 198
  if (noerrs) {
#line 199
    return;
  }
  {
#line 200
  errflag |= 1;
#line 202
  __builtin_va_start(ap, fmt);
#line 205
  zwarning(cmd, fmt, ap);
#line 206
  __builtin_va_end(ap);
  }
#line 207
  return;
}
}
#line 210 "/tmp/zsh-5.4.2/Src/utils.c"
void zwarn(char const   *fmt  , ...) 
{ 
  va_list___0 ap ;

  {
#line 217
  if (errflag) {
#line 218
    return;
  } else
#line 217
  if (noerrs) {
#line 218
    return;
  }
  {
#line 220
  __builtin_va_start(ap, fmt);
#line 222
  zwarning((char const   *)((void *)0), fmt, ap);
#line 223
  __builtin_va_end(ap);
  }
#line 224
  return;
}
}
#line 227 "/tmp/zsh-5.4.2/Src/utils.c"
void zwarnnam(char const   *cmd , char const   *fmt  , ...) 
{ 
  va_list___0 ap ;

  {
#line 235
  if (errflag) {
#line 236
    return;
  } else
#line 235
  if (noerrs) {
#line 236
    return;
  }
  {
#line 238
  __builtin_va_start(ap, fmt);
#line 241
  zwarning(cmd, fmt, ap);
#line 242
  __builtin_va_end(ap);
  }
#line 243
  return;
}
}
#line 285 "/tmp/zsh-5.4.2/Src/utils.c"
void zerrmsg(FILE *file , char const   *fmt , va_list___0 ap ) 
{ 
  char const   *str ;
  int num ;
  char *errmsg ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *s ;
  char const   *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 300
  if (! opts[160]) {
#line 300
    goto _L;
  } else
#line 300
  if (locallevel) {
    _L: /* CIL Label */ 
#line 300
    if (lineno) {
      {
#line 304
      fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%ld: ",
              lineno);
      }
    } else {
      {
#line 307
      fputc((int )((unsigned char )' '), file);
      }
    }
  } else {
    {
#line 307
    fputc((int )((unsigned char )' '), file);
    }
  }
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! *fmt) {
#line 309
      goto while_break;
    }
#line 310
    if ((int const   )*fmt == 37) {
#line 311
      fmt ++;
#line 312
      tmp = fmt;
#line 312
      fmt ++;
      {
#line 313
      if ((int const   )*tmp == 115) {
#line 313
        goto case_115;
      }
#line 317
      if ((int const   )*tmp == 108) {
#line 317
        goto case_108;
      }
#line 334
      if ((int const   )*tmp == 100) {
#line 334
        goto case_100;
      }
#line 338
      if ((int const   )*tmp == 37) {
#line 338
        goto case_37;
      }
#line 341
      if ((int const   )*tmp == 99) {
#line 341
        goto case_99;
      }
#line 350
      if ((int const   )*tmp == 101) {
#line 350
        goto case_101;
      }
#line 312
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 314
      tmp___0 = __builtin_va_arg(ap, char const   *);
#line 314
      str = tmp___0;
#line 315
      mb_niceformat(str, file, (char **)((void *)0), 0);
      }
#line 316
      goto switch_break;
      case_108: /* CIL Label */ 
      {
#line 319
      tmp___1 = __builtin_va_arg(ap, char const   *);
#line 319
      str = tmp___1;
#line 320
      tmp___2 = __builtin_va_arg(ap, int );
#line 320
      num = tmp___2;
#line 321
      num = metalen(str, num);
#line 322
      tmp___3 = zhalloc((size_t )(num + 1));
#line 322
      s = (char *)tmp___3;
#line 323
      memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)str, (size_t )num);
#line 324
      *(s + num) = (char )'\000';
#line 325
      mb_niceformat((char const   *)s, file, (char **)((void *)0), 0);
      }
#line 326
      goto switch_break;
      case_100: /* CIL Label */ 
      {
#line 335
      tmp___4 = __builtin_va_arg(ap, int );
#line 335
      num = tmp___4;
#line 336
      fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d",
              num);
      }
#line 337
      goto switch_break;
      case_37: /* CIL Label */ 
      {
#line 339
      _IO_putc('%', file);
      }
#line 340
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 342
      tmp___5 = __builtin_va_arg(ap, int );
#line 342
      num = tmp___5;
#line 344
      mb_charinit();
#line 345
      tmp___6 = wcs_nicechar(num, (size_t *)((void *)0), (char **)((void *)0));
#line 345
      zputs((char const   *)tmp___6, file);
      }
#line 349
      goto switch_break;
      case_101: /* CIL Label */ 
      {
#line 352
      tmp___7 = __builtin_va_arg(ap, int );
#line 352
      num = tmp___7;
      }
#line 353
      if (num == 4) {
        {
#line 354
        fputs((char const   */* __restrict  */)"interrupt\n", (FILE */* __restrict  */)file);
#line 355
        errflag |= 1;
        }
#line 356
        return;
      }
      {
#line 358
      errmsg = strerror(num);
      }
#line 361
      if (num == 5) {
        {
#line 362
        fputs((char const   */* __restrict  */)errmsg, (FILE */* __restrict  */)file);
        }
      } else {
        {
#line 364
        tmp___8 = tulower((int )*(errmsg + 0));
#line 364
        fputc(tmp___8, file);
#line 365
        fputs((char const   */* __restrict  */)(errmsg + 1), (FILE */* __restrict  */)file);
        }
      }
#line 367
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 371
      if ((int const   )*fmt == -125) {
#line 371
        fmt ++;
#line 371
        tmp___9 = (int const   )*fmt ^ 32;
      } else {
#line 371
        tmp___9 = (int const   )*fmt;
      }
      {
#line 371
      _IO_putc((int )tmp___9, file);
#line 372
      fmt ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  _IO_putc('\n', file);
#line 375
  fflush(file);
  }
#line 376
  return;
}
}
#line 382 "/tmp/zsh-5.4.2/Src/utils.c"
int putraw(int c ) 
{ 


  {
  {
#line 385
  _IO_putc(c, stdout);
  }
#line 386
  return (0);
}
}
#line 392 "/tmp/zsh-5.4.2/Src/utils.c"
int putshout(int c ) 
{ 


  {
  {
#line 395
  _IO_putc(c, shout);
  }
#line 396
  return (0);
}
}
#line 424 "/tmp/zsh-5.4.2/Src/utils.c"
static char buf[10]  ;
#line 421 "/tmp/zsh-5.4.2/Src/utils.c"
char *nicechar_sel(int c , int quotable ) 
{ 
  char *s ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
  {
#line 425
  s = buf;
#line 426
  c &= 255;
#line 427
  tmp = __ctype_b_loc();
  }
#line 427
  if ((int const   )*(*tmp + c) & 16384) {
#line 428
    goto done;
  }
#line 429
  if (c & 128) {
#line 430
    if (opts[137]) {
#line 431
      goto done;
    }
    {
#line 432
    tmp___0 = s;
#line 432
    s ++;
#line 432
    *tmp___0 = (char )'\\';
#line 433
    tmp___1 = s;
#line 433
    s ++;
#line 433
    *tmp___1 = (char )'M';
#line 434
    tmp___2 = s;
#line 434
    s ++;
#line 434
    *tmp___2 = (char )'-';
#line 435
    c &= 127;
#line 436
    tmp___3 = __ctype_b_loc();
    }
#line 436
    if ((int const   )*(*tmp___3 + c) & 16384) {
#line 437
      goto done;
    }
  }
#line 439
  if (c == 127) {
#line 440
    if (quotable) {
#line 441
      tmp___4 = s;
#line 441
      s ++;
#line 441
      *tmp___4 = (char )'\\';
#line 442
      tmp___5 = s;
#line 442
      s ++;
#line 442
      *tmp___5 = (char )'C';
#line 443
      tmp___6 = s;
#line 443
      s ++;
#line 443
      *tmp___6 = (char )'-';
    } else {
#line 445
      tmp___7 = s;
#line 445
      s ++;
#line 445
      *tmp___7 = (char )'^';
    }
#line 446
    c = '?';
  } else
#line 447
  if (c == 10) {
#line 448
    tmp___8 = s;
#line 448
    s ++;
#line 448
    *tmp___8 = (char )'\\';
#line 449
    c = 'n';
  } else
#line 450
  if (c == 9) {
#line 451
    tmp___9 = s;
#line 451
    s ++;
#line 451
    *tmp___9 = (char )'\\';
#line 452
    c = 't';
  } else
#line 453
  if (c < 32) {
#line 454
    if (quotable) {
#line 455
      tmp___10 = s;
#line 455
      s ++;
#line 455
      *tmp___10 = (char )'\\';
#line 456
      tmp___11 = s;
#line 456
      s ++;
#line 456
      *tmp___11 = (char )'C';
#line 457
      tmp___12 = s;
#line 457
      s ++;
#line 457
      *tmp___12 = (char )'-';
    } else {
#line 459
      tmp___13 = s;
#line 459
      s ++;
#line 459
      *tmp___13 = (char )'^';
    }
#line 460
    c += 64;
  }
  done: 
#line 469
  if ((int )typtab[(unsigned char )c] & (1 << 12)) {
#line 470
    tmp___14 = s;
#line 470
    s ++;
#line 470
    *tmp___14 = (char)-125;
#line 471
    tmp___15 = s;
#line 471
    s ++;
#line 471
    *tmp___15 = (char )(c ^ 32);
  } else {
#line 473
    tmp___16 = s;
#line 473
    s ++;
#line 473
    *tmp___16 = (char )c;
  }
#line 474
  *s = (char)0;
#line 475
  return (buf);
}
}
#line 479 "/tmp/zsh-5.4.2/Src/utils.c"
char *nicechar(int c ) 
{ 
  char *tmp ;

  {
  {
#line 482
  tmp = nicechar_sel(c, 0);
  }
#line 482
  return (tmp);
}
}
#line 546 "/tmp/zsh-5.4.2/Src/utils.c"
int is_nicechar(int c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
#line 549
  c &= 255;
#line 550
  tmp = __ctype_b_loc();
  }
#line 550
  if ((int const   )*(*tmp + c) & 16384) {
#line 551
    return (0);
  }
#line 552
  if (c & 128) {
#line 553
    return (! opts[137]);
  }
#line 554
  if (c == 127) {
#line 554
    tmp___0 = 1;
  } else
#line 554
  if (c == 10) {
#line 554
    tmp___0 = 1;
  } else
#line 554
  if (c == 9) {
#line 554
    tmp___0 = 1;
  } else
#line 554
  if (c < 32) {
#line 554
    tmp___0 = 1;
  } else {
#line 554
    tmp___0 = 0;
  }
#line 554
  return (tmp___0);
}
}
#line 559 "/tmp/zsh-5.4.2/Src/utils.c"
static mbstate_t mb_shiftstate  ;
#line 568 "/tmp/zsh-5.4.2/Src/utils.c"
void mb_charinit(void) 
{ 


  {
  {
#line 571
  memset((void *)(& mb_shiftstate), 0, sizeof(mb_shiftstate));
  }
#line 572
  return;
}
}
#line 611 "/tmp/zsh-5.4.2/Src/utils.c"
static char *buf___0  ;
#line 612 "/tmp/zsh-5.4.2/Src/utils.c"
static int bufalloc  =    0;
#line 612 "/tmp/zsh-5.4.2/Src/utils.c"
static int newalloc  ;
#line 608 "/tmp/zsh-5.4.2/Src/utils.c"
char *wcs_nicechar_sel(wchar_t c , size_t *widthp , char **swidep , int quotable ) 
{ 
  char *s ;
  char *mbptr ;
  int ret ;
  char *mbstr ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int wcw ;
  int tmp___18 ;
  char *tmp___19 ;

  {
  {
#line 614
  ret = 0;
#line 615
  tmp = __ctype_get_mb_cur_max();
#line 615
  tmp___0 = zhalloc(sizeof(char ) * tmp);
#line 615
  mbstr = (char *)tmp___0;
#line 624
  tmp___1 = __ctype_get_mb_cur_max();
#line 624
  newalloc = (int )(12UL + 2UL * tmp___1);
  }
#line 625
  if (bufalloc != newalloc) {
    {
#line 627
    bufalloc = newalloc;
#line 628
    tmp___2 = zrealloc((void *)buf___0, (size_t )bufalloc);
#line 628
    buf___0 = (char *)tmp___2;
    }
  }
  {
#line 631
  s = buf___0;
#line 632
  tmp___13 = iswprint((wint_t )c);
  }
#line 632
  if (! tmp___13) {
#line 632
    if (c < 128) {
#line 632
      goto _L;
    } else
#line 632
    if (! opts[137]) {
      _L: /* CIL Label */ 
#line 633
      if (c == 127) {
#line 634
        if (quotable) {
#line 635
          tmp___3 = s;
#line 635
          s ++;
#line 635
          *tmp___3 = (char )'\\';
#line 636
          tmp___4 = s;
#line 636
          s ++;
#line 636
          *tmp___4 = (char )'C';
#line 637
          tmp___5 = s;
#line 637
          s ++;
#line 637
          *tmp___5 = (char )'-';
        } else {
#line 639
          tmp___6 = s;
#line 639
          s ++;
#line 639
          *tmp___6 = (char )'^';
        }
#line 640
        c = '?';
      } else
#line 641
      if (c == 10) {
#line 642
        tmp___7 = s;
#line 642
        s ++;
#line 642
        *tmp___7 = (char )'\\';
#line 643
        c = 'n';
      } else
#line 644
      if (c == 9) {
#line 645
        tmp___8 = s;
#line 645
        s ++;
#line 645
        *tmp___8 = (char )'\\';
#line 646
        c = 't';
      } else
#line 647
      if (c < 32) {
#line 648
        if (quotable) {
#line 649
          tmp___9 = s;
#line 649
          s ++;
#line 649
          *tmp___9 = (char )'\\';
#line 650
          tmp___10 = s;
#line 650
          s ++;
#line 650
          *tmp___10 = (char )'C';
#line 651
          tmp___11 = s;
#line 651
          s ++;
#line 651
          *tmp___11 = (char )'-';
        } else {
#line 653
          tmp___12 = s;
#line 653
          s ++;
#line 653
          *tmp___12 = (char )'^';
        }
#line 654
        c += 64;
      } else
#line 655
      if (c >= 128) {
#line 656
        ret = -1;
      }
    }
  }
#line 660
  if (ret != -1) {
    {
#line 661
    tmp___14 = wcrtomb((char */* __restrict  */)mbstr, c, (mbstate_t */* __restrict  */)(& mb_shiftstate));
#line 661
    ret = (int )tmp___14;
    }
  }
#line 663
  if (ret == -1) {
    {
#line 664
    memset((void *)(& mb_shiftstate), 0, sizeof(mb_shiftstate));
    }
#line 672
    if (c >= 65536) {
      {
#line 673
      sprintf((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"\\U%.8x",
              (unsigned int )c);
      }
#line 674
      if (widthp) {
#line 675
        *widthp = (size_t )10;
      }
    } else
#line 676
    if (c >= 256) {
      {
#line 677
      sprintf((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"\\u%.4x",
              (unsigned int )c);
      }
#line 678
      if (widthp) {
#line 679
        *widthp = (size_t )6;
      }
    } else {
      {
#line 681
      tmp___15 = nicechar(c);
#line 681
      strcpy((char */* __restrict  */)buf___0, (char const   */* __restrict  */)tmp___15);
      }
#line 686
      if (widthp) {
        {
#line 687
        tmp___16 = ztrlen((char const   *)buf___0);
#line 687
        *widthp = (size_t )tmp___16;
        }
      }
#line 688
      if (swidep) {
        {
#line 689
        tmp___17 = strlen((char const   *)buf___0);
#line 689
        *swidep = buf___0 + tmp___17;
        }
      }
#line 690
      return (buf___0);
    }
#line 692
    if (swidep) {
#line 693
      if (widthp) {
#line 693
        *swidep = buf___0 + *widthp;
      } else {
#line 693
        *swidep = buf___0;
      }
    }
#line 694
    return (buf___0);
  }
#line 697
  if (widthp) {
    {
#line 698
    tmp___18 = wcwidth(c);
#line 698
    wcw = tmp___18;
#line 699
    *widthp = (size_t )(s - buf___0);
    }
#line 700
    if (wcw >= 0) {
#line 701
      *widthp += (size_t )wcw;
    } else {
#line 703
      (*widthp) ++;
    }
  }
#line 705
  if (swidep) {
#line 706
    *swidep = s;
  }
#line 707
  mbptr = mbstr;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (! ret) {
#line 707
      goto while_break;
    }
#line 710
    if ((int )typtab[(unsigned char )*mbptr] & (1 << 12)) {
#line 711
      tmp___19 = s;
#line 711
      s ++;
#line 711
      *tmp___19 = (char)-125;
#line 714
      *s = (char )((int )*mbptr ^ 32);
    } else {
#line 716
      *s = *mbptr;
    }
#line 707
    s ++;
#line 707
    mbptr ++;
#line 707
    ret --;
  }
  while_break: /* CIL Label */ ;
  }
#line 719
  *s = (char)0;
#line 720
  return (buf___0);
}
}
#line 724 "/tmp/zsh-5.4.2/Src/utils.c"
char *wcs_nicechar(wchar_t c , size_t *widthp , char **swidep ) 
{ 
  char *tmp ;

  {
  {
#line 727
  tmp = wcs_nicechar_sel(c, widthp, swidep, 0);
  }
#line 727
  return (tmp);
}
}
#line 735 "/tmp/zsh-5.4.2/Src/utils.c"
int is_wcs_nicechar(wchar_t c ) 
{ 
  int tmp ;

  {
  {
#line 737
  tmp = iswprint((wint_t )c);
  }
#line 737
  if (! tmp) {
#line 737
    if (c < 128) {
#line 737
      goto _L;
    } else
#line 737
    if (! opts[137]) {
      _L: /* CIL Label */ 
#line 738
      if (c == 127) {
#line 739
        return (1);
      } else
#line 738
      if (c == 10) {
#line 739
        return (1);
      } else
#line 738
      if (c == 9) {
#line 739
        return (1);
      } else
#line 738
      if (c < 32) {
#line 739
        return (1);
      }
#line 740
      if (c >= 128) {
#line 741
        return (c >= 256);
      }
    }
  }
#line 744
  return (0);
}
}
#line 748 "/tmp/zsh-5.4.2/Src/utils.c"
int zwcwidth(wint_t wc ) 
{ 
  int wcw ;

  {
#line 753
  if (wc == 4294967295U) {
#line 754
    return (1);
  } else
#line 753
  if (! opts[117]) {
#line 754
    return (1);
  }
  {
#line 755
  wcw = wcwidth((wchar_t )wc);
  }
#line 757
  if (wcw < 0) {
#line 758
    return (1);
  }
#line 759
  return (wcw);
}
}
#line 775 "/tmp/zsh-5.4.2/Src/utils.c"
char *pathprog(char *prog , char **namep ) 
{ 
  char **pp ;
  char ppmaxlen ;
  char *buf___7 ;
  char *funmeta ;
  struct stat st___0 ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 778
  ppmaxlen = (char)0;
#line 781
  pp = path;
  {
#line 781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 781
    if (! *pp) {
#line 781
      goto while_break;
    }
    {
#line 783
    tmp = strlen((char const   *)*pp);
#line 783
    len = (int )tmp;
    }
#line 784
    if (len > (int )ppmaxlen) {
#line 785
      ppmaxlen = (char )len;
    }
#line 781
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 787
  tmp___0 = strlen((char const   *)prog);
#line 787
  tmp___1 = zhalloc(((size_t )ppmaxlen + tmp___0) + 2UL);
#line 787
  buf___7 = (char *)tmp___1;
#line 788
  pp = path;
  }
  {
#line 788
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 788
    if (! *pp) {
#line 788
      goto while_break___0;
    }
    {
#line 789
    sprintf((char */* __restrict  */)buf___7, (char const   */* __restrict  */)"%s/%s",
            *pp, prog);
#line 790
    funmeta = unmeta((char const   *)buf___7);
#line 791
    tmp___2 = access((char const   *)funmeta, 0);
    }
#line 791
    if (tmp___2 == 0) {
      {
#line 791
      tmp___3 = stat((char const   */* __restrict  */)funmeta, (struct stat */* __restrict  */)(& st___0));
      }
#line 791
      if (tmp___3 >= 0) {
#line 791
        if (! ((st___0.st_mode & 61440U) == 16384U)) {
#line 794
          if (namep) {
#line 795
            *namep = buf___7;
          }
#line 796
          return (funmeta);
        }
      }
    }
#line 788
    pp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 800
  return ((char *)((void *)0));
}
}
#line 806 "/tmp/zsh-5.4.2/Src/utils.c"
char *findpwd(char *s ) 
{ 
  char *t ;
  char *tmp ;
  char const   *tmp___0 ;

  {
#line 811
  if ((int )*s == 47) {
    {
#line 812
    tmp = xsymlink(s, 0);
    }
#line 812
    return (tmp);
  }
#line 813
  if (*(pwd + 1)) {
#line 813
    tmp___0 = (char const   *)pwd;
  } else {
#line 813
    tmp___0 = "";
  }
  {
#line 813
  s = tricat(tmp___0, "/", (char const   *)s);
#line 814
  t = xsymlink(s, 0);
#line 815
  zsfree(s);
  }
#line 816
  return (t);
}
}
#line 823 "/tmp/zsh-5.4.2/Src/utils.c"
int ispwd(char *s ) 
{ 
  struct stat sbuf ;
  struct stat tbuf___0 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 829
  if ((int )*s != 47) {
#line 830
    return (0);
  }
  {
#line 832
  s = unmeta((char const   *)s);
#line 832
  tmp___0 = stat((char const   */* __restrict  */)s, (struct stat */* __restrict  */)(& sbuf));
  }
#line 832
  if (tmp___0 == 0) {
    {
#line 832
    tmp___1 = stat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& tbuf___0));
    }
#line 832
    if (tmp___1 == 0) {
#line 833
      if (sbuf.st_dev == tbuf___0.st_dev) {
#line 833
        if (sbuf.st_ino == tbuf___0.st_ino) {
          {
#line 835
          while (1) {
            while_continue: /* CIL Label */ ;
#line 835
            if (! *s) {
#line 835
              goto while_break;
            }
#line 836
            if ((int )*(s + 0) == 46) {
#line 836
              if (! *(s + 1)) {
#line 839
                goto while_break;
              } else
#line 836
              if ((int )*(s + 1) == 47) {
#line 839
                goto while_break;
              } else
#line 836
              if ((int )*(s + 1) == 46) {
#line 836
                if (! *(s + 2)) {
#line 839
                  goto while_break;
                } else
#line 836
                if ((int )*(s + 2) == 47) {
#line 839
                  goto while_break;
                }
              }
            }
            {
#line 840
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 840
              tmp = s;
#line 840
              s ++;
#line 840
              if ((int )*tmp != 47) {
#line 840
                if (! *s) {
#line 840
                  goto while_break___0;
                }
              } else {
#line 840
                goto while_break___0;
              }
#line 841
              goto while_continue___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 843
          return (! *s);
        }
      }
    }
  }
#line 845
  return (0);
}
}
#line 848 "/tmp/zsh-5.4.2/Src/utils.c"
static char xbuf[8193]  ;
#line 851 "/tmp/zsh-5.4.2/Src/utils.c"
static char **slashsplit(char *s ) 
{ 
  char *t ;
  char **r ;
  char **q ;
  int t0 ;
  void *tmp ;
  void *tmp___0 ;
  char **tmp___1 ;
  char **tmp___2 ;

  {
#line 857
  if (! *s) {
    {
#line 858
    tmp = zshcalloc(sizeof(char *));
    }
#line 858
    return ((char **)tmp);
  }
#line 860
  t = s;
#line 860
  t0 = 0;
  {
#line 860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 860
    if (! *t) {
#line 860
      goto while_break;
    }
#line 861
    if ((int )*t == 47) {
#line 862
      t0 ++;
    }
#line 860
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 863
  tmp___0 = zalloc(sizeof(char *) * (unsigned long )(t0 + 2));
#line 863
  r = (char **)tmp___0;
#line 863
  q = r;
  }
  {
#line 865
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 865
    t = strchr((char const   *)s, '/');
    }
#line 865
    if (! t) {
#line 865
      goto while_break___0;
    }
    {
#line 866
    tmp___1 = q;
#line 866
    q ++;
#line 866
    *tmp___1 = ztrduppfx((char const   *)s, (int )(t - s));
    }
    {
#line 867
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 867
      if (! ((int )*t == 47)) {
#line 867
        goto while_break___1;
      }
#line 868
      t ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 869
    if (! *t) {
#line 870
      *q = (char *)((void *)0);
#line 871
      return (r);
    }
#line 873
    s = t;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 875
  tmp___2 = q;
#line 875
  q ++;
#line 875
  *tmp___2 = ztrdup((char const   *)s);
#line 876
  *q = (char *)((void *)0);
  }
#line 877
  return (r);
}
}
#line 883 "/tmp/zsh-5.4.2/Src/utils.c"
static int xsymlinks(char *s , int full ) 
{ 
  char **pp ;
  char **opp ;
  char xbuf2[12289] ;
  char xbuf3[8193] ;
  int t0 ;
  int ret ;
  zulong xbuflen ;
  size_t tmp ;
  zulong pplen ;
  int tmp___0 ;
  char *p ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  zulong len ;
  size_t tmp___6 ;
  zulong newlen ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 888
  ret = 0;
#line 889
  tmp = strlen((char const   *)(xbuf));
#line 889
  xbuflen = tmp;
#line 891
  pp = slashsplit(s);
#line 891
  opp = pp;
  }
  {
#line 892
  while (1) {
    while_continue: /* CIL Label */ ;
#line 892
    if (xbuflen < sizeof(xbuf)) {
#line 892
      if (*pp) {
#line 892
        if (! (ret >= 0)) {
#line 892
          goto while_break;
        }
      } else {
#line 892
        goto while_break;
      }
    } else {
#line 892
      goto while_break;
    }
    {
#line 893
    tmp___0 = strcmp((char const   *)*pp, ".");
    }
#line 893
    if (! tmp___0) {
#line 894
      goto __Cont;
    }
    {
#line 895
    tmp___2 = strcmp((char const   *)*pp, "..");
    }
#line 895
    if (! tmp___2) {
      {
#line 898
      tmp___1 = strcmp((char const   *)(xbuf), "/");
      }
#line 898
      if (! tmp___1) {
#line 899
        goto __Cont;
      }
#line 900
      if (! xbuf[0]) {
#line 901
        goto __Cont;
      }
#line 902
      p = xbuf + xbuflen;
      {
#line 903
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 903
        p --;
#line 903
        if (! ((int )*p != 47)) {
#line 903
          goto while_break___0;
        }
#line 904
        xbuflen --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 905
      *p = (char )'\000';
#line 907
      xbuflen --;
#line 908
      goto __Cont;
    }
    {
#line 911
    tmp___3 = strlen((char const   *)*pp);
#line 911
    pplen = tmp___3 + 1UL;
    }
#line 912
    if ((xbuflen + pplen) + 1UL > sizeof(xbuf2)) {
#line 913
      xbuf[0] = (char)0;
#line 914
      ret = -1;
#line 915
      goto while_break;
    }
    {
#line 917
    memcpy((void */* __restrict  */)(xbuf2), (void const   */* __restrict  */)(xbuf),
           xbuflen);
#line 918
    xbuf2[xbuflen] = (char )'/';
#line 919
    memcpy((void */* __restrict  */)((xbuf2 + xbuflen) + 1), (void const   */* __restrict  */)*pp,
           pplen);
#line 920
    tmp___4 = unmeta((char const   *)(xbuf2));
#line 920
    tmp___5 = readlink((char const   */* __restrict  */)tmp___4, (char */* __restrict  */)(xbuf3),
                       (size_t )4096);
#line 920
    t0 = (int )tmp___5;
    }
#line 921
    if (t0 == -1) {
#line 922
      xbuflen += pplen;
#line 922
      if (xbuflen < sizeof(xbuf)) {
        {
#line 923
        strcat((char */* __restrict  */)(xbuf), (char const   */* __restrict  */)"/");
#line 924
        strcat((char */* __restrict  */)(xbuf), (char const   */* __restrict  */)*pp);
        }
      } else {
#line 926
        xbuf[0] = (char)0;
#line 927
        ret = -1;
#line 928
        goto while_break;
      }
    } else {
      {
#line 931
      ret = 1;
#line 932
      metafy(xbuf3, t0, 5);
      }
#line 933
      if (! full) {
#line 938
        len = xbuflen;
#line 939
        if ((int )xbuf3[0] == 47) {
          {
#line 940
          strcpy((char */* __restrict  */)(xbuf), (char const   */* __restrict  */)(xbuf3));
          }
        } else {
          {
#line 941
          tmp___6 = strlen((char const   *)(xbuf3));
#line 941
          len += tmp___6 + 1UL;
          }
#line 941
          if (len < sizeof(xbuf)) {
            {
#line 942
            strcpy((char */* __restrict  */)(xbuf + xbuflen), (char const   */* __restrict  */)"/");
#line 943
            strcpy((char */* __restrict  */)((xbuf + xbuflen) + 1), (char const   */* __restrict  */)(xbuf3));
            }
          } else {
#line 945
            xbuf[0] = (char)0;
#line 946
            ret = -1;
#line 947
            goto while_break;
          }
        }
        {
#line 950
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 950
          pp ++;
#line 950
          if (! *pp) {
#line 950
            goto while_break___1;
          }
          {
#line 951
          tmp___7 = strlen((char const   *)*pp);
#line 951
          newlen = (len + tmp___7) + 1UL;
          }
#line 952
          if (newlen < sizeof(xbuf)) {
            {
#line 953
            strcpy((char */* __restrict  */)(xbuf + len), (char const   */* __restrict  */)"/");
#line 954
            strcpy((char */* __restrict  */)((xbuf + len) + 1), (char const   */* __restrict  */)*pp);
#line 955
            len = newlen;
            }
          } else {
#line 957
            xbuf[0] = (char)1;
#line 958
            ret = -1;
#line 959
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 966
        goto while_break;
      }
#line 968
      if ((int )xbuf3[0] == 47) {
        {
#line 969
        strcpy((char */* __restrict  */)(xbuf), (char const   */* __restrict  */)"");
#line 970
        tmp___8 = xsymlinks(xbuf3 + 1, 1);
        }
#line 970
        if (tmp___8 < 0) {
#line 971
          ret = -1;
        } else {
          {
#line 973
          xbuflen = strlen((char const   *)(xbuf));
          }
        }
      } else {
        {
#line 975
        tmp___9 = xsymlinks(xbuf3, 1);
        }
#line 975
        if (tmp___9 < 0) {
#line 976
          ret = -1;
        } else {
          {
#line 978
          xbuflen = strlen((char const   *)(xbuf));
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 892
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 981
  freearray(opp);
  }
#line 982
  return (ret);
}
}
#line 993 "/tmp/zsh-5.4.2/Src/utils.c"
char *xsymlink(char *s , int heap ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 996
  if ((int )*s != 47) {
#line 997
    return ((char *)((void *)0));
  }
  {
#line 998
  xbuf[0] = (char )'\000';
#line 999
  tmp = xsymlinks(s + 1, 1);
  }
#line 999
  if (tmp < 0) {
    {
#line 1000
    zwarn("path expansion failed, using root directory");
    }
  }
#line 1001
  if (! xbuf[0]) {
#line 1002
    if (heap) {
      {
#line 1002
      tmp___0 = dupstring("/");
#line 1002
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 1002
      tmp___1 = ztrdup("/");
#line 1002
      tmp___2 = tmp___1;
      }
    }
#line 1002
    return (tmp___2);
  }
#line 1003
  if (heap) {
    {
#line 1003
    tmp___3 = dupstring((char const   *)(xbuf));
#line 1003
    tmp___5 = tmp___3;
    }
  } else {
    {
#line 1003
    tmp___4 = ztrdup((char const   *)(xbuf));
#line 1003
    tmp___5 = tmp___4;
    }
  }
#line 1003
  return (tmp___5);
}
}
#line 1007 "/tmp/zsh-5.4.2/Src/utils.c"
void print_if_link(char *s , int all ) 
{ 
  char *start ;
  char xbuflink[4097] ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1010
  if ((int )*s == 47) {
#line 1011
    xbuf[0] = (char )'\000';
#line 1012
    if (all) {
#line 1013
      start = s + 1;
      {
#line 1015
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1016
        tmp___0 = xsymlinks(start, 0);
        }
#line 1016
        if (tmp___0 > 0) {
          {
#line 1017
          printf((char const   */* __restrict  */)" -> ");
          }
#line 1018
          if (xbuf[0]) {
#line 1018
            tmp = (char const   *)(xbuf);
          } else {
#line 1018
            tmp = "/";
          }
          {
#line 1018
          zputs(tmp, stdout);
          }
#line 1019
          if (! xbuf[0]) {
#line 1020
            goto while_break;
          }
          {
#line 1021
          strcpy((char */* __restrict  */)(xbuflink), (char const   */* __restrict  */)(xbuf));
#line 1022
          start = xbuflink + 1;
#line 1023
          xbuf[0] = (char )'\000';
          }
        } else {
#line 1025
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1029
      tmp___2 = xsymlinks(s + 1, 1);
      }
#line 1029
      if (tmp___2 > 0) {
        {
#line 1030
        printf((char const   */* __restrict  */)" -> ");
        }
#line 1030
        if (xbuf[0]) {
#line 1030
          tmp___1 = (char const   *)(xbuf);
        } else {
#line 1030
          tmp___1 = "/";
        }
        {
#line 1030
        zputs(tmp___1, stdout);
        }
      }
    }
  }
#line 1033
  return;
}
}
#line 1038 "/tmp/zsh-5.4.2/Src/utils.c"
void fprintdir(char *s , FILE *f ) 
{ 
  Nameddir d___0 ;
  Nameddir tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1041
  tmp = finddir(s);
#line 1041
  d___0 = tmp;
  }
#line 1043
  if (! d___0) {
    {
#line 1044
    tmp___0 = unmeta((char const   *)s);
#line 1044
    fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)f);
    }
  } else {
    {
#line 1046
    _IO_putc('~', f);
#line 1047
    tmp___1 = unmeta((char const   *)d___0->node.nam);
#line 1047
    fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)f);
#line 1048
    tmp___2 = strlen((char const   *)d___0->dir);
#line 1048
    tmp___3 = unmeta((char const   *)(s + tmp___2));
#line 1048
    fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)f);
    }
  }
#line 1050
  return;
}
}
#line 1060 "/tmp/zsh-5.4.2/Src/utils.c"
char *substnamedir(char *s ) 
{ 
  Nameddir d___0 ;
  Nameddir tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1063
  tmp = finddir(s);
#line 1063
  d___0 = tmp;
  }
#line 1065
  if (! d___0) {
    {
#line 1066
    tmp___0 = quotestring((char const   *)s, 1);
    }
#line 1066
    return (tmp___0);
  }
  {
#line 1067
  tmp___1 = strlen((char const   *)d___0->dir);
#line 1067
  tmp___2 = quotestring((char const   *)(s + tmp___1), 1);
#line 1067
  tmp___3 = zhtricat("~", (char const   *)d___0->node.nam, (char const   *)tmp___2);
  }
#line 1067
  return (tmp___3);
}
}
#line 1082 "/tmp/zsh-5.4.2/Src/utils.c"
char *get_username(void) 
{ 
  struct passwd *pswd ;
  uid_t current_uid ;

  {
  {
#line 1089
  current_uid = getuid();
  }
#line 1090
  if (current_uid != cached_uid) {
    {
#line 1091
    cached_uid = current_uid;
#line 1092
    zsfree(cached_username);
#line 1093
    pswd = getpwuid(current_uid);
    }
#line 1093
    if (pswd) {
      {
#line 1094
      cached_username = ztrdup((char const   *)pswd->pw_name);
      }
    } else {
      {
#line 1096
      cached_username = ztrdup("");
      }
    }
  }
#line 1101
  return (cached_username);
}
}
#line 1106 "/tmp/zsh-5.4.2/Src/utils.c"
static char *finddir_full  ;
#line 1107 "/tmp/zsh-5.4.2/Src/utils.c"
static Nameddir finddir_last  ;
#line 1108 "/tmp/zsh-5.4.2/Src/utils.c"
static int finddir_best  ;
#line 1113 "/tmp/zsh-5.4.2/Src/utils.c"
static void finddir_scan(HashNode hn , int flags  __attribute__((__unused__)) ) 
{ 
  Nameddir nd ;
  int tmp ;

  {
#line 1116
  nd = (Nameddir )hn;
#line 1118
  if (nd->diff > finddir_best) {
    {
#line 1118
    tmp = dircmp(nd->dir, finddir_full);
    }
#line 1118
    if (! tmp) {
#line 1118
      if (! (nd->node.flags & (1 << 2))) {
#line 1120
        finddir_last = nd;
#line 1121
        finddir_best = nd->diff;
      }
    }
  }
#line 1123
  return;
}
}
#line 1137 "/tmp/zsh-5.4.2/Src/utils.c"
static struct nameddir homenode  =    {{(HashNode )((void *)0), (char *)"", 0}, (char *)((void *)0), 0};
#line 1138 "/tmp/zsh-5.4.2/Src/utils.c"
static int ffsz  ;
#line 1134 "/tmp/zsh-5.4.2/Src/utils.c"
Nameddir finddir(char *s ) 
{ 
  char **ares ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char tmp___7 ;
  zlong tmp___8 ;

  {
#line 1145
  if (! s) {
#line 1146
    if (home) {
#line 1146
      homenode.dir = home;
    } else {
#line 1146
      homenode.dir = (char *)"";
    }
#line 1147
    if (home) {
      {
#line 1147
      tmp = strlen((char const   *)home);
#line 1147
      homenode.diff = (int )tmp;
      }
    } else {
#line 1147
      homenode.diff = 0;
    }
#line 1148
    if (homenode.diff == 1) {
#line 1149
      homenode.diff = 0;
    }
#line 1150
    if (! finddir_full) {
      {
#line 1151
      ffsz = 4097;
#line 1151
      tmp___0 = zalloc((size_t )ffsz);
#line 1151
      finddir_full = (char *)tmp___0;
      }
    }
#line 1152
    *(finddir_full + 0) = (char)0;
#line 1153
    finddir_last = (Nameddir )((void *)0);
#line 1153
    return (finddir_last);
  }
  {
#line 1167
  tmp___3 = strlen((char const   *)s);
  }
#line 1167
  if ((int )tmp___3 >= ffsz) {
    {
#line 1168
    free((void *)finddir_full);
#line 1169
    tmp___1 = strlen((char const   *)s);
#line 1169
    ffsz = (int )(tmp___1 * 2UL);
#line 1169
    tmp___2 = zalloc((size_t )ffsz);
#line 1169
    finddir_full = (char *)tmp___2;
    }
  }
  {
#line 1171
  strcpy((char */* __restrict  */)finddir_full, (char const   */* __restrict  */)s);
#line 1172
  finddir_best = 0;
#line 1173
  finddir_last = (Nameddir )((void *)0);
#line 1174
  finddir_scan(& homenode.node, 0);
#line 1175
  scanhashtable(nameddirtab, 0, 0, 0, & finddir_scan, 0);
#line 1177
  ares = subst_string_by_hook((char *)"zsh_directory_name", (char *)"d", finddir_full);
  }
#line 1178
  if (ares) {
    {
#line 1178
    tmp___7 = arrlen_ge(ares, 2U);
    }
#line 1178
    if (tmp___7) {
      {
#line 1178
      tmp___8 = zstrtol((char const   *)*(ares + 1), (char **)((void *)0), 10);
#line 1178
      len = (int )tmp___8;
      }
#line 1178
      if (len > finddir_best) {
        {
#line 1181
        tmp___4 = hcalloc(sizeof(struct nameddir ));
#line 1181
        finddir_last = (Nameddir )tmp___4;
#line 1182
        tmp___5 = dupstring((char const   *)*(ares + 0));
#line 1182
        finddir_last->node.nam = zhtricat("[", (char const   *)tmp___5, "]");
#line 1183
        finddir_last->dir = dupstrpfx((char const   *)finddir_full, len);
#line 1184
        tmp___6 = strlen((char const   *)finddir_last->node.nam);
#line 1184
        finddir_last->diff = (int )((size_t )len - tmp___6);
#line 1185
        finddir_best = len;
        }
      }
    }
  }
#line 1188
  return (finddir_last);
}
}
#line 1194 "/tmp/zsh-5.4.2/Src/utils.c"
void adduserdir(char *s , char *t , int flags , int always ) 
{ 
  Nameddir nd ;
  char *eptr ;
  HashNode tmp ;
  HashNode tmp___0 ;
  HashNode hn ;
  HashNode tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 1201
  if (! opts[93]) {
#line 1202
    return;
  }
#line 1207
  if (flags & (1 << 1)) {
    {
#line 1207
    tmp = (*(nameddirtab->getnode2))(nameddirtab, (char const   *)s);
    }
#line 1207
    if (tmp) {
#line 1208
      return;
    }
  }
#line 1215
  if (! always) {
#line 1215
    if (! opts[11]) {
      {
#line 1215
      tmp___0 = (*(nameddirtab->getnode2))(nameddirtab, (char const   *)s);
      }
#line 1215
      if (! tmp___0) {
#line 1217
        return;
      }
    }
  }
#line 1219
  if (! t) {
#line 1219
    goto _L;
  } else
#line 1219
  if ((int )*t != 47) {
#line 1219
    goto _L;
  } else {
    {
#line 1219
    tmp___2 = strlen((char const   *)t);
    }
#line 1219
    if (tmp___2 >= 4096UL) {
      _L: /* CIL Label */ 
      {
#line 1222
      tmp___1 = (*(nameddirtab->removenode))(nameddirtab, (char const   *)s);
#line 1222
      hn = tmp___1;
      }
#line 1224
      if (hn) {
        {
#line 1225
        (*(nameddirtab->freenode))(hn);
        }
      }
#line 1226
      return;
    }
  }
  {
#line 1230
  tmp___3 = zshcalloc(sizeof(*nd));
#line 1230
  nd = (Nameddir )tmp___3;
#line 1231
  nd->node.flags = flags;
#line 1232
  tmp___4 = strlen((char const   *)t);
#line 1232
  eptr = t + tmp___4;
  }
  {
#line 1233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1233
    if ((unsigned long )eptr > (unsigned long )t) {
#line 1233
      if (! ((int )*(eptr + -1) == 47)) {
#line 1233
        goto while_break;
      }
    } else {
#line 1233
      goto while_break;
    }
#line 1234
    eptr --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  if ((unsigned long )eptr == (unsigned long )t) {
    {
#line 1241
    nd->dir = metafy(t, -1, 3);
    }
  } else {
    {
#line 1243
    nd->dir = metafy(t, (int )(eptr - t), 3);
    }
  }
  {
#line 1245
  tmp___5 = strcmp((char const   *)s, "PWD");
  }
#line 1245
  if (tmp___5) {
    {
#line 1245
    tmp___6 = strcmp((char const   *)s, "OLDPWD");
    }
#line 1245
    if (! tmp___6) {
#line 1246
      nd->node.flags |= 1 << 2;
    }
  } else {
#line 1246
    nd->node.flags |= 1 << 2;
  }
  {
#line 1247
  tmp___7 = metafy(s, -1, 3);
#line 1247
  (*(nameddirtab->addnode))(nameddirtab, tmp___7, (void *)nd);
  }
#line 1248
  return;
}
}
#line 1254 "/tmp/zsh-5.4.2/Src/utils.c"
char *getnameddir(char *name ) 
{ 
  Param pm ;
  char *str ;
  Nameddir nd ;
  char *tmp ;
  HashNode tmp___0 ;
  HashNode tmp___1 ;
  struct passwd *pw ;
  char *dir ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 1262
  tmp___0 = (*(nameddirtab->getnode))(nameddirtab, (char const   *)name);
#line 1262
  nd = (Nameddir )tmp___0;
  }
#line 1262
  if (nd) {
    {
#line 1263
    tmp = dupstring((char const   *)nd->dir);
    }
#line 1263
    return (tmp);
  }
  {
#line 1268
  tmp___1 = (*(paramtab->getnode))(paramtab, (char const   *)name);
#line 1268
  pm = (Param )tmp___1;
  }
#line 1268
  if (pm) {
#line 1268
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
      {
#line 1268
      str = getsparam(name);
      }
#line 1268
      if (str) {
#line 1268
        if ((int )*str == 47) {
          {
#line 1271
          pm->node.flags |= 1 << 30;
#line 1272
          adduserdir(name, str, 0, 1);
          }
#line 1273
          return (str);
        }
      }
    }
  }
  {
#line 1280
  pw = getpwnam((char const   *)name);
  }
#line 1280
  if (pw) {
#line 1281
    if (opts[31]) {
      {
#line 1281
      tmp___2 = xsymlink(pw->pw_dir, 0);
#line 1281
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 1281
      tmp___3 = ztrdup((char const   *)pw->pw_dir);
#line 1281
      tmp___4 = tmp___3;
      }
    }
#line 1281
    dir = tmp___4;
#line 1283
    if (dir) {
      {
#line 1284
      adduserdir(name, dir, 1 << 1, 1);
#line 1285
      str = dupstring((char const   *)dir);
#line 1286
      zsfree(dir);
      }
#line 1287
      return (str);
    } else {
      {
#line 1289
      tmp___5 = dupstring((char const   *)pw->pw_dir);
      }
#line 1289
      return (tmp___5);
    }
  }
#line 1295
  return ((char *)((void *)0));
}
}
#line 1303 "/tmp/zsh-5.4.2/Src/utils.c"
static int dircmp(char *s , char *t ) 
{ 


  {
#line 1306
  if (s) {
    {
#line 1307
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1307
      if (! ((int )*s == (int )*t)) {
#line 1307
        goto while_break;
      }
#line 1308
      if (! *s) {
#line 1309
        return (0);
      }
#line 1307
      s ++;
#line 1307
      t ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1310
    if (! *s) {
#line 1310
      if ((int )*t == 47) {
#line 1311
        return (0);
      }
    }
  }
#line 1313
  return (1);
}
}
#line 1321 "/tmp/zsh-5.4.2/Src/utils.c"
static LinkList prepromptfns  ;
#line 1326 "/tmp/zsh-5.4.2/Src/utils.c"
void addprepromptfn(void (*func)(void) ) 
{ 
  Prepromptfn ppdat ;
  void *tmp ;

  {
  {
#line 1329
  tmp = zalloc(sizeof(struct prepromptfn ));
#line 1329
  ppdat = (Prepromptfn )tmp;
#line 1330
  ppdat->func = func;
  }
#line 1331
  if (! prepromptfns) {
    {
#line 1332
    prepromptfns = znewlinklist();
    }
  }
  {
#line 1333
  zinsertlinknode(prepromptfns, prepromptfns->list.last, (void *)ppdat);
  }
#line 1334
  return;
}
}
#line 1339 "/tmp/zsh-5.4.2/Src/utils.c"
void delprepromptfn(void (*func)(void) ) 
{ 
  LinkNode ln ;
  Prepromptfn ppdat ;

  {
#line 1344
  ln = prepromptfns->list.first;
  {
#line 1344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1344
    if (! ln) {
#line 1344
      goto while_break;
    }
#line 1345
    ppdat = (Prepromptfn )ln->dat;
#line 1346
    if ((unsigned long )ppdat->func == (unsigned long )func) {
      {
#line 1347
      remnode(prepromptfns, ln);
#line 1348
      zfree((void *)ppdat, (int )sizeof(struct prepromptfn ));
      }
#line 1349
      return;
    }
#line 1344
    ln = ln->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1355
  return;
}
}
#line 1375 "/tmp/zsh-5.4.2/Src/utils.c"
void addtimedfn(void (*func)(void) , time_t when ) 
{ 
  Timedfn tfdat ;
  void *tmp ;
  LinkNode ln ;
  Timedfn tfdat2 ;
  LinkNode next___0 ;

  {
  {
#line 1378
  tmp = zalloc(sizeof(struct timedfn ));
#line 1378
  tfdat = (Timedfn )tmp;
#line 1379
  tfdat->func = func;
#line 1380
  tfdat->when = when;
  }
#line 1382
  if (! timedfns) {
    {
#line 1383
    timedfns = znewlinklist();
#line 1384
    zinsertlinknode(timedfns, timedfns->list.last, (void *)tfdat);
    }
  } else {
#line 1386
    ln = timedfns->list.first;
#line 1399
    if (! ln) {
      {
#line 1400
      zinsertlinknode(timedfns, timedfns->list.last, (void *)tfdat);
      }
#line 1401
      return;
    }
    {
#line 1403
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1405
      next___0 = ln->next;
#line 1406
      if (! next___0) {
        {
#line 1407
        zinsertlinknode(timedfns, timedfns->list.last, (void *)tfdat);
        }
#line 1408
        return;
      }
#line 1410
      tfdat2 = (Timedfn )next___0->dat;
#line 1411
      if (when < tfdat2->when) {
        {
#line 1412
        zinsertlinknode(timedfns, ln, (void *)tfdat);
        }
#line 1413
        return;
      }
#line 1415
      ln = next___0;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1418
  return;
}
}
#line 1434 "/tmp/zsh-5.4.2/Src/utils.c"
void deltimedfn(void (*func)(void) ) 
{ 
  LinkNode ln ;
  Timedfn ppdat ;

  {
#line 1439
  ln = timedfns->list.first;
  {
#line 1439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1439
    if (! ln) {
#line 1439
      goto while_break;
    }
#line 1440
    ppdat = (Timedfn )ln->dat;
#line 1441
    if ((unsigned long )ppdat->func == (unsigned long )func) {
      {
#line 1442
      remnode(timedfns, ln);
#line 1443
      zfree((void *)ppdat, (int )sizeof(struct timedfn ));
      }
#line 1444
      return;
    }
#line 1439
    ln = ln->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1450
  return;
}
}
#line 1478 "/tmp/zsh-5.4.2/Src/utils.c"
int callhookfunc(char *name , LinkList lnklst , int arrayp , int *retval ) 
{ 
  Shfunc shfunc ;
  int osc ;
  int osm ;
  int stat___0 ;
  int ret ;
  int old_incompfunc ;
  char **arrptr ;
  int namlen ;
  size_t tmp ;
  char *arrnam ;
  void *tmp___0 ;
  int newret ;
  int tmp___1 ;

  {
  {
#line 1486
  osc = sfcontext;
#line 1486
  osm = stopmsg;
#line 1486
  stat___0 = 1;
#line 1486
  ret = 0;
#line 1487
  old_incompfunc = incompfunc;
#line 1489
  sfcontext = 3;
#line 1490
  incompfunc = 0;
#line 1492
  shfunc = getshfunc(name);
  }
#line 1492
  if (shfunc) {
    {
#line 1493
    ret = doshfunc(shfunc, lnklst, 1);
#line 1494
    stat___0 = 0;
    }
  }
#line 1497
  if (arrayp) {
    {
#line 1499
    tmp = strlen((char const   *)name);
#line 1499
    namlen = (int )tmp;
#line 1500
    tmp___0 = zhalloc(sizeof(char ) * (unsigned long )(namlen + 11));
#line 1500
    arrnam = (char *)tmp___0;
#line 1501
    memcpy((void */* __restrict  */)arrnam, (void const   */* __restrict  */)name,
           (size_t )namlen);
#line 1502
    memcpy((void */* __restrict  */)(arrnam + namlen), (void const   */* __restrict  */)"_functions",
           (size_t )11);
#line 1504
    arrptr = getaparam(arrnam);
    }
#line 1504
    if (arrptr) {
      {
#line 1505
      arrptr = arrdup(arrptr);
      }
      {
#line 1506
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1506
        if (! *arrptr) {
#line 1506
          goto while_break;
        }
        {
#line 1507
        shfunc = getshfunc(*arrptr);
        }
#line 1507
        if (shfunc) {
          {
#line 1508
          tmp___1 = doshfunc(shfunc, lnklst, 1);
#line 1508
          newret = tmp___1;
          }
#line 1509
          if (! ret) {
#line 1510
            ret = newret;
          }
#line 1511
          stat___0 = 0;
        }
#line 1506
        arrptr ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1517
  sfcontext = osc;
#line 1518
  stopmsg = osm;
#line 1519
  incompfunc = old_incompfunc;
#line 1521
  if (retval) {
#line 1522
    *retval = ret;
  }
#line 1523
  return (stat___0);
}
}
#line 1532 "/tmp/zsh-5.4.2/Src/utils.c"
static time_t lastperiodic  ;
#line 1529 "/tmp/zsh-5.4.2/Src/utils.c"
void preprompt(void) 
{ 
  time_t currentmailcheck ;
  LinkNode ln ;
  zlong period ;
  zlong tmp ;
  zlong mailcheck ;
  zlong tmp___0 ;
  sigset_t tmp___1 ;
  sigset_t tmp___2 ;
  char *eolmark ;
  char *tmp___3 ;
  char *str ;
  int percents ;
  int w ;
  time_t tmp___4 ;
  int tmp___5 ;
  time_t tmp___6 ;
  double tmp___7 ;
  zlong tmp___8 ;
  char *mailfile ;
  char *x[2] ;
  sigset_t oset ;
  double tmp___9 ;
  Prepromptfn ppnode ;

  {
  {
#line 1535
  tmp = getiparam((char *)"PERIOD");
#line 1535
  period = tmp;
#line 1536
  tmp___0 = getiparam((char *)"MAILCHECK");
#line 1536
  mailcheck = tmp___0;
#line 1542
  tmp___1 = signal_mask(28);
#line 1542
  signal_unblock(tmp___1);
#line 1543
  tmp___2 = signal_mask(28);
#line 1543
  signal_block(tmp___2);
  }
#line 1545
  if (opts[143]) {
#line 1545
    if (opts[141]) {
#line 1545
      if (! use_exit_printed) {
#line 1545
        if (shout) {
          {
#line 1552
          tmp___3 = getsparam((char *)"PROMPT_EOL_MARK");
#line 1552
          eolmark = tmp___3;
#line 1554
          percents = (int )opts[142];
#line 1554
          w = 0;
          }
#line 1555
          if (! eolmark) {
#line 1556
            eolmark = (char *)"%B%S%#%s%b";
          }
          {
#line 1557
          opts[142] = (char)1;
#line 1558
          str = promptexpand(eolmark, 1, (char *)((void *)0), (char *)((void *)0),
                             (unsigned int *)((void *)0));
#line 1559
          countprompt(str, & w, (int *)0, -1);
#line 1560
          opts[142] = (char )percents;
#line 1561
          zputs((char const   *)str, shout);
#line 1562
          fprintf((FILE */* __restrict  */)shout, (char const   */* __restrict  */)"%*s\r%*s\r",
                  ((int )zterm_columns - w) - ! hasxn, "", w, "");
#line 1564
          fflush(shout);
#line 1565
          free((void *)str);
          }
        }
      }
    }
  }
#line 1570
  if (! opts[121]) {
    {
#line 1571
    scanjobs();
    }
  }
#line 1572
  if (errflag) {
#line 1573
    return;
  }
  {
#line 1577
  callhookfunc((char *)"precmd", (LinkList )((void *)0), 1, (int *)((void *)0));
  }
#line 1578
  if (errflag) {
#line 1579
    return;
  }
#line 1584
  if (period) {
    {
#line 1584
    tmp___4 = time((time_t *)((void *)0));
    }
#line 1584
    if (tmp___4 > lastperiodic + period) {
      {
#line 1584
      tmp___5 = callhookfunc((char *)"periodic", (LinkList )((void *)0), 1, (int *)((void *)0));
      }
#line 1584
      if (! tmp___5) {
        {
#line 1586
        lastperiodic = time((time_t *)((void *)0));
        }
      }
    }
  }
#line 1587
  if (errflag) {
#line 1588
    return;
  }
#line 1592
  if (watch) {
    {
#line 1593
    tmp___6 = time((time_t *)((void *)0));
#line 1593
    tmp___7 = difftime(tmp___6, lastwatch);
#line 1593
    tmp___8 = getiparam((char *)"LOGCHECK");
    }
#line 1593
    if ((zlong )((int )tmp___7) > tmp___8) {
      {
#line 1594
      dowatch();
#line 1595
      lastwatch = time((time_t *)((void *)0));
      }
    }
  }
#line 1598
  if (errflag) {
#line 1599
    return;
  }
  {
#line 1602
  currentmailcheck = time((time_t *)((void *)0));
  }
#line 1603
  if (mailcheck) {
    {
#line 1603
    tmp___9 = difftime(currentmailcheck, lastmailcheck);
    }
#line 1603
    if ((zlong )tmp___9 > mailcheck) {
#line 1607
      if (mailpath) {
#line 1607
        if (*mailpath) {
#line 1607
          if (*(*mailpath)) {
            {
#line 1608
            checkmailpath(mailpath);
            }
          } else {
#line 1607
            goto _L___0;
          }
        } else {
#line 1607
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 1610
        queueing_enabled ++;
#line 1611
        mailfile = getsparam((char *)"MAIL");
        }
#line 1611
        if (mailfile) {
#line 1611
          if (*mailfile) {
            {
#line 1614
            x[0] = mailfile;
#line 1615
            x[1] = (char *)((void *)0);
#line 1616
            checkmailpath(x);
            }
          }
        }
        {
#line 1618
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1618
          queueing_enabled --;
#line 1618
          if (! queueing_enabled) {
            {
#line 1618
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 1618
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 1618
                if (! (queue_front != queue_rear)) {
#line 1618
                  goto while_break___1;
                }
                {
#line 1618
                queue_front = (queue_front + 1) % 128;
#line 1618
                oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1618
                zhandler(signal_queue[queue_front]);
#line 1618
                signal_setmask(oset);
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 1618
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 1618
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 1620
      lastmailcheck = currentmailcheck;
    }
  }
#line 1623
  if (prepromptfns) {
#line 1624
    ln = prepromptfns->list.first;
    {
#line 1624
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1624
      if (! ln) {
#line 1624
        goto while_break___2;
      }
      {
#line 1625
      ppnode = (Prepromptfn )ln->dat;
#line 1626
      (*(ppnode->func))();
#line 1624
      ln = ln->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1629
  return;
}
}
#line 1632 "/tmp/zsh-5.4.2/Src/utils.c"
static void checkmailpath(char **s ) 
{ 
  struct stat st___0 ;
  char *v ;
  char *u ;
  char c ;
  int *tmp ;
  int *tmp___0 ;
  LinkList l ;
  DIR *lock ;
  char *tmp___1 ;
  DIR *tmp___2 ;
  char buf___7[8193] ;
  char **arr ;
  char **ap ;
  int ct ;
  char *fn___0 ;
  char *tmp___3 ;
  void *tmp___4 ;
  char **tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  char *usav ;
  int uusav ;
  void *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 1638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1638
    if (! *s) {
#line 1638
      goto while_break;
    }
#line 1639
    v = *s;
    {
#line 1639
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1639
      if (*v) {
#line 1639
        if (! ((int )*v != 63)) {
#line 1639
          goto while_break___0;
        }
      } else {
#line 1639
        goto while_break___0;
      }
#line 1639
      v ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1640
    c = *v;
#line 1641
    *v = (char )'\000';
#line 1642
    if ((int )c != 63) {
#line 1643
      u = (char *)((void *)0);
    } else {
#line 1645
      u = v + 1;
    }
#line 1646
    if ((int )*(*s) == 0) {
      {
#line 1647
      *v = c;
#line 1648
      zerr("empty MAILPATH component: %s", *s);
      }
    } else {
      {
#line 1649
      tmp___11 = unmeta((char const   *)*s);
#line 1649
      tmp___12 = stat((char const   */* __restrict  */)tmp___11, (struct stat */* __restrict  */)(& st___0));
      }
#line 1649
      if (tmp___12 == -1) {
        {
#line 1650
        tmp___0 = __errno_location();
        }
#line 1650
        if (*tmp___0 != 2) {
          {
#line 1651
          tmp = __errno_location();
#line 1651
          zerr("%e: %s", *tmp, *s);
          }
        }
      } else
#line 1652
      if ((st___0.st_mode & 61440U) == 16384U) {
        {
#line 1654
        tmp___1 = unmeta((char const   *)*s);
#line 1654
        tmp___2 = opendir((char const   *)tmp___1);
#line 1654
        lock = tmp___2;
#line 1656
        ct = 1;
        }
#line 1658
        if (lock) {
          {
#line 1661
          pushheap();
#line 1662
          l = newlinklist();
          }
          {
#line 1663
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 1663
            fn___0 = zreaddir(lock, 1);
            }
#line 1663
            if (fn___0) {
#line 1663
              if (! (! errflag)) {
#line 1663
                goto while_break___1;
              }
            } else {
#line 1663
              goto while_break___1;
            }
#line 1664
            if (u) {
              {
#line 1665
              sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%s/%s?%s",
                      *s, fn___0, u);
              }
            } else {
              {
#line 1667
              sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%s/%s",
                      *s, fn___0);
              }
            }
            {
#line 1668
            tmp___3 = dupstring((char const   *)(buf___7));
#line 1668
            insertlinknode(l, l->list.last, (void *)tmp___3);
#line 1669
            ct ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 1671
          closedir(lock);
#line 1672
          tmp___4 = zhalloc((unsigned long )ct * sizeof(char *));
#line 1672
          arr = (char **)tmp___4;
#line 1672
          ap = arr;
          }
          {
#line 1674
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 1674
            tmp___5 = ap;
#line 1674
            ap ++;
#line 1674
            tmp___7 = ugetnode(l);
#line 1674
            tmp___6 = (char *)tmp___7;
#line 1674
            *tmp___5 = tmp___6;
            }
#line 1674
            if (! tmp___6) {
#line 1674
              goto while_break___2;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1675
          checkmailpath(arr);
#line 1676
          popheap();
          }
        }
      } else
#line 1678
      if (shout) {
#line 1679
        if (st___0.st_size) {
#line 1679
          if (st___0.st_atim.tv_sec <= st___0.st_mtim.tv_sec) {
#line 1679
            if (st___0.st_mtim.tv_sec >= lastmailcheck) {
#line 1681
              if (! u) {
                {
#line 1682
                fprintf((FILE */* __restrict  */)shout, (char const   */* __restrict  */)"You have new mail.\n");
#line 1683
                fflush(shout);
                }
              } else {
                {
#line 1686
                uusav = underscoreused;
#line 1688
                tmp___8 = zalloc((size_t )underscoreused);
#line 1688
                usav = (char *)tmp___8;
                }
#line 1690
                if (usav) {
                  {
#line 1691
                  memcpy((void */* __restrict  */)usav, (void const   */* __restrict  */)zunderscore,
                         (size_t )underscoreused);
                  }
                }
                {
#line 1693
                setunderscore(*s);
#line 1695
                u = dupstring((char const   *)u);
#line 1696
                tmp___9 = parsestr(& u);
                }
#line 1696
                if (! tmp___9) {
                  {
#line 1697
                  singsub(& u);
#line 1698
                  zputs((char const   *)u, shout);
#line 1699
                  fputc('\n', shout);
#line 1700
                  fflush(shout);
                  }
                }
#line 1702
                if (usav) {
                  {
#line 1703
                  setunderscore(usav);
#line 1704
                  zfree((void *)usav, uusav);
                  }
                }
              }
            }
          }
        }
#line 1708
        if (opts[113]) {
#line 1708
          if (st___0.st_atim.tv_sec > st___0.st_mtim.tv_sec) {
#line 1708
            if (st___0.st_atim.tv_sec > lastmailcheck) {
#line 1708
              if (st___0.st_size) {
                {
#line 1710
                tmp___10 = unmeta((char const   *)*s);
#line 1710
                fprintf((FILE */* __restrict  */)shout, (char const   */* __restrict  */)"The mail in %s has been read.\n",
                        tmp___10);
#line 1711
                fflush(shout);
                }
              }
            }
          }
        }
      }
    }
#line 1714
    *v = c;
#line 1715
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1717
  return;
}
}
#line 1722 "/tmp/zsh-5.4.2/Src/utils.c"
FILE *xtrerr  =    (FILE *)0;
#line 1725 "/tmp/zsh-5.4.2/Src/utils.c"
void printprompt4(void) 
{ 
  int l ;
  int t ;
  char *s ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1728
  if (! xtrerr) {
#line 1729
    xtrerr = stderr;
  }
#line 1730
  if (prompt4) {
    {
#line 1731
    t = (int )opts[177];
#line 1732
    tmp = dupstring((char const   *)prompt4);
#line 1732
    s = tmp;
#line 1734
    opts[177] = (char)0;
#line 1735
    unmetafy(s, & l);
#line 1736
    tmp___0 = metafy(s, l, 5);
#line 1736
    tmp___1 = promptexpand(tmp___0, 0, (char *)((void *)0), (char *)((void *)0), (unsigned int *)((void *)0));
#line 1736
    s = unmetafy(tmp___1, & l);
#line 1738
    opts[177] = (char )t;
#line 1740
    fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)"%s",
            s);
#line 1741
    free((void *)s);
    }
  }
#line 1743
  return;
}
}
#line 1746 "/tmp/zsh-5.4.2/Src/utils.c"
void freestr(void *a ) 
{ 


  {
  {
#line 1749
  zsfree((char *)a);
  }
#line 1750
  return;
}
}
#line 1753 "/tmp/zsh-5.4.2/Src/utils.c"
void gettyinfo(struct ttyinfo *ti ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 1756
  if (SHTTY != -1) {
    {
#line 1759
    tmp___0 = tcgetattr(SHTTY, & ti->tio);
    }
#line 1759
    if (tmp___0 == -1) {
      {
#line 1763
      tmp = __errno_location();
#line 1763
      zerr("bad tcgets: %e", *tmp);
      }
    }
  }
#line 1775
  return;
}
}
#line 1778 "/tmp/zsh-5.4.2/Src/utils.c"
void settyinfo(struct ttyinfo *ti ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
#line 1781
  if (SHTTY != -1) {
    {
#line 1787
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1787
      tmp = tcsetattr(SHTTY, 1, (struct termios  const  *)(& ti->tio));
      }
#line 1787
      if (tmp == -1) {
        {
#line 1787
        tmp___0 = __errno_location();
        }
#line 1787
        if (! (*tmp___0 == 4)) {
#line 1787
          goto while_break;
        }
      } else {
#line 1787
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1805
  return;
}
}
#line 1824 "/tmp/zsh-5.4.2/Src/utils.c"
static int adjustlines(int signalled ) 
{ 
  int oldlines ;

  {
#line 1827
  oldlines = (int )zterm_lines;
#line 1830
  if (signalled) {
#line 1831
    zterm_lines = (zlong )shttyinfo.winsize.ws_row;
  } else
#line 1830
  if (zterm_lines <= 0L) {
#line 1831
    zterm_lines = (zlong )shttyinfo.winsize.ws_row;
  } else {
#line 1833
    shttyinfo.winsize.ws_row = (unsigned short )zterm_lines;
  }
#line 1835
  if (zterm_lines <= 0L) {
#line 1837
    if (tclines > 0) {
#line 1837
      zterm_lines = (zlong )tclines;
    } else {
#line 1837
      zterm_lines = (zlong )24;
    }
  }
#line 1840
  if (zterm_lines > 2L) {
#line 1841
    termflags &= -9;
  } else {
#line 1843
    termflags |= 8;
  }
#line 1845
  return (zterm_lines != (zlong )oldlines);
}
}
#line 1848 "/tmp/zsh-5.4.2/Src/utils.c"
static int adjustcolumns(int signalled ) 
{ 
  int oldcolumns ;

  {
#line 1851
  oldcolumns = (int )zterm_columns;
#line 1854
  if (signalled) {
#line 1855
    zterm_columns = (zlong )shttyinfo.winsize.ws_col;
  } else
#line 1854
  if (zterm_columns <= 0L) {
#line 1855
    zterm_columns = (zlong )shttyinfo.winsize.ws_col;
  } else {
#line 1857
    shttyinfo.winsize.ws_col = (unsigned short )zterm_columns;
  }
#line 1859
  if (zterm_columns <= 0L) {
#line 1861
    if (tccolumns > 0) {
#line 1861
      zterm_columns = (zlong )tccolumns;
    } else {
#line 1861
      zterm_columns = (zlong )80;
    }
  }
#line 1864
  if (zterm_columns > 2L) {
#line 1865
    termflags &= -17;
  } else {
#line 1867
    termflags |= 16;
  }
#line 1869
  return (zterm_columns != (zlong )oldcolumns);
}
}
#line 1883 "/tmp/zsh-5.4.2/Src/utils.c"
static int getwinsz  =    1;
#line 1880 "/tmp/zsh-5.4.2/Src/utils.c"
void adjustwinsize(int from ) 
{ 
  int ttyrows ;
  int ttycols ;
  int resetzle ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 1885
  ttyrows = (int )shttyinfo.winsize.ws_row;
#line 1886
  ttycols = (int )shttyinfo.winsize.ws_col;
#line 1888
  resetzle = 0;
#line 1890
  if (getwinsz) {
#line 1890
    goto _L;
  } else
#line 1890
  if (from == 1) {
    _L: /* CIL Label */ 
#line 1892
    if (SHTTY == -1) {
#line 1893
      return;
    }
    {
#line 1894
    tmp___0 = ioctl(SHTTY, 21523UL, (char *)(& shttyinfo.winsize));
    }
#line 1894
    if (tmp___0 == 0) {
#line 1895
      if (ttyrows != (int )shttyinfo.winsize.ws_row) {
#line 1895
        tmp = 1;
      } else
#line 1895
      if (ttycols != (int )shttyinfo.winsize.ws_col) {
#line 1895
        tmp = 1;
      } else {
#line 1895
        tmp = 0;
      }
#line 1895
      resetzle = tmp;
#line 1897
      if (from == 0) {
#line 1897
        if (resetzle) {
#line 1897
          if (ttyrows) {
#line 1897
            if (ttycols) {
#line 1898
              from = 1;
            }
          }
        }
      }
#line 1899
      ttyrows = (int )shttyinfo.winsize.ws_row;
#line 1900
      ttycols = (int )shttyinfo.winsize.ws_col;
    } else {
#line 1903
      shttyinfo.winsize.ws_row = (unsigned short )zterm_lines;
#line 1904
      shttyinfo.winsize.ws_col = (unsigned short )zterm_columns;
#line 1905
      resetzle = from == 1;
    }
  }
  {
#line 1915
  if (from == 1) {
#line 1915
    goto case_1;
  }
#line 1915
  if (from == 0) {
#line 1915
    goto case_1;
  }
#line 1929
  if (from == 2) {
#line 1929
    goto case_2;
  }
#line 1932
  if (from == 3) {
#line 1932
    goto case_3;
  }
#line 1913
  goto switch_break;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 1916
  getwinsz = 0;
#line 1923
  tmp___1 = adjustlines(from);
  }
#line 1923
  if (tmp___1) {
    {
#line 1923
    tmp___2 = zgetenv((char *)"LINES");
    }
#line 1923
    if (tmp___2) {
      {
#line 1924
      setiparam((char *)"LINES", zterm_lines);
      }
    }
  }
  {
#line 1925
  tmp___3 = adjustcolumns(from);
  }
#line 1925
  if (tmp___3) {
    {
#line 1925
    tmp___4 = zgetenv((char *)"COLUMNS");
    }
#line 1925
    if (tmp___4) {
      {
#line 1926
      setiparam((char *)"COLUMNS", zterm_columns);
      }
    }
  }
#line 1927
  getwinsz = 1;
#line 1928
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1930
  resetzle = adjustlines(0);
  }
#line 1931
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1933
  resetzle = adjustcolumns(0);
  }
#line 1934
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1938
  if (opts[93]) {
#line 1938
    if (from >= 2) {
#line 1938
      if ((int )shttyinfo.winsize.ws_row != ttyrows) {
#line 1938
        tmp___5 = 1;
      } else
#line 1938
      if ((int )shttyinfo.winsize.ws_col != ttycols) {
#line 1938
        tmp___5 = 1;
      } else {
#line 1938
        tmp___5 = 0;
      }
    } else {
#line 1938
      tmp___5 = 0;
    }
  } else {
#line 1938
    tmp___5 = 0;
  }
#line 1946
  if (zleactive) {
#line 1946
    if (resetzle) {
      {
#line 1948
      resetneeded = 1;
#line 1948
      winchanged = resetneeded;
#line 1951
      zleentry(4);
#line 1952
      zleentry(5);
      }
    }
  }
#line 1954
  return;
}
}
#line 1960 "/tmp/zsh-5.4.2/Src/utils.c"
static void check_fd_table(int fd ) 
{ 
  int old_size ;
  void *tmp ;

  {
#line 1963
  if (fd <= max_zsh_fd) {
#line 1964
    return;
  }
#line 1966
  if (fd >= fdtable_size) {
#line 1967
    old_size = fdtable_size;
    {
#line 1968
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1968
      if (! (fd >= fdtable_size)) {
#line 1968
        goto while_break;
      }
      {
#line 1969
      fdtable_size *= 2;
#line 1969
      tmp = zrealloc((void *)fdtable, (unsigned long )fdtable_size * sizeof(*fdtable));
#line 1969
      fdtable = (unsigned char *)tmp;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1971
    memset((void *)(fdtable + old_size), 0, (unsigned long )(fdtable_size - old_size) * sizeof(*fdtable));
    }
  }
#line 1974
  max_zsh_fd = fd;
#line 1975
  return;
}
}
#line 1981 "/tmp/zsh-5.4.2/Src/utils.c"
int movefd(int fd ) 
{ 
  int fe ;
  int tmp ;

  {
#line 1984
  if (fd != -1) {
#line 1984
    if (fd < 10) {
      {
#line 1986
      tmp = fcntl(fd, 0, 10);
#line 1986
      fe = tmp;
#line 1996
      zclose(fd);
#line 1997
      fd = fe;
      }
    }
  }
#line 1999
  if (fd != -1) {
    {
#line 2000
    check_fd_table(fd);
#line 2001
    *(fdtable + fd) = (unsigned char)1;
    }
  }
#line 2003
  return (fd);
}
}
#line 2012 "/tmp/zsh-5.4.2/Src/utils.c"
int redup(int x , int y ) 
{ 
  int ret ;
  int tmp ;

  {
#line 2015
  ret = y;
#line 2017
  if (x < 0) {
    {
#line 2018
    zclose(y);
    }
  } else
#line 2019
  if (x != y) {
    {
#line 2020
    tmp = dup2(x, y);
    }
#line 2020
    if (tmp == -1) {
#line 2021
      ret = -1;
    } else {
      {
#line 2023
      check_fd_table(y);
#line 2024
      *(fdtable + y) = *(fdtable + x);
      }
#line 2025
      if ((int )*(fdtable + y) == 5) {
#line 2026
        *(fdtable + y) = (unsigned char)1;
      } else
#line 2025
      if ((int )*(fdtable + y) == 6) {
#line 2026
        *(fdtable + y) = (unsigned char)1;
      }
    }
#line 2032
    if ((int )*(fdtable + x) == 5) {
#line 2033
      fdtable_flocks --;
    }
    {
#line 2034
    zclose(x);
    }
  }
#line 2037
  return (ret);
}
}
#line 2060 "/tmp/zsh-5.4.2/Src/utils.c"
void addmodulefd(int fd , int fdt ) 
{ 


  {
#line 2063
  if (fd >= 0) {
    {
#line 2064
    check_fd_table(fd);
#line 2065
    *(fdtable + fd) = (unsigned char )fdt;
    }
  }
#line 2067
  return;
}
}
#line 2081 "/tmp/zsh-5.4.2/Src/utils.c"
void addlockfd(int fd , int cloexec ) 
{ 


  {
#line 2084
  if (cloexec) {
#line 2085
    if ((int )*(fdtable + fd) != 5) {
#line 2086
      fdtable_flocks ++;
    }
#line 2087
    *(fdtable + fd) = (unsigned char)5;
  } else {
#line 2089
    *(fdtable + fd) = (unsigned char)6;
  }
#line 2091
  return;
}
}
#line 2096 "/tmp/zsh-5.4.2/Src/utils.c"
int zclose(int fd ) 
{ 
  int tmp ;

  {
#line 2099
  if (fd >= 0) {
#line 2104
    if (fd <= max_zsh_fd) {
#line 2105
      if ((int )*(fdtable + fd) == 5) {
#line 2106
        fdtable_flocks --;
      }
#line 2107
      *(fdtable + fd) = (unsigned char)0;
      {
#line 2108
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2108
        if (max_zsh_fd > 0) {
#line 2108
          if (! ((int )*(fdtable + max_zsh_fd) == 0)) {
#line 2108
            goto while_break;
          }
        } else {
#line 2108
          goto while_break;
        }
#line 2109
        max_zsh_fd --;
      }
      while_break: /* CIL Label */ ;
      }
#line 2110
      if (fd == coprocin) {
#line 2111
        coprocin = -1;
      }
#line 2112
      if (fd == coprocout) {
#line 2113
        coprocout = -1;
      }
    }
    {
#line 2115
    tmp = close(fd);
    }
#line 2115
    return (tmp);
  }
#line 2117
  return (-1);
}
}
#line 2125 "/tmp/zsh-5.4.2/Src/utils.c"
int zcloselockfd(int fd ) 
{ 


  {
#line 2128
  if (fd > max_zsh_fd) {
#line 2129
    return (-1);
  }
#line 2130
  if ((int )*(fdtable + fd) != 5) {
#line 2130
    if ((int )*(fdtable + fd) != 6) {
#line 2131
      return (-1);
    }
  }
  {
#line 2132
  zclose(fd);
  }
#line 2133
  return (0);
}
}
#line 2147 "/tmp/zsh-5.4.2/Src/utils.c"
char *gettempname(char const   *prefix , int use_heap ) 
{ 
  char *ret ;
  char *suffix ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  sigset_t oset ;

  {
#line 2150
  if (prefix) {
#line 2150
    tmp = ".XXXXXX";
  } else {
#line 2150
    tmp = "XXXXXX";
  }
#line 2150
  suffix = (char *)tmp;
#line 2152
  queueing_enabled ++;
#line 2153
  if (! prefix) {
    {
#line 2153
    tmp___0 = getsparam((char *)"TMPPREFIX");
#line 2153
    prefix = (char const   *)tmp___0;
    }
#line 2153
    if (! prefix) {
#line 2154
      prefix = "/tmp/zsh";
    }
  }
#line 2155
  if (use_heap) {
    {
#line 2156
    tmp___1 = unmeta(prefix);
#line 2156
    ret = dyncat((char const   *)tmp___1, (char const   *)suffix);
    }
  } else {
    {
#line 2158
    tmp___2 = unmeta(prefix);
#line 2158
    ret = bicat((char const   *)tmp___2, (char const   *)suffix);
    }
  }
  {
#line 2164
  tmp___3 = mktemp(ret);
#line 2164
  ret = tmp___3;
  }
  {
#line 2166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2166
    queueing_enabled --;
#line 2166
    if (! queueing_enabled) {
      {
#line 2166
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2166
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2166
          if (! (queue_front != queue_rear)) {
#line 2166
            goto while_break___1;
          }
          {
#line 2166
          queue_front = (queue_front + 1) % 128;
#line 2166
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 2166
          zhandler(signal_queue[queue_front]);
#line 2166
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2166
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2166
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2168
  return (ret);
}
}
#line 2175 "/tmp/zsh-5.4.2/Src/utils.c"
int gettempfile(char const   *prefix , int use_heap , char **tempname ) 
{ 
  char *fn___0 ;
  int fd ;
  char *suffix ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  sigset_t oset ;

  {
#line 2181
  if (prefix) {
#line 2181
    tmp = ".XXXXXX";
  } else {
#line 2181
    tmp = "XXXXXX";
  }
#line 2181
  suffix = (char *)tmp;
#line 2183
  queueing_enabled ++;
#line 2184
  if (! prefix) {
    {
#line 2184
    tmp___0 = getsparam((char *)"TMPPREFIX");
#line 2184
    prefix = (char const   *)tmp___0;
    }
#line 2184
    if (! prefix) {
#line 2185
      prefix = "/tmp/zsh";
    }
  }
#line 2186
  if (use_heap) {
    {
#line 2187
    tmp___1 = unmeta(prefix);
#line 2187
    fn___0 = dyncat((char const   *)tmp___1, (char const   *)suffix);
    }
  } else {
    {
#line 2189
    tmp___2 = unmeta(prefix);
#line 2189
    fn___0 = bicat((char const   *)tmp___2, (char const   *)suffix);
    }
  }
  {
#line 2191
  fd = mkstemp(fn___0);
  }
#line 2192
  if (fd < 0) {
#line 2193
    if (! use_heap) {
      {
#line 2194
      free((void *)fn___0);
      }
    }
#line 2195
    fn___0 = (char *)((void *)0);
  }
#line 2213
  *tempname = fn___0;
  {
#line 2215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2215
    queueing_enabled --;
#line 2215
    if (! queueing_enabled) {
      {
#line 2215
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2215
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2215
          if (! (queue_front != queue_rear)) {
#line 2215
            goto while_break___1;
          }
          {
#line 2215
          queue_front = (queue_front + 1) % 128;
#line 2215
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 2215
          zhandler(signal_queue[queue_front]);
#line 2215
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2215
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2215
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2216
  return (fd);
}
}
#line 2222 "/tmp/zsh-5.4.2/Src/utils.c"
int has_token(char const   *s ) 
{ 
  char const   *tmp ;

  {
  {
#line 2225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2225
    if (! *s) {
#line 2225
      goto while_break;
    }
#line 2226
    tmp = s;
#line 2226
    s ++;
#line 2226
    if ((int )typtab[(unsigned char )*tmp] & (1 << 4)) {
#line 2227
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2228
  return (0);
}
}
#line 2234 "/tmp/zsh-5.4.2/Src/utils.c"
void chuck(char *str ) 
{ 
  char tmp ;

  {
  {
#line 2237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2237
    tmp = *(str + 1);
#line 2237
    *(str + 0) = tmp;
#line 2237
    if (! tmp) {
#line 2237
      goto while_break;
    }
#line 2238
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2239
  return;
}
}
#line 2242 "/tmp/zsh-5.4.2/Src/utils.c"
int tulower(int c ) 
{ 
  int __res ;
  __int32_t const   **tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 2245
  c &= 255;
#line 2246
  tmp___3 = __ctype_b_loc();
  }
#line 2246
  if ((int const   )*(*tmp___3 + c) & 256) {
#line 2246
    if (sizeof(c) > 1UL) {
      {
#line 2246
      __res = tolower(c);
      }
    } else {
      {
#line 2246
      tmp___1 = __ctype_tolower_loc();
#line 2246
      __res = (int )*(*tmp___1 + c);
      }
    }
#line 2246
    tmp___2 = __res;
  } else {
#line 2246
    tmp___2 = c;
  }
#line 2246
  return (tmp___2);
}
}
#line 2250 "/tmp/zsh-5.4.2/Src/utils.c"
int tuupper(int c ) 
{ 
  int __res ;
  __int32_t const   **tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 2253
  c &= 255;
#line 2254
  tmp___3 = __ctype_b_loc();
  }
#line 2254
  if ((int const   )*(*tmp___3 + c) & 512) {
#line 2254
    if (sizeof(c) > 1UL) {
      {
#line 2254
      __res = toupper(c);
      }
    } else {
      {
#line 2254
      tmp___1 = __ctype_toupper_loc();
#line 2254
      __res = (int )*(*tmp___1 + c);
      }
    }
#line 2254
    tmp___2 = __res;
  } else {
#line 2254
    tmp___2 = c;
  }
#line 2254
  return (tmp___2);
}
}
#line 2260 "/tmp/zsh-5.4.2/Src/utils.c"
void ztrncpy(char *s , char *t , int len ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2263
    tmp___1 = len;
#line 2263
    len --;
#line 2263
    if (! tmp___1) {
#line 2263
      goto while_break;
    }
#line 2264
    tmp = s;
#line 2264
    s ++;
#line 2264
    tmp___0 = t;
#line 2264
    t ++;
#line 2264
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 2265
  *s = (char )'\000';
#line 2266
  return;
}
}
#line 2271 "/tmp/zsh-5.4.2/Src/utils.c"
void strucpy(char **s , char *t ) 
{ 
  char *u ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;

  {
#line 2274
  u = *s;
  {
#line 2276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2276
    tmp = u;
#line 2276
    u ++;
#line 2276
    tmp___1 = t;
#line 2276
    t ++;
#line 2276
    tmp___0 = *tmp___1;
#line 2276
    *tmp = tmp___0;
#line 2276
    if (! tmp___0) {
#line 2276
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2277
  *s = u - 1;
#line 2278
  return;
}
}
#line 2281 "/tmp/zsh-5.4.2/Src/utils.c"
void struncpy(char **s , char *t , int n ) 
{ 
  char *u ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 2284
  u = *s;
  {
#line 2286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2286
    tmp___1 = n;
#line 2286
    n --;
#line 2286
    if (! tmp___1) {
#line 2286
      goto while_break;
    }
#line 2287
    tmp = u;
#line 2287
    u ++;
#line 2287
    tmp___0 = t;
#line 2287
    t ++;
#line 2287
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 2288
  *s = u;
#line 2289
  *u = (char )'\000';
#line 2290
  return;
}
}
#line 2296 "/tmp/zsh-5.4.2/Src/utils.c"
int arrlen(char **s ) 
{ 
  int count ;

  {
#line 2301
  count = 0;
  {
#line 2301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2301
    if (! *s) {
#line 2301
      goto while_break;
    }
#line 2301
    s ++;
#line 2301
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2302
  return (count);
}
}
#line 2308 "/tmp/zsh-5.4.2/Src/utils.c"
char arrlen_ge(char **s , unsigned int lower_bound ) 
{ 
  char **tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 2311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2311
    tmp___0 = lower_bound;
#line 2311
    lower_bound --;
#line 2311
    if (! tmp___0) {
#line 2311
      goto while_break;
    }
#line 2312
    tmp = s;
#line 2312
    s ++;
#line 2312
    if (! *tmp) {
#line 2313
      return ((char)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2315
  return ((char)1);
}
}
#line 2321 "/tmp/zsh-5.4.2/Src/utils.c"
char arrlen_gt(char **s , unsigned int lower_bound ) 
{ 
  char tmp ;

  {
  {
#line 2324
  tmp = arrlen_ge(s, 1U + lower_bound);
  }
#line 2324
  return (tmp);
}
}
#line 2330 "/tmp/zsh-5.4.2/Src/utils.c"
char arrlen_le(char **s , unsigned int upper_bound ) 
{ 
  char tmp ;

  {
  {
#line 2333
  tmp = arrlen_lt(s, 1U + upper_bound);
  }
#line 2333
  return (tmp);
}
}
#line 2339 "/tmp/zsh-5.4.2/Src/utils.c"
char arrlen_lt(char **s , unsigned int upper_bound ) 
{ 
  char tmp ;
  int tmp___0 ;

  {
  {
#line 2342
  tmp = arrlen_ge(s, upper_bound);
  }
#line 2342
  if (tmp) {
#line 2342
    tmp___0 = 0;
  } else {
#line 2342
    tmp___0 = 1;
  }
#line 2342
  return ((char )tmp___0);
}
}
#line 2348 "/tmp/zsh-5.4.2/Src/utils.c"
int skipparens(char inpar , char outpar , char **s ) 
{ 
  int level ;

  {
#line 2353
  if ((int )*(*s) != (int )inpar) {
#line 2354
    return (-1);
  }
#line 2356
  level = 1;
  {
#line 2356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2356
    (*s) ++;
#line 2356
    if (*(*s)) {
#line 2356
      if (! level) {
#line 2356
        goto while_break;
      }
    } else {
#line 2356
      goto while_break;
    }
#line 2357
    if ((int )*(*s) == (int )inpar) {
#line 2358
      level ++;
    } else
#line 2359
    if ((int )*(*s) == (int )outpar) {
#line 2360
      level --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2362
  return (level);
}
}
#line 2366 "/tmp/zsh-5.4.2/Src/utils.c"
zlong zstrtol(char const   *s , char **t , int base ) 
{ 
  zlong tmp ;

  {
  {
#line 2369
  tmp = zstrtol_underscore(s, t, base, 0);
  }
#line 2369
  return (tmp);
}
}
#line 2377 "/tmp/zsh-5.4.2/Src/utils.c"
zlong zstrtol_underscore(char const   *s , char **t , int base , int underscore ) 
{ 
  char const   *inp ;
  char const   *trunc ;
  zulong calc ;
  zulong newcalc ;
  int neg ;
  int tmp ;
  int tmp___0 ;
  zlong tmp___1 ;

  {
#line 2380
  trunc = (char const   *)((void *)0);
#line 2381
  calc = (zulong )0;
#line 2381
  newcalc = (zulong )0;
  {
#line 2384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2384
    if (! ((int )typtab[(unsigned char )*s] & (1 << 3))) {
#line 2384
      goto while_break;
    }
#line 2385
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2387
  if ((int const   )*s == 45) {
#line 2387
    tmp = 1;
  } else
#line 2387
  if ((int const   )*s == -101) {
#line 2387
    tmp = 1;
  } else {
#line 2387
    tmp = 0;
  }
#line 2387
  neg = tmp;
#line 2387
  if (neg) {
#line 2388
    s ++;
  } else
#line 2389
  if ((int const   )*s == 43) {
#line 2390
    s ++;
  }
#line 2392
  if (! base) {
#line 2393
    if ((int const   )*s != 48) {
#line 2394
      base = 10;
    } else {
#line 2395
      s ++;
#line 2395
      if ((int const   )*s == 120) {
#line 2396
        base = 16;
#line 2396
        s ++;
      } else
#line 2395
      if ((int const   )*s == 88) {
#line 2396
        base = 16;
#line 2396
        s ++;
      } else
#line 2397
      if ((int const   )*s == 98) {
#line 2398
        base = 2;
#line 2398
        s ++;
      } else
#line 2397
      if ((int const   )*s == 66) {
#line 2398
        base = 2;
#line 2398
        s ++;
      } else {
#line 2400
        base = 8;
      }
    }
  }
#line 2402
  inp = s;
#line 2403
  if (base < 2) {
    {
#line 2404
    zerr("invalid base (must be 2 to 36 inclusive): %d", base);
    }
#line 2405
    return ((zlong )0);
  } else
#line 2403
  if (base > 36) {
    {
#line 2404
    zerr("invalid base (must be 2 to 36 inclusive): %d", base);
    }
#line 2405
    return ((zlong )0);
  } else
#line 2406
  if (base <= 10) {
    {
#line 2407
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2407
      if ((int const   )*s >= 48) {
#line 2407
        if (! ((int const   )*s < (int const   )(48 + base))) {
#line 2407
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2407
      if (underscore) {
#line 2407
        if (! ((int const   )*s == 95)) {
#line 2407
          goto while_break___0;
        }
      } else {
#line 2407
        goto while_break___0;
      }
#line 2409
      if (trunc) {
#line 2410
        goto __Cont;
      } else
#line 2409
      if ((int const   )*s == 95) {
#line 2410
        goto __Cont;
      }
#line 2411
      newcalc = (calc * (zulong )base + (zulong )*s) - 48UL;
#line 2412
      if (newcalc < calc) {
#line 2414
        trunc = s;
#line 2415
        goto __Cont;
      }
#line 2417
      calc = newcalc;
      __Cont: /* CIL Label */ 
#line 2407
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 2420
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2420
      if (! ((int )typtab[(unsigned char )*s] & 1)) {
#line 2420
        if ((int const   )*s >= 97) {
#line 2420
          if (! ((int const   )*s < (int const   )((97 + base) - 10))) {
#line 2420
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 2420
        if ((int const   )*s >= 65) {
#line 2420
          if (! ((int const   )*s < (int const   )((65 + base) - 10))) {
#line 2420
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 2420
        if (underscore) {
#line 2420
          if (! ((int const   )*s == 95)) {
#line 2420
            goto while_break___1;
          }
        } else {
#line 2420
          goto while_break___1;
        }
      }
#line 2423
      if (trunc) {
#line 2424
        goto __Cont___0;
      } else
#line 2423
      if ((int const   )*s == 95) {
#line 2424
        goto __Cont___0;
      }
#line 2425
      if ((int )typtab[(unsigned char )*s] & 1) {
#line 2425
        tmp___0 = (int const   )*s - 48;
      } else {
#line 2425
        tmp___0 = ((int const   )*s & 31) + 9;
      }
#line 2425
      newcalc = calc * (zulong )base + (zulong )tmp___0;
#line 2426
      if (newcalc < calc) {
#line 2428
        trunc = s;
#line 2429
        goto __Cont___0;
      }
#line 2431
      calc = newcalc;
      __Cont___0: /* CIL Label */ 
#line 2420
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 2443
  if (! trunc) {
#line 2443
    if ((zlong )calc < 0L) {
#line 2443
      if (! neg) {
#line 2446
        trunc = s - 1;
#line 2447
        calc /= (zulong )base;
      } else
#line 2443
      if (calc & ~ (1UL << (8UL * sizeof(zulong ) - 1UL))) {
#line 2446
        trunc = s - 1;
#line 2447
        calc /= (zulong )base;
      }
    }
  }
#line 2450
  if (trunc) {
    {
#line 2451
    zwarn("number truncated after %d digits: %s", (int )(trunc - inp), inp);
    }
  }
#line 2453
  if (t) {
#line 2454
    *t = (char *)s;
  }
#line 2455
  if (neg) {
#line 2455
    tmp___1 = - ((zlong )calc);
  } else {
#line 2455
    tmp___1 = (zlong )calc;
  }
#line 2455
  return (tmp___1);
}
}
#line 2459 "/tmp/zsh-5.4.2/Src/utils.c"
int setblock_fd(int turnonblocking , int fd , long *modep ) 
{ 
  struct stat st___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2479
  tmp___2 = fstat(fd, & st___0);
  }
#line 2479
  if (tmp___2) {
#line 2495
    *modep = -1L;
  } else
#line 2479
  if (! ((st___0.st_mode & 61440U) == 32768U)) {
    {
#line 2480
    tmp = fcntl(fd, 3, 0);
#line 2480
    *modep = (long )tmp;
    }
#line 2481
    if (*modep != -1L) {
#line 2482
      if (! turnonblocking) {
#line 2484
        if (*modep & 2048L) {
#line 2486
          return (1);
        } else {
          {
#line 2484
          tmp___0 = fcntl(fd, 4, *modep | 2048L);
          }
#line 2484
          if (! tmp___0) {
#line 2486
            return (1);
          }
        }
      } else
#line 2487
      if (*modep & 2048L) {
        {
#line 2487
        tmp___1 = fcntl(fd, 4, *modep & -2049L);
        }
#line 2487
        if (! tmp___1) {
#line 2490
          return (1);
        }
      }
    }
  } else {
#line 2495
    *modep = -1L;
  }
#line 2496
  return (0);
}
}
#line 2502 "/tmp/zsh-5.4.2/Src/utils.c"
int setblock_stdin(void) 
{ 
  long mode ;
  int tmp ;

  {
  {
#line 2506
  tmp = setblock_fd(1, 0, & mode);
  }
#line 2506
  return (tmp);
}
}
#line 2525 "/tmp/zsh-5.4.2/Src/utils.c"
int read_poll(int fd , int *readchar , int polltty , zlong microseconds ) 
{ 
  int ret ;
  long mode ;
  char c ;
  fd_set foofd ;
  struct timeval expire_tv ;
  struct ttyinfo ti ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 2528
  ret = -1;
#line 2529
  mode = -1L;
#line 2543
  if (fd < 0) {
#line 2544
    polltty = 0;
  } else
#line 2543
  if (polltty) {
    {
#line 2543
    tmp = isatty(fd);
    }
#line 2543
    if (! tmp) {
#line 2544
      polltty = 0;
    }
  }
#line 2566
  if (polltty) {
#line 2566
    if (fd >= 0) {
      {
#line 2567
      gettyinfo(& ti);
#line 2568
      polltty = (int )ti.tio.c_cc[6];
      }
#line 2568
      if (polltty) {
        {
#line 2569
        ti.tio.c_cc[6] = (cc_t )0;
#line 2571
        ti.tio.c_cc[5] = (cc_t )((int )(microseconds / 100000L));
#line 2572
        settyinfo(& ti);
        }
      }
    }
  }
#line 2579
  expire_tv.tv_sec = (__time_t )((int )(microseconds / 1000000L));
#line 2580
  expire_tv.tv_usec = microseconds % 1000000L;
  {
#line 2581
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2581
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& foofd.fds_bits[0]): "memory");
#line 2581
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2582
  if (fd > -1) {
    {
#line 2583
    foofd.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )));
#line 2584
    ret = select(fd + 1, (fd_set */* __restrict  */)(& foofd), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& expire_tv));
    }
  } else {
    {
#line 2586
    ret = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& expire_tv));
    }
  }
#line 2599
  if (fd >= 0) {
#line 2599
    if (ret < 0) {
#line 2599
      if (! errflag) {
#line 2604
        if (polltty) {
#line 2604
          goto _L;
        } else {
          {
#line 2604
          tmp___0 = setblock_fd(0, fd, & mode);
          }
#line 2604
          if (tmp___0) {
            _L: /* CIL Label */ 
            {
#line 2604
            tmp___1 = read(fd, (void *)(& c), (size_t )1);
            }
#line 2604
            if (tmp___1 > 0L) {
#line 2605
              *readchar = (int )c;
#line 2606
              ret = 1;
            }
          }
        }
#line 2608
        if (mode != -1L) {
          {
#line 2609
          fcntl(fd, 4, mode);
          }
        }
      }
    }
  }
#line 2612
  if (polltty) {
    {
#line 2613
    ti.tio.c_cc[6] = (cc_t )1;
#line 2614
    ti.tio.c_cc[5] = (cc_t )0;
#line 2615
    settyinfo(& ti);
    }
  }
#line 2618
  return (ret > 0);
}
}
#line 2628 "/tmp/zsh-5.4.2/Src/utils.c"
int zsleep(long us ) 
{ 
  struct timespec sleeptime ;
  struct timespec rem ;
  int ret ;
  int tmp ;
  int *tmp___0 ;

  {
#line 2634
  sleeptime.tv_sec = us / 1000000L;
#line 2635
  sleeptime.tv_nsec = (us % 1000000L) * 1000L;
  {
#line 2636
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2638
    tmp = nanosleep((struct timespec  const  *)(& sleeptime), & rem);
#line 2638
    ret = tmp;
    }
#line 2640
    if (ret == 0) {
#line 2641
      return (1);
    } else {
      {
#line 2642
      tmp___0 = __errno_location();
      }
#line 2642
      if (*tmp___0 != 4) {
#line 2643
        return (0);
      }
    }
#line 2644
    sleeptime = rem;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2662 "/tmp/zsh-5.4.2/Src/utils.c"
int zsleep_random(long max_us , time_t end_time ) 
{ 
  long r ;
  time_t now ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2666
  tmp = time((time_t *)((void *)0));
#line 2666
  now = tmp;
#line 2675
  tmp___0 = rand();
#line 2675
  r = (long )(tmp___0 & 65535);
#line 2682
  r = (max_us >> 16) * r;
  }
  {
#line 2688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2688
    if (r) {
#line 2688
      if (! (now + r / 1000000L > end_time)) {
#line 2688
        goto while_break;
      }
    } else {
#line 2688
      goto while_break;
    }
#line 2689
    r >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 2690
  if (r) {
    {
#line 2691
    tmp___1 = zsleep(r);
    }
#line 2691
    return (tmp___1);
  }
#line 2692
  return (0);
}
}
#line 2696 "/tmp/zsh-5.4.2/Src/utils.c"
int checkrmall(char *s ) 
{ 
  DIR *rmd ;
  int count ;
  int max_count ;
  int ignoredots ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 2700
  count = 0;
#line 2701
  if (! shout) {
#line 2702
    return (1);
  }
#line 2703
  if ((int )*s != 47) {
#line 2704
    if (*(pwd + 1)) {
      {
#line 2705
      s = zhtricat((char const   *)pwd, "/", (char const   *)s);
      }
    } else {
      {
#line 2707
      s = dyncat("/", (char const   *)s);
      }
    }
  }
  {
#line 2709
  max_count = 100;
#line 2710
  tmp___0 = unmeta((char const   *)s);
#line 2710
  rmd = opendir((char const   *)tmp___0);
  }
#line 2710
  if (rmd) {
#line 2711
    ignoredots = ! opts[64];
    {
#line 2712
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2712
      tmp = zreaddir(rmd, ignoredots);
      }
#line 2712
      if (! tmp) {
#line 2712
        goto while_break;
      }
#line 2713
      count ++;
#line 2714
      if (count > max_count) {
#line 2715
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2717
    closedir(rmd);
    }
  }
#line 2719
  if (count > max_count) {
    {
#line 2720
    fprintf((FILE */* __restrict  */)shout, (char const   */* __restrict  */)"zsh: sure you want to delete more than %d files in ",
            max_count);
    }
  } else
#line 2722
  if (count == 1) {
    {
#line 2723
    fprintf((FILE */* __restrict  */)shout, (char const   */* __restrict  */)"zsh: sure you want to delete the only file in ");
    }
  } else
#line 2724
  if (count > 0) {
    {
#line 2725
    fprintf((FILE */* __restrict  */)shout, (char const   */* __restrict  */)"zsh: sure you want to delete all %d files in ",
            count);
    }
  } else {
    {
#line 2728
    fprintf((FILE */* __restrict  */)shout, (char const   */* __restrict  */)"zsh: sure you want to delete all the files in ");
    }
  }
  {
#line 2729
  mb_niceformat((char const   *)s, shout, (char **)((void *)0), 0);
  }
#line 2730
  if (opts[156]) {
    {
#line 2731
    fputs((char const   */* __restrict  */)"? (waiting ten seconds)", (FILE */* __restrict  */)shout);
#line 2732
    fflush(shout);
#line 2733
    zbeep();
#line 2734
    sleep(10U);
#line 2735
    fputc('\n', shout);
    }
  }
#line 2737
  if (errflag) {
#line 2738
    return (0);
  }
  {
#line 2739
  fputs((char const   */* __restrict  */)" [yn]? ", (FILE */* __restrict  */)shout);
#line 2740
  fflush(shout);
#line 2741
  zbeep();
#line 2742
  tmp___1 = getquery((char *)"ny", 1);
  }
#line 2742
  return (tmp___1 == 121);
}
}
#line 2746 "/tmp/zsh-5.4.2/Src/utils.c"
ssize_t read_loop(int fd , char *buf___7 , size_t len ) 
{ 
  ssize_t got ;
  ssize_t ret ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 2749
  got = (ssize_t )len;
  {
#line 2751
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2752
    tmp = read(fd, (void *)buf___7, len);
#line 2752
    ret = tmp;
    }
#line 2753
    if ((size_t )ret == len) {
#line 2754
      goto while_break;
    }
#line 2755
    if (ret <= 0L) {
#line 2756
      if (ret < 0L) {
        {
#line 2757
        tmp___0 = __errno_location();
        }
#line 2757
        if (*tmp___0 == 4) {
#line 2758
          goto while_continue;
        }
#line 2759
        if (fd != SHTTY) {
          {
#line 2760
          tmp___1 = __errno_location();
#line 2760
          zwarn("read failed: %e", *tmp___1);
          }
        }
      }
#line 2762
      return (ret);
    }
#line 2764
    buf___7 += ret;
#line 2765
    len -= (size_t )ret;
  }
  while_break: /* CIL Label */ ;
  }
#line 2768
  return (got);
}
}
#line 2772 "/tmp/zsh-5.4.2/Src/utils.c"
ssize_t write_loop(int fd , char const   *buf___7 , size_t len ) 
{ 
  ssize_t wrote ;
  ssize_t ret ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 2775
  wrote = (ssize_t )len;
  {
#line 2777
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2778
    tmp = write(fd, (void const   *)buf___7, len);
#line 2778
    ret = tmp;
    }
#line 2779
    if ((size_t )ret == len) {
#line 2780
      goto while_break;
    }
#line 2781
    if (ret < 0L) {
      {
#line 2782
      tmp___0 = __errno_location();
      }
#line 2782
      if (*tmp___0 == 4) {
#line 2783
        goto while_continue;
      }
#line 2784
      if (fd != SHTTY) {
        {
#line 2785
        tmp___1 = __errno_location();
#line 2785
        zwarn("write failed: %e", *tmp___1);
        }
      }
#line 2786
      return ((ssize_t )-1);
    }
#line 2788
    buf___7 += ret;
#line 2789
    len -= (size_t )ret;
  }
  while_break: /* CIL Label */ ;
  }
#line 2792
  return (wrote);
}
}
#line 2795 "/tmp/zsh-5.4.2/Src/utils.c"
static int read1char(int echo___0 ) 
{ 
  char c ;
  int q ;
  sigset_t oset ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
#line 2799
  q = queueing_enabled;
  {
#line 2801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2801
    queueing_enabled = 0;
    {
#line 2801
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2801
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2801
        if (! (queue_front != queue_rear)) {
#line 2801
          goto while_break___1;
        }
        {
#line 2801
        queue_front = (queue_front + 1) % 128;
#line 2801
        oset = signal_setmask(signal_mask_queue[queue_front]);
#line 2801
        zhandler(signal_queue[queue_front]);
#line 2801
        signal_setmask(oset);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2801
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2801
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2802
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 2802
    tmp___0 = read(SHTTY, (void *)(& c), (size_t )1);
    }
#line 2802
    if (! (tmp___0 != 1L)) {
#line 2802
      goto while_break___2;
    }
    {
#line 2803
    tmp = __errno_location();
    }
#line 2803
    if (*tmp != 4) {
#line 2804
      queueing_enabled = q;
#line 2805
      return (-1);
    } else
#line 2803
    if (errflag) {
#line 2804
      queueing_enabled = q;
#line 2805
      return (-1);
    } else
#line 2803
    if (retflag) {
#line 2804
      queueing_enabled = q;
#line 2805
      return (-1);
    } else
#line 2803
    if (breaks) {
#line 2804
      queueing_enabled = q;
#line 2805
      return (-1);
    } else
#line 2803
    if (contflag) {
#line 2804
      queueing_enabled = q;
#line 2805
      return (-1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2808
  queueing_enabled = q;
#line 2809
  if (echo___0) {
    {
#line 2810
    write_loop(SHTTY, (char const   *)(& c), (size_t )1);
    }
  }
#line 2811
  return ((int )((unsigned char )c));
}
}
#line 2815 "/tmp/zsh-5.4.2/Src/utils.c"
int noquery(int purge ) 
{ 
  int val ;
  char c ;
  ssize_t tmp ;

  {
  {
#line 2818
  val = 0;
#line 2823
  ioctl(SHTTY, 21531UL, (char *)(& val));
  }
#line 2824
  if (purge) {
    {
#line 2825
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2825
      if (! val) {
#line 2825
        goto while_break;
      }
      {
#line 2826
      tmp = read(SHTTY, (void *)(& c), (size_t )1);
#line 2825
      val --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2833
  return (val);
}
}
#line 2837 "/tmp/zsh-5.4.2/Src/utils.c"
int getquery(char *valid_chars , int purge ) 
{ 
  int c ;
  int d___0 ;
  int nl___0 ;
  int isem ;
  int tmp ;
  int tmp___0 ;
  struct ttyinfo ti ;
  int tmp___1 ;
  char *tmp___2 ;
  char buf___7 ;
  mbstate_t mbs ;
  char cc ;
  size_t ret ;
  size_t tmp___3 ;

  {
  {
#line 2840
  nl___0 = 0;
#line 2841
  tmp = strcmp((char const   *)term, "emacs");
  }
#line 2841
  if (tmp) {
#line 2841
    tmp___0 = 0;
  } else {
#line 2841
    tmp___0 = 1;
  }
  {
#line 2841
  isem = tmp___0;
#line 2844
  attachtty(mypgrp);
#line 2846
  gettyinfo(& ti);
#line 2848
  ti.tio.c_lflag &= 4294967287U;
  }
#line 2849
  if (! isem) {
#line 2850
    ti.tio.c_lflag &= 4294967293U;
#line 2851
    ti.tio.c_cc[6] = (cc_t )1;
#line 2852
    ti.tio.c_cc[5] = (cc_t )0;
  }
  {
#line 2859
  settyinfo(& ti);
#line 2861
  tmp___1 = noquery(purge);
  }
#line 2861
  if (tmp___1) {
#line 2862
    if (! isem) {
      {
#line 2863
      settyinfo(& shttyinfo);
      }
    }
    {
#line 2864
    write_loop(SHTTY, "n\n", (size_t )2);
    }
#line 2865
    return ('n');
  }
  {
#line 2868
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2868
    c = read1char(0);
    }
#line 2868
    if (! (c >= 0)) {
#line 2868
      goto while_break;
    }
#line 2869
    if (c == 89) {
#line 2870
      c = 'y';
    } else
#line 2871
    if (c == 78) {
#line 2872
      c = 'n';
    }
#line 2873
    if (! valid_chars) {
#line 2874
      goto while_break;
    }
#line 2875
    if (c == 10) {
#line 2876
      c = (int )*valid_chars;
#line 2877
      nl___0 = 1;
#line 2878
      goto while_break;
    }
    {
#line 2880
    tmp___2 = strchr((char const   *)valid_chars, c);
    }
#line 2880
    if (tmp___2) {
#line 2881
      nl___0 = 1;
#line 2882
      goto while_break;
    }
    {
#line 2884
    zbeep();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2886
  if (c >= 0) {
    {
#line 2887
    buf___7 = (char )c;
#line 2888
    write_loop(SHTTY, (char const   *)(& buf___7), (size_t )1);
    }
  }
#line 2890
  if (nl___0) {
    {
#line 2891
    write_loop(SHTTY, "\n", (size_t )1);
    }
  }
#line 2893
  if (isem) {
#line 2894
    if (c != 10) {
      {
#line 2895
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2895
        d___0 = read1char(1);
        }
#line 2895
        if (d___0 >= 0) {
#line 2895
          if (! (d___0 != 10)) {
#line 2895
            goto while_break___0;
          }
        } else {
#line 2895
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 2897
  if (c != 10) {
#line 2897
    if (! valid_chars) {
#line 2899
      if (opts[117]) {
#line 2899
        if (c >= 0) {
          {
#line 2906
          cc = (char )c;
#line 2907
          memset((void *)(& mbs), 0, sizeof(mbs));
          }
          {
#line 2908
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 2909
            tmp___3 = mbrlen((char const   */* __restrict  */)(& cc), (size_t )1,
                             (mbstate_t */* __restrict  */)(& mbs));
#line 2909
            ret = tmp___3;
            }
#line 2911
            if (ret != 0xfffffffffffffffeUL) {
#line 2912
              goto while_break___1;
            }
            {
#line 2913
            c = read1char(1);
            }
#line 2914
            if (c < 0) {
#line 2915
              goto while_break___1;
            }
#line 2916
            cc = (char )c;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
      {
#line 2920
      write_loop(SHTTY, "\n", (size_t )1);
      }
    }
  }
  {
#line 2923
  settyinfo(& shttyinfo);
  }
#line 2924
  return (c);
}
}
#line 2927 "/tmp/zsh-5.4.2/Src/utils.c"
static int d  ;
#line 2928 "/tmp/zsh-5.4.2/Src/utils.c"
static char *guess  ;
#line 2928 "/tmp/zsh-5.4.2/Src/utils.c"
static char *best  ;
#line 2929 "/tmp/zsh-5.4.2/Src/utils.c"
static Patprog spckpat  ;
#line 2929 "/tmp/zsh-5.4.2/Src/utils.c"
static Patprog spnamepat  ;
#line 2932 "/tmp/zsh-5.4.2/Src/utils.c"
static void spscan(HashNode hn , int scanflags  __attribute__((__unused__)) ) 
{ 
  int nd ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 2937
  if (spckpat) {
    {
#line 2937
    tmp = pattry(spckpat, hn->nam);
    }
#line 2937
    if (tmp) {
#line 2938
      return;
    }
  }
  {
#line 2940
  tmp___0 = strlen((char const   *)guess);
#line 2940
  nd = spdist(hn->nam, guess, (int )tmp___0 / 4 + 1);
  }
#line 2941
  if (nd <= d) {
#line 2942
    best = hn->nam;
#line 2943
    d = nd;
  }
#line 2945
  return;
}
}
#line 2951 "/tmp/zsh-5.4.2/Src/utils.c"
void spckword(char **s , int hist , int cmd , int ask ) 
{ 
  char *t ;
  char *correct_ignore ;
  char ic ;
  int preflen ;
  int autocd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  HashNode tmp___3 ;
  HashNode tmp___4 ;
  HashNode tmp___5 ;
  HashNode tmp___6 ;
  HashNode tmp___7 ;
  HashNode tmp___8 ;
  char *tmp___9 ;
  Cmdnam tmp___10 ;
  int ne ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  Cmdnam tmp___15 ;
  char **pp ;
  char bestcd[4097] ;
  int thisdist ;
  int x ;
  char *u ;
  int tmp___16 ;
  size_t tmp___17 ;
  void *tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;
  char tmp___21 ;
  char *pptbuf ;
  int tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;

  {
#line 2955
  ic = (char )'\000';
#line 2956
  preflen = 0;
#line 2957
  if (cmd) {
#line 2957
    if (opts[7]) {
      {
#line 2957
      tmp = strcmp((char const   *)*s, ".");
      }
#line 2957
      if (tmp) {
        {
#line 2957
        tmp___0 = strcmp((char const   *)*s, "..");
        }
#line 2957
        if (tmp___0) {
#line 2957
          tmp___1 = 1;
        } else {
#line 2957
          tmp___1 = 0;
        }
      } else {
#line 2957
        tmp___1 = 0;
      }
    } else {
#line 2957
      tmp___1 = 0;
    }
  } else {
#line 2957
    tmp___1 = 0;
  }
#line 2957
  autocd = tmp___1;
#line 2959
  if (histdone & 2) {
#line 2960
    return;
  } else
#line 2959
  if ((int )*(*s) == 45) {
#line 2960
    return;
  } else
#line 2959
  if ((int )*(*s) == 37) {
#line 2960
    return;
  }
  {
#line 2961
  tmp___2 = strcmp((char const   *)*s, "in");
  }
#line 2961
  if (! tmp___2) {
#line 2962
    return;
  }
#line 2963
  if (! *(*s + 0)) {
#line 2964
    return;
  } else
#line 2963
  if (! *(*s + 1)) {
#line 2964
    return;
  }
#line 2965
  if (cmd) {
    {
#line 2966
    tmp___4 = (*(shfunctab->getnode))(shfunctab, (char const   *)*s);
    }
#line 2966
    if (tmp___4) {
#line 2971
      return;
    } else {
      {
#line 2966
      tmp___5 = (*(builtintab->getnode))(builtintab, (char const   *)*s);
      }
#line 2966
      if (tmp___5) {
#line 2971
        return;
      } else {
        {
#line 2966
        tmp___6 = (*(cmdnamtab->getnode))(cmdnamtab, (char const   *)*s);
        }
#line 2966
        if (tmp___6) {
#line 2971
          return;
        } else {
          {
#line 2966
          tmp___7 = (*(aliastab->getnode))(aliastab, (char const   *)*s);
          }
#line 2966
          if (tmp___7) {
#line 2971
            return;
          } else {
            {
#line 2966
            tmp___8 = (*(reswdtab->getnode))(reswdtab, (char const   *)*s);
            }
#line 2966
            if (tmp___8) {
#line 2971
              return;
            } else
#line 2972
            if (opts[70]) {
              {
#line 2973
              (*(cmdnamtab->filltable))(cmdnamtab);
#line 2974
              tmp___3 = (*(cmdnamtab->getnode))(cmdnamtab, (char const   *)*s);
              }
#line 2974
              if (tmp___3) {
#line 2975
                return;
              }
            }
          }
        }
      }
    }
  }
#line 2978
  t = *s;
#line 2979
  if ((int )*t == -104) {
#line 2980
    t ++;
  } else
#line 2979
  if ((int )*t == -115) {
#line 2980
    t ++;
  } else
#line 2979
  if ((int )*t == -123) {
#line 2980
    t ++;
  }
  {
#line 2981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2981
    if (! *t) {
#line 2981
      goto while_break;
    }
#line 2982
    if ((int )typtab[(unsigned char )*t] & (1 << 4)) {
#line 2983
      return;
    }
#line 2981
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2984
  best = (char *)((void *)0);
#line 2985
  t = *s;
  {
#line 2985
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2985
    if (! *t) {
#line 2985
      goto while_break___0;
    }
#line 2986
    if ((int )*t == 47) {
#line 2987
      goto while_break___0;
    }
#line 2985
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2988
  if ((int )*(*s) == -104) {
#line 2988
    if (! *t) {
#line 2989
      return;
    }
  }
  {
#line 2991
  correct_ignore = getsparam((char *)"CORRECT_IGNORE");
  }
#line 2991
  if ((unsigned long )correct_ignore != (unsigned long )((void *)0)) {
    {
#line 2992
    correct_ignore = dupstring((char const   *)correct_ignore);
#line 2992
    tokenize(correct_ignore);
#line 2993
    remnulargs(correct_ignore);
#line 2994
    spckpat = patcompile(correct_ignore, 0, (char **)((void *)0));
    }
  } else {
#line 2996
    spckpat = (Patprog )((void *)0);
  }
  {
#line 2998
  correct_ignore = getsparam((char *)"CORRECT_IGNORE_FILE");
  }
#line 2998
  if ((unsigned long )correct_ignore != (unsigned long )((void *)0)) {
    {
#line 2999
    correct_ignore = dupstring((char const   *)correct_ignore);
#line 2999
    tokenize(correct_ignore);
#line 3000
    remnulargs(correct_ignore);
#line 3001
    spnamepat = patcompile(correct_ignore, 0, (char **)((void *)0));
    }
  } else {
#line 3003
    spnamepat = (Patprog )((void *)0);
  }
#line 3005
  if ((int )*(*s) == -123) {
#line 3005
    if (! *t) {
      {
#line 3006
      guess = *s + 1;
#line 3007
      tmp___9 = itype_end((char const   *)guess, 1 << 7, 1);
      }
#line 3007
      if ((unsigned long )tmp___9 == (unsigned long )guess) {
#line 3008
        return;
      }
      {
#line 3009
      ic = (char)-123;
#line 3010
      d = 100;
#line 3011
      scanhashtable(paramtab, 1, 0, 0, & spscan, 0);
      }
    } else {
#line 3005
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3012
  if ((int )*(*s) == -115) {
#line 3013
    if (*t) {
#line 3014
      return;
    }
    {
#line 3015
    guess = *s + 1;
#line 3015
    tmp___10 = hashcmd(guess, pathchecked);
    }
#line 3015
    if (tmp___10) {
#line 3016
      return;
    }
    {
#line 3017
    d = 100;
#line 3018
    ic = (char)-115;
#line 3019
    scanhashtable(aliastab, 1, 0, 0, & spscan, 0);
#line 3020
    scanhashtable(cmdnamtab, 1, 0, 0, & spscan, 0);
    }
  } else {
#line 3022
    guess = *s;
#line 3023
    if ((int )*guess == -104) {
#line 3023
      goto _L;
    } else
#line 3023
    if ((int )*guess == -123) {
      _L: /* CIL Label */ 
#line 3025
      ic = *guess;
#line 3026
      t ++;
#line 3026
      if (! *t) {
#line 3027
        return;
      }
      {
#line 3028
      guess = dupstring((char const   *)guess);
#line 3029
      ne = noerrs;
#line 3030
      noerrs = 2;
#line 3031
      singsub(& guess);
#line 3032
      noerrs = ne;
      }
#line 3033
      if (! guess) {
#line 3034
        return;
      }
      {
#line 3035
      tmp___11 = strlen((char const   *)guess);
#line 3035
      tmp___12 = strlen((char const   *)t);
#line 3035
      preflen = (int )(tmp___11 - tmp___12);
      }
    }
    {
#line 3037
    tmp___13 = unmeta((char const   *)guess);
#line 3037
    tmp___14 = access((char const   *)tmp___13, 0);
    }
#line 3037
    if (tmp___14 == 0) {
#line 3038
      return;
    }
    {
#line 3039
    best = spname(guess);
    }
#line 3040
    if (! *t) {
#line 3040
      if (cmd) {
        {
#line 3041
        tmp___15 = hashcmd(guess, pathchecked);
        }
#line 3041
        if (tmp___15) {
#line 3042
          return;
        }
        {
#line 3043
        d = 100;
#line 3044
        scanhashtable(reswdtab, 1, 0, 0, & spscan, 0);
#line 3045
        scanhashtable(aliastab, 1, 0, 0, & spscan, 0);
#line 3046
        scanhashtable(shfunctab, 1, 0, 0, & spscan, 0);
#line 3047
        scanhashtable(builtintab, 1, 0, 0, & spscan, 0);
#line 3048
        scanhashtable(cmdnamtab, 1, 0, 0, & spscan, 0);
        }
#line 3049
        if (autocd) {
#line 3051
          pp = cdpath;
          {
#line 3051
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3051
            if (! *pp) {
#line 3051
              goto while_break___1;
            }
            {
#line 3058
            thisdist = mindist(*pp, *s, bestcd, 1);
            }
#line 3058
            if (thisdist < d) {
              {
#line 3059
              best = dupstring((char const   *)(bestcd));
#line 3060
              d = thisdist;
              }
            }
#line 3051
            pp ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 3066
  if (errflag) {
#line 3067
    return;
  }
#line 3068
  if (best) {
    {
#line 3068
    tmp___23 = strlen((char const   *)best);
    }
#line 3068
    if ((int )tmp___23 > 1) {
      {
#line 3068
      tmp___24 = strcmp((char const   *)best, (char const   *)guess);
      }
#line 3068
      if (tmp___24) {
#line 3070
        if (ic) {
#line 3072
          if (preflen) {
            {
#line 3074
            tmp___16 = strncmp((char const   *)guess, (char const   *)best, (size_t )preflen);
            }
#line 3074
            if (tmp___16) {
#line 3075
              return;
            }
            {
#line 3077
            tmp___17 = strlen((char const   *)(best + preflen));
#line 3077
            tmp___18 = zhalloc(((size_t )(t - *s) + tmp___17) + 1UL);
#line 3077
            u = (char *)tmp___18;
#line 3078
            strncpy((char */* __restrict  */)u, (char const   */* __restrict  */)*s,
                    (size_t )(t - *s));
#line 3079
            strcpy((char */* __restrict  */)(u + (t - *s)), (char const   */* __restrict  */)(best + preflen));
            }
          } else {
            {
#line 3081
            tmp___19 = strlen((char const   *)best);
#line 3081
            tmp___20 = zhalloc(tmp___19 + 2UL);
#line 3081
            u = (char *)tmp___20;
#line 3082
            *u = (char )'\000';
#line 3083
            strcpy((char */* __restrict  */)(u + 1), (char const   */* __restrict  */)best);
            }
          }
#line 3085
          best = u;
#line 3086
          guess = *s;
#line 3087
          tmp___21 = ztokens[(int )ic - -124];
#line 3087
          *best = tmp___21;
#line 3087
          *guess = tmp___21;
        }
#line 3089
        if (ask) {
          {
#line 3090
          tmp___22 = noquery(0);
          }
#line 3090
          if (tmp___22) {
#line 3091
            x = 'n';
          } else
#line 3092
          if (shout) {
            {
#line 3094
            pptbuf = promptexpand(sprompt, 0, best, guess, (unsigned int *)((void *)0));
#line 3095
            zputs((char const   *)pptbuf, shout);
#line 3096
            free((void *)pptbuf);
#line 3097
            fflush(shout);
#line 3098
            zbeep();
#line 3099
            x = getquery((char *)"nyae", 0);
            }
#line 3100
            if (cmd) {
#line 3100
              if (x == 110) {
#line 3101
                pathchecked = path;
              }
            }
          } else {
#line 3103
            x = 'n';
          }
        } else {
#line 3105
          x = 'y';
        }
#line 3106
        if (x == 121) {
          {
#line 3107
          *s = dupstring((char const   *)best);
          }
#line 3108
          if (hist) {
            {
#line 3109
            hwrep(best);
            }
          }
        } else
#line 3110
        if (x == 97) {
#line 3111
          histdone |= 2;
        } else
#line 3112
        if (x == 101) {
#line 3113
          histdone |= 6;
        }
#line 3115
        if (ic) {
#line 3116
          *(*s) = ic;
        }
      }
    }
  }
#line 3118
  return;
}
}
#line 3127 "/tmp/zsh-5.4.2/Src/utils.c"
static int ztrftimebuf(int *bufsizeptr , int decr ) 
{ 


  {
#line 3130
  if (*bufsizeptr <= decr) {
#line 3131
    return (1);
  }
#line 3132
  *bufsizeptr -= decr;
#line 3133
  return (0);
}
}
#line 3152 "/tmp/zsh-5.4.2/Src/utils.c"
int ztrftime(char *buf___7 , int bufsize , char *fmt , struct tm *tm , long usec ) 
{ 
  int hr12 ;
  int decr ;
  char *fmtstart ;
  char *origbuf ;
  int chr ;
  int tmp ;
  char *tmp___0 ;
  int strip ;
  int digs ;
  char *tmp___1 ;
  char *dstart ;
  char *dend ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int trunc ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char origchar ;
  int size ;
  char *tmp___27 ;
  char *last ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;

  {
#line 3166
  origbuf = buf___7;
  {
#line 3169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3169
    if (! *fmt) {
#line 3169
      goto while_break;
    }
#line 3170
    if ((int )*fmt == -125) {
      {
#line 3171
      chr = (int )*(fmt + 1) ^ 32;
#line 3172
      tmp = ztrftimebuf(& bufsize, 1);
      }
#line 3172
      if (tmp) {
#line 3173
        return (-1);
      }
#line 3174
      tmp___0 = buf___7;
#line 3174
      buf___7 ++;
#line 3174
      *tmp___0 = (char )chr;
#line 3175
      fmt += 2;
    } else
#line 3176
    if ((int )*fmt == 37) {
#line 3178
      digs = 3;
#line 3181
      tmp___1 = fmt;
#line 3181
      fmt ++;
#line 3181
      fmtstart = tmp___1;
#line 3185
      if ((int )*fmt == 45) {
#line 3186
        strip = 1;
#line 3187
        fmt ++;
      } else {
#line 3189
        strip = 0;
      }
#line 3190
      if ((int )typtab[(unsigned char )*fmt] & 1) {
#line 3192
        dstart = fmt;
#line 3193
        dend = fmt + 1;
        {
#line 3194
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3194
          if (! ((int )typtab[(unsigned char )*dend] & 1)) {
#line 3194
            goto while_break___0;
          }
#line 3195
          dend ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 3196
        if ((int )*dend == 46) {
          {
#line 3197
          fmt = dend;
#line 3198
          digs = atoi((char const   *)dstart);
          }
        }
      }
      {
#line 3207
      tmp___2 = ztrftimebuf(& bufsize, 2);
      }
#line 3207
      if (tmp___2) {
#line 3208
        return (-1);
      }
      morefmt: 
#line 3215
      if (! (fmt - fmtstart == 1L)) {
#line 3215
        if (fmt - fmtstart == 2L) {
#line 3215
          if (! strip) {
#line 3215
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 3215
        if (! ((int )*fmt == 46)) {
          {
#line 3216
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3216
            if (*fmt) {
              {
#line 3216
              tmp___3 = strchr("OE^#_-0123456789", (int )*fmt);
              }
#line 3216
              if (! tmp___3) {
#line 3216
                goto while_break___1;
              }
            } else {
#line 3216
              goto while_break___1;
            }
#line 3217
            fmt ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 3218
          if (*fmt) {
#line 3219
            fmt ++;
#line 3220
            goto strftimehandling;
          }
        }
      }
#line 3224
      tmp___4 = fmt;
#line 3224
      fmt ++;
      {
#line 3225
      if ((int )*tmp___4 == 46) {
#line 3225
        goto case_46;
      }
#line 3239
      if ((int )*tmp___4 == 0) {
#line 3239
        goto case_0;
      }
#line 3244
      if ((int )*tmp___4 == 102) {
#line 3244
        goto case_102;
      }
#line 3247
      if ((int )*tmp___4 == 101) {
#line 3247
        goto case_101;
      }
#line 3254
      if ((int )*tmp___4 == 75) {
#line 3254
        goto case_75;
      }
#line 3258
      if ((int )*tmp___4 == 107) {
#line 3258
        goto case_107;
      }
#line 3258
      if ((int )*tmp___4 == 72) {
#line 3258
        goto case_107;
      }
#line 3269
      if ((int )*tmp___4 == 76) {
#line 3269
        goto case_76;
      }
#line 3272
      if ((int )*tmp___4 == 108) {
#line 3272
        goto case_108;
      }
#line 3283
      if ((int )*tmp___4 == 100) {
#line 3283
        goto case_100;
      }
#line 3288
      if ((int )*tmp___4 == 109) {
#line 3288
        goto case_109;
      }
#line 3293
      if ((int )*tmp___4 == 77) {
#line 3293
        goto case_77;
      }
#line 3298
      if ((int )*tmp___4 == 83) {
#line 3298
        goto case_83;
      }
#line 3303
      if ((int )*tmp___4 == 121) {
#line 3303
        goto case_121;
      }
#line 3351
      if ((int )*tmp___4 == 57) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 56) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 55) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 54) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 53) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 52) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 51) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 50) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 49) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 48) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 45) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 95) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 35) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 94) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 79) {
#line 3351
        goto case_57;
      }
#line 3351
      if ((int )*tmp___4 == 69) {
#line 3351
        goto case_57;
      }
#line 3354
      goto strftimehandling;
      case_46: /* CIL Label */ 
      {
#line 3226
      tmp___5 = ztrftimebuf(& bufsize, digs);
      }
#line 3226
      if (tmp___5) {
#line 3227
        return (-1);
      }
#line 3228
      if (digs > 6) {
#line 3229
        digs = 6;
      }
#line 3230
      if (digs < 6) {
#line 3232
        trunc = 5 - digs;
        {
#line 3232
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3232
          if (! trunc) {
#line 3232
            goto while_break___2;
          }
#line 3233
          usec /= 10L;
#line 3232
          trunc --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3234
        usec = (usec + 5L) / 10L;
      }
      {
#line 3236
      sprintf((char */* __restrict  */)buf___7, (char const   */* __restrict  */)"%0*ld",
              digs, usec);
#line 3237
      buf___7 += digs;
      }
#line 3238
      goto switch_break;
      case_0: /* CIL Label */ 
#line 3241
      tmp___6 = buf___7;
#line 3241
      buf___7 ++;
#line 3241
      *tmp___6 = (char )'%';
#line 3242
      fmt --;
#line 3243
      goto switch_break;
      case_102: /* CIL Label */ 
#line 3245
      strip = 1;
      case_101: /* CIL Label */ 
#line 3248
      if (tm->tm_mday > 9) {
#line 3249
        tmp___7 = buf___7;
#line 3249
        buf___7 ++;
#line 3249
        *tmp___7 = (char )(48 + tm->tm_mday / 10);
      } else
#line 3250
      if (! strip) {
#line 3251
        tmp___8 = buf___7;
#line 3251
        buf___7 ++;
#line 3251
        *tmp___8 = (char )' ';
      }
#line 3252
      tmp___9 = buf___7;
#line 3252
      buf___7 ++;
#line 3252
      *tmp___9 = (char )(48 + tm->tm_mday % 10);
#line 3253
      goto switch_break;
      case_75: /* CIL Label */ 
#line 3255
      strip = 1;
      case_107: /* CIL Label */ 
      case_72: /* CIL Label */ 
#line 3259
      if (tm->tm_hour > 9) {
#line 3260
        tmp___10 = buf___7;
#line 3260
        buf___7 ++;
#line 3260
        *tmp___10 = (char )(48 + tm->tm_hour / 10);
      } else
#line 3261
      if (! strip) {
#line 3262
        if ((int )*(fmt + -1) == 72) {
#line 3263
          tmp___11 = buf___7;
#line 3263
          buf___7 ++;
#line 3263
          *tmp___11 = (char )'0';
        } else {
#line 3265
          tmp___12 = buf___7;
#line 3265
          buf___7 ++;
#line 3265
          *tmp___12 = (char )' ';
        }
      }
#line 3267
      tmp___13 = buf___7;
#line 3267
      buf___7 ++;
#line 3267
      *tmp___13 = (char )(48 + tm->tm_hour % 10);
#line 3268
      goto switch_break;
      case_76: /* CIL Label */ 
#line 3270
      strip = 1;
      case_108: /* CIL Label */ 
#line 3273
      hr12 = tm->tm_hour % 12;
#line 3274
      if (hr12 == 0) {
#line 3275
        hr12 = 12;
      }
#line 3276
      if (hr12 > 9) {
#line 3277
        tmp___14 = buf___7;
#line 3277
        buf___7 ++;
#line 3277
        *tmp___14 = (char )'1';
      } else
#line 3278
      if (! strip) {
#line 3279
        tmp___15 = buf___7;
#line 3279
        buf___7 ++;
#line 3279
        *tmp___15 = (char )' ';
      }
#line 3281
      tmp___16 = buf___7;
#line 3281
      buf___7 ++;
#line 3281
      *tmp___16 = (char )(48 + hr12 % 10);
#line 3282
      goto switch_break;
      case_100: /* CIL Label */ 
#line 3284
      if (tm->tm_mday > 9) {
#line 3285
        tmp___17 = buf___7;
#line 3285
        buf___7 ++;
#line 3285
        *tmp___17 = (char )(48 + tm->tm_mday / 10);
      } else
#line 3284
      if (! strip) {
#line 3285
        tmp___17 = buf___7;
#line 3285
        buf___7 ++;
#line 3285
        *tmp___17 = (char )(48 + tm->tm_mday / 10);
      }
#line 3286
      tmp___18 = buf___7;
#line 3286
      buf___7 ++;
#line 3286
      *tmp___18 = (char )(48 + tm->tm_mday % 10);
#line 3287
      goto switch_break;
      case_109: /* CIL Label */ 
#line 3289
      if (tm->tm_mon > 8) {
#line 3290
        tmp___19 = buf___7;
#line 3290
        buf___7 ++;
#line 3290
        *tmp___19 = (char )(48 + (tm->tm_mon + 1) / 10);
      } else
#line 3289
      if (! strip) {
#line 3290
        tmp___19 = buf___7;
#line 3290
        buf___7 ++;
#line 3290
        *tmp___19 = (char )(48 + (tm->tm_mon + 1) / 10);
      }
#line 3291
      tmp___20 = buf___7;
#line 3291
      buf___7 ++;
#line 3291
      *tmp___20 = (char )(48 + (tm->tm_mon + 1) % 10);
#line 3292
      goto switch_break;
      case_77: /* CIL Label */ 
#line 3294
      if (tm->tm_min > 9) {
#line 3295
        tmp___21 = buf___7;
#line 3295
        buf___7 ++;
#line 3295
        *tmp___21 = (char )(48 + tm->tm_min / 10);
      } else
#line 3294
      if (! strip) {
#line 3295
        tmp___21 = buf___7;
#line 3295
        buf___7 ++;
#line 3295
        *tmp___21 = (char )(48 + tm->tm_min / 10);
      }
#line 3296
      tmp___22 = buf___7;
#line 3296
      buf___7 ++;
#line 3296
      *tmp___22 = (char )(48 + tm->tm_min % 10);
#line 3297
      goto switch_break;
      case_83: /* CIL Label */ 
#line 3299
      if (tm->tm_sec > 9) {
#line 3300
        tmp___23 = buf___7;
#line 3300
        buf___7 ++;
#line 3300
        *tmp___23 = (char )(48 + tm->tm_sec / 10);
      } else
#line 3299
      if (! strip) {
#line 3300
        tmp___23 = buf___7;
#line 3300
        buf___7 ++;
#line 3300
        *tmp___23 = (char )(48 + tm->tm_sec / 10);
      }
#line 3301
      tmp___24 = buf___7;
#line 3301
      buf___7 ++;
#line 3301
      *tmp___24 = (char )(48 + tm->tm_sec % 10);
#line 3302
      goto switch_break;
      case_121: /* CIL Label */ 
#line 3304
      if (tm->tm_year > 9) {
#line 3305
        tmp___25 = buf___7;
#line 3305
        buf___7 ++;
#line 3305
        *tmp___25 = (char )(48 + (tm->tm_year / 10) % 10);
      } else
#line 3304
      if (! strip) {
#line 3305
        tmp___25 = buf___7;
#line 3305
        buf___7 ++;
#line 3305
        *tmp___25 = (char )(48 + (tm->tm_year / 10) % 10);
      }
#line 3306
      tmp___26 = buf___7;
#line 3306
      buf___7 ++;
#line 3306
      *tmp___26 = (char )(48 + tm->tm_year % 10);
#line 3307
      goto switch_break;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
      case_35: /* CIL Label */ 
      case_94: /* CIL Label */ 
      case_79: /* CIL Label */ 
      case_69: /* CIL Label */ 
#line 3352
      goto morefmt;
      strftimehandling: 
      switch_default: /* CIL Label */ 
      {
#line 3360
      origchar = *(fmt + -1);
#line 3361
      size = (int )(fmt - fmtstart);
#line 3363
      tmp___28 = zhalloc((size_t )(size + 1));
#line 3363
      tmp___27 = (char *)tmp___28;
#line 3364
      strncpy((char */* __restrict  */)tmp___27, (char const   */* __restrict  */)fmtstart,
              (size_t )size);
#line 3365
      last = fmt - 1;
      }
#line 3366
      if ((int )*last == -125) {
#line 3375
        fmt ++;
#line 3375
        *last = (char )((int )*fmt ^ 32);
      }
      {
#line 3377
      *(tmp___27 + size) = (char )'\000';
#line 3378
      *buf___7 = (char )'\001';
#line 3379
      tmp___29 = strftime((char */* __restrict  */)buf___7, (size_t )(bufsize + 2),
                          (char const   */* __restrict  */)tmp___27, (struct tm  const  */* __restrict  */)tm);
      }
#line 3379
      if (! tmp___29) {
#line 3385
        if (*buf___7) {
#line 3385
          goto _L___0;
        } else
#line 3385
        if ((int )origchar != 112) {
#line 3385
          if ((int )origchar != 80) {
            _L___0: /* CIL Label */ 
#line 3386
            if (*buf___7) {
#line 3387
              *(buf___7 + 0) = (char )'\000';
#line 3388
              return (-1);
            }
#line 3390
            return (0);
          }
        }
      }
      {
#line 3393
      tmp___30 = strlen((char const   *)buf___7);
#line 3393
      decr = (int )tmp___30;
#line 3394
      buf___7 += decr;
#line 3395
      bufsize -= decr - 2;
      }
#line 3398
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 3401
      tmp___31 = ztrftimebuf(& bufsize, 1);
      }
#line 3401
      if (tmp___31) {
#line 3402
        return (-1);
      }
#line 3403
      tmp___32 = buf___7;
#line 3403
      buf___7 ++;
#line 3403
      tmp___33 = fmt;
#line 3403
      fmt ++;
#line 3403
      *tmp___32 = *tmp___33;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3406
  *buf___7 = (char )'\000';
#line 3407
  return ((int )(buf___7 - origbuf));
}
}
#line 3411 "/tmp/zsh-5.4.2/Src/utils.c"
char *zjoin(char **arr , int delim , int heap ) 
{ 
  int len ;
  char **s ;
  char *ret ;
  char *ptr___0 ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
#line 3414
  len = 0;
#line 3417
  s = arr;
  {
#line 3417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3417
    if (! *s) {
#line 3417
      goto while_break;
    }
    {
#line 3418
    tmp = strlen((char const   *)*s);
    }
#line 3418
    if ((int )typtab[(unsigned char )delim] & (1 << 12)) {
#line 3418
      tmp___0 = 1;
    } else {
#line 3418
      tmp___0 = 0;
    }
#line 3418
    len = (int )((size_t )len + ((tmp + 1UL) + (size_t )tmp___0));
#line 3417
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3419
  if (! len) {
#line 3420
    if (heap) {
#line 3420
      tmp___2 = "";
    } else {
      {
#line 3420
      tmp___1 = ztrdup("");
#line 3420
      tmp___2 = (char const   *)tmp___1;
      }
    }
#line 3420
    return ((char *)tmp___2);
  }
#line 3421
  if (heap) {
    {
#line 3421
    tmp___3 = zhalloc((size_t )len);
#line 3421
    tmp___5 = tmp___3;
    }
  } else {
    {
#line 3421
    tmp___4 = zalloc((size_t )len);
#line 3421
    tmp___5 = tmp___4;
    }
  }
#line 3421
  ret = (char *)tmp___5;
#line 3421
  ptr___0 = ret;
#line 3422
  s = arr;
  {
#line 3422
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3422
    if (! *s) {
#line 3422
      goto while_break___0;
    }
    {
#line 3423
    strucpy(& ptr___0, *s);
    }
#line 3424
    if ((int )typtab[(unsigned char )delim] & (1 << 12)) {
#line 3425
      tmp___6 = ptr___0;
#line 3425
      ptr___0 ++;
#line 3425
      *tmp___6 = (char)-125;
#line 3426
      tmp___7 = ptr___0;
#line 3426
      ptr___0 ++;
#line 3426
      *tmp___7 = (char )(delim ^ 32);
    } else {
#line 3429
      tmp___8 = ptr___0;
#line 3429
      ptr___0 ++;
#line 3429
      *tmp___8 = (char )delim;
    }
#line 3422
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3431
  if ((int )typtab[(unsigned char )delim] & (1 << 12)) {
#line 3431
    tmp___9 = 1;
  } else {
#line 3431
    tmp___9 = 0;
  }
#line 3431
  *(ptr___0 + (-1 - tmp___9)) = (char )'\000';
#line 3432
  return (ret);
}
}
#line 3439 "/tmp/zsh-5.4.2/Src/utils.c"
char **colonsplit(char *s , int uniq ) 
{ 
  int ct ;
  char *t ;
  char **ret ;
  char **ptr___0 ;
  char **p ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char **tmp___3 ;
  char *tmp___4 ;

  {
#line 3445
  t = s;
#line 3445
  ct = 0;
  {
#line 3445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3445
    if (! *t) {
#line 3445
      goto while_break;
    }
#line 3446
    if ((int )*t == 58) {
#line 3447
      ct ++;
    }
#line 3445
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3448
  tmp = zalloc(sizeof(char *) * (unsigned long )(ct + 2));
#line 3448
  ret = (char **)tmp;
#line 3448
  ptr___0 = ret;
#line 3450
  t = s;
  }
  {
#line 3451
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3452
    s = t;
    {
#line 3454
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3454
      if (*t) {
#line 3454
        if (! ((int )*t != 58)) {
#line 3454
          goto while_break___1;
        }
      } else {
#line 3454
        goto while_break___1;
      }
#line 3454
      t ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3455
    if (uniq) {
#line 3456
      p = ret;
      {
#line 3456
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3456
        if (! ((unsigned long )p < (unsigned long )ptr___0)) {
#line 3456
          goto while_break___2;
        }
        {
#line 3457
        tmp___0 = strlen((char const   *)*p);
        }
#line 3457
        if ((long )((int )tmp___0) == t - s) {
          {
#line 3457
          tmp___1 = strncmp((char const   *)*p, (char const   *)s, (size_t )(t - s));
          }
#line 3457
          if (! tmp___1) {
#line 3458
            goto cont;
          }
        }
#line 3456
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 3459
    tmp___2 = zalloc((size_t )((t - s) + 1L));
#line 3459
    *ptr___0 = (char *)tmp___2;
#line 3460
    tmp___3 = ptr___0;
#line 3460
    ptr___0 ++;
#line 3460
    ztrncpy(*tmp___3, s, (int )(t - s));
    }
    cont: 
#line 3451
    tmp___4 = t;
#line 3451
    t ++;
#line 3451
    if (! *tmp___4) {
#line 3451
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3464
  *ptr___0 = (char *)((void *)0);
#line 3465
  return (ret);
}
}
#line 3469 "/tmp/zsh-5.4.2/Src/utils.c"
static int skipwsep(char **s ) 
{ 
  char *t ;
  int i ;
  int tmp ;

  {
#line 3472
  t = *s;
#line 3473
  i = 0;
  {
#line 3479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3479
    if (*t) {
#line 3479
      if ((int )*t == -125) {
#line 3479
        tmp = (int )*(t + 1) ^ 32;
      } else {
#line 3479
        tmp = (int )*t;
      }
#line 3479
      if (! ((int )typtab[(unsigned char )tmp] & (1 << 13))) {
#line 3479
        goto while_break;
      }
    } else {
#line 3479
      goto while_break;
    }
#line 3480
    if ((int )*t == -125) {
#line 3481
      t ++;
    }
#line 3482
    t ++;
#line 3483
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3485
  *s = t;
#line 3486
  return (i);
}
}
#line 3500 "/tmp/zsh-5.4.2/Src/utils.c"
char **spacesplit(char *s , int allownull , int heap , int quote___0 ) 
{ 
  char *t ;
  char **ret ;
  char **ptr___0 ;
  int l ;
  int tmp ;
  char *(*dup___0)(char const   * ) ;
  char *(*tmp___0)(char const   *s ) ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char **tmp___4 ;
  char const   *tmp___5 ;
  char **tmp___6 ;
  char *tmp___7 ;
  char *iend ;
  char *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  char **tmp___12 ;
  char **tmp___13 ;
  char **tmp___14 ;

  {
  {
#line 3504
  tmp = wordcount(s, (char *)((void *)0), - (! allownull));
#line 3504
  l = (int )(sizeof(*ret) * (unsigned long )(tmp + 1));
  }
#line 3505
  if (heap) {
#line 3505
    tmp___0 = & dupstring;
  } else {
#line 3505
    tmp___0 = & ztrdup;
  }
#line 3505
  dup___0 = tmp___0;
#line 3508
  if (heap) {
    {
#line 3508
    tmp___1 = hcalloc((size_t )l);
#line 3508
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 3508
    tmp___2 = zshcalloc((size_t )l);
#line 3508
    tmp___3 = tmp___2;
    }
  }
#line 3508
  ret = (char **)tmp___3;
#line 3508
  ptr___0 = ret;
#line 3510
  if (quote___0) {
    {
#line 3515
    s = dupstring((char const   *)s);
    }
  }
  {
#line 3518
  t = s;
#line 3519
  skipwsep(& s);
#line 3520
  mb_charinit();
  }
#line 3521
  if (*s) {
    {
#line 3521
    tmp___7 = itype_end((char const   *)s, 1 << 5, 1);
    }
#line 3521
    if ((unsigned long )tmp___7 != (unsigned long )s) {
#line 3522
      tmp___4 = ptr___0;
#line 3522
      ptr___0 ++;
#line 3522
      if (allownull) {
#line 3522
        tmp___5 = "";
      } else {
#line 3522
        tmp___5 = (char const   *)(nulstring);
      }
      {
#line 3522
      *tmp___4 = (*dup___0)(tmp___5);
      }
    } else {
#line 3521
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3523
  if (! allownull) {
#line 3523
    if ((unsigned long )t != (unsigned long )s) {
      {
#line 3524
      tmp___6 = ptr___0;
#line 3524
      ptr___0 ++;
#line 3524
      *tmp___6 = (*dup___0)("");
      }
    }
  }
  {
#line 3525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3525
    if (! *s) {
#line 3525
      goto while_break;
    }
    {
#line 3526
    tmp___8 = itype_end((char const   *)s, 1 << 5, 1);
#line 3526
    iend = tmp___8;
    }
#line 3527
    if ((unsigned long )iend != (unsigned long )s) {
      {
#line 3528
      s = iend;
#line 3529
      skipwsep(& s);
      }
    } else
#line 3531
    if (quote___0) {
#line 3531
      if ((int )*s == 92) {
        {
#line 3532
        s ++;
#line 3533
        skipwsep(& s);
        }
      }
    }
    {
#line 3535
    t = s;
#line 3536
    findsep(& s, (char *)((void *)0), quote___0);
    }
#line 3537
    if ((unsigned long )s > (unsigned long )t) {
#line 3537
      goto _L___0;
    } else
#line 3537
    if (allownull) {
      _L___0: /* CIL Label */ 
#line 3538
      if (heap) {
        {
#line 3538
        tmp___9 = zhalloc((size_t )((s - t) + 1L));
#line 3538
        tmp___11 = tmp___9;
        }
      } else {
        {
#line 3538
        tmp___10 = zalloc((size_t )((s - t) + 1L));
#line 3538
        tmp___11 = tmp___10;
        }
      }
      {
#line 3538
      *ptr___0 = (char *)tmp___11;
#line 3540
      tmp___12 = ptr___0;
#line 3540
      ptr___0 ++;
#line 3540
      ztrncpy(*tmp___12, t, (int )(s - t));
      }
    } else {
      {
#line 3542
      tmp___13 = ptr___0;
#line 3542
      ptr___0 ++;
#line 3542
      *tmp___13 = (*dup___0)((char const   *)(nulstring));
      }
    }
    {
#line 3543
    t = s;
#line 3544
    skipwsep(& s);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3546
  if (! allownull) {
#line 3546
    if ((unsigned long )t != (unsigned long )s) {
      {
#line 3547
      tmp___14 = ptr___0;
#line 3547
      ptr___0 ++;
#line 3547
      *tmp___14 = (*dup___0)("");
      }
    }
  }
#line 3548
  *ptr___0 = (char *)((void *)0);
#line 3549
  return (ret);
}
}
#line 3573 "/tmp/zsh-5.4.2/Src/utils.c"
static int findsep(char **s , char *sep , int quote___0 ) 
{ 
  int i ;
  int ilen ;
  char *t ;
  char *tt ;
  convchar_t c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3582
  mb_charinit();
  }
#line 3583
  if (! sep) {
#line 3584
    t = *s;
    {
#line 3584
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3584
      if (! *t) {
#line 3584
        goto while_break;
      }
#line 3585
      if (quote___0) {
#line 3585
        if ((int )*t == 92) {
#line 3586
          if ((int )*(t + 1) == 92) {
            {
#line 3587
            chuck(t);
#line 3588
            ilen = 1;
            }
#line 3589
            goto __Cont;
          } else {
            {
#line 3591
            ilen = mb_metacharlenconv((char const   *)(t + 1), & c);
#line 3592
            tmp = wcsitype((wchar_t )c, 1 << 5);
            }
#line 3592
            if (tmp) {
              {
#line 3593
              chuck(t);
              }
            } else {
#line 3597
              if ((int )typtab[(unsigned char )*t] & (1 << 5)) {
#line 3598
                goto while_break;
              }
#line 3599
              ilen = 1;
            }
          }
        } else {
#line 3585
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 3603
        ilen = mb_metacharlenconv((char const   *)t, & c);
#line 3604
        tmp___0 = wcsitype((wchar_t )c, 1 << 5);
        }
#line 3604
        if (tmp___0) {
#line 3605
          goto while_break;
        }
      }
      __Cont: /* CIL Label */ 
#line 3584
      t += ilen;
    }
    while_break: /* CIL Label */ ;
    }
#line 3608
    i = (unsigned long )t > (unsigned long )*s;
#line 3609
    *s = t;
#line 3610
    return (i);
  }
#line 3612
  if (! *(sep + 0)) {
#line 3617
    if (*(*s)) {
      {
#line 3618
      tmp___1 = mb_metacharlenconv((char const   *)*s, (wint_t *)((void *)0));
#line 3618
      *s += tmp___1;
      }
#line 3619
      return (1);
    }
#line 3621
    return (-1);
  }
#line 3623
  i = 0;
  {
#line 3623
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3623
    if (! *(*s)) {
#line 3623
      goto while_break___0;
    }
#line 3629
    t = sep;
#line 3629
    tt = *s;
    {
#line 3629
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3629
      if (*t) {
#line 3629
        if (*tt) {
#line 3629
          if (! ((int )*t == (int )*tt)) {
#line 3629
            goto while_break___1;
          }
        } else {
#line 3629
          goto while_break___1;
        }
      } else {
#line 3629
        goto while_break___1;
      }
#line 3629
      t ++;
#line 3629
      tt ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3630
    if (! *t) {
#line 3631
      return (i > 0);
    }
    {
#line 3632
    tmp___2 = mb_metacharlenconv((char const   *)*s, (wint_t *)((void *)0));
#line 3632
    *s += tmp___2;
#line 3623
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3634
  return (-1);
}
}
#line 3638 "/tmp/zsh-5.4.2/Src/utils.c"
char *findword(char **s , char *sep ) 
{ 
  char *r ;
  char *t ;
  int sl ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  convchar_t c ;
  int tmp___2 ;

  {
#line 3644
  if (! *(*s)) {
#line 3645
    return ((char *)((void *)0));
  }
#line 3647
  if (sep) {
    {
#line 3648
    tmp = strlen((char const   *)sep);
#line 3648
    sl = (int )tmp;
#line 3649
    r = *s;
    }
    {
#line 3650
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3650
      tmp___1 = findsep(s, sep, 0);
      }
#line 3650
      if (tmp___1) {
#line 3650
        goto while_break;
      }
#line 3651
      tmp___0 = *s + sl;
#line 3651
      *s = tmp___0;
#line 3651
      r = tmp___0;
    }
    while_break: /* CIL Label */ ;
    }
#line 3653
    return (r);
  }
  {
#line 3655
  mb_charinit();
#line 3656
  t = *s;
  }
  {
#line 3656
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3656
    if (! *t) {
#line 3656
      goto while_break___0;
    }
    {
#line 3658
    sl = mb_metacharlenconv((char const   *)t, & c);
#line 3659
    tmp___2 = wcsitype((wchar_t )c, 1 << 5);
    }
#line 3659
    if (! tmp___2) {
#line 3660
      goto while_break___0;
    }
#line 3656
    t += sl;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3662
  *s = t;
#line 3663
  findsep(s, sep, 0);
  }
#line 3664
  return (t);
}
}
#line 3668 "/tmp/zsh-5.4.2/Src/utils.c"
int wordcount(char *s , char *sep , int mul ) 
{ 
  int r ;
  int sl ;
  int c ;
  size_t tmp ;
  char *t ;
  char *tmp___0 ;
  char *ie ;
  char *tmp___1 ;

  {
#line 3673
  if (sep) {
    {
#line 3674
    r = 1;
#line 3675
    tmp = strlen((char const   *)sep);
#line 3675
    sl = (int )tmp;
    }
    {
#line 3676
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3676
      c = findsep(& s, sep, 0);
      }
#line 3676
      if (! (c >= 0)) {
#line 3676
        goto while_break;
      }
#line 3677
      if (c) {
#line 3677
        goto _L;
      } else
#line 3677
      if (mul) {
        _L: /* CIL Label */ 
#line 3677
        if (sl) {
#line 3678
          r ++;
        } else
#line 3677
        if (*(s + sl)) {
#line 3678
          r ++;
        }
      }
#line 3676
      s += sl;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 3680
    t = s;
#line 3682
    r = 0;
#line 3683
    if (mul <= 0) {
      {
#line 3684
      skipwsep(& s);
      }
    }
#line 3685
    if (*s) {
      {
#line 3685
      tmp___0 = itype_end((char const   *)s, 1 << 5, 1);
      }
#line 3685
      if ((unsigned long )tmp___0 != (unsigned long )s) {
#line 3687
        r ++;
      } else {
#line 3685
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 3685
    if (mul < 0) {
#line 3685
      if ((unsigned long )t != (unsigned long )s) {
#line 3687
        r ++;
      }
    }
    {
#line 3688
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3688
      if (! *s) {
#line 3688
        goto while_break___0;
      }
      {
#line 3689
      tmp___1 = itype_end((char const   *)s, 1 << 5, 1);
#line 3689
      ie = tmp___1;
      }
#line 3690
      if ((unsigned long )ie != (unsigned long )s) {
#line 3691
        s = ie;
#line 3692
        if (mul <= 0) {
          {
#line 3693
          skipwsep(& s);
          }
        }
      }
      {
#line 3695
      findsep(& s, (char *)((void *)0), 0);
#line 3696
      t = s;
      }
#line 3697
      if (mul <= 0) {
        {
#line 3698
        skipwsep(& s);
        }
      }
#line 3688
      r ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3700
    if (mul < 0) {
#line 3700
      if ((unsigned long )t != (unsigned long )s) {
#line 3701
        r ++;
      }
    }
  }
#line 3703
  return (r);
}
}
#line 3707 "/tmp/zsh-5.4.2/Src/utils.c"
char *sepjoin(char **s , char *sep , int heap ) 
{ 
  char *r ;
  char *p ;
  char **t ;
  int l ;
  int sl ;
  char sepbuf[2] ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 3714
  if (! *s) {
#line 3715
    if (heap) {
#line 3715
      tmp___0 = "";
    } else {
      {
#line 3715
      tmp = ztrdup("");
#line 3715
      tmp___0 = (char const   *)tmp;
      }
    }
#line 3715
    return ((char *)tmp___0);
  }
#line 3716
  if (! sep) {
#line 3718
    if (ifs) {
#line 3718
      if ((int )*ifs != 32) {
        {
#line 3719
        mb_charinit();
#line 3720
        tmp___1 = mb_metacharlenconv((char const   *)ifs, (wint_t *)((void *)0));
#line 3720
        sep = dupstrpfx((char const   *)ifs, tmp___1);
        }
      } else {
#line 3718
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 3722
      sep = sepbuf;
#line 3722
      p = sep;
#line 3723
      tmp___2 = p;
#line 3723
      p ++;
#line 3723
      *tmp___2 = (char )' ';
#line 3724
      *p = (char )'\000';
    }
  }
  {
#line 3727
  tmp___3 = strlen((char const   *)sep);
#line 3727
  sl = (int )tmp___3;
#line 3728
  t = s;
#line 3728
  l = 1 - sl;
  }
  {
#line 3728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3728
    if (! *t) {
#line 3728
      goto while_break;
    }
    {
#line 3728
    tmp___4 = strlen((char const   *)*t);
#line 3728
    l = (int )((size_t )l + (tmp___4 + (size_t )sl));
#line 3728
    t ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3729
  if (heap) {
    {
#line 3729
    tmp___5 = zhalloc((size_t )l);
#line 3729
    tmp___7 = tmp___5;
    }
  } else {
    {
#line 3729
    tmp___6 = zalloc((size_t )l);
#line 3729
    tmp___7 = tmp___6;
    }
  }
#line 3729
  p = (char *)tmp___7;
#line 3729
  r = p;
#line 3730
  t = s;
  {
#line 3731
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3731
    if (! *t) {
#line 3731
      goto while_break___0;
    }
    {
#line 3732
    strucpy(& p, *t);
#line 3733
    t ++;
    }
#line 3733
    if (*t) {
      {
#line 3734
      strucpy(& p, sep);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3736
  *p = (char )'\000';
#line 3737
  return (r);
}
}
#line 3741 "/tmp/zsh-5.4.2/Src/utils.c"
char **sepsplit(char *s , char *sep , int allownull , int heap ) 
{ 
  int n ;
  int sl ;
  char *t ;
  char *tt ;
  char **r ;
  char **p ;
  char **tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;

  {
#line 3748
  if ((int )*(s + 0) == -95) {
#line 3748
    if (! *(s + 1)) {
#line 3749
      s ++;
    }
  }
#line 3751
  if (! sep) {
    {
#line 3752
    tmp = spacesplit(s, allownull, heap, 0);
    }
#line 3752
    return (tmp);
  }
  {
#line 3754
  tmp___0 = strlen((char const   *)sep);
#line 3754
  sl = (int )tmp___0;
#line 3755
  n = wordcount(s, sep, 1);
  }
#line 3756
  if (heap) {
    {
#line 3756
    tmp___1 = zhalloc((unsigned long )(n + 1) * sizeof(char *));
#line 3756
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 3756
    tmp___2 = zalloc((unsigned long )(n + 1) * sizeof(char *));
#line 3756
    tmp___3 = tmp___2;
    }
  }
#line 3756
  p = (char **)tmp___3;
#line 3756
  r = p;
#line 3759
  t = s;
  {
#line 3759
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3759
    tmp___7 = n;
#line 3759
    n --;
#line 3759
    if (! tmp___7) {
#line 3759
      goto while_break;
    }
    {
#line 3760
    tt = t;
#line 3761
    findsep(& t, sep, 0);
    }
#line 3762
    if (heap) {
      {
#line 3762
      tmp___4 = zhalloc((size_t )((t - tt) + 1L));
#line 3762
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 3762
      tmp___5 = zalloc((size_t )((t - tt) + 1L));
#line 3762
      tmp___6 = tmp___5;
      }
    }
    {
#line 3762
    *p = (char *)tmp___6;
#line 3764
    strncpy((char */* __restrict  */)*p, (char const   */* __restrict  */)tt, (size_t )(t - tt));
#line 3765
    *(*p + (t - tt)) = (char )'\000';
#line 3766
    p ++;
#line 3767
    t += sl;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3769
  *p = (char *)((void *)0);
#line 3771
  return (r);
}
}
#line 3777 "/tmp/zsh-5.4.2/Src/utils.c"
Shfunc getshfunc(char *nam ) 
{ 
  HashNode tmp ;

  {
  {
#line 3780
  tmp = (*(shfunctab->getnode))(shfunctab, (char const   *)nam);
  }
#line 3780
  return ((Shfunc )tmp);
}
}
#line 3796 "/tmp/zsh-5.4.2/Src/utils.c"
char **subst_string_by_func(Shfunc func , char *arg1 , char *orig ) 
{ 
  int osc ;
  int osm ;
  int old_incompfunc ;
  LinkList l ;
  LinkList tmp ;
  char **ret ;
  int tmp___0 ;

  {
  {
#line 3799
  osc = sfcontext;
#line 3799
  osm = stopmsg;
#line 3799
  old_incompfunc = incompfunc;
#line 3800
  tmp = newlinklist();
#line 3800
  l = tmp;
#line 3803
  insertlinknode(l, l->list.last, (void *)func->node.nam);
  }
#line 3804
  if (arg1) {
    {
#line 3805
    insertlinknode(l, l->list.last, (void *)arg1);
    }
  }
  {
#line 3806
  insertlinknode(l, l->list.last, (void *)orig);
#line 3807
  sfcontext = 7;
#line 3808
  incompfunc = 0;
#line 3810
  tmp___0 = doshfunc(func, l, 1);
  }
#line 3810
  if (tmp___0) {
#line 3811
    ret = (char **)((void *)0);
  } else {
    {
#line 3813
    ret = getaparam((char *)"reply");
    }
  }
#line 3815
  sfcontext = osc;
#line 3816
  stopmsg = osm;
#line 3817
  incompfunc = old_incompfunc;
#line 3818
  return (ret);
}
}
#line 3828 "/tmp/zsh-5.4.2/Src/utils.c"
char **subst_string_by_hook(char *name , char *arg1 , char *orig ) 
{ 
  Shfunc func ;
  char **ret ;
  char **arrptr ;
  int namlen ;
  size_t tmp ;
  char *arrnam ;
  void *tmp___0 ;

  {
  {
#line 3832
  ret = (char **)((void *)0);
#line 3834
  func = getshfunc(name);
  }
#line 3834
  if (func) {
    {
#line 3835
    ret = subst_string_by_func(func, arg1, orig);
    }
  }
#line 3838
  if (! ret) {
    {
#line 3840
    tmp = strlen((char const   *)name);
#line 3840
    namlen = (int )tmp;
#line 3841
    tmp___0 = zhalloc(sizeof(char ) * (unsigned long )(namlen + 11));
#line 3841
    arrnam = (char *)tmp___0;
#line 3842
    memcpy((void */* __restrict  */)arrnam, (void const   */* __restrict  */)name,
           (size_t )namlen);
#line 3843
    memcpy((void */* __restrict  */)(arrnam + namlen), (void const   */* __restrict  */)"_functions",
           (size_t )11);
#line 3845
    arrptr = getaparam(arrnam);
    }
#line 3845
    if (arrptr) {
      {
#line 3847
      arrptr = arrdup(arrptr);
      }
      {
#line 3848
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3848
        if (! *arrptr) {
#line 3848
          goto while_break;
        }
        {
#line 3849
        func = getshfunc(*arrptr);
        }
#line 3849
        if (func) {
          {
#line 3850
          ret = subst_string_by_func(func, arg1, orig);
          }
#line 3851
          if (ret) {
#line 3852
            goto while_break;
          }
        }
#line 3848
        arrptr ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 3858
  return (ret);
}
}
#line 3862 "/tmp/zsh-5.4.2/Src/utils.c"
char **mkarray(char *s ) 
{ 
  char **t ;
  unsigned long tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 3865
  if (s) {
#line 3865
    tmp = 2UL * sizeof(s);
  } else {
#line 3865
    tmp = sizeof(s);
  }
  {
#line 3865
  tmp___0 = zalloc(tmp);
#line 3865
  t = (char **)tmp___0;
#line 3867
  tmp___1 = s;
#line 3867
  *t = tmp___1;
  }
#line 3867
  if (tmp___1) {
#line 3868
    *(t + 1) = (char *)((void *)0);
  }
#line 3869
  return (t);
}
}
#line 3873 "/tmp/zsh-5.4.2/Src/utils.c"
char **hmkarray(char *s ) 
{ 
  char **t ;
  unsigned long tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 3876
  if (s) {
#line 3876
    tmp = 2UL * sizeof(s);
  } else {
#line 3876
    tmp = sizeof(s);
  }
  {
#line 3876
  tmp___0 = zhalloc(tmp);
#line 3876
  t = (char **)tmp___0;
#line 3878
  tmp___1 = s;
#line 3878
  *t = tmp___1;
  }
#line 3878
  if (tmp___1) {
#line 3879
    *(t + 1) = (char *)((void *)0);
  }
#line 3880
  return (t);
}
}
#line 3884 "/tmp/zsh-5.4.2/Src/utils.c"
void zbeep(void) 
{ 
  char *vb ;
  int len ;
  sigset_t oset ;

  {
  {
#line 3888
  queueing_enabled ++;
#line 3889
  vb = getsparam_u((char *)"ZBEEP");
  }
#line 3889
  if (vb) {
    {
#line 3891
    vb = getkeystring(vb, & len, 7, (int *)((void *)0));
#line 3892
    write_loop(SHTTY, (char const   *)vb, (size_t )len);
    }
  } else
#line 3893
  if (opts[22]) {
    {
#line 3894
    write_loop(SHTTY, "\a", (size_t )1);
    }
  }
  {
#line 3895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3895
    queueing_enabled --;
#line 3895
    if (! queueing_enabled) {
      {
#line 3895
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 3895
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3895
          if (! (queue_front != queue_rear)) {
#line 3895
            goto while_break___1;
          }
          {
#line 3895
          queue_front = (queue_front + 1) % 128;
#line 3895
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3895
          zhandler(signal_queue[queue_front]);
#line 3895
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3895
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 3895
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3896
  return;
}
}
#line 3899 "/tmp/zsh-5.4.2/Src/utils.c"
void freearray(char **s ) 
{ 
  char **t ;
  char **tmp ;

  {
#line 3902
  t = s;
  {
#line 3906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3906
    if (! *s) {
#line 3906
      goto while_break;
    }
    {
#line 3907
    tmp = s;
#line 3907
    s ++;
#line 3907
    zsfree(*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3908
  free((void *)t);
  }
#line 3909
  return;
}
}
#line 3912 "/tmp/zsh-5.4.2/Src/utils.c"
int equalsplit(char *s , char **t ) 
{ 
  char *tmp ;

  {
  {
#line 3915
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3915
    if (*s) {
#line 3915
      if (! ((int )*s != 61)) {
#line 3915
        goto while_break;
      }
    } else {
#line 3915
      goto while_break;
    }
#line 3915
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3916
  if ((int )*s == 61) {
#line 3917
    tmp = s;
#line 3917
    s ++;
#line 3917
    *tmp = (char )'\000';
#line 3918
    *t = s;
#line 3919
    return (1);
  }
#line 3921
  return (0);
}
}
#line 3929 "/tmp/zsh-5.4.2/Src/utils.c"
static int typtab_flags  =    0;
#line 3934 "/tmp/zsh-5.4.2/Src/utils.c"
void inittyptab(void) 
{ 
  int t0 ;
  char *s ;
  short tmp ;
  short tmp___0 ;
  char const   *tmp___1 ;
  int c ;
  int tmp___2 ;
  int c___0 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  sigset_t oset ;

  {
#line 3940
  if (! (typtab_flags & 1)) {
#line 3941
    typtab_flags = 1;
#line 3942
    if (opts[93]) {
#line 3942
      if (opts[160]) {
#line 3943
        typtab_flags |= 2;
      }
    }
  }
  {
#line 3946
  queueing_enabled ++;
#line 3948
  memset((void *)(typtab), 0, sizeof(typtab));
#line 3949
  t0 = 0;
  }
  {
#line 3949
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3949
    if (! (t0 != 32)) {
#line 3949
      goto while_break;
    }
#line 3950
    tmp = (short )(1 << 9);
#line 3950
    typtab[t0 + 128] = tmp;
#line 3950
    typtab[t0] = tmp;
#line 3949
    t0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3951
  typtab[127] = (short )(1 << 9);
#line 3952
  t0 = '0';
  {
#line 3952
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3952
    if (! (t0 <= 57)) {
#line 3952
      goto while_break___0;
    }
#line 3953
    typtab[t0] = (short )((((1 | (1 << 1)) | (1 << 10)) | (1 << 7)) | (1 << 8));
#line 3952
    t0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3954
  t0 = 'a';
  {
#line 3954
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3954
    if (! (t0 <= 122)) {
#line 3954
      goto while_break___1;
    }
#line 3955
    tmp___0 = (short )(((((1 << 6) | (1 << 1)) | (1 << 7)) | (1 << 8)) | (1 << 10));
#line 3955
    typtab[(t0 - 97) + 65] = tmp___0;
#line 3955
    typtab[t0] = tmp___0;
#line 3954
    t0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3969
  typtab['_'] = (short )((1 << 7) | (1 << 8));
#line 3970
  typtab[(unsigned char)155] = (short )(1 << 8);
#line 3970
  typtab['.'] = typtab[(unsigned char)155];
#line 3970
  typtab['-'] = typtab['.'];
#line 3971
  typtab[' '] = (short )((int )typtab[32] | ((1 << 2) | (1 << 3)));
#line 3972
  typtab['\t'] = (short )((int )typtab[9] | ((1 << 2) | (1 << 3)));
#line 3973
  typtab['\n'] = (short )((int )typtab[10] | (1 << 3));
#line 3974
  typtab['\000'] = (short )((int )typtab[0] | (1 << 12));
#line 3975
  typtab[(unsigned char)131] = (short )((int )typtab[(unsigned char)131] | (1 << 12));
#line 3976
  typtab[(unsigned char)162] = (short )((int )typtab[(unsigned char)162] | (1 << 12));
#line 3977
  t0 = 132;
  {
#line 3977
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3977
    if (! (t0 <= 156)) {
#line 3977
      goto while_break___2;
    }
#line 3978
    typtab[t0] = (short )((int )typtab[t0] | ((1 << 4) | (1 << 12)));
#line 3977
    t0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3979
  t0 = 157;
  {
#line 3979
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3979
    if (! (t0 <= 161)) {
#line 3979
      goto while_break___3;
    }
#line 3980
    typtab[t0] = (short )((int )typtab[t0] | (((1 << 4) | (1 << 12)) | (1 << 14)));
#line 3979
    t0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3981
  if (ifs) {
#line 3981
    s = ifs;
  } else {
#line 3981
    if (emulation & ((1 << 2) | (1 << 3))) {
#line 3981
      tmp___1 = " \t\n";
    } else {
#line 3981
      tmp___1 = " \t\n\203 ";
    }
#line 3981
    s = (char *)tmp___1;
  }
  {
#line 3981
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 3981
    if (! *s) {
#line 3981
      goto while_break___4;
    }
#line 3983
    if ((int )*s == -125) {
#line 3983
      s ++;
#line 3983
      tmp___2 = (int )*s ^ 32;
    } else {
#line 3983
      tmp___2 = (int )*s;
    }
#line 3983
    c = (int )((unsigned char )tmp___2);
#line 3985
    if (! ((c & -128) == 0)) {
#line 3987
      goto __Cont;
    }
#line 3990
    if ((int )typtab[(unsigned char )c] & (1 << 3)) {
#line 3991
      if ((int )*(s + 1) == c) {
#line 3992
        s ++;
      } else {
#line 3994
        typtab[c] = (short )((int )typtab[c] | (1 << 13));
      }
    }
#line 3996
    typtab[c] = (short )((int )typtab[c] | (1 << 5));
    __Cont: /* CIL Label */ 
#line 3981
    s ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 3998
  if (wordchars) {
#line 3998
    s = wordchars;
  } else {
#line 3998
    s = (char *)"*?_-.[]~=/&;!#$%^(){}<>";
  }
  {
#line 3998
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 3998
    if (! *s) {
#line 3998
      goto while_break___5;
    }
#line 3999
    if ((int )*s == -125) {
#line 3999
      s ++;
#line 3999
      tmp___3 = (int )*s ^ 32;
    } else {
#line 3999
      tmp___3 = (int )*s;
    }
#line 3999
    c___0 = (int )((unsigned char )tmp___3);
#line 4001
    if (! ((c___0 & -128) == 0)) {
#line 4009
      goto __Cont___0;
    }
#line 4012
    typtab[c___0] = (short )((int )typtab[c___0] | (1 << 10));
    __Cont___0: /* CIL Label */ 
#line 3998
    s ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 4015
  set_widearray(wordchars, & wordchars_wide);
  }
#line 4016
  if (ifs) {
#line 4016
    tmp___5 = (char const   *)ifs;
  } else {
#line 4016
    if (emulation & ((1 << 2) | (1 << 3))) {
#line 4016
      tmp___4 = " \t\n";
    } else {
#line 4016
      tmp___4 = " \t\n\203 ";
    }
#line 4016
    tmp___5 = tmp___4;
  }
  {
#line 4016
  set_widearray((char *)tmp___5, & ifs_wide);
#line 4019
  s = (char *)"#$^*()=|{}[]`<>?~;&\n\t \\\'\"";
  }
  {
#line 4019
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 4019
    if (! *s) {
#line 4019
      goto while_break___6;
    }
#line 4020
    typtab[(unsigned char )*s] = (short )((int )typtab[(unsigned char )*s] | (1 << 11));
#line 4019
    s ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 4021
  if (typtab_flags & 4) {
#line 4022
    typtab[(unsigned char )','] = (short )((int )typtab[(unsigned char)44] | (1 << 11));
  }
#line 4023
  if (opts[18]) {
#line 4023
    if (bangchar) {
#line 4023
      if (typtab_flags & 2) {
#line 4024
        typtab_flags |= 8;
#line 4025
        typtab[bangchar] = (short )((int )typtab[bangchar] | (1 << 11));
      } else {
#line 4027
        typtab_flags &= -9;
      }
    } else {
#line 4027
      typtab_flags &= -9;
    }
  } else {
#line 4027
    typtab_flags &= -9;
  }
#line 4028
  s = (char *)"#^*()|[]<>?~\\";
  {
#line 4028
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 4028
    if (! *s) {
#line 4028
      goto while_break___7;
    }
#line 4029
    typtab[(unsigned char )*s] = (short )((int )typtab[(unsigned char )*s] | (1 << 15));
#line 4028
    s ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 4031
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 4031
    queueing_enabled --;
#line 4031
    if (! queueing_enabled) {
      {
#line 4031
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 4031
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 4031
          if (! (queue_front != queue_rear)) {
#line 4031
            goto while_break___10;
          }
          {
#line 4031
          queue_front = (queue_front + 1) % 128;
#line 4031
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 4031
          zhandler(signal_queue[queue_front]);
#line 4031
          signal_setmask(oset);
          }
        }
        while_break___10: /* CIL Label */ ;
        }
#line 4031
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 4031
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 4032
  return;
}
}
#line 4035 "/tmp/zsh-5.4.2/Src/utils.c"
void makecommaspecial(int yesno ) 
{ 


  {
#line 4038
  if (yesno != 0) {
#line 4039
    typtab_flags |= 4;
#line 4040
    typtab[(unsigned char )','] = (short )((int )typtab[(unsigned char)44] | (1 << 11));
  } else {
#line 4042
    typtab_flags &= -5;
#line 4043
    typtab[(unsigned char )','] = (short )((int )typtab[(unsigned char)44] & ~ (1 << 11));
  }
#line 4045
  return;
}
}
#line 4048 "/tmp/zsh-5.4.2/Src/utils.c"
void makebangspecial(int yesno ) 
{ 


  {
#line 4055
  if (yesno == 0) {
#line 4056
    typtab[bangchar] = (short )((int )typtab[bangchar] & ~ (1 << 11));
  } else
#line 4057
  if (typtab_flags & 8) {
#line 4058
    typtab[bangchar] = (short )((int )typtab[bangchar] | (1 << 11));
  }
#line 4060
  return;
}
}
#line 4067 "/tmp/zsh-5.4.2/Src/utils.c"
int wcsiblank(wint_t wc ) 
{ 
  int tmp ;

  {
  {
#line 4070
  tmp = iswspace(wc);
  }
#line 4070
  if (tmp) {
#line 4070
    if (wc != 10U) {
#line 4071
      return (1);
    }
  }
#line 4072
  return (0);
}
}
#line 4086 "/tmp/zsh-5.4.2/Src/utils.c"
int wcsitype(wchar_t c , int itype ) 
{ 
  int len ;
  mbstate_t mbs ;
  char *outstr ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  wchar_t *tmp___5 ;
  int tmp___6 ;
  wchar_t *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 4091
  tmp = __ctype_get_mb_cur_max();
#line 4091
  tmp___0 = zhalloc(sizeof(char ) * tmp);
#line 4091
  outstr = (char *)tmp___0;
  }
#line 4093
  if (! opts[117]) {
#line 4094
    return ((int )typtab[(unsigned char )c] & itype);
  }
  {
#line 4103
  memset((void *)(& mbs), 0, sizeof(mbs));
#line 4104
  tmp___1 = wcrtomb((char */* __restrict  */)outstr, c, (mbstate_t */* __restrict  */)(& mbs));
#line 4104
  len = (int )tmp___1;
  }
#line 4106
  if (len == 0) {
#line 4108
    return ((int )typtab[(unsigned char)0] & itype);
  } else
#line 4109
  if (len == 1) {
#line 4109
    if (((int )*(outstr + 0) & -128) == 0) {
#line 4110
      return ((int )typtab[(unsigned char )*(outstr + 0)] & itype);
    } else {
#line 4109
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 4113
    if (itype == 1 << 7) {
#line 4113
      goto case_exp;
    }
#line 4118
    if (itype == 1 << 10) {
#line 4118
      goto case_exp___0;
    }
#line 4132
    if (itype == 1 << 5) {
#line 4132
      goto case_exp___1;
    }
#line 4135
    goto switch_default;
    case_exp: /* CIL Label */ 
#line 4114
    if (! opts[133]) {
#line 4115
      return (0);
    }
    {
#line 4116
    tmp___2 = iswalnum((wint_t )c);
    }
#line 4116
    return (tmp___2);
    case_exp___0: /* CIL Label */ 
    {
#line 4119
    tmp___3 = iswalnum((wint_t )c);
    }
#line 4119
    if (tmp___3) {
#line 4120
      return (1);
    }
#line 4128
    if (c != 0) {
      {
#line 4128
      tmp___4 = wcwidth(c);
      }
#line 4128
      if (tmp___4 == 0) {
#line 4129
        return (1);
      }
    }
    {
#line 4130
    tmp___5 = wmemchr((wchar_t const   *)wordchars_wide.chars, c, wordchars_wide.len);
    }
#line 4130
    if (tmp___5) {
#line 4130
      tmp___6 = 1;
    } else {
#line 4130
      tmp___6 = 0;
    }
#line 4130
    return (tmp___6);
    case_exp___1: /* CIL Label */ 
    {
#line 4133
    tmp___7 = wmemchr((wchar_t const   *)ifs_wide.chars, c, ifs_wide.len);
    }
#line 4133
    if (tmp___7) {
#line 4133
      tmp___8 = 1;
    } else {
#line 4133
      tmp___8 = 0;
    }
#line 4133
    return (tmp___8);
    switch_default: /* CIL Label */ 
    {
#line 4136
    tmp___9 = iswalnum((wint_t )c);
    }
#line 4136
    return (tmp___9);
    switch_break: /* CIL Label */ ;
    }
  }
}
}
#line 4160 "/tmp/zsh-5.4.2/Src/utils.c"
char *itype_end(char const   *ptr___0 , int itype , int once ) 
{ 
  int len ;
  wint_t wc ;
  int chr ;
  int tmp ;
  int tmp___0 ;
  wchar_t *tmp___1 ;
  wchar_t *tmp___2 ;
  int tmp___3 ;
  int chr___0 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 4164
  if (opts[117]) {
#line 4164
    if (itype != 1 << 7) {
#line 4164
      goto _L___1;
    } else
#line 4164
    if (! opts[133]) {
      _L___1: /* CIL Label */ 
      {
#line 4166
      mb_charinit();
      }
      {
#line 4167
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4167
        if (! *ptr___0) {
#line 4167
          goto while_break;
        }
#line 4169
        if ((int )typtab[(unsigned char )*ptr___0] & (1 << 4)) {
#line 4171
          len = 1;
#line 4172
          if (! ((int )typtab[(unsigned char )*ptr___0] & itype)) {
#line 4173
            goto while_break;
          }
        } else {
          {
#line 4176
          len = mb_metacharlenconv(ptr___0, & wc);
          }
#line 4178
          if (! len) {
#line 4179
            goto while_break;
          }
#line 4181
          if (wc == 4294967295U) {
#line 4183
            if ((int const   )*ptr___0 == -125) {
#line 4183
              tmp = (int const   )*(ptr___0 + 1) ^ 32;
            } else {
#line 4183
              tmp = (int const   )*ptr___0;
            }
#line 4183
            chr = (int )((unsigned char )tmp);
#line 4185
            if (chr > 127) {
#line 4186
              goto while_break;
            } else
#line 4185
            if (! ((int )typtab[(unsigned char )chr] & itype)) {
#line 4186
              goto while_break;
            }
          } else
#line 4187
          if (len == 1) {
#line 4187
            if (((int const   )*ptr___0 & -128) == 0) {
#line 4189
              if (! ((int )typtab[(unsigned char )*ptr___0] & itype)) {
#line 4190
                goto while_break;
              }
            } else {
#line 4187
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 4196
            if (itype == 1 << 10) {
#line 4196
              goto case_exp;
            }
#line 4203
            if (itype == 1 << 5) {
#line 4203
              goto case_exp___0;
            }
#line 4208
            goto switch_default;
            case_exp: /* CIL Label */ 
            {
#line 4197
            tmp___0 = iswalnum(wc);
            }
#line 4197
            if (! tmp___0) {
              {
#line 4197
              tmp___1 = wmemchr((wchar_t const   *)wordchars_wide.chars, (wchar_t )wc,
                                wordchars_wide.len);
              }
#line 4197
              if (! tmp___1) {
#line 4200
                return ((char *)ptr___0);
              }
            }
#line 4201
            goto switch_break;
            case_exp___0: /* CIL Label */ 
            {
#line 4204
            tmp___2 = wmemchr((wchar_t const   *)ifs_wide.chars, (wchar_t )wc, ifs_wide.len);
            }
#line 4204
            if (! tmp___2) {
#line 4205
              return ((char *)ptr___0);
            }
#line 4206
            goto switch_break;
            switch_default: /* CIL Label */ 
            {
#line 4209
            tmp___3 = iswalnum(wc);
            }
#line 4209
            if (! tmp___3) {
#line 4210
              return ((char *)ptr___0);
            }
            switch_break: /* CIL Label */ ;
            }
          }
        }
#line 4214
        ptr___0 += len;
#line 4216
        if (once) {
#line 4217
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 4164
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 4221
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4222
      if ((int const   )*ptr___0 == -125) {
#line 4222
        tmp___4 = (int const   )*(ptr___0 + 1) ^ 32;
      } else {
#line 4222
        tmp___4 = (int const   )*ptr___0;
      }
#line 4222
      chr___0 = (int )((unsigned char )tmp___4);
#line 4223
      if (! ((int )typtab[(unsigned char )chr___0] & itype)) {
#line 4224
        goto while_break___0;
      }
#line 4225
      if ((int const   )*ptr___0 == -125) {
#line 4225
        tmp___5 = 2;
      } else {
#line 4225
        tmp___5 = 1;
      }
#line 4225
      ptr___0 += tmp___5;
#line 4227
      if (once) {
#line 4228
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 4240
  return ((char *)ptr___0);
}
}
#line 4244 "/tmp/zsh-5.4.2/Src/utils.c"
char **arrdup(char **s ) 
{ 
  char **x ;
  char **y ;
  int tmp ;
  void *tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  char **tmp___3 ;

  {
  {
#line 4249
  tmp = arrlen(s);
#line 4249
  tmp___0 = zhalloc(sizeof(char *) * (unsigned long )(tmp + 1));
#line 4249
  x = (char **)tmp___0;
#line 4249
  y = x;
  }
  {
#line 4251
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4251
    tmp___1 = x;
#line 4251
    x ++;
#line 4251
    tmp___3 = s;
#line 4251
    s ++;
#line 4251
    tmp___2 = dupstring((char const   *)*tmp___3);
#line 4251
    *tmp___1 = tmp___2;
    }
#line 4251
    if (! tmp___2) {
#line 4251
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4253
  return (y);
}
}
#line 4259 "/tmp/zsh-5.4.2/Src/utils.c"
char **arrdup_max(char **s , unsigned int max ) 
{ 
  char **x ;
  char **y ;
  char **send ;
  int len ;
  void *tmp ;
  char **tmp___0 ;
  char **tmp___1 ;

  {
#line 4263
  len = 0;
#line 4265
  if (max) {
    {
#line 4266
    len = arrlen(s);
    }
  }
#line 4269
  if (max > (unsigned int )len) {
#line 4270
    max = (unsigned int )len;
  }
  {
#line 4272
  tmp = zhalloc(sizeof(char *) * (unsigned long )(max + 1U));
#line 4272
  x = (char **)tmp;
#line 4272
  y = x;
#line 4274
  send = s + max;
  }
  {
#line 4275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4275
    if (! ((unsigned long )s < (unsigned long )send)) {
#line 4275
      goto while_break;
    }
    {
#line 4276
    tmp___0 = x;
#line 4276
    x ++;
#line 4276
    tmp___1 = s;
#line 4276
    s ++;
#line 4276
    *tmp___0 = dupstring((char const   *)*tmp___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4277
  *x = (char *)((void *)0);
#line 4279
  return (y);
}
}
#line 4283 "/tmp/zsh-5.4.2/Src/utils.c"
char **zarrdup(char **s ) 
{ 
  char **x ;
  char **y ;
  int tmp ;
  void *tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  char **tmp___3 ;

  {
  {
#line 4288
  tmp = arrlen(s);
#line 4288
  tmp___0 = zalloc(sizeof(char *) * (unsigned long )(tmp + 1));
#line 4288
  x = (char **)tmp___0;
#line 4288
  y = x;
  }
  {
#line 4290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4290
    tmp___1 = x;
#line 4290
    x ++;
#line 4290
    tmp___3 = s;
#line 4290
    s ++;
#line 4290
    tmp___2 = ztrdup((char const   *)*tmp___3);
#line 4290
    *tmp___1 = tmp___2;
    }
#line 4290
    if (! tmp___2) {
#line 4290
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4292
  return (y);
}
}
#line 4298 "/tmp/zsh-5.4.2/Src/utils.c"
wchar_t **wcs_zarrdup(wchar_t **s ) 
{ 
  wchar_t **x ;
  wchar_t **y ;
  int tmp ;
  void *tmp___0 ;
  wchar_t **tmp___1 ;
  wchar_t *tmp___2 ;
  wchar_t **tmp___3 ;

  {
  {
#line 4303
  tmp = arrlen((char **)s);
#line 4303
  tmp___0 = zalloc(sizeof(wchar_t *) * (unsigned long )(tmp + 1));
#line 4303
  x = (wchar_t **)tmp___0;
#line 4303
  y = x;
  }
  {
#line 4305
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4305
    tmp___1 = x;
#line 4305
    x ++;
#line 4305
    tmp___3 = s;
#line 4305
    s ++;
#line 4305
    tmp___2 = wcs_ztrdup((wchar_t const   *)*tmp___3);
#line 4305
    *tmp___1 = tmp___2;
    }
#line 4305
    if (! tmp___2) {
#line 4305
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4307
  return (y);
}
}
#line 4317 "/tmp/zsh-5.4.2/Src/utils.c"
static char newname[4097]  ;
#line 4313 "/tmp/zsh-5.4.2/Src/utils.c"
static char *spname(char *oldname ) 
{ 
  char *p ;
  char spnameguess[4097] ;
  char spnamebest[4097] ;
  char *new ;
  char *old ;
  int bestdist ;
  int thisdist ;
  int thresh ;
  int maxthresh ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;

  {
#line 4318
  new = newname;
#line 4318
  old = oldname;
#line 4319
  bestdist = 0;
#line 4319
  maxthresh = 0;
  {
#line 4326
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4327
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4327
      if (! ((int )*old == 47)) {
#line 4327
        goto while_break___0;
      }
#line 4328
      if ((unsigned long )(new - newname) >= sizeof(newname) - 1UL) {
#line 4329
        return ((char *)((void *)0));
      }
#line 4330
      tmp = new;
#line 4330
      new ++;
#line 4330
      tmp___0 = old;
#line 4330
      old ++;
#line 4330
      *tmp = *tmp___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4332
    *new = (char )'\000';
#line 4333
    if ((int )*old == 0) {
#line 4334
      return (newname);
    }
#line 4335
    p = spnameguess;
    {
#line 4336
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4336
      if ((int )*old != 47) {
#line 4336
        if (! ((int )*old != 0)) {
#line 4336
          goto while_break___1;
        }
      } else {
#line 4336
        goto while_break___1;
      }
#line 4337
      if ((unsigned long )p < (unsigned long )(spnameguess + 4096)) {
#line 4338
        tmp___1 = p;
#line 4338
        p ++;
#line 4338
        *tmp___1 = *old;
      }
#line 4336
      old ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4339
    *p = (char )'\000';
#line 4342
    thresh = (int )(p - spnameguess) / 4 + 1;
#line 4343
    if (thresh < 3) {
#line 4344
      thresh = 3;
    } else
#line 4345
    if (thresh > 100) {
#line 4346
      thresh = 100;
    }
    {
#line 4347
    thisdist = mindist(newname, spnameguess, spnamebest, (int )*old == 47);
    }
#line 4348
    if (thisdist >= thresh) {
#line 4356
      if (bestdist < maxthresh) {
        {
#line 4357
        strcpy((char */* __restrict  */)new, (char const   */* __restrict  */)(spnameguess));
#line 4358
        strcat((char */* __restrict  */)new, (char const   */* __restrict  */)old);
        }
#line 4359
        return (newname);
      } else {
#line 4361
        return ((char *)((void *)0));
      }
    } else {
#line 4363
      maxthresh = bestdist + thresh;
#line 4364
      bestdist += thisdist;
    }
#line 4366
    p = spnamebest;
    {
#line 4366
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4366
      tmp___3 = p;
#line 4366
      p ++;
#line 4366
      tmp___2 = *tmp___3;
#line 4366
      *new = tmp___2;
#line 4366
      if (! tmp___2) {
#line 4366
        goto while_break___2;
      }
#line 4367
      new ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 4372 "/tmp/zsh-5.4.2/Src/utils.c"
static int mindist(char *dir , char *mindistguess , char *mindistbest , int wantdir ) 
{ 
  int mindistd ;
  int nd ;
  DIR *dd ;
  char *fn___0 ;
  char *buf___7 ;
  struct stat st___0 ;
  size_t dirlen ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 4382
  if ((int )*(dir + 0) == 0) {
#line 4383
    dir = (char *)".";
  }
  {
#line 4384
  mindistd = 100;
#line 4386
  dirlen = strlen((char const   *)dir);
#line 4386
  tmp = strlen((char const   *)mindistguess);
#line 4386
  tmp___0 = zalloc((dirlen + tmp) + 2UL);
#line 4386
  buf___7 = (char *)tmp___0;
  }
#line 4386
  if (! buf___7) {
#line 4387
    return (0);
  }
  {
#line 4388
  sprintf((char */* __restrict  */)buf___7, (char const   */* __restrict  */)"%s/%s",
          dir, mindistguess);
#line 4390
  tmp___1 = unmeta((char const   *)buf___7);
#line 4390
  tmp___2 = stat((char const   */* __restrict  */)tmp___1, (struct stat */* __restrict  */)(& st___0));
  }
#line 4390
  if (tmp___2 == 0) {
#line 4390
    if (! wantdir) {
      {
#line 4391
      strcpy((char */* __restrict  */)mindistbest, (char const   */* __restrict  */)mindistguess);
#line 4392
      free((void *)buf___7);
      }
#line 4393
      return (0);
    } else
#line 4390
    if ((st___0.st_mode & 61440U) == 16384U) {
      {
#line 4391
      strcpy((char */* __restrict  */)mindistbest, (char const   */* __restrict  */)mindistguess);
#line 4392
      free((void *)buf___7);
      }
#line 4393
      return (0);
    }
  }
  {
#line 4396
  tmp___9 = unmeta((char const   *)dir);
#line 4396
  dd = opendir((char const   *)tmp___9);
  }
#line 4396
  if (dd) {
    {
#line 4397
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 4397
      fn___0 = zreaddir(dd, 0);
      }
#line 4397
      if (! fn___0) {
#line 4397
        goto while_break;
      }
#line 4398
      if (spnamepat) {
        {
#line 4398
        tmp___3 = pattry(spnamepat, fn___0);
        }
#line 4398
        if (tmp___3) {
#line 4399
          goto while_continue;
        }
      }
      {
#line 4400
      tmp___4 = strlen((char const   *)mindistguess);
#line 4400
      nd = spdist(fn___0, mindistguess, (int )tmp___4 / 4 + 1);
      }
#line 4402
      if (nd <= mindistd) {
#line 4403
        if (wantdir) {
          {
#line 4404
          tmp___5 = strlen((char const   *)fn___0);
#line 4404
          tmp___6 = zrealloc((void *)buf___7, (dirlen + tmp___5) + 2UL);
#line 4404
          buf___7 = (char *)tmp___6;
          }
#line 4404
          if (! buf___7) {
#line 4405
            goto while_continue;
          }
          {
#line 4406
          sprintf((char */* __restrict  */)buf___7, (char const   */* __restrict  */)"%s/%s",
                  dir, fn___0);
#line 4407
          tmp___7 = unmeta((char const   *)buf___7);
#line 4407
          tmp___8 = stat((char const   */* __restrict  */)tmp___7, (struct stat */* __restrict  */)(& st___0));
          }
#line 4407
          if (tmp___8 != 0) {
#line 4408
            goto while_continue;
          } else
#line 4407
          if (! ((st___0.st_mode & 61440U) == 16384U)) {
#line 4408
            goto while_continue;
          }
        }
        {
#line 4410
        strcpy((char */* __restrict  */)mindistbest, (char const   */* __restrict  */)fn___0);
#line 4411
        mindistd = nd;
        }
#line 4412
        if (mindistd == 0) {
#line 4413
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4416
    closedir(dd);
    }
  }
  {
#line 4418
  free((void *)buf___7);
  }
#line 4419
  return (mindistd);
}
}
#line 4423 "/tmp/zsh-5.4.2/Src/utils.c"
static int spdist(char *s , char *t , int thresh ) 
{ 
  char *p ;
  char *q ;
  char qwertykeymap[155] ;
  char dvorakkeymap[155] ;
  char const   *keymap ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int t0 ;
  char *z ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 4428
  qwertykeymap[0] = (char )'\n';
#line 4428
  qwertykeymap[1] = (char )'\n';
#line 4428
  qwertykeymap[2] = (char )'\n';
#line 4428
  qwertykeymap[3] = (char )'\n';
#line 4428
  qwertykeymap[4] = (char )'\n';
#line 4428
  qwertykeymap[5] = (char )'\n';
#line 4428
  qwertykeymap[6] = (char )'\n';
#line 4428
  qwertykeymap[7] = (char )'\n';
#line 4428
  qwertykeymap[8] = (char )'\n';
#line 4428
  qwertykeymap[9] = (char )'\n';
#line 4428
  qwertykeymap[10] = (char )'\n';
#line 4428
  qwertykeymap[11] = (char )'\n';
#line 4428
  qwertykeymap[12] = (char )'\n';
#line 4428
  qwertykeymap[13] = (char )'\n';
#line 4428
  qwertykeymap[14] = (char )'\t';
#line 4428
  qwertykeymap[15] = (char )'1';
#line 4428
  qwertykeymap[16] = (char )'2';
#line 4428
  qwertykeymap[17] = (char )'3';
#line 4428
  qwertykeymap[18] = (char )'4';
#line 4428
  qwertykeymap[19] = (char )'5';
#line 4428
  qwertykeymap[20] = (char )'6';
#line 4428
  qwertykeymap[21] = (char )'7';
#line 4428
  qwertykeymap[22] = (char )'8';
#line 4428
  qwertykeymap[23] = (char )'9';
#line 4428
  qwertykeymap[24] = (char )'0';
#line 4428
  qwertykeymap[25] = (char )'-';
#line 4428
  qwertykeymap[26] = (char )'=';
#line 4428
  qwertykeymap[27] = (char )'\t';
#line 4428
  qwertykeymap[28] = (char )'\t';
#line 4428
  qwertykeymap[29] = (char )'q';
#line 4428
  qwertykeymap[30] = (char )'w';
#line 4428
  qwertykeymap[31] = (char )'e';
#line 4428
  qwertykeymap[32] = (char )'r';
#line 4428
  qwertykeymap[33] = (char )'t';
#line 4428
  qwertykeymap[34] = (char )'y';
#line 4428
  qwertykeymap[35] = (char )'u';
#line 4428
  qwertykeymap[36] = (char )'i';
#line 4428
  qwertykeymap[37] = (char )'o';
#line 4428
  qwertykeymap[38] = (char )'p';
#line 4428
  qwertykeymap[39] = (char )'[';
#line 4428
  qwertykeymap[40] = (char )']';
#line 4428
  qwertykeymap[41] = (char )'\t';
#line 4428
  qwertykeymap[42] = (char )'\t';
#line 4428
  qwertykeymap[43] = (char )'a';
#line 4428
  qwertykeymap[44] = (char )'s';
#line 4428
  qwertykeymap[45] = (char )'d';
#line 4428
  qwertykeymap[46] = (char )'f';
#line 4428
  qwertykeymap[47] = (char )'g';
#line 4428
  qwertykeymap[48] = (char )'h';
#line 4428
  qwertykeymap[49] = (char )'j';
#line 4428
  qwertykeymap[50] = (char )'k';
#line 4428
  qwertykeymap[51] = (char )'l';
#line 4428
  qwertykeymap[52] = (char )';';
#line 4428
  qwertykeymap[53] = (char )'\'';
#line 4428
  qwertykeymap[54] = (char )'\n';
#line 4428
  qwertykeymap[55] = (char )'\t';
#line 4428
  qwertykeymap[56] = (char )'\t';
#line 4428
  qwertykeymap[57] = (char )'z';
#line 4428
  qwertykeymap[58] = (char )'x';
#line 4428
  qwertykeymap[59] = (char )'c';
#line 4428
  qwertykeymap[60] = (char )'v';
#line 4428
  qwertykeymap[61] = (char )'b';
#line 4428
  qwertykeymap[62] = (char )'n';
#line 4428
  qwertykeymap[63] = (char )'m';
#line 4428
  qwertykeymap[64] = (char )',';
#line 4428
  qwertykeymap[65] = (char )'.';
#line 4428
  qwertykeymap[66] = (char )'/';
#line 4428
  qwertykeymap[67] = (char )'\t';
#line 4428
  qwertykeymap[68] = (char )'\t';
#line 4428
  qwertykeymap[69] = (char )'\t';
#line 4428
  qwertykeymap[70] = (char )'\n';
#line 4428
  qwertykeymap[71] = (char )'\n';
#line 4428
  qwertykeymap[72] = (char )'\n';
#line 4428
  qwertykeymap[73] = (char )'\n';
#line 4428
  qwertykeymap[74] = (char )'\n';
#line 4428
  qwertykeymap[75] = (char )'\n';
#line 4428
  qwertykeymap[76] = (char )'\n';
#line 4428
  qwertykeymap[77] = (char )'\n';
#line 4428
  qwertykeymap[78] = (char )'\n';
#line 4428
  qwertykeymap[79] = (char )'\n';
#line 4428
  qwertykeymap[80] = (char )'\n';
#line 4428
  qwertykeymap[81] = (char )'\n';
#line 4428
  qwertykeymap[82] = (char )'\n';
#line 4428
  qwertykeymap[83] = (char )'\n';
#line 4428
  qwertykeymap[84] = (char )'\t';
#line 4428
  qwertykeymap[85] = (char )'!';
#line 4428
  qwertykeymap[86] = (char )'@';
#line 4428
  qwertykeymap[87] = (char )'#';
#line 4428
  qwertykeymap[88] = (char )'$';
#line 4428
  qwertykeymap[89] = (char )'%';
#line 4428
  qwertykeymap[90] = (char )'^';
#line 4428
  qwertykeymap[91] = (char )'&';
#line 4428
  qwertykeymap[92] = (char )'*';
#line 4428
  qwertykeymap[93] = (char )'(';
#line 4428
  qwertykeymap[94] = (char )')';
#line 4428
  qwertykeymap[95] = (char )'_';
#line 4428
  qwertykeymap[96] = (char )'+';
#line 4428
  qwertykeymap[97] = (char )'\t';
#line 4428
  qwertykeymap[98] = (char )'\t';
#line 4428
  qwertykeymap[99] = (char )'Q';
#line 4428
  qwertykeymap[100] = (char )'W';
#line 4428
  qwertykeymap[101] = (char )'E';
#line 4428
  qwertykeymap[102] = (char )'R';
#line 4428
  qwertykeymap[103] = (char )'T';
#line 4428
  qwertykeymap[104] = (char )'Y';
#line 4428
  qwertykeymap[105] = (char )'U';
#line 4428
  qwertykeymap[106] = (char )'I';
#line 4428
  qwertykeymap[107] = (char )'O';
#line 4428
  qwertykeymap[108] = (char )'P';
#line 4428
  qwertykeymap[109] = (char )'{';
#line 4428
  qwertykeymap[110] = (char )'}';
#line 4428
  qwertykeymap[111] = (char )'\t';
#line 4428
  qwertykeymap[112] = (char )'\t';
#line 4428
  qwertykeymap[113] = (char )'A';
#line 4428
  qwertykeymap[114] = (char )'S';
#line 4428
  qwertykeymap[115] = (char )'D';
#line 4428
  qwertykeymap[116] = (char )'F';
#line 4428
  qwertykeymap[117] = (char )'G';
#line 4428
  qwertykeymap[118] = (char )'H';
#line 4428
  qwertykeymap[119] = (char )'J';
#line 4428
  qwertykeymap[120] = (char )'K';
#line 4428
  qwertykeymap[121] = (char )'L';
#line 4428
  qwertykeymap[122] = (char )':';
#line 4428
  qwertykeymap[123] = (char )'\"';
#line 4428
  qwertykeymap[124] = (char )'\n';
#line 4428
  qwertykeymap[125] = (char )'\t';
#line 4428
  qwertykeymap[126] = (char )'\t';
#line 4428
  qwertykeymap[127] = (char )'Z';
#line 4428
  qwertykeymap[128] = (char )'X';
#line 4428
  qwertykeymap[129] = (char )'C';
#line 4428
  qwertykeymap[130] = (char )'V';
#line 4428
  qwertykeymap[131] = (char )'B';
#line 4428
  qwertykeymap[132] = (char )'N';
#line 4428
  qwertykeymap[133] = (char )'M';
#line 4428
  qwertykeymap[134] = (char )'<';
#line 4428
  qwertykeymap[135] = (char )'>';
#line 4428
  qwertykeymap[136] = (char )'?';
#line 4428
  qwertykeymap[137] = (char )'\n';
#line 4428
  qwertykeymap[138] = (char )'\n';
#line 4428
  qwertykeymap[139] = (char )'\t';
#line 4428
  qwertykeymap[140] = (char )'\n';
#line 4428
  qwertykeymap[141] = (char )'\n';
#line 4428
  qwertykeymap[142] = (char )'\n';
#line 4428
  qwertykeymap[143] = (char )'\n';
#line 4428
  qwertykeymap[144] = (char )'\n';
#line 4428
  qwertykeymap[145] = (char )'\n';
#line 4428
  qwertykeymap[146] = (char )'\n';
#line 4428
  qwertykeymap[147] = (char )'\n';
#line 4428
  qwertykeymap[148] = (char )'\n';
#line 4428
  qwertykeymap[149] = (char )'\n';
#line 4428
  qwertykeymap[150] = (char )'\n';
#line 4428
  qwertykeymap[151] = (char )'\n';
#line 4428
  qwertykeymap[152] = (char )'\n';
#line 4428
  qwertykeymap[153] = (char )'\n';
#line 4428
  qwertykeymap[154] = (char )'\000';
#line 4440
  dvorakkeymap[0] = (char )'\n';
#line 4440
  dvorakkeymap[1] = (char )'\n';
#line 4440
  dvorakkeymap[2] = (char )'\n';
#line 4440
  dvorakkeymap[3] = (char )'\n';
#line 4440
  dvorakkeymap[4] = (char )'\n';
#line 4440
  dvorakkeymap[5] = (char )'\n';
#line 4440
  dvorakkeymap[6] = (char )'\n';
#line 4440
  dvorakkeymap[7] = (char )'\n';
#line 4440
  dvorakkeymap[8] = (char )'\n';
#line 4440
  dvorakkeymap[9] = (char )'\n';
#line 4440
  dvorakkeymap[10] = (char )'\n';
#line 4440
  dvorakkeymap[11] = (char )'\n';
#line 4440
  dvorakkeymap[12] = (char )'\n';
#line 4440
  dvorakkeymap[13] = (char )'\n';
#line 4440
  dvorakkeymap[14] = (char )'\t';
#line 4440
  dvorakkeymap[15] = (char )'1';
#line 4440
  dvorakkeymap[16] = (char )'2';
#line 4440
  dvorakkeymap[17] = (char )'3';
#line 4440
  dvorakkeymap[18] = (char )'4';
#line 4440
  dvorakkeymap[19] = (char )'5';
#line 4440
  dvorakkeymap[20] = (char )'6';
#line 4440
  dvorakkeymap[21] = (char )'7';
#line 4440
  dvorakkeymap[22] = (char )'8';
#line 4440
  dvorakkeymap[23] = (char )'9';
#line 4440
  dvorakkeymap[24] = (char )'0';
#line 4440
  dvorakkeymap[25] = (char )'[';
#line 4440
  dvorakkeymap[26] = (char )']';
#line 4440
  dvorakkeymap[27] = (char )'\t';
#line 4440
  dvorakkeymap[28] = (char )'\t';
#line 4440
  dvorakkeymap[29] = (char )'\'';
#line 4440
  dvorakkeymap[30] = (char )',';
#line 4440
  dvorakkeymap[31] = (char )'.';
#line 4440
  dvorakkeymap[32] = (char )'p';
#line 4440
  dvorakkeymap[33] = (char )'y';
#line 4440
  dvorakkeymap[34] = (char )'f';
#line 4440
  dvorakkeymap[35] = (char )'g';
#line 4440
  dvorakkeymap[36] = (char )'c';
#line 4440
  dvorakkeymap[37] = (char )'r';
#line 4440
  dvorakkeymap[38] = (char )'l';
#line 4440
  dvorakkeymap[39] = (char )'/';
#line 4440
  dvorakkeymap[40] = (char )'=';
#line 4440
  dvorakkeymap[41] = (char )'\t';
#line 4440
  dvorakkeymap[42] = (char )'\t';
#line 4440
  dvorakkeymap[43] = (char )'a';
#line 4440
  dvorakkeymap[44] = (char )'o';
#line 4440
  dvorakkeymap[45] = (char )'e';
#line 4440
  dvorakkeymap[46] = (char )'u';
#line 4440
  dvorakkeymap[47] = (char )'i';
#line 4440
  dvorakkeymap[48] = (char )'d';
#line 4440
  dvorakkeymap[49] = (char )'h';
#line 4440
  dvorakkeymap[50] = (char )'t';
#line 4440
  dvorakkeymap[51] = (char )'n';
#line 4440
  dvorakkeymap[52] = (char )'s';
#line 4440
  dvorakkeymap[53] = (char )'-';
#line 4440
  dvorakkeymap[54] = (char )'\n';
#line 4440
  dvorakkeymap[55] = (char )'\t';
#line 4440
  dvorakkeymap[56] = (char )'\t';
#line 4440
  dvorakkeymap[57] = (char )';';
#line 4440
  dvorakkeymap[58] = (char )'q';
#line 4440
  dvorakkeymap[59] = (char )'j';
#line 4440
  dvorakkeymap[60] = (char )'k';
#line 4440
  dvorakkeymap[61] = (char )'x';
#line 4440
  dvorakkeymap[62] = (char )'b';
#line 4440
  dvorakkeymap[63] = (char )'m';
#line 4440
  dvorakkeymap[64] = (char )'w';
#line 4440
  dvorakkeymap[65] = (char )'v';
#line 4440
  dvorakkeymap[66] = (char )'z';
#line 4440
  dvorakkeymap[67] = (char )'\t';
#line 4440
  dvorakkeymap[68] = (char )'\t';
#line 4440
  dvorakkeymap[69] = (char )'\t';
#line 4440
  dvorakkeymap[70] = (char )'\n';
#line 4440
  dvorakkeymap[71] = (char )'\n';
#line 4440
  dvorakkeymap[72] = (char )'\n';
#line 4440
  dvorakkeymap[73] = (char )'\n';
#line 4440
  dvorakkeymap[74] = (char )'\n';
#line 4440
  dvorakkeymap[75] = (char )'\n';
#line 4440
  dvorakkeymap[76] = (char )'\n';
#line 4440
  dvorakkeymap[77] = (char )'\n';
#line 4440
  dvorakkeymap[78] = (char )'\n';
#line 4440
  dvorakkeymap[79] = (char )'\n';
#line 4440
  dvorakkeymap[80] = (char )'\n';
#line 4440
  dvorakkeymap[81] = (char )'\n';
#line 4440
  dvorakkeymap[82] = (char )'\n';
#line 4440
  dvorakkeymap[83] = (char )'\n';
#line 4440
  dvorakkeymap[84] = (char )'\t';
#line 4440
  dvorakkeymap[85] = (char )'!';
#line 4440
  dvorakkeymap[86] = (char )'@';
#line 4440
  dvorakkeymap[87] = (char )'#';
#line 4440
  dvorakkeymap[88] = (char )'$';
#line 4440
  dvorakkeymap[89] = (char )'%';
#line 4440
  dvorakkeymap[90] = (char )'^';
#line 4440
  dvorakkeymap[91] = (char )'&';
#line 4440
  dvorakkeymap[92] = (char )'*';
#line 4440
  dvorakkeymap[93] = (char )'(';
#line 4440
  dvorakkeymap[94] = (char )')';
#line 4440
  dvorakkeymap[95] = (char )'{';
#line 4440
  dvorakkeymap[96] = (char )'}';
#line 4440
  dvorakkeymap[97] = (char )'\t';
#line 4440
  dvorakkeymap[98] = (char )'\t';
#line 4440
  dvorakkeymap[99] = (char )'\"';
#line 4440
  dvorakkeymap[100] = (char )'<';
#line 4440
  dvorakkeymap[101] = (char )'>';
#line 4440
  dvorakkeymap[102] = (char )'P';
#line 4440
  dvorakkeymap[103] = (char )'Y';
#line 4440
  dvorakkeymap[104] = (char )'F';
#line 4440
  dvorakkeymap[105] = (char )'G';
#line 4440
  dvorakkeymap[106] = (char )'C';
#line 4440
  dvorakkeymap[107] = (char )'R';
#line 4440
  dvorakkeymap[108] = (char )'L';
#line 4440
  dvorakkeymap[109] = (char )'?';
#line 4440
  dvorakkeymap[110] = (char )'+';
#line 4440
  dvorakkeymap[111] = (char )'\t';
#line 4440
  dvorakkeymap[112] = (char )'\t';
#line 4440
  dvorakkeymap[113] = (char )'A';
#line 4440
  dvorakkeymap[114] = (char )'O';
#line 4440
  dvorakkeymap[115] = (char )'E';
#line 4440
  dvorakkeymap[116] = (char )'U';
#line 4440
  dvorakkeymap[117] = (char )'I';
#line 4440
  dvorakkeymap[118] = (char )'D';
#line 4440
  dvorakkeymap[119] = (char )'H';
#line 4440
  dvorakkeymap[120] = (char )'T';
#line 4440
  dvorakkeymap[121] = (char )'N';
#line 4440
  dvorakkeymap[122] = (char )'S';
#line 4440
  dvorakkeymap[123] = (char )'_';
#line 4440
  dvorakkeymap[124] = (char )'\n';
#line 4440
  dvorakkeymap[125] = (char )'\t';
#line 4440
  dvorakkeymap[126] = (char )'\t';
#line 4440
  dvorakkeymap[127] = (char )':';
#line 4440
  dvorakkeymap[128] = (char )'Q';
#line 4440
  dvorakkeymap[129] = (char )'J';
#line 4440
  dvorakkeymap[130] = (char )'K';
#line 4440
  dvorakkeymap[131] = (char )'X';
#line 4440
  dvorakkeymap[132] = (char )'B';
#line 4440
  dvorakkeymap[133] = (char )'M';
#line 4440
  dvorakkeymap[134] = (char )'W';
#line 4440
  dvorakkeymap[135] = (char )'V';
#line 4440
  dvorakkeymap[136] = (char )'Z';
#line 4440
  dvorakkeymap[137] = (char )'\n';
#line 4440
  dvorakkeymap[138] = (char )'\n';
#line 4440
  dvorakkeymap[139] = (char )'\t';
#line 4440
  dvorakkeymap[140] = (char )'\n';
#line 4440
  dvorakkeymap[141] = (char )'\n';
#line 4440
  dvorakkeymap[142] = (char )'\n';
#line 4440
  dvorakkeymap[143] = (char )'\n';
#line 4440
  dvorakkeymap[144] = (char )'\n';
#line 4440
  dvorakkeymap[145] = (char )'\n';
#line 4440
  dvorakkeymap[146] = (char )'\n';
#line 4440
  dvorakkeymap[147] = (char )'\n';
#line 4440
  dvorakkeymap[148] = (char )'\n';
#line 4440
  dvorakkeymap[149] = (char )'\n';
#line 4440
  dvorakkeymap[150] = (char )'\n';
#line 4440
  dvorakkeymap[151] = (char )'\n';
#line 4440
  dvorakkeymap[152] = (char )'\n';
#line 4440
  dvorakkeymap[153] = (char )'\n';
#line 4440
  dvorakkeymap[154] = (char )'\000';
#line 4453
  if (opts[179]) {
#line 4454
    keymap = (char const   *)(dvorakkeymap);
  } else {
#line 4456
    keymap = (char const   *)(qwertykeymap);
  }
  {
#line 4458
  tmp = strcmp((char const   *)s, (char const   *)t);
  }
#line 4458
  if (! tmp) {
#line 4459
    return (0);
  }
#line 4461
  p = s;
#line 4461
  q = t;
  {
#line 4461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4461
    if (*p) {
      {
#line 4461
      tmp___0 = tulower((int )*p);
#line 4461
      tmp___1 = tulower((int )*q);
      }
#line 4461
      if (! (tmp___0 == tmp___1)) {
#line 4461
        goto while_break;
      }
    } else {
#line 4461
      goto while_break;
    }
#line 4461
    p ++;
#line 4461
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4462
  if (! *p) {
#line 4462
    if (! *q) {
#line 4463
      return (1);
    }
  }
#line 4464
  if (! thresh) {
#line 4465
    return (200);
  }
#line 4466
  p = s;
#line 4466
  q = t;
  {
#line 4466
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4466
    if (*p) {
#line 4466
      if (! *q) {
#line 4466
        goto while_break___0;
      }
    } else {
#line 4466
      goto while_break___0;
    }
#line 4467
    if (! ((int )*p == (int )*q)) {
#line 4469
      if ((int )*(p + 1) == (int )*(q + 0)) {
#line 4469
        if ((int )*(q + 1) == (int )*(p + 0)) {
          {
#line 4470
          tmp___2 = spdist(p + 2, q + 2, thresh - 1);
          }
#line 4470
          return (tmp___2 + 1);
        } else {
#line 4469
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 4471
      if ((int )*(p + 1) == (int )*(q + 0)) {
        {
#line 4472
        tmp___3 = spdist(p + 1, q + 0, thresh - 1);
        }
#line 4472
        return (tmp___3 + 2);
      } else
#line 4473
      if ((int )*(p + 0) == (int )*(q + 1)) {
        {
#line 4474
        tmp___4 = spdist(p + 0, q + 1, thresh - 1);
        }
#line 4474
        return (tmp___4 + 2);
      } else
#line 4475
      if ((int )*p != (int )*q) {
#line 4476
        goto while_break___0;
      }
    }
    __Cont: /* CIL Label */ 
#line 4466
    p ++;
#line 4466
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4477
  if (! *p) {
    {
#line 4477
    tmp___5 = strlen((char const   *)q);
    }
#line 4477
    if (tmp___5 == 1UL) {
#line 4478
      return (2);
    } else {
#line 4477
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 4477
  if (! *q) {
    {
#line 4477
    tmp___6 = strlen((char const   *)p);
    }
#line 4477
    if (tmp___6 == 1UL) {
#line 4478
      return (2);
    }
  }
#line 4479
  p = s;
#line 4479
  q = t;
  {
#line 4479
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4479
    if (*p) {
#line 4479
      if (! *q) {
#line 4479
        goto while_break___1;
      }
    } else {
#line 4479
      goto while_break___1;
    }
#line 4480
    if ((int )*(p + 0) != (int )*(q + 0)) {
#line 4480
      if ((int )*(p + 1) == (int )*(q + 1)) {
        {
#line 4486
        z = strchr(keymap, (int )*(p + 0));
        }
#line 4486
        if (z) {
#line 4486
          if ((int )*z == 10) {
            {
#line 4487
            tmp___7 = spdist(p + 1, q + 1, thresh - 1);
            }
#line 4487
            return (tmp___7 + 1);
          } else
#line 4486
          if ((int )*z == 9) {
            {
#line 4487
            tmp___7 = spdist(p + 1, q + 1, thresh - 1);
            }
#line 4487
            return (tmp___7 + 1);
          }
        } else {
          {
#line 4487
          tmp___7 = spdist(p + 1, q + 1, thresh - 1);
          }
#line 4487
          return (tmp___7 + 1);
        }
#line 4488
        t0 = (int )(z - (char *)keymap);
#line 4489
        if ((int )*q == (int )*(keymap + (t0 - 15))) {
          {
#line 4494
          tmp___8 = spdist(p + 1, q + 1, thresh - 1);
          }
#line 4494
          return (tmp___8 + 2);
        } else
#line 4489
        if ((int )*q == (int )*(keymap + (t0 - 14))) {
          {
#line 4494
          tmp___8 = spdist(p + 1, q + 1, thresh - 1);
          }
#line 4494
          return (tmp___8 + 2);
        } else
#line 4489
        if ((int )*q == (int )*(keymap + (t0 - 13))) {
          {
#line 4494
          tmp___8 = spdist(p + 1, q + 1, thresh - 1);
          }
#line 4494
          return (tmp___8 + 2);
        } else
#line 4489
        if ((int )*q == (int )*(keymap + (t0 - 1))) {
          {
#line 4494
          tmp___8 = spdist(p + 1, q + 1, thresh - 1);
          }
#line 4494
          return (tmp___8 + 2);
        } else
#line 4489
        if ((int )*q == (int )*(keymap + (t0 + 1))) {
          {
#line 4494
          tmp___8 = spdist(p + 1, q + 1, thresh - 1);
          }
#line 4494
          return (tmp___8 + 2);
        } else
#line 4489
        if ((int )*q == (int )*(keymap + (t0 + 13))) {
          {
#line 4494
          tmp___8 = spdist(p + 1, q + 1, thresh - 1);
          }
#line 4494
          return (tmp___8 + 2);
        } else
#line 4489
        if ((int )*q == (int )*(keymap + (t0 + 14))) {
          {
#line 4494
          tmp___8 = spdist(p + 1, q + 1, thresh - 1);
          }
#line 4494
          return (tmp___8 + 2);
        } else
#line 4489
        if ((int )*q == (int )*(keymap + (t0 + 15))) {
          {
#line 4494
          tmp___8 = spdist(p + 1, q + 1, thresh - 1);
          }
#line 4494
          return (tmp___8 + 2);
        }
#line 4495
        return (200);
      } else {
#line 4480
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 4496
    if ((int )*p != (int )*q) {
#line 4497
      goto while_break___1;
    }
#line 4479
    p ++;
#line 4479
    q ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 4498
  return (200);
}
}
#line 4504 "/tmp/zsh-5.4.2/Src/utils.c"
void setcbreak(void) 
{ 
  struct ttyinfo ti ;

  {
  {
#line 4509
  ti = shttyinfo;
#line 4511
  ti.tio.c_lflag &= 4294967293U;
#line 4512
  ti.tio.c_cc[6] = (cc_t )1;
#line 4513
  ti.tio.c_cc[5] = (cc_t )0;
#line 4517
  settyinfo(& ti);
  }
#line 4518
  return;
}
}
#line 4526 "/tmp/zsh-5.4.2/Src/utils.c"
static int ep  =    0;
#line 4523 "/tmp/zsh-5.4.2/Src/utils.c"
void attachtty(pid_t pgrp ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4528
  if (opts[116]) {
#line 4528
    if (opts[93]) {
#line 4530
      if (SHTTY != -1) {
        {
#line 4530
        tmp___2 = tcsetpgrp(SHTTY, pgrp);
        }
#line 4530
        if (tmp___2 == -1) {
#line 4530
          if (! ep) {
#line 4541
            if (pgrp != mypgrp) {
              {
#line 4541
              tmp___1 = kill(- pgrp, 0);
              }
#line 4541
              if (tmp___1 == -1) {
                {
#line 4542
                attachtty(mypgrp);
                }
              } else {
#line 4541
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 4544
              tmp___0 = __errno_location();
              }
#line 4544
              if (*tmp___0 != 25) {
                {
#line 4546
                tmp = __errno_location();
#line 4546
                zwarn("can\'t set tty pgrp: %e", *tmp);
#line 4547
                fflush(stderr);
                }
              }
#line 4549
              opts[116] = (char)0;
#line 4550
              ep = 1;
            }
          }
        }
      }
    }
  }
#line 4554
  return;
}
}
#line 4559 "/tmp/zsh-5.4.2/Src/utils.c"
pid_t gettygrp(void) 
{ 
  pid_t arg ;

  {
#line 4564
  if (SHTTY == -1) {
#line 4565
    return (-1);
  }
  {
#line 4568
  arg = tcgetpgrp(SHTTY);
  }
#line 4573
  return (arg);
}
}
#line 4605 "/tmp/zsh-5.4.2/Src/utils.c"
static char mbuf[8193]  ;
#line 4600 "/tmp/zsh-5.4.2/Src/utils.c"
char *metafy(char *buf___7 , int len , int heap ) 
{ 
  int meta___0 ;
  char *t ;
  char *p ;
  char *e ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char tmp___9 ;

  {
#line 4603
  meta___0 = 0;
#line 4607
  if (len == -1) {
#line 4608
    e = buf___7;
#line 4608
    len = 0;
    {
#line 4608
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4608
      if (! *e) {
#line 4608
        goto while_break;
      }
#line 4609
      tmp = e;
#line 4609
      e ++;
#line 4609
      if ((int )typtab[(unsigned char )*tmp] & (1 << 12)) {
#line 4610
        meta___0 ++;
      }
#line 4608
      len ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 4612
    e = buf___7;
    {
#line 4612
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4612
      if (! ((unsigned long )e < (unsigned long )(buf___7 + len))) {
#line 4612
        goto while_break___0;
      }
#line 4613
      tmp___0 = e;
#line 4613
      e ++;
#line 4613
      if ((int )typtab[(unsigned char )*tmp___0] & (1 << 12)) {
#line 4614
        meta___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 4616
  if (meta___0) {
#line 4616
    goto _L;
  } else
#line 4616
  if (heap == 3) {
#line 4616
    goto _L;
  } else
#line 4616
  if (heap == 6) {
    _L: /* CIL Label */ 
    {
#line 4618
    if (heap == 0) {
#line 4618
      goto case_0;
    }
#line 4621
    if (heap == 7) {
#line 4621
      goto case_7;
    }
#line 4625
    if (heap == 3) {
#line 4625
      goto case_3;
    }
#line 4625
    if (heap == 4) {
#line 4625
      goto case_3;
    }
#line 4629
    if (heap == 6) {
#line 4629
      goto case_6;
    }
#line 4629
    if (heap == 1) {
#line 4629
      goto case_6;
    }
#line 4632
    if (heap == 2) {
#line 4632
      goto case_2;
    }
#line 4617
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 4619
    tmp___1 = zrealloc((void *)buf___7, (size_t )((len + meta___0) + 1));
#line 4619
    buf___7 = (char *)tmp___1;
    }
#line 4620
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 4622
    tmp___2 = hrealloc(buf___7, (size_t )len, (size_t )((len + meta___0) + 1));
#line 4622
    buf___7 = (char *)tmp___2;
    }
#line 4623
    goto switch_break;
    case_3: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 4626
    tmp___3 = zalloc((size_t )((len + meta___0) + 1));
#line 4626
    tmp___4 = memcpy((void */* __restrict  */)tmp___3, (void const   */* __restrict  */)buf___7,
                     (size_t )len);
#line 4626
    buf___7 = (char *)tmp___4;
    }
#line 4627
    goto switch_break;
    case_6: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 4630
    tmp___5 = zhalloc((size_t )((len + meta___0) + 1));
#line 4630
    tmp___6 = memcpy((void */* __restrict  */)tmp___5, (void const   */* __restrict  */)buf___7,
                     (size_t )len);
#line 4630
    buf___7 = (char *)tmp___6;
    }
#line 4631
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 4639
    tmp___7 = memcpy((void */* __restrict  */)(mbuf), (void const   */* __restrict  */)buf___7,
                     (size_t )len);
#line 4639
    buf___7 = (char *)tmp___7;
    }
#line 4640
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 4650
    p = buf___7 + len;
#line 4651
    t = (buf___7 + len) + meta___0;
#line 4651
    e = t;
    {
#line 4652
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4652
      if (! meta___0) {
#line 4652
        goto while_break___1;
      }
#line 4653
      t --;
#line 4653
      p --;
#line 4653
      tmp___9 = *p;
#line 4653
      *t = tmp___9;
#line 4653
      if ((int )typtab[(unsigned char )tmp___9] & (1 << 12)) {
#line 4654
        tmp___8 = t;
#line 4654
        t --;
#line 4654
        *tmp___8 = (char )((int )*tmp___8 ^ 32);
#line 4655
        *t = (char)-125;
#line 4656
        meta___0 --;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 4660
  *e = (char )'\000';
#line 4661
  return (buf___7);
}
}
#line 4673 "/tmp/zsh-5.4.2/Src/utils.c"
char *ztrdup_metafy(char const   *s ) 
{ 
  char *tmp ;

  {
#line 4677
  if (! s) {
#line 4678
    return ((char *)((void *)0));
  }
  {
#line 4683
  tmp = metafy((char *)s, -1, 3);
  }
#line 4683
  return (tmp);
}
}
#line 4698 "/tmp/zsh-5.4.2/Src/utils.c"
char *unmetafy(char *s , int *len ) 
{ 
  char *p ;
  char *t ;
  char *tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char *tmp___2 ;

  {
#line 4703
  p = s;
  {
#line 4703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4703
    if (*p) {
#line 4703
      if (! ((int )*p != -125)) {
#line 4703
        goto while_break;
      }
    } else {
#line 4703
      goto while_break;
    }
#line 4703
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4704
  t = p;
  {
#line 4704
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4704
    tmp___2 = p;
#line 4704
    p ++;
#line 4704
    tmp___1 = *tmp___2;
#line 4704
    *t = tmp___1;
#line 4704
    if (! tmp___1) {
#line 4704
      goto while_break___0;
    }
#line 4705
    tmp___0 = t;
#line 4705
    t ++;
#line 4705
    if ((int )*tmp___0 == -125) {
#line 4705
      if (*p) {
#line 4706
        tmp = p;
#line 4706
        p ++;
#line 4706
        *(t + -1) = (char )((int )*tmp ^ 32);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4707
  if (len) {
#line 4708
    *len = (int )(t - s);
  }
#line 4709
  return (s);
}
}
#line 4716 "/tmp/zsh-5.4.2/Src/utils.c"
int metalen(char const   *s , int len ) 
{ 
  int mlen ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 4719
  mlen = len;
  {
#line 4721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4721
    tmp___0 = len;
#line 4721
    len --;
#line 4721
    if (! tmp___0) {
#line 4721
      goto while_break;
    }
#line 4722
    tmp = s;
#line 4722
    s ++;
#line 4722
    if ((int const   )*tmp == -125) {
#line 4723
      mlen ++;
#line 4724
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4727
  return (mlen);
}
}
#line 4741 "/tmp/zsh-5.4.2/Src/utils.c"
static char *fn  ;
#line 4742 "/tmp/zsh-5.4.2/Src/utils.c"
static int sz  ;
#line 4738 "/tmp/zsh-5.4.2/Src/utils.c"
char *unmeta(char const   *file_name ) 
{ 
  char *p ;
  char const   *t ;
  int newsz ;
  int meta___0 ;
  void *tmp ;
  char const   *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 4747
  if (! file_name) {
#line 4748
    return ((char *)((void *)0));
  }
#line 4750
  meta___0 = 0;
#line 4751
  t = file_name;
  {
#line 4751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4751
    if (! *t) {
#line 4751
      goto while_break;
    }
#line 4752
    if ((int const   )*t == -125) {
#line 4753
      meta___0 = 1;
    }
#line 4751
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4755
  if (! meta___0) {
#line 4759
    if (sz > 16384) {
      {
#line 4760
      zfree((void *)fn, sz);
#line 4761
      fn = (char *)((void *)0);
#line 4762
      sz = 0;
      }
    }
#line 4764
    return ((char *)file_name);
  }
#line 4767
  newsz = (int )((t - file_name) + 1L);
#line 4776
  if (! fn) {
#line 4776
    goto _L;
  } else
#line 4776
  if (newsz > sz) {
#line 4776
    goto _L;
  } else
#line 4776
  if (sz > 16384) {
#line 4776
    if (newsz <= 16384) {
      _L: /* CIL Label */ 
#line 4778
      if (fn) {
        {
#line 4779
        zfree((void *)fn, sz);
        }
      }
      {
#line 4780
      sz = newsz;
#line 4781
      tmp = zalloc((size_t )sz);
#line 4781
      fn = (char *)tmp;
      }
#line 4782
      if (! fn) {
#line 4783
        sz = 0;
#line 4787
        return ((char *)((void *)0));
      }
    }
  }
#line 4791
  t = file_name;
#line 4791
  p = fn;
  {
#line 4791
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4791
    if (! *t) {
#line 4791
      goto while_break___0;
    }
#line 4792
    tmp___2 = t;
#line 4792
    t ++;
#line 4792
    tmp___1 = (char )*tmp___2;
#line 4792
    *p = tmp___1;
#line 4792
    if ((int )tmp___1 == -125) {
#line 4792
      if (*t) {
#line 4793
        tmp___0 = t;
#line 4793
        t ++;
#line 4793
        *p = (char )((int const   )*tmp___0 ^ 32);
      }
    }
#line 4791
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4794
  *p = (char )'\000';
#line 4795
  return (fn);
}
}
#line 4802 "/tmp/zsh-5.4.2/Src/utils.c"
convchar_t unmeta_one(char const   *in , int *sz___0 ) 
{ 
  convchar_t wc ;
  int newsz ;
  mbstate_t wstate ;

  {
#line 4811
  if (! sz___0) {
#line 4812
    sz___0 = & newsz;
  }
#line 4813
  *sz___0 = 0;
#line 4815
  if (! in) {
#line 4816
    return ((convchar_t )0);
  } else
#line 4815
  if (! *in) {
#line 4816
    return ((convchar_t )0);
  }
  {
#line 4819
  memset((void *)(& wstate), 0, sizeof(wstate));
#line 4820
  *sz___0 = mb_metacharlenconv_r(in, & wc, & wstate);
  }
#line 4830
  return (wc);
}
}
#line 4850 "/tmp/zsh-5.4.2/Src/utils.c"
int ztrcmp(char const   *s1 , char const   *s2 ) 
{ 
  int c1 ;
  int c2 ;

  {
  {
#line 4855
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4855
    if (*s1) {
#line 4855
      if (! ((int const   )*s1 == (int const   )*s2)) {
#line 4855
        goto while_break;
      }
    } else {
#line 4855
      goto while_break;
    }
#line 4856
    s1 ++;
#line 4857
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4860
  c1 = (int )*s1;
#line 4860
  if (c1) {
#line 4862
    if (c1 == 131) {
#line 4863
      s1 ++;
#line 4863
      c1 = (int )((int const   )*s1 ^ 32);
    }
  } else {
#line 4861
    c1 = -1;
  }
#line 4864
  c2 = (int )*s2;
#line 4864
  if (c2) {
#line 4866
    if (c2 == 131) {
#line 4867
      s2 ++;
#line 4867
      c2 = (int )((int const   )*s2 ^ 32);
    }
  } else {
#line 4865
    c2 = -1;
  }
#line 4869
  if (c1 == c2) {
#line 4870
    return (0);
  } else
#line 4871
  if (c1 < c2) {
#line 4872
    return (-1);
  } else {
#line 4874
    return (1);
  }
}
}
#line 4880 "/tmp/zsh-5.4.2/Src/utils.c"
int ztrlen(char const   *s ) 
{ 
  int l ;
  char const   *tmp ;

  {
#line 4885
  l = 0;
  {
#line 4885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4885
    if (! *s) {
#line 4885
      goto while_break;
    }
#line 4886
    tmp = s;
#line 4886
    s ++;
#line 4886
    if ((int const   )*tmp == -125) {
#line 4893
      s ++;
    }
#line 4885
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4896
  return (l);
}
}
#line 4931 "/tmp/zsh-5.4.2/Src/utils.c"
int ztrsub(char const   *t , char const   *s ) 
{ 
  int l ;
  char const   *tmp ;

  {
#line 4934
  l = (int )(t - s);
  {
#line 4936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4936
    if (! ((unsigned long )s != (unsigned long )t)) {
#line 4936
      goto while_break;
    }
#line 4937
    tmp = s;
#line 4937
    s ++;
#line 4937
    if ((int const   )*tmp == -125) {
#line 4943
      s ++;
#line 4944
      l --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4947
  return (l);
}
}
#line 4951 "/tmp/zsh-5.4.2/Src/utils.c"
char *zreaddir(DIR *dir , int ignoredots ) 
{ 
  struct dirent *de ;
  char *tmp ;

  {
  {
#line 4962
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4963
    de = readdir(dir);
    }
#line 4964
    if (! de) {
#line 4965
      return ((char *)((void *)0));
    }
#line 4962
    if (ignoredots) {
#line 4962
      if ((int )de->d_name[0] == 46) {
#line 4962
        if (! (! de->d_name[1])) {
#line 4962
          if ((int )de->d_name[1] == 46) {
#line 4962
            if (! (! de->d_name[2])) {
#line 4962
              goto while_break;
            }
          } else {
#line 4962
            goto while_break;
          }
        }
      } else {
#line 4962
        goto while_break;
      }
    } else {
#line 4962
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4993
  tmp = metafy(de->d_name, -1, 2);
  }
#line 4993
  return (tmp);
}
}
#line 4999 "/tmp/zsh-5.4.2/Src/utils.c"
int zputs(char const   *s , FILE *stream ) 
{ 
  int c ;
  int tmp ;

  {
  {
#line 5004
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5004
    if (! *s) {
#line 5004
      goto while_break;
    }
#line 5005
    if ((int const   )*s == -125) {
#line 5006
      s ++;
#line 5006
      c = (int )((int const   )*s ^ 32);
    } else
#line 5007
    if ((int )typtab[(unsigned char )*s] & (1 << 4)) {
#line 5008
      s ++;
#line 5009
      goto while_continue;
    } else {
#line 5011
      c = (int )*s;
    }
    {
#line 5012
    s ++;
#line 5013
    tmp = fputc(c, stream);
    }
#line 5013
    if (tmp < 0) {
#line 5014
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5016
  return (0);
}
}
#line 5050 "/tmp/zsh-5.4.2/Src/utils.c"
char *nicedupstring(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 5053
  tmp = nicedup(s, 1);
  }
#line 5053
  return (tmp);
}
}
#line 5126 "/tmp/zsh-5.4.2/Src/utils.c"
size_t mb_niceformat(char const   *s , FILE *stream , char **outstrp , int flags ) 
{ 
  size_t l ;
  size_t newl ;
  int umlen ;
  int outalloc ;
  int outleft ;
  int eol ;
  wchar_t c ;
  char *ums ;
  char *ptr___0 ;
  char *fmt ;
  char *outstr ;
  char *outptr ;
  mbstate_t mbs ;
  size_t tmp ;
  void *tmp___0 ;
  size_t cnt ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int outlen ;
  size_t tmp___3 ;
  int outoffset ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 5129
  l = (size_t )0;
#line 5130
  eol = 0;
#line 5135
  if (outstrp) {
    {
#line 5136
    tmp = strlen(s);
#line 5136
    outalloc = (int )(5UL * tmp);
#line 5136
    outleft = outalloc;
#line 5137
    tmp___0 = zalloc((size_t )outalloc);
#line 5137
    outstr = (char *)tmp___0;
#line 5137
    outptr = outstr;
    }
  } else {
#line 5139
    outalloc = 0;
#line 5139
    outleft = outalloc;
#line 5140
    outstr = (char *)((void *)0);
#line 5140
    outptr = outstr;
  }
  {
#line 5143
  ums = ztrdup(s);
#line 5149
  untokenize(ums);
#line 5150
  ptr___0 = unmetafy(ums, & umlen);
#line 5152
  memset((void *)(& mbs), 0, sizeof(mbs));
  }
  {
#line 5153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5153
    if (! (umlen > 0)) {
#line 5153
      goto while_break;
    }
#line 5154
    if (eol) {
#line 5154
      tmp___2 = (size_t )-1;
    } else {
      {
#line 5154
      tmp___1 = mbrtowc((wchar_t */* __restrict  */)(& c), (char const   */* __restrict  */)ptr___0,
                        (size_t )umlen, (mbstate_t */* __restrict  */)(& mbs));
#line 5154
      tmp___2 = tmp___1;
      }
    }
#line 5154
    cnt = tmp___2;
    {
#line 5157
    if (cnt == 0xfffffffffffffffeUL) {
#line 5157
      goto case_18446744073709551614;
    }
#line 5160
    if (cnt == 0xffffffffffffffffUL) {
#line 5160
      goto case_18446744073709551615;
    }
#line 5168
    if (cnt == 0UL) {
#line 5168
      goto case_0;
    }
#line 5173
    goto switch_default;
    case_18446744073709551614: /* CIL Label */ 
#line 5158
    eol = 1;
    case_18446744073709551615: /* CIL Label */ 
    {
#line 5162
    fmt = nicechar_sel((int )*ptr___0, flags & 2);
#line 5163
    newl = strlen((char const   *)fmt);
#line 5164
    cnt = (size_t )1;
#line 5166
    memset((void *)(& mbs), 0, sizeof(mbs));
    }
#line 5167
    goto switch_break;
    case_0: /* CIL Label */ 
#line 5171
    cnt = (size_t )1;
    switch_default: /* CIL Label */ 
#line 5174
    if (c == 39) {
#line 5174
      if (flags & 2) {
#line 5175
        fmt = (char *)"\\\'";
#line 5176
        newl = (size_t )2;
      } else {
#line 5174
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 5178
    if (c == 92) {
#line 5178
      if (flags & 2) {
#line 5179
        fmt = (char *)"\\\\";
#line 5180
        newl = (size_t )2;
      } else {
        {
#line 5183
        fmt = wcs_nicechar_sel(c, & newl, (char **)((void *)0), flags & 2);
        }
      }
    } else {
      {
#line 5183
      fmt = wcs_nicechar_sel(c, & newl, (char **)((void *)0), flags & 2);
      }
    }
#line 5184
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 5187
    umlen = (int )((size_t )umlen - cnt);
#line 5188
    ptr___0 += cnt;
#line 5189
    l += newl;
#line 5191
    if (stream) {
      {
#line 5192
      zputs((char const   *)fmt, stream);
      }
    }
#line 5193
    if (outstr) {
      {
#line 5195
      tmp___3 = strlen((char const   *)fmt);
#line 5195
      outlen = (int )tmp___3;
      }
#line 5196
      if (outlen >= outleft) {
        {
#line 5198
        outoffset = (int )(outptr - outstr);
#line 5200
        outleft += outalloc;
#line 5201
        outalloc *= 2;
#line 5202
        tmp___4 = zrealloc((void *)outstr, (size_t )outalloc);
#line 5202
        outstr = (char *)tmp___4;
#line 5203
        outptr = outstr + outoffset;
        }
      }
      {
#line 5205
      memcpy((void */* __restrict  */)outptr, (void const   */* __restrict  */)fmt,
             (size_t )outlen);
#line 5207
      outptr += outlen;
#line 5209
      outleft -= outlen;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5213
  free((void *)ums);
  }
#line 5214
  if (outstrp) {
#line 5215
    *outptr = (char )'\000';
#line 5217
    if (flags & 4) {
#line 5218
      *outstrp = outstr;
    } else {
#line 5220
      if (flags & 1) {
        {
#line 5220
        tmp___5 = dupstring((char const   *)outstr);
#line 5220
        *outstrp = tmp___5;
        }
      } else {
        {
#line 5220
        tmp___6 = ztrdup((char const   *)outstr);
#line 5220
        *outstrp = tmp___6;
        }
      }
      {
#line 5222
      free((void *)outstr);
      }
    }
  }
#line 5226
  return (l);
}
}
#line 5234 "/tmp/zsh-5.4.2/Src/utils.c"
int is_mb_niceformat(char const   *s ) 
{ 
  int umlen ;
  int eol ;
  int ret ;
  wchar_t c ;
  char *ums ;
  char *ptr___0 ;
  mbstate_t mbs ;
  size_t cnt ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 5237
  eol = 0;
#line 5237
  ret = 0;
#line 5242
  ums = ztrdup(s);
#line 5243
  untokenize(ums);
#line 5244
  ptr___0 = unmetafy(ums, & umlen);
#line 5246
  memset((void *)(& mbs), 0, sizeof(mbs));
  }
  {
#line 5247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5247
    if (! (umlen > 0)) {
#line 5247
      goto while_break;
    }
#line 5248
    if (eol) {
#line 5248
      tmp___0 = (size_t )-1;
    } else {
      {
#line 5248
      tmp = mbrtowc((wchar_t */* __restrict  */)(& c), (char const   */* __restrict  */)ptr___0,
                    (size_t )umlen, (mbstate_t */* __restrict  */)(& mbs));
#line 5248
      tmp___0 = tmp;
      }
    }
#line 5248
    cnt = tmp___0;
    {
#line 5251
    if (cnt == 0xfffffffffffffffeUL) {
#line 5251
      goto case_18446744073709551614;
    }
#line 5254
    if (cnt == 0xffffffffffffffffUL) {
#line 5254
      goto case_18446744073709551615;
    }
#line 5264
    if (cnt == 0UL) {
#line 5264
      goto case_0;
    }
#line 5269
    goto switch_default;
    case_18446744073709551614: /* CIL Label */ 
#line 5252
    eol = 1;
    case_18446744073709551615: /* CIL Label */ 
    {
#line 5256
    tmp___1 = is_nicechar((int )*ptr___0);
    }
#line 5256
    if (tmp___1) {
#line 5257
      ret = 1;
#line 5258
      goto switch_break;
    }
    {
#line 5260
    cnt = (size_t )1;
#line 5262
    memset((void *)(& mbs), 0, sizeof(mbs));
    }
#line 5263
    goto switch_break;
    case_0: /* CIL Label */ 
#line 5267
    cnt = (size_t )1;
    switch_default: /* CIL Label */ 
    {
#line 5270
    tmp___2 = is_wcs_nicechar(c);
    }
#line 5270
    if (tmp___2) {
#line 5271
      ret = 1;
    }
#line 5272
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 5275
    if (ret) {
#line 5276
      goto while_break;
    }
#line 5278
    umlen = (int )((size_t )umlen - cnt);
#line 5279
    ptr___0 += cnt;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5282
  free((void *)ums);
  }
#line 5284
  return (ret);
}
}
#line 5290 "/tmp/zsh-5.4.2/Src/utils.c"
char *nicedup(char const   *s , int heap ) 
{ 
  char *retstr ;
  int tmp ;

  {
#line 5295
  if (heap) {
#line 5295
    tmp = 1;
  } else {
#line 5295
    tmp = 0;
  }
  {
#line 5295
  mb_niceformat(s, (FILE *)((void *)0), & retstr, tmp);
  }
#line 5297
  return (retstr);
}
}
#line 5308 "/tmp/zsh-5.4.2/Src/utils.c"
int mb_metacharlenconv_r(char const   *s , wint_t *wcp , mbstate_t *mbsp ) 
{ 
  size_t ret ;
  char inchar ;
  char const   *ptr___0 ;
  wchar_t wc ;

  {
#line 5311
  ret = (size_t )-1;
#line 5316
  if ((int )((unsigned char )*s) <= 127) {
#line 5317
    if (wcp) {
#line 5318
      *wcp = (wint_t )*s;
    }
#line 5319
    return (1);
  }
#line 5322
  ptr___0 = s;
  {
#line 5322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5322
    if (! *ptr___0) {
#line 5322
      goto while_break;
    }
#line 5323
    if ((int const   )*ptr___0 == -125) {
#line 5324
      ptr___0 ++;
#line 5324
      inchar = (char )((int const   )*ptr___0 ^ 32);
    } else
#line 5327
    if ((int )typtab[(unsigned char )*ptr___0] & (1 << 12)) {
#line 5334
      goto while_break;
    } else {
#line 5336
      inchar = (char )*ptr___0;
    }
    {
#line 5337
    ptr___0 ++;
#line 5338
    ret = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)(& inchar),
                  (size_t )1, (mbstate_t */* __restrict  */)mbsp);
    }
#line 5340
    if (ret == 0xffffffffffffffffUL) {
#line 5341
      goto while_break;
    }
#line 5342
    if (ret == 0xfffffffffffffffeUL) {
#line 5343
      goto __Cont;
    }
#line 5344
    if (wcp) {
#line 5345
      *wcp = (wint_t )wc;
    }
#line 5346
    return ((int )(ptr___0 - s));
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 5349
  if (wcp) {
#line 5350
    *wcp = 4294967295U;
  }
  {
#line 5352
  memset((void *)mbsp, 0, sizeof(*mbsp));
  }
#line 5353
  if ((unsigned long )ptr___0 > (unsigned long )s) {
#line 5354
    return (1 + ((int const   )*s == -125));
  } else {
#line 5356
    return (0);
  }
}
}
#line 5371 "/tmp/zsh-5.4.2/Src/utils.c"
int mb_metacharlenconv(char const   *s , wint_t *wcp ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 5374
  if (! opts[117]) {
#line 5374
    goto _L;
  } else
#line 5374
  if ((int )((unsigned char )*s) <= 127) {
    _L: /* CIL Label */ 
#line 5376
    if (wcp) {
#line 5377
      if ((int const   )*s == -125) {
#line 5377
        tmp = (int const   )*(s + 1) ^ 32;
      } else {
#line 5377
        tmp = (int const   )*s;
      }
#line 5377
      *wcp = (wint_t )tmp;
    }
#line 5378
    return (1 + ((int const   )*s == -125));
  }
#line 5390
  if ((int )typtab[(unsigned char )*s] & (1 << 4)) {
#line 5391
    if (wcp) {
#line 5392
      *wcp = 4294967295U;
    }
#line 5393
    return (1);
  }
  {
#line 5396
  tmp___0 = mb_metacharlenconv_r(s, wcp, & mb_shiftstate);
  }
#line 5396
  return (tmp___0);
}
}
#line 5415 "/tmp/zsh-5.4.2/Src/utils.c"
int mb_metastrlenend(char *ptr___0 , int width , char *eptr ) 
{ 
  char inchar ;
  char *laststart ;
  size_t ret ;
  wchar_t wc ;
  int num ;
  int num_in_char ;
  int complete ;
  int tmp ;
  int tmp___0 ;
  int wcw ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 5423
  if (! opts[117]) {
#line 5424
    if (eptr) {
#line 5424
      tmp___0 = (int )(eptr - ptr___0);
    } else {
      {
#line 5424
      tmp = ztrlen((char const   *)ptr___0);
#line 5424
      tmp___0 = tmp;
      }
    }
#line 5424
    return (tmp___0);
  }
  {
#line 5426
  laststart = ptr___0;
#line 5427
  ret = (size_t )-1;
#line 5428
  num_in_char = 0;
#line 5428
  num = num_in_char;
#line 5429
  complete = 1;
#line 5431
  memset((void *)(& mb_shiftstate), 0, sizeof(mb_shiftstate));
  }
  {
#line 5432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5432
    if (*ptr___0) {
#line 5432
      if (eptr) {
#line 5432
        if ((unsigned long )ptr___0 >= (unsigned long )eptr) {
#line 5432
          goto while_break;
        }
      }
    } else {
#line 5432
      goto while_break;
    }
#line 5433
    if ((int )*ptr___0 == -125) {
#line 5434
      ptr___0 ++;
#line 5434
      inchar = (char )((int )*ptr___0 ^ 32);
    } else {
#line 5436
      inchar = *ptr___0;
    }
#line 5437
    ptr___0 ++;
#line 5439
    if (complete) {
#line 5439
      if ((int )((unsigned char )inchar) <= 127) {
#line 5444
        num ++;
#line 5445
        laststart = ptr___0;
#line 5446
        num_in_char = 0;
#line 5447
        goto while_continue;
      }
    }
    {
#line 5450
    ret = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)(& inchar),
                  (size_t )1, (mbstate_t */* __restrict  */)(& mb_shiftstate));
    }
#line 5452
    if (ret == 0xfffffffffffffffeUL) {
#line 5468
      num_in_char ++;
#line 5469
      complete = 0;
    } else {
#line 5471
      if (ret == 0xffffffffffffffffUL) {
        {
#line 5473
        memset((void *)(& mb_shiftstate), 0, sizeof(mb_shiftstate));
#line 5474
        ptr___0 = (laststart + ((int )*laststart == -125)) + 1;
#line 5475
        num ++;
        }
      } else
#line 5476
      if (width) {
        {
#line 5481
        tmp___1 = wcwidth(wc);
#line 5481
        wcw = tmp___1;
        }
#line 5482
        if (wcw > 0) {
#line 5483
          if (width == 1) {
#line 5484
            num += wcw;
          } else {
#line 5486
            num ++;
          }
        }
      } else {
#line 5489
        num ++;
      }
#line 5490
      laststart = ptr___0;
#line 5491
      num_in_char = 0;
#line 5492
      complete = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5497
  if (num_in_char) {
#line 5497
    tmp___2 = 1;
  } else {
#line 5497
    tmp___2 = 0;
  }
#line 5497
  return (num + tmp___2);
}
}
#line 5507 "/tmp/zsh-5.4.2/Src/utils.c"
int mb_charlenconv_r(char const   *s , int slen , wint_t *wcp , mbstate_t *mbsp ) 
{ 
  size_t ret ;
  char inchar ;
  char const   *ptr___0 ;
  wchar_t wc ;

  {
#line 5510
  ret = (size_t )-1;
#line 5515
  if (slen) {
#line 5515
    if ((int )((unsigned char )*s) <= 127) {
#line 5516
      if (wcp) {
#line 5517
        *wcp = (wint_t )*s;
      }
#line 5518
      return (1);
    }
  }
#line 5521
  ptr___0 = s;
  {
#line 5521
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5521
    if (! slen) {
#line 5521
      goto while_break;
    }
    {
#line 5522
    inchar = (char )*ptr___0;
#line 5523
    ptr___0 ++;
#line 5524
    slen --;
#line 5525
    ret = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)(& inchar),
                  (size_t )1, (mbstate_t */* __restrict  */)mbsp);
    }
#line 5527
    if (ret == 0xffffffffffffffffUL) {
#line 5528
      goto while_break;
    }
#line 5529
    if (ret == 0xfffffffffffffffeUL) {
#line 5530
      goto __Cont;
    }
#line 5531
    if (wcp) {
#line 5532
      *wcp = (wint_t )wc;
    }
#line 5533
    return ((int )(ptr___0 - s));
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 5536
  if (wcp) {
#line 5537
    *wcp = 4294967295U;
  }
  {
#line 5539
  memset((void *)mbsp, 0, sizeof(*mbsp));
  }
#line 5540
  if ((unsigned long )ptr___0 > (unsigned long )s) {
#line 5541
    return (1);
  } else {
#line 5543
    return (0);
  }
}
}
#line 5553 "/tmp/zsh-5.4.2/Src/utils.c"
int mb_charlenconv(char const   *s , int slen , wint_t *wcp ) 
{ 
  int tmp ;

  {
#line 5556
  if (! opts[117]) {
#line 5556
    goto _L;
  } else
#line 5556
  if ((int )((unsigned char )*s) <= 127) {
    _L: /* CIL Label */ 
#line 5557
    if (wcp) {
#line 5558
      *wcp = (wint_t )*s;
    }
#line 5559
    return (1);
  }
  {
#line 5562
  tmp = mb_charlenconv_r(s, slen, wcp, & mb_shiftstate);
  }
#line 5562
  return (tmp);
}
}
#line 5620 "/tmp/zsh-5.4.2/Src/utils.c"
int zexpandtabs(char const   *s , int len , int width , int startpos , FILE *fout ,
                int all ) 
{ 
  int at_start ;
  mbstate_t mbs ;
  size_t ret ;
  wchar_t wc ;
  char const   *sstart ;
  int wcw ;
  int tmp ;

  {
  {
#line 5624
  at_start = 1;
#line 5631
  memset((void *)(& mbs), 0, sizeof(mbs));
  }
  {
#line 5634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5634
    if (! len) {
#line 5634
      goto while_break;
    }
#line 5635
    if ((int const   )*s == 9) {
#line 5636
      if (all) {
#line 5636
        goto _L;
      } else
#line 5636
      if (at_start) {
        _L: /* CIL Label */ 
#line 5637
        s ++;
#line 5638
        len --;
#line 5639
        if (width <= 0) {
          {
#line 5641
          fputc(' ', fout);
#line 5642
          startpos ++;
          }
        } else
#line 5639
        if (! (startpos % width)) {
          {
#line 5641
          fputc(' ', fout);
#line 5642
          startpos ++;
          }
        }
#line 5644
        if (width <= 0) {
#line 5645
          goto while_continue;
        }
        {
#line 5646
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 5646
          if (! (startpos % width)) {
#line 5646
            goto while_break___0;
          }
          {
#line 5647
          fputc(' ', fout);
#line 5648
          startpos ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 5657
        startpos += width - startpos % width;
#line 5658
        s ++;
#line 5659
        len --;
#line 5660
        fputc('\t', fout);
        }
      }
#line 5662
      goto while_continue;
    } else
#line 5663
    if ((int const   )*s == 10) {
#line 5663
      goto _L___0;
    } else
#line 5663
    if ((int const   )*s == 13) {
      _L___0: /* CIL Label */ 
      {
#line 5664
      fputc((int )*s, fout);
#line 5665
      s ++;
#line 5666
      len --;
#line 5667
      startpos = 0;
#line 5668
      at_start = 1;
      }
#line 5669
      goto while_continue;
    }
#line 5672
    at_start = 0;
#line 5674
    if (opts[117]) {
      {
#line 5675
      sstart = s;
#line 5676
      ret = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)s,
                    (size_t )len, (mbstate_t */* __restrict  */)(& mbs));
      }
#line 5677
      if (ret == 0xffffffffffffffffUL) {
        {
#line 5679
        memset((void *)(& mbs), 0, sizeof(mbs));
#line 5680
        s ++;
#line 5681
        len --;
        }
      } else
#line 5682
      if (ret == 0xfffffffffffffffeUL) {
#line 5684
        s ++;
#line 5685
        len --;
      } else {
#line 5687
        s += ret;
#line 5688
        len -= (int )ret;
      }
#line 5690
      if (ret == 0xffffffffffffffffUL) {
#line 5691
        startpos ++;
      } else
#line 5690
      if (ret == 0xfffffffffffffffeUL) {
#line 5691
        startpos ++;
      } else {
        {
#line 5693
        tmp = wcwidth(wc);
#line 5693
        wcw = tmp;
        }
#line 5694
        if (wcw > 0) {
#line 5695
          startpos += wcw;
        }
      }
      {
#line 5697
      fwrite((void const   */* __restrict  */)sstart, (size_t )(s - sstart), (size_t )1,
             (FILE */* __restrict  */)fout);
      }
#line 5699
      goto while_continue;
    }
    {
#line 5702
    fputc((int )*s, fout);
#line 5703
    s ++;
#line 5704
    len --;
#line 5705
    startpos ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5708
  return (startpos);
}
}
#line 5714 "/tmp/zsh-5.4.2/Src/utils.c"
int hasspecial(char const   *s ) 
{ 
  int tmp ;

  {
  {
#line 5717
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5717
    if (! *s) {
#line 5717
      goto while_break;
    }
#line 5718
    if ((int const   )*s == -125) {
#line 5718
      s ++;
#line 5718
      tmp = (int const   )*s ^ 32;
    } else {
#line 5718
      tmp = (int const   )*s;
    }
#line 5718
    if ((int )typtab[(unsigned char )tmp] & (1 << 11)) {
#line 5719
      return (1);
    }
#line 5717
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5721
  return (0);
}
}
#line 5725 "/tmp/zsh-5.4.2/Src/utils.c"
static char *addunprintable(char *v , char const   *u , char const   *uend ) 
{ 
  int c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 5728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5728
    if (! ((unsigned long )u < (unsigned long )uend)) {
#line 5728
      goto while_break;
    }
#line 5735
    if ((int const   )*u == -125) {
#line 5736
      u ++;
#line 5736
      c = (int )((unsigned char )((int const   )*u ^ 32));
    } else {
#line 5738
      c = (int )((unsigned char )*u);
    }
    {
#line 5740
    if (c == 0) {
#line 5740
      goto case_0;
    }
#line 5749
    if (c == 7) {
#line 5749
      goto case_7;
    }
#line 5750
    if (c == 8) {
#line 5750
      goto case_8;
    }
#line 5751
    if (c == 12) {
#line 5751
      goto case_12;
    }
#line 5752
    if (c == 10) {
#line 5752
      goto case_10;
    }
#line 5753
    if (c == 13) {
#line 5753
      goto case_13;
    }
#line 5754
    if (c == 9) {
#line 5754
      goto case_9;
    }
#line 5755
    if (c == 11) {
#line 5755
      goto case_11;
    }
#line 5757
    goto switch_default;
    case_0: /* CIL Label */ 
#line 5741
    tmp = v;
#line 5741
    v ++;
#line 5741
    *tmp = (char )'\\';
#line 5742
    tmp___0 = v;
#line 5742
    v ++;
#line 5742
    *tmp___0 = (char )'0';
#line 5743
    if (48 <= (int )*(u + 1)) {
#line 5743
      if ((int const   )*(u + 1) <= 55) {
#line 5744
        tmp___1 = v;
#line 5744
        v ++;
#line 5744
        *tmp___1 = (char )'0';
#line 5745
        tmp___2 = v;
#line 5745
        v ++;
#line 5745
        *tmp___2 = (char )'0';
      }
    }
#line 5747
    goto switch_break;
    case_7: /* CIL Label */ 
#line 5749
    tmp___3 = v;
#line 5749
    v ++;
#line 5749
    *tmp___3 = (char )'\\';
#line 5749
    tmp___4 = v;
#line 5749
    v ++;
#line 5749
    *tmp___4 = (char )'a';
#line 5749
    goto switch_break;
    case_8: /* CIL Label */ 
#line 5750
    tmp___5 = v;
#line 5750
    v ++;
#line 5750
    *tmp___5 = (char )'\\';
#line 5750
    tmp___6 = v;
#line 5750
    v ++;
#line 5750
    *tmp___6 = (char )'b';
#line 5750
    goto switch_break;
    case_12: /* CIL Label */ 
#line 5751
    tmp___7 = v;
#line 5751
    v ++;
#line 5751
    *tmp___7 = (char )'\\';
#line 5751
    tmp___8 = v;
#line 5751
    v ++;
#line 5751
    *tmp___8 = (char )'f';
#line 5751
    goto switch_break;
    case_10: /* CIL Label */ 
#line 5752
    tmp___9 = v;
#line 5752
    v ++;
#line 5752
    *tmp___9 = (char )'\\';
#line 5752
    tmp___10 = v;
#line 5752
    v ++;
#line 5752
    *tmp___10 = (char )'n';
#line 5752
    goto switch_break;
    case_13: /* CIL Label */ 
#line 5753
    tmp___11 = v;
#line 5753
    v ++;
#line 5753
    *tmp___11 = (char )'\\';
#line 5753
    tmp___12 = v;
#line 5753
    v ++;
#line 5753
    *tmp___12 = (char )'r';
#line 5753
    goto switch_break;
    case_9: /* CIL Label */ 
#line 5754
    tmp___13 = v;
#line 5754
    v ++;
#line 5754
    *tmp___13 = (char )'\\';
#line 5754
    tmp___14 = v;
#line 5754
    v ++;
#line 5754
    *tmp___14 = (char )'t';
#line 5754
    goto switch_break;
    case_11: /* CIL Label */ 
#line 5755
    tmp___15 = v;
#line 5755
    v ++;
#line 5755
    *tmp___15 = (char )'\\';
#line 5755
    tmp___16 = v;
#line 5755
    v ++;
#line 5755
    *tmp___16 = (char )'v';
#line 5755
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 5758
    tmp___17 = v;
#line 5758
    v ++;
#line 5758
    *tmp___17 = (char )'\\';
#line 5759
    tmp___18 = v;
#line 5759
    v ++;
#line 5759
    *tmp___18 = (char )(48 + ((c >> 6) & 7));
#line 5760
    tmp___19 = v;
#line 5760
    v ++;
#line 5760
    *tmp___19 = (char )(48 + ((c >> 3) & 7));
#line 5761
    tmp___20 = v;
#line 5761
    v ++;
#line 5761
    *tmp___20 = (char )(48 + (c & 7));
#line 5762
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 5728
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5766
  return (v);
}
}
#line 5783 "/tmp/zsh-5.4.2/Src/utils.c"
char *quotestring(char const   *s , int instring ) 
{ 
  char const   *u ;
  char *v ;
  int alloclen ;
  char *buf___7 ;
  int shownull ;
  int quotesub ;
  int slen ;
  char *quotestart ;
  convchar_t cc ;
  char const   *uend ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int dobackslash ;
  char c ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  char c___0 ;
  int tmp___19 ;
  int tmp___20 ;
  char beg ;
  int level ;
  char *tmp___21 ;
  char const   *tmp___22 ;
  char *tmp___23 ;
  char const   *tmp___24 ;
  char *tmp___25 ;
  char const   *tmp___26 ;
  char *tmp___27 ;
  char const   *tmp___28 ;
  char *tmp___29 ;
  char *addq ;
  char *tmp___30 ;
  char const   *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char const   *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  int inmath ;
  char *tmp___51 ;
  char const   *tmp___52 ;
  char uc ;
  char *tmp___53 ;
  char const   *tmp___54 ;
  char *tmp___55 ;
  char const   *tmp___56 ;
  int tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char const   *tmp___60 ;
  char *tmp___61 ;
  char const   *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  int tmp___66 ;
  char *tmp___67 ;

  {
  {
#line 5790
  shownull = 0;
#line 5799
  quotesub = 0;
#line 5804
  tmp = strlen(s);
#line 5804
  slen = (int )tmp;
  }
  {
#line 5807
  if (instring == 8) {
#line 5807
    goto case_8;
  }
#line 5811
  if (instring == 1) {
#line 5811
    goto case_1;
  }
#line 5820
  if (instring == 7) {
#line 5820
    goto case_7;
  }
#line 5824
  if (instring == 6) {
#line 5824
    goto case_6;
  }
#line 5833
  goto switch_default;
  case_8: /* CIL Label */ 
#line 5808
  shownull = 1;
#line 5809
  instring = 1;
  case_1: /* CIL Label */ 
#line 5817
  alloclen = slen * 7 + 1;
#line 5818
  goto switch_break;
  case_7: /* CIL Label */ 
#line 5821
  alloclen = slen * 2 + 1;
#line 5822
  goto switch_break;
  case_6: /* CIL Label */ 
#line 5829
  alloclen = slen * 4 + 3;
#line 5830
  shownull = 1;
#line 5830
  quotesub = shownull;
#line 5831
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 5834
  alloclen = slen * 4 + 1;
#line 5835
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 5837
  if (! *s) {
#line 5837
    if (shownull) {
#line 5838
      alloclen += 2;
    }
  }
  {
#line 5840
  tmp___0 = zshcalloc((size_t )alloclen);
#line 5840
  buf___7 = (char *)tmp___0;
#line 5840
  v = buf___7;
#line 5840
  quotestart = v;
#line 5845
  u = s;
  }
#line 5846
  if (instring == 4) {
#line 5851
    if ((int )typtab[(unsigned char )*u] & (1 << 14)) {
#line 5852
      u ++;
    }
    {
#line 5857
    mb_charinit();
    }
    {
#line 5858
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5858
      if (! *u) {
#line 5858
        goto while_break;
      }
      {
#line 5859
      tmp___1 = mb_metacharlenconv(u, & cc);
#line 5859
      uend = u + tmp___1;
      }
#line 5861
      if (cc != 4294967295U) {
        {
#line 5861
        tmp___6 = iswprint(cc);
        }
#line 5861
        if (tmp___6) {
          {
#line 5868
          if (cc == 39U) {
#line 5868
            goto case_39;
          }
#line 5868
          if (cc == 92U) {
#line 5868
            goto case_39;
          }
#line 5872
          goto switch_default___0;
          case_39: /* CIL Label */ 
          case_92: /* CIL Label */ 
#line 5869
          tmp___2 = v;
#line 5869
          v ++;
#line 5869
          *tmp___2 = (char )'\\';
#line 5870
          goto switch_break___0;
          switch_default___0: /* CIL Label */ 
#line 5873
          if (opts[18]) {
#line 5873
            if (cc == (convchar_t )((wchar_t )bangchar)) {
#line 5874
              tmp___3 = v;
#line 5874
              v ++;
#line 5874
              *tmp___3 = (char )'\\';
            }
          }
#line 5875
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
          {
#line 5877
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 5877
            if (! ((unsigned long )u < (unsigned long )uend)) {
#line 5877
              goto while_break___0;
            }
#line 5878
            tmp___4 = v;
#line 5878
            v ++;
#line 5878
            tmp___5 = u;
#line 5878
            u ++;
#line 5878
            *tmp___4 = (char )*tmp___5;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 5881
          v = addunprintable(v, u, uend);
#line 5882
          u = uend;
          }
        }
      } else {
        {
#line 5881
        v = addunprintable(v, u, uend);
#line 5882
        u = uend;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 5885
  if (instring == 7) {
    {
#line 5886
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5886
      if (! *u) {
#line 5886
        goto while_break___1;
      }
#line 5887
      if ((int )typtab[(unsigned char )*u] & (1 << 15)) {
#line 5888
        tmp___7 = v;
#line 5888
        v ++;
#line 5888
        *tmp___7 = (char )'\\';
      }
#line 5889
      tmp___8 = v;
#line 5889
      v ++;
#line 5889
      tmp___9 = u;
#line 5889
      u ++;
#line 5889
      *tmp___8 = (char )*tmp___9;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 5892
    if (shownull) {
#line 5894
      if (! *u) {
#line 5895
        tmp___10 = v;
#line 5895
        v ++;
#line 5895
        *tmp___10 = (char )'\'';
#line 5896
        tmp___11 = v;
#line 5896
        v ++;
#line 5896
        *tmp___11 = (char )'\'';
      }
    }
    {
#line 5903
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 5903
      if (! *u) {
#line 5903
        goto while_break___2;
      }
#line 5904
      dobackslash = 0;
#line 5905
      if ((int const   )*u == -109) {
#line 5905
        goto _L___13;
      } else
#line 5905
      if ((int const   )*u == -103) {
        _L___13: /* CIL Label */ 
#line 5906
        tmp___12 = u;
#line 5906
        u ++;
#line 5906
        c = (char )*tmp___12;
#line 5908
        tmp___13 = v;
#line 5908
        v ++;
#line 5908
        *tmp___13 = c;
        {
#line 5909
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 5909
          if (*u) {
#line 5909
            if (! ((int const   )*u != (int const   )c)) {
#line 5909
              goto while_break___3;
            }
          } else {
#line 5909
            goto while_break___3;
          }
#line 5910
          tmp___14 = v;
#line 5910
          v ++;
#line 5910
          tmp___15 = u;
#line 5910
          u ++;
#line 5910
          *tmp___14 = (char )*tmp___15;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 5911
        tmp___16 = v;
#line 5911
        v ++;
#line 5911
        *tmp___16 = c;
#line 5912
        if (*u) {
#line 5913
          u ++;
        }
#line 5914
        goto while_continue___2;
      } else
#line 5915
      if ((int const   )*u == -116) {
#line 5915
        goto _L___12;
      } else
#line 5915
      if ((int const   )*u == 36) {
        _L___12: /* CIL Label */ 
#line 5915
        if ((int const   )*(u + 1) == 39) {
#line 5915
          if (instring == 3) {
#line 5923
            tmp___17 = v;
#line 5923
            v ++;
#line 5923
            tmp___18 = u;
#line 5923
            u ++;
#line 5923
            *tmp___17 = (char )*tmp___18;
          } else {
#line 5915
            goto _L___11;
          }
        } else {
#line 5915
          goto _L___11;
        }
      } else
      _L___11: /* CIL Label */ 
#line 5924
      if ((int const   )*u == -123) {
#line 5924
        goto _L___9;
      } else
#line 5924
      if ((int const   )*u == -116) {
        _L___9: /* CIL Label */ 
#line 5924
        if ((int const   )*(u + 1) == -120) {
#line 5924
          goto _L___8;
        } else
#line 5924
        if ((int const   )*(u + 1) == -111) {
#line 5924
          goto _L___8;
        } else
#line 5924
        if ((int const   )*(u + 1) == -113) {
          _L___8: /* CIL Label */ 
#line 5926
          if ((int const   )*(u + 1) == -120) {
#line 5926
            tmp___20 = -118;
          } else {
#line 5926
            if ((int const   )*(u + 1) == -113) {
#line 5926
              tmp___19 = -112;
            } else {
#line 5926
              tmp___19 = -110;
            }
#line 5926
            tmp___20 = tmp___19;
          }
#line 5926
          c___0 = (char )tmp___20;
#line 5928
          beg = (char )*u;
#line 5929
          level = 0;
#line 5931
          tmp___21 = v;
#line 5931
          v ++;
#line 5931
          tmp___22 = u;
#line 5931
          u ++;
#line 5931
          *tmp___21 = (char )*tmp___22;
#line 5932
          tmp___23 = v;
#line 5932
          v ++;
#line 5932
          tmp___24 = u;
#line 5932
          u ++;
#line 5932
          *tmp___23 = (char )*tmp___24;
          {
#line 5933
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 5933
            if (*u) {
#line 5933
              if (! ((int const   )*u != (int const   )c___0)) {
#line 5933
                if (! level) {
#line 5933
                  goto while_break___4;
                }
              }
            } else {
#line 5933
              goto while_break___4;
            }
#line 5934
            if ((int const   )*u == (int const   )beg) {
#line 5935
              level ++;
            } else
#line 5936
            if ((int const   )*u == (int const   )c___0) {
#line 5937
              level --;
            }
#line 5938
            tmp___25 = v;
#line 5938
            v ++;
#line 5938
            tmp___26 = u;
#line 5938
            u ++;
#line 5938
            *tmp___25 = (char )*tmp___26;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 5940
          if (*u) {
#line 5941
            tmp___27 = v;
#line 5941
            v ++;
#line 5941
            tmp___28 = u;
#line 5941
            u ++;
#line 5941
            *tmp___27 = (char )*tmp___28;
          }
#line 5942
          goto while_continue___2;
        } else {
#line 5924
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 5944
      if ((int )typtab[(unsigned char )*u] & (1 << 11)) {
#line 5944
        if ((int const   )*u != 61) {
#line 5944
          if ((int const   )*u != 126) {
#line 5944
            goto _L___4;
          } else {
#line 5944
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 5944
        if ((unsigned long )u == (unsigned long )s) {
#line 5944
          goto _L___4;
        } else
#line 5944
        if (opts[112]) {
#line 5944
          if ((int const   )*(u + -1) == 61) {
#line 5944
            goto _L___4;
          } else
#line 5944
          if ((int const   )*(u + -1) == 58) {
#line 5944
            goto _L___4;
          } else {
#line 5944
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 5944
        if ((int const   )*u == 126) {
#line 5944
          if (opts[53]) {
            _L___4: /* CIL Label */ 
#line 5944
            if (instring == 1) {
#line 5944
              goto _L___0;
            } else
#line 5944
            if (instring == 6) {
#line 5944
              goto _L___0;
            } else
#line 5944
            if (opts[18]) {
#line 5944
              if ((int const   )*u == (int const   )((char )bangchar)) {
#line 5944
                if (instring != 2) {
#line 5944
                  goto _L___0;
                } else {
#line 5944
                  goto _L___3;
                }
              } else {
#line 5944
                goto _L___3;
              }
            } else
            _L___3: /* CIL Label */ 
#line 5944
            if (instring == 3) {
#line 5944
              if ((int const   )*u == 36) {
#line 5944
                goto _L___0;
              } else
#line 5944
              if ((int const   )*u == 96) {
#line 5944
                goto _L___0;
              } else
#line 5944
              if ((int const   )*u == 34) {
#line 5944
                goto _L___0;
              } else
#line 5944
              if ((int const   )*u == 92) {
#line 5944
                goto _L___0;
              } else {
#line 5944
                goto _L___1;
              }
            } else
            _L___1: /* CIL Label */ 
#line 5944
            if (instring == 2) {
#line 5944
              if ((int const   )*u == 39) {
                _L___0: /* CIL Label */ 
#line 5957
                if (instring == 6) {
#line 5958
                  if (quotesub == 1) {
#line 5962
                    if ((int const   )*u == 39) {
#line 5966
                      tmp___29 = v;
#line 5966
                      v ++;
#line 5966
                      *tmp___29 = (char )'\\';
                    } else {
#line 5971
                      if ((unsigned long )v > (unsigned long )quotestart) {
#line 5975
                        addq = v;
                        {
#line 5975
                        while (1) {
                          while_continue___5: /* CIL Label */ ;
#line 5975
                          if (! ((unsigned long )addq > (unsigned long )quotestart)) {
#line 5975
                            goto while_break___5;
                          }
#line 5976
                          *addq = *(addq + -1);
#line 5975
                          addq --;
                        }
                        while_break___5: /* CIL Label */ ;
                        }
                      }
#line 5978
                      *quotestart = (char )'\'';
#line 5979
                      v ++;
#line 5980
                      quotesub = 2;
                    }
#line 5982
                    tmp___30 = v;
#line 5982
                    v ++;
#line 5982
                    tmp___31 = u;
#line 5982
                    u ++;
#line 5982
                    *tmp___30 = (char )*tmp___31;
#line 5986
                    quotestart = v;
                  } else
#line 5987
                  if ((int const   )*u == 39) {
#line 5988
                    if (! opts[150]) {
#line 5989
                      tmp___32 = v;
#line 5989
                      v ++;
#line 5989
                      *tmp___32 = (char )'\'';
#line 5990
                      tmp___33 = v;
#line 5990
                      v ++;
#line 5990
                      *tmp___33 = (char )'\\';
#line 5991
                      tmp___34 = v;
#line 5991
                      v ++;
#line 5991
                      *tmp___34 = (char )'\'';
#line 5993
                      quotesub = 1;
#line 5994
                      quotestart = v;
                    } else {
#line 5997
                      tmp___35 = v;
#line 5997
                      v ++;
#line 5997
                      *tmp___35 = (char )'\'';
#line 5998
                      tmp___36 = v;
#line 5998
                      v ++;
#line 5998
                      *tmp___36 = (char )'\'';
                    }
#line 6001
                    u ++;
                  } else {
#line 6004
                    tmp___37 = v;
#line 6004
                    v ++;
#line 6004
                    tmp___38 = u;
#line 6004
                    u ++;
#line 6004
                    *tmp___37 = (char )*tmp___38;
                  }
#line 6006
                  goto while_continue___2;
                } else
#line 6007
                if ((int const   )*u == 10) {
#line 6007
                  goto _L;
                } else
#line 6007
                if (instring == 2) {
#line 6007
                  if ((int const   )*u == 39) {
                    _L: /* CIL Label */ 
#line 6009
                    if ((int const   )*u == 10) {
#line 6010
                      tmp___39 = v;
#line 6010
                      v ++;
#line 6010
                      *tmp___39 = (char )'$';
#line 6011
                      tmp___40 = v;
#line 6011
                      v ++;
#line 6011
                      *tmp___40 = (char )'\'';
#line 6012
                      tmp___41 = v;
#line 6012
                      v ++;
#line 6012
                      *tmp___41 = (char )'\\';
#line 6013
                      tmp___42 = v;
#line 6013
                      v ++;
#line 6013
                      *tmp___42 = (char )'n';
#line 6014
                      tmp___43 = v;
#line 6014
                      v ++;
#line 6014
                      *tmp___43 = (char )'\'';
                    } else
#line 6015
                    if (! opts[150]) {
#line 6016
                      tmp___44 = v;
#line 6016
                      v ++;
#line 6016
                      *tmp___44 = (char )'\'';
#line 6017
                      if ((int const   )*u == 39) {
#line 6018
                        tmp___45 = v;
#line 6018
                        v ++;
#line 6018
                        *tmp___45 = (char )'\\';
                      }
#line 6019
                      tmp___46 = v;
#line 6019
                      v ++;
#line 6019
                      *tmp___46 = (char )*u;
#line 6020
                      tmp___47 = v;
#line 6020
                      v ++;
#line 6020
                      *tmp___47 = (char )'\'';
                    } else {
#line 6022
                      tmp___48 = v;
#line 6022
                      v ++;
#line 6022
                      *tmp___48 = (char )'\'';
#line 6022
                      tmp___49 = v;
#line 6022
                      v ++;
#line 6022
                      *tmp___49 = (char )'\'';
                    }
#line 6023
                    u ++;
#line 6024
                    goto while_continue___2;
                  } else {
#line 6031
                    dobackslash = 1;
                  }
                } else {
#line 6031
                  dobackslash = 1;
                }
              }
            }
          }
        }
      }
#line 6035
      if ((int )typtab[(unsigned char )*u] & (1 << 4)) {
#line 6035
        goto _L___15;
      } else
#line 6035
      if (instring != 1) {
        _L___15: /* CIL Label */ 
#line 6037
        if (dobackslash) {
#line 6038
          tmp___50 = v;
#line 6038
          v ++;
#line 6038
          *tmp___50 = (char )'\\';
        }
#line 6039
        if ((int const   )*u == -119) {
#line 6044
          inmath = 1;
#line 6045
          tmp___51 = v;
#line 6045
          v ++;
#line 6045
          tmp___52 = u;
#line 6045
          u ++;
#line 6045
          *tmp___51 = (char )*tmp___52;
          {
#line 6046
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 6047
            uc = (char )*u;
#line 6048
            tmp___53 = v;
#line 6048
            v ++;
#line 6048
            tmp___54 = u;
#line 6048
            u ++;
#line 6048
            *tmp___53 = (char )*tmp___54;
#line 6049
            if ((int )uc == 0) {
#line 6050
              goto while_break___6;
            } else
#line 6051
            if ((int )uc == -117) {
#line 6051
              inmath --;
#line 6051
              if (inmath) {
#line 6051
                goto _L___14;
              } else {
#line 6052
                goto while_break___6;
              }
            } else
            _L___14: /* CIL Label */ 
#line 6053
            if ((int )uc == -119) {
#line 6054
              inmath ++;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
        } else {
#line 6057
          tmp___55 = v;
#line 6057
          v ++;
#line 6057
          tmp___56 = u;
#line 6057
          u ++;
#line 6057
          *tmp___55 = (char )*tmp___56;
        }
#line 6058
        goto while_continue___2;
      }
      {
#line 6065
      tmp___57 = mb_metacharlenconv(u, & cc);
#line 6065
      uend = u + tmp___57;
      }
#line 6066
      if (cc != 4294967295U) {
        {
#line 6066
        tmp___66 = iswprint(cc);
        }
#line 6066
        if (tmp___66) {
#line 6071
          if (dobackslash) {
#line 6072
            tmp___58 = v;
#line 6072
            v ++;
#line 6072
            *tmp___58 = (char )'\\';
          }
          {
#line 6073
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 6073
            if (! ((unsigned long )u < (unsigned long )uend)) {
#line 6073
              goto while_break___7;
            }
#line 6074
            if ((int const   )*u == -125) {
#line 6075
              tmp___59 = v;
#line 6075
              v ++;
#line 6075
              tmp___60 = u;
#line 6075
              u ++;
#line 6075
              *tmp___59 = (char )*tmp___60;
            }
#line 6076
            tmp___61 = v;
#line 6076
            v ++;
#line 6076
            tmp___62 = u;
#line 6076
            u ++;
#line 6076
            *tmp___61 = (char )*tmp___62;
          }
          while_break___7: /* CIL Label */ ;
          }
        } else {
#line 6066
          goto _L___16;
        }
      } else {
        _L___16: /* CIL Label */ 
        {
#line 6080
        tmp___63 = v;
#line 6080
        v ++;
#line 6080
        *tmp___63 = (char )'$';
#line 6081
        tmp___64 = v;
#line 6081
        v ++;
#line 6081
        *tmp___64 = (char )'\'';
#line 6082
        v = addunprintable(v, u, uend);
#line 6083
        tmp___65 = v;
#line 6083
        v ++;
#line 6083
        *tmp___65 = (char )'\'';
#line 6084
        u = uend;
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 6088
  if (quotesub == 2) {
#line 6089
    tmp___67 = v;
#line 6089
    v ++;
#line 6089
    *tmp___67 = (char )'\'';
  }
  {
#line 6090
  *v = (char )'\000';
#line 6092
  v = dupstring((char const   *)buf___7);
#line 6093
  zfree((void *)buf___7, alloclen);
  }
#line 6094
  return (v);
}
}
#line 6106 "/tmp/zsh-5.4.2/Src/utils.c"
char *quotedzputs(char const   *s , FILE *stream ) 
{ 
  int inquote ;
  int c ;
  char *outstr ;
  char *ptr___0 ;
  char *tmp ;
  char *substr ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *cptr ;
  int l ;
  size_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;

  {
#line 6109
  inquote = 0;
#line 6113
  if (! *s) {
#line 6114
    if (! stream) {
      {
#line 6115
      tmp = dupstring("\'\'");
      }
#line 6115
      return (tmp);
    }
    {
#line 6116
    fputs((char const   */* __restrict  */)"\'\'", (FILE */* __restrict  */)stream);
    }
#line 6117
    return ((char *)((void *)0));
  }
  {
#line 6121
  tmp___2 = is_mb_niceformat(s);
  }
#line 6121
  if (tmp___2) {
#line 6122
    if (stream) {
      {
#line 6123
      fputs((char const   */* __restrict  */)"$\'", (FILE */* __restrict  */)stream);
#line 6124
      mb_niceformat(s, stream, (char **)((void *)0), 2);
#line 6125
      fputc('\'', stream);
      }
#line 6126
      return ((char *)((void *)0));
    } else {
      {
#line 6129
      mb_niceformat(s, (FILE *)((void *)0), & substr, 6);
#line 6130
      tmp___0 = strlen((char const   *)substr);
#line 6130
      tmp___1 = zhalloc(4UL + tmp___0);
#line 6130
      outstr = (char *)tmp___1;
#line 6131
      sprintf((char */* __restrict  */)outstr, (char const   */* __restrict  */)"$\'%s\'",
              substr);
#line 6132
      free((void *)substr);
      }
#line 6133
      return (outstr);
    }
  }
  {
#line 6138
  tmp___4 = hasspecial(s);
  }
#line 6138
  if (! tmp___4) {
#line 6139
    if (stream) {
      {
#line 6140
      zputs(s, stream);
      }
#line 6141
      return ((char *)((void *)0));
    } else {
      {
#line 6143
      tmp___3 = dupstring(s);
      }
#line 6143
      return (tmp___3);
    }
  }
#line 6147
  if (! stream) {
    {
#line 6149
    tmp___5 = strlen(s);
#line 6149
    l = (int )(tmp___5 + 2UL);
#line 6150
    cptr = s;
    }
    {
#line 6150
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6150
      if (! *cptr) {
#line 6150
        goto while_break;
      }
#line 6151
      if ((int const   )*cptr == -125) {
#line 6152
        cptr ++;
      } else
#line 6153
      if ((int const   )*cptr == 39) {
#line 6154
        if (opts[150]) {
#line 6154
          tmp___6 = 1;
        } else {
#line 6154
          tmp___6 = 3;
        }
#line 6154
        l += tmp___6;
      }
#line 6150
      cptr ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 6156
    tmp___7 = zhalloc((size_t )(l + 1));
#line 6156
    outstr = (char *)tmp___7;
#line 6156
    ptr___0 = outstr;
    }
  } else {
#line 6158
    outstr = (char *)((void *)0);
#line 6158
    ptr___0 = outstr;
  }
#line 6160
  if (opts[150]) {
#line 6162
    if (stream) {
      {
#line 6163
      tmp___8 = fputc('\'', stream);
      }
#line 6163
      if (tmp___8 < 0) {
#line 6164
        return ((char *)((void *)0));
      }
    } else {
#line 6166
      tmp___9 = ptr___0;
#line 6166
      ptr___0 ++;
#line 6166
      *tmp___9 = (char )'\'';
    }
    {
#line 6167
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6167
      if (! *s) {
#line 6167
        goto while_break___0;
      }
#line 6168
      if ((int const   )*s == -101) {
#line 6169
        c = '-';
      } else
#line 6170
      if ((int const   )*s == -125) {
#line 6171
        s ++;
#line 6171
        c = (int )((int const   )*s ^ 32);
      } else {
#line 6173
        c = (int )*s;
      }
#line 6174
      s ++;
#line 6175
      if (c == 39) {
#line 6176
        if (stream) {
          {
#line 6177
          tmp___10 = fputc('\'', stream);
          }
#line 6177
          if (tmp___10 < 0) {
#line 6178
            return ((char *)((void *)0));
          }
        } else {
#line 6180
          tmp___11 = ptr___0;
#line 6180
          ptr___0 ++;
#line 6180
          *tmp___11 = (char )'\'';
        }
      } else
#line 6181
      if (c == 10) {
#line 6181
        if (opts[44]) {
#line 6182
          if (stream) {
            {
#line 6183
            tmp___12 = fputc('\\', stream);
            }
#line 6183
            if (tmp___12 < 0) {
#line 6184
              return ((char *)((void *)0));
            }
          } else {
#line 6186
            tmp___13 = ptr___0;
#line 6186
            ptr___0 ++;
#line 6186
            *tmp___13 = (char )'\\';
          }
        }
      }
#line 6188
      if (stream) {
        {
#line 6189
        tmp___14 = fputc(c, stream);
        }
#line 6189
        if (tmp___14 < 0) {
#line 6190
          return ((char *)((void *)0));
        }
      } else
#line 6192
      if ((int )typtab[(unsigned char )c] & (1 << 12)) {
#line 6193
        tmp___15 = ptr___0;
#line 6193
        ptr___0 ++;
#line 6193
        *tmp___15 = (char)-125;
#line 6194
        tmp___16 = ptr___0;
#line 6194
        ptr___0 ++;
#line 6194
        *tmp___16 = (char )(c ^ 32);
      } else {
#line 6196
        tmp___17 = ptr___0;
#line 6196
        ptr___0 ++;
#line 6196
        *tmp___17 = (char )c;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6199
    if (stream) {
      {
#line 6200
      tmp___18 = fputc('\'', stream);
      }
#line 6200
      if (tmp___18 < 0) {
#line 6201
        return ((char *)((void *)0));
      }
    } else {
#line 6203
      tmp___19 = ptr___0;
#line 6203
      ptr___0 ++;
#line 6203
      *tmp___19 = (char )'\'';
    }
  } else {
    {
#line 6206
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 6206
      if (! *s) {
#line 6206
        goto while_break___1;
      }
#line 6207
      if ((int const   )*s == -101) {
#line 6208
        c = '-';
      } else
#line 6209
      if ((int const   )*s == -125) {
#line 6210
        s ++;
#line 6210
        c = (int )((int const   )*s ^ 32);
      } else {
#line 6212
        c = (int )*s;
      }
#line 6213
      s ++;
#line 6214
      if (c == 39) {
#line 6215
        if (inquote) {
#line 6216
          if (stream) {
            {
#line 6217
            tmp___20 = _IO_putc('\'', stream);
            }
#line 6217
            if (tmp___20 < 0) {
#line 6218
              return ((char *)((void *)0));
            }
          } else {
#line 6220
            tmp___21 = ptr___0;
#line 6220
            ptr___0 ++;
#line 6220
            *tmp___21 = (char )'\'';
          }
#line 6221
          inquote = 0;
        }
#line 6223
        if (stream) {
          {
#line 6224
          tmp___22 = fputs((char const   */* __restrict  */)"\\\'", (FILE */* __restrict  */)stream);
          }
#line 6224
          if (tmp___22 < 0) {
#line 6225
            return ((char *)((void *)0));
          }
        } else {
#line 6227
          tmp___23 = ptr___0;
#line 6227
          ptr___0 ++;
#line 6227
          *tmp___23 = (char )'\\';
#line 6228
          tmp___24 = ptr___0;
#line 6228
          ptr___0 ++;
#line 6228
          *tmp___24 = (char )'\'';
        }
      } else {
#line 6231
        if (! inquote) {
#line 6232
          if (stream) {
            {
#line 6233
            tmp___25 = fputc('\'', stream);
            }
#line 6233
            if (tmp___25 < 0) {
#line 6234
              return ((char *)((void *)0));
            }
          } else {
#line 6236
            tmp___26 = ptr___0;
#line 6236
            ptr___0 ++;
#line 6236
            *tmp___26 = (char )'\'';
          }
#line 6237
          inquote = 1;
        }
#line 6239
        if (c == 10) {
#line 6239
          if (opts[44]) {
#line 6240
            if (stream) {
              {
#line 6241
              tmp___27 = fputc('\\', stream);
              }
#line 6241
              if (tmp___27 < 0) {
#line 6242
                return ((char *)((void *)0));
              }
            } else {
#line 6244
              tmp___28 = ptr___0;
#line 6244
              ptr___0 ++;
#line 6244
              *tmp___28 = (char )'\\';
            }
          }
        }
#line 6246
        if (stream) {
          {
#line 6247
          tmp___29 = fputc(c, stream);
          }
#line 6247
          if (tmp___29 < 0) {
#line 6248
            return ((char *)((void *)0));
          }
        } else
#line 6250
        if ((int )typtab[(unsigned char )c] & (1 << 12)) {
#line 6251
          tmp___30 = ptr___0;
#line 6251
          ptr___0 ++;
#line 6251
          *tmp___30 = (char)-125;
#line 6252
          tmp___31 = ptr___0;
#line 6252
          ptr___0 ++;
#line 6252
          *tmp___31 = (char )(c ^ 32);
        } else {
#line 6254
          tmp___32 = ptr___0;
#line 6254
          ptr___0 ++;
#line 6254
          *tmp___32 = (char )c;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 6258
    if (inquote) {
#line 6259
      if (stream) {
        {
#line 6260
        tmp___33 = fputc('\'', stream);
        }
#line 6260
        if (tmp___33 < 0) {
#line 6261
          return ((char *)((void *)0));
        }
      } else {
#line 6263
        tmp___34 = ptr___0;
#line 6263
        ptr___0 ++;
#line 6263
        *tmp___34 = (char )'\'';
      }
    }
  }
#line 6266
  if (! stream) {
#line 6267
    tmp___35 = ptr___0;
#line 6267
    ptr___0 ++;
#line 6267
    *tmp___35 = (char )'\000';
  }
#line 6269
  return (outstr);
}
}
#line 6275 "/tmp/zsh-5.4.2/Src/utils.c"
char *dquotedztrdup(char const   *s ) 
{ 
  int len ;
  size_t tmp ;
  char *buf___7 ;
  void *tmp___0 ;
  char *p ;
  char *ret ;
  int inquote ;
  int c ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int pending ;
  char *tmp___10 ;
  int c___0 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
  {
#line 6278
  tmp = strlen(s);
#line 6278
  len = (int )(tmp * 4UL + 2UL);
#line 6279
  tmp___0 = zalloc((size_t )len);
#line 6279
  buf___7 = (char *)tmp___0;
#line 6280
  p = buf___7;
  }
#line 6282
  if (opts[44]) {
#line 6283
    inquote = 0;
    {
#line 6285
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6285
      if (! *s) {
#line 6285
        goto while_break;
      }
#line 6286
      tmp___1 = s;
#line 6286
      s ++;
#line 6286
      c = (int )*tmp___1;
#line 6288
      if (c == -125) {
#line 6289
        tmp___2 = s;
#line 6289
        s ++;
#line 6289
        c = (int )((int const   )*tmp___2 ^ 32);
      }
      {
#line 6293
      if (c == 96) {
#line 6293
        goto case_96;
      }
#line 6293
      if (c == 36) {
#line 6293
        goto case_96;
      }
#line 6293
      if (c == 34) {
#line 6293
        goto case_96;
      }
#line 6301
      goto switch_default;
      case_96: /* CIL Label */ 
      case_36: /* CIL Label */ 
      case_34: /* CIL Label */ 
#line 6294
      if (inquote) {
#line 6295
        tmp___3 = p;
#line 6295
        p ++;
#line 6295
        *tmp___3 = (char )'\"';
#line 6296
        inquote = 0;
      }
#line 6298
      tmp___4 = p;
#line 6298
      p ++;
#line 6298
      *tmp___4 = (char )'\\';
#line 6299
      tmp___5 = p;
#line 6299
      p ++;
#line 6299
      *tmp___5 = (char )c;
#line 6300
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 6302
      if (! inquote) {
#line 6303
        tmp___6 = p;
#line 6303
        p ++;
#line 6303
        *tmp___6 = (char )'\"';
#line 6304
        inquote = 1;
      }
#line 6306
      if (c == 10) {
#line 6307
        tmp___7 = p;
#line 6307
        p ++;
#line 6307
        *tmp___7 = (char )'\\';
      }
#line 6308
      tmp___8 = p;
#line 6308
      p ++;
#line 6308
      *tmp___8 = (char )c;
#line 6309
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 6312
    if (inquote) {
#line 6313
      tmp___9 = p;
#line 6313
      p ++;
#line 6313
      *tmp___9 = (char )'\"';
    }
  } else {
#line 6315
    pending = 0;
#line 6317
    tmp___10 = p;
#line 6317
    p ++;
#line 6317
    *tmp___10 = (char )'\"';
    {
#line 6318
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6318
      if (! *s) {
#line 6318
        goto while_break___0;
      }
#line 6319
      tmp___11 = s;
#line 6319
      s ++;
#line 6319
      c___0 = (int )*tmp___11;
#line 6321
      if (c___0 == -125) {
#line 6322
        tmp___12 = s;
#line 6322
        s ++;
#line 6322
        c___0 = (int )((int const   )*tmp___12 ^ 32);
      }
      {
#line 6324
      if (c___0 == 92) {
#line 6324
        goto case_92;
      }
#line 6332
      if (c___0 == 96) {
#line 6332
        goto case_96___0;
      }
#line 6332
      if (c___0 == 36) {
#line 6332
        goto case_96___0;
      }
#line 6332
      if (c___0 == 34) {
#line 6332
        goto case_96___0;
      }
#line 6337
      goto switch_default___0;
      case_92: /* CIL Label */ 
#line 6325
      if (pending) {
#line 6326
        tmp___13 = p;
#line 6326
        p ++;
#line 6326
        *tmp___13 = (char )'\\';
      }
#line 6327
      tmp___14 = p;
#line 6327
      p ++;
#line 6327
      *tmp___14 = (char )'\\';
#line 6328
      pending = 1;
#line 6329
      goto switch_break___0;
      case_96___0: /* CIL Label */ 
      case_36___0: /* CIL Label */ 
      case_34___0: /* CIL Label */ 
#line 6333
      if (pending) {
#line 6334
        tmp___15 = p;
#line 6334
        p ++;
#line 6334
        *tmp___15 = (char )'\\';
      }
#line 6335
      tmp___16 = p;
#line 6335
      p ++;
#line 6335
      *tmp___16 = (char )'\\';
      switch_default___0: /* CIL Label */ 
#line 6338
      tmp___17 = p;
#line 6338
      p ++;
#line 6338
      *tmp___17 = (char )c___0;
#line 6339
      pending = 0;
#line 6340
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6343
    if (pending) {
#line 6344
      tmp___18 = p;
#line 6344
      p ++;
#line 6344
      *tmp___18 = (char )'\\';
    }
#line 6345
    tmp___19 = p;
#line 6345
    p ++;
#line 6345
    *tmp___19 = (char )'\"';
  }
  {
#line 6347
  ret = metafy(buf___7, (int )(p - buf___7), 3);
#line 6348
  zfree((void *)buf___7, len);
  }
#line 6349
  return (ret);
}
}
#line 6467 "/tmp/zsh-5.4.2/Src/utils.c"
char *getkeystring(char *s , int *len , int how , int *misc ) 
{ 
  char *buf___7 ;
  char tmp[1] ;
  char *t ;
  char *tdest ;
  char *u ;
  char *sstart ;
  char *tbuf___0 ;
  char svchar ;
  int meta___0 ;
  int control ;
  int ignoring ;
  int i ;
  wint_t wval ;
  int count ;
  int maxlen ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int miscadded ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char tmp___18 ;
  char *t2 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  zlong tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  wint_t wc ;
  int len___0 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *t2___0 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;

  {
#line 6471
  tdest = (char *)((void *)0);
#line 6471
  u = (char *)((void *)0);
#line 6471
  sstart = s;
#line 6471
  tbuf___0 = (char *)((void *)0);
#line 6472
  svchar = (char )'\000';
#line 6473
  meta___0 = 0;
#line 6473
  control = 0;
#line 6473
  ignoring = 0;
#line 6497
  if (how & 64) {
#line 6498
    buf___7 = tmp;
#line 6498
    t = buf___7;
  } else {
#line 6501
    maxlen = 1;
#line 6510
    t = s;
    {
#line 6510
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6510
      if (! *t) {
#line 6510
        goto while_break;
      }
#line 6511
      if ((int )*t == 92) {
#line 6512
        if (! *(t + 1)) {
#line 6513
          maxlen ++;
#line 6514
          goto while_break;
        }
#line 6516
        if ((int )*(t + 1) == 117) {
          {
#line 6517
          tmp___0 = __ctype_get_mb_cur_max();
#line 6517
          maxlen = (int )((size_t )maxlen + tmp___0 * 2UL);
          }
        } else
#line 6516
        if ((int )*(t + 1) == 85) {
          {
#line 6517
          tmp___0 = __ctype_get_mb_cur_max();
#line 6517
          maxlen = (int )((size_t )maxlen + tmp___0 * 2UL);
          }
        } else {
#line 6519
          maxlen += 2;
        }
#line 6521
        t ++;
      } else {
#line 6523
        maxlen ++;
      }
#line 6510
      t ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 6525
    if (how & 16) {
      {
#line 6543
      tmp___1 = zhalloc((size_t )maxlen);
#line 6543
      tdest = (char *)tmp___1;
#line 6543
      buf___7 = tdest;
#line 6544
      tmp___2 = __ctype_get_mb_cur_max();
#line 6544
      tmp___3 = zhalloc(tmp___2 * 3UL + 1UL);
#line 6544
      tbuf___0 = (char *)tmp___3;
#line 6544
      t = tbuf___0;
      }
    } else {
      {
#line 6546
      tmp___4 = zhalloc((size_t )maxlen);
#line 6546
      buf___7 = (char *)tmp___4;
#line 6546
      t = buf___7;
      }
    }
  }
  {
#line 6549
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6549
    if (! *s) {
#line 6549
      goto while_break___0;
    }
#line 6550
    if ((int )*s == 92) {
#line 6550
      if (*(s + 1)) {
#line 6552
        if (how & 128) {
#line 6552
          if (s - sstart < (long )*misc) {
#line 6553
            (*misc) --;
#line 6554
            miscadded = 1;
          } else {
#line 6556
            miscadded = 0;
          }
        } else {
#line 6556
          miscadded = 0;
        }
#line 6557
        s ++;
        {
#line 6558
        if ((int )*s == 97) {
#line 6558
          goto case_97;
        }
#line 6565
        if ((int )*s == 110) {
#line 6565
          goto case_110;
        }
#line 6568
        if ((int )*s == 98) {
#line 6568
          goto case_98;
        }
#line 6571
        if ((int )*s == 116) {
#line 6571
          goto case_116;
        }
#line 6574
        if ((int )*s == 118) {
#line 6574
          goto case_118;
        }
#line 6577
        if ((int )*s == 102) {
#line 6577
          goto case_102;
        }
#line 6580
        if ((int )*s == 114) {
#line 6580
          goto case_114;
        }
#line 6583
        if ((int )*s == 69) {
#line 6583
          goto case_69;
        }
#line 6591
        if ((int )*s == 101) {
#line 6591
          goto case_101;
        }
#line 6594
        if ((int )*s == 77) {
#line 6594
          goto case_77;
        }
#line 6606
        if ((int )*s == 67) {
#line 6606
          goto case_67;
        }
#line 6618
        if ((int )*s == -125) {
#line 6618
          goto case_neg_125;
        }
#line 6623
        if ((int )*s == 45) {
#line 6623
          goto case_45;
        }
#line 6629
        if ((int )*s == 99) {
#line 6629
          goto case_99;
        }
#line 6637
        if ((int )*s == 85) {
#line 6637
          goto case_85;
        }
#line 6641
        if ((int )*s == 117) {
#line 6641
          goto case_117;
        }
#line 6760
        if ((int )*s == 92) {
#line 6760
          goto case_92;
        }
#line 6760
        if ((int )*s == 39) {
#line 6760
          goto case_92;
        }
#line 6772
        goto def;
        case_97: /* CIL Label */ 
#line 6560
        tmp___5 = t;
#line 6560
        t ++;
#line 6560
        *tmp___5 = (char )'\a';
#line 6564
        goto switch_break;
        case_110: /* CIL Label */ 
#line 6566
        tmp___6 = t;
#line 6566
        t ++;
#line 6566
        *tmp___6 = (char )'\n';
#line 6567
        goto switch_break;
        case_98: /* CIL Label */ 
#line 6569
        tmp___7 = t;
#line 6569
        t ++;
#line 6569
        *tmp___7 = (char )'\b';
#line 6570
        goto switch_break;
        case_116: /* CIL Label */ 
#line 6572
        tmp___8 = t;
#line 6572
        t ++;
#line 6572
        *tmp___8 = (char )'\t';
#line 6573
        goto switch_break;
        case_118: /* CIL Label */ 
#line 6575
        tmp___9 = t;
#line 6575
        t ++;
#line 6575
        *tmp___9 = (char )'\v';
#line 6576
        goto switch_break;
        case_102: /* CIL Label */ 
#line 6578
        tmp___10 = t;
#line 6578
        t ++;
#line 6578
        *tmp___10 = (char )'\f';
#line 6579
        goto switch_break;
        case_114: /* CIL Label */ 
#line 6581
        tmp___11 = t;
#line 6581
        t ++;
#line 6581
        *tmp___11 = (char )'\r';
#line 6582
        goto switch_break;
        case_69: /* CIL Label */ 
#line 6584
        if (! (how & 2)) {
#line 6585
          tmp___12 = t;
#line 6585
          t ++;
#line 6585
          *tmp___12 = (char )'\\';
#line 6585
          s --;
#line 6586
          if (miscadded) {
#line 6587
            (*misc) ++;
          }
#line 6588
          goto __Cont;
        }
        case_101: /* CIL Label */ 
#line 6592
        tmp___13 = t;
#line 6592
        t ++;
#line 6592
        *tmp___13 = (char )'\033';
#line 6593
        goto switch_break;
        case_77: /* CIL Label */ 
#line 6596
        if (how & 2) {
#line 6597
          if ((int )*(s + 1) == 45) {
#line 6598
            s ++;
          }
#line 6599
          meta___0 = 1 + control;
        } else {
#line 6601
          if (miscadded) {
#line 6602
            (*misc) ++;
          }
#line 6603
          tmp___14 = t;
#line 6603
          t ++;
#line 6603
          *tmp___14 = (char )'\\';
#line 6603
          s --;
        }
#line 6605
        goto __Cont;
        case_67: /* CIL Label */ 
#line 6608
        if (how & 2) {
#line 6609
          if ((int )*(s + 1) == 45) {
#line 6610
            s ++;
          }
#line 6611
          control = 1;
        } else {
#line 6613
          if (miscadded) {
#line 6614
            (*misc) ++;
          }
#line 6615
          tmp___15 = t;
#line 6615
          t ++;
#line 6615
          *tmp___15 = (char )'\\';
#line 6615
          s --;
        }
#line 6617
        goto __Cont;
        case_neg_125: /* CIL Label */ 
#line 6619
        if (miscadded) {
#line 6620
          (*misc) ++;
        }
#line 6621
        tmp___16 = t;
#line 6621
        t ++;
#line 6621
        *tmp___16 = (char )'\\';
#line 6621
        s --;
#line 6622
        goto switch_break;
        case_45: /* CIL Label */ 
#line 6624
        if (how & 32) {
#line 6625
          *misc = 1;
#line 6626
          goto switch_break;
        }
#line 6628
        goto def;
        case_99: /* CIL Label */ 
#line 6630
        if (how & 8) {
#line 6631
          *misc = 1;
#line 6632
          *t = (char )'\000';
#line 6633
          *len = (int )(t - buf___7);
#line 6634
          return (buf___7);
        }
#line 6636
        goto def;
        case_85: /* CIL Label */ 
#line 6638
        if (how & 128) {
#line 6638
          if (s - sstart < (long )*misc) {
#line 6639
            *misc -= 4;
          }
        }
        case_117: /* CIL Label */ 
#line 6642
        if (how & 128) {
#line 6642
          if (s - sstart < (long )*misc) {
#line 6643
            *misc -= 6;
          }
        }
#line 6650
        wval = (wint_t )0;
#line 6651
        if ((int )*s == 117) {
#line 6651
          i = 4;
        } else {
#line 6651
          i = 8;
        }
        {
#line 6651
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 6651
          if (! (i > 0)) {
#line 6651
            goto while_break___1;
          }
#line 6652
          s ++;
#line 6652
          if (*s) {
#line 6652
            if ((int )typtab[(unsigned char )*s] & 1) {
#line 6653
              wval = wval * 16U + (wint_t )((int )*s - 48);
            } else {
#line 6652
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 6654
          if (*s) {
#line 6654
            if ((int )*s >= 97) {
#line 6654
              if ((int )*s <= 102) {
#line 6656
                wval = (wval * 16U + (wint_t )((int )*s & 31)) + 9U;
              } else {
#line 6654
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 6654
            if ((int )*s >= 65) {
#line 6654
              if ((int )*s <= 70) {
#line 6656
                wval = (wval * 16U + (wint_t )((int )*s & 31)) + 9U;
              } else {
#line 6658
                s --;
#line 6659
                goto while_break___1;
              }
            } else {
#line 6658
              s --;
#line 6659
              goto while_break___1;
            }
          } else {
#line 6658
            s --;
#line 6659
            goto while_break___1;
          }
#line 6651
          i --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 6662
        if (how & 64) {
#line 6663
          *misc = (int )wval;
#line 6664
          return (s + 1);
        }
        {
#line 6667
        count = wctomb(t, (wchar_t )wval);
        }
#line 6668
        if (count == -1) {
          {
#line 6669
          zerr("character not in range");
          }
#line 6670
          if (how & 16) {
            {
#line 6670
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 6670
              tmp___17 = tdest;
#line 6670
              tdest ++;
#line 6670
              s ++;
#line 6670
              tmp___18 = *s;
#line 6670
              *tmp___17 = tmp___18;
#line 6670
              if (! tmp___18) {
#line 6670
                goto while_break___2;
              }
#line 6670
              if (how & 128) {
#line 6670
                if (s - sstart > (long )*misc) {
#line 6670
                  (*misc) ++;
                }
              }
#line 6670
              if ((int )*s == -99) {
#line 6670
                *len = (int )((s - sstart) + 1L);
#line 6670
                *tdest = (char )'\000';
#line 6670
                return (buf___7);
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 6670
            *len = (int )(tdest - buf___7);
#line 6670
            return (buf___7);
          }
#line 6670
          *t = (char )'\000';
#line 6670
          *len = (int )(t - buf___7);
#line 6670
          return (buf___7);
        }
#line 6672
        if (how & 128) {
#line 6672
          if (s - sstart < (long )*misc) {
#line 6673
            *misc += count;
          }
        }
#line 6674
        t += count;
#line 6746
        if (how & 16) {
#line 6748
          t2 = tbuf___0;
          {
#line 6748
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 6748
            if (! ((unsigned long )t2 < (unsigned long )t)) {
#line 6748
              goto while_break___3;
            }
#line 6749
            if ((int )typtab[(unsigned char )*t2] & (1 << 12)) {
#line 6750
              tmp___19 = tdest;
#line 6750
              tdest ++;
#line 6750
              *tmp___19 = (char)-125;
#line 6751
              tmp___20 = tdest;
#line 6751
              tdest ++;
#line 6751
              *tmp___20 = (char )((int )*t2 ^ 32);
            } else {
#line 6753
              tmp___21 = tdest;
#line 6753
              tdest ++;
#line 6753
              *tmp___21 = *t2;
            }
#line 6748
            t2 ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 6756
          t = tbuf___0;
        }
#line 6758
        goto __Cont;
        case_92: /* CIL Label */ 
        case_39: /* CIL Label */ 
#line 6761
        if (how & 16) {
#line 6768
          tmp___22 = t;
#line 6768
          t ++;
#line 6768
          *tmp___22 = *s;
#line 6769
          goto switch_break;
        }
        def: 
        switch_default: /* CIL Label */ 
#line 6775
        if ((int )typtab[(unsigned char )*s] & 1) {
#line 6775
          if ((int )*s < 56) {
#line 6775
            goto _L___1;
          } else {
#line 6775
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 6775
        if ((int )*s == 120) {
          _L___1: /* CIL Label */ 
#line 6776
          if (! (how & 1)) {
#line 6777
            if ((int )*s == 48) {
#line 6778
              s ++;
            } else
#line 6779
            if ((int )*s != 120) {
#line 6780
              tmp___23 = t;
#line 6780
              t ++;
#line 6780
              *tmp___23 = (char )'\\';
#line 6780
              s --;
#line 6781
              goto __Cont;
            }
          }
#line 6784
          if (*(s + 1)) {
#line 6784
            if (*(s + 2)) {
#line 6784
              if (*(s + 3)) {
#line 6785
                svchar = *(s + 3);
#line 6786
                *(s + 3) = (char )'\000';
#line 6787
                u = s;
              }
            }
          }
#line 6789
          tmp___24 = t;
#line 6789
          t ++;
#line 6789
          if ((int )*s == 120) {
#line 6789
            tmp___25 = 16;
          } else {
#line 6789
            tmp___25 = 8;
          }
          {
#line 6789
          tmp___26 = zstrtol((char const   *)(s + ((int )*s == 120)), & s, tmp___25);
#line 6789
          *tmp___24 = (char )tmp___26;
          }
#line 6791
          if (how & 256) {
#line 6791
            if ((int )*(t + -1) == 37) {
#line 6792
              tmp___27 = t;
#line 6792
              t ++;
#line 6792
              *tmp___27 = (char )'%';
            }
          }
#line 6793
          if (svchar) {
#line 6794
            *(u + 3) = svchar;
#line 6795
            svchar = (char )'\000';
          }
#line 6797
          s --;
        } else {
#line 6799
          if (! (how & 2)) {
#line 6799
            if ((int )*s != 92) {
#line 6800
              if (miscadded) {
#line 6801
                (*misc) ++;
              }
#line 6802
              tmp___28 = t;
#line 6802
              t ++;
#line 6802
              *tmp___28 = (char )'\\';
            }
          }
#line 6804
          tmp___29 = t;
#line 6804
          t ++;
#line 6804
          *tmp___29 = *s;
        }
#line 6806
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 6550
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 6808
    if (how & 16) {
#line 6808
      if ((int )*s == -99) {
#line 6810
        *len = (int )((s - sstart) + 1L);
#line 6811
        *tdest = (char )'\000';
#line 6812
        return (buf___7);
      } else {
#line 6808
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 6813
    if ((int )*s == 94) {
#line 6813
      if (! control) {
#line 6813
        if (how & 4) {
#line 6813
          if (*(s + 1)) {
#line 6814
            control = 1;
#line 6815
            goto __Cont;
          } else {
#line 6813
            goto _L___8;
          }
        } else {
#line 6813
          goto _L___8;
        }
      } else {
#line 6813
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 6817
    if (how & 64) {
#line 6817
      if (opts[117]) {
#line 6817
        if ((int )((unsigned char )*s) > 127) {
          {
#line 6821
          len___0 = mb_metacharlenconv((char const   *)s, & wc);
          }
#line 6822
          if (wc != 4294967295U) {
#line 6823
            *misc = (int )wc;
#line 6824
            return (s + len___0);
          }
        } else {
#line 6817
          goto _L___5;
        }
      } else {
#line 6817
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 6828
    if ((int )*s == -125) {
#line 6829
      tmp___30 = t;
#line 6829
      t ++;
#line 6829
      s ++;
#line 6829
      *tmp___30 = (char )((int )*s ^ 32);
    } else
#line 6831
    if ((int )typtab[(unsigned char )*s] & (1 << 4)) {
#line 6840
      if (meta___0) {
#line 6840
        goto _L___3;
      } else
#line 6840
      if (control) {
        _L___3: /* CIL Label */ 
#line 6850
        if (how & 16) {
#line 6850
          if ((int )*s == -97) {
#line 6851
            tmp___31 = t;
#line 6851
            t ++;
#line 6851
            s ++;
#line 6851
            *tmp___31 = *s;
          } else {
#line 6853
            tmp___32 = t;
#line 6853
            t ++;
#line 6853
            *tmp___32 = ztokens[(int )*s - -124];
          }
        } else {
#line 6853
          tmp___32 = t;
#line 6853
          t ++;
#line 6853
          *tmp___32 = ztokens[(int )*s - -124];
        }
      } else
#line 6854
      if (how & 16) {
#line 6859
        tmp___33 = tdest;
#line 6859
        tdest ++;
#line 6859
        *tmp___33 = *s;
#line 6860
        if ((int )*s == -97) {
#line 6870
          tmp___34 = tdest;
#line 6870
          tdest ++;
#line 6870
          s ++;
#line 6870
          *tmp___34 = *s;
        }
#line 6873
        t = tbuf___0;
#line 6874
        goto __Cont;
      } else {
#line 6876
        tmp___35 = t;
#line 6876
        t ++;
#line 6876
        *tmp___35 = *s;
      }
    } else {
#line 6878
      tmp___36 = t;
#line 6878
      t ++;
#line 6878
      *tmp___36 = *s;
    }
#line 6880
    if (meta___0 == 2) {
#line 6881
      *(t + -1) = (char )((int )*(t + -1) | 128);
#line 6882
      meta___0 = 0;
    }
#line 6884
    if (control) {
#line 6885
      if ((int )*(t + -1) == 63) {
#line 6886
        *(t + -1) = (char)127;
      } else {
#line 6888
        *(t + -1) = (char )((int )*(t + -1) & 159);
      }
#line 6889
      control = 0;
    }
#line 6891
    if (meta___0) {
#line 6892
      *(t + -1) = (char )((int )*(t + -1) | 128);
#line 6893
      meta___0 = 0;
    }
#line 6895
    if (how & 16) {
#line 6897
      t2___0 = tbuf___0;
      {
#line 6897
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 6897
        if (! ((unsigned long )t2___0 < (unsigned long )t)) {
#line 6897
          goto while_break___4;
        }
#line 6902
        if (opts[135]) {
#line 6903
          if ((int )*t2___0 == 0) {
#line 6904
            ignoring = 1;
          }
#line 6905
          if (ignoring) {
#line 6906
            goto while_break___4;
          }
        }
#line 6908
        if ((int )typtab[(unsigned char )*t2___0] & (1 << 12)) {
#line 6909
          tmp___37 = tdest;
#line 6909
          tdest ++;
#line 6909
          *tmp___37 = (char)-125;
#line 6910
          tmp___38 = tdest;
#line 6910
          tdest ++;
#line 6910
          *tmp___38 = (char )((int )*t2___0 ^ 32);
        } else {
#line 6912
          tmp___39 = tdest;
#line 6912
          tdest ++;
#line 6912
          *tmp___39 = *t2___0;
        }
#line 6897
        t2___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 6918
      t = tbuf___0;
    }
#line 6920
    if (how & 64) {
#line 6920
      if ((unsigned long )t != (unsigned long )(tmp)) {
#line 6921
        *misc = (int )((unsigned char )tmp[0]);
#line 6922
        return (s + 1);
      }
    }
    __Cont: /* CIL Label */ 
#line 6549
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6932
  *t = (char )'\000';
#line 6933
  if (how & 16) {
#line 6934
    *tdest = (char )'\000';
  }
#line 6935
  if (how & 64) {
#line 6936
    *misc = 0;
  } else {
#line 6938
    if (how & 16) {
#line 6938
      tmp___40 = tdest;
    } else {
#line 6938
      tmp___40 = t;
    }
#line 6938
    *len = (int )(tmp___40 - buf___7);
  }
#line 6939
  return (buf___7);
}
}
#line 6945 "/tmp/zsh-5.4.2/Src/utils.c"
int strpfx(char const   *s , char const   *t ) 
{ 


  {
  {
#line 6948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6948
    if (*s) {
#line 6948
      if (! ((int const   )*s == (int const   )*t)) {
#line 6948
        goto while_break;
      }
    } else {
#line 6948
      goto while_break;
    }
#line 6949
    s ++;
#line 6949
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6950
  return (! *s);
}
}
#line 6956 "/tmp/zsh-5.4.2/Src/utils.c"
int strsfx(char *s , char *t ) 
{ 
  int ls ;
  size_t tmp ;
  int lt ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 6959
  tmp = strlen((char const   *)s);
#line 6959
  ls = (int )tmp;
#line 6959
  tmp___0 = strlen((char const   *)t);
#line 6959
  lt = (int )tmp___0;
  }
#line 6961
  if (ls <= lt) {
    {
#line 6962
    tmp___1 = strcmp((char const   *)((t + lt) - ls), (char const   *)s);
    }
#line 6962
    if (tmp___1) {
#line 6962
      tmp___2 = 0;
    } else {
#line 6962
      tmp___2 = 1;
    }
#line 6962
    return (tmp___2);
  }
#line 6963
  return (0);
}
}
#line 6967 "/tmp/zsh-5.4.2/Src/utils.c"
static int upchdir(int n ) 
{ 
  char buf___7[4097] ;
  char *s ;
  int err ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 6972
  err = -1;
  {
#line 6974
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6974
    if (! (n > 0)) {
#line 6974
      goto while_break;
    }
#line 6975
    s = buf___7;
    {
#line 6975
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6975
      if ((unsigned long )s < (unsigned long )((buf___7 + 4096) - 4)) {
#line 6975
        tmp___2 = n;
#line 6975
        n --;
#line 6975
        if (! tmp___2) {
#line 6975
          goto while_break___0;
        }
      } else {
#line 6975
        goto while_break___0;
      }
#line 6976
      tmp = s;
#line 6976
      s ++;
#line 6976
      *tmp = (char )'.';
#line 6976
      tmp___0 = s;
#line 6976
      s ++;
#line 6976
      *tmp___0 = (char )'.';
#line 6976
      tmp___1 = s;
#line 6976
      s ++;
#line 6976
      *tmp___1 = (char )'/';
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 6977
    *(s + -1) = (char )'\000';
#line 6978
    tmp___3 = chdir((char const   *)(buf___7));
    }
#line 6978
    if (tmp___3) {
#line 6979
      return (err);
    }
#line 6980
    err = -2;
  }
  while_break: /* CIL Label */ ;
  }
#line 6982
  return (0);
}
}
#line 6992 "/tmp/zsh-5.4.2/Src/utils.c"
void init_dirsav(Dirsav d___0 ) 
{ 
  dev_t tmp ;
  int tmp___0 ;

  {
#line 6995
  tmp = (dev_t )0;
#line 6995
  d___0->dev = tmp;
#line 6995
  d___0->ino = tmp;
#line 6996
  d___0->dirname = (char *)((void *)0);
#line 6997
  tmp___0 = -1;
#line 6997
  d___0->level = tmp___0;
#line 6997
  d___0->dirfd = tmp___0;
#line 6998
  return;
}
}
#line 7011 "/tmp/zsh-5.4.2/Src/utils.c"
int lchdir(char const   *path___0 , struct dirsav *d___0 , int hard ) 
{ 
  char const   *pptr ;
  int level ;
  struct stat st1 ;
  struct dirsav ds ;
  char buf___7[4097] ;
  char *ptr___0 ;
  int err ;
  struct stat st2 ;
  int close_dir ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int restoreerr ;
  int *tmp___13 ;
  int i ;
  char const   *cdest ;
  int tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;

  {
#line 7024
  close_dir = 0;
#line 7027
  if (! d___0) {
    {
#line 7028
    init_dirsav(& ds);
#line 7029
    d___0 = & ds;
    }
  }
#line 7032
  if ((int const   )*path___0 == 47) {
#line 7032
    goto _L___0;
  } else
#line 7032
  if (! hard) {
    _L___0: /* CIL Label */ 
#line 7032
    if ((unsigned long )d___0 != (unsigned long )(& ds)) {
#line 7037
      level = -1;
    } else
#line 7032
    if (hard) {
#line 7037
      level = -1;
    } else {
#line 7032
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 7043
    level = 0;
#line 7044
    if (! d___0->dev) {
#line 7044
      if (! d___0->ino) {
        {
#line 7045
        stat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& st1));
#line 7046
        d___0->dev = st1.st_dev;
#line 7047
        d___0->ino = st1.st_ino;
        }
      }
    }
  }
#line 7052
  if (! hard) {
#line 7055
    if ((unsigned long )d___0 != (unsigned long )(& ds)) {
#line 7056
      pptr = path___0;
      {
#line 7056
      while (1) {
        while_continue: /* CIL Label */ ;
#line 7056
        if (! *pptr) {
#line 7056
          goto while_break;
        }
        {
#line 7057
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 7057
          if (*pptr) {
#line 7057
            tmp = pptr;
#line 7057
            pptr ++;
#line 7057
            if (! ((int const   )*tmp != 47)) {
#line 7057
              goto while_break___0;
            }
          } else {
#line 7057
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 7058
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 7058
          if (! ((int const   )*pptr == 47)) {
#line 7058
            goto while_break___1;
          }
#line 7059
          pptr ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 7056
        level ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 7061
      d___0->level = level;
    }
    {
#line 7063
    tmp___0 = zchdir((char *)path___0);
    }
#line 7063
    return (tmp___0);
  }
#line 7068
  if (d___0->dirfd < 0) {
    {
#line 7069
    close_dir = 1;
#line 7070
    tmp___1 = open(".", 256);
#line 7070
    d___0->dirfd = tmp___1;
    }
#line 7070
    if (tmp___1 < 0) {
      {
#line 7070
      tmp___2 = zgetdir(d___0);
      }
#line 7070
      if (tmp___2) {
#line 7070
        if ((int )*(d___0->dirname) != 47) {
          {
#line 7072
          d___0->dirfd = open("..", 256);
          }
        }
      }
    }
  }
#line 7075
  if ((int const   )*path___0 == 47) {
    {
#line 7076
    tmp___4 = chdir("/");
    }
#line 7076
    if (tmp___4 < 0) {
      {
#line 7077
      tmp___3 = __errno_location();
#line 7077
      zwarn("failed to chdir(/): %e", *tmp___3);
      }
    }
  }
  {
#line 7078
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 7079
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 7079
      if (! ((int const   )*path___0 == 47)) {
#line 7079
        goto while_break___3;
      }
#line 7080
      path___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 7081
    if (! *path___0) {
#line 7082
      if ((unsigned long )d___0 == (unsigned long )(& ds)) {
        {
#line 7083
        zsfree(ds.dirname);
        }
      } else {
#line 7085
        d___0->level = level;
      }
#line 7087
      if (d___0->dirfd >= 0) {
#line 7087
        if (close_dir) {
          {
#line 7088
          close(d___0->dirfd);
#line 7089
          d___0->dirfd = -1;
          }
        }
      }
#line 7092
      return (0);
    }
#line 7094
    pptr = path___0;
    {
#line 7094
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 7094
      pptr ++;
#line 7094
      if (*pptr) {
#line 7094
        if (! ((int const   )*pptr != 47)) {
#line 7094
          goto while_break___4;
        }
      } else {
#line 7094
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 7095
    if (pptr - path___0 > 4096L) {
#line 7096
      err = 36;
#line 7097
      goto while_break___2;
    }
#line 7099
    ptr___0 = buf___7;
    {
#line 7099
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 7099
      if (! ((unsigned long )path___0 != (unsigned long )pptr)) {
#line 7099
        goto while_break___5;
      }
#line 7100
      tmp___5 = ptr___0;
#line 7100
      ptr___0 ++;
#line 7100
      tmp___6 = path___0;
#line 7100
      path___0 ++;
#line 7100
      *tmp___5 = (char )*tmp___6;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 7101
    *ptr___0 = (char)0;
#line 7102
    tmp___8 = lstat((char const   */* __restrict  */)(buf___7), (struct stat */* __restrict  */)(& st1));
    }
#line 7102
    if (tmp___8) {
      {
#line 7103
      tmp___7 = __errno_location();
#line 7103
      err = *tmp___7;
      }
#line 7104
      goto while_break___2;
    }
#line 7106
    if (! ((st1.st_mode & 61440U) == 16384U)) {
#line 7107
      err = 20;
#line 7108
      goto while_break___2;
    }
    {
#line 7110
    tmp___10 = chdir((char const   *)(buf___7));
    }
#line 7110
    if (tmp___10) {
      {
#line 7111
      tmp___9 = __errno_location();
#line 7111
      err = *tmp___9;
      }
#line 7112
      goto while_break___2;
    }
#line 7114
    if (level >= 0) {
#line 7115
      level ++;
    }
    {
#line 7116
    tmp___12 = lstat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& st2));
    }
#line 7116
    if (tmp___12) {
      {
#line 7117
      tmp___11 = __errno_location();
#line 7117
      err = *tmp___11;
      }
#line 7118
      goto while_break___2;
    }
#line 7120
    if (st1.st_dev != st2.st_dev) {
#line 7121
      err = 20;
#line 7122
      goto while_break___2;
    } else
#line 7120
    if (st1.st_ino != st2.st_ino) {
#line 7121
      err = 20;
#line 7122
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 7125
  tmp___17 = restoredir(d___0);
  }
#line 7125
  if (tmp___17) {
    {
#line 7126
    tmp___13 = __errno_location();
#line 7126
    restoreerr = *tmp___13;
#line 7132
    i = 0;
    }
    {
#line 7132
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 7132
      if (! (i < 2)) {
#line 7132
        goto while_break___6;
      }
#line 7134
      if (i) {
#line 7135
        cdest = "/";
      } else {
#line 7137
        if (! home) {
#line 7138
          goto __Cont;
        }
#line 7139
        cdest = (char const   *)home;
      }
      {
#line 7141
      zsfree(pwd);
#line 7142
      pwd = ztrdup(cdest);
#line 7143
      tmp___14 = chdir((char const   *)pwd);
      }
#line 7143
      if (tmp___14 == 0) {
#line 7144
        goto while_break___6;
      }
      __Cont: /* CIL Label */ 
#line 7132
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 7146
    if (i == 2) {
      {
#line 7147
      tmp___15 = __errno_location();
#line 7147
      zerr("lost current directory, failed to cd to /: %e", *tmp___15);
      }
    } else {
      {
#line 7149
      zerr("lost current directory: %e: changed to `%s\'", restoreerr, pwd);
      }
    }
#line 7151
    if ((unsigned long )d___0 == (unsigned long )(& ds)) {
      {
#line 7152
      zsfree(ds.dirname);
      }
    }
#line 7154
    if (d___0->dirfd >= 0) {
#line 7154
      if (close_dir) {
        {
#line 7155
        close(d___0->dirfd);
#line 7156
        d___0->dirfd = -1;
        }
      }
    }
    {
#line 7159
    tmp___16 = __errno_location();
#line 7159
    *tmp___16 = err;
    }
#line 7160
    return (-2);
  }
#line 7162
  if ((unsigned long )d___0 == (unsigned long )(& ds)) {
    {
#line 7163
    zsfree(ds.dirname);
    }
  }
#line 7165
  if (d___0->dirfd >= 0) {
#line 7165
    if (close_dir) {
      {
#line 7166
      close(d___0->dirfd);
#line 7167
      d___0->dirfd = -1;
      }
    }
  }
  {
#line 7170
  tmp___18 = __errno_location();
#line 7170
  *tmp___18 = err;
  }
#line 7171
  return (-1);
}
}
#line 7176 "/tmp/zsh-5.4.2/Src/utils.c"
int restoredir(struct dirsav *d___0 ) 
{ 
  int err ;
  struct stat sbuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 7179
  err = 0;
#line 7182
  if (d___0->dirname) {
#line 7182
    if ((int )*(d___0->dirname) == 47) {
      {
#line 7183
      tmp = chdir((char const   *)d___0->dirname);
      }
#line 7183
      return (tmp);
    }
  }
#line 7185
  if (d___0->dirfd >= 0) {
    {
#line 7186
    tmp___1 = fchdir(d___0->dirfd);
    }
#line 7186
    if (tmp___1) {
      {
#line 7195
      close(d___0->dirfd);
#line 7196
      err = -1;
#line 7196
      d___0->dirfd = err;
      }
    } else
#line 7187
    if (! d___0->dirname) {
#line 7188
      return (0);
    } else {
      {
#line 7189
      tmp___0 = chdir((char const   *)d___0->dirname);
      }
#line 7189
      if (tmp___0) {
        {
#line 7190
        close(d___0->dirfd);
#line 7191
        d___0->dirfd = -1;
#line 7192
        err = -2;
        }
      }
    }
  } else
#line 7200
  if (d___0->level > 0) {
    {
#line 7201
    err = upchdir(d___0->level);
    }
  } else
#line 7202
  if (d___0->level < 0) {
#line 7203
    err = -1;
  }
#line 7204
  if (d___0->dev) {
#line 7204
    goto _L;
  } else
#line 7204
  if (d___0->ino) {
    _L: /* CIL Label */ 
    {
#line 7205
    stat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& sbuf));
    }
#line 7206
    if (sbuf.st_ino != d___0->ino) {
#line 7207
      err = -2;
    } else
#line 7206
    if (sbuf.st_dev != d___0->dev) {
#line 7207
      err = -2;
    }
  }
#line 7209
  return (err);
}
}
#line 7219 "/tmp/zsh-5.4.2/Src/utils.c"
int privasserted(void) 
{ 
  __uid_t tmp ;

  {
  {
#line 7222
  tmp = geteuid();
  }
#line 7222
  if (! tmp) {
#line 7223
    return (1);
  }
#line 7241
  return (0);
}
}
#line 7245 "/tmp/zsh-5.4.2/Src/utils.c"
int mode_to_octal(mode_t mode ) 
{ 
  int m ;

  {
#line 7248
  m = 0;
#line 7250
  if (mode & 2048U) {
#line 7251
    m |= 2048;
  }
#line 7252
  if (mode & 1024U) {
#line 7253
    m |= 1024;
  }
#line 7254
  if (mode & 512U) {
#line 7255
    m |= 512;
  }
#line 7256
  if (mode & 256U) {
#line 7257
    m |= 256;
  }
#line 7258
  if (mode & 128U) {
#line 7259
    m |= 128;
  }
#line 7260
  if (mode & 64U) {
#line 7261
    m |= 64;
  }
#line 7262
  if (mode & (unsigned int )(256 >> 3)) {
#line 7263
    m |= 32;
  }
#line 7264
  if (mode & (unsigned int )(128 >> 3)) {
#line 7265
    m |= 16;
  }
#line 7266
  if (mode & (unsigned int )(64 >> 3)) {
#line 7267
    m |= 8;
  }
#line 7268
  if (mode & (unsigned int )((256 >> 3) >> 3)) {
#line 7269
    m |= 4;
  }
#line 7270
  if (mode & (unsigned int )((128 >> 3) >> 3)) {
#line 7271
    m |= 2;
  }
#line 7272
  if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 7273
    m |= 1;
  }
#line 7274
  return (m);
}
}
#line 35 "./parse.epro"
void useeprog(Eprog p ) ;
#line 36
void freeeprog(Eprog p ) ;
#line 37
char *ecgetstr(Estate s , int dup___0 , int *tokflag ) ;
#line 41
LinkList ecgetredirs(Estate s ) ;
#line 5 "./text.epro"
int text_expand_tabs  ;
#line 6
int is_cond_binary_op(char const   *str ) ;
#line 7
void zoutputtab(FILE *outf ) ;
#line 8
char *getpermtext(Eprog prog , Wordcode c , int start_indent ) ;
#line 9
char *getjobtext(Eprog prog , Wordcode c ) ;
#line 10
void getredirs(LinkList redirs ) ;
#line 2 "./text.pro"
static void taddchr(int c ) ;
#line 3
static void taddstr(char const   *s ) ;
#line 4
static void taddlist(Estate state , int num ) ;
#line 5
static void taddassignlist(Estate state , wordcode count ) ;
#line 6
static void taddnl(int no_semicolon ) ;
#line 7
static void gettext2(Estate state ) ;
#line 48 "/tmp/zsh-5.4.2/Src/text.c"
static char const   *cond_binary_ops[16]  = 
#line 48 "/tmp/zsh-5.4.2/Src/text.c"
  {      "=",      "==",      "!=",      "<", 
        ">",      "-nt",      "-ot",      "-ef", 
        "-eq",      "-ne",      "-lt",      "-gt", 
        "-le",      "-ge",      "=~",      (char const   *)((void *)0)};
#line 53 "/tmp/zsh-5.4.2/Src/text.c"
static char *tptr  ;
#line 53 "/tmp/zsh-5.4.2/Src/text.c"
static char *tbuf  ;
#line 53 "/tmp/zsh-5.4.2/Src/text.c"
static char *tlim  ;
#line 53 "/tmp/zsh-5.4.2/Src/text.c"
static char *tpending  ;
#line 54 "/tmp/zsh-5.4.2/Src/text.c"
static int tsiz  ;
#line 54 "/tmp/zsh-5.4.2/Src/text.c"
static int tindent  ;
#line 54 "/tmp/zsh-5.4.2/Src/text.c"
static int tnewlins  ;
#line 54 "/tmp/zsh-5.4.2/Src/text.c"
static int tjob  ;
#line 57 "/tmp/zsh-5.4.2/Src/text.c"
int is_cond_binary_op(char const   *str ) 
{ 
  char const   **op___0 ;
  int tmp ;

  {
#line 61
  op___0 = cond_binary_ops;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! *op___0) {
#line 61
      goto while_break;
    }
    {
#line 63
    tmp = strcmp(str, *op___0);
    }
#line 63
    if (! tmp) {
#line 64
      return (1);
    }
#line 61
    op___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return (0);
}
}
#line 69 "/tmp/zsh-5.4.2/Src/text.c"
static void dec_tindent(void) 
{ 


  {
#line 73
  if (tindent > 0) {
#line 74
    tindent --;
  }
#line 75
  return;
}
}
#line 88 "/tmp/zsh-5.4.2/Src/text.c"
static void taddpending(char *str1 , char *str2 ) 
{ 
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  int oldlen ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 91
  tmp = strlen((char const   *)str1);
#line 91
  tmp___0 = strlen((char const   *)str2);
#line 91
  len = (int )((tmp + tmp___0) + 1UL);
  }
#line 101
  if (tpending) {
    {
#line 102
    tmp___1 = strlen((char const   *)tpending);
#line 102
    oldlen = (int )tmp___1;
#line 103
    tmp___2 = zrealloc((void *)tpending, (size_t )((len + oldlen) + 1));
#line 103
    tpending = (char *)tmp___2;
#line 104
    sprintf((char */* __restrict  */)(tpending + oldlen), (char const   */* __restrict  */)"\n%s%s",
            str1, str2);
    }
  } else {
    {
#line 106
    tmp___3 = zalloc((size_t )len);
#line 106
    tpending = (char *)tmp___3;
#line 107
    sprintf((char */* __restrict  */)tpending, (char const   */* __restrict  */)"%s%s",
            str1, str2);
    }
  }
#line 109
  return;
}
}
#line 113 "/tmp/zsh-5.4.2/Src/text.c"
static void tdopending(void) 
{ 


  {
#line 116
  if (tpending) {
    {
#line 117
    taddchr('\n');
#line 118
    taddstr((char const   *)tpending);
#line 119
    zsfree(tpending);
#line 120
    tpending = (char *)((void *)0);
    }
  }
#line 122
  return;
}
}
#line 127 "/tmp/zsh-5.4.2/Src/text.c"
static void taddchr(int c ) 
{ 
  char *tmp ;
  void *tmp___0 ;

  {
#line 130
  tmp = tptr;
#line 130
  tptr ++;
#line 130
  *tmp = (char )c;
#line 131
  if ((unsigned long )tptr == (unsigned long )tlim) {
#line 132
    if (! tbuf) {
#line 133
      tptr --;
#line 134
      return;
    }
    {
#line 136
    tsiz *= 2;
#line 136
    tmp___0 = zrealloc((void *)tbuf, (size_t )tsiz);
#line 136
    tbuf = (char *)tmp___0;
#line 137
    tlim = tbuf + tsiz;
#line 138
    tptr = tbuf + tsiz / 2;
    }
  }
#line 140
  return;
}
}
#line 145 "/tmp/zsh-5.4.2/Src/text.c"
static void taddstr(char const   *s ) 
{ 
  int sl ;
  size_t tmp ;
  char c ;
  int x ;
  void *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 148
  tmp = strlen(s);
#line 148
  sl = (int )tmp;
  }
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! ((unsigned long )(tptr + sl) >= (unsigned long )tlim)) {
#line 151
      goto while_break;
    }
#line 152
    x = (int )(tptr - tbuf);
#line 154
    if (! tbuf) {
#line 155
      return;
    }
    {
#line 156
    tsiz *= 2;
#line 156
    tmp___0 = zrealloc((void *)tbuf, (size_t )tsiz);
#line 156
    tbuf = (char *)tmp___0;
#line 157
    tlim = tbuf + tsiz;
#line 158
    tptr = tbuf + x;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if (tnewlins) {
    {
#line 161
    memcpy((void */* __restrict  */)tptr, (void const   */* __restrict  */)s, (size_t )sl);
#line 162
    tptr += sl;
    }
  } else {
    {
#line 164
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 164
      tmp___2 = s;
#line 164
      s ++;
#line 164
      c = (char )*tmp___2;
#line 164
      if (! c) {
#line 164
        goto while_break___0;
      }
#line 165
      tmp___1 = tptr;
#line 165
      tptr ++;
#line 165
      if ((int )c == 10) {
#line 165
        *tmp___1 = (char )' ';
      } else {
#line 165
        *tmp___1 = c;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 166
  return;
}
}
#line 169 "/tmp/zsh-5.4.2/Src/text.c"
static void taddlist(Estate state , int num ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 172
  if (num) {
    {
#line 173
    while (1) {
      while_continue: /* CIL Label */ ;
#line 173
      tmp___0 = num;
#line 173
      num --;
#line 173
      if (! tmp___0) {
#line 173
        goto while_break;
      }
      {
#line 174
      tmp = ecgetstr(state, 0, (int *)((void *)0));
#line 174
      taddstr((char const   *)tmp);
#line 175
      taddchr(' ');
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 177
    tptr --;
  }
#line 179
  return;
}
}
#line 183 "/tmp/zsh-5.4.2/Src/text.c"
static void taddassign(wordcode code , Estate state , int typeset ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 187
  tmp = ecgetstr(state, 0, (int *)((void *)0));
#line 187
  taddstr((char const   *)tmp);
  }
#line 189
  if (((code >> 5) & 2U) >> 1 == 1U) {
#line 190
    if (typeset) {
      {
#line 192
      ecgetstr(state, 0, (int *)((void *)0));
#line 193
      taddchr(' ');
      }
#line 194
      return;
    }
    {
#line 196
    taddchr('+');
    }
  }
  {
#line 198
  taddchr('=');
  }
#line 199
  if (((code >> 5) & 1U) == 1U) {
    {
#line 200
    taddchr('(');
#line 201
    taddlist(state, (int )((code >> 5) >> 2));
#line 202
    taddstr(") ");
    }
  } else {
    {
#line 204
    tmp___0 = ecgetstr(state, 0, (int *)((void *)0));
#line 204
    taddstr((char const   *)tmp___0);
#line 205
    taddchr(' ');
    }
  }
#line 207
  return;
}
}
#line 212 "/tmp/zsh-5.4.2/Src/text.c"
static void taddassignlist(Estate state , wordcode count ) 
{ 
  wordcode code ;
  Wordcode tmp ;
  wordcode tmp___0 ;

  {
#line 215
  if (count) {
    {
#line 216
    taddchr(' ');
    }
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    tmp___0 = count;
#line 217
    count --;
#line 217
    if (! tmp___0) {
#line 217
      goto while_break;
    }
    {
#line 218
    tmp = state->pc;
#line 218
    (state->pc) ++;
#line 218
    code = *tmp;
#line 219
    taddassign(code, state, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return;
}
}
#line 226 "/tmp/zsh-5.4.2/Src/text.c"
static void taddnl(int no_semicolon ) 
{ 
  int t0 ;
  int t1 ;

  {
#line 231
  if (tnewlins) {
    {
#line 232
    tdopending();
#line 233
    taddchr('\n');
#line 234
    t0 = 0;
    }
    {
#line 234
    while (1) {
      while_continue: /* CIL Label */ ;
#line 234
      if (! (t0 != tindent)) {
#line 234
        goto while_break;
      }
#line 235
      if (text_expand_tabs >= 0) {
#line 236
        if (text_expand_tabs) {
#line 238
          t1 = 0;
          {
#line 238
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 238
            if (! (t1 < text_expand_tabs)) {
#line 238
              goto while_break___0;
            }
            {
#line 239
            taddchr(' ');
#line 238
            t1 ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 241
          taddchr('\t');
          }
        }
      }
#line 234
      t0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 244
  if (no_semicolon) {
    {
#line 245
    taddstr(" ");
    }
  } else {
    {
#line 247
    taddstr("; ");
    }
  }
#line 249
  return;
}
}
#line 262 "/tmp/zsh-5.4.2/Src/text.c"
void zoutputtab(FILE *outf ) 
{ 
  int i ;

  {
#line 265
  if (text_expand_tabs < 0) {
#line 266
    return;
  }
#line 267
  if (text_expand_tabs) {
#line 269
    i = 0;
    {
#line 269
    while (1) {
      while_continue: /* CIL Label */ ;
#line 269
      if (! (i < text_expand_tabs)) {
#line 269
        goto while_break;
      }
      {
#line 270
      fputc(' ', outf);
#line 269
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 272
    fputc('\t', outf);
    }
  }
#line 273
  return;
}
}
#line 278 "/tmp/zsh-5.4.2/Src/text.c"
char *getpermtext(Eprog prog , Wordcode c , int start_indent ) 
{ 
  struct estate s ;
  void *tmp ;
  sigset_t oset ;

  {
#line 283
  queueing_enabled ++;
#line 285
  if (! c) {
#line 286
    c = prog->prog;
  }
  {
#line 288
  useeprog(prog);
#line 290
  s.prog = prog;
#line 291
  s.pc = c;
#line 292
  s.strs = prog->strs;
#line 294
  tindent = start_indent;
#line 295
  tnewlins = 1;
#line 296
  tsiz = 32;
#line 296
  tmp = zalloc((size_t )tsiz);
#line 296
  tbuf = (char *)tmp;
#line 297
  tptr = tbuf;
#line 298
  tlim = tbuf + tsiz;
#line 299
  tjob = 0;
  }
#line 300
  if (prog->len) {
    {
#line 301
    gettext2(& s);
    }
  }
  {
#line 302
  *tptr = (char )'\000';
#line 303
  freeeprog(prog);
#line 304
  untokenize(tbuf);
  }
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    queueing_enabled --;
#line 306
    if (! queueing_enabled) {
      {
#line 306
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 306
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 306
          if (! (queue_front != queue_rear)) {
#line 306
            goto while_break___1;
          }
          {
#line 306
          queue_front = (queue_front + 1) % 128;
#line 306
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 306
          zhandler(signal_queue[queue_front]);
#line 306
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 306
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 306
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return (tbuf);
}
}
#line 317 "/tmp/zsh-5.4.2/Src/text.c"
static char jbuf[80]  ;
#line 314 "/tmp/zsh-5.4.2/Src/text.c"
char *getjobtext(Eprog prog , Wordcode c ) 
{ 
  struct estate s ;
  sigset_t oset ;

  {
#line 321
  queueing_enabled ++;
#line 323
  if (! c) {
#line 324
    c = prog->prog;
  }
  {
#line 326
  useeprog(prog);
#line 327
  s.prog = prog;
#line 328
  s.pc = c;
#line 329
  s.strs = prog->strs;
#line 331
  tindent = 0;
#line 332
  tnewlins = 0;
#line 333
  tbuf = (char *)((void *)0);
#line 334
  tptr = jbuf;
#line 335
  tlim = (tptr + 80) - 1;
#line 336
  tjob = 1;
#line 337
  gettext2(& s);
#line 338
  *tptr = (char )'\000';
#line 339
  freeeprog(prog);
#line 340
  untokenize(jbuf);
  }
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    queueing_enabled --;
#line 342
    if (! queueing_enabled) {
      {
#line 342
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 342
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 342
          if (! (queue_front != queue_rear)) {
#line 342
            goto while_break___1;
          }
          {
#line 342
          queue_front = (queue_front + 1) % 128;
#line 342
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 342
          zhandler(signal_queue[queue_front]);
#line 342
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 342
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 342
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  return (jbuf);
}
}
#line 391 "/tmp/zsh-5.4.2/Src/text.c"
static Tstack tstack  ;
#line 391 "/tmp/zsh-5.4.2/Src/text.c"
static Tstack tfree  ;
#line 393 "/tmp/zsh-5.4.2/Src/text.c"
static Tstack tpush(wordcode code , int pop___0 ) 
{ 
  Tstack s ;
  void *tmp ;

  {
#line 398
  s = tfree;
#line 398
  if (s) {
#line 399
    tfree = s->prev;
  } else {
    {
#line 401
    tmp = zalloc(sizeof(*s));
#line 401
    s = (Tstack )tmp;
    }
  }
#line 403
  s->prev = tstack;
#line 404
  tstack = s;
#line 405
  s->code = code;
#line 406
  s->pop = pop___0;
#line 408
  return (s);
}
}
#line 412 "/tmp/zsh-5.4.2/Src/text.c"
static void gettext2(Estate state ) 
{ 
  Tstack s ;
  Tstack n ;
  int stack___0 ;
  wordcode code ;
  Wordcode tmp ;
  char const   *tmp___0 ;
  Wordcode tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  Wordcode tmp___5 ;
  Wordcode tmp___6 ;
  int tmp___7 ;
  Wordcode tmp___8 ;
  Wordcode p ;
  Wordcode end ;
  int nargs ;
  Wordcode tmp___9 ;
  int nargs___0 ;
  Wordcode tmp___10 ;
  Wordcode tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  Wordcode tmp___15 ;
  Wordcode tmp___16 ;
  char *tmp___17 ;
  Wordcode tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  Wordcode end___0 ;
  wordcode ialts ;
  char *tmp___21 ;
  Wordcode prev_pc ;
  Wordcode tmp___22 ;
  Wordcode tmp___23 ;
  char *tmp___24 ;
  wordcode tmp___25 ;
  Wordcode prev_pc___0 ;
  wordcode ialts___0 ;
  Wordcode tmp___26 ;
  Wordcode tmp___27 ;
  char *tmp___28 ;
  wordcode tmp___29 ;
  Wordcode end___1 ;
  Wordcode tmp___30 ;
  int ctype ;
  Wordcode tmp___31 ;
  Wordcode tmp___32 ;
  Wordcode tmp___33 ;
  Wordcode tmp___34 ;
  Wordcode tmp___35 ;
  char *tmp___36 ;
  char *name ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char c2[4] ;
  char *tmp___42 ;
  char *tmp___43 ;

  {
#line 416
  stack___0 = 0;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (stack___0) {
#line 421
      s = tstack;
#line 421
      if (! s) {
#line 422
        goto while_break;
      }
#line 423
      if (s->pop) {
#line 424
        tstack = s->prev;
#line 425
        s->prev = tfree;
#line 426
        tfree = s;
      }
#line 428
      code = s->code;
#line 429
      stack___0 = 0;
    } else {
#line 431
      s = (Tstack )((void *)0);
#line 432
      tmp = state->pc;
#line 432
      (state->pc) ++;
#line 432
      code = *tmp;
    }
    {
#line 435
    if ((code & (wordcode )((1 << 5) - 1)) == 1U) {
#line 435
      goto case_1;
    }
#line 457
    if ((code & (wordcode )((1 << 5) - 1)) == 2U) {
#line 457
      goto case_2;
    }
#line 482
    if ((code & (wordcode )((1 << 5) - 1)) == 3U) {
#line 482
      goto case_3;
    }
#line 496
    if ((code & (wordcode )((1 << 5) - 1)) == 4U) {
#line 496
      goto case_4;
    }
#line 506
    if ((code & (wordcode )((1 << 5) - 1)) == 5U) {
#line 506
      goto case_5;
    }
#line 509
    if ((code & (wordcode )((1 << 5) - 1)) == 6U) {
#line 509
      goto case_6;
    }
#line 513
    if ((code & (wordcode )((1 << 5) - 1)) == 7U) {
#line 513
      goto case_7;
    }
#line 518
    if ((code & (wordcode )((1 << 5) - 1)) == 8U) {
#line 518
      goto case_8;
    }
#line 536
    if ((code & (wordcode )((1 << 5) - 1)) == 9U) {
#line 536
      goto case_9;
    }
#line 554
    if ((code & (wordcode )((1 << 5) - 1)) == 10U) {
#line 554
      goto case_10;
    }
#line 568
    if ((code & (wordcode )((1 << 5) - 1)) == 11U) {
#line 568
      goto case_11;
    }
#line 620
    if ((code & (wordcode )((1 << 5) - 1)) == 12U) {
#line 620
      goto case_12;
    }
#line 650
    if ((code & (wordcode )((1 << 5) - 1)) == 13U) {
#line 650
      goto case_13;
    }
#line 670
    if ((code & (wordcode )((1 << 5) - 1)) == 14U) {
#line 670
      goto case_14;
    }
#line 690
    if ((code & (wordcode )((1 << 5) - 1)) == 15U) {
#line 690
      goto case_15;
    }
#line 706
    if ((code & (wordcode )((1 << 5) - 1)) == 16U) {
#line 706
      goto case_16;
    }
#line 805
    if ((code & (wordcode )((1 << 5) - 1)) == 17U) {
#line 805
      goto case_17;
    }
#line 846
    if ((code & (wordcode )((1 << 5) - 1)) == 18U) {
#line 846
      goto case_18;
    }
#line 957
    if ((code & (wordcode )((1 << 5) - 1)) == 19U) {
#line 957
      goto case_19___0;
    }
#line 963
    if ((code & (wordcode )((1 << 5) - 1)) == 20U) {
#line 963
      goto case_20;
    }
#line 967
    if ((code & (wordcode )((1 << 5) - 1)) == 21U) {
#line 967
      goto case_21;
    }
#line 991
    if ((code & (wordcode )((1 << 5) - 1)) == 0U) {
#line 991
      goto case_0___0;
    }
#line 994
    goto switch_default___2;
    case_1: /* CIL Label */ 
#line 436
    if (! s) {
      {
#line 437
      s = tpush(code, (int )((code >> 5) & (unsigned int )(1 << 4)));
#line 438
      stack___0 = 0;
      }
    } else {
#line 440
      if ((code >> 5) & (unsigned int )(1 << 2)) {
        {
#line 441
        taddstr(" &");
        }
#line 442
        if ((code >> 5) & (unsigned int )(1 << 3)) {
          {
#line 443
          taddstr("|");
          }
        }
      }
#line 445
      stack___0 = (int )((code >> 5) & (unsigned int )(1 << 4));
#line 445
      if (! stack___0) {
#line 446
        if (tnewlins) {
          {
#line 447
          taddnl(0);
          }
        } else {
#line 449
          if ((code >> 5) & (unsigned int )(1 << 2)) {
#line 449
            tmp___0 = " ";
          } else {
#line 449
            tmp___0 = "; ";
          }
          {
#line 449
          taddstr(tmp___0);
          }
        }
#line 450
        tmp___1 = state->pc;
#line 450
        (state->pc) ++;
#line 450
        s->code = *tmp___1;
#line 451
        s->pop = (int )((s->code >> 5) & (unsigned int )(1 << 4));
      }
    }
#line 454
    if (! stack___0) {
#line 454
      if ((s->code >> 5) & (unsigned int )(1 << 5)) {
#line 455
        (state->pc) ++;
      }
    }
#line 456
    goto switch_break;
    case_2: /* CIL Label */ 
#line 458
    if (! s) {
#line 459
      if (! (((code >> 5) & 28U) & 16U)) {
#line 459
        if ((*(state->pc) & (wordcode )((1 << 5) - 1)) != 3U) {
#line 461
          stack___0 = -1;
        }
      }
#line 462
      if (((code >> 5) & 28U) & 8U) {
#line 463
        if (stack___0) {
#line 463
          tmp___2 = "!";
        } else {
#line 463
          tmp___2 = "! ";
        }
        {
#line 463
        taddstr(tmp___2);
        }
      }
#line 464
      if (((code >> 5) & 28U) & 4U) {
#line 465
        if (stack___0) {
#line 465
          tmp___3 = "coproc";
        } else {
#line 465
          tmp___3 = "coproc ";
        }
        {
#line 465
        taddstr(tmp___3);
        }
      }
      {
#line 466
      s = tpush(code, ((code >> 5) & 3U) == 0U);
      }
    } else {
#line 468
      stack___0 = ((code >> 5) & 3U) == 0U;
#line 468
      if (! stack___0) {
#line 469
        if (((code >> 5) & 3U) == 2U) {
#line 469
          tmp___4 = " || ";
        } else {
#line 469
          tmp___4 = " && ";
        }
        {
#line 469
        taddstr(tmp___4);
#line 471
        tmp___5 = state->pc;
#line 471
        (state->pc) ++;
#line 471
        s->code = *tmp___5;
#line 472
        s->pop = ((s->code >> 5) & 3U) == 0U;
        }
#line 473
        if (((s->code >> 5) & 28U) & 8U) {
          {
#line 474
          taddstr("! ");
          }
        }
#line 475
        if (((s->code >> 5) & 28U) & 4U) {
          {
#line 476
          taddstr("coproc ");
          }
        }
      }
    }
#line 479
    if (stack___0 < 1) {
#line 479
      if (((s->code >> 5) & 28U) & 16U) {
#line 480
        (state->pc) ++;
      }
    }
#line 481
    goto switch_break;
    case_3: /* CIL Label */ 
#line 483
    if (! s) {
      {
#line 484
      tpush(code, ((code >> 5) & 1U) == 0U);
      }
#line 485
      if (((code >> 5) & 1U) == 1U) {
#line 486
        (state->pc) ++;
      }
    } else {
#line 488
      stack___0 = ((code >> 5) & 1U) == 0U;
#line 488
      if (! stack___0) {
        {
#line 489
        taddstr(" | ");
#line 490
        tmp___6 = state->pc;
#line 490
        (state->pc) ++;
#line 490
        s->code = *tmp___6;
#line 491
        tmp___7 = ((s->code >> 5) & 1U) == 0U;
#line 491
        s->pop = tmp___7;
        }
#line 491
        if (! tmp___7) {
#line 492
          (state->pc) ++;
        }
      }
    }
#line 495
    goto switch_break;
    case_4: /* CIL Label */ 
#line 497
    if (! s) {
      {
#line 498
      (state->pc) --;
#line 499
      n = tpush(code, 1);
#line 500
      n->u._redir.list = ecgetredirs(state);
      }
    } else {
      {
#line 502
      getredirs(s->u._redir.list);
#line 503
      stack___0 = 1;
      }
    }
#line 505
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 507
    taddassign(code, state, 0);
    }
#line 508
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 510
    taddlist(state, (int )(code >> 5));
#line 511
    stack___0 = 1;
    }
#line 512
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 514
    taddlist(state, (int )(code >> 5));
#line 515
    tmp___8 = state->pc;
#line 515
    (state->pc) ++;
#line 515
    taddassignlist(state, *tmp___8);
#line 516
    stack___0 = 1;
    }
#line 517
    goto switch_break;
    case_8: /* CIL Label */ 
#line 519
    if (! s) {
      {
#line 520
      taddstr("(");
#line 521
      tindent ++;
#line 522
      taddnl(1);
#line 523
      n = tpush(code, 1);
#line 524
      n->u._subsh.end = state->pc + (code >> 5);
#line 526
      (state->pc) ++;
      }
    } else {
      {
#line 528
      state->pc = s->u._subsh.end;
#line 529
      dec_tindent();
#line 531
      taddnl(0);
#line 532
      taddstr(")");
#line 533
      stack___0 = 1;
      }
    }
#line 535
    goto switch_break;
    case_9: /* CIL Label */ 
#line 537
    if (! s) {
      {
#line 538
      taddstr("{");
#line 539
      tindent ++;
#line 540
      taddnl(1);
#line 541
      n = tpush(code, 1);
#line 542
      n->u._subsh.end = state->pc + (code >> 5);
#line 544
      (state->pc) ++;
      }
    } else {
      {
#line 546
      state->pc = s->u._subsh.end;
#line 547
      dec_tindent();
#line 549
      taddnl(0);
#line 550
      taddstr("}");
#line 551
      stack___0 = 1;
      }
    }
#line 553
    goto switch_break;
    case_10: /* CIL Label */ 
#line 555
    if (! s) {
      {
#line 556
      taddstr("time");
      }
#line 557
      if (code >> 5 == 1U) {
        {
#line 558
        taddchr(' ');
#line 559
        tindent ++;
#line 560
        tpush(code, 1);
        }
      } else {
#line 562
        stack___0 = 1;
      }
    } else {
      {
#line 564
      dec_tindent();
#line 565
      stack___0 = 1;
      }
    }
#line 567
    goto switch_break;
    case_11: /* CIL Label */ 
#line 569
    if (! s) {
      {
#line 570
      p = state->pc;
#line 571
      end = p + (code >> 5);
#line 572
      tmp___9 = state->pc;
#line 572
      (state->pc) ++;
#line 572
      nargs = (int )*tmp___9;
#line 574
      taddlist(state, nargs);
      }
#line 575
      if (nargs) {
        {
#line 576
        taddstr(" ");
        }
      }
#line 577
      if (tjob) {
        {
#line 578
        taddstr("() { ... }");
#line 579
        state->pc = end;
        }
#line 580
        if (! nargs) {
#line 586
          state->pc += *end;
        }
#line 588
        stack___0 = 1;
      } else {
        {
#line 590
        taddstr("() {");
#line 591
        tindent ++;
#line 592
        taddnl(1);
#line 593
        n = tpush(code, 1);
#line 594
        n->u._funcdef.strs = state->strs;
#line 595
        n->u._funcdef.end = end;
#line 596
        n->u._funcdef.nargs = nargs;
#line 597
        state->strs += *(state->pc);
#line 598
        state->pc += 3;
        }
      }
    } else {
      {
#line 601
      state->strs = s->u._funcdef.strs;
#line 602
      state->pc = s->u._funcdef.end;
#line 603
      dec_tindent();
#line 604
      taddnl(0);
#line 605
      taddstr("}");
      }
#line 606
      if (s->u._funcdef.nargs == 0) {
#line 609
        tmp___10 = state->pc;
#line 609
        (state->pc) ++;
#line 609
        s->u._funcdef.end += *tmp___10;
#line 610
        tmp___11 = state->pc;
#line 610
        (state->pc) ++;
#line 610
        nargs___0 = (int )*tmp___11;
#line 611
        if (nargs___0) {
          {
#line 612
          taddstr(" ");
#line 613
          taddlist(state, nargs___0);
          }
        }
#line 615
        state->pc = s->u._funcdef.end;
      }
#line 617
      stack___0 = 1;
    }
#line 619
    goto switch_break;
    case_12: /* CIL Label */ 
#line 621
    if (! s) {
      {
#line 622
      taddstr("for ");
      }
#line 623
      if (((code >> 5) & 3U) == 2U) {
        {
#line 624
        taddstr("((");
#line 625
        tmp___12 = ecgetstr(state, 0, (int *)((void *)0));
#line 625
        taddstr((char const   *)tmp___12);
#line 626
        taddstr("; ");
#line 627
        tmp___13 = ecgetstr(state, 0, (int *)((void *)0));
#line 627
        taddstr((char const   *)tmp___13);
#line 628
        taddstr("; ");
#line 629
        tmp___14 = ecgetstr(state, 0, (int *)((void *)0));
#line 629
        taddstr((char const   *)tmp___14);
#line 630
        taddstr(")) do");
        }
      } else {
        {
#line 632
        tmp___15 = state->pc;
#line 632
        (state->pc) ++;
#line 632
        taddlist(state, (int )*tmp___15);
        }
#line 633
        if (((code >> 5) & 3U) == 1U) {
          {
#line 634
          taddstr(" in ");
#line 635
          tmp___16 = state->pc;
#line 635
          (state->pc) ++;
#line 635
          taddlist(state, (int )*tmp___16);
          }
        }
        {
#line 637
        taddnl(0);
#line 638
        taddstr("do");
        }
      }
      {
#line 640
      tindent ++;
#line 641
      taddnl(0);
#line 642
      tpush(code, 1);
      }
    } else {
      {
#line 644
      dec_tindent();
#line 645
      taddnl(0);
#line 646
      taddstr("done");
#line 647
      stack___0 = 1;
      }
    }
#line 649
    goto switch_break;
    case_13: /* CIL Label */ 
#line 651
    if (! s) {
      {
#line 652
      taddstr("select ");
#line 653
      tmp___17 = ecgetstr(state, 0, (int *)((void *)0));
#line 653
      taddstr((char const   *)tmp___17);
      }
#line 654
      if (((code >> 5) & 1U) == 1U) {
        {
#line 655
        taddstr(" in ");
#line 656
        tmp___18 = state->pc;
#line 656
        (state->pc) ++;
#line 656
        taddlist(state, (int )*tmp___18);
        }
      }
      {
#line 658
      taddnl(0);
#line 659
      taddstr("do");
#line 660
      taddnl(0);
#line 661
      tindent ++;
#line 662
      tpush(code, 1);
      }
    } else {
      {
#line 664
      dec_tindent();
#line 665
      taddnl(0);
#line 666
      taddstr("done");
#line 667
      stack___0 = 1;
      }
    }
#line 669
    goto switch_break;
    case_14: /* CIL Label */ 
#line 671
    if (! s) {
#line 672
      if (((code >> 5) & 1U) == 1U) {
#line 672
        tmp___19 = "until ";
      } else {
#line 672
        tmp___19 = "while ";
      }
      {
#line 672
      taddstr(tmp___19);
#line 674
      tindent ++;
#line 675
      tpush(code, 0);
      }
    } else
#line 676
    if (! s->pop) {
      {
#line 677
      dec_tindent();
#line 678
      taddnl(0);
#line 679
      taddstr("do");
#line 680
      tindent ++;
#line 681
      taddnl(0);
#line 682
      s->pop = 1;
      }
    } else {
      {
#line 684
      dec_tindent();
#line 685
      taddnl(0);
#line 686
      taddstr("done");
#line 687
      stack___0 = 1;
      }
    }
#line 689
    goto switch_break;
    case_15: /* CIL Label */ 
#line 691
    if (! s) {
      {
#line 692
      taddstr("repeat ");
#line 693
      tmp___20 = ecgetstr(state, 0, (int *)((void *)0));
#line 693
      taddstr((char const   *)tmp___20);
#line 694
      taddnl(0);
#line 695
      taddstr("do");
#line 696
      tindent ++;
#line 697
      taddnl(0);
#line 698
      tpush(code, 1);
      }
    } else {
      {
#line 700
      dec_tindent();
#line 701
      taddnl(0);
#line 702
      taddstr("done");
#line 703
      stack___0 = 1;
      }
    }
#line 705
    goto switch_break;
    case_16: /* CIL Label */ 
#line 707
    if (! s) {
      {
#line 708
      end___0 = state->pc + ((code >> 5) >> 3);
#line 711
      taddstr("case ");
#line 712
      tmp___21 = ecgetstr(state, 0, (int *)((void *)0));
#line 712
      taddstr((char const   *)tmp___21);
#line 713
      taddstr(" in");
      }
#line 715
      if ((unsigned long )state->pc >= (unsigned long )end___0) {
#line 716
        if (tnewlins) {
          {
#line 717
          taddnl(0);
          }
        } else {
          {
#line 719
          taddchr(' ');
          }
        }
        {
#line 720
        taddstr("esac");
#line 721
        stack___0 = 1;
        }
      } else {
#line 724
        tindent ++;
#line 725
        if (tnewlins) {
          {
#line 726
          taddnl(0);
          }
        } else {
          {
#line 728
          taddchr(' ');
          }
        }
        {
#line 729
        taddstr("(");
#line 730
        tmp___22 = state->pc;
#line 730
        (state->pc) ++;
#line 730
        code = *tmp___22;
#line 731
        tmp___23 = state->pc;
#line 731
        (state->pc) ++;
#line 731
        prev_pc = tmp___23;
#line 732
        ialts = *prev_pc;
        }
        {
#line 733
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 733
          tmp___25 = ialts;
#line 733
          ialts --;
#line 733
          if (! tmp___25) {
#line 733
            goto while_break___0;
          }
          {
#line 734
          tmp___24 = ecgetstr(state, 0, (int *)((void *)0));
#line 734
          taddstr((char const   *)tmp___24);
#line 735
          (state->pc) ++;
          }
#line 736
          if (ialts) {
            {
#line 737
            taddstr(" | ");
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 739
        taddstr(") ");
#line 740
        tindent ++;
#line 741
        n = tpush(code, 0);
#line 742
        n->u._case.end = end___0;
#line 743
        n->pop = (unsigned long )(prev_pc + ((code >> 5) >> 3)) >= (unsigned long )end___0;
        }
      }
    } else
#line 745
    if ((unsigned long )state->pc < (unsigned long )s->u._case.end) {
      {
#line 748
      dec_tindent();
      }
      {
#line 750
      if (((code >> 5) & 7U) == 1U) {
#line 750
        goto case_1___0;
      }
#line 754
      if (((code >> 5) & 7U) == 2U) {
#line 754
        goto case_2___0;
      }
#line 758
      goto switch_default;
      case_1___0: /* CIL Label */ 
      {
#line 751
      taddstr(" ;;");
      }
#line 752
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 755
      taddstr(" ;&");
      }
#line 756
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 759
      taddstr(" ;|");
      }
#line 760
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 762
      if (tnewlins) {
        {
#line 763
        taddnl(0);
        }
      } else {
        {
#line 765
        taddchr(' ');
        }
      }
      {
#line 766
      taddstr("(");
#line 767
      tmp___26 = state->pc;
#line 767
      (state->pc) ++;
#line 767
      code = *tmp___26;
#line 768
      tmp___27 = state->pc;
#line 768
      (state->pc) ++;
#line 768
      prev_pc___0 = tmp___27;
#line 769
      ialts___0 = *prev_pc___0;
      }
      {
#line 770
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 770
        tmp___29 = ialts___0;
#line 770
        ialts___0 --;
#line 770
        if (! tmp___29) {
#line 770
          goto while_break___1;
        }
        {
#line 771
        tmp___28 = ecgetstr(state, 0, (int *)((void *)0));
#line 771
        taddstr((char const   *)tmp___28);
#line 772
        (state->pc) ++;
        }
#line 773
        if (ialts___0) {
          {
#line 774
          taddstr(" | ");
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 776
      taddstr(") ");
#line 777
      tindent ++;
#line 778
      s->code = code;
#line 779
      s->pop = (unsigned long )(prev_pc___0 + ((code >> 5) >> 3)) >= (unsigned long )s->u._case.end;
      }
    } else {
      {
#line 782
      dec_tindent();
      }
      {
#line 784
      if (((code >> 5) & 7U) == 1U) {
#line 784
        goto case_1___1;
      }
#line 788
      if (((code >> 5) & 7U) == 2U) {
#line 788
        goto case_2___1;
      }
#line 792
      goto switch_default___0;
      case_1___1: /* CIL Label */ 
      {
#line 785
      taddstr(" ;;");
      }
#line 786
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
      {
#line 789
      taddstr(" ;&");
      }
#line 790
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 793
      taddstr(" ;|");
      }
#line 794
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 796
      dec_tindent();
      }
#line 797
      if (tnewlins) {
        {
#line 798
        taddnl(0);
        }
      } else {
        {
#line 800
        taddchr(' ');
        }
      }
      {
#line 801
      taddstr("esac");
#line 802
      stack___0 = 1;
      }
    }
#line 804
    goto switch_break;
    case_17: /* CIL Label */ 
#line 806
    if (! s) {
      {
#line 807
      end___1 = state->pc + ((code >> 5) >> 2);
#line 809
      taddstr("if ");
#line 810
      tindent ++;
#line 811
      (state->pc) ++;
#line 813
      n = tpush(code, 0);
#line 814
      n->u._if.end = end___1;
#line 815
      n->u._if.cond = 1;
      }
    } else
#line 816
    if (s->pop) {
#line 817
      stack___0 = 1;
    } else
#line 818
    if (s->u._if.cond) {
      {
#line 819
      dec_tindent();
#line 820
      taddnl(0);
#line 821
      taddstr("then");
#line 822
      tindent ++;
#line 823
      taddnl(0);
#line 824
      s->u._if.cond = 0;
      }
    } else
#line 825
    if ((unsigned long )state->pc < (unsigned long )s->u._if.end) {
      {
#line 826
      dec_tindent();
#line 827
      taddnl(0);
#line 828
      tmp___30 = state->pc;
#line 828
      (state->pc) ++;
#line 828
      code = *tmp___30;
      }
#line 829
      if (((code >> 5) & 3U) == 2U) {
        {
#line 830
        taddstr("elif ");
#line 831
        tindent ++;
#line 832
        s->u._if.cond = 1;
        }
      } else {
        {
#line 834
        taddstr("else");
#line 835
        tindent ++;
#line 836
        taddnl(0);
        }
      }
    } else {
      {
#line 839
      s->pop = 1;
#line 840
      dec_tindent();
#line 841
      taddnl(0);
#line 842
      taddstr("fi");
#line 843
      stack___0 = 1;
      }
    }
#line 845
    goto switch_break;
    case_18: /* CIL Label */ 
#line 850
    if (! s) {
      {
#line 851
      taddstr("[[ ");
#line 852
      n = tpush(code, 1);
#line 853
      n->u._cond.par = 2;
      }
    } else
#line 854
    if (s->u._cond.par == 2) {
      {
#line 855
      taddstr(" ]]");
#line 856
      stack___0 = 1;
      }
#line 857
      goto switch_break;
    } else
#line 858
    if (s->u._cond.par == 1) {
      {
#line 859
      taddstr(" )");
#line 860
      stack___0 = 1;
      }
#line 861
      goto switch_break;
    } else
#line 862
    if (((s->code >> 5) & 127U) == 1U) {
      {
#line 863
      taddstr(" && ");
#line 864
      tmp___31 = state->pc;
#line 864
      (state->pc) ++;
#line 864
      code = *tmp___31;
      }
#line 865
      if (((code >> 5) & 127U) == 2U) {
        {
#line 866
        taddstr("( ");
#line 867
        n = tpush(code, 1);
#line 868
        n->u._cond.par = 1;
        }
      }
    } else
#line 870
    if (((s->code >> 5) & 127U) == 2U) {
      {
#line 871
      taddstr(" || ");
#line 872
      tmp___32 = state->pc;
#line 872
      (state->pc) ++;
#line 872
      code = *tmp___32;
      }
#line 873
      if (((code >> 5) & 127U) == 1U) {
        {
#line 874
        taddstr("( ");
#line 875
        n = tpush(code, 1);
#line 876
        n->u._cond.par = 1;
        }
      }
    }
    {
#line 879
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 879
      if (! (! stack___0)) {
#line 879
        goto while_break___2;
      }
#line 880
      ctype = (int )((code >> 5) & 127U);
      {
#line 881
      if (ctype == 0) {
#line 881
        goto case_0;
      }
#line 890
      if (ctype == 1) {
#line 890
        goto case_1___2;
      }
#line 900
      if (ctype == 2) {
#line 900
        goto case_2___2;
      }
#line 910
      if (ctype == 18) {
#line 910
        goto case_18___0;
      }
#line 916
      if (ctype == 19) {
#line 916
        goto case_19;
      }
#line 928
      goto switch_default___1;
      case_0: /* CIL Label */ 
      {
#line 882
      taddstr("! ");
#line 883
      tmp___33 = state->pc;
#line 883
      (state->pc) ++;
#line 883
      code = *tmp___33;
      }
#line 884
      if (((code >> 5) & 127U) <= 2U) {
        {
#line 885
        taddstr("( ");
#line 886
        n = tpush(code, 1);
#line 887
        n->u._cond.par = 1;
        }
      }
#line 889
      goto switch_break___2;
      case_1___2: /* CIL Label */ 
      {
#line 891
      n = tpush(code, 1);
#line 892
      n->u._cond.par = 0;
#line 893
      tmp___34 = state->pc;
#line 893
      (state->pc) ++;
#line 893
      code = *tmp___34;
      }
#line 894
      if (((code >> 5) & 127U) == 2U) {
        {
#line 895
        taddstr("( ");
#line 896
        n = tpush(code, 1);
#line 897
        n->u._cond.par = 1;
        }
      }
#line 899
      goto switch_break___2;
      case_2___2: /* CIL Label */ 
      {
#line 901
      n = tpush(code, 1);
#line 902
      n->u._cond.par = 0;
#line 903
      tmp___35 = state->pc;
#line 903
      (state->pc) ++;
#line 903
      code = *tmp___35;
      }
#line 904
      if (((code >> 5) & 127U) == 1U) {
        {
#line 905
        taddstr("( ");
#line 906
        n = tpush(code, 1);
#line 907
        n->u._cond.par = 1;
        }
      }
#line 909
      goto switch_break___2;
      case_18___0: /* CIL Label */ 
      {
#line 911
      tmp___36 = ecgetstr(state, 0, (int *)((void *)0));
#line 911
      taddstr((char const   *)tmp___36);
#line 912
      taddchr(' ');
#line 913
      taddlist(state, (int )((code >> 5) >> 7));
#line 914
      stack___0 = 1;
      }
#line 915
      goto switch_break___2;
      case_19: /* CIL Label */ 
      {
#line 918
      tmp___37 = ecgetstr(state, 0, (int *)((void *)0));
#line 918
      name = tmp___37;
#line 920
      tmp___38 = ecgetstr(state, 0, (int *)((void *)0));
#line 920
      taddstr((char const   *)tmp___38);
#line 921
      taddchr(' ');
#line 922
      taddstr((char const   *)name);
#line 923
      taddchr(' ');
#line 924
      tmp___39 = ecgetstr(state, 0, (int *)((void *)0));
#line 924
      taddstr((char const   *)tmp___39);
#line 925
      stack___0 = 1;
      }
#line 927
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
#line 929
      if (ctype < 18) {
        {
#line 931
        tmp___40 = ecgetstr(state, 0, (int *)((void *)0));
#line 931
        taddstr((char const   *)tmp___40);
#line 932
        taddstr(" ");
#line 933
        taddstr(cond_binary_ops[ctype - 3]);
#line 934
        taddstr(" ");
#line 935
        tmp___41 = ecgetstr(state, 0, (int *)((void *)0));
#line 935
        taddstr((char const   *)tmp___41);
        }
#line 936
        if (ctype == 3) {
#line 939
          (state->pc) ++;
        } else
#line 936
        if (ctype == 4) {
#line 939
          (state->pc) ++;
        } else
#line 936
        if (ctype == 5) {
#line 939
          (state->pc) ++;
        }
      } else {
        {
#line 944
        c2[0] = (char )'-';
#line 945
        c2[1] = (char )ctype;
#line 946
        c2[2] = (char )' ';
#line 947
        c2[3] = (char )'\000';
#line 948
        taddstr((char const   *)(c2));
#line 949
        tmp___42 = ecgetstr(state, 0, (int *)((void *)0));
#line 949
        taddstr((char const   *)tmp___42);
        }
      }
#line 951
      stack___0 = 1;
#line 952
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 956
    goto switch_break;
    case_19___0: /* CIL Label */ 
    {
#line 958
    taddstr("((");
#line 959
    tmp___43 = ecgetstr(state, 0, (int *)((void *)0));
#line 959
    taddstr((char const   *)tmp___43);
#line 960
    taddstr("))");
#line 961
    stack___0 = 1;
    }
#line 962
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 964
    taddstr("builtin autoload -X");
#line 965
    stack___0 = 1;
    }
#line 966
    goto switch_break;
    case_21: /* CIL Label */ 
#line 968
    if (! s) {
      {
#line 969
      taddstr("{");
#line 970
      tindent ++;
#line 971
      taddnl(0);
#line 972
      n = tpush(code, 0);
#line 973
      (state->pc) ++;
#line 975
      n->u._subsh.end = state->pc + (*(state->pc + -1) >> 5);
      }
    } else
#line 976
    if (! s->pop) {
      {
#line 977
      state->pc = s->u._subsh.end;
#line 978
      dec_tindent();
#line 979
      taddnl(0);
#line 980
      taddstr("} always {");
#line 981
      tindent ++;
#line 982
      taddnl(0);
#line 983
      s->pop = 1;
      }
    } else {
      {
#line 985
      dec_tindent();
#line 986
      taddnl(0);
#line 987
      taddstr("}");
#line 988
      stack___0 = 1;
      }
    }
#line 990
    goto switch_break;
    case_0___0: /* CIL Label */ 
#line 992
    stack___0 = 1;
#line 993
    goto switch_break;
    switch_default___2: /* CIL Label */ ;
#line 996
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 999
  tdopending();
  }
#line 1000
  return;
}
}
#line 1007 "/tmp/zsh-5.4.2/Src/text.c"
static char *fstr[18]  = 
#line 1007
  {      (char *)">",      (char *)">|",      (char *)">>",      (char *)">>|", 
        (char *)"&>",      (char *)"&>|",      (char *)"&>>",      (char *)"&>>|", 
        (char *)"<>",      (char *)"<",      (char *)"<<",      (char *)"<<-", 
        (char *)"<<<",      (char *)"<&",      (char *)">&",      (char *)((void *)0), 
        (char *)"<",      (char *)">"};
#line 1003 "/tmp/zsh-5.4.2/Src/text.c"
void getredirs(LinkList redirs ) 
{ 
  LinkNode n ;
  Redir f ;
  int tmp ;
  int fnamelen ;
  int sav ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  sigset_t oset ;

  {
  {
#line 1013
  queueing_enabled ++;
#line 1015
  taddchr(' ');
#line 1016
  n = redirs->list.first;
  }
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1016
    if (! n) {
#line 1016
      goto while_break;
    }
#line 1017
    f = (Redir )n->dat;
    {
#line 1034
    if (f->type == 17) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 16) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 14) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 13) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 12) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 8) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 9) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 7) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 6) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 5) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 4) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 3) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 2) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 1) {
#line 1034
      goto case_17;
    }
#line 1034
    if (f->type == 0) {
#line 1034
      goto case_17;
    }
#line 1019
    goto switch_break;
    case_17: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1035
    if (f->varid) {
      {
#line 1036
      taddchr('{');
#line 1037
      taddstr((char const   *)f->varid);
#line 1038
      taddchr('}');
      }
    } else {
#line 1039
      if (f->type >= 8) {
#line 1039
        if (f->type <= 13) {
#line 1039
          tmp = 0;
        } else {
#line 1039
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1039
      if (f->type == 16) {
#line 1039
        tmp = 0;
      } else {
#line 1039
        tmp = 1;
      }
#line 1039
      if (f->fd1 != tmp) {
        {
#line 1040
        taddchr(48 + f->fd1);
        }
      }
    }
#line 1041
    if (f->type == 12) {
#line 1041
      if (f->flags & 1) {
#line 1043
        if (tnewlins) {
          {
#line 1049
          taddstr((char const   *)fstr[10]);
#line 1050
          taddstr((char const   *)f->here_terminator);
#line 1051
          taddpending(f->name, f->munged_here_terminator);
          }
        } else {
          {
#line 1054
          taddstr((char const   *)fstr[12]);
#line 1059
          tmp___0 = strlen((char const   *)f->name);
#line 1059
          fnamelen = (int )tmp___0;
          }
#line 1060
          if (fnamelen > 0) {
#line 1060
            if ((int )*(f->name + (fnamelen - 1)) == 10) {
#line 1061
              sav = 1;
#line 1062
              *(f->name + (fnamelen - 1)) = (char )'\000';
            } else {
#line 1064
              sav = 0;
            }
          } else {
#line 1064
            sav = 0;
          }
          {
#line 1070
          tmp___3 = has_token((char const   *)f->name);
          }
#line 1070
          if (tmp___3) {
            {
#line 1075
            taddchr('\"');
#line 1076
            tmp___2 = quotestring((char const   *)f->name, 3);
#line 1076
            taddstr((char const   *)tmp___2);
#line 1077
            taddchr('\"');
            }
          } else {
            {
#line 1071
            taddchr('\'');
#line 1072
            tmp___1 = quotestring((char const   *)f->name, 2);
#line 1072
            taddstr((char const   *)tmp___1);
#line 1073
            taddchr('\'');
            }
          }
#line 1079
          if (sav) {
#line 1080
            *(f->name + (fnamelen - 1)) = (char )'\n';
          }
        }
      } else {
#line 1041
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 1083
      taddstr((char const   *)fstr[f->type]);
      }
#line 1084
      if (f->type != 13) {
#line 1084
        if (f->type != 14) {
          {
#line 1085
          taddchr(' ');
          }
        }
      }
      {
#line 1086
      taddstr((char const   *)f->name);
      }
    }
    {
#line 1088
    taddchr(' ');
    }
#line 1089
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1016
    n = n->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1101
  tptr --;
  {
#line 1103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1103
    queueing_enabled --;
#line 1103
    if (! queueing_enabled) {
      {
#line 1103
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1103
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1103
          if (! (queue_front != queue_rear)) {
#line 1103
            goto while_break___2;
          }
          {
#line 1103
          queue_front = (queue_front + 1) % 128;
#line 1103
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1103
          zhandler(signal_queue[queue_front]);
#line 1103
          signal_setmask(oset);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1103
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1103
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1104
  return;
}
}
#line 606 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 13 "./builtin.epro"
LinkList dirstack ;
#line 43
void zexit(int val , int from_where ) ;
#line 25 "./compat.epro"
char *zgetcwd(void) ;
#line 37 "./exec.epro"
char *findcmd(char *arg0 , int docopy , int default_path ) ;
#line 52
LinkList getoutput(char *cmd , int qt ) ;
#line 54
char *getoutputfile(char *cmd , char **eptr ) ;
#line 55
char *getproc(char *cmd , char **eptr ) ;
#line 5 "./glob.epro"
int badcshglob ;
#line 11
void zglob(LinkList list , LinkNode np , int nountok ) ;
#line 13
int hasbraces(char *str ) ;
#line 15
void xpandbraces(LinkList list , LinkNode *np ) ;
#line 17
int getmatch(char **sp___0 , char *pat , int fl , int n , char *replstr ) ;
#line 18
void getmatcharr(char ***ap , char *pat , int fl , int n , char *replstr ) ;
#line 25
void shtokenize(char *s ) ;
#line 7 "./hashtable.epro"
extern void deletehashtable(HashTable ht ) ;
#line 9
extern HashNode addhashnode2(HashTable ht , char *nam , void *nodeptr ) ;
#line 11
extern HashNode gethashnode2(HashTable ht , char const   *nam ) ;
#line 29 "./hist.epro"
char *hsubl ;
#line 30
char *hsubr ;
#line 59
int chabspath(char **junkptr ) ;
#line 60
int chrealpath(char **junkptr ) ;
#line 61
int remtpath(char **junkptr ) ;
#line 62
int remtext(char **junkptr ) ;
#line 63
int rembutext(char **junkptr ) ;
#line 64
int remlpaths(char **junkptr ) ;
#line 65
char *casemodify(char *str , int how ) ;
#line 66
int subst(char **strptr , char *in , char *out , int gbal ) ;
#line 76
LinkList bufferwords(LinkList list , char *buf___7 , int *index___0 , int flags ) ;
#line 37 "./lex.epro"
int parsestrnoerr(char **s ) ;
#line 38
char *parse_subscript(char *s , int sub , int endchar ) ;
#line 39
int parse_subst_string(char *s ) ;
#line 10 "./linklist.epro"
void insertlinklist(LinkList l , LinkNode where , LinkList x ) ;
#line 14
void *uremnode(LinkList list , LinkNode nd ) ;
#line 16
int countlinknodes(LinkList list ) ;
#line 22
char **hlinklist2array(LinkList list , int copy ) ;
#line 9 "./math.epro"
int outputradix ;
#line 10
int outputunderscore ;
#line 12
mnumber matheval(char *s ) ;
#line 13
zlong mathevali(char *s ) ;
#line 6 "./params.epro"
char **pparams ;
#line 20
char *oldpwd ;
#line 39
zlong mypid ;
#line 63
struct gsu_array  const  vararray_gsu ;
#line 72
char **paramvalarr(HashTable ht , int flags ) ;
#line 76
Param createparam(char *name , int flags ) ;
#line 80
int getindex(char **pptr , Value v , int flags ) ;
#line 82
Value fetchvalue(Value v , char **pptr , int bracks , int flags ) ;
#line 83
char *getstrvalue(Value v ) ;
#line 84
char **getarrvalue(Value v ) ;
#line 100
Param setsparam(char *s , char *val ) ;
#line 102
Param setaparam(char *s , char **aval ) ;
#line 103
Param sethparam(char *s , char **val ) ;
#line 136
HashTable newuniqtable(zlong size ) ;
#line 138
void zhuniqarray(char **x ) ;
#line 196
char *convbase_underscore(char *s , zlong v , int base , int underscore ) ;
#line 198
char *convfloat_underscore(double dval , int underscore ) ;
#line 6 "./sort.epro"
void strmetasort(char **array , int sortwhat , int *unmetalenp ) ;
#line 6 "./subst.epro"
void prefork(LinkList list , int flags , int *ret_flags ) ;
#line 7
char *quotesubst(char *str ) ;
#line 8
void globlist(LinkList list , int nountok ) ;
#line 10
void filesub(char **namptr , int assign ) ;
#line 11
char *equalsubstr(char *str , int assign , int nomatch ) ;
#line 12
int filesubstr(char **namptr , int assign ) ;
#line 13
char *get_strarg(char *s , int *lenp ) ;
#line 14
void modify(char **str , char **ptr___0 ) ;
#line 2 "./subst.pro"
static char *stringsubstquote(char *strstart , char **pstrdpos ) ;
#line 3
static LinkNode stringsubst(LinkList list , LinkNode node , int pf_flags , int *ret_flags ,
                            int asssub ) ;
#line 4
static int multsub(char **s , int pf_flags , char ***a , int *isarr , char *sep ,
                   int *ms_flags ) ;
#line 5
static char *strcatsub(char **d___0 , char *pb , char *pe , char *src , int l , char *s ,
                       int glbsub , int copied ) ;
#line 6
static int get_intarg(char **s , int *delmatchp ) ;
#line 7
static LinkNode paramsubst(LinkList l , LinkNode n , char **str , int qt , int pf_flags ,
                           int *ret_flags ) ;
#line 8
static char *arithsubst(char *a , char **bptr , char *rest ) ;
#line 9
static char *dstackent(char ch , int val ) ;
#line 36 "/tmp/zsh-5.4.2/Src/subst.c"
char nulstring[2]  = {      (char)-95,      (char )'\000'};
#line 56 "/tmp/zsh-5.4.2/Src/subst.c"
void prefork(LinkList list , int flags , int *ret_flags ) 
{ 
  LinkNode node ;
  LinkNode stop ;
  int keep ;
  int asssub ;
  int tmp ;
  int ret_flags_local ;
  char *cptr ;
  sigset_t oset ;
  int tmp___0 ;
  char *cptr___0 ;
  sigset_t oset___0 ;
  sigset_t oset___1 ;

  {
#line 59
  stop = (LinkNode )0;
#line 60
  keep = 0;
#line 60
  if (flags & 1) {
#line 60
    if (opts[99]) {
#line 60
      tmp = 1;
    } else {
#line 60
      tmp = 0;
    }
  } else {
#line 60
    tmp = 0;
  }
#line 60
  asssub = tmp;
#line 61
  ret_flags_local = 0;
#line 62
  if (! ret_flags) {
#line 63
    ret_flags = & ret_flags_local;
  }
#line 65
  queueing_enabled ++;
#line 66
  node = list->list.first;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! node) {
#line 66
      goto while_break;
    }
#line 67
    if (opts[158]) {
      {
#line 77
      cptr = (char *)node->dat;
#line 78
      filesub(& cptr, flags & 3);
#line 83
      node->dat = (void *)cptr;
      }
    }
    {
#line 85
    node = stringsubst(list, node, flags & -4, ret_flags, asssub);
    }
#line 85
    if (! node) {
      {
#line 88
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 88
        queueing_enabled --;
#line 88
        if (! queueing_enabled) {
          {
#line 88
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 88
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 88
              if (! (queue_front != queue_rear)) {
#line 88
                goto while_break___2;
              }
              {
#line 88
              queue_front = (queue_front + 1) % 128;
#line 88
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 88
              zhandler(signal_queue[queue_front]);
#line 88
              signal_setmask(oset);
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 88
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 88
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 89
      return;
    }
#line 66
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  node = list->list.first;
  {
#line 92
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 92
    if (! node) {
#line 92
      goto while_break___3;
    }
#line 93
    if ((unsigned long )node == (unsigned long )stop) {
#line 94
      keep = 0;
    }
#line 95
    if (*((char *)node->dat)) {
      {
#line 96
      remnulargs((char *)node->dat);
      }
#line 97
      if (! opts[88]) {
#line 97
        if (! (flags & 4)) {
#line 98
          if (! keep) {
#line 99
            stop = node->next;
          }
          {
#line 100
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 100
            tmp___0 = hasbraces((char *)node->dat);
            }
#line 100
            if (! tmp___0) {
#line 100
              goto while_break___4;
            }
            {
#line 101
            keep = 1;
#line 102
            xpandbraces(list, & node);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
        }
      }
#line 105
      if (! opts[158]) {
        {
#line 106
        cptr___0 = (char *)node->dat;
#line 107
        filesub(& cptr___0, flags & 3);
#line 108
        node->dat = (void *)cptr___0;
        }
      }
    } else
#line 110
    if (! (flags & 4)) {
#line 110
      if (! keep) {
        {
#line 111
        uremnode(list, node);
        }
      }
    }
#line 112
    if (errflag) {
      {
#line 113
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 113
        queueing_enabled --;
#line 113
        if (! queueing_enabled) {
          {
#line 113
          while (1) {
            while_continue___6: /* CIL Label */ ;
            {
#line 113
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 113
              if (! (queue_front != queue_rear)) {
#line 113
                goto while_break___7;
              }
              {
#line 113
              queue_front = (queue_front + 1) % 128;
#line 113
              oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 113
              zhandler(signal_queue[queue_front]);
#line 113
              signal_setmask(oset___0);
              }
            }
            while_break___7: /* CIL Label */ ;
            }
#line 113
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 113
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 114
      return;
    }
#line 92
    node = node->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 117
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 117
    queueing_enabled --;
#line 117
    if (! queueing_enabled) {
      {
#line 117
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 117
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 117
          if (! (queue_front != queue_rear)) {
#line 117
            goto while_break___10;
          }
          {
#line 117
          queue_front = (queue_front + 1) % 128;
#line 117
          oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 117
          zhandler(signal_queue[queue_front]);
#line 117
          signal_setmask(oset___1);
          }
        }
        while_break___10: /* CIL Label */ ;
        }
#line 117
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 117
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 130 "/tmp/zsh-5.4.2/Src/subst.c"
static char *stringsubstquote(char *strstart , char **pstrdpos ) 
{ 
  int len ;
  char *strdpos ;
  char *strsub ;
  char *strret ;
  size_t tmp ;

  {
  {
#line 134
  strdpos = *pstrdpos;
#line 136
  strsub = getkeystring(strdpos + 2, & len, 19, (int *)((void *)0));
#line 138
  len += 2;
  }
#line 140
  if ((unsigned long )strstart != (unsigned long )strdpos) {
#line 141
    *strdpos = (char )'\000';
#line 142
    if (*(strdpos + len)) {
      {
#line 143
      strret = zhtricat((char const   *)strstart, (char const   *)strsub, (char const   *)(strdpos + len));
      }
    } else {
      {
#line 145
      strret = dyncat((char const   *)strstart, (char const   *)strsub);
      }
    }
  } else
#line 146
  if (*(strdpos + len)) {
    {
#line 147
    strret = dyncat((char const   *)strsub, (char const   *)(strdpos + len));
    }
  } else
#line 148
  if (*strsub) {
#line 149
    strret = strsub;
  } else {
    {
#line 152
    strret = dupstring((char const   *)(nulstring));
    }
  }
  {
#line 155
  tmp = strlen((char const   *)strsub);
#line 155
  *pstrdpos = (strret + (strdpos - strstart)) + tmp;
  }
#line 157
  return (strret);
}
}
#line 161 "/tmp/zsh-5.4.2/Src/subst.c"
static LinkNode stringsubst(LinkList list , LinkNode node , int pf_flags , int *ret_flags ,
                            int asssub ) 
{ 
  int qt ;
  char *str3 ;
  char *str ;
  char c ;
  char *subst___0 ;
  char *rest ;
  char *snew ;
  char *sptr ;
  int str3len ;
  int sublen ;
  int restlen ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *str2 ;
  int tmp___2 ;
  char tmp___3 ;
  LinkList pl ;
  char *s ;
  char *str2___0 ;
  char endchar ;
  int l1 ;
  int l2 ;
  int mathpar ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  LinkNode n ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  LinkNode tmp___16 ;

  {
#line 166
  str3 = (char *)node->dat;
#line 167
  str = str3;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! errflag) {
#line 169
      c = *str;
#line 169
      if (! c) {
#line 169
        goto while_break;
      }
    } else {
#line 169
      goto while_break;
    }
#line 170
    c = *str;
#line 170
    if ((int )c == -108) {
#line 170
      goto _L;
    } else
#line 170
    if ((int )c == -106) {
#line 170
      goto _L;
    } else
#line 170
    if ((unsigned long )str == (unsigned long )str3) {
#line 170
      if ((int )c == -115) {
        _L: /* CIL Label */ 
#line 170
        if ((int )*(str + 1) == -120) {
#line 174
          str3len = (int )(str - str3);
#line 176
          if ((int )c == -108) {
            {
#line 177
            subst___0 = getproc(str, & rest);
            }
          } else
#line 176
          if ((int )c == -106) {
            {
#line 177
            subst___0 = getproc(str, & rest);
            }
          } else {
            {
#line 179
            subst___0 = getoutputfile(str, & rest);
            }
          }
#line 180
          if (errflag) {
#line 181
            return ((LinkNode )((void *)0));
          }
#line 182
          if (! subst___0) {
#line 183
            subst___0 = (char *)"";
#line 183
            rest = subst___0;
          }
          {
#line 185
          tmp = strlen((char const   *)subst___0);
#line 185
          sublen = (int )tmp;
#line 186
          tmp___0 = strlen((char const   *)rest);
#line 186
          restlen = (int )tmp___0;
#line 187
          tmp___1 = hcalloc((size_t )(((str3len + sublen) + restlen) + 1));
#line 187
          snew = (char *)tmp___1;
#line 187
          sptr = snew;
          }
#line 188
          if (str3len) {
            {
#line 189
            memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)str3,
                   (size_t )str3len);
#line 190
            sptr += str3len;
            }
          }
#line 192
          if (sublen) {
            {
#line 193
            memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)subst___0,
                   (size_t )sublen);
#line 194
            sptr += sublen;
            }
          }
#line 196
          if (restlen) {
            {
#line 197
            memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)rest,
                   (size_t )restlen);
            }
          }
#line 198
          *(sptr + restlen) = (char )'\000';
#line 199
          str3 = snew;
#line 200
          str = (snew + str3len) + sublen;
#line 201
          node->dat = (void *)str3;
        } else {
#line 203
          str ++;
        }
      } else {
#line 203
        str ++;
      }
    } else {
#line 203
      str ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  str = str3;
  {
#line 207
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 207
    if (! errflag) {
#line 207
      c = *str;
#line 207
      if (! c) {
#line 207
        goto while_break___0;
      }
    } else {
#line 207
      goto while_break___0;
    }
#line 208
    qt = (int )c == -116;
#line 208
    if (qt) {
#line 208
      goto _L___4;
    } else
#line 208
    if ((int )c == -123) {
      _L___4: /* CIL Label */ 
#line 209
      c = *(str + 1);
#line 209
      if ((int )c == -120) {
#line 209
        goto _L___1;
      } else
#line 209
      if ((int )c == -119) {
        _L___1: /* CIL Label */ 
#line 210
        if (! qt) {
#line 211
          list->list.flags |= 1;
        }
#line 212
        str ++;
#line 213
        goto comsub;
      } else
#line 214
      if ((int )c == -111) {
        {
#line 216
        str2 = str;
#line 217
        str2 ++;
#line 218
        tmp___2 = skipparens((char)-111, (char)-110, & str2);
        }
#line 218
        if (tmp___2) {
          {
#line 219
          zerr("closing bracket missing");
          }
#line 220
          return ((LinkNode )((void *)0));
        }
        {
#line 222
        tmp___3 = (char )'\000';
#line 222
        *str = tmp___3;
#line 222
        *(str2 + -1) = tmp___3;
#line 223
        str = arithsubst(str + 2, & str3, str2);
#line 224
        node->dat = (void *)str3;
        }
#line 225
        goto while_continue___0;
      } else
#line 226
      if ((int )c == -99) {
        {
#line 227
        str3 = stringsubstquote(str3, & str);
#line 228
        node->dat = (void *)str3;
        }
#line 229
        goto while_continue___0;
      } else {
#line 243
        if (opts[164]) {
#line 243
          if (! (pf_flags & 32)) {
#line 246
            pf_flags |= 16;
          } else {
#line 243
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 243
        if (pf_flags & 8) {
#line 246
          pf_flags |= 16;
        }
        {
#line 247
        node = paramsubst(list, node, & str, qt, pf_flags & 84, ret_flags);
        }
#line 251
        if (errflag) {
#line 252
          return ((LinkNode )((void *)0));
        } else
#line 251
        if (! node) {
#line 252
          return ((LinkNode )((void *)0));
        }
#line 253
        str3 = (char *)node->dat;
#line 254
        goto while_continue___0;
      }
    } else {
#line 256
      qt = (int )c == -103;
#line 256
      if (qt) {
#line 256
        goto comsub;
      } else {
#line 256
        if ((int )c == -109) {
#line 256
          tmp___14 = list->list.flags | 1;
#line 256
          list->list.flags = tmp___14;
#line 256
          tmp___15 = tmp___14;
        } else {
#line 256
          tmp___15 = 0;
        }
#line 256
        if (tmp___15) {
          comsub: 
#line 259
          str2___0 = str;
#line 263
          if ((int )c == -120) {
            {
#line 264
            endchar = (char)-118;
#line 265
            *(str + -1) = (char )'\000';
#line 270
            skipparens((char)-120, (char)-118, & str);
#line 272
            str --;
            }
          } else
#line 273
          if ((int )c == -119) {
#line 278
            mathpar = 1;
#line 279
            *(str + -1) = (char )'\000';
            {
#line 280
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 280
              if (mathpar) {
#line 280
                if (! *str) {
#line 280
                  goto while_break___1;
                }
              } else {
#line 280
                goto while_break___1;
              }
#line 281
              str ++;
#line 282
              if ((int )*str == -117) {
#line 283
                mathpar --;
              } else
#line 284
              if ((int )*str == -119) {
#line 285
                mathpar ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 287
            if ((int )*str != -117) {
              {
#line 288
              zerr("failed to find end of math substitution");
              }
#line 289
              return ((LinkNode )((void *)0));
            }
#line 291
            *(str + -1) = (char )'\000';
#line 292
            if (opts[52]) {
              {
#line 293
              str = arithsubst(str2___0 + 2, & str3, str + 1);
              }
            } else {
              {
#line 295
              strncpy((char */* __restrict  */)str3, (char const   */* __restrict  */)str2___0,
                      (size_t )1);
              }
            }
#line 296
            node->dat = (void *)str3;
#line 297
            goto while_continue___0;
          } else {
#line 299
            endchar = c;
#line 300
            *str = (char )'\000';
            {
#line 302
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 302
              str ++;
#line 302
              if (! ((int )*str != (int )endchar)) {
#line 302
                goto while_break___2;
              }
#line 303
              if (! *str) {
                {
#line 304
                zerr("failed to find end of command substitution");
                }
#line 305
                return ((LinkNode )((void *)0));
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
#line 309
          tmp___4 = str;
#line 309
          str ++;
#line 309
          *tmp___4 = (char )'\000';
#line 317
          str = str2___0;
          {
#line 317
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 317
            str ++;
#line 317
            c = *str;
#line 317
            if (! c) {
#line 317
              goto while_break___3;
            }
#line 318
            if ((int )typtab[(unsigned char )c] & (1 << 4)) {
#line 318
              if ((int )c != -95) {
#line 318
                if ((int )endchar != -118) {
#line 318
                  if ((int )c == -97) {
#line 318
                    if (! ((int )*(str + 1) == 36)) {
#line 318
                      if (! ((int )*(str + 1) == 92)) {
#line 318
                        if (! ((int )*(str + 1) == 96)) {
#line 318
                          if (qt) {
#line 318
                            if (! ((int )*(str + 1) == 34)) {
#line 322
                              *str = ztokens[(int )c - -124];
                            }
                          } else {
#line 322
                            *str = ztokens[(int )c - -124];
                          }
                        }
                      }
                    }
                  } else {
#line 322
                    *str = ztokens[(int )c - -124];
                  }
                } else {
#line 322
                  *str = ztokens[(int )c - -124];
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 323
          str ++;
#line 324
          if (qt) {
#line 324
            tmp___5 = 1;
          } else
#line 324
          if (pf_flags & 4) {
#line 324
            tmp___5 = 1;
          } else {
#line 324
            tmp___5 = 0;
          }
          {
#line 324
          pl = getoutput(str2___0 + 1, tmp___5);
          }
#line 324
          if (! pl) {
            {
#line 326
            zerr("parse error in command substitution");
            }
#line 327
            return ((LinkNode )((void *)0));
          }
#line 329
          if ((int )endchar == -118) {
#line 330
            str2___0 --;
          }
          {
#line 331
          tmp___8 = ugetnode(pl);
#line 331
          s = (char *)tmp___8;
          }
#line 331
          if (! s) {
            {
#line 332
            tmp___6 = strlen((char const   *)str);
#line 332
            tmp___7 = memmove((void *)str2___0, (void const   *)str, tmp___6 + 1UL);
#line 332
            str = (char *)tmp___7;
            }
#line 333
            goto while_continue___0;
          }
#line 335
          if (! qt) {
#line 335
            if (pf_flags & 4) {
#line 335
              if (opts[66]) {
                {
#line 336
                shtokenize(s);
                }
              }
            }
          }
          {
#line 337
          l1 = (int )(str2___0 - str3);
#line 338
          tmp___9 = strlen((char const   *)s);
#line 338
          l2 = (int )tmp___9;
          }
#line 339
          if ((unsigned long )pl->list.first != (unsigned long )((void *)0)) {
            {
#line 340
            n = pl->list.last;
#line 341
            tmp___10 = hcalloc((size_t )((l1 + l2) + 1));
#line 341
            str2___0 = (char *)tmp___10;
#line 342
            strcpy((char */* __restrict  */)str2___0, (char const   */* __restrict  */)str3);
#line 343
            strcpy((char */* __restrict  */)(str2___0 + l1), (char const   */* __restrict  */)s);
#line 344
            node->dat = (void *)str2___0;
#line 345
            insertlinklist(pl, node, list);
#line 346
            node = n;
#line 346
            s = (char *)node->dat;
#line 347
            l1 = 0;
#line 348
            tmp___11 = strlen((char const   *)s);
#line 348
            l2 = (int )tmp___11;
            }
          }
          {
#line 350
          tmp___12 = strlen((char const   *)str);
#line 350
          tmp___13 = hcalloc(((size_t )(l1 + l2) + tmp___12) + 1UL);
#line 350
          str2___0 = (char *)tmp___13;
          }
#line 351
          if (l1) {
            {
#line 352
            strcpy((char */* __restrict  */)str2___0, (char const   */* __restrict  */)str3);
            }
          }
          {
#line 353
          strcpy((char */* __restrict  */)(str2___0 + l1), (char const   */* __restrict  */)s);
#line 354
          str = strcpy((char */* __restrict  */)((str2___0 + l1) + l2), (char const   */* __restrict  */)str);
#line 355
          str3 = str2___0;
#line 356
          node->dat = (void *)str3;
          }
#line 357
          goto while_continue___0;
        } else
#line 358
        if (asssub) {
#line 358
          if ((int )c == 61) {
#line 358
            goto _L___2;
          } else
#line 358
          if ((int )c == -115) {
            _L___2: /* CIL Label */ 
#line 358
            if ((unsigned long )str != (unsigned long )str3) {
#line 363
              pf_flags |= 4;
            }
          }
        }
      }
    }
#line 365
    str ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 367
  if (errflag) {
#line 367
    tmp___16 = (LinkNode )((void *)0);
  } else {
#line 367
    tmp___16 = node;
  }
#line 367
  return (tmp___16);
}
}
#line 387 "/tmp/zsh-5.4.2/Src/subst.c"
char *quotesubst(char *str ) 
{ 
  char *s ;

  {
#line 390
  s = str;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! *s) {
#line 392
      goto while_break;
    }
#line 393
    if ((int )*s == -123) {
#line 393
      if ((int )*(s + 1) == -99) {
        {
#line 394
        str = stringsubstquote(str, & s);
        }
      } else {
#line 396
        s ++;
      }
    } else {
#line 396
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 399
  remnulargs(str);
  }
#line 400
  return (str);
}
}
#line 404 "/tmp/zsh-5.4.2/Src/subst.c"
void globlist(LinkList list , int nountok ) 
{ 
  LinkNode node ;
  LinkNode next___0 ;

  {
#line 409
  badcshglob = 0;
#line 410
  node = list->list.first;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! errflag) {
#line 410
      if (! node) {
#line 410
        goto while_break;
      }
    } else {
#line 410
      goto while_break;
    }
    {
#line 411
    next___0 = node->next;
#line 412
    zglob(list, node, nountok);
#line 410
    node = next___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 414
  if (noerrs) {
#line 415
    badcshglob = 0;
  } else
#line 416
  if (badcshglob == 1) {
    {
#line 417
    zerr("no match");
    }
  }
#line 418
  return;
}
}
#line 423 "/tmp/zsh-5.4.2/Src/subst.c"
void singsub(char **s ) 
{ 
  union linkroot foo ;
  struct linknode __n0 ;
  void *tmp ;

  {
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    foo.list.first = & __n0;
#line 428
    foo.list.last = & __n0;
#line 428
    foo.list.flags = 0;
#line 428
    __n0.next = (LinkNode )((void *)0);
#line 428
    __n0.prev = & foo.node;
#line 428
    __n0.dat = (void *)*s;
#line 428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 430
  prefork(& foo, 4, (int *)((void *)0));
  }
#line 431
  if (errflag) {
#line 432
    return;
  }
  {
#line 433
  tmp = ugetnode(& foo);
#line 433
  *s = (char *)tmp;
  }
#line 435
  return;
}
}
#line 453 "/tmp/zsh-5.4.2/Src/subst.c"
static int multsub(char **s , int pf_flags , char ***a , int *isarr , char *sep ,
                   int *ms_flags ) 
{ 
  int l ;
  char **r ;
  char **p ;
  char *x ;
  union linkroot foo ;
  struct linknode __n0 ;
  char c ;
  int tmp ;
  LinkNode n ;
  int inq ;
  int inp ;
  int rawc ;
  convchar_t c___0 ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char **tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 458
  x = *s;
#line 461
  if (pf_flags & 8) {
    {
#line 466
    while (1) {
      while_continue: /* CIL Label */ ;
#line 466
      if (! *x) {
#line 466
        goto while_break;
      }
#line 467
      l = (int )*x == -125;
#line 467
      if (l) {
#line 467
        tmp = (int )*(x + 1) ^ 32;
      } else {
#line 467
        tmp = (int )*x;
      }
#line 467
      c = (char )tmp;
#line 468
      l ++;
#line 469
      if (! ((int )typtab[(unsigned char )c] & (1 << 13))) {
#line 470
        goto while_break;
      }
#line 471
      *ms_flags |= 1;
#line 466
      x += l;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 475
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 475
    foo.list.first = & __n0;
#line 475
    foo.list.last = & __n0;
#line 475
    foo.list.flags = 0;
#line 475
    __n0.next = (LinkNode )((void *)0);
#line 475
    __n0.prev = & foo.node;
#line 475
    __n0.dat = (void *)x;
#line 475
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 477
  if (pf_flags & 8) {
    {
#line 478
    n = foo.list.first;
#line 479
    inq = 0;
#line 479
    inp = 0;
#line 480
    mb_charinit();
    }
    {
#line 481
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 481
      if (! *x) {
#line 481
        goto while_break___1;
      }
#line 482
      rawc = -1;
#line 484
      if ((int )*x == -101) {
#line 485
        *x = (char )'-';
      }
#line 486
      if ((int )typtab[(unsigned char )*x] & (1 << 4)) {
#line 488
        rawc = (int )*x;
#line 489
        l = 1;
      } else {
        {
#line 491
        l = mb_metacharlenconv((char const   *)x, & c___0);
        }
#line 492
        if (! inq) {
#line 492
          if (! inp) {
            {
#line 492
            tmp___1 = wcsitype((wchar_t )c___0, 1 << 5);
            }
#line 492
            if (tmp___1) {
#line 493
              *x = (char )'\000';
#line 494
              x += l;
              {
#line 494
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 494
                if (! *x) {
#line 494
                  goto while_break___2;
                }
#line 495
                if ((int )typtab[(unsigned char )*x] & (1 << 4)) {
#line 497
                  rawc = (int )*x;
#line 498
                  l = 1;
#line 499
                  goto while_break___2;
                }
                {
#line 501
                l = mb_metacharlenconv((char const   *)x, & c___0);
#line 502
                tmp___0 = wcsitype((wchar_t )c___0, 1 << 5);
                }
#line 502
                if (! tmp___0) {
#line 503
                  goto while_break___2;
                }
#line 494
                x += l;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 505
              if (! *x) {
#line 506
                *ms_flags |= 2;
#line 507
                goto while_break___1;
              }
              {
#line 509
              insertlinknode(& foo, n, (void *)x);
#line 509
              n = n->next;
              }
            }
          }
        }
      }
      {
#line 515
      if (rawc == -109) {
#line 515
        goto case_neg_109;
      }
#line 515
      if (rawc == -99) {
#line 515
        goto case_neg_109;
      }
#line 515
      if (rawc == -98) {
#line 515
        goto case_neg_109;
      }
#line 519
      if (rawc == -120) {
#line 519
        goto case_neg_120;
      }
#line 522
      if (rawc == -118) {
#line 522
        goto case_neg_118;
      }
#line 526
      if (rawc == -96) {
#line 526
        goto case_neg_96;
      }
#line 526
      if (rawc == -97) {
#line 526
        goto case_neg_96;
      }
#line 512
      goto switch_break;
      case_neg_109: /* CIL Label */ 
      case_neg_99: /* CIL Label */ 
      case_neg_98: /* CIL Label */ 
#line 517
      inq = ! inq;
#line 518
      goto switch_break;
      case_neg_120: /* CIL Label */ 
#line 520
      inp ++;
#line 521
      goto switch_break;
      case_neg_118: /* CIL Label */ 
#line 523
      inp --;
#line 524
      goto switch_break;
      case_neg_96: /* CIL Label */ 
      case_neg_97: /* CIL Label */ 
      {
#line 528
      x += l;
#line 529
      l = mb_metacharlenconv((char const   *)x, (wint_t *)((void *)0));
      }
#line 530
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 481
      x += l;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 535
  prefork(& foo, pf_flags, ms_flags);
  }
#line 536
  if (errflag) {
#line 537
    if (isarr) {
#line 538
      *isarr = 0;
    }
#line 539
    return (0);
  }
  {
#line 542
  l = countlinknodes(& foo);
  }
#line 542
  if (l > 1) {
#line 542
    goto _L;
  } else
#line 542
  if (foo.list.flags & 1) {
#line 542
    if (a) {
      _L: /* CIL Label */ 
      {
#line 543
      tmp___2 = hcalloc((unsigned long )(l + 1) * sizeof(char *));
#line 543
      r = (char **)tmp___2;
#line 543
      p = r;
      }
      {
#line 544
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 544
        if (! ((unsigned long )foo.list.first != (unsigned long )((void *)0))) {
#line 544
          goto while_break___3;
        }
        {
#line 545
        tmp___3 = p;
#line 545
        p ++;
#line 545
        tmp___4 = ugetnode(& foo);
#line 545
        *tmp___3 = (char *)tmp___4;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 546
      *p = (char *)((void *)0);
#line 551
      if (a) {
#line 551
        if (l > 1) {
#line 552
          *a = r;
#line 553
          *isarr = 1 << 5;
#line 554
          return (0);
        } else
#line 551
        if (foo.list.flags & 1) {
#line 552
          *a = r;
#line 553
          *isarr = 1 << 5;
#line 554
          return (0);
        }
      }
      {
#line 556
      *s = sepjoin(r, sep, 1);
      }
#line 557
      if (isarr) {
#line 558
        *isarr = 0;
      }
#line 559
      return (0);
    }
  }
#line 561
  if (l) {
    {
#line 562
    tmp___5 = ugetnode(& foo);
#line 562
    *s = (char *)tmp___5;
    }
  } else {
    {
#line 564
    *s = dupstring("");
    }
  }
#line 565
  if (isarr) {
#line 566
    *isarr = 0;
  }
#line 567
  return (! l);
}
}
#line 576 "/tmp/zsh-5.4.2/Src/subst.c"
void filesub(char **namptr , int assign ) 
{ 
  char *eql ;
  char *sub ;
  char *str ;
  char *ptr___0 ;
  int len ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 579
  eql = (char *)((void *)0);
#line 579
  sub = (char *)((void *)0);
#line 582
  filesubstr(namptr, assign);
  }
#line 584
  if (! assign) {
#line 585
    return;
  }
#line 587
  if (assign & 1) {
#line 588
    if (*(*namptr + 1)) {
      {
#line 588
      sub = strchr((char const   *)(*namptr + 1), -115);
#line 588
      eql = sub;
      }
#line 588
      if (eql) {
#line 589
        str = sub + 1;
#line 590
        if ((int )*(sub + 1) == -104) {
#line 590
          goto _L;
        } else
#line 590
        if ((int )*(sub + 1) == -115) {
          _L: /* CIL Label */ 
          {
#line 590
          tmp = filesubstr(& str, assign);
          }
#line 590
          if (tmp) {
            {
#line 591
            *(sub + 1) = (char )'\000';
#line 592
            *namptr = dyncat((char const   *)*namptr, (char const   *)str);
            }
          }
        }
      } else {
#line 595
        return;
      }
    } else {
#line 595
      return;
    }
  }
#line 598
  ptr___0 = *namptr;
  {
#line 599
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 599
    sub = strchr((char const   *)ptr___0, ':');
    }
#line 599
    if (! sub) {
#line 599
      goto while_break;
    }
#line 600
    str = sub + 1;
#line 601
    len = (int )(sub - *namptr);
#line 602
    if ((unsigned long )sub > (unsigned long )eql) {
#line 602
      if ((int )*(sub + 1) == -104) {
#line 602
        goto _L___0;
      } else
#line 602
      if ((int )*(sub + 1) == -115) {
        _L___0: /* CIL Label */ 
        {
#line 602
        tmp___0 = filesubstr(& str, assign);
        }
#line 602
        if (tmp___0) {
          {
#line 605
          *(sub + 1) = (char )'\000';
#line 606
          *namptr = dyncat((char const   *)*namptr, (char const   *)str);
          }
        }
      }
    }
#line 608
    ptr___0 = (*namptr + len) + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 610
  return;
}
}
#line 624 "/tmp/zsh-5.4.2/Src/subst.c"
char *equalsubstr(char *str , int assign , int nomatch ) 
{ 
  char *pp ;
  char *cnam ;
  char *cmdstr ;
  char *tmp ;

  {
#line 629
  pp = str;
  {
#line 629
  while (1) {
    while_continue: /* CIL Label */ ;
#line 629
    if (! *pp) {
#line 629
      goto while_break;
    } else
#line 629
    if ((int )*pp == -120) {
#line 629
      goto while_break;
    } else
#line 629
    if (assign) {
#line 629
      if ((int )*pp == 58) {
#line 629
        goto while_break;
      }
    }
#line 629
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 631
  cmdstr = dupstrpfx((char const   *)str, (int )(pp - str));
#line 632
  untokenize(cmdstr);
#line 633
  remnulargs(cmdstr);
#line 634
  cnam = findcmd(cmdstr, 1, 0);
  }
#line 634
  if (! cnam) {
#line 635
    if (nomatch) {
      {
#line 636
      zerr("%s not found", cmdstr);
      }
    }
#line 637
    return ((char *)((void *)0));
  }
#line 639
  if (*pp) {
    {
#line 640
    tmp = dyncat((char const   *)cnam, (char const   *)pp);
    }
#line 640
    return (tmp);
  } else {
#line 642
    return (cnam);
  }
}
}
#line 646 "/tmp/zsh-5.4.2/Src/subst.c"
int filesubstr(char **namptr , int assign ) 
{ 
  char *str ;
  char *ptr___0 ;
  char *tmp ;
  char *res ;
  char *ptr2 ;
  int val ;
  zlong tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char **arr ;
  char *ds ;
  char *untok ;
  char *hom ;
  char *expn ;
  char *tmp___3 ;

  {
#line 649
  str = *namptr;
#line 651
  if ((int )*str == -104) {
#line 651
    if ((int )*(str + 1) != 61) {
#line 651
      if ((int )*(str + 1) != -115) {
#line 655
        if ((int )*(str + 1) == -101) {
#line 656
          *(str + 1) = (char )'-';
        }
        {
#line 657
        tmp___0 = zstrtol((char const   *)(str + 1), & ptr___0, 10);
#line 657
        val = (int )tmp___0;
        }
#line 658
        if (! *(str + 1)) {
#line 658
          goto _L___7;
        } else
#line 658
        if ((int )*(str + 1) == 47) {
#line 658
          goto _L___7;
        } else
#line 658
        if ((int )*(str + 1) == -120) {
#line 658
          goto _L___7;
        } else
#line 658
        if (assign) {
#line 658
          if ((int )*(str + 1) == 58) {
            _L___7: /* CIL Label */ 
#line 659
            if (home) {
#line 659
              tmp___1 = (char const   *)home;
            } else {
#line 659
              tmp___1 = "";
            }
            {
#line 659
            *namptr = dyncat(tmp___1, (char const   *)(str + 1));
            }
#line 660
            return (1);
          } else {
#line 658
            goto _L___8;
          }
        } else
        _L___8: /* CIL Label */ 
#line 661
        if ((int )*(str + 1) == 43) {
#line 661
          if (! *(str + 2)) {
            {
#line 662
            *namptr = dyncat((char const   *)pwd, (char const   *)(str + 2));
            }
#line 663
            return (1);
          } else
#line 661
          if ((int )*(str + 2) == 47) {
            {
#line 662
            *namptr = dyncat((char const   *)pwd, (char const   *)(str + 2));
            }
#line 663
            return (1);
          } else
#line 661
          if ((int )*(str + 2) == -120) {
            {
#line 662
            *namptr = dyncat((char const   *)pwd, (char const   *)(str + 2));
            }
#line 663
            return (1);
          } else
#line 661
          if (assign) {
#line 661
            if ((int )*(str + 2) == 58) {
              {
#line 662
              *namptr = dyncat((char const   *)pwd, (char const   *)(str + 2));
              }
#line 663
              return (1);
            } else {
#line 661
              goto _L___6;
            }
          } else {
#line 661
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 664
        if ((int )*(str + 1) == 45) {
#line 664
          if (! *(str + 2)) {
#line 664
            goto _L___5;
          } else
#line 664
          if ((int )*(str + 2) == 47) {
#line 664
            goto _L___5;
          } else
#line 664
          if ((int )*(str + 2) == -120) {
#line 664
            goto _L___5;
          } else
#line 664
          if (assign) {
#line 664
            if ((int )*(str + 2) == 58) {
              _L___5: /* CIL Label */ 
#line 665
              tmp = oldpwd;
#line 665
              if (tmp) {
#line 665
                tmp___2 = tmp;
              } else {
#line 665
                tmp___2 = pwd;
              }
              {
#line 665
              *namptr = dyncat((char const   *)tmp___2, (char const   *)(str + 2));
              }
#line 666
              return (1);
            } else {
#line 664
              goto _L___4;
            }
          } else {
#line 664
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 667
        if ((int )*(str + 1) == -111) {
          {
#line 667
          ptr2 = strchr((char const   *)(str + 2), -110);
          }
#line 667
          if (ptr2) {
            {
#line 670
            tmp = dupstrpfx((char const   *)(str + 2), (int )(ptr2 - (str + 2)));
#line 670
            untokenize(tmp);
#line 671
            remnulargs(tmp);
#line 672
            arr = subst_string_by_hook((char *)"zsh_directory_name", (char *)"n",
                                       tmp);
            }
#line 673
            if (arr) {
#line 673
              res = *arr;
            } else {
#line 673
              res = (char *)((void *)0);
            }
#line 674
            if (res) {
              {
#line 675
              *namptr = dyncat((char const   *)res, (char const   *)(ptr2 + 1));
              }
#line 676
              return (1);
            }
#line 678
            if (opts[120]) {
              {
#line 679
              zerr("no directory expansion: ~[%s]", tmp);
              }
            }
#line 680
            return (0);
          } else {
#line 667
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 681
        if (! ((int )typtab[(unsigned char )*(str + 1)] & (1 << 3))) {
#line 681
          if (! *ptr___0) {
#line 681
            goto _L___2;
          } else
#line 681
          if ((int )*ptr___0 == 47) {
#line 681
            goto _L___2;
          } else
#line 681
          if ((int )*ptr___0 == -120) {
#line 681
            goto _L___2;
          } else
#line 681
          if (assign) {
#line 681
            if ((int )*ptr___0 == 58) {
              _L___2: /* CIL Label */ 
#line 681
              if (! ((int )typtab[(unsigned char )*(str + 1)] & 1)) {
#line 681
                goto _L___0;
              } else
#line 681
              if (ptr___0 - str < 4L) {
                _L___0: /* CIL Label */ 
#line 685
                if (val < 0) {
#line 686
                  val = - val;
                }
                {
#line 687
                ds = dstackent(*(str + 1), val);
                }
#line 688
                if (! ds) {
#line 689
                  return (0);
                }
                {
#line 690
                *namptr = dyncat((char const   *)ds, (char const   *)ptr___0);
                }
#line 691
                return (1);
              } else {
#line 681
                goto _L___1;
              }
            } else {
#line 681
              goto _L___1;
            }
          } else {
#line 681
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 692
          ptr___0 = itype_end((char const   *)(str + 1), 1 << 8, 0);
          }
#line 692
          if ((unsigned long )ptr___0 != (unsigned long )(str + 1)) {
#line 695
            if (! (! *ptr___0)) {
#line 695
              if (! ((int )*ptr___0 == 47)) {
#line 695
                if (! ((int )*ptr___0 == -120)) {
#line 695
                  if (assign) {
#line 695
                    if (! ((int )*ptr___0 == 58)) {
#line 696
                      return (0);
                    }
                  } else {
#line 696
                    return (0);
                  }
                }
              }
            }
            {
#line 697
            str ++;
#line 697
            untok = dupstring((char const   *)str);
#line 698
            *(untok + (ptr___0 - str)) = (char)0;
#line 699
            untokenize(untok);
#line 701
            hom = getnameddir(untok);
            }
#line 701
            if (! hom) {
#line 702
              if (opts[120]) {
#line 702
                if (opts[52]) {
                  {
#line 703
                  zerr("no such user or named directory: %s", untok);
                  }
                }
              }
#line 704
              return (0);
            }
            {
#line 706
            *namptr = dyncat((char const   *)hom, (char const   *)ptr___0);
            }
#line 707
            return (1);
          }
        }
      } else {
#line 651
        goto _L___10;
      }
    } else {
#line 651
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 709
  if ((int )*str == -115) {
#line 709
    if (opts[49]) {
#line 709
      if (*(str + 1)) {
        {
#line 710
        tmp___3 = equalsubstr(str + 1, assign, (int )opts[120]);
#line 710
        expn = tmp___3;
        }
#line 711
        if (expn) {
#line 712
          *namptr = expn;
#line 713
          return (1);
        }
      }
    }
  }
#line 716
  return (0);
}
}
#line 723 "/tmp/zsh-5.4.2/Src/subst.c"
static char *strcatsub(char **d___0 , char *pb , char *pe , char *src , int l , char *s ,
                       int glbsub , int copied ) 
{ 
  char *dest ;
  int pl ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 728
  pl = (int )(pe - pb);
#line 730
  if (! pl) {
#line 730
    if (! s) {
#line 730
      goto _L___0;
    } else
#line 730
    if (! *s) {
      _L___0: /* CIL Label */ 
#line 731
      if (copied) {
#line 731
        dest = src;
      } else {
        {
#line 731
        tmp = dupstring((char const   *)src);
#line 731
        dest = tmp;
        }
      }
#line 731
      *d___0 = dest;
#line 732
      if (glbsub) {
        {
#line 733
        shtokenize(dest);
        }
      }
    } else {
#line 730
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 735
    if (s) {
      {
#line 735
      tmp___0 = strlen((char const   *)s);
#line 735
      tmp___1 = tmp___0;
      }
    } else {
#line 735
      tmp___1 = (size_t )0;
    }
    {
#line 735
    tmp___2 = hcalloc(((size_t )(pl + l) + tmp___1) + 1UL);
#line 735
    dest = (char *)tmp___2;
#line 735
    *d___0 = dest;
#line 736
    strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)pb, (size_t )pl);
#line 737
    dest += pl;
#line 738
    strcpy((char */* __restrict  */)dest, (char const   */* __restrict  */)src);
    }
#line 739
    if (glbsub) {
      {
#line 740
      shtokenize(dest);
      }
    }
#line 741
    dest += l;
#line 742
    if (s) {
      {
#line 743
      strcpy((char */* __restrict  */)dest, (char const   */* __restrict  */)s);
      }
    }
  }
#line 745
  return (dest);
}
}
#line 757 "/tmp/zsh-5.4.2/Src/subst.c"
static int wcpadwidth(wchar_t wc , int multi_width ) 
{ 
  int width ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 764
  if (multi_width == 0) {
#line 764
    goto case_0;
  }
#line 767
  if (multi_width == 1) {
#line 767
    goto case_1;
  }
#line 773
  goto switch_default;
  case_0: /* CIL Label */ 
#line 765
  return (1);
  case_1: /* CIL Label */ 
  {
#line 768
  width = wcwidth(wc);
  }
#line 769
  if (width >= 0) {
#line 770
    return (width);
  }
#line 771
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 774
  tmp___1 = wcwidth(wc);
  }
#line 774
  if (tmp___1 > 0) {
#line 774
    tmp___0 = 1;
  } else {
#line 774
    tmp___0 = 0;
  }
#line 774
  return (tmp___0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 802 "/tmp/zsh-5.4.2/Src/subst.c"
static char *dopadding(char *str , int prenum , int postnum , char *preone , char *postone ,
                       char *premul , char *postmul , int multi_width ) 
{ 
  char *def ;
  char *ret ;
  char *t ;
  char *r ;
  int ls ;
  int ls2 ;
  int lpreone ;
  int lpostone ;
  int lpremul ;
  int lpostmul ;
  int lr ;
  int f ;
  int m ;
  int c ;
  int cc ;
  int cl ;
  convchar_t cchar ;
  char *tmpifs ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  char *tmp___84 ;
  char *tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;

  {
  {
#line 814
  mb_charinit();
  }
#line 815
  if (! ifs) {
#line 815
    goto _L;
  } else
#line 815
  if (*ifs) {
    _L: /* CIL Label */ 
#line 816
    if (ifs) {
#line 816
      tmp = (char const   *)ifs;
    } else {
#line 816
      tmp = " \t\n\203 ";
    }
    {
#line 816
    tmpifs = (char *)tmp;
#line 817
    tmp___0 = mb_metacharlenconv((char const   *)tmpifs, (wint_t *)((void *)0));
#line 817
    def = dupstrpfx((char const   *)tmpifs, tmp___0);
    }
  } else {
#line 819
    def = (char *)"";
  }
#line 820
  if (preone) {
#line 820
    if (! *preone) {
#line 821
      preone = def;
    }
  }
#line 822
  if (postone) {
#line 822
    if (! *postone) {
#line 823
      postone = def;
    }
  }
#line 824
  if (! premul) {
#line 825
    premul = def;
  } else
#line 824
  if (! *premul) {
#line 825
    premul = def;
  }
#line 826
  if (! postmul) {
#line 827
    postmul = def;
  } else
#line 826
  if (! *postmul) {
#line 827
    postmul = def;
  }
  {
#line 829
  ls = mb_metastrlenend(str, multi_width, (char *)((void *)0));
  }
#line 830
  if (preone) {
    {
#line 830
    tmp___1 = mb_metastrlenend(preone, multi_width, (char *)((void *)0));
#line 830
    lpreone = tmp___1;
    }
  } else {
#line 830
    lpreone = 0;
  }
#line 831
  if (postone) {
    {
#line 831
    tmp___2 = mb_metastrlenend(postone, multi_width, (char *)((void *)0));
#line 831
    lpostone = tmp___2;
    }
  } else {
#line 831
    lpostone = 0;
  }
  {
#line 832
  lpremul = mb_metastrlenend(premul, multi_width, (char *)((void *)0));
#line 833
  lpostmul = mb_metastrlenend(postmul, multi_width, (char *)((void *)0));
  }
#line 835
  if (prenum + postnum == ls) {
#line 836
    return (str);
  }
  {
#line 845
  tmp___3 = strlen((char const   *)str);
#line 845
  tmp___4 = strlen((char const   *)premul);
#line 845
  tmp___5 = strlen((char const   *)postmul);
#line 845
  lr = (int )((tmp___3 + tmp___4 * (size_t )prenum) + tmp___5 * (size_t )postnum);
  }
#line 849
  if (preone) {
    {
#line 850
    tmp___6 = strlen((char const   *)preone);
#line 850
    lr = (int )((size_t )lr + tmp___6);
    }
  }
#line 851
  if (postone) {
    {
#line 852
    tmp___7 = strlen((char const   *)postone);
#line 852
    lr = (int )((size_t )lr + tmp___7);
    }
  }
  {
#line 853
  tmp___8 = zhalloc((size_t )(lr + 1));
#line 853
  ret = (char *)tmp___8;
#line 853
  r = ret;
  }
#line 855
  if (prenum) {
#line 859
    if (postnum) {
#line 866
      ls2 = ls / 2;
#line 869
      f = prenum - ls2;
#line 870
      if (f <= 0) {
        {
#line 872
        f = - f;
#line 873
        mb_charinit();
        }
        {
#line 874
        while (1) {
          while_continue: /* CIL Label */ ;
#line 874
          if (! (f > 0)) {
#line 874
            goto while_break;
          }
          {
#line 875
          cl = mb_metacharlenconv((char const   *)str, & cchar);
          }
#line 876
          if (! cl) {
#line 877
            goto while_break;
          }
          {
#line 878
          str += cl;
#line 879
          tmp___9 = wcpadwidth((wchar_t )cchar, multi_width);
#line 879
          f -= tmp___9;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 882
        c = prenum;
        {
#line 882
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 882
          if (! (c > 0)) {
#line 882
            goto while_break___0;
          }
          {
#line 883
          cl = mb_metacharlenconv((char const   *)str, & cchar);
          }
#line 884
          if (! cl) {
#line 885
            goto while_break___0;
          }
          {
#line 886
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 886
            tmp___12 = cl;
#line 886
            cl --;
#line 886
            if (! tmp___12) {
#line 886
              goto while_break___1;
            }
#line 887
            tmp___10 = r;
#line 887
            r ++;
#line 887
            tmp___11 = str;
#line 887
            str ++;
#line 887
            *tmp___10 = *tmp___11;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 888
          tmp___13 = wcpadwidth((wchar_t )cchar, multi_width);
#line 888
          c -= tmp___13;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 891
        if (f <= lpreone) {
#line 892
          if (preone) {
            {
#line 896
            mb_charinit();
#line 898
            f = lpreone - f;
#line 900
            t = preone;
            }
            {
#line 900
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 900
              if (! (f > 0)) {
#line 900
                goto while_break___2;
              }
              {
#line 901
              cl = mb_metacharlenconv((char const   *)t, & cchar);
              }
#line 902
              if (! cl) {
#line 903
                goto while_break___2;
              }
              {
#line 904
              t += cl;
#line 905
              tmp___14 = wcpadwidth((wchar_t )cchar, multi_width);
#line 905
              f -= tmp___14;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 908
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 908
              if (! *t) {
#line 908
                goto while_break___3;
              }
#line 909
              tmp___15 = r;
#line 909
              r ++;
#line 909
              tmp___16 = t;
#line 909
              t ++;
#line 909
              *tmp___15 = *tmp___16;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        } else {
#line 912
          f -= lpreone;
#line 913
          if (lpremul) {
#line 914
            m = f % lpremul;
#line 914
            if (m) {
              {
#line 918
              mb_charinit();
#line 920
              m = lpremul - m;
#line 921
              t = premul;
              }
              {
#line 921
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 921
                if (! (m > 0)) {
#line 921
                  goto while_break___4;
                }
                {
#line 922
                cl = mb_metacharlenconv((char const   *)t, & cchar);
                }
#line 923
                if (! cl) {
#line 924
                  goto while_break___4;
                }
                {
#line 925
                t += cl;
#line 926
                tmp___17 = wcpadwidth((wchar_t )cchar, multi_width);
#line 926
                m -= tmp___17;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
              {
#line 929
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 929
                if (! *t) {
#line 929
                  goto while_break___5;
                }
#line 930
                tmp___18 = r;
#line 930
                r ++;
#line 930
                tmp___19 = t;
#line 930
                t ++;
#line 930
                *tmp___18 = *tmp___19;
              }
              while_break___5: /* CIL Label */ ;
              }
            }
#line 932
            cc = f / lpremul;
            {
#line 932
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 932
              tmp___24 = cc;
#line 932
              cc --;
#line 932
              if (! tmp___24) {
#line 932
                goto while_break___6;
              }
              {
#line 934
              mb_charinit();
#line 935
              c = lpremul;
#line 935
              t = premul;
              }
              {
#line 935
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 935
                if (! (c > 0)) {
#line 935
                  goto while_break___7;
                }
                {
#line 936
                cl = mb_metacharlenconv((char const   *)t, & cchar);
                }
#line 937
                if (! cl) {
#line 938
                  goto while_break___7;
                }
                {
#line 939
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 939
                  tmp___22 = cl;
#line 939
                  cl --;
#line 939
                  if (! tmp___22) {
#line 939
                    goto while_break___8;
                  }
#line 940
                  tmp___20 = r;
#line 940
                  r ++;
#line 940
                  tmp___21 = t;
#line 940
                  t ++;
#line 940
                  *tmp___20 = *tmp___21;
                }
                while_break___8: /* CIL Label */ ;
                }
                {
#line 941
                tmp___23 = wcpadwidth((wchar_t )cchar, multi_width);
#line 941
                c -= tmp___23;
                }
              }
              while_break___7: /* CIL Label */ ;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
          }
#line 945
          if (preone) {
            {
#line 947
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 947
              if (! *preone) {
#line 947
                goto while_break___9;
              }
#line 948
              tmp___25 = r;
#line 948
              r ++;
#line 948
              tmp___26 = preone;
#line 948
              preone ++;
#line 948
              *tmp___25 = *tmp___26;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
        }
#line 952
        c = ls2;
        {
#line 952
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 952
          if (! (c > 0)) {
#line 952
            goto while_break___10;
          }
          {
#line 953
          cl = mb_metacharlenconv((char const   *)str, & cchar);
          }
#line 954
          if (! cl) {
#line 955
            goto while_break___10;
          }
          {
#line 956
          tmp___27 = wcpadwidth((wchar_t )cchar, multi_width);
#line 956
          c -= tmp___27;
          }
          {
#line 957
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 957
            tmp___30 = cl;
#line 957
            cl --;
#line 957
            if (! tmp___30) {
#line 957
              goto while_break___11;
            }
#line 958
            tmp___28 = r;
#line 958
            r ++;
#line 958
            tmp___29 = str;
#line 958
            str ++;
#line 958
            *tmp___28 = *tmp___29;
          }
          while_break___11: /* CIL Label */ ;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 962
      ls2 = ls - ls2;
#line 964
      f = postnum - ls2;
#line 965
      if (f <= 0) {
        {
#line 967
        mb_charinit();
#line 968
        c = postnum;
        }
        {
#line 968
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 968
          if (! (c > 0)) {
#line 968
            goto while_break___12;
          }
          {
#line 969
          cl = mb_metacharlenconv((char const   *)str, & cchar);
          }
#line 970
          if (! cl) {
#line 971
            goto while_break___12;
          }
          {
#line 972
          tmp___31 = wcpadwidth((wchar_t )cchar, multi_width);
#line 972
          c -= tmp___31;
          }
          {
#line 973
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 973
            tmp___34 = cl;
#line 973
            cl --;
#line 973
            if (! tmp___34) {
#line 973
              goto while_break___13;
            }
#line 974
            tmp___32 = r;
#line 974
            r ++;
#line 974
            tmp___33 = str;
#line 974
            str ++;
#line 974
            *tmp___32 = *tmp___33;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
      } else {
        {
#line 978
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 978
          if (! *str) {
#line 978
            goto while_break___14;
          }
#line 979
          tmp___35 = r;
#line 979
          r ++;
#line 979
          tmp___36 = str;
#line 979
          str ++;
#line 979
          *tmp___35 = *tmp___36;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 980
        if (f <= lpostone) {
#line 981
          if (postone) {
#line 983
            c = f;
            {
#line 983
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 983
              if (! (c > 0)) {
#line 983
                goto while_break___15;
              }
              {
#line 984
              cl = mb_metacharlenconv((char const   *)postone, & cchar);
              }
#line 985
              if (! cl) {
#line 986
                goto while_break___15;
              }
              {
#line 987
              tmp___37 = wcpadwidth((wchar_t )cchar, multi_width);
#line 987
              c -= tmp___37;
              }
              {
#line 988
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 988
                tmp___40 = cl;
#line 988
                cl --;
#line 988
                if (! tmp___40) {
#line 988
                  goto while_break___16;
                }
#line 989
                tmp___38 = r;
#line 989
                r ++;
#line 989
                tmp___39 = postone;
#line 989
                postone ++;
#line 989
                *tmp___38 = *tmp___39;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
            while_break___15: /* CIL Label */ ;
            }
          }
        } else {
#line 993
          if (postone) {
#line 994
            f -= lpostone;
            {
#line 996
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 996
              if (! *postone) {
#line 996
                goto while_break___17;
              }
#line 997
              tmp___41 = r;
#line 997
              r ++;
#line 997
              tmp___42 = postone;
#line 997
              postone ++;
#line 997
              *tmp___41 = *tmp___42;
            }
            while_break___17: /* CIL Label */ ;
            }
          }
#line 999
          if (lpostmul) {
#line 1000
            cc = f / lpostmul;
            {
#line 1000
            while (1) {
              while_continue___18: /* CIL Label */ ;
#line 1000
              tmp___45 = cc;
#line 1000
              cc --;
#line 1000
              if (! tmp___45) {
#line 1000
                goto while_break___18;
              }
#line 1002
              t = postmul;
              {
#line 1002
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 1002
                if (! *t) {
#line 1002
                  goto while_break___19;
                }
#line 1003
                tmp___43 = r;
#line 1003
                r ++;
#line 1003
                tmp___44 = t;
#line 1003
                t ++;
#line 1003
                *tmp___43 = *tmp___44;
              }
              while_break___19: /* CIL Label */ ;
              }
            }
            while_break___18: /* CIL Label */ ;
            }
#line 1005
            m = f % lpostmul;
#line 1005
            if (m) {
              {
#line 1007
              mb_charinit();
              }
              {
#line 1008
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 1008
                if (! (m > 0)) {
#line 1008
                  goto while_break___20;
                }
                {
#line 1009
                cl = mb_metacharlenconv((char const   *)postmul, & cchar);
                }
#line 1010
                if (! cl) {
#line 1011
                  goto while_break___20;
                }
                {
#line 1012
                tmp___46 = wcpadwidth((wchar_t )cchar, multi_width);
#line 1012
                m -= tmp___46;
                }
                {
#line 1013
                while (1) {
                  while_continue___21: /* CIL Label */ ;
#line 1013
                  tmp___49 = cl;
#line 1013
                  cl --;
#line 1013
                  if (! tmp___49) {
#line 1013
                    goto while_break___21;
                  }
#line 1014
                  tmp___47 = r;
#line 1014
                  r ++;
#line 1014
                  tmp___48 = postmul;
#line 1014
                  postmul ++;
#line 1014
                  *tmp___47 = *tmp___48;
                }
                while_break___21: /* CIL Label */ ;
                }
              }
              while_break___20: /* CIL Label */ ;
              }
            }
          }
        }
      }
    } else {
#line 1024
      f = prenum - ls;
#line 1025
      if (f <= 0) {
        {
#line 1032
        f = - f;
#line 1033
        mb_charinit();
        }
        {
#line 1034
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 1034
          if (! (f > 0)) {
#line 1034
            goto while_break___22;
          }
          {
#line 1035
          cl = mb_metacharlenconv((char const   *)str, & cchar);
          }
#line 1036
          if (! cl) {
#line 1037
            goto while_break___22;
          }
          {
#line 1038
          str += cl;
#line 1039
          tmp___50 = wcpadwidth((wchar_t )cchar, multi_width);
#line 1039
          f -= tmp___50;
          }
        }
        while_break___22: /* CIL Label */ ;
        }
#line 1042
        c = prenum;
        {
#line 1042
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 1042
          if (! (c > 0)) {
#line 1042
            goto while_break___23;
          }
          {
#line 1043
          cl = mb_metacharlenconv((char const   *)str, & cchar);
          }
#line 1044
          if (! cl) {
#line 1045
            goto while_break___23;
          }
          {
#line 1046
          while (1) {
            while_continue___24: /* CIL Label */ ;
#line 1046
            tmp___53 = cl;
#line 1046
            cl --;
#line 1046
            if (! tmp___53) {
#line 1046
              goto while_break___24;
            }
#line 1047
            tmp___51 = r;
#line 1047
            r ++;
#line 1047
            tmp___52 = str;
#line 1047
            str ++;
#line 1047
            *tmp___51 = *tmp___52;
          }
          while_break___24: /* CIL Label */ ;
          }
          {
#line 1048
          tmp___54 = wcpadwidth((wchar_t )cchar, multi_width);
#line 1048
          c -= tmp___54;
          }
        }
        while_break___23: /* CIL Label */ ;
        }
      } else {
#line 1054
        if (f <= lpreone) {
#line 1055
          if (preone) {
            {
#line 1060
            c = f;
#line 1065
            f = lpreone - f;
#line 1066
            mb_charinit();
#line 1067
            t = preone;
            }
            {
#line 1067
            while (1) {
              while_continue___25: /* CIL Label */ ;
#line 1067
              if (! (f > 0)) {
#line 1067
                goto while_break___25;
              }
              {
#line 1068
              cl = mb_metacharlenconv((char const   *)t, & cchar);
              }
#line 1069
              if (! cl) {
#line 1070
                goto while_break___25;
              }
              {
#line 1071
              t += cl;
#line 1072
              tmp___55 = wcpadwidth((wchar_t )cchar, multi_width);
#line 1072
              f -= tmp___55;
              }
            }
            while_break___25: /* CIL Label */ ;
            }
            {
#line 1075
            while (1) {
              while_continue___26: /* CIL Label */ ;
#line 1075
              if (! *t) {
#line 1075
                goto while_break___26;
              }
#line 1076
              tmp___56 = r;
#line 1076
              r ++;
#line 1076
              tmp___57 = t;
#line 1076
              t ++;
#line 1076
              *tmp___56 = *tmp___57;
            }
            while_break___26: /* CIL Label */ ;
            }
          }
        } else {
#line 1083
          f -= lpreone;
#line 1084
          if (lpremul) {
#line 1085
            m = f % lpremul;
#line 1085
            if (m) {
              {
#line 1090
              c = m;
#line 1092
              m = lpremul - m;
#line 1093
              mb_charinit();
#line 1094
              t = premul;
              }
              {
#line 1094
              while (1) {
                while_continue___27: /* CIL Label */ ;
#line 1094
                if (! (m > 0)) {
#line 1094
                  goto while_break___27;
                }
                {
#line 1095
                cl = mb_metacharlenconv((char const   *)t, & cchar);
                }
#line 1096
                if (! cl) {
#line 1097
                  goto while_break___27;
                }
                {
#line 1098
                t += cl;
#line 1099
                tmp___58 = wcpadwidth((wchar_t )cchar, multi_width);
#line 1099
                m -= tmp___58;
                }
              }
              while_break___27: /* CIL Label */ ;
              }
              {
#line 1102
              while (1) {
                while_continue___28: /* CIL Label */ ;
#line 1102
                if (! (c > 0)) {
#line 1102
                  goto while_break___28;
                }
                {
#line 1103
                cl = mb_metacharlenconv((char const   *)t, & cchar);
                }
#line 1104
                if (! cl) {
#line 1105
                  goto while_break___28;
                }
                {
#line 1106
                while (1) {
                  while_continue___29: /* CIL Label */ ;
#line 1106
                  tmp___61 = cl;
#line 1106
                  cl --;
#line 1106
                  if (! tmp___61) {
#line 1106
                    goto while_break___29;
                  }
#line 1107
                  tmp___59 = r;
#line 1107
                  r ++;
#line 1107
                  tmp___60 = t;
#line 1107
                  t ++;
#line 1107
                  *tmp___59 = *tmp___60;
                }
                while_break___29: /* CIL Label */ ;
                }
                {
#line 1108
                tmp___62 = wcpadwidth((wchar_t )cchar, multi_width);
#line 1108
                c -= tmp___62;
                }
              }
              while_break___28: /* CIL Label */ ;
              }
            }
#line 1111
            cc = f / lpremul;
            {
#line 1111
            while (1) {
              while_continue___30: /* CIL Label */ ;
#line 1111
              tmp___67 = cc;
#line 1111
              cc --;
#line 1111
              if (! tmp___67) {
#line 1111
                goto while_break___30;
              }
              {
#line 1115
              mb_charinit();
#line 1116
              c = lpremul;
#line 1116
              t = premul;
              }
              {
#line 1116
              while (1) {
                while_continue___31: /* CIL Label */ ;
#line 1116
                if (! (c > 0)) {
#line 1116
                  goto while_break___31;
                }
                {
#line 1117
                cl = mb_metacharlenconv((char const   *)t, & cchar);
                }
#line 1118
                if (! cl) {
#line 1119
                  goto while_break___31;
                }
                {
#line 1120
                while (1) {
                  while_continue___32: /* CIL Label */ ;
#line 1120
                  tmp___65 = cl;
#line 1120
                  cl --;
#line 1120
                  if (! tmp___65) {
#line 1120
                    goto while_break___32;
                  }
#line 1121
                  tmp___63 = r;
#line 1121
                  r ++;
#line 1121
                  tmp___64 = t;
#line 1121
                  t ++;
#line 1121
                  *tmp___63 = *tmp___64;
                }
                while_break___32: /* CIL Label */ ;
                }
                {
#line 1122
                tmp___66 = wcpadwidth((wchar_t )cchar, multi_width);
#line 1122
                c -= tmp___66;
                }
              }
              while_break___31: /* CIL Label */ ;
              }
            }
            while_break___30: /* CIL Label */ ;
            }
          }
#line 1126
          if (preone) {
            {
#line 1136
            while (1) {
              while_continue___33: /* CIL Label */ ;
#line 1136
              if (! *preone) {
#line 1136
                goto while_break___33;
              }
#line 1137
              tmp___68 = r;
#line 1137
              r ++;
#line 1137
              tmp___69 = preone;
#line 1137
              preone ++;
#line 1137
              *tmp___68 = *tmp___69;
            }
            while_break___33: /* CIL Label */ ;
            }
          }
        }
        {
#line 1141
        while (1) {
          while_continue___34: /* CIL Label */ ;
#line 1141
          if (! *str) {
#line 1141
            goto while_break___34;
          }
#line 1142
          tmp___70 = r;
#line 1142
          r ++;
#line 1142
          tmp___71 = str;
#line 1142
          str ++;
#line 1142
          *tmp___70 = *tmp___71;
        }
        while_break___34: /* CIL Label */ ;
        }
      }
    }
  } else
#line 1145
  if (postnum) {
    {
#line 1149
    f = postnum - ls;
#line 1150
    mb_charinit();
    }
#line 1151
    if (f <= 0) {
#line 1156
      c = postnum;
      {
#line 1156
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 1156
        if (! (c > 0)) {
#line 1156
          goto while_break___35;
        }
        {
#line 1157
        cl = mb_metacharlenconv((char const   *)str, & cchar);
        }
#line 1158
        if (! cl) {
#line 1159
          goto while_break___35;
        }
        {
#line 1160
        while (1) {
          while_continue___36: /* CIL Label */ ;
#line 1160
          tmp___74 = cl;
#line 1160
          cl --;
#line 1160
          if (! tmp___74) {
#line 1160
            goto while_break___36;
          }
#line 1161
          tmp___72 = r;
#line 1161
          r ++;
#line 1161
          tmp___73 = str;
#line 1161
          str ++;
#line 1161
          *tmp___72 = *tmp___73;
        }
        while_break___36: /* CIL Label */ ;
        }
        {
#line 1162
        tmp___75 = wcpadwidth((wchar_t )cchar, multi_width);
#line 1162
        c -= tmp___75;
        }
      }
      while_break___35: /* CIL Label */ ;
      }
    } else {
#line 1170
      c = ls;
      {
#line 1170
      while (1) {
        while_continue___37: /* CIL Label */ ;
#line 1170
        if (! *str) {
#line 1170
          goto while_break___37;
        }
        {
#line 1171
        cl = mb_metacharlenconv((char const   *)str, & cchar);
        }
#line 1172
        if (! cl) {
#line 1173
          goto while_break___37;
        }
        {
#line 1174
        while (1) {
          while_continue___38: /* CIL Label */ ;
#line 1174
          tmp___78 = cl;
#line 1174
          cl --;
#line 1174
          if (! tmp___78) {
#line 1174
            goto while_break___38;
          }
#line 1175
          tmp___76 = r;
#line 1175
          r ++;
#line 1175
          tmp___77 = str;
#line 1175
          str ++;
#line 1175
          *tmp___76 = *tmp___77;
        }
        while_break___38: /* CIL Label */ ;
        }
        {
#line 1176
        tmp___79 = wcpadwidth((wchar_t )cchar, multi_width);
#line 1176
        c -= tmp___79;
        }
      }
      while_break___37: /* CIL Label */ ;
      }
      {
#line 1178
      mb_charinit();
      }
#line 1179
      if (f <= lpostone) {
#line 1180
        if (postone) {
#line 1185
          c = f;
          {
#line 1185
          while (1) {
            while_continue___39: /* CIL Label */ ;
#line 1185
            if (! (c > 0)) {
#line 1185
              goto while_break___39;
            }
            {
#line 1186
            cl = mb_metacharlenconv((char const   *)postone, & cchar);
            }
#line 1187
            if (! cl) {
#line 1188
              goto while_break___39;
            }
            {
#line 1189
            while (1) {
              while_continue___40: /* CIL Label */ ;
#line 1189
              tmp___82 = cl;
#line 1189
              cl --;
#line 1189
              if (! tmp___82) {
#line 1189
                goto while_break___40;
              }
#line 1190
              tmp___80 = r;
#line 1190
              r ++;
#line 1190
              tmp___81 = postone;
#line 1190
              postone ++;
#line 1190
              *tmp___80 = *tmp___81;
            }
            while_break___40: /* CIL Label */ ;
            }
            {
#line 1191
            tmp___83 = wcpadwidth((wchar_t )cchar, multi_width);
#line 1191
            c -= tmp___83;
            }
          }
          while_break___39: /* CIL Label */ ;
          }
        }
      } else {
#line 1195
        if (postone) {
#line 1196
          f -= lpostone;
#line 1198
          c = lpostone;
          {
#line 1198
          while (1) {
            while_continue___41: /* CIL Label */ ;
#line 1198
            if (! *postone) {
#line 1198
              goto while_break___41;
            }
            {
#line 1199
            cl = mb_metacharlenconv((char const   *)postone, & cchar);
            }
#line 1200
            if (! cl) {
#line 1201
              goto while_break___41;
            }
            {
#line 1202
            while (1) {
              while_continue___42: /* CIL Label */ ;
#line 1202
              tmp___86 = cl;
#line 1202
              cl --;
#line 1202
              if (! tmp___86) {
#line 1202
                goto while_break___42;
              }
#line 1203
              tmp___84 = r;
#line 1203
              r ++;
#line 1203
              tmp___85 = postone;
#line 1203
              postone ++;
#line 1203
              *tmp___84 = *tmp___85;
            }
            while_break___42: /* CIL Label */ ;
            }
            {
#line 1204
            tmp___87 = wcpadwidth((wchar_t )cchar, multi_width);
#line 1204
            c -= tmp___87;
            }
          }
          while_break___41: /* CIL Label */ ;
          }
        }
#line 1207
        if (lpostmul) {
#line 1209
          cc = f / lpostmul;
          {
#line 1209
          while (1) {
            while_continue___43: /* CIL Label */ ;
#line 1209
            tmp___92 = cc;
#line 1209
            cc --;
#line 1209
            if (! tmp___92) {
#line 1209
              goto while_break___43;
            }
            {
#line 1210
            mb_charinit();
#line 1211
            c = lpostmul;
#line 1211
            t = postmul;
            }
            {
#line 1211
            while (1) {
              while_continue___44: /* CIL Label */ ;
#line 1211
              if (! *t) {
#line 1211
                goto while_break___44;
              }
              {
#line 1212
              cl = mb_metacharlenconv((char const   *)t, & cchar);
              }
#line 1213
              if (! cl) {
#line 1214
                goto while_break___44;
              }
              {
#line 1215
              while (1) {
                while_continue___45: /* CIL Label */ ;
#line 1215
                tmp___90 = cl;
#line 1215
                cl --;
#line 1215
                if (! tmp___90) {
#line 1215
                  goto while_break___45;
                }
#line 1216
                tmp___88 = r;
#line 1216
                r ++;
#line 1216
                tmp___89 = t;
#line 1216
                t ++;
#line 1216
                *tmp___88 = *tmp___89;
              }
              while_break___45: /* CIL Label */ ;
              }
              {
#line 1217
              tmp___91 = wcpadwidth((wchar_t )cchar, multi_width);
#line 1217
              c -= tmp___91;
              }
            }
            while_break___44: /* CIL Label */ ;
            }
          }
          while_break___43: /* CIL Label */ ;
          }
#line 1224
          m = f % lpostmul;
#line 1224
          if (m) {
            {
#line 1225
            mb_charinit();
            }
            {
#line 1226
            while (1) {
              while_continue___46: /* CIL Label */ ;
#line 1226
              if (! (m > 0)) {
#line 1226
                goto while_break___46;
              }
              {
#line 1227
              cl = mb_metacharlenconv((char const   *)postmul, & cchar);
              }
#line 1228
              if (! cl) {
#line 1229
                goto while_break___46;
              }
              {
#line 1230
              while (1) {
                while_continue___47: /* CIL Label */ ;
#line 1230
                tmp___95 = cl;
#line 1230
                cl --;
#line 1230
                if (! tmp___95) {
#line 1230
                  goto while_break___47;
                }
#line 1231
                tmp___93 = r;
#line 1231
                r ++;
#line 1231
                tmp___94 = postmul;
#line 1231
                postmul ++;
#line 1231
                *tmp___93 = *tmp___94;
              }
              while_break___47: /* CIL Label */ ;
              }
              {
#line 1232
              tmp___96 = wcpadwidth((wchar_t )cchar, multi_width);
#line 1232
              m -= tmp___96;
              }
            }
            while_break___46: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 1239
  *r = (char )'\000';
#line 1241
  return (ret);
}
}
#line 1257 "/tmp/zsh-5.4.2/Src/subst.c"
char *get_strarg(char *s , int *lenp ) 
{ 
  convchar_t del ;
  int len ;
  char ctok ;
  int tmp ;
  convchar_t del2 ;
  int tmp___0 ;

  {
  {
#line 1262
  ctok = (char)0;
#line 1264
  mb_charinit();
#line 1265
  len = mb_metacharlenconv((char const   *)s, & del);
  }
#line 1266
  if (! len) {
#line 1267
    *lenp = 0;
#line 1268
    return (s);
  }
#line 1272
  if (del == 4294967295U) {
#line 1273
    if ((int )*s == -125) {
#line 1273
      tmp = (int )*(s + 1) ^ 32;
    } else {
#line 1273
      tmp = (int )*s;
    }
#line 1273
    del = (wint_t )tmp;
  }
#line 1275
  s += len;
  {
#line 1277
  if (del == 40U) {
#line 1277
    goto case_40;
  }
#line 1280
  if (del == 91U) {
#line 1280
    goto case_91;
  }
#line 1283
  if (del == 123U) {
#line 1283
    goto case_123;
  }
#line 1286
  if (del == 60U) {
#line 1286
    goto case_60;
  }
#line 1289
  if (del == 4294967176U) {
#line 1289
    goto case_4294967176;
  }
#line 1292
  if (del == 4294967188U) {
#line 1292
    goto case_4294967188;
  }
#line 1295
  if (del == 4294967183U) {
#line 1295
    goto case_4294967183;
  }
#line 1298
  if (del == 4294967185U) {
#line 1298
    goto case_4294967185;
  }
#line 1276
  goto switch_break;
  case_40: /* CIL Label */ 
#line 1278
  del = (convchar_t )41;
#line 1279
  goto switch_break;
  case_91: /* CIL Label */ 
#line 1281
  del = (convchar_t )93;
#line 1282
  goto switch_break;
  case_123: /* CIL Label */ 
#line 1284
  del = (convchar_t )125;
#line 1285
  goto switch_break;
  case_60: /* CIL Label */ 
#line 1287
  del = (convchar_t )62;
#line 1288
  goto switch_break;
  case_4294967176: /* CIL Label */ 
#line 1290
  ctok = (char)-118;
#line 1291
  goto switch_break;
  case_4294967188: /* CIL Label */ 
#line 1293
  ctok = (char)-107;
#line 1294
  goto switch_break;
  case_4294967183: /* CIL Label */ 
#line 1296
  ctok = (char)-112;
#line 1297
  goto switch_break;
  case_4294967185: /* CIL Label */ 
#line 1299
  ctok = (char)-110;
#line 1300
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1303
  if (ctok) {
    {
#line 1308
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1308
      if (*s) {
#line 1308
        if (! ((int )*s != (int )ctok)) {
#line 1308
          goto while_break;
        }
      } else {
#line 1308
        goto while_break;
      }
#line 1309
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1312
    len = 0;
    {
#line 1313
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1313
      if (! *s) {
#line 1313
        goto while_break___0;
      }
      {
#line 1314
      len = mb_metacharlenconv((char const   *)s, & del2);
      }
#line 1316
      if (del2 == 4294967295U) {
#line 1317
        if ((int )*s == -125) {
#line 1317
          tmp___0 = (int )*(s + 1) ^ 32;
        } else {
#line 1317
          tmp___0 = (int )*s;
        }
#line 1317
        del2 = (wint_t )tmp___0;
      }
#line 1319
      if (del == del2) {
#line 1320
        goto while_break___0;
      }
#line 1321
      s += len;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1325
  *lenp = len;
#line 1326
  return (s);
}
}
#line 1337 "/tmp/zsh-5.4.2/Src/subst.c"
static int get_intarg(char **s , int *delmatchp ) 
{ 
  int arglen ;
  char *t ;
  char *tmp ;
  char *p ;
  char sav ;
  zlong ret ;
  int tmp___0 ;

  {
  {
#line 1341
  tmp = get_strarg(*s, & arglen);
#line 1341
  t = tmp;
#line 1345
  *delmatchp = 0;
  }
#line 1346
  if (! *t) {
#line 1347
    return (-1);
  }
  {
#line 1348
  sav = *t;
#line 1349
  *t = (char )'\000';
#line 1350
  p = dupstring((char const   *)(*s + arglen));
#line 1351
  *s = t + arglen;
#line 1352
  *t = sav;
#line 1353
  tmp___0 = parsestr(& p);
  }
#line 1353
  if (tmp___0) {
#line 1354
    return (-1);
  }
  {
#line 1355
  singsub(& p);
  }
#line 1356
  if (errflag) {
#line 1357
    return (-1);
  }
  {
#line 1358
  ret = mathevali(p);
  }
#line 1359
  if (errflag) {
#line 1360
    return (-1);
  }
#line 1361
  if (ret < 0L) {
#line 1362
    ret = - ret;
  }
#line 1363
  *delmatchp = arglen;
#line 1364
  return ((int )ret);
}
}
#line 1369 "/tmp/zsh-5.4.2/Src/subst.c"
static int subst_parse_str(char **sp___0 , int single , int err ) 
{ 
  char *s ;
  int qt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1374
  s = dupstring((char const   *)*sp___0);
#line 1374
  *sp___0 = s;
  }
#line 1376
  if (err) {
    {
#line 1376
    tmp = parsestr(& s);
#line 1376
    tmp___1 = tmp;
    }
  } else {
    {
#line 1376
    tmp___0 = parsestrnoerr(& s);
#line 1376
    tmp___1 = tmp___0;
    }
  }
#line 1376
  if (! tmp___1) {
#line 1377
    *sp___0 = s;
#line 1378
    if (! single) {
#line 1379
      qt = 0;
      {
#line 1381
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1381
        if (! *s) {
#line 1381
          goto while_break;
        }
#line 1382
        if (! qt) {
#line 1383
          if ((int )*s == -116) {
#line 1384
            *s = (char)-123;
          } else
#line 1385
          if ((int )*s == -103) {
#line 1386
            *s = (char)-109;
          }
        }
#line 1388
        if ((int )*s == -98) {
#line 1389
          qt = ! qt;
        }
#line 1381
        s ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 1392
    return (0);
  }
#line 1394
  return (1);
}
}
#line 1399 "/tmp/zsh-5.4.2/Src/subst.c"
static char *substevalchar(char *ptr___0 ) 
{ 
  zlong ires ;
  zlong tmp ;
  int len ;
  char buf___7[11] ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1402
  tmp = mathevali(ptr___0);
#line 1402
  ires = tmp;
#line 1403
  len = 0;
  }
#line 1405
  if (errflag) {
#line 1406
    return ((char *)((void *)0));
  }
#line 1408
  if (opts[117]) {
#line 1408
    if (ires > 127L) {
      {
#line 1413
      sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"\\U%.8x",
              (unsigned int )ires & 4294967295U);
#line 1414
      ptr___0 = getkeystring(buf___7, & len, 7, (int *)((void *)0));
      }
    }
  }
#line 1416
  if (len == 0) {
    {
#line 1419
    tmp___0 = zhalloc((size_t )2);
#line 1419
    ptr___0 = (char *)tmp___0;
#line 1420
    len = 1;
#line 1421
    sprintf((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)"%c",
            (int )ires);
    }
  }
  {
#line 1423
  tmp___1 = metafy(ptr___0, len, 1);
  }
#line 1423
  return (tmp___1);
}
}
#line 1431 "/tmp/zsh-5.4.2/Src/subst.c"
static char *untok_and_escape(char *s , int escapes , int tok_arg ) 
{ 
  int klen ;
  char *dst ;
  char *pstart ;
  char *pend ;
  char *tmp ;

  {
#line 1435
  dst = (char *)((void *)0);
#line 1437
  if (escapes) {
#line 1437
    if ((int )*s == -123) {
#line 1437
      goto _L;
    } else
#line 1437
    if ((int )*s == -116) {
      _L: /* CIL Label */ 
#line 1437
      if (*(s + 1)) {
#line 1438
        pstart = s + 1;
#line 1439
        pend = pstart;
        {
#line 1439
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1439
          if (! *pend) {
#line 1439
            goto while_break;
          }
#line 1440
          if (! ((int )typtab[(unsigned char )*pend] & (1 << 7))) {
#line 1441
            goto while_break;
          }
#line 1439
          pend ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 1442
        if (! *pend) {
          {
#line 1443
          tmp = getsparam(pstart);
#line 1443
          dst = dupstring((char const   *)tmp);
          }
        }
      }
    }
  }
#line 1446
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
    {
#line 1447
    dst = dupstring((char const   *)s);
#line 1447
    untokenize(dst);
    }
#line 1448
    if (escapes) {
      {
#line 1449
      dst = getkeystring(dst, & klen, 3, (int *)((void *)0));
#line 1450
      dst = metafy(dst, klen, 7);
      }
    }
  }
#line 1453
  if (tok_arg) {
    {
#line 1454
    shtokenize(dst);
    }
  }
#line 1455
  return (dst);
}
}
#line 1469 "/tmp/zsh-5.4.2/Src/subst.c"
static char *check_colon_subscript(char *str , char **endp ) 
{ 
  int sav ;
  int tmp ;

  {
#line 1475
  if (! *str) {
#line 1476
    return ((char *)((void *)0));
  } else
#line 1475
  if ((int )typtab[(unsigned char )*str] & (1 << 6)) {
#line 1476
    return ((char *)((void *)0));
  } else
#line 1475
  if ((int )*str == 38) {
#line 1476
    return ((char *)((void *)0));
  }
  {
#line 1478
  *endp = parse_subscript(str, 0, ':');
  }
#line 1479
  if (! *endp) {
    {
#line 1481
    *endp = parse_subscript(str, 0, '\000');
    }
#line 1482
    if (! *endp) {
#line 1483
      return ((char *)((void *)0));
    }
  }
  {
#line 1485
  sav = (int )*(*endp);
#line 1486
  *(*endp) = (char )'\000';
#line 1487
  str = dupstring((char const   *)str);
#line 1488
  tmp = parsestr(& str);
  }
#line 1488
  if (tmp) {
#line 1489
    return ((char *)((void *)0));
  }
  {
#line 1490
  singsub(& str);
#line 1491
  remnulargs(str);
#line 1492
  untokenize(str);
#line 1494
  *(*endp) = (char )sav;
  }
#line 1495
  return (str);
}
}
#line 1521 "/tmp/zsh-5.4.2/Src/subst.c"
static LinkNode paramsubst(LinkList l , LinkNode n , char **str , int qt , int pf_flags ,
                           int *ret_flags ) 
{ 
  char *aptr ;
  char c ;
  char cc ;
  char *s ;
  char *fstr___0 ;
  char *idbeg ;
  char *idend ;
  char *ostr ;
  int colf ;
  int isarr ;
  int plan9 ;
  int globsubst ;
  int evalchar ;
  int getlen ;
  int whichlen ;
  int chkset ;
  int vunset ;
  int wantt ;
  int spbreak ;
  int tmp ;
  char *val ;
  char **aval ;
  struct value vbuf ;
  Value v ;
  int flags ;
  int flnum ;
  int sortit ;
  int indord ;
  int unique ;
  int casmod ;
  int quotemod ;
  int quotetype ;
  int quoteerr ;
  int mods ;
  int shsplit ;
  int ssub ;
  char *sep ;
  char *spsep ;
  char *premul ;
  char *postmul ;
  char *preone ;
  char *postone ;
  char *replstr ;
  zlong prenum ;
  zlong postnum ;
  int multi_width ;
  int copied ;
  int arrasg ;
  int eval___0 ;
  int aspar ;
  int presc ;
  int getkeys ;
  int nojoin ;
  int tmp___0 ;
  int tmp___1 ;
  char inbrace ;
  char hkeys ;
  char hvals ;
  int subexp ;
  int horrible_offset_hack ;
  int ms_flags ;
  int fetch_needed ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *t ;
  char sav ;
  int tt ;
  zlong num ;
  int escapes ;
  int tok_arg ;
  int arglen ;
  int dellen ;
  char *del0 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int sav___0 ;
  int quoted ;
  int outtok ;
  char *tmp___11 ;
  void *tmp___12 ;
  char ***tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *ov ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  int f ;
  Param pm ;
  char *os ;
  int tmp___23 ;
  void *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmplen ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char tmp___31 ;
  int tmp___32 ;
  int bct ;
  char *tmp___33 ;
  char *ptr___0 ;
  int tmp___34 ;
  int split_flags ;
  char ***tmp___35 ;
  char sav___1 ;
  int l___0 ;
  int split_flags___0 ;
  int tmp___36 ;
  char *arr[2] ;
  char **t___0 ;
  char **a ;
  char **p ;
  void *tmp___37 ;
  char **tmp___38 ;
  char **tmp___39 ;
  int tmp___40 ;
  char **tmp___41 ;
  Param pm___0 ;
  Param tmp___42 ;
  HashTable tmp___43 ;
  char *tmp___44 ;
  char const   *tmp___45 ;
  __pid_t tmp___46 ;
  int one ;
  int oef ;
  int haserr ;
  char **ap ;
  char **zip ;
  int shortest ;
  char *tmp___47 ;
  char *sval ;
  char **out ;
  int alen ;
  int ziplen ;
  int outlen ;
  int i ;
  void *tmp___48 ;
  int intersect ;
  int tmp___49 ;
  char **compare ;
  char **ap___0 ;
  char **apsrc ;
  char *tmp___50 ;
  HashTable ht ;
  int tmp___51 ;
  HashTable tmp___52 ;
  int present ;
  void *tmp___53 ;
  HashNode tmp___54 ;
  int tmp___55 ;
  HashNode tmp___56 ;
  int tmp___57 ;
  char const   *tmp___58 ;
  char *check_offset2 ;
  char *check_offset ;
  char *tmp___59 ;
  zlong offset ;
  zlong tmp___60 ;
  zlong length ;
  int length_set ;
  int offset_hack_argzero ;
  int alen___0 ;
  int count ;
  char **srcptr ;
  char **dstptr ;
  char **newarr ;
  void *tmp___61 ;
  char **tmp___62 ;
  char **tmp___63 ;
  char **tmp___64 ;
  int tmp___65 ;
  char *sptr ;
  char *eptr ;
  int given_offset ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  char *ss ;
  char **ap___1 ;
  char **pp ;
  int tmp___70 ;
  void *tmp___71 ;
  char **tmp___72 ;
  char *tmp___73 ;
  char **tmp___74 ;
  char *t___1 ;
  int one___0 ;
  int oef___0 ;
  int haserr___0 ;
  char **aval2 ;
  char **avptr ;
  char **av2ptr ;
  int tmp___75 ;
  void *tmp___76 ;
  char *tmp___77 ;
  long len ;
  char buf___7[14] ;
  char **ctr ;
  int sl ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int force_split ;
  int tmp___84 ;
  char *tmp___85 ;
  char **ap___2 ;
  char **ap2 ;
  int tmp___86 ;
  void *tmp___87 ;
  char **tmp___88 ;
  char **tmp___89 ;
  char **tmp___90 ;
  int len___0 ;
  char **ap___3 ;
  char **ap2___0 ;
  int tmp___91 ;
  void *tmp___92 ;
  char **tmp___93 ;
  int ops ;
  int opb ;
  int opp ;
  char **ap___4 ;
  char *tmps ;
  char *tmps___0 ;
  int pre ;
  int post ;
  char **ap___5 ;
  int sl___0 ;
  char *tmp___94 ;
  size_t tmp___95 ;
  void *tmp___96 ;
  char tmp___97 ;
  int one___1 ;
  int oef___1 ;
  int haserr___1 ;
  int tmp___98 ;
  int sl___1 ;
  char *tmp___99 ;
  size_t tmp___100 ;
  void *tmp___101 ;
  char tmp___102 ;
  int one___2 ;
  int oef___2 ;
  int haserr___2 ;
  char **ap___6 ;
  LinkList list ;
  char **ap___7 ;
  char *tmp___103 ;
  char *tmp___104 ;
  char *x ;
  char *y ;
  int xlen ;
  int i___0 ;
  LinkNode on ;
  int vallen ;
  size_t tmp___105 ;
  size_t tmp___106 ;
  void *tmp___107 ;
  char *copy ;
  char **end ;
  int tmp___108 ;
  char **start ;
  char **tmp___109 ;
  char **tmp___110 ;
  LinkNode tn ;
  union linkroot tl ;
  struct linknode __n0 ;
  LinkNode tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  size_t tmp___114 ;
  char **tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  size_t tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  size_t tmp___124 ;
  int xlen___0 ;
  char *x___0 ;
  char *y___0 ;
  int tmp___125 ;
  int tmp___126 ;
  size_t tmp___127 ;

  {
#line 1525
  aptr = *str;
#line 1526
  s = aptr;
#line 1526
  ostr = (char *)n->dat;
#line 1554
  isarr = 0;
#line 1559
  plan9 = (int )opts[149];
#line 1565
  globsubst = (int )opts[66];
#line 1569
  evalchar = 0;
#line 1574
  getlen = 0;
#line 1575
  whichlen = 0;
#line 1579
  chkset = 0;
#line 1587
  vunset = 0;
#line 1593
  wantt = 0;
#line 1601
  if (pf_flags & 16) {
#line 1601
    if (! (pf_flags & 4)) {
#line 1601
      if (! qt) {
#line 1601
        tmp = 1;
      } else {
#line 1601
        tmp = 0;
      }
    } else {
#line 1601
      tmp = 0;
    }
  } else {
#line 1601
    tmp = 0;
  }
#line 1601
  spbreak = tmp;
#line 1604
  val = (char *)((void *)0);
#line 1604
  aval = (char **)((void *)0);
#line 1610
  v = (Value )((void *)0);
#line 1616
  flags = 0;
#line 1618
  flnum = 0;
#line 1624
  sortit = 0;
#line 1624
  indord = 0;
#line 1626
  unique = 0;
#line 1628
  casmod = 0;
#line 1635
  quotemod = 0;
#line 1635
  quotetype = 0;
#line 1635
  quoteerr = 0;
#line 1642
  mods = 0;
#line 1650
  shsplit = 0;
#line 1655
  ssub = pf_flags & 4;
#line 1662
  sep = (char *)((void *)0);
#line 1662
  spsep = (char *)((void *)0);
#line 1668
  premul = (char *)((void *)0);
#line 1668
  postmul = (char *)((void *)0);
#line 1668
  preone = (char *)((void *)0);
#line 1668
  postone = (char *)((void *)0);
#line 1670
  replstr = (char *)((void *)0);
#line 1672
  prenum = (zlong )0;
#line 1672
  postnum = (zlong )0;
#line 1675
  multi_width = 0;
#line 1683
  copied = 0;
#line 1689
  arrasg = 0;
#line 1694
  eval___0 = 0;
#line 1699
  aspar = 0;
#line 1703
  presc = 0;
#line 1707
  getkeys = -1;
#line 1713
  if (pf_flags & 16) {
#line 1713
    if (ifs) {
#line 1713
      if (*ifs) {
#line 1713
        tmp___0 = 0;
      } else {
#line 1713
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1713
    if (! qt) {
#line 1713
      tmp___0 = 1;
    } else {
#line 1713
      tmp___0 = 0;
    }
#line 1713
    tmp___1 = tmp___0;
  } else {
#line 1713
    tmp___1 = 0;
  }
  {
#line 1713
  nojoin = tmp___1;
#line 1719
  inbrace = (char)0;
#line 1724
  hkeys = (char)0;
#line 1731
  hvals = (char)0;
#line 1745
  horrible_offset_hack = 0;
#line 1753
  ms_flags = 0;
#line 1761
  tmp___2 = s;
#line 1761
  s ++;
#line 1761
  *tmp___2 = (char )'\000';
#line 1769
  c = *s;
#line 1770
  tmp___3 = itype_end((char const   *)s, 1 << 7, 1);
  }
#line 1770
  if ((unsigned long )tmp___3 == (unsigned long )s) {
#line 1770
    if ((int )*s != 35) {
#line 1770
      if ((int )c != -124) {
#line 1770
        if (! ((int )c == 45)) {
#line 1770
          if (! ((int )c == -101)) {
#line 1770
            if ((int )c != 33) {
#line 1770
              if ((int )c != 36) {
#line 1770
                if ((int )c != -123) {
#line 1770
                  if ((int )c != -116) {
#line 1770
                    if ((int )c != 63) {
#line 1770
                      if ((int )c != -105) {
#line 1770
                        if ((int )c != 42) {
#line 1770
                          if ((int )c != -121) {
#line 1770
                            if ((int )c != 64) {
#line 1770
                              if ((int )c != 123) {
#line 1770
                                if ((int )c != -113) {
#line 1770
                                  if ((int )c != 61) {
#line 1770
                                    if ((int )c != -115) {
#line 1770
                                      if ((int )c != -122) {
#line 1770
                                        if ((int )c != 94) {
#line 1770
                                          if ((int )c != 126) {
#line 1770
                                            if ((int )c != -104) {
#line 1770
                                              if ((int )c != 43) {
#line 1777
                                                *(s + -1) = (char )'$';
#line 1778
                                                *str = s;
#line 1779
                                                return (n);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1786
  if ((int )c == -113) {
#line 1787
    inbrace = (char)1;
#line 1788
    s ++;
#line 1797
    c = *s;
#line 1797
    if ((int )c == 33) {
#line 1797
      if ((int )*(s + 1) != -112) {
#line 1797
        if (emulation & (1 << 2)) {
#line 1798
          hkeys = (char )(1 << 1);
#line 1799
          s ++;
        } else {
#line 1797
          goto _L___3;
        }
      } else {
#line 1797
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1800
    if ((int )c == 40) {
#line 1800
      goto _L___1;
    } else
#line 1800
    if ((int )c == -120) {
      _L___1: /* CIL Label */ 
#line 1802
      tt = 0;
#line 1809
      escapes = 0;
#line 1814
      tok_arg = 0;
#line 1816
      s ++;
      {
#line 1816
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1816
        c = *s;
#line 1816
        if ((int )c != 41) {
#line 1816
          if (! ((int )c != -118)) {
#line 1816
            goto while_break;
          }
        } else {
#line 1816
          goto while_break;
        }
        {
#line 1823
        if ((int )c == -118) {
#line 1823
          goto case_neg_118;
        }
#line 1823
        if ((int )c == 41) {
#line 1823
          goto case_neg_118;
        }
#line 1827
        if ((int )c == -104) {
#line 1827
          goto case_neg_104;
        }
#line 1827
        if ((int )c == 126) {
#line 1827
          goto case_neg_104;
        }
#line 1830
        if ((int )c == 65) {
#line 1830
          goto case_65;
        }
#line 1833
        if ((int )c == 64) {
#line 1833
          goto case_64;
        }
#line 1836
        if ((int )c == 77) {
#line 1836
          goto case_77;
        }
#line 1839
        if ((int )c == 82) {
#line 1839
          goto case_82;
        }
#line 1842
        if ((int )c == 66) {
#line 1842
          goto case_66;
        }
#line 1845
        if ((int )c == 69) {
#line 1845
          goto case_69;
        }
#line 1848
        if ((int )c == 78) {
#line 1848
          goto case_78;
        }
#line 1851
        if ((int )c == 83) {
#line 1851
          goto case_83;
        }
#line 1854
        if ((int )c == 73) {
#line 1854
          goto case_73;
        }
#line 1862
        if ((int )c == 76) {
#line 1862
          goto case_76;
        }
#line 1865
        if ((int )c == 85) {
#line 1865
          goto case_85;
        }
#line 1868
        if ((int )c == 67) {
#line 1868
          goto case_67;
        }
#line 1872
        if ((int )c == 111) {
#line 1872
          goto case_111;
        }
#line 1876
        if ((int )c == 79) {
#line 1876
          goto case_79;
        }
#line 1879
        if ((int )c == 105) {
#line 1879
          goto case_105;
        }
#line 1882
        if ((int )c == 110) {
#line 1882
          goto case_110;
        }
#line 1885
        if ((int )c == 97) {
#line 1885
          goto case_97;
        }
#line 1890
        if ((int )c == 68) {
#line 1890
          goto case_68;
        }
#line 1893
        if ((int )c == 86) {
#line 1893
          goto case_86;
        }
#line 1897
        if ((int )c == 113) {
#line 1897
          goto case_113;
        }
#line 1916
        if ((int )c == 98) {
#line 1916
          goto case_98;
        }
#line 1922
        if ((int )c == 81) {
#line 1922
          goto case_81;
        }
#line 1925
        if ((int )c == 88) {
#line 1925
          goto case_88;
        }
#line 1929
        if ((int )c == 101) {
#line 1929
          goto case_101;
        }
#line 1932
        if ((int )c == 80) {
#line 1932
          goto case_80;
        }
#line 1936
        if ((int )c == 99) {
#line 1936
          goto case_99;
        }
#line 1939
        if ((int )c == 119) {
#line 1939
          goto case_119;
        }
#line 1942
        if ((int )c == 87) {
#line 1942
          goto case_87;
        }
#line 1946
        if ((int )c == 102) {
#line 1946
          goto case_102;
        }
#line 1949
        if ((int )c == 70) {
#line 1949
          goto case_70;
        }
#line 1953
        if ((int )c == 48) {
#line 1953
          goto case_48;
        }
#line 1960
        if ((int )c == 115) {
#line 1960
          goto case_115;
        }
#line 1963
        if ((int )c == 106) {
#line 1963
          goto case_106;
        }
#line 1980
        if ((int )c == 108) {
#line 1980
          goto case_108;
        }
#line 1983
        if ((int )c == 114) {
#line 1983
          goto case_114;
        }
#line 2036
        if ((int )c == 109) {
#line 2036
          goto case_109;
        }
#line 2042
        if ((int )c == 112) {
#line 2042
          goto case_112;
        }
#line 2046
        if ((int )c == 107) {
#line 2046
          goto case_107;
        }
#line 2049
        if ((int )c == 118) {
#line 2049
          goto case_118;
        }
#line 2053
        if ((int )c == 116) {
#line 2053
          goto case_116;
        }
#line 2057
        if ((int )c == 37) {
#line 2057
          goto case_37;
        }
#line 2061
        if ((int )c == 103) {
#line 2061
          goto case_103;
        }
#line 2091
        if ((int )c == 122) {
#line 2091
          goto case_122;
        }
#line 2095
        if ((int )c == 90) {
#line 2095
          goto case_90;
        }
#line 2128
        if ((int )c == 117) {
#line 2128
          goto case_117;
        }
#line 2133
        if ((int )c == -124) {
#line 2133
          goto case_neg_124;
        }
#line 2133
        if ((int )c == 35) {
#line 2133
          goto case_neg_124;
        }
#line 2137
        if ((int )c == 95) {
#line 2137
          goto case_95;
        }
#line 2156
        goto flagerr;
        case_neg_118: /* CIL Label */ 
        case_41: /* CIL Label */ 
#line 1825
        goto switch_break;
        case_neg_104: /* CIL Label */ 
        case_126: /* CIL Label */ 
#line 1828
        tok_arg = ! tok_arg;
#line 1829
        goto switch_break;
        case_65: /* CIL Label */ 
#line 1831
        arrasg ++;
#line 1832
        goto switch_break;
        case_64: /* CIL Label */ 
#line 1834
        nojoin = 2;
#line 1835
        goto switch_break;
        case_77: /* CIL Label */ 
#line 1837
        flags |= 8;
#line 1838
        goto switch_break;
        case_82: /* CIL Label */ 
#line 1840
        flags |= 16;
#line 1841
        goto switch_break;
        case_66: /* CIL Label */ 
#line 1843
        flags |= 32;
#line 1844
        goto switch_break;
        case_69: /* CIL Label */ 
#line 1846
        flags |= 64;
#line 1847
        goto switch_break;
        case_78: /* CIL Label */ 
#line 1849
        flags |= 128;
#line 1850
        goto switch_break;
        case_83: /* CIL Label */ 
#line 1852
        flags |= 4;
#line 1853
        goto switch_break;
        case_73: /* CIL Label */ 
        {
#line 1855
        s ++;
#line 1856
        flnum = get_intarg(& s, & dellen);
        }
#line 1857
        if (flnum < 0) {
#line 1858
          goto flagerr;
        }
#line 1859
        s --;
#line 1860
        goto switch_break;
        case_76: /* CIL Label */ 
#line 1863
        casmod = 2;
#line 1864
        goto switch_break;
        case_85: /* CIL Label */ 
#line 1866
        casmod = 1;
#line 1867
        goto switch_break;
        case_67: /* CIL Label */ 
#line 1869
        casmod = 3;
#line 1870
        goto switch_break;
        case_111: /* CIL Label */ 
#line 1873
        if (! sortit) {
#line 1874
          sortit |= 16;
        }
#line 1875
        goto switch_break;
        case_79: /* CIL Label */ 
#line 1877
        sortit |= 4;
#line 1878
        goto switch_break;
        case_105: /* CIL Label */ 
#line 1880
        sortit |= 1;
#line 1881
        goto switch_break;
        case_110: /* CIL Label */ 
#line 1883
        sortit |= 2;
#line 1884
        goto switch_break;
        case_97: /* CIL Label */ 
#line 1886
        sortit |= 16;
#line 1887
        indord = 1;
#line 1888
        goto switch_break;
        case_68: /* CIL Label */ 
#line 1891
        mods |= 1;
#line 1892
        goto switch_break;
        case_86: /* CIL Label */ 
#line 1894
        mods |= 2;
#line 1895
        goto switch_break;
        case_113: /* CIL Label */ 
#line 1898
        if (quotetype == 4) {
#line 1900
          goto flagerr;
        } else
#line 1898
        if (quotetype == 7) {
#line 1900
          goto flagerr;
        }
#line 1901
        if ((int )*(s + 1) == 45) {
#line 1901
          goto _L___0;
        } else
#line 1901
        if ((int )*(s + 1) == -101) {
#line 1901
          goto _L___0;
        } else
#line 1901
        if ((int )*(s + 1) == 43) {
          _L___0: /* CIL Label */ 
#line 1902
          if (quotemod) {
#line 1903
            goto flagerr;
          }
#line 1904
          s ++;
#line 1905
          quotemod = 1;
#line 1906
          if ((int )*s == 43) {
#line 1906
            quotetype = 9;
          } else {
#line 1906
            quotetype = 6;
          }
        } else {
#line 1909
          if (quotetype == 6) {
#line 1911
            goto flagerr;
          }
#line 1913
          quotemod ++;
#line 1913
          quotetype ++;
        }
#line 1915
        goto switch_break;
        case_98: /* CIL Label */ 
#line 1917
        if (quotemod) {
#line 1918
          goto flagerr;
        } else
#line 1917
        if (quotetype != 0) {
#line 1918
          goto flagerr;
        }
#line 1919
        quotemod = 1;
#line 1920
        quotetype = 7;
#line 1921
        goto switch_break;
        case_81: /* CIL Label */ 
#line 1923
        quotemod --;
#line 1924
        goto switch_break;
        case_88: /* CIL Label */ 
#line 1926
        quoteerr = 1;
#line 1927
        goto switch_break;
        case_101: /* CIL Label */ 
#line 1930
        eval___0 = 1;
#line 1931
        goto switch_break;
        case_80: /* CIL Label */ 
#line 1933
        aspar = 1;
#line 1934
        goto switch_break;
        case_99: /* CIL Label */ 
#line 1937
        whichlen = 1;
#line 1938
        goto switch_break;
        case_119: /* CIL Label */ 
#line 1940
        whichlen = 2;
#line 1941
        goto switch_break;
        case_87: /* CIL Label */ 
#line 1943
        whichlen = 3;
#line 1944
        goto switch_break;
        case_102: /* CIL Label */ 
#line 1947
        spsep = (char *)"\n";
#line 1948
        goto switch_break;
        case_70: /* CIL Label */ 
#line 1950
        sep = (char *)"\n";
#line 1951
        goto switch_break;
        case_48: /* CIL Label */ 
        {
#line 1954
        tmp___4 = zhalloc((size_t )3);
#line 1954
        spsep = (char *)tmp___4;
#line 1955
        *(spsep + 0) = (char)-125;
#line 1956
        *(spsep + 1) = (char)32;
#line 1957
        *(spsep + 2) = (char )'\000';
        }
#line 1958
        goto switch_break;
        case_115: /* CIL Label */ 
#line 1961
        tt = 1;
        case_106: /* CIL Label */ 
        {
#line 1964
        s ++;
#line 1964
        t = get_strarg(s, & arglen);
        }
#line 1965
        if (*t) {
#line 1966
          sav = *t;
#line 1967
          *t = (char )'\000';
#line 1968
          if (tt) {
            {
#line 1969
            spsep = untok_and_escape(s + arglen, escapes, tok_arg);
            }
          } else {
            {
#line 1972
            sep = untok_and_escape(s + arglen, escapes, tok_arg);
            }
          }
#line 1974
          *t = sav;
#line 1975
          s = (t + arglen) - 1;
        } else {
#line 1977
          goto flagerr;
        }
#line 1978
        goto switch_break;
        case_108: /* CIL Label */ 
#line 1981
        tt = 1;
        case_114: /* CIL Label */ 
        {
#line 1984
        s ++;
#line 1986
        del0 = s;
#line 1987
        tmp___5 = get_intarg(& s, & dellen);
#line 1987
        num = (zlong )tmp___5;
        }
#line 1988
        if (num < 0L) {
#line 1989
          goto flagerr;
        }
#line 1990
        if (tt) {
#line 1991
          prenum = num;
        } else {
#line 1993
          postnum = num;
        }
#line 1995
        if (! dellen) {
#line 1997
          s --;
#line 1998
          goto switch_break;
        } else {
          {
#line 1995
          tmp___6 = memcmp((void const   *)del0, (void const   *)s, (size_t )dellen);
          }
#line 1995
          if (tmp___6) {
#line 1997
            s --;
#line 1998
            goto switch_break;
          }
        }
        {
#line 2000
        t = get_strarg(s, & arglen);
        }
#line 2001
        if (! *t) {
#line 2002
          goto flagerr;
        }
#line 2003
        sav = *t;
#line 2004
        *t = (char )'\000';
#line 2005
        if (tt) {
          {
#line 2006
          premul = untok_and_escape(s + arglen, escapes, tok_arg);
          }
        } else {
          {
#line 2009
          postmul = untok_and_escape(s + arglen, escapes, tok_arg);
          }
        }
        {
#line 2011
        *t = sav;
#line 2012
        sav = *s;
#line 2013
        s = t + arglen;
#line 2015
        tmp___7 = memcmp((void const   *)del0, (void const   *)s, (size_t )dellen);
        }
#line 2015
        if (tmp___7) {
#line 2017
          s --;
#line 2018
          goto switch_break;
        }
        {
#line 2020
        t = get_strarg(s, & arglen);
        }
#line 2021
        if (! *t) {
#line 2022
          goto flagerr;
        }
#line 2023
        sav = *t;
#line 2024
        *t = (char )'\000';
#line 2025
        if (tt) {
          {
#line 2026
          preone = untok_and_escape(s + arglen, escapes, tok_arg);
          }
        } else {
          {
#line 2029
          postone = untok_and_escape(s + arglen, escapes, tok_arg);
          }
        }
#line 2031
        *t = sav;
#line 2033
        s = (t + arglen) - 1;
#line 2034
        goto switch_break;
        case_109: /* CIL Label */ 
#line 2038
        multi_width ++;
#line 2040
        goto switch_break;
        case_112: /* CIL Label */ 
#line 2043
        escapes = 1;
#line 2044
        goto switch_break;
        case_107: /* CIL Label */ 
#line 2047
        hkeys = (char )(1 << 1);
#line 2048
        goto switch_break;
        case_118: /* CIL Label */ 
#line 2050
        hvals = (char)1;
#line 2051
        goto switch_break;
        case_116: /* CIL Label */ 
#line 2054
        wantt = 1;
#line 2055
        goto switch_break;
        case_37: /* CIL Label */ 
#line 2058
        presc ++;
#line 2059
        goto switch_break;
        case_103: /* CIL Label */ 
        {
#line 2062
        s ++;
#line 2062
        t = get_strarg(s, & arglen);
        }
#line 2063
        if (getkeys < 0) {
#line 2064
          getkeys = 0;
        }
#line 2065
        if (*t) {
#line 2066
          sav = *t;
#line 2067
          *t = (char)0;
          {
#line 2068
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2068
            s ++;
#line 2068
            if (! *s) {
#line 2068
              goto while_break___0;
            }
            {
#line 2070
            if ((int )*s == 101) {
#line 2070
              goto case_101___0;
            }
#line 2073
            if ((int )*s == 111) {
#line 2073
              goto case_111___0;
            }
#line 2076
            if ((int )*s == 99) {
#line 2076
              goto case_99___0;
            }
#line 2080
            goto switch_default;
            case_101___0: /* CIL Label */ 
#line 2071
            getkeys |= 2;
#line 2072
            goto switch_break___0;
            case_111___0: /* CIL Label */ 
#line 2074
            getkeys |= 1;
#line 2075
            goto switch_break___0;
            case_99___0: /* CIL Label */ 
#line 2077
            getkeys |= 4;
#line 2078
            goto switch_break___0;
            switch_default: /* CIL Label */ 
#line 2081
            *t = sav;
#line 2082
            goto flagerr;
            switch_break___0: /* CIL Label */ ;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 2085
          *t = sav;
#line 2086
          s = (t + arglen) - 1;
        } else {
#line 2088
          goto flagerr;
        }
#line 2089
        goto switch_break;
        case_122: /* CIL Label */ 
#line 2092
        shsplit = 1;
#line 2093
        goto switch_break;
        case_90: /* CIL Label */ 
        {
#line 2096
        s ++;
#line 2096
        t = get_strarg(s, & arglen);
        }
#line 2097
        if (*t) {
#line 2098
          sav = *t;
#line 2099
          *t = (char)0;
          {
#line 2100
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2100
            s ++;
#line 2100
            if (! *s) {
#line 2100
              goto while_break___1;
            }
            {
#line 2102
            if ((int )*s == 99) {
#line 2102
              goto case_99___1;
            }
#line 2107
            if ((int )*s == 67) {
#line 2107
              goto case_67___0;
            }
#line 2112
            if ((int )*s == 110) {
#line 2112
              goto case_110___0;
            }
#line 2117
            goto switch_default___0;
            case_99___1: /* CIL Label */ 
#line 2104
            shsplit |= 4;
#line 2105
            goto switch_break___1;
            case_67___0: /* CIL Label */ 
#line 2109
            shsplit |= 8;
#line 2110
            goto switch_break___1;
            case_110___0: /* CIL Label */ 
#line 2114
            shsplit |= 16;
#line 2115
            goto switch_break___1;
            switch_default___0: /* CIL Label */ 
#line 2118
            *t = sav;
#line 2119
            goto flagerr;
            switch_break___1: /* CIL Label */ ;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2122
          *t = sav;
#line 2123
          s = (t + arglen) - 1;
        } else {
#line 2125
          goto flagerr;
        }
#line 2126
        goto switch_break;
        case_117: /* CIL Label */ 
#line 2129
        unique = 1;
#line 2130
        goto switch_break;
        case_neg_124: /* CIL Label */ 
        case_35: /* CIL Label */ 
#line 2134
        evalchar = 1;
#line 2135
        goto switch_break;
        case_95: /* CIL Label */ 
        {
#line 2138
        s ++;
#line 2138
        t = get_strarg(s, & arglen);
        }
#line 2139
        if (*t) {
#line 2140
          sav = *t;
#line 2141
          *t = (char)0;
          {
#line 2142
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2142
            s ++;
#line 2142
            if (! *s) {
#line 2142
              goto while_break___2;
            }
            {
#line 2145
            goto switch_default___1;
            switch_default___1: /* CIL Label */ 
#line 2146
            *t = sav;
#line 2147
            goto flagerr;
            switch_break___2: /* CIL Label */ ;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2150
          *t = sav;
#line 2151
          s = (t + arglen) - 1;
        } else {
#line 2153
          goto flagerr;
        }
#line 2154
        goto switch_break;
        flagerr: 
        switch_default___2: /* CIL Label */ 
        {
#line 2158
        zerr("error in flags");
        }
#line 2159
        return ((LinkNode )((void *)0));
        switch_break: /* CIL Label */ ;
        }
#line 1816
        s ++;
#line 1816
        tt = 0;
      }
      while_break: /* CIL Label */ ;
      }
#line 2162
      s ++;
    }
  }
#line 2170
  if (! premul) {
#line 2171
    premul = (char *)" ";
  }
#line 2172
  if (! postmul) {
#line 2173
    postmul = (char *)" ";
  }
  {
#line 2180
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2181
    c = *s;
#line 2181
    if ((int )c == 94) {
#line 2181
      goto _L___18;
    } else
#line 2181
    if ((int )c == -122) {
      _L___18: /* CIL Label */ 
#line 2183
      s ++;
#line 2183
      c = *s;
#line 2183
      if ((int )c == 94) {
#line 2184
        plan9 = 0;
#line 2185
        s ++;
      } else
#line 2183
      if ((int )c == -122) {
#line 2184
        plan9 = 0;
#line 2185
        s ++;
      } else {
#line 2187
        plan9 = 1;
      }
    } else {
#line 2188
      c = *s;
#line 2188
      if ((int )c == 61) {
#line 2188
        goto _L___17;
      } else
#line 2188
      if ((int )c == -115) {
        _L___17: /* CIL Label */ 
#line 2190
        s ++;
#line 2190
        c = *s;
#line 2190
        if ((int )c == 61) {
#line 2190
          goto _L___4;
        } else
#line 2190
        if ((int )c == -115) {
          _L___4: /* CIL Label */ 
#line 2191
          spbreak = 0;
#line 2192
          if (nojoin < 2) {
#line 2193
            nojoin = 0;
          }
#line 2194
          s ++;
        } else {
#line 2196
          spbreak = 2;
#line 2197
          if (nojoin < 2) {
#line 2198
            if (ifs) {
#line 2198
              if (*ifs) {
#line 2198
                tmp___8 = 0;
              } else {
#line 2198
                tmp___8 = 1;
              }
            } else {
#line 2198
              tmp___8 = 1;
            }
#line 2198
            nojoin = tmp___8;
          }
        }
      } else
#line 2200
      if ((int )c == 35) {
#line 2200
        goto _L___16;
      } else
#line 2200
      if ((int )c == -124) {
        _L___16: /* CIL Label */ 
#line 2200
        if (inbrace) {
#line 2200
          goto _L___15;
        } else
#line 2200
        if (! opts[133]) {
          _L___15: /* CIL Label */ 
          {
#line 2200
          tmp___10 = itype_end((char const   *)(s + 1), 1 << 7, 0);
          }
#line 2200
          if ((unsigned long )tmp___10 != (unsigned long )(s + 1)) {
#line 2218
            getlen = 1 + whichlen;
#line 2218
            s ++;
          } else {
#line 2200
            cc = *(s + 1);
#line 2200
            if ((int )cc == 42) {
#line 2218
              getlen = 1 + whichlen;
#line 2218
              s ++;
            } else
#line 2200
            if ((int )cc == -121) {
#line 2218
              getlen = 1 + whichlen;
#line 2218
              s ++;
            } else
#line 2200
            if ((int )cc == 64) {
#line 2218
              getlen = 1 + whichlen;
#line 2218
              s ++;
            } else
#line 2200
            if ((int )cc == 63) {
#line 2218
              getlen = 1 + whichlen;
#line 2218
              s ++;
            } else
#line 2200
            if ((int )cc == -105) {
#line 2218
              getlen = 1 + whichlen;
#line 2218
              s ++;
            } else
#line 2200
            if ((int )cc == 36) {
#line 2218
              getlen = 1 + whichlen;
#line 2218
              s ++;
            } else
#line 2200
            if ((int )cc == -123) {
#line 2218
              getlen = 1 + whichlen;
#line 2218
              s ++;
            } else
#line 2200
            if ((int )cc == -116) {
#line 2218
              getlen = 1 + whichlen;
#line 2218
              s ++;
            } else
#line 2200
            if ((int )cc == 35) {
#line 2200
              goto _L___13;
            } else
#line 2200
            if ((int )cc == -124) {
              _L___13: /* CIL Label */ 
#line 2200
              if ((int )*(s + 2) == -112) {
#line 2218
                getlen = 1 + whichlen;
#line 2218
                s ++;
              } else {
#line 2200
                goto _L___12;
              }
            } else
            _L___12: /* CIL Label */ 
#line 2200
            if ((int )cc == 45) {
#line 2218
              getlen = 1 + whichlen;
#line 2218
              s ++;
            } else
#line 2200
            if ((int )cc == -101) {
#line 2218
              getlen = 1 + whichlen;
#line 2218
              s ++;
            } else
#line 2200
            if ((int )cc == 58) {
#line 2200
              if ((int )*(s + 2) == 45) {
#line 2218
                getlen = 1 + whichlen;
#line 2218
                s ++;
              } else
#line 2200
              if ((int )*(s + 2) == -101) {
#line 2218
                getlen = 1 + whichlen;
#line 2218
                s ++;
              } else {
#line 2200
                goto _L___11;
              }
            } else
            _L___11: /* CIL Label */ 
#line 2200
            if ((int )cc == 36) {
#line 2200
              goto _L___10;
            } else
#line 2200
            if ((int )cc == -123) {
#line 2200
              goto _L___10;
            } else
#line 2200
            if ((int )cc == -116) {
              _L___10: /* CIL Label */ 
#line 2200
              if ((int )*(s + 2) == -113) {
#line 2218
                getlen = 1 + whichlen;
#line 2218
                s ++;
              } else
#line 2200
              if ((int )*(s + 2) == -120) {
#line 2218
                getlen = 1 + whichlen;
#line 2218
                s ++;
              } else {
#line 2200
                goto _L___14;
              }
            } else {
#line 2200
              goto _L___14;
            }
          }
        } else {
#line 2200
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 2226
      if ((int )c == 126) {
#line 2226
        goto _L___8;
      } else
#line 2226
      if ((int )c == -104) {
        _L___8: /* CIL Label */ 
#line 2228
        s ++;
#line 2228
        c = *s;
#line 2228
        if ((int )c == 126) {
#line 2229
          globsubst = 0;
#line 2230
          s ++;
        } else
#line 2228
        if ((int )c == -104) {
#line 2229
          globsubst = 0;
#line 2230
          s ++;
        } else {
#line 2232
          globsubst = 2;
        }
      } else
#line 2233
      if ((int )c == 43) {
        {
#line 2239
        tmp___9 = itype_end((char const   *)(s + 1), 1 << 7, 0);
        }
#line 2239
        if ((unsigned long )tmp___9 != (unsigned long )(s + 1)) {
#line 2241
          chkset = 1;
#line 2241
          s ++;
        } else
#line 2239
        if (aspar) {
#line 2239
          if ((int )*(s + 1) == 36) {
#line 2239
            goto _L___7;
          } else
#line 2239
          if ((int )*(s + 1) == -123) {
#line 2239
            goto _L___7;
          } else
#line 2239
          if ((int )*(s + 1) == -116) {
            _L___7: /* CIL Label */ 
#line 2239
            if ((int )*(s + 2) == -113) {
#line 2241
              chkset = 1;
#line 2241
              s ++;
            } else
#line 2239
            if ((int )*(s + 2) == -120) {
#line 2241
              chkset = 1;
#line 2241
              s ++;
            } else {
#line 2239
              goto _L___6;
            }
          } else {
#line 2239
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 2242
        if (! inbrace) {
#line 2244
          *aptr = (char )'$';
#line 2245
          *str = aptr + 1;
#line 2246
          return (n);
        } else {
          {
#line 2248
          zerr("bad substitution");
          }
#line 2249
          return ((LinkNode )((void *)0));
        }
      } else
#line 2251
      if (inbrace) {
#line 2251
        if ((int )typtab[(unsigned char )*s] & (1 << 14)) {
#line 2258
          s ++;
        } else {
#line 2260
          goto while_break___3;
        }
      } else {
#line 2260
        goto while_break___3;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2263
  if (qt) {
#line 2264
    globsubst = 0;
  }
#line 2277
  idbeg = s;
#line 2278
  if (inbrace) {
#line 2278
    if (*(s + -1)) {
#line 2278
      if ((int )*s == 36) {
#line 2278
        goto _L___20;
      } else
#line 2278
      if ((int )*s == -123) {
#line 2278
        goto _L___20;
      } else
#line 2278
      if ((int )*s == -116) {
        _L___20: /* CIL Label */ 
#line 2278
        if ((int )*(s + 1) == -113) {
#line 2278
          tmp___16 = 1;
        } else
#line 2278
        if ((int )*(s + 1) == -120) {
#line 2278
          tmp___16 = 1;
        } else
#line 2278
        if ((int )*(s + 1) == -119) {
#line 2278
          tmp___16 = 1;
        } else {
#line 2278
          tmp___16 = 0;
        }
      } else {
#line 2278
        tmp___16 = 0;
      }
    } else {
#line 2278
      tmp___16 = 0;
    }
  } else {
#line 2278
    tmp___16 = 0;
  }
#line 2278
  subexp = tmp___16;
#line 2278
  if (subexp) {
#line 2281
    quoted = (int )*s == -116;
#line 2284
    tmp___11 = s;
#line 2284
    s ++;
#line 2284
    val = tmp___11;
    {
#line 2286
    if ((int )*s == -113) {
#line 2286
      goto case_neg_113;
    }
#line 2289
    if ((int )*s == -120) {
#line 2289
      goto case_neg_120;
    }
#line 2292
    if ((int )*s == -119) {
#line 2292
      goto case_neg_119;
    }
#line 2295
    goto switch_default___3;
    case_neg_113: /* CIL Label */ 
#line 2287
    outtok = -112;
#line 2288
    goto switch_break___3;
    case_neg_120: /* CIL Label */ 
#line 2290
    outtok = -118;
#line 2291
    goto switch_break___3;
    case_neg_119: /* CIL Label */ 
#line 2293
    outtok = -117;
#line 2294
    goto switch_break___3;
    switch_default___3: /* CIL Label */ ;
#line 2298
    return ((LinkNode )((void *)0));
    switch_break___3: /* CIL Label */ ;
    }
    {
#line 2300
    skipparens(*s, (char )outtok, & s);
#line 2301
    sav___0 = (int )*s;
#line 2302
    *s = (char)0;
    }
#line 2310
    if (aspar) {
#line 2310
      tmp___13 = (char ***)((void *)0);
    } else {
#line 2310
      tmp___13 = & aval;
    }
    {
#line 2310
    tmp___14 = multsub(& val, 64, tmp___13, & isarr, (char *)((void *)0), & ms_flags);
    }
#line 2310
    if (tmp___14) {
#line 2310
      if (quoted) {
        {
#line 2313
        isarr = -1;
#line 2314
        tmp___12 = hcalloc(sizeof(char *));
#line 2314
        aval = (char **)tmp___12;
#line 2315
        aspar = 0;
        }
      } else {
#line 2310
        goto _L___19;
      }
    } else
    _L___19: /* CIL Label */ 
#line 2316
    if (aspar) {
#line 2317
      idbeg = val;
    }
#line 2318
    *s = (char )sav___0;
    {
#line 2323
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2323
      if (! ((int )typtab[(unsigned char )*s] & (1 << 14))) {
#line 2323
        goto while_break___4;
      }
#line 2324
      s ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2325
    if (ms_flags & 4) {
#line 2335
      if (isarr) {
#line 2336
        if (*(aval + 0)) {
#line 2336
          if (*(aval + 1)) {
            {
#line 2337
            zerr("parameter name reference used with array");
            }
#line 2338
            return ((LinkNode )((void *)0));
          }
        }
#line 2340
        val = *(aval + 0);
#line 2341
        isarr = 0;
      }
      {
#line 2343
      s = dyncat((char const   *)val, (char const   *)s);
#line 2345
      subexp = 0;
      }
#line 2351
      if (aspar) {
#line 2351
        if (! (pf_flags & 64)) {
#line 2351
          tmp___15 = 1;
        } else {
#line 2351
          tmp___15 = 0;
        }
      } else {
#line 2351
        tmp___15 = 0;
      }
#line 2351
      fetch_needed = tmp___15;
    } else {
#line 2353
      fetch_needed = 0;
    }
#line 2354
    v = (Value )((void *)0);
  } else {
#line 2356
    fetch_needed = aspar;
  }
#line 2357
  if (fetch_needed) {
#line 2367
    if (qt) {
#line 2367
      tmp___17 = 1 << 8;
    } else {
#line 2367
      tmp___17 = 0;
    }
    {
#line 2367
    v = fetchvalue(& vbuf, & s, 1, tmp___17);
    }
#line 2367
    if (v) {
      {
#line 2368
      idbeg = getstrvalue(v);
#line 2368
      val = idbeg;
#line 2369
      subexp = 1;
      }
    } else {
#line 2371
      vunset = 1;
    }
  }
#line 2373
  if (aspar) {
#line 2373
    if (pf_flags & 64) {
#line 2381
      aspar = 0;
#line 2382
      *ret_flags |= 4;
    }
  }
#line 2390
  if (! subexp) {
#line 2390
    goto _L___22;
  } else
#line 2390
  if (aspar) {
    _L___22: /* CIL Label */ 
#line 2391
    ov = val;
#line 2418
    if (arrasg) {
#line 2418
      tmp___18 = 1 << 6;
    } else {
#line 2418
      tmp___18 = 0;
    }
#line 2418
    if (qt) {
#line 2418
      tmp___19 = 1 << 8;
    } else {
#line 2418
      tmp___19 = 0;
    }
#line 2418
    if (wantt) {
#line 2418
      tmp___21 = -1;
    } else {
#line 2418
      if (! opts[95]) {
#line 2418
        tmp___20 = 1;
      } else
#line 2418
      if (inbrace) {
#line 2418
        tmp___20 = 1;
      } else {
#line 2418
        tmp___20 = -1;
      }
#line 2418
      tmp___21 = tmp___20;
    }
#line 2418
    if (subexp) {
#line 2418
      tmp___22 = & ov;
    } else {
#line 2418
      tmp___22 = & s;
    }
    {
#line 2418
    v = fetchvalue(& vbuf, tmp___22, tmp___21, (((int )hkeys | (int )hvals) | tmp___18) | tmp___19);
    }
#line 2418
    if (v) {
#line 2418
      if (v->pm) {
#line 2418
        if ((v->pm)->node.flags & (1 << 25)) {
#line 2426
          vunset = 1;
        } else {
#line 2418
          goto _L___21;
        }
      } else
      _L___21: /* CIL Label */ 
#line 2418
      if (v->flags & 2) {
#line 2426
        vunset = 1;
      }
    } else {
#line 2426
      vunset = 1;
    }
#line 2428
    if (wantt) {
#line 2433
      if (v) {
#line 2433
        if (v->pm) {
#line 2433
          if (! ((v->pm)->node.flags & (1 << 25))) {
#line 2434
            f = (v->pm)->node.flags;
            {
#line 2437
            if ((f & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 2437
              goto case_0;
            }
#line 2438
            if ((f & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 2438
              goto case_1;
            }
#line 2439
            if ((f & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 2439
              goto case_exp;
            }
#line 2441
            if ((f & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 2441
              goto case_exp___0;
            }
#line 2441
            if ((f & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 2441
              goto case_exp___0;
            }
#line 2442
            if ((f & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
#line 2442
              goto case_exp___2;
            }
#line 2436
            goto switch_break___4;
            case_0: /* CIL Label */ 
#line 2437
            val = (char *)"scalar";
#line 2437
            goto switch_break___4;
            case_1: /* CIL Label */ 
#line 2438
            val = (char *)"array";
#line 2438
            goto switch_break___4;
            case_exp: /* CIL Label */ 
#line 2439
            val = (char *)"integer";
#line 2439
            goto switch_break___4;
            case_exp___0: /* CIL Label */ 
            case_exp___1: /* CIL Label */ 
#line 2441
            val = (char *)"float";
#line 2441
            goto switch_break___4;
            case_exp___2: /* CIL Label */ 
#line 2442
            val = (char *)"association";
#line 2442
            goto switch_break___4;
            switch_break___4: /* CIL Label */ ;
            }
            {
#line 2444
            val = dupstring((char const   *)val);
            }
#line 2445
            if ((v->pm)->level) {
              {
#line 2446
              val = dyncat((char const   *)val, "-local");
              }
            }
#line 2447
            if (f & (1 << 5)) {
              {
#line 2448
              val = dyncat((char const   *)val, "-left");
              }
            }
#line 2449
            if (f & (1 << 6)) {
              {
#line 2450
              val = dyncat((char const   *)val, "-right_blanks");
              }
            }
#line 2451
            if (f & (1 << 7)) {
              {
#line 2452
              val = dyncat((char const   *)val, "-right_zeros");
              }
            }
#line 2453
            if (f & (1 << 8)) {
              {
#line 2454
              val = dyncat((char const   *)val, "-lower");
              }
            }
#line 2455
            if (f & (1 << 9)) {
              {
#line 2456
              val = dyncat((char const   *)val, "-upper");
              }
            }
#line 2457
            if (f & (1 << 10)) {
              {
#line 2458
              val = dyncat((char const   *)val, "-readonly");
              }
            }
#line 2459
            if (f & (1 << 11)) {
              {
#line 2460
              val = dyncat((char const   *)val, "-tag");
              }
            }
#line 2461
            if (f & (1 << 16)) {
              {
#line 2462
              val = dyncat((char const   *)val, "-tag_local");
              }
            }
#line 2463
            if (f & (1 << 12)) {
              {
#line 2464
              val = dyncat((char const   *)val, "-export");
              }
            }
#line 2465
            if (f & (1 << 13)) {
              {
#line 2466
              val = dyncat((char const   *)val, "-unique");
              }
            }
#line 2467
            if (f & (1 << 14)) {
              {
#line 2468
              val = dyncat((char const   *)val, "-hide");
              }
            }
#line 2469
            if (f & (1 << 15)) {
              {
#line 2470
              val = dyncat((char const   *)val, "-hideval");
              }
            }
#line 2471
            if (f & (1 << 22)) {
              {
#line 2472
              val = dyncat((char const   *)val, "-special");
              }
            }
#line 2473
            vunset = 0;
          } else {
            {
#line 2475
            val = dupstring("");
            }
          }
        } else {
          {
#line 2475
          val = dupstring("");
          }
        }
      } else {
        {
#line 2475
        val = dupstring("");
        }
      }
#line 2477
      v = (Value )((void *)0);
#line 2478
      isarr = 0;
    }
  }
  {
#line 2486
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2486
    if (! v) {
#line 2486
      if (inbrace) {
#line 2486
        goto _L___23;
      } else
#line 2486
      if (! opts[95]) {
#line 2486
        if (vunset) {
          _L___23: /* CIL Label */ 
#line 2486
          if (! ((int )*s == 91)) {
#line 2486
            if (! ((int )*s == -111)) {
#line 2486
              goto while_break___5;
            }
          }
        } else {
#line 2486
          goto while_break___5;
        }
      } else {
#line 2486
        goto while_break___5;
      }
    }
#line 2487
    if (! v) {
#line 2500
      os = s;
#line 2502
      if (! ((int )*s == 91)) {
#line 2502
        if (! ((int )*s == -111)) {
#line 2503
          goto while_break___5;
        }
      }
#line 2504
      if (vunset) {
        {
#line 2505
        val = dupstring("");
#line 2506
        isarr = 0;
        }
      }
#line 2508
      if (isarr) {
#line 2508
        tmp___23 = 1;
      } else {
#line 2508
        tmp___23 = 0;
      }
      {
#line 2508
      pm = createparam(nulstring, tmp___23);
      }
#line 2510
      if (isarr) {
#line 2511
        pm->u.arr = aval;
      } else {
#line 2513
        pm->u.str = val;
      }
      {
#line 2514
      tmp___24 = hcalloc(sizeof(*v));
#line 2514
      v = (Value )tmp___24;
#line 2515
      v->isarr = isarr;
#line 2516
      v->pm = pm;
#line 2517
      v->end = -1;
      }
#line 2518
      if (qt) {
#line 2518
        tmp___25 = 1 << 8;
      } else {
#line 2518
        tmp___25 = 0;
      }
      {
#line 2518
      tmp___26 = getindex(& s, v, tmp___25);
      }
#line 2518
      if (tmp___26) {
#line 2519
        goto while_break___5;
      } else
#line 2518
      if ((unsigned long )s == (unsigned long )os) {
#line 2519
        goto while_break___5;
      }
    }
#line 2534
    isarr = v->isarr;
#line 2534
    if (isarr) {
#line 2540
      if (v->isarr == 1 << 2) {
        {
#line 2541
        tmp___27 = 0;
#line 2541
        v->isarr = tmp___27;
#line 2541
        isarr = tmp___27;
#line 2542
        val = dupstring((char const   *)(v->pm)->node.nam);
        }
      } else {
        {
#line 2544
        aval = getarrvalue(v);
        }
      }
    } else {
#line 2547
      if ((v->pm)->node.flags & 1) {
#line 2560
        tmplen = -1;
#line 2562
        if (v->start < 0) {
          {
#line 2563
          tmp___28 = (*(((v->pm)->gsu.a)->getfn))(v->pm);
#line 2563
          tmplen = arrlen(tmp___28);
          }
#line 2564
          if (v->flags & 1) {
#line 2564
            tmp___29 = 1;
          } else {
#line 2564
            tmp___29 = 0;
          }
#line 2564
          v->start += tmplen + tmp___29;
        }
#line 2566
        if (! (v->flags & 1)) {
#line 2567
          if (v->start < 0) {
#line 2571
            vunset = 1;
          } else {
#line 2567
            if (tmplen != -1) {
#line 2567
              tmp___32 = v->start >= tmplen;
            } else {
              {
#line 2567
              tmp___30 = (*(((v->pm)->gsu.a)->getfn))(v->pm);
#line 2567
              tmp___31 = arrlen_le(tmp___30, (unsigned int )v->start);
#line 2567
              tmp___32 = (int )tmp___31;
              }
            }
#line 2567
            if (tmp___32) {
#line 2571
              vunset = 1;
            }
          }
        }
      }
#line 2573
      if (! vunset) {
        {
#line 2582
        v->flags |= 4;
#line 2583
        val = getstrvalue(v);
        }
      }
    }
#line 2587
    if (v) {
#line 2587
      if (v->pm) {
#line 2587
        if ((unsigned long )(v->pm)->gsu.a == (unsigned long )(& vararray_gsu)) {
#line 2587
          if ((unsigned long )((char ***)(v->pm)->u.data) == (unsigned long )(& pparams)) {
#line 2589
            horrible_offset_hack = 1;
          } else {
#line 2591
            horrible_offset_hack = 0;
          }
        } else {
#line 2591
          horrible_offset_hack = 0;
        }
      } else {
#line 2591
        horrible_offset_hack = 0;
      }
    } else {
#line 2591
      horrible_offset_hack = 0;
    }
#line 2599
    v = (Value )((void *)0);
#line 2600
    if (! inbrace) {
#line 2601
      goto while_break___5;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2611
  if (inbrace) {
#line 2612
    c = *s;
#line 2613
    if (! ((int )c == 45)) {
#line 2613
      if (! ((int )c == -101)) {
#line 2613
        if ((int )c != 43) {
#line 2613
          if ((int )c != 58) {
#line 2613
            if ((int )c != 37) {
#line 2613
              if ((int )c != 47) {
#line 2613
                if ((int )c != 61) {
#line 2613
                  if ((int )c != -115) {
#line 2613
                    if ((int )c != 35) {
#line 2613
                      if ((int )c != -124) {
#line 2613
                        if ((int )c != 63) {
#line 2613
                          if ((int )c != -105) {
#line 2613
                            if ((int )c != 125) {
#line 2613
                              if ((int )c != -112) {
                                {
#line 2619
                                zerr("bad substitution");
                                }
#line 2620
                                return ((LinkNode )((void *)0));
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 2647
  if (isarr) {
#line 2648
    if (nojoin) {
#line 2649
      isarr = -1;
    }
#line 2650
    if (qt) {
#line 2650
      if (! getlen) {
#line 2650
        if (isarr > 0) {
          {
#line 2651
          val = sepjoin(aval, sep, 1);
#line 2652
          isarr = 0;
          }
        }
      }
    }
  }
#line 2656
  idend = s;
#line 2657
  if (inbrace) {
    {
#line 2663
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2663
      if (! ((int )typtab[(unsigned char )*s] & (1 << 14))) {
#line 2663
        goto while_break___6;
      }
#line 2664
      s ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 2671
  colf = (int )*s == 58;
#line 2671
  if (colf) {
#line 2672
    s ++;
  }
#line 2677
  fstr___0 = s;
#line 2678
  if (inbrace) {
#line 2680
    bct = 1;
    {
#line 2680
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2680
      c = *fstr___0;
#line 2680
      if (! c) {
#line 2680
        goto while_break___7;
      }
#line 2681
      if ((int )c == -113) {
#line 2682
        bct ++;
      } else
#line 2683
      if ((int )c == -112) {
#line 2683
        bct --;
#line 2683
        if (! bct) {
#line 2684
          goto while_break___7;
        }
      }
#line 2680
      fstr___0 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2687
    if (bct) {
      noclosebrace: 
      {
#line 2689
      zerr("closing brace expected");
      }
#line 2690
      return ((LinkNode )((void *)0));
    }
#line 2692
    if (c) {
#line 2693
      tmp___33 = fstr___0;
#line 2693
      fstr___0 ++;
#line 2693
      *tmp___33 = (char )'\000';
    }
  }
#line 2699
  if (inbrace) {
#line 2699
    c = *s;
#line 2699
    if ((int )c == 43) {
#line 2699
      goto _L___38;
    } else
#line 2699
    if ((int )c == 45) {
#line 2699
      goto _L___38;
    } else
#line 2699
    if ((int )c == -101) {
#line 2699
      goto _L___38;
    } else
#line 2699
    if ((int )c == 58) {
#line 2699
      goto _L___38;
    } else
#line 2699
    if ((int )c == 61) {
#line 2699
      goto _L___38;
    } else
#line 2699
    if ((int )c == -115) {
#line 2699
      goto _L___38;
    } else
#line 2699
    if ((int )c == 37) {
#line 2699
      goto _L___38;
    } else
#line 2699
    if ((int )c == 35) {
#line 2699
      goto _L___38;
    } else
#line 2699
    if ((int )c == -124) {
#line 2699
      goto _L___38;
    } else
#line 2699
    if ((int )c == 63) {
#line 2699
      goto _L___38;
    } else
#line 2699
    if ((int )c == -105) {
#line 2699
      goto _L___38;
    } else
#line 2699
    if ((int )c == 47) {
      _L___38: /* CIL Label */ 
#line 2713
      if (! flnum) {
#line 2714
        flnum ++;
      }
#line 2715
      if ((int )c == 37) {
#line 2716
        flags |= 1;
      }
#line 2719
      if ((int )c == 37) {
#line 2719
        goto _L___24;
      } else
#line 2719
      if ((int )c == 35) {
#line 2719
        goto _L___24;
      } else
#line 2719
      if ((int )c == -124) {
        _L___24: /* CIL Label */ 
#line 2719
        if ((int )c == (int )*(s + 1)) {
#line 2720
          s ++;
#line 2722
          flags |= 2;
        }
      }
#line 2724
      s ++;
#line 2725
      if ((int )*(s + -1) == 47) {
#line 2731
        if (flags & 4) {
#line 2731
          flags = 0;
        } else {
#line 2731
          flags = 2;
        }
#line 2732
        c = *s;
#line 2732
        if ((int )c == 47) {
#line 2734
          flags |= 512;
#line 2735
          s ++;
#line 2735
          c = *s;
        }
#line 2738
        if ((int )c == 35) {
#line 2744
          flags |= 4096;
#line 2745
          s ++;
        } else
#line 2738
        if ((int )c == -124) {
#line 2744
          flags |= 4096;
#line 2745
          s ++;
        }
#line 2747
        if ((int )*s == 37) {
#line 2749
          flags |= 1;
#line 2750
          s ++;
        }
#line 2752
        if (! (flags & 4097)) {
#line 2754
          flags |= 4;
        }
#line 2765
        ptr___0 = s;
        {
#line 2765
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2765
          c = *ptr___0;
#line 2765
          if (c) {
#line 2765
            if (! ((int )c != 47)) {
#line 2765
              goto while_break___8;
            }
          } else {
#line 2765
            goto while_break___8;
          }
#line 2767
          if ((int )c == -97) {
#line 2767
            goto _L___25;
          } else
#line 2767
          if ((int )c == -96) {
#line 2767
            goto _L___25;
          } else
#line 2767
          if ((int )c == 92) {
            _L___25: /* CIL Label */ 
#line 2767
            if (*(ptr___0 + 1)) {
#line 2769
              if ((int )*(ptr___0 + 1) == 47) {
                {
#line 2770
                chuck(ptr___0);
                }
              } else {
#line 2772
                ptr___0 ++;
              }
            }
          }
#line 2765
          ptr___0 ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 2775
        if (*ptr___0) {
#line 2775
          if (*(ptr___0 + 1)) {
#line 2775
            replstr = ptr___0 + 1;
          } else {
#line 2775
            replstr = (char *)"";
          }
        } else {
#line 2775
          replstr = (char *)"";
        }
#line 2776
        *ptr___0 = (char )'\000';
      }
#line 2780
      if (colf) {
#line 2781
        flags |= 256;
      }
#line 2787
      if (! (flags & 248)) {
#line 2788
        flags |= 16;
      }
#line 2795
      if (colf) {
#line 2795
        if (! vunset) {
#line 2796
          if (isarr) {
#line 2796
            vunset = ! *aval;
          } else {
#line 2796
            if (! *val) {
#line 2796
              tmp___34 = 1;
            } else
#line 2796
            if ((int )*val == -95) {
#line 2796
              if (! *(val + 1)) {
#line 2796
                tmp___34 = 1;
              } else {
#line 2796
                tmp___34 = 0;
              }
            } else {
#line 2796
              tmp___34 = 0;
            }
#line 2796
            vunset = tmp___34;
          }
#line 2797
          vunset *= -1;
        }
      }
      {
#line 2801
      if ((int )*(s + -1) == 43) {
#line 2801
        goto case_43;
      }
#line 2811
      if ((int )*(s + -1) == -101) {
#line 2811
        goto case_neg_101;
      }
#line 2811
      if ((int )*(s + -1) == 45) {
#line 2811
        goto case_neg_101;
      }
#line 2843
      if ((int )*(s + -1) == 58) {
#line 2843
        goto case_58;
      }
#line 2851
      if ((int )*(s + -1) == -115) {
#line 2851
        goto case_neg_115;
      }
#line 2851
      if ((int )*(s + -1) == 61) {
#line 2851
        goto case_neg_115;
      }
#line 2932
      if ((int )*(s + -1) == -105) {
#line 2932
        goto case_neg_105;
      }
#line 2932
      if ((int )*(s + -1) == 63) {
#line 2932
        goto case_neg_105;
      }
#line 2962
      if ((int )*(s + -1) == 47) {
#line 2962
        goto case_47;
      }
#line 2962
      if ((int )*(s + -1) == -124) {
#line 2962
        goto case_47;
      }
#line 2962
      if ((int )*(s + -1) == 35) {
#line 2962
        goto case_47;
      }
#line 2962
      if ((int )*(s + -1) == 37) {
#line 2962
        goto case_47;
      }
#line 2800
      goto switch_break___5;
      case_43: /* CIL Label */ 
#line 2802
      if (vunset) {
        {
#line 2803
        val = dupstring("");
#line 2804
        copied = 1;
#line 2805
        isarr = 0;
        }
#line 2806
        goto switch_break___5;
      }
#line 2808
      vunset = 1;
      case_neg_101: /* CIL Label */ 
      case_45: /* CIL Label */ 
#line 2812
      if (vunset) {
        {
#line 2814
        val = dupstring((char const   *)s);
        }
#line 2822
        if (spbreak) {
#line 2823
          split_flags = 16;
#line 2824
          if (! aspar) {
#line 2825
            split_flags |= 8;
          }
        } else {
#line 2832
          split_flags = 32;
        }
#line 2834
        if (aspar) {
#line 2834
          tmp___35 = (char ***)((void *)0);
        } else {
#line 2834
          tmp___35 = & aval;
        }
        {
#line 2834
        multsub(& val, split_flags, tmp___35, & isarr, (char *)((void *)0), & ms_flags);
#line 2836
        copied = 1;
#line 2837
        spbreak = 0;
        }
#line 2839
        if (globsubst != 2) {
#line 2840
          globsubst = 0;
        }
      }
#line 2842
      goto switch_break___5;
      case_58: /* CIL Label */ 
#line 2845
      if ((int )*s != 61) {
#line 2845
        if ((int )*s != -115) {
#line 2846
          goto noclosebrace;
        }
      }
#line 2847
      vunset = 1;
#line 2848
      s ++;
      case_neg_115: /* CIL Label */ 
      case_61: /* CIL Label */ 
#line 2852
      if (vunset) {
        {
#line 2853
        sav___1 = *idend;
#line 2856
        *idend = (char )'\000';
#line 2857
        val = dupstring((char const   *)s);
        }
#line 2858
        if (spsep) {
#line 2858
          goto _L___26;
        } else
#line 2858
        if (! arrasg) {
          _L___26: /* CIL Label */ 
#line 2862
          if (spbreak) {
#line 2862
            tmp___36 = 4;
          } else {
#line 2862
            tmp___36 = 32;
          }
          {
#line 2862
          multsub(& val, tmp___36, (char ***)((void *)0), & isarr, (char *)((void *)0),
                  & ms_flags);
          }
        } else {
#line 2866
          if (spbreak) {
#line 2867
            split_flags___0 = 24;
          } else {
#line 2869
            split_flags___0 = 32;
          }
          {
#line 2870
          multsub(& val, split_flags___0, & aval, & isarr, (char *)((void *)0), & ms_flags);
#line 2872
          spbreak = 0;
          }
        }
#line 2874
        if (arrasg) {
#line 2877
          if (spsep) {
#line 2877
            goto _L___27;
          } else
#line 2877
          if (spbreak) {
            _L___27: /* CIL Label */ 
            {
#line 2878
            aval = sepsplit(val, spsep, 0, 1);
            }
#line 2879
            if (nojoin) {
#line 2879
              isarr = 1;
            } else {
#line 2879
              isarr = 2;
            }
            {
#line 2880
            l___0 = arrlen(aval);
            }
#line 2881
            if (l___0) {
#line 2881
              if (! *(*(aval + (l___0 - 1)))) {
#line 2882
                l___0 --;
              }
            }
#line 2883
            if (l___0) {
#line 2883
              if (! *(*aval)) {
#line 2884
                l___0 --;
#line 2884
                t___0 = aval + 1;
              } else {
#line 2886
                t___0 = aval;
              }
            } else {
#line 2886
              t___0 = aval;
            }
          } else
#line 2887
          if (! isarr) {
#line 2888
            if (! *val) {
#line 2888
              if (arrasg > 1) {
#line 2889
                arr[0] = (char *)((void *)0);
#line 2890
                l___0 = 0;
              } else {
#line 2892
                arr[0] = val;
#line 2893
                arr[1] = (char *)((void *)0);
#line 2894
                l___0 = 1;
              }
            } else {
#line 2892
              arr[0] = val;
#line 2893
              arr[1] = (char *)((void *)0);
#line 2894
              l___0 = 1;
            }
#line 2896
            aval = arr;
#line 2896
            t___0 = aval;
          } else {
            {
#line 2898
            l___0 = arrlen(aval);
#line 2898
            t___0 = aval;
            }
          }
          {
#line 2899
          tmp___37 = zalloc(sizeof(char *) * (unsigned long )(l___0 + 1));
#line 2899
          a = (char **)tmp___37;
#line 2899
          p = a;
          }
          {
#line 2900
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 2900
            tmp___40 = l___0;
#line 2900
            l___0 --;
#line 2900
            if (! tmp___40) {
#line 2900
              goto while_break___9;
            }
            {
#line 2901
            untokenize(*t___0);
#line 2902
            tmp___38 = p;
#line 2902
            p ++;
#line 2902
            tmp___39 = t___0;
#line 2902
            t___0 ++;
#line 2902
            *tmp___38 = ztrdup((char const   *)*tmp___39);
            }
          }
          while_break___9: /* CIL Label */ ;
          }
#line 2904
          tmp___41 = p;
#line 2904
          p ++;
#line 2904
          *tmp___41 = (char *)((void *)0);
#line 2905
          if (arrasg > 1) {
            {
#line 2906
            tmp___42 = sethparam(idbeg, a);
#line 2906
            pm___0 = tmp___42;
            }
#line 2907
            if (pm___0) {
              {
#line 2908
              tmp___43 = (*((pm___0->gsu.h)->getfn))(pm___0);
#line 2908
              aval = paramvalarr(tmp___43, (int )hkeys | (int )hvals);
              }
            }
          } else {
            {
#line 2910
            setaparam(idbeg, a);
            }
          }
#line 2911
          isarr = 1;
#line 2912
          arrasg = 0;
        } else {
          {
#line 2914
          untokenize(val);
#line 2915
          tmp___44 = ztrdup((char const   *)val);
#line 2915
          setsparam(idbeg, tmp___44);
          }
        }
#line 2917
        *idend = sav___1;
#line 2918
        copied = 1;
#line 2919
        if (isarr) {
#line 2920
          if (nojoin) {
#line 2921
            isarr = -1;
          }
#line 2922
          if (qt) {
#line 2922
            if (! getlen) {
#line 2922
              if (isarr > 0) {
#line 2922
                if (! spsep) {
#line 2922
                  if (spbreak < 2) {
                    {
#line 2923
                    val = sepjoin(aval, sep, 1);
#line 2924
                    isarr = 0;
                    }
                  }
                }
              }
            }
          }
#line 2926
          spsep = (char *)((void *)0);
#line 2926
          sep = spsep;
#line 2927
          spbreak = 0;
        }
      }
#line 2930
      goto switch_break___5;
      case_neg_105: /* CIL Label */ 
      case_63: /* CIL Label */ 
#line 2933
      if (vunset) {
#line 2934
        if (opts[52]) {
#line 2935
          *idend = (char )'\000';
#line 2936
          if (*s) {
#line 2936
            tmp___45 = (char const   *)s;
          } else {
#line 2936
            tmp___45 = "parameter not set";
          }
          {
#line 2936
          zerr("%s: %s", idbeg, tmp___45);
#line 2943
          errflag |= 4;
          }
#line 2944
          if (! opts[93]) {
            {
#line 2945
            tmp___46 = getpid();
            }
#line 2945
            if (mypid == (zlong )tmp___46) {
              {
#line 2950
              stopmsg = 1;
#line 2951
              zexit(1, 0);
              }
            } else {
              {
#line 2953
              _exit(1);
              }
            }
          }
        }
#line 2956
        return ((LinkNode )((void *)0));
      }
#line 2958
      goto switch_break___5;
      case_47: /* CIL Label */ 
      case_neg_124___0: /* CIL Label */ 
      case_35___0: /* CIL Label */ 
      case_37___0: /* CIL Label */ 
#line 2971
      one = noerrs;
#line 2971
      oef = errflag;
#line 2973
      if (! quoteerr) {
#line 2974
        noerrs = 1;
      }
      {
#line 2975
      haserr = parse_subst_string(s);
#line 2976
      noerrs = one;
      }
#line 2977
      if (! quoteerr) {
#line 2979
        errflag = oef | (errflag & 2);
#line 2980
        if (haserr) {
          {
#line 2981
          shtokenize(s);
          }
        }
      } else
#line 2982
      if (haserr) {
        {
#line 2983
        zerr("parse error in ${...%c...} substitution", (int )*(s + -1));
        }
#line 2984
        return ((LinkNode )((void *)0));
      } else
#line 2982
      if (errflag) {
        {
#line 2983
        zerr("parse error in ${...%c...} substitution", (int )*(s + -1));
        }
#line 2984
        return ((LinkNode )((void *)0));
      }
      {
#line 3011
      singsub(& s);
      }
#line 3021
      if (! vunset) {
#line 3021
        if (isarr) {
#line 3023
          if (! copied) {
            {
#line 3024
            aval = arrdup(aval);
#line 3025
            copied = 1;
            }
          }
#line 3027
          ap = aval;
          {
#line 3027
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 3027
            if (! *ap) {
#line 3027
              goto while_break___10;
            }
            {
#line 3028
            untokenize(*ap);
#line 3027
            ap ++;
            }
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 3030
          getmatcharr(& aval, s, flags, flnum, replstr);
          }
        } else {
#line 3021
          goto _L___28;
        }
      } else {
        _L___28: /* CIL Label */ 
#line 3032
        if (vunset) {
#line 3033
          if (vunset > 0) {
#line 3033
            if (! opts[172]) {
              {
#line 3034
              *idend = (char )'\000';
#line 3035
              zerr("%s: parameter not set", idbeg);
              }
#line 3036
              return ((LinkNode )((void *)0));
            }
          }
          {
#line 3038
          val = dupstring("");
          }
        }
#line 3040
        if (! copied) {
          {
#line 3041
          val = dupstring((char const   *)val);
#line 3042
          copied = 1;
#line 3043
          untokenize(val);
          }
        }
        {
#line 3045
        getmatch(& val, s, flags, flnum, replstr);
        }
      }
#line 3047
      goto switch_break___5;
      switch_break___5: /* CIL Label */ ;
      }
    } else {
#line 2699
      goto _L___37;
    }
  } else
  _L___37: /* CIL Label */ 
#line 3049
  if (inbrace) {
#line 3049
    if ((int )*s == 94) {
#line 3049
      goto _L___36;
    } else
#line 3049
    if ((int )*s == -122) {
      _L___36: /* CIL Label */ 
#line 3051
      shortest = 1;
#line 3052
      s ++;
#line 3053
      if ((int )*s == 94) {
#line 3054
        shortest = 0;
#line 3055
        s ++;
      } else
#line 3053
      if ((int )*s == -122) {
#line 3054
        shortest = 0;
#line 3055
        s ++;
      }
      {
#line 3057
      tmp___47 = itype_end((char const   *)s, 1 << 7, 0);
      }
#line 3057
      if (*tmp___47) {
        {
#line 3058
        untokenize(s);
#line 3059
        zerr("not an identifier: %s", s);
        }
#line 3060
        return ((LinkNode )((void *)0));
      }
#line 3062
      if (vunset) {
#line 3063
        if (vunset > 0) {
#line 3063
          if (! opts[172]) {
            {
#line 3064
            *idend = (char )'\000';
#line 3065
            zerr("%s: parameter not set", idbeg);
            }
#line 3066
            return ((LinkNode )((void *)0));
          }
        }
        {
#line 3068
        val = dupstring("");
        }
      } else {
        {
#line 3071
        zip = getaparam(s);
        }
#line 3072
        if (! zip) {
          {
#line 3073
          sval = getsparam(s);
          }
#line 3074
          if (sval) {
            {
#line 3075
            zip = hmkarray(sval);
            }
          }
        }
#line 3077
        if (! isarr) {
          {
#line 3078
          aval = mkarray(val);
#line 3079
          isarr = 1;
          }
        }
#line 3081
        if (zip) {
          {
#line 3083
          i = 0;
#line 3084
          alen = arrlen(aval);
#line 3085
          ziplen = arrlen(zip);
          }
#line 3086
          if (shortest ^ (alen > ziplen)) {
#line 3086
            outlen = alen;
          } else {
#line 3086
            outlen = ziplen;
          }
#line 3087
          if (! shortest) {
#line 3087
            if (alen == 0) {
#line 3087
              goto _L___30;
            } else
#line 3087
            if (ziplen == 0) {
              _L___30: /* CIL Label */ 
#line 3088
              if (ziplen) {
                {
#line 3089
                aval = arrdup(zip);
                }
              }
            } else {
#line 3087
              goto _L___29;
            }
          } else {
            _L___29: /* CIL Label */ 
            {
#line 3091
            tmp___48 = zhalloc(sizeof(char *) * (unsigned long )(2 * outlen + 1));
#line 3091
            out = (char **)tmp___48;
            }
            {
#line 3092
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 3092
              if (! (i < outlen)) {
#line 3092
                goto while_break___11;
              }
#line 3093
              if (copied) {
#line 3094
                *(out + i * 2) = *(aval + i % alen);
              } else {
                {
#line 3096
                *(out + i * 2) = dupstring((char const   *)*(aval + i % alen));
                }
              }
              {
#line 3097
              *(out + (i * 2 + 1)) = dupstring((char const   *)*(zip + i % ziplen));
#line 3098
              i ++;
              }
            }
            while_break___11: /* CIL Label */ ;
            }
#line 3100
            *(out + i * 2) = (char *)((void *)0);
#line 3101
            aval = out;
#line 3102
            copied = 1;
          }
        } else {
#line 3105
          if (! opts[172]) {
            {
#line 3106
            zerr("%s: parameter not set", s);
            }
#line 3107
            return ((LinkNode )((void *)0));
          }
          {
#line 3109
          val = dupstring("");
          }
        }
      }
    } else {
#line 3049
      goto _L___35;
    }
  } else
  _L___35: /* CIL Label */ 
#line 3112
  if (inbrace) {
#line 3112
    if ((int )*s == 124) {
#line 3112
      goto _L___34;
    } else
#line 3112
    if ((int )*s == -114) {
#line 3112
      goto _L___34;
    } else
#line 3112
    if ((int )*s == 42) {
#line 3112
      goto _L___34;
    } else
#line 3112
    if ((int )*s == -121) {
      _L___34: /* CIL Label */ 
#line 3114
      if ((int )*s == 42) {
#line 3114
        tmp___49 = 1;
      } else
#line 3114
      if ((int )*s == -121) {
#line 3114
        tmp___49 = 1;
      } else {
#line 3114
        tmp___49 = 0;
      }
      {
#line 3114
      intersect = tmp___49;
#line 3116
      s ++;
#line 3117
      tmp___50 = itype_end((char const   *)s, 1 << 7, 0);
      }
#line 3117
      if (*tmp___50) {
        {
#line 3118
        untokenize(s);
#line 3119
        zerr("not an identifier: %s", s);
        }
#line 3120
        return ((LinkNode )((void *)0));
      }
      {
#line 3122
      compare = getaparam(s);
      }
#line 3123
      if (compare) {
        {
#line 3124
        tmp___51 = arrlen(compare);
#line 3124
        tmp___52 = newuniqtable((zlong )(tmp___51 + 1));
#line 3124
        ht = tmp___52;
#line 3126
        ap___0 = compare;
        }
        {
#line 3126
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 3126
          if (! *ap___0) {
#line 3126
            goto while_break___12;
          }
          {
#line 3127
          tmp___53 = zhalloc(sizeof(struct hashnode ));
#line 3127
          addhashnode2(ht, *ap___0, (void *)((HashNode )tmp___53));
#line 3126
          ap___0 ++;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
#line 3129
        if (! vunset) {
#line 3129
          if (isarr) {
#line 3130
            if (! copied) {
              {
#line 3131
              aval = arrdup(aval);
#line 3132
              copied = 1;
              }
            }
#line 3134
            apsrc = aval;
#line 3134
            ap___0 = apsrc;
            {
#line 3134
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 3134
              if (! *apsrc) {
#line 3134
                goto while_break___13;
              }
              {
#line 3135
              untokenize(*apsrc);
#line 3136
              tmp___54 = gethashnode2(ht, (char const   *)*apsrc);
#line 3136
              present = (unsigned long )tmp___54 != (unsigned long )((void *)0);
              }
#line 3137
              if (intersect) {
#line 3137
                tmp___55 = present;
              } else {
#line 3137
                tmp___55 = ! present;
              }
#line 3137
              if (tmp___55) {
#line 3138
                if ((unsigned long )ap___0 != (unsigned long )apsrc) {
#line 3139
                  *ap___0 = *apsrc;
                }
#line 3141
                ap___0 ++;
              }
#line 3134
              apsrc ++;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 3144
            *ap___0 = (char *)((void *)0);
          } else {
#line 3129
            goto _L___31;
          }
        } else
        _L___31: /* CIL Label */ 
#line 3146
        if (vunset) {
#line 3147
          if (vunset > 0) {
#line 3147
            if (! opts[172]) {
              {
#line 3148
              *idend = (char )'\000';
#line 3149
              zerr("%s: parameter not set", idbeg);
#line 3150
              deletehashtable(ht);
              }
#line 3151
              return ((LinkNode )((void *)0));
            }
          }
          {
#line 3153
          val = dupstring("");
          }
        } else {
          {
#line 3155
          tmp___56 = gethashnode2(ht, (char const   *)val);
#line 3155
          present = (unsigned long )tmp___56 != (unsigned long )((void *)0);
          }
#line 3156
          if (intersect) {
#line 3156
            tmp___57 = ! present;
          } else {
#line 3156
            tmp___57 = present;
          }
#line 3156
          if (tmp___57) {
            {
#line 3157
            val = dupstring("");
            }
          }
        }
        {
#line 3160
        deletehashtable(ht);
        }
      } else
#line 3161
      if (intersect) {
#line 3167
        if (! vunset) {
#line 3168
          if (isarr) {
            {
#line 3169
            aval = hmkarray((char *)((void *)0));
            }
          } else {
            {
#line 3171
            val = dupstring("");
            }
          }
        }
      }
#line 3175
      if (vunset) {
#line 3176
        if (vunset > 0) {
#line 3176
          if (! opts[172]) {
            {
#line 3177
            *idend = (char )'\000';
#line 3178
            zerr("%s: parameter not set", idbeg);
            }
#line 3179
            return ((LinkNode )((void *)0));
          }
        }
        {
#line 3181
        val = dupstring("");
        }
      }
    } else {
#line 3112
      goto _L___33;
    }
  } else {
    _L___33: /* CIL Label */ 
#line 3189
    if (chkset) {
#line 3190
      if (vunset) {
#line 3190
        tmp___58 = "0";
      } else {
#line 3190
        tmp___58 = "1";
      }
      {
#line 3190
      val = dupstring(tmp___58);
#line 3191
      isarr = 0;
      }
    } else
#line 3192
    if (vunset) {
#line 3193
      if (vunset > 0) {
#line 3193
        if (! opts[172]) {
          {
#line 3194
          *idend = (char )'\000';
#line 3195
          zerr("%s: parameter not set", idbeg);
          }
#line 3196
          return ((LinkNode )((void *)0));
        }
      }
      {
#line 3198
      val = dupstring("");
      }
    }
#line 3200
    if (colf) {
#line 3200
      if (inbrace) {
        {
#line 3208
        tmp___59 = check_colon_subscript(s, & check_offset2);
#line 3208
        check_offset = tmp___59;
        }
#line 3209
        if (check_offset) {
          {
#line 3210
          tmp___60 = mathevali(check_offset);
#line 3210
          offset = tmp___60;
#line 3211
          length = (zlong )0;
#line 3212
          length_set = 0;
#line 3213
          offset_hack_argzero = 0;
          }
#line 3214
          if (errflag) {
#line 3215
            return ((LinkNode )((void *)0));
          }
#line 3216
          if (*check_offset2) {
#line 3216
            if ((int )*check_offset2 != 58) {
              {
#line 3217
              zerr("invalid subscript: %s", check_offset);
              }
#line 3218
              return ((LinkNode )((void *)0));
            }
          }
#line 3220
          if (*check_offset2) {
            {
#line 3221
            check_offset = check_colon_subscript(check_offset2 + 1, & check_offset2);
            }
#line 3223
            if (*check_offset2) {
#line 3223
              if ((int )*check_offset2 != 58) {
                {
#line 3224
                zerr("invalid length: %s", check_offset);
                }
#line 3225
                return ((LinkNode )((void *)0));
              }
            }
#line 3227
            if (check_offset) {
              {
#line 3228
              length = mathevali(check_offset);
#line 3229
              length_set = 1;
              }
#line 3230
              if (errflag) {
#line 3231
                return ((LinkNode )((void *)0));
              }
            }
          }
#line 3234
          if (isarr) {
#line 3238
            if (horrible_offset_hack) {
#line 3246
              if (offset == 0L) {
#line 3247
                offset_hack_argzero = 1;
              } else
#line 3248
              if (offset > 0L) {
#line 3249
                offset --;
              }
            }
            {
#line 3253
            alen___0 = arrlen(aval);
            }
#line 3254
            if (offset < 0L) {
#line 3255
              offset += (zlong )alen___0;
#line 3256
              if (offset < 0L) {
#line 3257
                offset = (zlong )0;
              }
            }
#line 3259
            if (offset_hack_argzero) {
#line 3260
              alen___0 ++;
            }
#line 3261
            if (length_set) {
#line 3262
              if (length < 0L) {
#line 3263
                length += (zlong )alen___0 - offset;
              }
#line 3264
              if (length < 0L) {
                {
#line 3265
                zerr("substring expression: %d < %d", (int )(length + offset), (int )offset);
                }
#line 3267
                return ((LinkNode )((void *)0));
              }
            } else {
#line 3270
              length = (zlong )alen___0;
            }
#line 3271
            if (offset > (zlong )alen___0) {
#line 3272
              offset = (zlong )alen___0;
            }
#line 3273
            if (offset + length > (zlong )alen___0) {
#line 3274
              length = (zlong )alen___0 - offset;
            }
            {
#line 3275
            count = (int )length;
#line 3276
            srcptr = aval + offset;
#line 3277
            tmp___61 = zhalloc((unsigned long )(length + 1L) * sizeof(char *));
#line 3277
            dstptr = (char **)tmp___61;
#line 3277
            newarr = dstptr;
            }
#line 3279
            if (count) {
#line 3279
              if (offset_hack_argzero) {
                {
#line 3280
                tmp___62 = dstptr;
#line 3280
                dstptr ++;
#line 3280
                *tmp___62 = dupstring((char const   *)argzero);
#line 3281
                count --;
                }
              }
            }
            {
#line 3283
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 3283
              tmp___65 = count;
#line 3283
              count --;
#line 3283
              if (! tmp___65) {
#line 3283
                goto while_break___14;
              }
              {
#line 3284
              tmp___63 = dstptr;
#line 3284
              dstptr ++;
#line 3284
              tmp___64 = srcptr;
#line 3284
              srcptr ++;
#line 3284
              *tmp___63 = dupstring((char const   *)*tmp___64);
              }
            }
            while_break___14: /* CIL Label */ ;
            }
#line 3285
            *dstptr = (char *)((void *)0);
#line 3286
            aval = newarr;
          } else {
#line 3290
            if (offset < 0L) {
              {
#line 3291
              mb_charinit();
#line 3292
              sptr = val;
              }
              {
#line 3292
              while (1) {
                while_continue___15: /* CIL Label */ ;
#line 3292
                if (! *sptr) {
#line 3292
                  goto while_break___15;
                }
                {
#line 3293
                tmp___66 = mb_metacharlenconv((char const   *)sptr, (wint_t *)((void *)0));
#line 3293
                sptr += tmp___66;
#line 3294
                offset ++;
                }
              }
              while_break___15: /* CIL Label */ ;
              }
#line 3296
              if (offset < 0L) {
#line 3297
                offset = (zlong )0;
              }
            }
            {
#line 3299
            given_offset = (int )offset;
#line 3300
            mb_charinit();
            }
#line 3301
            if (length_set) {
#line 3301
              if (length < 0L) {
#line 3302
                length -= offset;
              }
            }
#line 3303
            sptr = val;
            {
#line 3303
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 3303
              if (*sptr) {
#line 3303
                if (! offset) {
#line 3303
                  goto while_break___16;
                }
              } else {
#line 3303
                goto while_break___16;
              }
              {
#line 3304
              tmp___67 = mb_metacharlenconv((char const   *)sptr, (wint_t *)((void *)0));
#line 3304
              sptr += tmp___67;
#line 3305
              offset --;
              }
            }
            while_break___16: /* CIL Label */ ;
            }
#line 3307
            if (length_set) {
#line 3308
              if (length < 0L) {
                {
#line 3309
                mb_charinit();
#line 3310
                eptr = val;
                }
                {
#line 3310
                while (1) {
                  while_continue___17: /* CIL Label */ ;
#line 3310
                  if (! *eptr) {
#line 3310
                    goto while_break___17;
                  }
                  {
#line 3311
                  tmp___68 = mb_metacharlenconv((char const   *)eptr, (wint_t *)((void *)0));
#line 3311
                  eptr += tmp___68;
#line 3312
                  length ++;
                  }
                }
                while_break___17: /* CIL Label */ ;
                }
#line 3314
                if (length < 0L) {
                  {
#line 3315
                  zerr("substring expression: %d < %d", (int )(length + (zlong )given_offset),
                       given_offset);
                  }
#line 3318
                  return ((LinkNode )((void *)0));
                }
              }
#line 3321
              eptr = sptr;
              {
#line 3321
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 3321
                if (*eptr) {
#line 3321
                  if (! length) {
#line 3321
                    goto while_break___18;
                  }
                } else {
#line 3321
                  goto while_break___18;
                }
                {
#line 3322
                tmp___69 = mb_metacharlenconv((char const   *)eptr, (wint_t *)((void *)0));
#line 3322
                eptr += tmp___69;
#line 3323
                length --;
                }
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 3325
              val = dupstrpfx((char const   *)sptr, (int )(eptr - sptr));
              }
            } else {
              {
#line 3327
              val = dupstring((char const   *)sptr);
              }
            }
          }
#line 3330
          if (! *check_offset2) {
#line 3331
            colf = 0;
          } else {
#line 3333
            s = check_offset2 + 1;
          }
        }
      }
    }
#line 3337
    if (colf) {
#line 3342
      s --;
#line 3343
      if (! opts[95]) {
#line 3343
        goto _L___32;
      } else
#line 3343
      if (inbrace) {
        _L___32: /* CIL Label */ 
#line 3344
        if (! isarr) {
          {
#line 3345
          modify(& val, & s);
          }
        } else {
          {
#line 3348
          ap___1 = aval;
#line 3349
          tmp___70 = arrlen(aval);
#line 3349
          tmp___71 = hcalloc(sizeof(char *) * (unsigned long )(tmp___70 + 1));
#line 3349
          aval = (char **)tmp___71;
#line 3349
          pp = aval;
          }
          {
#line 3352
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 3352
            tmp___74 = ap___1;
#line 3352
            ap___1 ++;
#line 3352
            tmp___73 = *tmp___74;
#line 3352
            *pp = tmp___73;
#line 3352
            if (! tmp___73) {
#line 3352
              goto while_break___19;
            }
            {
#line 3353
            ss = s;
#line 3354
            tmp___72 = pp;
#line 3354
            pp ++;
#line 3354
            modify(tmp___72, & ss);
            }
          }
          while_break___19: /* CIL Label */ ;
          }
#line 3356
          if ((unsigned long )pp == (unsigned long )aval) {
            {
#line 3357
            t___1 = (char *)"";
#line 3358
            ss = s;
#line 3359
            modify(& t___1, & ss);
            }
          }
#line 3361
          s = ss;
        }
#line 3363
        copied = 1;
#line 3364
        if (inbrace) {
#line 3364
          if (*s) {
#line 3365
            if ((int )*s == 58) {
#line 3365
              if (! ((int )typtab[(unsigned char )*(s + 1)] & (1 << 12))) {
                {
#line 3366
                zerr("unrecognized modifier `%c\'", (int )*(s + 1));
                }
              } else {
                {
#line 3368
                zerr("unrecognized modifier");
                }
              }
            } else {
              {
#line 3368
              zerr("unrecognized modifier");
              }
            }
#line 3369
            return ((LinkNode )((void *)0));
          }
        }
      }
    }
#line 3373
    if (! inbrace) {
#line 3374
      fstr___0 = s;
    }
  }
#line 3376
  if (errflag) {
#line 3377
    return ((LinkNode )((void *)0));
  }
#line 3378
  if (evalchar) {
#line 3379
    one___0 = noerrs;
#line 3379
    oef___0 = errflag;
#line 3379
    haserr___0 = 0;
#line 3381
    if (! quoteerr) {
#line 3382
      noerrs = 1;
    }
#line 3387
    if (isarr) {
      {
#line 3390
      tmp___75 = arrlen(aval);
#line 3390
      tmp___76 = zhalloc((unsigned long )(tmp___75 + 1) * sizeof(char *));
#line 3390
      aval2 = (char **)tmp___76;
#line 3392
      avptr = aval;
#line 3392
      av2ptr = aval2;
      }
      {
#line 3392
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 3392
        if (! *avptr) {
#line 3392
          goto while_break___20;
        }
        {
#line 3395
        tmp___77 = substevalchar(*avptr);
#line 3395
        *av2ptr = tmp___77;
        }
#line 3395
        if (! tmp___77) {
#line 3396
          haserr___0 = 1;
#line 3397
          goto while_break___20;
        }
#line 3392
        avptr ++;
#line 3392
        av2ptr ++;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 3400
      *av2ptr = (char *)((void *)0);
#line 3401
      aval = aval2;
    } else {
      {
#line 3404
      val = substevalchar(val);
      }
#line 3404
      if (! val) {
#line 3405
        haserr___0 = 1;
      }
    }
#line 3407
    noerrs = one___0;
#line 3408
    if (! quoteerr) {
#line 3410
      errflag = oef___0 | (errflag & 2);
    }
#line 3412
    if (haserr___0) {
#line 3413
      return ((LinkNode )((void *)0));
    } else
#line 3412
    if (errflag) {
#line 3413
      return ((LinkNode )((void *)0));
    }
#line 3414
    ms_flags = 0;
  }
#line 3423
  if (getlen) {
#line 3424
    len = 0L;
#line 3427
    if (isarr) {
#line 3429
      if (sep) {
        {
#line 3429
        tmp___78 = mb_metastrlenend(sep, 0, (char *)((void *)0));
#line 3429
        tmp___79 = tmp___78;
        }
      } else {
#line 3429
        tmp___79 = 1;
      }
#line 3429
      sl = tmp___79;
#line 3431
      if (getlen == 1) {
#line 3432
        ctr = aval;
        {
#line 3432
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 3432
          if (! *ctr) {
#line 3432
            goto while_break___21;
          }
#line 3432
          ctr ++;
#line 3432
          len ++;
        }
        while_break___21: /* CIL Label */ ;
        }
      } else
#line 3433
      if (getlen == 2) {
#line 3434
        if (*aval) {
#line 3435
          len = (long )(- sl);
#line 3435
          ctr = aval;
          {
#line 3435
          while (1) {
            while_continue___22: /* CIL Label */ ;
            {
#line 3435
            tmp___80 = mb_metastrlenend(*ctr, multi_width, (char *)((void *)0));
#line 3435
            len += (long )(sl + tmp___80);
#line 3435
            ctr ++;
            }
#line 3435
            if (! *ctr) {
#line 3435
              goto while_break___22;
            }
          }
          while_break___22: /* CIL Label */ ;
          }
        }
      } else {
#line 3440
        ctr = aval;
        {
#line 3440
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 3440
          if (! *ctr) {
#line 3440
            goto while_break___23;
          }
          {
#line 3440
          tmp___81 = wordcount(*ctr, spsep, getlen > 3);
#line 3440
          len += (long )tmp___81;
#line 3440
          ctr ++;
          }
        }
        while_break___23: /* CIL Label */ ;
        }
      }
    } else
#line 3444
    if (getlen < 3) {
      {
#line 3445
      tmp___82 = mb_metastrlenend(val, multi_width, (char *)((void *)0));
#line 3445
      len = (long )tmp___82;
      }
    } else {
      {
#line 3447
      tmp___83 = wordcount(val, spsep, getlen > 3);
#line 3447
      len = (long )tmp___83;
      }
    }
    {
#line 3450
    sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%ld",
            len);
#line 3451
    val = dupstring((char const   *)(buf___7));
#line 3452
    isarr = 0;
#line 3453
    ms_flags = 0;
    }
  }
#line 3459
  if (isarr) {
#line 3460
    l->list.flags |= 1;
  } else {
#line 3462
    l->list.flags &= -2;
  }
#line 3463
  if (isarr > 0) {
#line 3463
    if (! plan9) {
#line 3463
      if (! aval) {
        {
#line 3464
        val = dupstring("");
#line 3465
        isarr = 0;
        }
      } else
#line 3463
      if (! *(aval + 0)) {
        {
#line 3464
        val = dupstring("");
#line 3465
        isarr = 0;
        }
      } else {
#line 3463
        goto _L___40;
      }
    } else {
#line 3463
      goto _L___40;
    }
  } else
  _L___40: /* CIL Label */ 
#line 3466
  if (isarr) {
#line 3466
    if (aval) {
#line 3466
      if (*(aval + 0)) {
#line 3466
        if (! *(aval + 1)) {
#line 3471
          val = *(aval + 0);
#line 3472
          isarr = 0;
        }
      }
    }
  }
#line 3479
  if (ssub) {
#line 3479
    goto _L___42;
  } else
#line 3479
  if (spbreak) {
#line 3479
    goto _L___42;
  } else
#line 3479
  if (spsep) {
#line 3479
    goto _L___42;
  } else
#line 3479
  if (sep) {
    _L___42: /* CIL Label */ 
#line 3480
    if (! ssub) {
#line 3480
      if (spbreak) {
#line 3480
        tmp___84 = 1;
      } else
#line 3480
      if (spsep) {
#line 3480
        tmp___84 = 1;
      } else {
#line 3480
        tmp___84 = 0;
      }
    } else {
#line 3480
      tmp___84 = 0;
    }
#line 3480
    force_split = tmp___84;
#line 3481
    if (isarr) {
#line 3483
      if (nojoin == 0) {
        {
#line 3484
        val = sepjoin(aval, sep, 1);
#line 3485
        isarr = 0;
        }
      } else
#line 3483
      if (sep) {
        {
#line 3484
        val = sepjoin(aval, sep, 1);
#line 3485
        isarr = 0;
        }
      } else
#line 3486
      if (force_split) {
#line 3486
        if (spsep) {
#line 3486
          goto _L___41;
        } else
#line 3486
        if (nojoin == 2) {
#line 3486
          goto _L___41;
        } else
#line 3486
        if (! ifs) {
#line 3486
          if (isarr < 0) {
            _L___41: /* CIL Label */ 
#line 3492
            if (nojoin == 1) {
#line 3492
              tmp___85 = (char *)((void *)0);
            } else {
#line 3492
              tmp___85 = spsep;
            }
            {
#line 3492
            val = sepjoin(aval, tmp___85, 1);
#line 3493
            isarr = 0;
            }
          }
        }
      }
#line 3495
      if (! isarr) {
#line 3496
        ms_flags = 0;
      }
    }
#line 3498
    if (force_split) {
#line 3498
      if (! isarr) {
        {
#line 3499
        aval = sepsplit(val, spsep, 0, 1);
        }
#line 3500
        if (! aval) {
          {
#line 3501
          val = dupstring("");
          }
        } else
#line 3500
        if (! *(aval + 0)) {
          {
#line 3501
          val = dupstring("");
          }
        } else
#line 3502
        if (! *(aval + 1)) {
#line 3503
          val = *(aval + 0);
        } else
#line 3505
        if (nojoin) {
#line 3505
          isarr = 1;
        } else {
#line 3505
          isarr = 2;
        }
      }
    }
#line 3507
    if (isarr) {
#line 3508
      l->list.flags |= 1;
    } else {
#line 3510
      l->list.flags &= -2;
    }
  }
#line 3515
  if (casmod != 0) {
#line 3516
    copied = 1;
#line 3517
    if (isarr) {
      {
#line 3520
      ap___2 = aval;
#line 3521
      tmp___86 = arrlen(aval);
#line 3521
      tmp___87 = zhalloc(sizeof(char *) * (unsigned long )(tmp___86 + 1));
#line 3521
      aval = (char **)tmp___87;
#line 3521
      ap2 = aval;
      }
      {
#line 3523
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 3523
        if (! *ap___2) {
#line 3523
          goto while_break___24;
        }
        {
#line 3524
        tmp___88 = ap2;
#line 3524
        ap2 ++;
#line 3524
        tmp___89 = ap___2;
#line 3524
        ap___2 ++;
#line 3524
        *tmp___88 = casemodify(*tmp___89, casmod);
        }
      }
      while_break___24: /* CIL Label */ ;
      }
#line 3525
      tmp___90 = ap2;
#line 3525
      ap2 ++;
#line 3525
      *tmp___90 = (char *)((void *)0);
    } else {
      {
#line 3527
      val = casemodify(val, casmod);
      }
    }
  }
#line 3533
  if (getkeys >= 0) {
#line 3536
    copied = 1;
#line 3537
    if (isarr) {
      {
#line 3540
      ap___3 = aval;
#line 3541
      tmp___91 = arrlen(aval);
#line 3541
      tmp___92 = zhalloc(sizeof(char *) * (unsigned long )(tmp___91 + 1));
#line 3541
      aval = (char **)tmp___92;
#line 3542
      ap2___0 = aval;
      }
      {
#line 3542
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 3542
        if (! *ap___3) {
#line 3542
          goto while_break___25;
        }
        {
#line 3543
        *ap2___0 = getkeystring(*ap___3, & len___0, getkeys, (int *)((void *)0));
#line 3544
        *ap2___0 = metafy(*ap2___0, len___0, 1);
#line 3542
        ap___3 ++;
#line 3542
        ap2___0 ++;
        }
      }
      while_break___25: /* CIL Label */ ;
      }
#line 3546
      tmp___93 = ap2___0;
#line 3546
      ap2___0 ++;
#line 3546
      *tmp___93 = (char *)((void *)0);
    } else {
      {
#line 3548
      val = getkeystring(val, & len___0, getkeys, (int *)((void *)0));
#line 3549
      val = metafy(val, len___0, 1);
      }
    }
  }
#line 3555
  if (presc) {
#line 3556
    ops = (int )opts[144];
#line 3556
    opb = (int )opts[140];
#line 3557
    opp = (int )opts[142];
#line 3559
    if (presc < 2) {
#line 3560
      opts[142] = (char)1;
#line 3561
      opts[140] = (char)0;
#line 3561
      opts[144] = opts[140];
    }
#line 3571
    if (isarr) {
#line 3574
      if (! copied) {
        {
#line 3575
        aval = arrdup(aval);
#line 3575
        copied = 1;
        }
      }
#line 3576
      ap___4 = aval;
      {
#line 3577
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 3577
        if (! *ap___4) {
#line 3577
          goto while_break___26;
        }
        {
#line 3579
        untokenize(*ap___4);
#line 3580
        tmps = promptexpand(*ap___4, 0, (char *)((void *)0), (char *)((void *)0),
                            (unsigned int *)((void *)0));
#line 3581
        *ap___4 = dupstring((char const   *)tmps);
#line 3582
        free((void *)tmps);
#line 3577
        ap___4 ++;
        }
      }
      while_break___26: /* CIL Label */ ;
      }
    } else {
#line 3586
      if (! copied) {
        {
#line 3587
        val = dupstring((char const   *)val);
#line 3587
        copied = 1;
        }
      }
      {
#line 3588
      untokenize(val);
#line 3589
      tmps___0 = promptexpand(val, 0, (char *)((void *)0), (char *)((void *)0), (unsigned int *)((void *)0));
#line 3590
      val = dupstring((char const   *)tmps___0);
#line 3591
      free((void *)tmps___0);
      }
    }
#line 3593
    opts[144] = (char )ops;
#line 3594
    opts[140] = (char )opb;
#line 3595
    opts[142] = (char )opp;
  }
#line 3601
  if (quotemod) {
#line 3602
    pre = 0;
#line 3602
    post = 0;
#line 3604
    if (quotemod > 0) {
      {
#line 3607
      if (quotetype == 4) {
#line 3607
        goto case_4;
      }
#line 3616
      if (quotetype == 7) {
#line 3616
        goto case_7;
      }
#line 3616
      if (quotetype == 1) {
#line 3616
        goto case_7;
      }
#line 3616
      if (quotetype == 6) {
#line 3616
        goto case_7;
      }
#line 3620
      goto switch_default___4;
      case_4: /* CIL Label */ 
#line 3609
      pre = 2;
#line 3610
      post = 1;
#line 3611
      goto switch_break___6;
      case_7: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
      case_6: /* CIL Label */ 
#line 3618
      goto switch_break___6;
      switch_default___4: /* CIL Label */ 
#line 3621
      post = 1;
#line 3621
      pre = post;
#line 3622
      goto switch_break___6;
      switch_break___6: /* CIL Label */ ;
      }
    }
#line 3625
    if (isarr) {
#line 3628
      if (! copied) {
        {
#line 3629
        aval = arrdup(aval);
#line 3629
        copied = 1;
        }
      }
#line 3630
      ap___5 = aval;
#line 3632
      if (quotemod > 0) {
#line 3633
        if (quotetype == 9) {
          {
#line 3634
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 3634
            if (! *ap___5) {
#line 3634
              goto while_break___27;
            }
            {
#line 3635
            *ap___5 = quotedzputs((char const   *)*ap___5, (FILE *)((void *)0));
#line 3634
            ap___5 ++;
            }
          }
          while_break___27: /* CIL Label */ ;
          }
        } else
#line 3636
        if (quotetype > 1) {
          {
#line 3640
          while (1) {
            while_continue___28: /* CIL Label */ ;
#line 3640
            if (! *ap___5) {
#line 3640
              goto while_break___28;
            }
            {
#line 3641
            tmp___94 = quotestring((char const   *)*ap___5, quotetype);
#line 3642
            tmp___95 = strlen((char const   *)tmp___94);
#line 3642
            sl___0 = (int )tmp___95;
#line 3643
            tmp___96 = zhalloc((size_t )(((pre + sl___0) + post) + 1));
#line 3643
            *ap___5 = (char *)tmp___96;
#line 3644
            strcpy((char */* __restrict  */)(*ap___5 + pre), (char const   */* __restrict  */)tmp___94);
            }
#line 3645
            if (pre) {
#line 3646
              if (quotetype != 3) {
#line 3646
                tmp___97 = (char )'\'';
              } else {
#line 3646
                tmp___97 = (char )'\"';
              }
#line 3646
              *(*(ap___5 + 0) + (pre + sl___0)) = tmp___97;
#line 3646
              *(*(ap___5 + 0) + (pre - 1)) = tmp___97;
            }
#line 3648
            *(*(ap___5 + 0) + ((pre + sl___0) + post)) = (char )'\000';
#line 3649
            if (quotetype == 4) {
#line 3650
              *(*(ap___5 + 0) + 0) = (char )'$';
            }
#line 3640
            ap___5 ++;
          }
          while_break___28: /* CIL Label */ ;
          }
        } else {
          {
#line 3653
          while (1) {
            while_continue___29: /* CIL Label */ ;
#line 3653
            if (! *ap___5) {
#line 3653
              goto while_break___29;
            }
            {
#line 3654
            *ap___5 = quotestring((char const   *)*ap___5, 8);
#line 3653
            ap___5 ++;
            }
          }
          while_break___29: /* CIL Label */ ;
          }
        }
      } else {
#line 3656
        one___1 = noerrs;
#line 3656
        oef___1 = errflag;
#line 3656
        haserr___1 = 0;
#line 3658
        if (! quoteerr) {
#line 3659
          noerrs = 1;
        }
        {
#line 3660
        while (1) {
          while_continue___30: /* CIL Label */ ;
#line 3660
          if (! *ap___5) {
#line 3660
            goto while_break___30;
          }
          {
#line 3661
          tmp___98 = parse_subst_string(*ap___5);
#line 3661
          haserr___1 |= tmp___98;
#line 3662
          remnulargs(*ap___5);
#line 3663
          untokenize(*ap___5);
#line 3660
          ap___5 ++;
          }
        }
        while_break___30: /* CIL Label */ ;
        }
#line 3665
        noerrs = one___1;
#line 3666
        if (! quoteerr) {
#line 3668
          errflag = oef___1 | (errflag & 2);
        } else
#line 3670
        if (haserr___1) {
          {
#line 3671
          zerr("parse error in parameter value");
          }
#line 3672
          return ((LinkNode )((void *)0));
        } else
#line 3670
        if (errflag) {
          {
#line 3671
          zerr("parse error in parameter value");
          }
#line 3672
          return ((LinkNode )((void *)0));
        }
      }
    } else {
#line 3676
      if (! copied) {
        {
#line 3677
        val = dupstring((char const   *)val);
#line 3677
        copied = 1;
        }
      }
#line 3678
      if (quotemod > 0) {
#line 3679
        if (quotetype == 9) {
          {
#line 3680
          val = quotedzputs((char const   *)val, (FILE *)((void *)0));
          }
        } else
#line 3681
        if (quotetype > 1) {
          {
#line 3684
          tmp___99 = quotestring((char const   *)val, quotetype);
#line 3685
          tmp___100 = strlen((char const   *)tmp___99);
#line 3685
          sl___1 = (int )tmp___100;
#line 3686
          tmp___101 = zhalloc((size_t )(((pre + sl___1) + post) + 1));
#line 3686
          val = (char *)tmp___101;
#line 3687
          strcpy((char */* __restrict  */)(val + pre), (char const   */* __restrict  */)tmp___99);
          }
#line 3688
          if (pre) {
#line 3689
            if (quotetype != 3) {
#line 3689
              tmp___102 = (char )'\'';
            } else {
#line 3689
              tmp___102 = (char )'\"';
            }
#line 3689
            *(val + (pre + sl___1)) = tmp___102;
#line 3689
            *(val + (pre - 1)) = tmp___102;
          }
#line 3691
          *(val + ((pre + sl___1) + post)) = (char )'\000';
#line 3692
          if (quotetype == 4) {
#line 3693
            *(val + 0) = (char )'$';
          }
        } else {
          {
#line 3695
          val = quotestring((char const   *)val, 8);
          }
        }
      } else {
#line 3697
        one___2 = noerrs;
#line 3697
        oef___2 = errflag;
#line 3699
        if (! quoteerr) {
#line 3700
          noerrs = 1;
        }
        {
#line 3701
        haserr___2 = parse_subst_string(val);
#line 3702
        noerrs = one___2;
        }
#line 3703
        if (! quoteerr) {
#line 3705
          errflag = oef___2 | (errflag & 2);
        } else
#line 3707
        if (haserr___2) {
          {
#line 3708
          zerr("parse error in parameter value");
          }
#line 3709
          return ((LinkNode )((void *)0));
        } else
#line 3707
        if (errflag) {
          {
#line 3708
          zerr("parse error in parameter value");
          }
#line 3709
          return ((LinkNode )((void *)0));
        }
        {
#line 3711
        remnulargs(val);
#line 3712
        untokenize(val);
        }
      }
    }
  }
#line 3720
  if (mods) {
#line 3721
    if (isarr) {
#line 3723
      if (! copied) {
        {
#line 3724
        aval = arrdup(aval);
#line 3724
        copied = 1;
        }
      }
#line 3725
      ap___6 = aval;
      {
#line 3725
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 3725
        if (! *ap___6) {
#line 3725
          goto while_break___31;
        }
#line 3726
        if (mods & 1) {
          {
#line 3727
          *ap___6 = substnamedir(*ap___6);
          }
        }
#line 3728
        if (mods & 2) {
          {
#line 3729
          *ap___6 = nicedupstring((char const   *)*ap___6);
          }
        }
#line 3725
        ap___6 ++;
      }
      while_break___31: /* CIL Label */ ;
      }
    } else {
#line 3732
      if (! copied) {
        {
#line 3733
        val = dupstring((char const   *)val);
#line 3733
        copied = 1;
        }
      }
#line 3734
      if (mods & 1) {
        {
#line 3735
        val = substnamedir(val);
        }
      }
#line 3736
      if (mods & 2) {
        {
#line 3737
        val = nicedupstring((char const   *)val);
        }
      }
    }
  }
#line 3745
  if (shsplit) {
#line 3746
    list = (LinkList )((void *)0);
#line 3748
    if (isarr) {
#line 3750
      ap___7 = aval;
      {
#line 3750
      while (1) {
        while_continue___32: /* CIL Label */ ;
#line 3750
        if (! *ap___7) {
#line 3750
          goto while_break___32;
        }
        {
#line 3751
        list = bufferwords(list, *ap___7, (int *)((void *)0), shsplit);
#line 3750
        ap___7 ++;
        }
      }
      while_break___32: /* CIL Label */ ;
      }
#line 3752
      isarr = 0;
    } else {
      {
#line 3754
      list = bufferwords((LinkList )((void *)0), val, (int *)((void *)0), shsplit);
      }
    }
#line 3756
    if (! list) {
      {
#line 3757
      val = dupstring("");
      }
    } else
#line 3756
    if (! list->list.first) {
      {
#line 3757
      val = dupstring("");
      }
    } else
#line 3758
    if (! (list->list.first)->next) {
#line 3759
      val = (char *)(list->list.first)->dat;
    } else {
      {
#line 3761
      aval = hlinklist2array(list, 0);
      }
#line 3762
      if (nojoin) {
#line 3762
        isarr = 1;
      } else {
#line 3762
        isarr = 2;
      }
#line 3763
      l->list.flags |= 1;
    }
#line 3765
    copied = 1;
  }
#line 3782
  if (isarr) {
#line 3782
    if (ssub) {
      {
#line 3784
      val = sepjoin(aval, (char *)((void *)0), 1);
#line 3785
      isarr = 0;
#line 3786
      l->list.flags &= -2;
      }
    }
  }
#line 3793
  if (ms_flags & 1) {
#line 3793
    if ((unsigned long )aptr > (unsigned long )ostr) {
      {
#line 3794
      tmp___103 = dupstrpfx((char const   *)ostr, (int )(aptr - ostr));
#line 3794
      insertlinknode(l, n, (void *)tmp___103);
#line 3794
      n = n->next;
#line 3795
      ostr = aptr;
      }
    }
  }
#line 3798
  if (ms_flags & 2) {
#line 3798
    if (*fstr___0) {
      {
#line 3799
      tmp___104 = dupstring((char const   *)fstr___0);
#line 3799
      insertlinknode(l, n, (void *)tmp___104);
#line 3800
      *fstr___0 = (char )'\000';
      }
    }
  }
#line 3802
  if (arrasg) {
#line 3802
    if (! isarr) {
      {
#line 3807
      l->list.flags |= 1;
#line 3808
      aval = hmkarray(val);
#line 3809
      isarr = 1;
      }
    }
  }
#line 3812
  if (isarr) {
#line 3817
    on = n;
#line 3820
    if (unique) {
#line 3821
      if (! copied) {
        {
#line 3822
        aval = arrdup(aval);
        }
      }
      {
#line 3824
      i___0 = arrlen(aval);
      }
#line 3825
      if (i___0 > 1) {
        {
#line 3826
        zhuniqarray(aval);
        }
      }
    }
#line 3828
    if (! *(aval + 0)) {
#line 3828
      goto _L___43;
    } else
#line 3828
    if (! *(aval + 1)) {
      _L___43: /* CIL Label */ 
#line 3828
      if (! plan9) {
#line 3840
        if ((unsigned long )aptr > (unsigned long )((char *)n->dat)) {
#line 3840
          if ((int )*(aptr + -1) == -98) {
#line 3840
            if ((int )*fstr___0 == -98) {
#line 3842
              aptr --;
#line 3842
              *aptr = (char )'\000';
#line 3842
              fstr___0 ++;
            }
          }
        }
#line 3843
        if (*(aval + 0)) {
          {
#line 3843
          tmp___105 = strlen((char const   *)*(aval + 0));
#line 3843
          vallen = (int )tmp___105;
          }
        } else {
#line 3843
          vallen = 0;
        }
        {
#line 3844
        tmp___106 = strlen((char const   *)fstr___0);
#line 3844
        tmp___107 = hcalloc(((size_t )((aptr - ostr) + (long )vallen) + tmp___106) + 1UL);
#line 3844
        y = (char *)tmp___107;
#line 3845
        strcpy((char */* __restrict  */)y, (char const   */* __restrict  */)ostr);
#line 3846
        *str = y + (aptr - ostr);
        }
#line 3847
        if (vallen) {
          {
#line 3849
          strcpy((char */* __restrict  */)*str, (char const   */* __restrict  */)*(aval + 0));
#line 3850
          *str += vallen;
          }
        }
        {
#line 3852
        strcpy((char */* __restrict  */)*str, (char const   */* __restrict  */)fstr___0);
#line 3853
        n->dat = (void *)y;
        }
#line 3854
        return (n);
      }
    }
#line 3857
    if (sortit != 0) {
#line 3858
      if (! copied) {
        {
#line 3859
        aval = arrdup(aval);
        }
      }
#line 3860
      if (indord) {
#line 3861
        if (sortit & 4) {
          {
#line 3863
          tmp___108 = arrlen(aval);
#line 3863
          end = (aval + tmp___108) - 1;
#line 3863
          start = aval;
          }
          {
#line 3866
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 3866
            if (! ((unsigned long )start < (unsigned long )end)) {
#line 3866
              goto while_break___33;
            }
#line 3867
            copy = *end;
#line 3868
            tmp___109 = end;
#line 3868
            end --;
#line 3868
            *tmp___109 = *start;
#line 3869
            tmp___110 = start;
#line 3869
            start ++;
#line 3869
            *tmp___110 = copy;
          }
          while_break___33: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 3880
        strmetasort(aval, sortit, (int *)((void *)0));
        }
      }
    }
#line 3883
    if (plan9) {
#line 3888
      fstr___0 --;
#line 3888
      *fstr___0 = (char)-94;
      {
#line 3889
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 3889
        tl.list.first = & __n0;
#line 3889
        tl.list.last = & __n0;
#line 3889
        tl.list.flags = 0;
#line 3889
        __n0.next = (LinkNode )((void *)0);
#line 3889
        __n0.prev = & tl.node;
#line 3889
        __n0.dat = (void *)fstr___0;
#line 3889
        goto while_break___34;
      }
      while_break___34: /* CIL Label */ ;
      }
#line 3890
      if (! eval___0) {
        {
#line 3890
        tmp___111 = stringsubst(& tl, tl.list.first, ssub, ret_flags, 0);
        }
#line 3890
        if (! tmp___111) {
#line 3891
          return ((LinkNode )((void *)0));
        }
      }
#line 3892
      *str = aptr;
#line 3893
      tn = tl.list.first;
      {
#line 3894
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 3894
        tmp___115 = aval;
#line 3894
        aval ++;
#line 3894
        x = *tmp___115;
#line 3894
        if (! x) {
#line 3894
          goto while_break___35;
        }
#line 3895
        if (prenum) {
          {
#line 3896
          x = dopadding(x, (int )prenum, (int )postnum, preone, postone, premul, postmul,
                        multi_width);
          }
        } else
#line 3895
        if (postnum) {
          {
#line 3896
          x = dopadding(x, (int )prenum, (int )postnum, preone, postone, premul, postmul,
                        multi_width);
          }
        }
#line 3902
        if (eval___0) {
#line 3902
          if (qt) {
#line 3902
            if (! nojoin) {
#line 3902
              tmp___112 = 1;
            } else {
#line 3902
              tmp___112 = 0;
            }
          } else {
#line 3902
            tmp___112 = 0;
          }
          {
#line 3902
          tmp___113 = subst_parse_str(& x, tmp___112, quoteerr);
          }
#line 3902
          if (tmp___113) {
#line 3903
            return ((LinkNode )((void *)0));
          }
        }
        {
#line 3904
        tmp___114 = strlen((char const   *)x);
#line 3904
        xlen = (int )tmp___114;
#line 3905
        tn = tl.list.first;
        }
        {
#line 3905
        while (1) {
          while_continue___36: /* CIL Label */ ;
#line 3905
          if (tn) {
#line 3905
            y = (char *)tn->dat;
#line 3905
            if (! ((int )*y == -94)) {
#line 3905
              goto while_break___36;
            }
          } else {
#line 3905
            goto while_break___36;
          }
          {
#line 3908
          strcatsub(& y, ostr, aptr, x, xlen, y + 1, globsubst, copied);
          }
#line 3910
          if (qt) {
#line 3910
            if (! *y) {
#line 3910
              if (isarr != 2) {
                {
#line 3911
                y = dupstring((char const   *)(nulstring));
                }
              }
            }
          }
#line 3912
          if (plan9) {
#line 3913
            n->dat = (void *)y;
#line 3913
            plan9 = 0;
          } else {
            {
#line 3915
            insertlinknode(l, n, (void *)y);
#line 3915
            n = n->next;
            }
          }
#line 3905
          tn = tn->next;
        }
        while_break___36: /* CIL Label */ ;
        }
      }
      while_break___35: /* CIL Label */ ;
      }
      {
#line 3918
      while (1) {
        while_continue___37: /* CIL Label */ ;
#line 3918
        if (! tn) {
#line 3918
          goto while_break___37;
        }
#line 3919
        y = (char *)tn->dat;
#line 3920
        if ((int )*y == -94) {
#line 3921
          goto __Cont;
        }
#line 3922
        if (qt) {
#line 3922
          if (! *y) {
#line 3922
            if (isarr != 2) {
              {
#line 3923
              y = dupstring((char const   *)(nulstring));
              }
            }
          }
        }
#line 3924
        if (plan9) {
#line 3925
          n->dat = (void *)y;
#line 3925
          plan9 = 0;
        } else {
          {
#line 3927
          insertlinknode(l, n, (void *)y);
#line 3927
          n = n->next;
          }
        }
        __Cont: /* CIL Label */ 
#line 3918
        tn = tn->next;
      }
      while_break___37: /* CIL Label */ ;
      }
#line 3929
      if (plan9) {
        {
#line 3930
        uremnode(l, n);
        }
#line 3931
        return (n);
      }
    } else {
#line 3942
      x = *(aval + 0);
#line 3943
      if (prenum) {
        {
#line 3944
        x = dopadding(x, (int )prenum, (int )postnum, preone, postone, premul, postmul,
                      multi_width);
        }
      } else
#line 3943
      if (postnum) {
        {
#line 3944
        x = dopadding(x, (int )prenum, (int )postnum, preone, postone, premul, postmul,
                      multi_width);
        }
      }
#line 3950
      if (eval___0) {
#line 3950
        if (qt) {
#line 3950
          if (! nojoin) {
#line 3950
            tmp___116 = 1;
          } else {
#line 3950
            tmp___116 = 0;
          }
        } else {
#line 3950
          tmp___116 = 0;
        }
        {
#line 3950
        tmp___117 = subst_parse_str(& x, tmp___116, quoteerr);
        }
#line 3950
        if (tmp___117) {
#line 3951
          return ((LinkNode )((void *)0));
        }
      }
      {
#line 3952
      tmp___118 = strlen((char const   *)x);
#line 3952
      xlen = (int )tmp___118;
#line 3953
      strcatsub(& y, ostr, aptr, x, xlen, (char *)((void *)0), globsubst, copied);
      }
#line 3954
      if (qt) {
#line 3954
        if (! *y) {
#line 3954
          if (isarr != 2) {
            {
#line 3955
            y = dupstring((char const   *)(nulstring));
            }
          }
        }
      }
#line 3956
      n->dat = (void *)y;
#line 3958
      i___0 = 1;
      {
#line 3960
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 3960
        if (! *(aval + (i___0 + 1))) {
#line 3960
          goto while_break___38;
        }
#line 3961
        tmp___119 = i___0;
#line 3961
        i___0 ++;
#line 3961
        x = *(aval + tmp___119);
#line 3962
        if (prenum) {
          {
#line 3963
          x = dopadding(x, (int )prenum, (int )postnum, preone, postone, premul, postmul,
                        multi_width);
          }
        } else
#line 3962
        if (postnum) {
          {
#line 3963
          x = dopadding(x, (int )prenum, (int )postnum, preone, postone, premul, postmul,
                        multi_width);
          }
        }
#line 3969
        if (eval___0) {
#line 3969
          if (qt) {
#line 3969
            if (! nojoin) {
#line 3969
              tmp___120 = 1;
            } else {
#line 3969
              tmp___120 = 0;
            }
          } else {
#line 3969
            tmp___120 = 0;
          }
          {
#line 3969
          tmp___121 = subst_parse_str(& x, tmp___120, quoteerr);
          }
#line 3969
          if (tmp___121) {
#line 3970
            return ((LinkNode )((void *)0));
          }
        }
#line 3971
        if (qt) {
#line 3971
          if (! *x) {
#line 3971
            if (isarr != 2) {
              {
#line 3972
              y = dupstring((char const   *)(nulstring));
              }
            } else {
#line 3971
              goto _L___45;
            }
          } else {
#line 3971
            goto _L___45;
          }
        } else {
          _L___45: /* CIL Label */ 
          {
#line 3974
          y = dupstring((char const   *)x);
          }
#line 3975
          if (globsubst) {
            {
#line 3976
            shtokenize(y);
            }
          }
        }
        {
#line 3978
        insertlinknode(l, n, (void *)y);
#line 3978
        n = n->next;
        }
      }
      while_break___38: /* CIL Label */ ;
      }
#line 3981
      x = *(aval + i___0);
#line 3982
      if (prenum) {
        {
#line 3983
        x = dopadding(x, (int )prenum, (int )postnum, preone, postone, premul, postmul,
                      multi_width);
        }
      } else
#line 3982
      if (postnum) {
        {
#line 3983
        x = dopadding(x, (int )prenum, (int )postnum, preone, postone, premul, postmul,
                      multi_width);
        }
      }
#line 3989
      if (eval___0) {
#line 3989
        if (qt) {
#line 3989
          if (! nojoin) {
#line 3989
            tmp___122 = 1;
          } else {
#line 3989
            tmp___122 = 0;
          }
        } else {
#line 3989
          tmp___122 = 0;
        }
        {
#line 3989
        tmp___123 = subst_parse_str(& x, tmp___122, quoteerr);
        }
#line 3989
        if (tmp___123) {
#line 3990
          return ((LinkNode )((void *)0));
        }
      }
      {
#line 3991
      tmp___124 = strlen((char const   *)x);
#line 3991
      xlen = (int )tmp___124;
#line 3992
      *str = strcatsub(& y, aptr, aptr, x, xlen, fstr___0, globsubst, copied);
      }
#line 3993
      if (qt) {
#line 3993
        if (! *y) {
#line 3993
          if (isarr != 2) {
            {
#line 3994
            y = dupstring((char const   *)(nulstring));
            }
          }
        }
      }
      {
#line 3995
      insertlinknode(l, n, (void *)y);
#line 3995
      n = n->next;
      }
    }
#line 4004
    n = on;
#line 4004
    *str = (char *)n->dat;
  } else {
#line 4015
    x___0 = val;
#line 4016
    if (! x___0) {
#line 4019
      return ((LinkNode )((void *)0));
    }
#line 4021
    if (prenum) {
      {
#line 4022
      x___0 = dopadding(x___0, (int )prenum, (int )postnum, preone, postone, premul,
                        postmul, multi_width);
      }
    } else
#line 4021
    if (postnum) {
      {
#line 4022
      x___0 = dopadding(x___0, (int )prenum, (int )postnum, preone, postone, premul,
                        postmul, multi_width);
      }
    }
#line 4028
    if (eval___0) {
#line 4028
      if (qt) {
#line 4028
        if (! nojoin) {
#line 4028
          tmp___125 = 1;
        } else {
#line 4028
          tmp___125 = 0;
        }
      } else {
#line 4028
        tmp___125 = 0;
      }
      {
#line 4028
      tmp___126 = subst_parse_str(& x___0, tmp___125, quoteerr);
      }
#line 4028
      if (tmp___126) {
#line 4029
        return ((LinkNode )((void *)0));
      }
    }
    {
#line 4030
    tmp___127 = strlen((char const   *)x___0);
#line 4030
    xlen___0 = (int )tmp___127;
#line 4031
    *str = strcatsub(& y___0, ostr, aptr, x___0, xlen___0, fstr___0, globsubst, copied);
    }
#line 4032
    if (qt) {
#line 4032
      if (! *y___0) {
        {
#line 4033
        y___0 = dupstring((char const   *)(nulstring));
        }
      }
    }
#line 4034
    n->dat = (void *)y___0;
  }
#line 4036
  if (eval___0) {
#line 4037
    *str = (char *)n->dat;
  }
#line 4039
  return (n);
}
}
#line 4051 "/tmp/zsh-5.4.2/Src/subst.c"
static char *arithsubst(char *a , char **bptr , char *rest ) 
{ 
  char *s ;
  char *t ;
  char buf___7[(int )(sizeof(zlong ) * 8UL + 4UL)] ;
  char *b ;
  mnumber v ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  char tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 4054
  s = *bptr;
#line 4058
  singsub(& a);
#line 4059
  v = matheval(a);
  }
#line 4060
  if (v.type & 2) {
#line 4060
    if (! outputradix) {
      {
#line 4061
      b = convfloat_underscore(v.u.d, outputunderscore);
      }
    } else {
#line 4060
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 4063
    if (v.type & 2) {
#line 4064
      v.u.l = (zlong )v.u.d;
    }
    {
#line 4065
    b = convbase_underscore(buf___7, v.u.l, outputradix, outputunderscore);
    }
  }
  {
#line 4067
  tmp___0 = strlen((char const   *)*bptr);
#line 4067
  tmp___1 = strlen((char const   *)b);
#line 4067
  tmp___2 = strlen((char const   *)rest);
#line 4067
  tmp___3 = hcalloc(((tmp___0 + tmp___1) + tmp___2) + 1UL);
#line 4067
  tmp = (char *)tmp___3;
#line 4067
  *bptr = tmp;
#line 4067
  t = tmp;
#line 4069
  t --;
  }
  {
#line 4070
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4070
    t ++;
#line 4070
    tmp___5 = s;
#line 4070
    s ++;
#line 4070
    tmp___4 = *tmp___5;
#line 4070
    *t = tmp___4;
#line 4070
    if (! tmp___4) {
#line 4070
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4071
  t --;
  {
#line 4072
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4072
    t ++;
#line 4072
    tmp___7 = b;
#line 4072
    b ++;
#line 4072
    tmp___6 = *tmp___7;
#line 4072
    *t = tmp___6;
#line 4072
    if (! tmp___6) {
#line 4072
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4073
  strcat((char */* __restrict  */)t, (char const   */* __restrict  */)rest);
  }
#line 4074
  return (t);
}
}
#line 4091 "/tmp/zsh-5.4.2/Src/subst.c"
void modify(char **str , char **ptr___0 ) 
{ 
  char *ptr1 ;
  char *ptr2 ;
  char *ptr3 ;
  char *lptr ;
  char c ;
  char *test ;
  char *sep ;
  char *t ;
  char *tt ;
  char tc ;
  char *e ;
  char *copy ;
  char *all ;
  char *tmp ;
  char sav ;
  char sav1 ;
  char *ptr1end ;
  int gbal ;
  int wall ;
  int rec ;
  int al ;
  int nl___0 ;
  int charlen ;
  int dellen ;
  convchar_t del ;
  int tmp___0 ;
  convchar_t del2 ;
  int tmp___1 ;
  convchar_t del3 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *copy2 ;
  char *tmp___5 ;
  int one ;
  int oef ;
  char *here ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *copy2___0 ;
  char *tmp___18 ;
  int one___0 ;
  int oef___0 ;
  char *here___0 ;
  char *tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 4099
  test = (char *)((void *)0);
#line 4101
  if ((int )*(*ptr___0) == 58) {
    {
#line 4102
    *str = dupstring((char const   *)*str);
    }
  }
  {
#line 4104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4104
    if (! ((int )*(*ptr___0) == 58)) {
#line 4104
      goto while_break;
    }
#line 4105
    lptr = *ptr___0;
#line 4106
    (*ptr___0) ++;
#line 4107
    gbal = 0;
#line 4107
    wall = gbal;
#line 4108
    rec = 1;
#line 4109
    c = (char )'\000';
#line 4110
    sep = (char *)((void *)0);
    {
#line 4112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4112
      if (! c) {
#line 4112
        if (! *(*ptr___0)) {
#line 4112
          goto while_break___0;
        }
      } else {
#line 4112
        goto while_break___0;
      }
      {
#line 4125
      if ((int )*(*ptr___0) == 80) {
#line 4125
        goto case_80;
      }
#line 4125
      if ((int )*(*ptr___0) == 81) {
#line 4125
        goto case_80;
      }
#line 4125
      if ((int )*(*ptr___0) == 113) {
#line 4125
        goto case_80;
      }
#line 4125
      if ((int )*(*ptr___0) == 117) {
#line 4125
        goto case_80;
      }
#line 4125
      if ((int )*(*ptr___0) == 108) {
#line 4125
        goto case_80;
      }
#line 4125
      if ((int )*(*ptr___0) == 116) {
#line 4125
        goto case_80;
      }
#line 4125
      if ((int )*(*ptr___0) == 101) {
#line 4125
        goto case_80;
      }
#line 4125
      if ((int )*(*ptr___0) == 114) {
#line 4125
        goto case_80;
      }
#line 4125
      if ((int )*(*ptr___0) == 104) {
#line 4125
        goto case_80;
      }
#line 4125
      if ((int )*(*ptr___0) == 99) {
#line 4125
        goto case_80;
      }
#line 4125
      if ((int )*(*ptr___0) == 65) {
#line 4125
        goto case_80;
      }
#line 4125
      if ((int )*(*ptr___0) == 97) {
#line 4125
        goto case_80;
      }
#line 4129
      if ((int )*(*ptr___0) == 115) {
#line 4129
        goto case_115;
      }
#line 4223
      if ((int )*(*ptr___0) == 38) {
#line 4223
        goto case_38;
      }
#line 4227
      if ((int )*(*ptr___0) == 103) {
#line 4227
        goto case_103;
      }
#line 4232
      if ((int )*(*ptr___0) == 119) {
#line 4232
        goto case_119;
      }
#line 4236
      if ((int )*(*ptr___0) == 87) {
#line 4236
        goto case_87;
      }
#line 4249
      if ((int )*(*ptr___0) == 102) {
#line 4249
        goto case_102;
      }
#line 4253
      if ((int )*(*ptr___0) == 70) {
#line 4253
        goto case_70;
      }
#line 4257
      goto switch_default;
      case_80: /* CIL Label */ 
      case_81: /* CIL Label */ 
      case_113: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_108: /* CIL Label */ 
      case_116: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_114: /* CIL Label */ 
      case_104: /* CIL Label */ 
      case_99: /* CIL Label */ 
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
#line 4126
      c = *(*ptr___0);
#line 4127
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 4130
      c = *(*ptr___0);
#line 4131
      (*ptr___0) ++;
#line 4132
      ptr1 = *ptr___0;
#line 4133
      mb_charinit();
#line 4134
      charlen = mb_metacharlenconv((char const   *)ptr1, & del);
      }
#line 4136
      if (del == 4294967295U) {
#line 4137
        if ((int )*ptr1 == -125) {
#line 4137
          tmp___0 = (int )*(ptr1 + 1) ^ 32;
        } else {
#line 4137
          tmp___0 = (int )*ptr1;
        }
#line 4137
        del = (wint_t )tmp___0;
      }
#line 4139
      ptr1 += charlen;
#line 4140
      ptr2 = ptr1;
#line 4140
      charlen = 0;
      {
#line 4140
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4140
        if (! *ptr2) {
#line 4140
          goto while_break___1;
        }
#line 4142
        if ((int )*ptr2 == -97) {
#line 4142
          goto _L;
        } else
#line 4142
        if ((int )*ptr2 == 92) {
          _L: /* CIL Label */ 
#line 4142
          if (*(ptr2 + 1)) {
#line 4144
            if ((int )*ptr2 == 92) {
#line 4145
              *ptr2 = (char)-97;
            }
#line 4146
            charlen = 2;
#line 4147
            goto __Cont;
          }
        }
        {
#line 4149
        charlen = mb_metacharlenconv((char const   *)ptr2, & del2);
        }
#line 4151
        if (del2 == 4294967295U) {
#line 4152
          if ((int )*ptr2 == -125) {
#line 4152
            tmp___1 = (int )*(ptr2 + 1) ^ 32;
          } else {
#line 4152
            tmp___1 = (int )*ptr2;
          }
#line 4152
          del2 = (wint_t )tmp___1;
        }
#line 4155
        if (del2 == del) {
#line 4156
          goto while_break___1;
        }
        __Cont: /* CIL Label */ 
#line 4140
        ptr2 += charlen;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4158
      if (! *ptr2) {
        {
#line 4159
        zerr("bad substitution");
        }
#line 4160
        return;
      }
#line 4162
      ptr1end = ptr2;
#line 4163
      ptr2 += charlen;
#line 4164
      sav1 = *ptr1end;
#line 4165
      *ptr1end = (char )'\000';
#line 4166
      ptr3 = ptr2;
#line 4166
      charlen = 0;
      {
#line 4166
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 4166
        if (! *ptr3) {
#line 4166
          goto while_break___2;
        }
#line 4168
        if ((int )*ptr3 == -97) {
#line 4168
          goto _L___0;
        } else
#line 4168
        if ((int )*ptr3 == 92) {
          _L___0: /* CIL Label */ 
#line 4168
          if (*(ptr3 + 1)) {
#line 4170
            if ((int )*ptr3 == 92) {
#line 4171
              *ptr3 = (char)-97;
            }
#line 4172
            charlen = 2;
#line 4173
            goto __Cont___0;
          }
        }
        {
#line 4175
        charlen = mb_metacharlenconv((char const   *)ptr3, & del3);
        }
#line 4177
        if (del3 == 4294967295U) {
#line 4178
          if ((int )*ptr3 == -125) {
#line 4178
            tmp___2 = (int )*(ptr3 + 1) ^ 32;
          } else {
#line 4178
            tmp___2 = (int )*ptr3;
          }
#line 4178
          del3 = (wint_t )tmp___2;
        }
#line 4181
        if (del3 == del) {
#line 4182
          goto while_break___2;
        }
        __Cont___0: /* CIL Label */ 
#line 4166
        ptr3 += charlen;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 4184
      sav = *ptr3;
#line 4185
      *ptr3 = (char )'\000';
#line 4186
      if (*ptr1) {
        {
#line 4187
        zsfree(hsubl);
#line 4188
        hsubl = ztrdup((char const   *)ptr1);
        }
      }
#line 4190
      if (! hsubl) {
        {
#line 4191
        zerr("no previous substitution");
        }
#line 4192
        return;
      }
      {
#line 4194
      zsfree(hsubr);
#line 4195
      tt = hsubl;
      }
      {
#line 4195
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 4195
        if (! *tt) {
#line 4195
          goto while_break___3;
        }
#line 4196
        if ((int )typtab[(unsigned char )*tt] & (1 << 14)) {
#line 4196
          if ((int )*tt != -96) {
            {
#line 4197
            tmp___3 = tt;
#line 4197
            tt --;
#line 4197
            chuck(tmp___3);
            }
          }
        }
#line 4195
        tt ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 4198
      if (! opts[85]) {
        {
#line 4199
        untokenize(hsubl);
        }
      }
      {
#line 4200
      hsubr = ztrdup((char const   *)ptr2);
#line 4200
      tt = hsubr;
      }
      {
#line 4200
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 4200
        if (! *tt) {
#line 4200
          goto while_break___4;
        }
#line 4201
        if ((int )typtab[(unsigned char )*tt] & (1 << 14)) {
#line 4201
          if ((int )*tt != -96) {
#line 4202
            if ((int )*tt == -97) {
#line 4202
              if ((int )*(tt + 1) == 38) {
#line 4208
                *tt = (char )'\\';
              } else
#line 4202
              if ((int )*(tt + 1) == 92) {
#line 4208
                *tt = (char )'\\';
              } else {
                {
#line 4210
                tmp___4 = tt;
#line 4210
                tt --;
#line 4210
                chuck(tmp___4);
                }
              }
            } else {
              {
#line 4210
              tmp___4 = tt;
#line 4210
              tt --;
#line 4210
              chuck(tmp___4);
              }
            }
          }
        }
#line 4200
        tt ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 4214
      *ptr1end = sav1;
#line 4215
      *ptr3 = sav;
#line 4216
      *ptr___0 = ptr3 - 1;
#line 4217
      if (*ptr3) {
#line 4219
        *ptr___0 += charlen;
      }
#line 4221
      goto switch_break;
      case_38: /* CIL Label */ 
#line 4224
      c = (char )'s';
#line 4225
      goto switch_break;
      case_103: /* CIL Label */ 
#line 4228
      (*ptr___0) ++;
#line 4229
      gbal = 1;
#line 4230
      goto switch_break;
      case_119: /* CIL Label */ 
#line 4233
      wall = 1;
#line 4234
      (*ptr___0) ++;
#line 4235
      goto switch_break;
      case_87: /* CIL Label */ 
      {
#line 4237
      wall = 1;
#line 4238
      (*ptr___0) ++;
#line 4239
      ptr2 = *ptr___0;
#line 4239
      ptr1 = get_strarg(ptr2, & charlen);
#line 4240
      sav = *ptr1;
      }
#line 4240
      if (sav) {
#line 4241
        *ptr1 = (char )'\000';
      }
      {
#line 4242
      sep = dupstring((char const   *)(ptr2 + charlen));
      }
#line 4243
      if (sav) {
#line 4244
        *ptr1 = sav;
      }
#line 4245
      *ptr___0 = ptr1 + charlen;
#line 4246
      c = (char )'\000';
#line 4247
      goto switch_break;
      case_102: /* CIL Label */ 
#line 4250
      rec = -1;
#line 4251
      (*ptr___0) ++;
#line 4252
      goto switch_break;
      case_70: /* CIL Label */ 
      {
#line 4254
      (*ptr___0) ++;
#line 4255
      rec = get_intarg(ptr___0, & dellen);
      }
#line 4256
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 4258
      *ptr___0 = lptr;
#line 4259
      return;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4262
    (*ptr___0) ++;
#line 4263
    if (! c) {
#line 4264
      *ptr___0 = lptr;
#line 4265
      return;
    }
#line 4267
    if (rec < 0) {
      {
#line 4268
      test = dupstring((char const   *)*str);
      }
    }
    {
#line 4270
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 4270
      tmp___23 = rec;
#line 4270
      rec --;
#line 4270
      if (! tmp___23) {
#line 4270
        goto while_break___5;
      }
#line 4271
      if (wall) {
#line 4272
        al = 0;
#line 4273
        all = (char *)((void *)0);
#line 4274
        e = *str;
#line 4274
        t = e;
        {
#line 4274
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 4274
          tt = findword(& e, sep);
          }
#line 4274
          if (! tt) {
#line 4274
            goto while_break___6;
          }
#line 4275
          tc = *e;
#line 4276
          *e = (char )'\000';
#line 4277
          if ((int )c != 108) {
#line 4277
            if ((int )c != 117) {
              {
#line 4278
              copy = dupstring((char const   *)tt);
              }
            }
          }
#line 4279
          *e = tc;
          {
#line 4281
          if ((int )c == 97) {
#line 4281
            goto case_97___0;
          }
#line 4284
          if ((int )c == 65) {
#line 4284
            goto case_65___0;
          }
#line 4287
          if ((int )c == 99) {
#line 4287
            goto case_99___0;
          }
#line 4294
          if ((int )c == 104) {
#line 4294
            goto case_104___0;
          }
#line 4297
          if ((int )c == 114) {
#line 4297
            goto case_114___0;
          }
#line 4300
          if ((int )c == 101) {
#line 4300
            goto case_101___0;
          }
#line 4303
          if ((int )c == 116) {
#line 4303
            goto case_116___0;
          }
#line 4306
          if ((int )c == 108) {
#line 4306
            goto case_108___0;
          }
#line 4309
          if ((int )c == 117) {
#line 4309
            goto case_117___0;
          }
#line 4312
          if ((int )c == 115) {
#line 4312
            goto case_115___0;
          }
#line 4316
          if ((int )c == 113) {
#line 4316
            goto case_113___0;
          }
#line 4319
          if ((int )c == 81) {
#line 4319
            goto case_81___0;
          }
#line 4332
          if ((int )c == 80) {
#line 4332
            goto case_80___0;
          }
#line 4280
          goto switch_break___0;
          case_97___0: /* CIL Label */ 
          {
#line 4282
          chabspath(& copy);
          }
#line 4283
          goto switch_break___0;
          case_65___0: /* CIL Label */ 
          {
#line 4285
          chrealpath(& copy);
          }
#line 4286
          goto switch_break___0;
          case_99___0: /* CIL Label */ 
          {
#line 4289
          tmp___5 = equalsubstr(copy, 0, 0);
#line 4289
          copy2 = tmp___5;
          }
#line 4290
          if (copy2) {
#line 4291
            copy = copy2;
          }
#line 4292
          goto switch_break___0;
          case_104___0: /* CIL Label */ 
          {
#line 4295
          remtpath(& copy);
          }
#line 4296
          goto switch_break___0;
          case_114___0: /* CIL Label */ 
          {
#line 4298
          remtext(& copy);
          }
#line 4299
          goto switch_break___0;
          case_101___0: /* CIL Label */ 
          {
#line 4301
          rembutext(& copy);
          }
#line 4302
          goto switch_break___0;
          case_116___0: /* CIL Label */ 
          {
#line 4304
          remlpaths(& copy);
          }
#line 4305
          goto switch_break___0;
          case_108___0: /* CIL Label */ 
          {
#line 4307
          copy = casemodify(tt, 2);
          }
#line 4308
          goto switch_break___0;
          case_117___0: /* CIL Label */ 
          {
#line 4310
          copy = casemodify(tt, 1);
          }
#line 4311
          goto switch_break___0;
          case_115___0: /* CIL Label */ 
#line 4313
          if (hsubl) {
#line 4313
            if (hsubr) {
              {
#line 4314
              subst(& copy, hsubl, hsubr, gbal);
              }
            }
          }
#line 4315
          goto switch_break___0;
          case_113___0: /* CIL Label */ 
          {
#line 4317
          copy = quotestring((char const   *)copy, 8);
          }
#line 4318
          goto switch_break___0;
          case_81___0: /* CIL Label */ 
          {
#line 4321
          one = noerrs;
#line 4321
          oef = errflag;
#line 4323
          noerrs = 1;
#line 4324
          parse_subst_string(copy);
#line 4325
          noerrs = one;
#line 4327
          errflag = oef | (errflag & 2);
#line 4328
          remnulargs(copy);
#line 4329
          untokenize(copy);
          }
#line 4331
          goto switch_break___0;
          case_80___0: /* CIL Label */ 
#line 4333
          if ((int )*copy != 47) {
            {
#line 4334
            tmp___6 = zgetcwd();
#line 4334
            here = tmp___6;
#line 4335
            tmp___8 = strlen((char const   *)here);
            }
#line 4335
            if ((int )*(here + (tmp___8 - 1UL)) != 47) {
              {
#line 4336
              tmp___7 = metafy(here, -1, 6);
#line 4336
              copy = zhtricat((char const   *)tmp___7, "/", (char const   *)copy);
              }
            } else {
              {
#line 4338
              copy = dyncat((char const   *)here, (char const   *)copy);
              }
            }
          }
          {
#line 4340
          copy = xsymlink(copy, 1);
          }
#line 4341
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
          {
#line 4343
          tc = *tt;
#line 4344
          *tt = (char )'\000';
#line 4345
          tmp___9 = strlen((char const   *)t);
#line 4345
          tmp___10 = strlen((char const   *)copy);
#line 4345
          nl___0 = (int )(((size_t )al + tmp___9) + tmp___10);
#line 4346
          tmp___11 = zhalloc((size_t )(nl___0 + 1));
#line 4346
          tmp = (char *)tmp___11;
#line 4346
          ptr1 = tmp;
          }
#line 4347
          if (all) {
#line 4348
            ptr2 = all;
            {
#line 4348
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 4348
              if (! *ptr2) {
#line 4348
                goto while_break___7;
              }
#line 4349
              tmp___12 = ptr1;
#line 4349
              ptr1 ++;
#line 4349
              tmp___13 = ptr2;
#line 4349
              ptr2 ++;
#line 4349
              *tmp___12 = *tmp___13;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
#line 4350
          ptr2 = t;
          {
#line 4350
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 4350
            if (! *ptr2) {
#line 4350
              goto while_break___8;
            }
#line 4351
            tmp___14 = ptr1;
#line 4351
            ptr1 ++;
#line 4351
            tmp___15 = ptr2;
#line 4351
            ptr2 ++;
#line 4351
            *tmp___14 = *tmp___15;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 4352
          *tt = tc;
#line 4353
          ptr2 = copy;
          {
#line 4353
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 4353
            if (! *ptr2) {
#line 4353
              goto while_break___9;
            }
#line 4354
            tmp___16 = ptr1;
#line 4354
            ptr1 ++;
#line 4354
            tmp___17 = ptr2;
#line 4354
            ptr2 ++;
#line 4354
            *tmp___16 = *tmp___17;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 4355
          *ptr1 = (char )'\000';
#line 4356
          al = nl___0;
#line 4357
          all = tmp;
#line 4358
          t = e;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 4360
        if (! all) {
          {
#line 4361
          *str = dupstring("");
          }
        } else {
#line 4363
          *str = all;
        }
      } else {
        {
#line 4367
        if ((int )c == 97) {
#line 4367
          goto case_97___1;
        }
#line 4370
        if ((int )c == 65) {
#line 4370
          goto case_65___1;
        }
#line 4373
        if ((int )c == 99) {
#line 4373
          goto case_99___1;
        }
#line 4380
        if ((int )c == 104) {
#line 4380
          goto case_104___1;
        }
#line 4383
        if ((int )c == 114) {
#line 4383
          goto case_114___1;
        }
#line 4386
        if ((int )c == 101) {
#line 4386
          goto case_101___1;
        }
#line 4389
        if ((int )c == 116) {
#line 4389
          goto case_116___1;
        }
#line 4392
        if ((int )c == 108) {
#line 4392
          goto case_108___1;
        }
#line 4395
        if ((int )c == 117) {
#line 4395
          goto case_117___1;
        }
#line 4398
        if ((int )c == 115) {
#line 4398
          goto case_115___1;
        }
#line 4402
        if ((int )c == 113) {
#line 4402
          goto case_113___1;
        }
#line 4405
        if ((int )c == 81) {
#line 4405
          goto case_81___1;
        }
#line 4418
        if ((int )c == 80) {
#line 4418
          goto case_80___1;
        }
#line 4366
        goto switch_break___1;
        case_97___1: /* CIL Label */ 
        {
#line 4368
        chabspath(str);
        }
#line 4369
        goto switch_break___1;
        case_65___1: /* CIL Label */ 
        {
#line 4371
        chrealpath(str);
        }
#line 4372
        goto switch_break___1;
        case_99___1: /* CIL Label */ 
        {
#line 4375
        tmp___18 = equalsubstr(*str, 0, 0);
#line 4375
        copy2___0 = tmp___18;
        }
#line 4376
        if (copy2___0) {
#line 4377
          *str = copy2___0;
        }
#line 4378
        goto switch_break___1;
        case_104___1: /* CIL Label */ 
        {
#line 4381
        remtpath(str);
        }
#line 4382
        goto switch_break___1;
        case_114___1: /* CIL Label */ 
        {
#line 4384
        remtext(str);
        }
#line 4385
        goto switch_break___1;
        case_101___1: /* CIL Label */ 
        {
#line 4387
        rembutext(str);
        }
#line 4388
        goto switch_break___1;
        case_116___1: /* CIL Label */ 
        {
#line 4390
        remlpaths(str);
        }
#line 4391
        goto switch_break___1;
        case_108___1: /* CIL Label */ 
        {
#line 4393
        *str = casemodify(*str, 2);
        }
#line 4394
        goto switch_break___1;
        case_117___1: /* CIL Label */ 
        {
#line 4396
        *str = casemodify(*str, 1);
        }
#line 4397
        goto switch_break___1;
        case_115___1: /* CIL Label */ 
#line 4399
        if (hsubl) {
#line 4399
          if (hsubr) {
            {
#line 4400
            subst(str, hsubl, hsubr, gbal);
            }
          }
        }
#line 4401
        goto switch_break___1;
        case_113___1: /* CIL Label */ 
        {
#line 4403
        *str = quotestring((char const   *)*str, 1);
        }
#line 4404
        goto switch_break___1;
        case_81___1: /* CIL Label */ 
        {
#line 4407
        one___0 = noerrs;
#line 4407
        oef___0 = errflag;
#line 4409
        noerrs = 1;
#line 4410
        parse_subst_string(*str);
#line 4411
        noerrs = one___0;
#line 4413
        errflag = oef___0 | (errflag & 2);
#line 4414
        remnulargs(*str);
#line 4415
        untokenize(*str);
        }
#line 4417
        goto switch_break___1;
        case_80___1: /* CIL Label */ 
#line 4419
        if ((int )*(*str) != 47) {
          {
#line 4420
          tmp___19 = zgetcwd();
#line 4420
          here___0 = tmp___19;
#line 4421
          tmp___21 = strlen((char const   *)here___0);
          }
#line 4421
          if ((int )*(here___0 + (tmp___21 - 1UL)) != 47) {
            {
#line 4422
            tmp___20 = metafy(here___0, -1, 6);
#line 4422
            *str = zhtricat((char const   *)tmp___20, "/", (char const   *)*str);
            }
          } else {
            {
#line 4424
            *str = dyncat((char const   *)here___0, (char const   *)*str);
            }
          }
        }
        {
#line 4426
        *str = xsymlink(*str, 1);
        }
#line 4427
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
#line 4430
      if (rec < 0) {
        {
#line 4431
        tmp___22 = strcmp((char const   *)test, (char const   *)*str);
        }
#line 4431
        if (tmp___22) {
          {
#line 4434
          test = dupstring((char const   *)*str);
          }
        } else {
#line 4432
          rec = 0;
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4438
  return;
}
}
#line 4443 "/tmp/zsh-5.4.2/Src/subst.c"
static char *dstackent(char ch , int val ) 
{ 
  int backwards ;
  LinkNode end ;
  LinkNode n ;
  int tmp ;
  int tmp___0 ;

  {
#line 4447
  end = (LinkNode )dirstack;
#line 4449
  if (opts[146]) {
#line 4449
    tmp = '+';
  } else {
#line 4449
    tmp = '-';
  }
#line 4449
  backwards = (int )ch == tmp;
#line 4450
  if (! backwards) {
#line 4450
    tmp___0 = val;
#line 4450
    val --;
#line 4450
    if (! tmp___0) {
#line 4451
      return (pwd);
    }
  }
#line 4452
  if (backwards) {
#line 4453
    n = dirstack->list.last;
    {
#line 4453
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4453
      if ((unsigned long )n != (unsigned long )end) {
#line 4453
        if (! val) {
#line 4453
          goto while_break;
        }
      } else {
#line 4453
        goto while_break;
      }
#line 4453
      val --;
#line 4453
      n = n->prev;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 4455
    end = (LinkNode )((void *)0);
#line 4455
    n = dirstack->list.first;
    {
#line 4455
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4455
      if (n) {
#line 4455
        if (! val) {
#line 4455
          goto while_break___0;
        }
      } else {
#line 4455
        goto while_break___0;
      }
#line 4455
      val --;
#line 4455
      n = n->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 4456
  if ((unsigned long )n == (unsigned long )end) {
#line 4457
    if (backwards) {
#line 4457
      if (! val) {
#line 4458
        return (pwd);
      }
    }
#line 4459
    if (opts[120]) {
      {
#line 4460
      zerr("not enough directory stack entries.");
      }
    }
#line 4461
    return ((char *)((void *)0));
  }
#line 4463
  return ((char *)n->dat);
}
}
#line 87 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) wchar_t *( __attribute__((__nonnull__(1,2))) wcscpy)(wchar_t * __restrict  __dest ,
                                                                                          wchar_t const   * __restrict  __src ) ;
#line 222
extern  __attribute__((__nothrow__)) size_t wcslen(wchar_t const   *__s )  __attribute__((__pure__)) ;
#line 6 "./string.epro"
char *dupstring_wlen(char const   *s , unsigned int len ) ;
#line 7
char *dupstring_glen(char const   *s , unsigned int *len_ret ) ;
#line 18
char *appstr(char *base , char const   *append ) ;
#line 19
char *strend(char *str ) ;
#line 32 "/tmp/zsh-5.4.2/Src/string.c"
char *dupstring(char const   *s ) 
{ 
  char *t ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 37
  if (! s) {
#line 38
    return ((char *)((void *)0));
  }
  {
#line 39
  tmp = strlen((char const   *)((char *)s));
#line 39
  tmp___0 = zhalloc(tmp + 1UL);
#line 39
  t = (char *)tmp___0;
#line 40
  strcpy((char */* __restrict  */)t, (char const   */* __restrict  */)s);
  }
#line 41
  return (t);
}
}
#line 47 "/tmp/zsh-5.4.2/Src/string.c"
char *dupstring_wlen(char const   *s , unsigned int len ) 
{ 
  char *t ;
  void *tmp ;

  {
#line 52
  if (! s) {
#line 53
    return ((char *)((void *)0));
  }
  {
#line 54
  tmp = zhalloc((size_t )(len + 1U));
#line 54
  t = (char *)tmp;
#line 55
  memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)s, (size_t )len);
#line 56
  *(t + len) = (char )'\000';
  }
#line 57
  return (t);
}
}
#line 63 "/tmp/zsh-5.4.2/Src/string.c"
char *dupstring_glen(char const   *s , unsigned int *len_ret ) 
{ 
  char *t ;
  unsigned int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 68
  if (! s) {
#line 69
    return ((char *)((void *)0));
  }
  {
#line 70
  tmp___0 = strlen((char const   *)((char *)s));
#line 70
  tmp = (unsigned int )tmp___0;
#line 70
  *len_ret = tmp;
#line 70
  tmp___1 = zhalloc((size_t )(tmp + 1U));
#line 70
  t = (char *)tmp___1;
#line 71
  strcpy((char */* __restrict  */)t, (char const   */* __restrict  */)s);
  }
#line 72
  return (t);
}
}
#line 76 "/tmp/zsh-5.4.2/Src/string.c"
char *ztrdup(char const   *s ) 
{ 
  char *t ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 81
  if (! s) {
#line 82
    return ((char *)((void *)0));
  }
  {
#line 83
  tmp = strlen((char const   *)((char *)s));
#line 83
  tmp___0 = zalloc(tmp + 1UL);
#line 83
  t = (char *)tmp___0;
#line 84
  strcpy((char */* __restrict  */)t, (char const   */* __restrict  */)s);
  }
#line 85
  return (t);
}
}
#line 91 "/tmp/zsh-5.4.2/Src/string.c"
wchar_t *wcs_ztrdup(wchar_t const   *s ) 
{ 
  wchar_t *t ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 96
  if (! s) {
#line 97
    return ((wchar_t *)((void *)0));
  }
  {
#line 98
  tmp = wcslen((wchar_t const   *)((wchar_t *)s));
#line 98
  tmp___0 = zalloc(sizeof(wchar_t ) * (tmp + 1UL));
#line 98
  t = (wchar_t *)tmp___0;
#line 99
  wcscpy((wchar_t */* __restrict  */)t, (wchar_t const   */* __restrict  */)s);
  }
#line 100
  return (t);
}
}
#line 109 "/tmp/zsh-5.4.2/Src/string.c"
char *tricat(char const   *s1 , char const   *s2 , char const   *s3 ) 
{ 
  char *ptr___0 ;
  size_t l1 ;
  size_t tmp ;
  size_t l2 ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 114
  tmp = strlen(s1);
#line 114
  l1 = tmp;
#line 115
  tmp___0 = strlen(s2);
#line 115
  l2 = tmp___0;
#line 117
  tmp___1 = strlen(s3);
#line 117
  tmp___2 = zalloc(((l1 + l2) + tmp___1) + 1UL);
#line 117
  ptr___0 = (char *)tmp___2;
#line 118
  strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)s1);
#line 119
  strcpy((char */* __restrict  */)(ptr___0 + l1), (char const   */* __restrict  */)s2);
#line 120
  strcpy((char */* __restrict  */)((ptr___0 + l1) + l2), (char const   */* __restrict  */)s3);
  }
#line 121
  return (ptr___0);
}
}
#line 125 "/tmp/zsh-5.4.2/Src/string.c"
char *zhtricat(char const   *s1 , char const   *s2 , char const   *s3 ) 
{ 
  char *ptr___0 ;
  size_t l1 ;
  size_t tmp ;
  size_t l2 ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 129
  tmp = strlen(s1);
#line 129
  l1 = tmp;
#line 130
  tmp___0 = strlen(s2);
#line 130
  l2 = tmp___0;
#line 132
  tmp___1 = strlen(s3);
#line 132
  tmp___2 = zhalloc(((l1 + l2) + tmp___1) + 1UL);
#line 132
  ptr___0 = (char *)tmp___2;
#line 133
  strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)s1);
#line 134
  strcpy((char */* __restrict  */)(ptr___0 + l1), (char const   */* __restrict  */)s2);
#line 135
  strcpy((char */* __restrict  */)((ptr___0 + l1) + l2), (char const   */* __restrict  */)s3);
  }
#line 136
  return (ptr___0);
}
}
#line 142 "/tmp/zsh-5.4.2/Src/string.c"
char *dyncat(char const   *s1 , char const   *s2 ) 
{ 
  char *ptr___0 ;
  size_t l1 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 147
  tmp = strlen(s1);
#line 147
  l1 = tmp;
#line 149
  tmp___0 = strlen(s2);
#line 149
  tmp___1 = zhalloc((l1 + tmp___0) + 1UL);
#line 149
  ptr___0 = (char *)tmp___1;
#line 150
  strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)s1);
#line 151
  strcpy((char */* __restrict  */)(ptr___0 + l1), (char const   */* __restrict  */)s2);
  }
#line 152
  return (ptr___0);
}
}
#line 156 "/tmp/zsh-5.4.2/Src/string.c"
char *bicat(char const   *s1 , char const   *s2 ) 
{ 
  char *ptr___0 ;
  size_t l1 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 161
  tmp = strlen(s1);
#line 161
  l1 = tmp;
#line 163
  tmp___0 = strlen(s2);
#line 163
  tmp___1 = zalloc((l1 + tmp___0) + 1UL);
#line 163
  ptr___0 = (char *)tmp___1;
#line 164
  strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)s1);
#line 165
  strcpy((char */* __restrict  */)(ptr___0 + l1), (char const   */* __restrict  */)s2);
  }
#line 166
  return (ptr___0);
}
}
#line 172 "/tmp/zsh-5.4.2/Src/string.c"
char *dupstrpfx(char const   *s , int len ) 
{ 
  char *r ;
  void *tmp ;

  {
  {
#line 175
  tmp = zhalloc((size_t )(len + 1));
#line 175
  r = (char *)tmp;
#line 177
  memcpy((void */* __restrict  */)r, (void const   */* __restrict  */)s, (size_t )len);
#line 178
  *(r + len) = (char )'\000';
  }
#line 179
  return (r);
}
}
#line 183 "/tmp/zsh-5.4.2/Src/string.c"
char *ztrduppfx(char const   *s , int len ) 
{ 
  char *r ;
  void *tmp ;

  {
  {
#line 187
  tmp = zalloc((size_t )(len + 1));
#line 187
  r = (char *)tmp;
#line 189
  memcpy((void */* __restrict  */)r, (void const   */* __restrict  */)s, (size_t )len);
#line 190
  *(r + len) = (char )'\000';
  }
#line 191
  return (r);
}
}
#line 197 "/tmp/zsh-5.4.2/Src/string.c"
char *appstr(char *base , char const   *append ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 200
  tmp = strlen((char const   *)base);
#line 200
  tmp___0 = strlen(append);
#line 200
  tmp___1 = realloc((void *)base, (tmp + tmp___0) + 1UL);
#line 200
  tmp___2 = strcat((char */* __restrict  */)tmp___1, (char const   */* __restrict  */)append);
  }
#line 200
  return (tmp___2);
}
}
#line 207 "/tmp/zsh-5.4.2/Src/string.c"
char *strend(char *str ) 
{ 
  size_t tmp ;

  {
#line 210
  if ((int )*str == 0) {
#line 211
    return (str);
  }
  {
#line 212
  tmp = strlen((char const   *)str);
  }
#line 212
  return ((str + tmp) - 1);
}
}
#line 143 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcoll)(char const   *__s1 ,
                                                                                      char const   *__s2 )  __attribute__((__pure__)) ;
#line 166 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) wint_t towlower(wint_t __wc ) ;
#line 5 "./sort.epro"
int zstrcmp(char const   *as , char const   *bs , int sortflags ) ;
#line 2 "./sort.pro"
static int eltpcmp(void const   *a , void const   *b ) ;
#line 34 "/tmp/zsh-5.4.2/Src/sort.c"
static int sortdir  ;
#line 37 "/tmp/zsh-5.4.2/Src/sort.c"
static int sortnumeric  ;
#line 40 "/tmp/zsh-5.4.2/Src/sort.c"
static int eltpcmp(void const   *a , void const   *b ) 
{ 
  SortElt ae ;
  SortElt be ;
  char const   *as ;
  char const   *bs ;
  char const   *ao ;
  int cmp ;
  char const   *cmpa ;
  char const   *cmpb ;
  char const   *laststarta ;
  int len ;
  int tmp ;

  {
#line 43
  ae = (SortElt )*((SortElt const   *)a);
#line 44
  be = (SortElt )*((SortElt const   *)b);
#line 45
  as = ae->cmp;
#line 45
  bs = be->cmp;
#line 46
  ao = as;
#line 49
  if (ae->len != -1) {
#line 49
    goto _L;
  } else
#line 49
  if (be->len != -1) {
    _L: /* CIL Label */ 
#line 61
    laststarta = as;
#line 63
    if (ae->len != -1) {
#line 64
      len = ae->len;
#line 65
      if (be->len != -1) {
#line 65
        if (len > be->len) {
#line 66
          len = be->len;
        }
      }
    } else {
#line 69
      len = be->len;
    }
#line 71
    cmpa = as;
#line 71
    cmpb = bs;
    {
#line 71
    while (1) {
      while_continue: /* CIL Label */ ;
#line 71
      if ((int const   )*cmpa == (int const   )*cmpb) {
#line 71
        tmp = len;
#line 71
        len --;
#line 71
        if (! tmp) {
#line 71
          goto while_break;
        }
      } else {
#line 71
        goto while_break;
      }
#line 72
      if (! *cmpa) {
#line 77
        if (ae->len == -1) {
#line 78
          goto while_break;
        } else
#line 77
        if (be->len == -1) {
#line 78
          goto while_break;
        }
#line 79
        laststarta = cmpa + 1;
      }
#line 71
      cmpa ++;
#line 71
      cmpb ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    if ((int const   )*cmpa == (int const   )*cmpb) {
#line 82
      if (ae->len != be->len) {
#line 90
        if (ae->len != -1) {
#line 91
          if (be->len != -1) {
#line 96
            return ((ae->len - be->len) * sortdir);
          } else {
#line 102
            return (sortdir);
          }
        } else {
#line 109
          return (- sortdir);
        }
      }
    }
#line 113
    bs += laststarta - as;
#line 114
    as += laststarta - as;
  }
  {
#line 117
  cmp = strcoll(as, bs);
  }
#line 119
  if (sortnumeric) {
    {
#line 120
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 120
      if ((int const   )*as == (int const   )*bs) {
#line 120
        if (! *as) {
#line 120
          goto while_break___0;
        }
      } else {
#line 120
        goto while_break___0;
      }
#line 120
      as ++;
#line 120
      bs ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 124
    if ((int )typtab[(unsigned char )*as] & 1) {
#line 124
      goto _L___1;
    } else
#line 124
    if ((int )typtab[(unsigned char )*bs] & 1) {
      _L___1: /* CIL Label */ 
      {
#line 125
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 125
        if ((unsigned long )as > (unsigned long )ao) {
#line 125
          if (! ((int )typtab[(unsigned char )*(as + -1)] & 1)) {
#line 125
            goto while_break___1;
          }
        } else {
#line 125
          goto while_break___1;
        }
#line 125
        as --;
#line 125
        bs --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 126
      if ((int )typtab[(unsigned char )*as] & 1) {
#line 126
        if ((int )typtab[(unsigned char )*bs] & 1) {
          {
#line 127
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 127
            if (! ((int const   )*as == 48)) {
#line 127
              goto while_break___2;
            }
#line 128
            as ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 129
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 129
            if (! ((int const   )*bs == 48)) {
#line 129
              goto while_break___3;
            }
#line 130
            bs ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 131
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 131
            if ((int )typtab[(unsigned char )*as] & 1) {
#line 131
              if (! ((int const   )*as == (int const   )*bs)) {
#line 131
                goto while_break___4;
              }
            } else {
#line 131
              goto while_break___4;
            }
#line 131
            as ++;
#line 131
            bs ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 132
          if ((int )typtab[(unsigned char )*as] & 1) {
#line 132
            goto _L___0;
          } else
#line 132
          if ((int )typtab[(unsigned char )*bs] & 1) {
            _L___0: /* CIL Label */ 
#line 133
            cmp = (int )((unsigned char )*as) - (int )((unsigned char )*bs);
            {
#line 134
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 134
              if ((int )typtab[(unsigned char )*as] & 1) {
#line 134
                if (! ((int )typtab[(unsigned char )*bs] & 1)) {
#line 134
                  goto while_break___5;
                }
              } else {
#line 134
                goto while_break___5;
              }
#line 135
              as ++;
#line 135
              bs ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 136
            if ((int )typtab[(unsigned char )*as] & 1) {
#line 136
              if (! ((int )typtab[(unsigned char )*bs] & 1)) {
#line 137
                return (sortdir);
              }
            }
#line 138
            if ((int )typtab[(unsigned char )*bs] & 1) {
#line 138
              if (! ((int )typtab[(unsigned char )*as] & 1)) {
#line 139
                return (- sortdir);
              }
            }
          }
        }
      }
    }
  }
#line 149
  return (sortdir * cmp);
}
}
#line 161 "/tmp/zsh-5.4.2/Src/sort.c"
int zstrcmp(char const   *as , char const   *bs , int sortflags ) 
{ 
  struct sortelt ae ;
  struct sortelt be ;
  struct sortelt *aeptr ;
  struct sortelt *beptr ;
  int oldsortdir ;
  int oldsortnumeric ;
  int ret ;

  {
#line 165
  oldsortdir = sortdir;
#line 165
  oldsortnumeric = sortnumeric;
#line 167
  ae.cmp = as;
#line 168
  be.cmp = bs;
#line 169
  ae.len = -1;
#line 170
  be.len = -1;
#line 172
  aeptr = & ae;
#line 173
  beptr = & be;
#line 175
  sortdir = 1;
#line 176
  if (sortflags & 2) {
#line 176
    sortnumeric = 1;
  } else {
#line 176
    sortnumeric = 0;
  }
  {
#line 178
  ret = eltpcmp((void const   *)(& aeptr), (void const   *)(& beptr));
#line 181
  sortnumeric = oldsortnumeric;
#line 182
  sortdir = oldsortdir;
  }
#line 184
  return (ret);
}
}
#line 198 "/tmp/zsh-5.4.2/Src/sort.c"
void strmetasort(char **array , int sortwhat , int *unmetalenp ) 
{ 
  char **arrptr ;
  SortElt *sortptrarr ;
  SortElt *sortptrarrptr ;
  SortElt sortarr ;
  SortElt sortarrptr ;
  int oldsortdir ;
  int oldsortnumeric ;
  int nsort ;
  void *tmp ;
  void *tmp___0 ;
  char *metaptr ;
  int needlen ;
  int needalloc ;
  int count ;
  int tmp___1 ;
  char *s ;
  char *t ;
  char *src ;
  char *dst ;
  int len ;
  int tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *t___0 ;
  char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char tmp___8 ;
  char *tmp___9 ;
  char *send ;
  mbstate_t mbsin ;
  mbstate_t mbsout ;
  int clen ;
  wchar_t wc ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  wint_t tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *end ;
  char *tmp___20 ;
  char *tmp___21 ;
  char **tmp___22 ;
  SortElt *tmp___23 ;
  int tmp___24 ;

  {
  {
#line 212
  nsort = arrlen(array);
  }
#line 213
  if (nsort < 2) {
#line 214
    return;
  }
  {
#line 216
  pushheap();
#line 218
  tmp = zhalloc((unsigned long )nsort * sizeof(SortElt ));
#line 218
  sortptrarr = (SortElt *)tmp;
#line 219
  tmp___0 = zhalloc((unsigned long )nsort * sizeof(struct sortelt ));
#line 219
  sortarr = (SortElt )tmp___0;
#line 220
  arrptr = array;
#line 220
  sortptrarrptr = sortptrarr;
#line 220
  sortarrptr = sortarr;
  }
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! *arrptr) {
#line 220
      goto while_break;
    }
#line 224
    *sortptrarrptr = sortarrptr;
#line 225
    sortarrptr->orig = *arrptr;
#line 227
    if (unmetalenp) {
#line 232
      count = *(unmetalenp + (arrptr - array));
#line 234
      sortarrptr->origlen = count;
#line 235
      metaptr = *arrptr;
      {
#line 235
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 235
        if ((int )*metaptr != 0) {
#line 235
          tmp___1 = count;
#line 235
          count --;
#line 235
          if (! tmp___1) {
#line 235
            goto while_break___0;
          }
        } else {
#line 235
          goto while_break___0;
        }
#line 235
        metaptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 238
      needlen = count != 0;
    } else {
#line 245
      needlen = 0;
#line 246
      metaptr = *arrptr;
      {
#line 246
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 246
        if (*metaptr) {
#line 246
          if (! ((int )*metaptr != -125)) {
#line 246
            goto while_break___1;
          }
        } else {
#line 246
          goto while_break___1;
        }
#line 246
        metaptr ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 254
    needalloc = sortwhat & 9;
#line 254
    if (needalloc) {
#line 254
      goto _L;
    } else
#line 254
    if ((int )*metaptr == -125) {
      _L: /* CIL Label */ 
#line 257
      src = *arrptr;
#line 259
      if (sortwhat & 1) {
#line 259
        tmp___2 = 2;
      } else {
#line 259
        tmp___2 = 1;
      }
      {
#line 259
      tmp___3 = strlen((char const   *)src);
#line 259
      tmp___4 = zhalloc((size_t )tmp___2 * tmp___3 + 1UL);
#line 259
      dst = (char *)tmp___4;
#line 259
      sortarrptr->cmp = (char const   *)dst;
      }
#line 262
      if (unmetalenp) {
#line 264
        len = *(unmetalenp + (arrptr - array));
      } else
#line 265
      if ((int )*metaptr != 0) {
#line 270
        t___0 = dst + (metaptr - src);
#line 272
        if ((unsigned long )metaptr != (unsigned long )src) {
          {
#line 273
          memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src,
                 (size_t )(metaptr - src));
          }
        }
        {
#line 274
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 274
          tmp___9 = metaptr;
#line 274
          metaptr ++;
#line 274
          tmp___8 = *tmp___9;
#line 274
          *t___0 = tmp___8;
#line 274
          if (! tmp___8) {
#line 274
            goto while_break___2;
          }
#line 275
          tmp___7 = t___0;
#line 275
          t___0 ++;
#line 275
          if ((int )*tmp___7 == -125) {
#line 276
            tmp___6 = metaptr;
#line 276
            metaptr ++;
#line 276
            tmp___5 = (char )((int )*tmp___6 ^ 32);
#line 276
            *(t___0 + -1) = tmp___5;
#line 276
            if ((int )tmp___5 == 0) {
#line 277
              needlen = 1;
            }
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 280
        len = (int )(t___0 - dst);
#line 281
        src = dst;
      } else {
#line 292
        len = (int )(metaptr - src);
      }
#line 294
      if (sortwhat & 1) {
#line 295
        send = src + len;
#line 297
        if (opts[117]) {
          {
#line 309
          memset((void *)(& mbsin), 0, sizeof(mbstate_t ));
#line 310
          memset((void *)(& mbsout), 0, sizeof(mbstate_t ));
#line 312
          s = src;
#line 312
          t = dst;
          }
          {
#line 312
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 312
            if (! ((unsigned long )s < (unsigned long )send)) {
#line 312
              goto while_break___3;
            }
            {
#line 313
            tmp___10 = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)s,
                               (size_t )(send - s), (mbstate_t */* __restrict  */)(& mbsin));
#line 313
            clen = (int )tmp___10;
            }
#line 314
            if (clen < 0) {
              {
#line 316
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 316
                if (! ((unsigned long )s < (unsigned long )send)) {
#line 316
                  goto while_break___4;
                }
                {
#line 317
                tmp___11 = t;
#line 317
                t ++;
#line 317
                tmp___12 = s;
#line 317
                s ++;
#line 317
                tmp___13 = tulower((int )*tmp___12);
#line 317
                *tmp___11 = (char )tmp___13;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 318
              goto while_break___3;
            }
#line 320
            if (clen == 0) {
#line 322
              tmp___14 = t;
#line 322
              t ++;
#line 322
              *tmp___14 = (char )'\000';
#line 323
              s ++;
#line 324
              goto __Cont;
            }
            {
#line 326
            s += clen;
#line 327
            tmp___15 = towlower((wint_t )wc);
#line 327
            wc = (wchar_t )tmp___15;
#line 328
            tmp___16 = wcrtomb((char */* __restrict  */)t, wc, (mbstate_t */* __restrict  */)(& mbsout));
#line 328
            clen = (int )tmp___16;
#line 329
            t += clen;
            }
            __Cont: /* CIL Label */ ;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 332
          *t = (char )'\000';
#line 333
          len = (int )(t - dst);
        } else {
#line 336
          s = src;
#line 336
          t = dst;
          {
#line 336
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 336
            if (! ((unsigned long )s < (unsigned long )send)) {
#line 336
              goto while_break___5;
            }
            {
#line 337
            tmp___17 = t;
#line 337
            t ++;
#line 337
            tmp___18 = s;
#line 337
            s ++;
#line 337
            tmp___19 = tulower((int )*tmp___18);
#line 337
            *tmp___17 = (char )tmp___19;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 338
        src = dst;
      }
#line 340
      if (sortwhat & 8) {
#line 341
        end = (src + len) + 1;
#line 343
        s = src;
#line 343
        t = dst;
        {
#line 343
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 343
          if (! ((unsigned long )s < (unsigned long )end)) {
#line 343
            goto while_break___6;
          }
#line 344
          if ((int )*s == 92) {
#line 345
            s ++;
#line 346
            len --;
          }
#line 348
          tmp___20 = t;
#line 348
          t ++;
#line 348
          tmp___21 = s;
#line 348
          s ++;
#line 348
          *tmp___20 = *tmp___21;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 352
      if (needlen) {
#line 352
        sortarrptr->len = len;
      } else {
#line 352
        sortarrptr->len = -1;
      }
    } else {
#line 358
      sortarrptr->cmp = (char const   *)*arrptr;
#line 359
      if (needlen) {
#line 359
        sortarrptr->len = *(unmetalenp + (arrptr - array));
      } else {
#line 359
        sortarrptr->len = -1;
      }
    }
#line 220
    arrptr ++;
#line 220
    sortptrarrptr ++;
#line 220
    sortarrptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  oldsortdir = sortdir;
#line 366
  oldsortnumeric = sortnumeric;
#line 368
  if (sortwhat & 4) {
#line 368
    sortdir = -1;
  } else {
#line 368
    sortdir = 1;
  }
#line 369
  if (sortwhat & 2) {
#line 369
    sortnumeric = 1;
  } else {
#line 369
    sortnumeric = 0;
  }
  {
#line 371
  qsort((void *)sortptrarr, (size_t )nsort, sizeof(SortElt ), & eltpcmp);
#line 373
  sortnumeric = oldsortnumeric;
#line 374
  sortdir = oldsortdir;
#line 375
  arrptr = array;
#line 375
  sortptrarrptr = sortptrarr;
  }
  {
#line 375
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 375
    tmp___24 = nsort;
#line 375
    nsort --;
#line 375
    if (! tmp___24) {
#line 375
      goto while_break___7;
    }
#line 376
    if (unmetalenp) {
#line 377
      *(unmetalenp + (arrptr - array)) = (*sortptrarrptr)->origlen;
    }
#line 378
    tmp___22 = arrptr;
#line 378
    arrptr ++;
#line 378
    tmp___23 = sortptrarrptr;
#line 378
    sortptrarrptr ++;
#line 378
    *tmp___22 = (*tmp___23)->orig;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 381
  popheap();
  }
#line 382
  return;
}
}
#line 6 "./signames.epro"
char *sig_msg[33] ;
#line 7
char *sigs[35] ;
#line 11 "/tmp/zsh-5.4.2/Src/signames.c"
char *sig_msg[33]  = 
#line 11 "/tmp/zsh-5.4.2/Src/signames.c"
  {      (char *)"done",      (char *)"hangup",      (char *)"interrupt",      (char *)"quit", 
        (char *)"illegal hardware instruction",      (char *)"trace trap",      (char *)"abort",      (char *)"bus error", 
        (char *)"floating point exception",      (char *)"killed",      (char *)"user-defined signal 1",      (char *)"segmentation fault", 
        (char *)"user-defined signal 2",      (char *)"broken pipe",      (char *)"alarm",      (char *)"terminated", 
        (char *)"",      (char *)"death of child",      (char *)"continued",      (char *)"suspended (signal)", 
        (char *)"suspended",      (char *)"suspended (tty input)",      (char *)"suspended (tty output)",      (char *)"urgent condition", 
        (char *)"cpu limit exceeded",      (char *)"file size limit exceeded",      (char *)"virtual time alarm",      (char *)"profile signal", 
        (char *)"window size changed",      (char *)"pollable event occurred",      (char *)"",      (char *)"invalid system call", 
        (char *)((void *)0)};
#line 64 "/tmp/zsh-5.4.2/Src/signames.c"
char *sigs[35]  = 
#line 64
  {      (char *)"EXIT",      (char *)"HUP",      (char *)"INT",      (char *)"QUIT", 
        (char *)"ILL",      (char *)"TRAP",      (char *)"ABRT",      (char *)"BUS", 
        (char *)"FPE",      (char *)"KILL",      (char *)"USR1",      (char *)"SEGV", 
        (char *)"USR2",      (char *)"PIPE",      (char *)"ALRM",      (char *)"TERM", 
        (char *)"16",      (char *)"CHLD",      (char *)"CONT",      (char *)"STOP", 
        (char *)"TSTP",      (char *)"TTIN",      (char *)"TTOU",      (char *)"URG", 
        (char *)"XCPU",      (char *)"XFSZ",      (char *)"VTALRM",      (char *)"PROF", 
        (char *)"WINCH",      (char *)"POLL",      (char *)"30",      (char *)"SYS", 
        (char *)"ZERR",      (char *)"DEBUG",      (char *)((void *)0)};
#line 435 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 88 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 119
extern  __attribute__((__nothrow__)) int killpg(__pid_t __pgrp , int __sig ) ;
#line 196
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 199
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigfillset)(sigset_t *__set ) ;
#line 202
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
#line 229
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 237
extern int ( __attribute__((__nonnull__(1))) sigsuspend)(sigset_t const   *__set ) ;
#line 240
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 68 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 136 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern  __attribute__((__nothrow__)) __pid_t wait3(int *__stat_loc , int __options ,
                                                   struct rusage *__usage ) ;
#line 6 "./context.epro"
void zcontext_save(void) ;
#line 8
void zcontext_restore(void) ;
#line 5 "./exec.epro"
int noerrexit ;
#line 10
int trap_state ;
#line 11
int trap_return ;
#line 22
pid_t cmdoutpid ;
#line 23
int cmdoutval ;
#line 24
int use_cmdoutval ;
#line 26
struct execstack *exstack ;
#line 35
int list_pipe ;
#line 36
int simple_pline ;
#line 42
int forklevel ;
#line 44
void execode(Eprog p , int dont_change_job , int exiting , char *context ) ;
#line 56
Emulation_options sticky_emulation_dup(Emulation_options src , int useheap ) ;
#line 64
void execsave(void) ;
#line 65
void execrestore(void) ;
#line 12 "./hashtable.epro"
extern HashNode removehashnode(HashTable ht , char const   *nam ) ;
#line 45
void dircache_set(char **name , char *value ) ;
#line 32 "./hist.epro"
char *chline ;
#line 22 "./init.epro"
struct hookdef zshhooks[3] ;
#line 14 "./input.epro"
void inerrflush(void) ;
#line 7 "./jobs.epro"
int thisjob ;
#line 10
struct job *jobtab ;
#line 12
int maxjob ;
#line 23
int findproc(pid_t pid , Job *jptr , Process *pptr , int aux ) ;
#line 25
void get_usage(void) ;
#line 27
void check_cursh_sig(int sig ) ;
#line 29
void update_job(Job jn ) ;
#line 51
void addbgstatus(pid_t pid , int status ) ;
#line 56
HashNode gettrapnode(int sig , int ignoredisable ) ;
#line 15 "./linklist.epro"
void freelinklist(LinkList list , void (*freefunc)(void * ) ) ;
#line 5 "./loop.epro"
int loops ;
#line 17
zlong try_tryflag ;
#line 35 "./module.epro"
int runhookdef(Hookdef h , void *d___0 ) ;
#line 38 "./params.epro"
zlong lastval ;
#line 159
zlong ttyidlegetfn(Param pm  __attribute__((__unused__)) ) ;
#line 27 "./parse.epro"
int empty_eprog(Eprog p ) ;
#line 34
Eprog dupeprog(Eprog p , int heap ) ;
#line 5 "./signals.epro"
int sigtrapped[34]  ;
#line 6 "./signals.epro"
Eprog siglists[34]  ;
#line 7 "./signals.epro"
int nsigtrapped  ;
#line 8 "./signals.epro"
int in_exit_trap  ;
#line 9 "./signals.epro"
int queueing_enabled  ;
#line 10 "./signals.epro"
int queue_front  ;
#line 11 "./signals.epro"
int queue_rear  ;
#line 12 "./signals.epro"
int signal_queue[128]  ;
#line 13 "./signals.epro"
sigset_t signal_mask_queue[128]  ;
#line 15 "./signals.epro"
int trap_queueing_enabled  ;
#line 16 "./signals.epro"
int trap_queue_front  ;
#line 17 "./signals.epro"
int trap_queue_rear  ;
#line 18 "./signals.epro"
int trap_queue[128]  ;
#line 19
void install_handler(int sig ) ;
#line 20
void intr(void) ;
#line 29
int signal_suspend(int sig  __attribute__((__unused__)) , int wait_cmd ) ;
#line 30 "./signals.epro"
int last_signal  ;
#line 31
void wait_for_processes(void) ;
#line 33
void killrunjobs(int from_signal ) ;
#line 34
int killjb(Job jn , int sig ) ;
#line 35
int settrap(int sig , Eprog l , int flags ) ;
#line 36
void unsettrap(int sig ) ;
#line 37
HashNode removetrap(int sig ) ;
#line 38
void starttrapscope(void) ;
#line 39
void endtrapscope(void) ;
#line 40
void queue_traps(int wait_cmd ) ;
#line 41
void unqueue_traps(void) ;
#line 42 "./signals.epro"
int intrap  ;
#line 43 "./signals.epro"
int trapisfunc  ;
#line 44 "./signals.epro"
int traplocallevel  ;
#line 45
void dotrap(int sig ) ;
#line 2 "./signals.pro"
static int exit_trap_posix  ;
#line 5
static int handletrap(int sig ) ;
#line 6
static void dotrapargs(int sig , int *sigtr , void *sigfn ) ;
#line 124 "/tmp/zsh-5.4.2/Src/signals.c"
void install_handler(int sig ) 
{ 
  struct sigaction act ;

  {
  {
#line 130
  act.__sigaction_handler.sa_handler = & zhandler;
#line 131
  sigemptyset(& act.sa_mask);
#line 132
  act.sa_flags = 0;
  }
#line 134
  if (opts[93]) {
#line 135
    act.sa_flags |= 536870912;
  }
  {
#line 137
  sigaction(sig, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((struct sigaction *)((void *)0)));
  }
#line 159
  return;
}
}
#line 164 "/tmp/zsh-5.4.2/Src/signals.c"
void intr(void) 
{ 


  {
#line 167
  if (opts[93]) {
    {
#line 168
    install_handler(2);
    }
  }
#line 169
  return;
}
}
#line 185 "/tmp/zsh-5.4.2/Src/signals.c"
void holdintr(void) 
{ 
  sigset_t tmp ;

  {
#line 188
  if (opts[93]) {
    {
#line 189
    tmp = signal_mask(2);
#line 189
    signal_block(tmp);
    }
  }
#line 190
  return;
}
}
#line 195 "/tmp/zsh-5.4.2/Src/signals.c"
void noholdintr(void) 
{ 
  sigset_t tmp ;

  {
#line 198
  if (opts[93]) {
    {
#line 199
    tmp = signal_mask(2);
#line 199
    signal_unblock(tmp);
    }
  }
#line 200
  return;
}
}
#line 206 "/tmp/zsh-5.4.2/Src/signals.c"
sigset_t signal_mask(int sig ) 
{ 
  sigset_t set ;

  {
  {
#line 211
  sigemptyset(& set);
  }
#line 212
  if (sig) {
    {
#line 213
    sigaddset(& set, sig);
    }
  }
#line 214
  return (set);
}
}
#line 224 "/tmp/zsh-5.4.2/Src/signals.c"
sigset_t signal_block(sigset_t set ) 
{ 
  sigset_t oset ;

  {
  {
#line 230
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)(& oset));
  }
#line 258
  return (oset);
}
}
#line 268 "/tmp/zsh-5.4.2/Src/signals.c"
sigset_t signal_unblock(sigset_t set ) 
{ 
  sigset_t oset ;

  {
  {
#line 274
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)(& oset));
  }
#line 307
  return (oset);
}
}
#line 314 "/tmp/zsh-5.4.2/Src/signals.c"
sigset_t signal_setmask(sigset_t set ) 
{ 
  sigset_t oset ;

  {
  {
#line 320
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)(& oset));
  }
#line 355
  return (oset);
}
}
#line 364 "/tmp/zsh-5.4.2/Src/signals.c"
int signal_suspend(int sig  __attribute__((__unused__)) , int wait_cmd ) 
{ 
  int ret ;
  sigset_t set ;

  {
  {
#line 375
  sigemptyset(& set);
  }
#line 382
  if (! wait_cmd) {
#line 382
    if (! opts[170]) {
#line 382
      if (! (sigtrapped[2] & ~ (1 << 1))) {
        {
#line 384
        sigaddset(& set, 2);
        }
      }
    }
  }
  {
#line 393
  ret = sigsuspend((sigset_t const   *)(& set));
  }
#line 416
  return (ret);
}
}
#line 431 "/tmp/zsh-5.4.2/Src/signals.c"
void wait_for_processes(void) 
{ 
  int old_errno ;
  int *tmp ;
  int status ;
  Job jn ;
  Process pn ;
  pid_t pid ;
  pid_t *procsubpid ;
  int *procsubval ;
  int cont ;
  struct execstack *es ;
  struct rusage ru ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  struct timezone dummy_tz ;
  int tmp___3 ;
  int tmp___4 ;
  int val ;
  int tmp___5 ;
  int tmp___6 ;
  sigset_t oset ;

  {
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 437
    tmp = __errno_location();
#line 437
    old_errno = *tmp;
#line 442
    procsubpid = & cmdoutpid;
#line 443
    procsubval = & cmdoutval;
#line 444
    cont = 0;
#line 445
    es = exstack;
#line 462
    pid = wait3((int *)((void *)(& status)), 11, & ru);
    }
#line 474
    if (! pid) {
#line 475
      goto while_break;
    }
    {
#line 478
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 479
      if (pid == *procsubpid) {
#line 480
        *procsubpid = 0;
#line 481
        if ((int )((signed char )((status & 127) + 1)) >> 1 > 0) {
#line 482
          *procsubval = 128 | (status & 127);
        } else {
#line 484
          *procsubval = (status & 65280) >> 8;
        }
        {
#line 485
        use_cmdoutval = 1;
#line 486
        get_usage();
#line 487
        cont = 1;
        }
#line 488
        goto while_break___0;
      }
#line 490
      if (! es) {
#line 491
        goto while_break___0;
      }
#line 492
      procsubpid = & es->cmdoutpid;
#line 493
      procsubval = & es->cmdoutval;
#line 494
      es = es->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 496
    if (cont) {
#line 497
      goto __Cont;
    }
#line 500
    if (pid == -1) {
      {
#line 501
      tmp___1 = __errno_location();
      }
#line 501
      if (*tmp___1 != 10) {
        {
#line 502
        tmp___0 = __errno_location();
#line 502
        zerr("wait failed: %e", *tmp___0);
        }
      }
      {
#line 504
      tmp___2 = __errno_location();
#line 504
      *tmp___2 = old_errno;
      }
#line 505
      goto while_break;
    }
    {
#line 512
    queueing_enabled ++;
#line 518
    tmp___4 = findproc(pid, & jn, & pn, 0);
    }
#line 518
    if (tmp___4) {
#line 519
      if (jn->stat & 16384) {
#line 519
        goto _L___3;
      } else
#line 519
      if (list_pipe) {
#line 519
        if (thisjob == -1) {
#line 519
          goto _L___3;
        } else
#line 519
        if ((jobtab + thisjob)->stat & 16384) {
          _L___3: /* CIL Label */ 
#line 519
          if ((status & 255) == 127) {
#line 519
            if ((status & 65280) >> 8 == 20) {
              {
#line 524
              killjb(jn, 18);
#line 525
              zwarn("job can\'t be suspended");
              }
            } else {
#line 519
              goto _L___2;
            }
          } else {
#line 519
            goto _L___2;
          }
        } else {
#line 519
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        {
#line 529
        gettimeofday((struct timeval */* __restrict  */)(& pn->endtime), (__timezone_ptr_t )(& dummy_tz));
        }
#line 531
        if (status == 65535) {
#line 532
          pn->status = -1;
        } else {
#line 535
          pn->status = status;
        }
#line 536
        pn->ti = ru;
      }
      {
#line 541
      update_job(jn);
      }
    } else {
      {
#line 542
      tmp___3 = findproc(pid, & jn, & pn, 1);
      }
#line 542
      if (tmp___3) {
        {
#line 543
        pn->status = status;
#line 544
        update_job(jn);
        }
      } else {
        {
#line 551
        get_usage();
        }
      }
    }
#line 559
    if (jn) {
#line 559
      if (! (jn->stat & 17408)) {
#line 559
        if (jn - jobtab != (long )thisjob) {
#line 561
          if ((int )((signed char )((status & 127) + 1)) >> 1 > 0) {
#line 561
            tmp___6 = 128 | (status & 127);
          } else {
#line 561
            if ((status & 255) == 127) {
#line 561
              tmp___5 = 128 | ((status & 65280) >> 8);
            } else {
#line 561
              tmp___5 = (status & 65280) >> 8;
            }
#line 561
            tmp___6 = tmp___5;
          }
          {
#line 561
          val = tmp___6;
#line 566
          addbgstatus(pid, val);
          }
        }
      }
    }
    {
#line 569
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 569
      queueing_enabled --;
#line 569
      if (! queueing_enabled) {
        {
#line 569
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 569
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 569
            if (! (queue_front != queue_rear)) {
#line 569
              goto while_break___3;
            }
            {
#line 569
            queue_front = (queue_front + 1) % 128;
#line 569
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 569
            zhandler(signal_queue[queue_front]);
#line 569
            signal_setmask(oset);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 569
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 569
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  return;
}
}
#line 576 "/tmp/zsh-5.4.2/Src/signals.c"
void zhandler(int sig ) 
{ 
  sigset_t newmask ;
  sigset_t oldmask ;
  int temp_rear ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int idle ;
  zlong tmp___3 ;
  int tmout ;
  zlong tmp___4 ;
  int tmp___5 ;

  {
  {
#line 586
  last_signal = sig;
#line 589
  sigfillset(& newmask);
#line 591
  oldmask = signal_block(newmask);
  }
#line 609
  if (queueing_enabled) {
#line 610
    queue_rear ++;
#line 610
    temp_rear = queue_rear % 128;
#line 614
    if (temp_rear != queue_front) {
#line 616
      queue_rear = temp_rear;
#line 618
      signal_queue[queue_rear] = sig;
#line 620
      signal_mask_queue[queue_rear] = oldmask;
    }
#line 623
    return;
  }
  {
#line 627
  signal_setmask(oldmask);
  }
  {
#line 630
  if (sig == 17) {
#line 630
    goto case_17;
  }
#line 634
  if (sig == 13) {
#line 634
    goto case_13;
  }
#line 645
  if (sig == 1) {
#line 645
    goto case_1;
  }
#line 652
  if (sig == 2) {
#line 652
    goto case_2;
  }
#line 668
  if (sig == 28) {
#line 668
    goto case_28;
  }
#line 674
  if (sig == 14) {
#line 674
    goto case_14;
  }
#line 694
  goto switch_default;
  case_17: /* CIL Label */ 
  {
#line 631
  wait_for_processes();
  }
#line 632
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 635
  tmp___0 = handletrap(13);
  }
#line 635
  if (! tmp___0) {
#line 636
    if (! opts[93]) {
      {
#line 637
      _exit(13);
      }
    } else {
      {
#line 638
      tmp = isatty(SHTTY);
      }
#line 638
      if (! tmp) {
        {
#line 639
        stopmsg = 1;
#line 640
        zexit(13, 1);
        }
      }
    }
  }
#line 643
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 646
  tmp___1 = handletrap(1);
  }
#line 646
  if (! tmp___1) {
    {
#line 647
    stopmsg = 1;
#line 648
    zexit(1, 1);
    }
  }
#line 650
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 653
  tmp___2 = handletrap(2);
  }
#line 653
  if (! tmp___2) {
#line 654
    if (opts[139]) {
#line 654
      goto _L;
    } else
#line 654
    if (opts[154]) {
      _L: /* CIL Label */ 
#line 654
      if (opts[93]) {
#line 654
        if (noerrexit & 8) {
          {
#line 656
          zexit(2, 1);
          }
        }
      }
    }
#line 657
    if (list_pipe) {
      {
#line 658
      breaks = loops;
#line 659
      errflag |= 2;
#line 660
      inerrflush();
#line 661
      check_cursh_sig(2);
      }
    } else
#line 657
    if (chline) {
      {
#line 658
      breaks = loops;
#line 659
      errflag |= 2;
#line 660
      inerrflush();
#line 661
      check_cursh_sig(2);
      }
    } else
#line 657
    if (simple_pline) {
      {
#line 658
      breaks = loops;
#line 659
      errflag |= 2;
#line 660
      inerrflush();
#line 661
      check_cursh_sig(2);
      }
    }
#line 663
    lastval = (zlong )130;
  }
#line 665
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 669
  adjustwinsize(1);
#line 670
  handletrap(28);
  }
#line 671
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 675
  tmp___5 = handletrap(14);
  }
#line 675
  if (! tmp___5) {
    {
#line 676
    tmp___3 = ttyidlegetfn((Param )((void *)0));
#line 676
    idle = (int )tmp___3;
#line 677
    tmp___4 = getiparam((char *)"TMOUT");
#line 677
    tmout = (int )tmp___4;
    }
#line 678
    if (idle >= 0) {
#line 678
      if (idle < tmout) {
        {
#line 679
        alarm((unsigned int )(tmout - idle));
        }
      } else {
        {
#line 686
        noerrs = 0;
#line 686
        errflag = noerrs;
#line 687
        zwarn("timeout");
#line 688
        stopmsg = 1;
#line 689
        zexit(14, 1);
        }
      }
    } else {
      {
#line 686
      noerrs = 0;
#line 686
      errflag = noerrs;
#line 687
      zwarn("timeout");
#line 688
      stopmsg = 1;
#line 689
      zexit(14, 1);
      }
    }
  }
#line 692
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 695
  handletrap(sig);
  }
#line 696
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 707
  return;
}
}
#line 713 "/tmp/zsh-5.4.2/Src/signals.c"
void killrunjobs(int from_signal ) 
{ 
  int i ;
  int killed ;
  __pid_t tmp ;
  int tmp___0 ;

  {
#line 716
  killed = 0;
#line 718
  if (! opts[87]) {
#line 719
    return;
  }
#line 720
  i = 1;
  {
#line 720
  while (1) {
    while_continue: /* CIL Label */ ;
#line 720
    if (! (i <= maxjob)) {
#line 720
      goto while_break;
    }
#line 721
    if (from_signal) {
#line 721
      goto _L;
    } else
#line 721
    if (i != thisjob) {
      _L: /* CIL Label */ 
#line 721
      if ((jobtab + i)->stat & 16) {
#line 721
        if (! ((jobtab + i)->stat & 32)) {
#line 721
          if (! ((jobtab + i)->stat & 2)) {
            {
#line 724
            tmp = getpid();
            }
#line 724
            if ((jobtab + i)->gleader != tmp) {
              {
#line 724
              tmp___0 = killpg((jobtab + i)->gleader, 1);
              }
#line 724
              if (tmp___0 != -1) {
#line 726
                killed ++;
              }
            }
          }
        }
      }
    }
#line 720
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 728
  if (killed) {
    {
#line 729
    zwarn("warning: %d jobs SIGHUPed", killed);
    }
  }
#line 730
  return;
}
}
#line 736 "/tmp/zsh-5.4.2/Src/signals.c"
int killjb(Job jn , int sig ) 
{ 
  Process pn ;
  int err ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;

  {
#line 740
  err = 0;
#line 742
  if (opts[116]) {
#line 743
    if (jn->stat & 128) {
#line 744
      if (sig == 18) {
#line 745
        pn = (jobtab + jn->other)->procs;
        {
#line 745
        while (1) {
          while_continue: /* CIL Label */ ;
#line 745
          if (! pn) {
#line 745
            goto while_break;
          }
          {
#line 746
          tmp___1 = killpg(pn->pid, sig);
          }
#line 746
          if (tmp___1 == -1) {
            {
#line 747
            tmp = kill(pn->pid, sig);
            }
#line 747
            if (tmp == -1) {
              {
#line 747
              tmp___0 = __errno_location();
              }
#line 747
              if (*tmp___0 != 3) {
#line 748
                err = -1;
              }
            }
          }
#line 745
          pn = pn->next;
        }
        while_break: /* CIL Label */ ;
        }
#line 756
        pn = jn->procs;
        {
#line 756
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 756
          if (! pn->next) {
#line 756
            goto while_break___0;
          }
          {
#line 757
          tmp___2 = kill(pn->pid, sig);
          }
#line 757
          if (tmp___2 == -1) {
            {
#line 757
            tmp___3 = __errno_location();
            }
#line 757
            if (*tmp___3 != 3) {
#line 758
              err = -1;
            }
          }
#line 756
          pn = pn->next;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 764
        if (! (jobtab + jn->other)->procs) {
#line 764
          if (pn) {
            {
#line 765
            tmp___4 = kill(pn->pid, sig);
            }
#line 765
            if (tmp___4 == -1) {
              {
#line 765
              tmp___5 = __errno_location();
              }
#line 765
              if (*tmp___5 != 3) {
#line 766
                err = -1;
              }
            }
          }
        }
#line 768
        return (err);
      }
      {
#line 770
      tmp___6 = killpg((jobtab + jn->other)->gleader, sig);
      }
#line 770
      if (tmp___6 == -1) {
        {
#line 770
        tmp___7 = __errno_location();
        }
#line 770
        if (*tmp___7 != 3) {
#line 771
          err = -1;
        }
      }
      {
#line 773
      tmp___8 = killpg(jn->gleader, sig);
      }
#line 773
      if (tmp___8 == -1) {
        {
#line 773
        tmp___9 = __errno_location();
        }
#line 773
        if (*tmp___9 != 3) {
#line 774
          err = -1;
        }
      }
#line 776
      return (err);
    } else {
      {
#line 779
      tmp___10 = killpg(jn->gleader, sig);
      }
#line 779
      return (tmp___10);
    }
  }
#line 781
  pn = jn->procs;
  {
#line 781
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 781
    if (! pn) {
#line 781
      goto while_break___1;
    }
    {
#line 782
    err = kill(pn->pid, sig);
    }
#line 782
    if (err == -1) {
      {
#line 782
      tmp___11 = __errno_location();
      }
#line 782
      if (*tmp___11 != 3) {
#line 782
        if (sig != 0) {
#line 783
          return (-1);
        }
      }
    }
#line 781
    pn = pn->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 784
  return (err);
}
}
#line 796 "/tmp/zsh-5.4.2/Src/signals.c"
static LinkList savetraps  ;
#line 797 "/tmp/zsh-5.4.2/Src/signals.c"
static int dontsavetrap  ;
#line 804 "/tmp/zsh-5.4.2/Src/signals.c"
static void dosavetrap(int sig , int level ) 
{ 
  struct savetrap *st___0 ;
  void *tmp ;
  Shfunc shf ;
  Shfunc newshf ;
  void *tmp___0 ;
  HashNode tmp___1 ;
  Eprog tmp___2 ;
  int tmp___3 ;

  {
  {
#line 808
  tmp = zalloc(sizeof(*st___0));
#line 808
  st___0 = (struct savetrap *)tmp;
#line 809
  st___0->sig = sig;
#line 810
  st___0->local = level;
  }
#line 811
  if (sig == 0) {
#line 811
    st___0->posix = exit_trap_posix;
  } else {
#line 811
    st___0->posix = 0;
  }
#line 812
  tmp___3 = sigtrapped[sig];
#line 812
  st___0->flags = tmp___3;
#line 812
  if (tmp___3 & (1 << 2)) {
    {
#line 817
    newshf = (Shfunc )((void *)0);
#line 818
    tmp___1 = gettrapnode(sig, 1);
#line 818
    shf = (Shfunc )tmp___1;
    }
#line 818
    if (shf) {
      {
#line 820
      tmp___0 = zshcalloc(sizeof(*newshf));
#line 820
      newshf = (Shfunc )tmp___0;
#line 821
      newshf->node.nam = ztrdup((char const   *)shf->node.nam);
#line 822
      newshf->node.flags = shf->node.flags;
#line 823
      newshf->funcdef = dupeprog(shf->funcdef, 0);
      }
#line 824
      if (shf->node.flags & (1 << 19)) {
        {
#line 825
        dircache_set(& newshf->filename, shf->filename);
        }
      } else {
        {
#line 827
        newshf->filename = ztrdup((char const   *)shf->filename);
        }
      }
#line 829
      if (shf->sticky) {
        {
#line 830
        newshf->sticky = sticky_emulation_dup(shf->sticky, 0);
        }
      } else {
#line 832
        newshf->sticky = (Emulation_options )0;
      }
#line 833
      if (shf->node.flags & (1 << 9)) {
#line 834
        (newshf->funcdef)->shf = newshf;
      }
    }
#line 840
    st___0->list = (void *)newshf;
  } else
#line 841
  if (sigtrapped[sig]) {
#line 842
    if (siglists[sig]) {
      {
#line 842
      tmp___2 = dupeprog(siglists[sig], 0);
#line 842
      st___0->list = (void *)tmp___2;
      }
    } else {
#line 842
      st___0->list = (void *)0;
    }
  } else {
#line 845
    st___0->list = (void *)0;
  }
#line 847
  if (! savetraps) {
    {
#line 848
    savetraps = znewlinklist();
    }
  }
  {
#line 852
  zinsertlinknode(savetraps, (LinkNode )savetraps, (void *)st___0);
  }
#line 853
  return;
}
}
#line 871 "/tmp/zsh-5.4.2/Src/signals.c"
int settrap(int sig , Eprog l , int flags ) 
{ 
  int tmp ;
  sigset_t oset ;

  {
#line 874
  if (sig == -1) {
#line 875
    return (1);
  }
#line 876
  if (opts[116]) {
#line 876
    if (sig == 22) {
      {
#line 877
      zerr("can\'t trap SIG%s in interactive shells", sigs[sig]);
      }
#line 878
      return (1);
    } else
#line 876
    if (sig == 20) {
      {
#line 877
      zerr("can\'t trap SIG%s in interactive shells", sigs[sig]);
      }
#line 878
      return (1);
    } else
#line 876
    if (sig == 21) {
      {
#line 877
      zerr("can\'t trap SIG%s in interactive shells", sigs[sig]);
      }
#line 878
      return (1);
    }
  }
  {
#line 885
  queueing_enabled ++;
#line 886
  unsettrap(sig);
#line 890
  siglists[sig] = l;
  }
#line 891
  if (! (flags & (1 << 2))) {
    {
#line 891
    tmp = empty_eprog(l);
    }
#line 891
    if (tmp) {
#line 892
      sigtrapped[sig] = 1 << 1;
#line 893
      if (sig) {
#line 893
        if (sig <= 31) {
#line 893
          if (sig != 28) {
#line 893
            if (sig != 17) {
              {
#line 898
              signal(sig, (void (*)(int  ))1);
              }
            }
          }
        }
      }
    } else {
#line 891
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 900
    nsigtrapped ++;
#line 901
    sigtrapped[sig] = 1;
#line 902
    if (sig) {
#line 902
      if (sig <= 31) {
#line 902
        if (sig != 28) {
#line 902
          if (sig != 17) {
            {
#line 907
            install_handler(sig);
            }
          }
        }
      }
    }
  }
#line 909
  sigtrapped[sig] |= flags;
#line 915
  if (sig == 0) {
#line 917
    exit_trap_posix = (int )opts[136];
#line 919
    if (! exit_trap_posix) {
#line 920
      sigtrapped[sig] |= locallevel << 4;
    }
  } else {
#line 923
    sigtrapped[sig] |= locallevel << 4;
  }
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    queueing_enabled --;
#line 924
    if (! queueing_enabled) {
      {
#line 924
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 924
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 924
          if (! (queue_front != queue_rear)) {
#line 924
            goto while_break___1;
          }
          {
#line 924
          queue_front = (queue_front + 1) % 128;
#line 924
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 924
          zhandler(signal_queue[queue_front]);
#line 924
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 924
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 924
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 925
  return (0);
}
}
#line 929 "/tmp/zsh-5.4.2/Src/signals.c"
void unsettrap(int sig ) 
{ 
  HashNode hn ;
  sigset_t oset ;

  {
  {
#line 934
  queueing_enabled ++;
#line 935
  hn = removetrap(sig);
  }
#line 936
  if (hn) {
    {
#line 937
    (*(shfunctab->freenode))(hn);
    }
  }
  {
#line 938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 938
    queueing_enabled --;
#line 938
    if (! queueing_enabled) {
      {
#line 938
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 938
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 938
          if (! (queue_front != queue_rear)) {
#line 938
            goto while_break___1;
          }
          {
#line 938
          queue_front = (queue_front + 1) % 128;
#line 938
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 938
          zhandler(signal_queue[queue_front]);
#line 938
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 938
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 938
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 939
  return;
}
}
#line 942 "/tmp/zsh-5.4.2/Src/signals.c"
HashNode removetrap(int sig ) 
{ 
  int trapped ;
  int tmp ;
  sigset_t oset ;
  HashNode node ;
  HashNode tmp___0 ;
  sigset_t oset___0 ;
  sigset_t oset___1 ;

  {
#line 947
  if (sig == -1) {
#line 949
    return ((HashNode )((void *)0));
  } else
#line 947
  if (opts[116]) {
#line 947
    if (sig == 22) {
#line 949
      return ((HashNode )((void *)0));
    } else
#line 947
    if (sig == 20) {
#line 949
      return ((HashNode )((void *)0));
    } else
#line 947
    if (sig == 21) {
#line 949
      return ((HashNode )((void *)0));
    }
  }
#line 951
  queueing_enabled ++;
#line 952
  trapped = sigtrapped[sig];
#line 963
  if (! dontsavetrap) {
#line 963
    if (sig == 0) {
#line 963
      tmp = ! opts[136];
    } else {
#line 963
      tmp = (int )opts[109];
    }
#line 963
    if (tmp) {
#line 963
      if (locallevel) {
#line 963
        if (! trapped) {
          {
#line 967
          dosavetrap(sig, locallevel);
          }
        } else
#line 963
        if (locallevel > sigtrapped[sig] >> 4) {
          {
#line 967
          dosavetrap(sig, locallevel);
          }
        }
      }
    }
  }
#line 969
  if (! trapped) {
    {
#line 970
    while (1) {
      while_continue: /* CIL Label */ ;
#line 970
      queueing_enabled --;
#line 970
      if (! queueing_enabled) {
        {
#line 970
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 970
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 970
            if (! (queue_front != queue_rear)) {
#line 970
              goto while_break___1;
            }
            {
#line 970
            queue_front = (queue_front + 1) % 128;
#line 970
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 970
            zhandler(signal_queue[queue_front]);
#line 970
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 970
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 970
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 971
    return ((HashNode )((void *)0));
  }
#line 973
  if (sigtrapped[sig] & 1) {
#line 974
    nsigtrapped --;
  }
#line 975
  sigtrapped[sig] = 0;
#line 976
  if (sig == 2) {
#line 976
    if (opts[93]) {
      {
#line 979
      intr();
#line 980
      noholdintr();
      }
    } else {
#line 976
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 981
  if (sig == 1) {
    {
#line 982
    install_handler(sig);
    }
  } else
#line 983
  if (sig == 13) {
#line 983
    if (opts[93]) {
#line 983
      if (! forklevel) {
        {
#line 984
        install_handler(sig);
        }
      } else {
#line 983
        goto _L___0;
      }
    } else {
#line 983
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 985
  if (sig) {
#line 985
    if (sig <= 31) {
#line 985
      if (sig != 28) {
#line 985
        if (sig != 17) {
          {
#line 990
          signal(sig, (void (*)(int  ))0);
          }
        }
      }
    }
  }
#line 991
  if (sig == 0) {
#line 992
    exit_trap_posix = 0;
  }
#line 1002
  if (trapped & (1 << 2)) {
    {
#line 1003
    tmp___0 = gettrapnode(sig, 1);
#line 1003
    node = tmp___0;
    }
#line 1009
    if (node) {
      {
#line 1010
      removehashnode(shfunctab, (char const   *)node->nam);
      }
    }
    {
#line 1011
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1011
      queueing_enabled --;
#line 1011
      if (! queueing_enabled) {
        {
#line 1011
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1011
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1011
            if (! (queue_front != queue_rear)) {
#line 1011
              goto while_break___4;
            }
            {
#line 1011
            queue_front = (queue_front + 1) % 128;
#line 1011
            oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 1011
            zhandler(signal_queue[queue_front]);
#line 1011
            signal_setmask(oset___0);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1011
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1011
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1013
    return (node);
  } else
#line 1014
  if (siglists[sig]) {
    {
#line 1015
    freeeprog(siglists[sig]);
#line 1016
    siglists[sig] = (Eprog )((void *)0);
    }
  }
  {
#line 1018
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1018
    queueing_enabled --;
#line 1018
    if (! queueing_enabled) {
      {
#line 1018
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 1018
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1018
          if (! (queue_front != queue_rear)) {
#line 1018
            goto while_break___7;
          }
          {
#line 1018
          queue_front = (queue_front + 1) % 128;
#line 1018
          oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 1018
          zhandler(signal_queue[queue_front]);
#line 1018
          signal_setmask(oset___1);
          }
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1018
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1018
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1020
  return ((HashNode )((void *)0));
}
}
#line 1024 "/tmp/zsh-5.4.2/Src/signals.c"
void starttrapscope(void) 
{ 


  {
#line 1028
  if (intrap) {
#line 1029
    return;
  }
#line 1036
  if (sigtrapped[0]) {
#line 1036
    if (! exit_trap_posix) {
      {
#line 1037
      locallevel ++;
#line 1038
      unsettrap(0);
#line 1039
      locallevel --;
      }
    }
  }
#line 1041
  return;
}
}
#line 1049 "/tmp/zsh-5.4.2/Src/signals.c"
void endtrapscope(void) 
{ 
  LinkNode ln ;
  struct savetrap *st___0 ;
  int exittr ;
  void *exitfn ;
  HashNode tmp ;
  int sig ;
  int tmp___0 ;

  {
#line 1054
  exittr = 0;
#line 1055
  exitfn = (void *)0;
#line 1062
  if (! intrap) {
#line 1062
    if (! exit_trap_posix) {
#line 1062
      exittr = sigtrapped[0];
#line 1062
      if (exittr) {
#line 1064
        if (exittr & (1 << 2)) {
          {
#line 1065
          tmp = removehashnode(shfunctab, "TRAPEXIT");
#line 1065
          exitfn = (void *)tmp;
          }
        } else {
#line 1067
          exitfn = (void *)siglists[0];
#line 1068
          siglists[0] = (Eprog )((void *)0);
        }
#line 1070
        if (sigtrapped[0] & 1) {
#line 1071
          nsigtrapped --;
        }
#line 1072
        sigtrapped[0] = 0;
      }
    }
  }
#line 1075
  if (savetraps) {
    {
#line 1076
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1076
      ln = savetraps->list.first;
#line 1076
      if (ln) {
#line 1076
        st___0 = (struct savetrap *)ln->dat;
#line 1076
        if (st___0) {
#line 1076
          if (! (st___0->local > locallevel)) {
#line 1076
            goto while_break;
          }
        } else {
#line 1076
          goto while_break;
        }
      } else {
#line 1076
        goto while_break;
      }
      {
#line 1079
      sig = st___0->sig;
#line 1081
      remnode(savetraps, ln);
      }
#line 1083
      if (st___0->flags) {
#line 1083
        if ((unsigned long )st___0->list != (unsigned long )((void *)0)) {
#line 1085
          dontsavetrap ++;
#line 1086
          if (st___0->flags & (1 << 2)) {
            {
#line 1087
            settrap(sig, (Eprog )((void *)0), 1 << 2);
            }
          } else {
            {
#line 1089
            settrap(sig, (Eprog )st___0->list, 0);
            }
          }
#line 1090
          if (sig == 0) {
#line 1091
            exit_trap_posix = st___0->posix;
          }
#line 1092
          dontsavetrap --;
#line 1099
          tmp___0 = st___0->flags;
#line 1099
          sigtrapped[sig] = tmp___0;
#line 1099
          if (tmp___0 & (1 << 2)) {
            {
#line 1100
            (*(shfunctab->addnode))(shfunctab, ((Shfunc )st___0->list)->node.nam,
                                    (void *)((Shfunc )st___0->list));
            }
          }
        } else {
#line 1083
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1102
      if (sigtrapped[sig]) {
#line 1107
        if (sig != 0) {
          {
#line 1108
          unsettrap(sig);
          }
        } else
#line 1107
        if (! exit_trap_posix) {
          {
#line 1108
          unsettrap(sig);
          }
        }
      }
      {
#line 1111
      zfree((void *)st___0, (int )sizeof(*st___0));
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1115
  if (exittr) {
    {
#line 1121
    dotrapargs(0, & exittr, exitfn);
    }
#line 1122
    if (exittr & (1 << 2)) {
      {
#line 1123
      (*(shfunctab->freenode))((HashNode )exitfn);
      }
    } else {
      {
#line 1125
      freeeprog((Eprog )exitfn);
      }
    }
  }
#line 1129
  return;
}
}
#line 1141 "/tmp/zsh-5.4.2/Src/signals.c"
static int handletrap(int sig ) 
{ 
  int temp_rear ;
  int tmout ;
  zlong tmp ;

  {
#line 1144
  if (! sigtrapped[sig]) {
#line 1145
    return (0);
  }
#line 1147
  if (trap_queueing_enabled) {
#line 1150
    trap_queue_rear ++;
#line 1150
    temp_rear = trap_queue_rear % 128;
#line 1154
    if (temp_rear != trap_queue_front) {
#line 1155
      trap_queue_rear = temp_rear;
#line 1156
      trap_queue[trap_queue_rear] = sig;
    }
#line 1158
    return (1);
  }
  {
#line 1161
  dotrap(sig);
  }
#line 1163
  if (sig == 14) {
    {
#line 1172
    tmp = getiparam((char *)"TMOUT");
#line 1172
    tmout = (int )tmp;
    }
#line 1172
    if (tmout) {
      {
#line 1173
      alarm((unsigned int )tmout);
      }
    }
  }
#line 1176
  return (1);
}
}
#line 1193 "/tmp/zsh-5.4.2/Src/signals.c"
void queue_traps(int wait_cmd ) 
{ 


  {
#line 1196
  if (! opts[170]) {
#line 1196
    if (! wait_cmd) {
#line 1201
      trap_queueing_enabled = 1;
    }
  }
#line 1203
  return;
}
}
#line 1210 "/tmp/zsh-5.4.2/Src/signals.c"
void unqueue_traps(void) 
{ 


  {
#line 1213
  trap_queueing_enabled = 0;
  {
#line 1214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1214
    if (! (trap_queue_front != trap_queue_rear)) {
#line 1214
      goto while_break;
    }
    {
#line 1215
    trap_queue_front = (trap_queue_front + 1) % 128;
#line 1216
    handletrap(trap_queue[trap_queue_front]);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1218
  return;
}
}
#line 1250 "/tmp/zsh-5.4.2/Src/signals.c"
static void dotrapargs(int sig , int *sigtr , void *sigfn ) 
{ 
  LinkList args ;
  char *name ;
  char num[4] ;
  int obreaks ;
  int oretflag ;
  int olastval ;
  int isfunc ;
  int traperr ;
  int new_trap_state ;
  int new_trap_return ;
  int osc ;
  int old_incompfunc ;
  HashNode hn ;
  HashNode tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  sigset_t oset ;

  {
#line 1255
  obreaks = breaks;
#line 1256
  oretflag = retflag;
#line 1257
  olastval = (int )lastval;
#line 1271
  if (*sigtr & (1 << 1)) {
#line 1272
    return;
  } else
#line 1271
  if (! sigfn) {
#line 1272
    return;
  } else
#line 1271
  if (errflag) {
#line 1272
    return;
  }
#line 1282
  if (intrap) {
    {
#line 1286
    if (sig == 32) {
#line 1286
      goto case_32;
    }
#line 1286
    if (sig == 33) {
#line 1286
      goto case_32;
    }
#line 1286
    if (sig == 0) {
#line 1286
      goto case_32;
    }
#line 1283
    goto switch_break;
    case_32: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1287
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 1291
  queueing_enabled ++;
#line 1293
  intrap ++;
#line 1294
  *sigtr |= 1 << 1;
#line 1296
  zcontext_save();
#line 1298
  execsave();
#line 1299
  retflag = 0;
#line 1299
  breaks = retflag;
#line 1300
  traplocallevel = locallevel;
#line 1301
  runhookdef(zshhooks + 1, (void *)0);
  }
#line 1302
  if (*sigtr & (1 << 2)) {
    {
#line 1303
    osc = sfcontext;
#line 1303
    old_incompfunc = incompfunc;
#line 1304
    tmp = gettrapnode(sig, 0);
#line 1304
    hn = tmp;
#line 1306
    args = znewlinklist();
    }
#line 1314
    if (hn) {
      {
#line 1315
      name = ztrdup((char const   *)hn->nam);
      }
    } else {
      {
#line 1317
      tmp___0 = strlen((char const   *)sigs[sig]);
#line 1317
      tmp___1 = zalloc(5UL + tmp___0);
#line 1317
      name = (char *)tmp___1;
#line 1318
      sprintf((char */* __restrict  */)name, (char const   */* __restrict  */)"TRAP%s",
              sigs[sig]);
      }
    }
    {
#line 1320
    zinsertlinknode(args, args->list.last, (void *)name);
#line 1321
    sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)"%d",
            sig);
#line 1322
    zinsertlinknode(args, args->list.last, (void *)(num));
#line 1324
    trap_return = -1;
#line 1325
    trap_state = 1;
#line 1326
    isfunc = 1;
#line 1326
    trapisfunc = isfunc;
#line 1328
    sfcontext = 2;
#line 1329
    incompfunc = 0;
#line 1330
    doshfunc((Shfunc )sigfn, args, 1);
#line 1331
    sfcontext = osc;
#line 1332
    incompfunc = old_incompfunc;
#line 1333
    freelinklist(args, (void (*)(void * ))((void *)0));
#line 1334
    zsfree(name);
    }
  } else {
    {
#line 1336
    trap_return = -2;
#line 1337
    trap_state = 1;
#line 1338
    isfunc = 0;
#line 1338
    trapisfunc = isfunc;
#line 1340
    execode((Eprog )sigfn, 1, 0, (char *)"trap");
    }
  }
  {
#line 1342
  runhookdef(zshhooks + 2, (void *)0);
#line 1344
  traperr = errflag;
#line 1347
  new_trap_state = trap_state;
#line 1348
  new_trap_return = trap_return;
#line 1350
  execrestore();
#line 1351
  zcontext_restore();
  }
#line 1353
  if (new_trap_state == 2) {
#line 1353
    if (isfunc) {
#line 1353
      if (new_trap_return == 0) {
#line 1353
        goto _L;
      } else {
#line 1353
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1356
      if (isfunc) {
#line 1357
        breaks = loops;
#line 1366
        if (sig == 2) {
#line 1367
          errflag |= 2;
        } else
#line 1366
        if (sig == 3) {
#line 1367
          errflag |= 2;
        } else {
#line 1369
          errflag |= 1;
        }
      }
#line 1371
      lastval = (zlong )new_trap_return;
#line 1373
      retflag = 1;
    }
  } else {
    _L: /* CIL Label */ 
#line 1375
    if (traperr) {
#line 1375
      if (! (emulation & (1 << 3))) {
#line 1376
        lastval = (zlong )1;
      } else {
#line 1382
        lastval = (zlong )olastval;
      }
    } else {
#line 1382
      lastval = (zlong )olastval;
    }
#line 1384
    if (try_tryflag) {
#line 1385
      if (traperr) {
#line 1386
        errflag |= 1;
      } else {
#line 1388
        errflag &= -2;
      }
    }
#line 1390
    breaks += obreaks;
#line 1392
    retflag = oretflag;
#line 1393
    if (breaks > loops) {
#line 1394
      breaks = loops;
    }
  }
#line 1401
  if (zleactive) {
#line 1401
    if (resetneeded) {
      {
#line 1402
      zleentry(5);
      }
    }
  }
#line 1404
  if (*sigtr != 1 << 1) {
#line 1405
    *sigtr &= ~ (1 << 1);
  }
#line 1406
  intrap --;
  {
#line 1408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1408
    queueing_enabled --;
#line 1408
    if (! queueing_enabled) {
      {
#line 1408
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1408
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1408
          if (! (queue_front != queue_rear)) {
#line 1408
            goto while_break___1;
          }
          {
#line 1408
          queue_front = (queue_front + 1) % 128;
#line 1408
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1408
          zhandler(signal_queue[queue_front]);
#line 1408
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1408
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1408
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1409
  return;
}
}
#line 1414 "/tmp/zsh-5.4.2/Src/signals.c"
void dotrap(int sig ) 
{ 
  void *funcprog ;
  int q ;
  HashNode hn ;
  HashNode tmp ;
  sigset_t oset ;

  {
#line 1418
  q = queueing_enabled;
#line 1420
  if (sigtrapped[sig] & (1 << 2)) {
    {
#line 1421
    tmp = gettrapnode(sig, 0);
#line 1421
    hn = tmp;
    }
#line 1422
    if (hn) {
#line 1423
      funcprog = (void *)hn;
    } else {
#line 1428
      funcprog = (void *)0;
    }
  } else {
#line 1431
    funcprog = (void *)siglists[sig];
  }
#line 1438
  if (sigtrapped[sig] & (1 << 1)) {
#line 1439
    return;
  } else
#line 1438
  if (! funcprog) {
#line 1439
    return;
  } else
#line 1438
  if (errflag) {
#line 1439
    return;
  }
  {
#line 1441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1441
    queueing_enabled = 0;
    {
#line 1441
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1441
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1441
        if (! (queue_front != queue_rear)) {
#line 1441
          goto while_break___1;
        }
        {
#line 1441
        queue_front = (queue_front + 1) % 128;
#line 1441
        oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1441
        zhandler(signal_queue[queue_front]);
#line 1441
        signal_setmask(oset);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1441
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1441
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1443
  if (sig == 0) {
#line 1444
    in_exit_trap ++;
  }
  {
#line 1446
  dotrapargs(sig, sigtrapped + sig, funcprog);
  }
#line 1448
  if (sig == 0) {
#line 1449
    in_exit_trap --;
  }
#line 1451
  queueing_enabled = q;
#line 1452
  return;
}
}
#line 687 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 788 "/usr/include/term.h"
extern char *tgoto(char const   * , int  , int  ) ;
#line 791
extern int tgetnum(char const   * ) ;
#line 792
extern int tputs(char const   * , int  , int (*)(int  ) ) ;
#line 27 "./exec.epro"
Funcstack funcstack ;
#line 15 "./hist.epro"
zlong curhist ;
#line 12 "./init.epro"
char *tcstr[34] ;
#line 13
int tclen[34] ;
#line 20
int tccolours ;
#line 28
int init_term(void) ;
#line 11 "./params.epro"
char **psvar ;
#line 36
char *ttystrname ;
#line 48
zlong shlvl ;
#line 53
struct timeval shtimer ;
#line 195
void convbase(char *s , zlong v , int base ) ;
#line 5 "./prompt.epro"
unsigned int txtattrmask  ;
#line 6 "./prompt.epro"
unsigned char *cmdstack  ;
#line 7 "./prompt.epro"
int cmdsp  ;
#line 9
void stradd(char *d___0 ) ;
#line 11
int putstr(int d___0 ) ;
#line 13
void cmdpush(int cmdtok ) ;
#line 14
void cmdpop(void) ;
#line 15
int match_colour(char const   **teststrp , int is_fg , int colour ) ;
#line 16
void match_highlight(char const   *teststr , int *on_var ) ;
#line 17
int output_highlight(int atr , char *buf___7 ) ;
#line 18
void set_default_colour_sequences(void) ;
#line 19
void allocate_colour_buffer(void) ;
#line 20
void free_colour_buffer(void) ;
#line 21
void set_colour_attribute(int atr , int fg_bg , int flags ) ;
#line 2 "./prompt.pro"
static int putpromptchar(int doprint , int endchar , unsigned int *txtchangep ) ;
#line 3
static void pputc(char c ) ;
#line 4
static void addbufspc(int need ) ;
#line 5
static int prompttrunc(int arg , int truncchar , int doprint , int endchar , unsigned int *txtchangep ) ;
#line 47 "/tmp/zsh-5.4.2/Src/prompt.c"
static char *cmdnames[32]  = 
#line 47 "/tmp/zsh-5.4.2/Src/prompt.c"
  {      (char *)"for",      (char *)"while",      (char *)"repeat",      (char *)"select", 
        (char *)"until",      (char *)"if",      (char *)"then",      (char *)"else", 
        (char *)"elif",      (char *)"math",      (char *)"cond",      (char *)"cmdor", 
        (char *)"cmdand",      (char *)"pipe",      (char *)"errpipe",      (char *)"foreach", 
        (char *)"case",      (char *)"function",      (char *)"subsh",      (char *)"cursh", 
        (char *)"array",      (char *)"quote",      (char *)"dquote",      (char *)"bquote", 
        (char *)"cmdsubst",      (char *)"mathsubst",      (char *)"elif-then",      (char *)"heredoc", 
        (char *)"heredocd",      (char *)"brace",      (char *)"braceparam",      (char *)"always"};
#line 111 "/tmp/zsh-5.4.2/Src/prompt.c"
static Buf_vars bv  ;
#line 118 "/tmp/zsh-5.4.2/Src/prompt.c"
static void promptpath(char *p , int npath , int tilde ) 
{ 
  char *modp ;
  Nameddir nd ;
  size_t tmp ;
  char *sptr ;
  size_t tmp___0 ;
  char cbu ;

  {
#line 121
  modp = p;
#line 124
  if (tilde) {
    {
#line 124
    nd = finddir(p);
    }
#line 124
    if (nd) {
      {
#line 125
      tmp = strlen((char const   *)nd->dir);
#line 125
      modp = tricat("~", (char const   *)nd->node.nam, (char const   *)(p + tmp));
      }
    }
  }
#line 127
  if (npath) {
#line 129
    if (npath > 0) {
      {
#line 130
      tmp___0 = strlen((char const   *)modp);
#line 130
      sptr = modp + tmp___0;
      }
      {
#line 130
      while (1) {
        while_continue: /* CIL Label */ ;
#line 130
        if (! ((unsigned long )sptr > (unsigned long )modp)) {
#line 130
          goto while_break;
        }
#line 131
        if ((int )*sptr == 47) {
#line 131
          npath --;
#line 131
          if (! npath) {
#line 132
            sptr ++;
#line 133
            goto while_break;
          }
        }
#line 130
        sptr --;
      }
      while_break: /* CIL Label */ ;
      }
#line 136
      if ((int )*sptr == 47) {
#line 136
        if (*(sptr + 1)) {
#line 136
          if ((unsigned long )sptr != (unsigned long )modp) {
#line 137
            sptr ++;
          }
        }
      }
      {
#line 138
      stradd(sptr);
      }
    } else {
#line 141
      sptr = modp + 1;
      {
#line 141
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 141
        if (! *sptr) {
#line 141
          goto while_break___0;
        }
#line 142
        if ((int )*sptr == 47) {
#line 142
          npath ++;
#line 142
          if (! npath) {
#line 143
            goto while_break___0;
          }
        }
#line 141
        sptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 144
      cbu = *sptr;
#line 145
      *sptr = (char)0;
#line 146
      stradd(modp);
#line 147
      *sptr = cbu;
      }
    }
  } else {
    {
#line 150
    stradd(modp);
    }
  }
#line 152
  if ((unsigned long )p != (unsigned long )modp) {
    {
#line 153
    zsfree(modp);
    }
  }
#line 154
  return;
}
}
#line 170 "/tmp/zsh-5.4.2/Src/prompt.c"
char *promptexpand(char *s , int ns , char *rs , char *Rs , unsigned int *txtchangep ) 
{ 
  struct buf_vars new_vars ;
  char *tmp ;
  int olderr ;
  int oldval ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
#line 175
  if (! s) {
    {
#line 176
    tmp = ztrdup("");
    }
#line 176
    return (tmp);
  }
#line 178
  if (termflags & 2) {
#line 178
    if (! opts[93]) {
      {
#line 179
      init_term();
      }
    }
  }
#line 181
  if (opts[144]) {
    {
#line 182
    olderr = errflag;
#line 183
    oldval = (int )lastval;
#line 185
    s = dupstring((char const   *)s);
#line 186
    tmp___0 = parsestr(& s);
    }
#line 186
    if (! tmp___0) {
      {
#line 187
      singsub(& s);
      }
    }
#line 192
    if ((int )*s == -95) {
#line 192
      if ((int )*(s + 1) == 0) {
#line 193
        *s = (char )'\000';
      }
    }
#line 199
    errflag = olderr | (errflag & 2);
#line 200
    lastval = (zlong )oldval;
  }
  {
#line 203
  memset((void *)(& new_vars), 0, sizeof(new_vars));
#line 204
  new_vars.last = bv;
#line 205
  bv = & new_vars;
#line 207
  new_vars.rstring = rs;
#line 208
  new_vars.Rstring = Rs;
#line 209
  new_vars.fm = s;
#line 210
  new_vars.bufspc = 256;
#line 211
  tmp___1 = zshcalloc((size_t )new_vars.bufspc);
#line 211
  new_vars.buf = (char *)tmp___1;
#line 211
  new_vars.bufline = new_vars.buf;
#line 211
  new_vars.bp = new_vars.bufline;
#line 212
  new_vars.bp1 = (char *)((void *)0);
#line 213
  new_vars.truncwidth = 0;
#line 215
  putpromptchar(1, '\000', txtchangep);
#line 216
  addbufspc(2);
  }
#line 217
  if (new_vars.dontcount) {
#line 218
    tmp___2 = new_vars.bp;
#line 218
    (new_vars.bp) ++;
#line 218
    *tmp___2 = (char)-118;
  }
#line 219
  *(new_vars.bp) = (char )'\000';
#line 220
  if (! ns) {
#line 222
    new_vars.bp = new_vars.buf;
    {
#line 222
    while (1) {
      while_continue: /* CIL Label */ ;
#line 222
      if (! *(new_vars.bp)) {
#line 222
        goto while_break;
      }
#line 223
      if ((int )*(new_vars.bp) == -125) {
#line 224
        new_vars.bp += 2;
      } else
#line 225
      if ((int )*(new_vars.bp) == -120) {
        {
#line 227
        chuck(new_vars.bp);
        }
      } else
#line 225
      if ((int )*(new_vars.bp) == -118) {
        {
#line 227
        chuck(new_vars.bp);
        }
      } else
#line 225
      if ((int )*(new_vars.bp) == -95) {
        {
#line 227
        chuck(new_vars.bp);
        }
      } else {
#line 229
        (new_vars.bp) ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 233
  bv = new_vars.last;
#line 235
  return (new_vars.buf);
}
}
#line 239 "/tmp/zsh-5.4.2/Src/prompt.c"
static int parsecolorchar(int arg , int is_fg ) 
{ 
  char *ep___0 ;
  char oc ;
  char *col ;
  char *coll ;

  {
#line 242
  if ((int )*(bv->fm + 1) == 123) {
    {
#line 244
    bv->fm += 2;
#line 245
    ep___0 = strchr((char const   *)bv->fm, '}');
    }
#line 245
    if (ep___0) {
      {
#line 246
      oc = *ep___0;
#line 247
      *ep___0 = (char )'\000';
#line 250
      col = promptexpand(bv->fm, 0, (char *)((void *)0), (char *)((void *)0), (unsigned int *)((void *)0));
#line 250
      coll = col;
#line 251
      *ep___0 = oc;
#line 252
      arg = match_colour((char const   **)(& coll), is_fg, 0);
#line 253
      free((void *)col);
#line 254
      bv->fm = ep___0;
      }
    } else {
      {
#line 256
      arg = match_colour((char const   **)(& bv->fm), is_fg, 0);
      }
#line 257
      if ((int )*(bv->fm) != 125) {
#line 258
        (bv->fm) --;
      }
    }
  } else {
    {
#line 261
    arg = match_colour((char const   **)((void *)0), 1, arg);
    }
  }
#line 262
  return (arg);
}
}
#line 270 "/tmp/zsh-5.4.2/Src/prompt.c"
static int putpromptchar(int doprint , int endchar , unsigned int *txtchangep ) 
{ 
  char *ss ;
  char *hostnam ;
  int t0 ;
  int arg ;
  int test ;
  int sep ;
  int j ;
  int numjobs ;
  int len ;
  struct tm *tm ;
  struct timezone dummy_tz ;
  struct timeval tv ;
  time_t timet ;
  Nameddir nd ;
  int minus ;
  zlong tmp ;
  int tc ;
  int otruncwidth ;
  zlong tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  __uid_t tmp___3 ;
  __gid_t tmp___4 ;
  Funcstack fsptr ;
  time_t tmp___5 ;
  char tmp___6 ;
  int tmp___7 ;
  char tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  sigset_t oset ;
  sigset_t oset___0 ;
  size_t tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  sigset_t oset___1 ;
  unsigned int tmp___21 ;
  int tmp___22 ;
  unsigned int tmp___23 ;
  int tmp___24 ;
  unsigned int tmp___25 ;
  int tmp___26 ;
  unsigned int tmp___27 ;
  int tmp___28 ;
  unsigned int tmp___29 ;
  int tmp___30 ;
  unsigned int tmp___31 ;
  int tmp___32 ;
  unsigned int tmp___33 ;
  int tmp___34 ;
  unsigned int tmp___35 ;
  int tmp___36 ;
  unsigned int tmp___37 ;
  int tmp___38 ;
  unsigned int tmp___39 ;
  int tmp___40 ;
  zlong tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;
  char *tmp___46 ;
  int tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmfmt ;
  char *dd ;
  char *tmbuf ;
  void *tmp___50 ;
  char *tmp___51 ;
  size_t tmp___52 ;
  size_t tmp___53 ;
  char *tmp___54 ;
  int tmp___56 ;
  int tmp___58 ;
  size_t tmp___59 ;
  size_t tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  int tmp___64 ;
  int tmp___65 ;
  char tmp___66 ;
  char *tmp___67 ;
  int tmp___68 ;
  char *tmp___69 ;
  int tmp___70 ;
  char *tmp___71 ;
  int tmp___72 ;
  char *tmp___73 ;
  int tmp___74 ;
  int depth ;
  Funcstack fsptr___0 ;
  size_t tmp___75 ;
  zlong flineno ;
  size_t tmp___76 ;
  size_t tmp___77 ;
  char const   *tmp___78 ;
  char *tmp___79 ;
  size_t tmp___80 ;
  char c ;
  int tmp___81 ;

  {
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (*(bv->fm)) {
#line 281
      if (! ((int )*(bv->fm) != endchar)) {
#line 281
        goto while_break;
      }
    } else {
#line 281
      goto while_break;
    }
#line 282
    arg = 0;
#line 283
    if ((int )*(bv->fm) == 37) {
#line 283
      if (opts[142]) {
#line 284
        minus = 0;
#line 285
        (bv->fm) ++;
#line 286
        if ((int )*(bv->fm) == 45) {
#line 287
          minus = 1;
#line 288
          (bv->fm) ++;
        }
#line 290
        if ((int )typtab[(unsigned char )*(bv->fm)] & 1) {
          {
#line 291
          tmp = zstrtol((char const   *)bv->fm, & bv->fm, 10);
#line 291
          arg = (int )tmp;
          }
#line 292
          if (minus) {
#line 293
            arg *= -1;
          }
        } else
#line 294
        if (minus) {
#line 295
          arg = -1;
        }
#line 296
        if ((int )*(bv->fm) == 40) {
#line 299
          (bv->fm) ++;
#line 299
          if ((int )typtab[(unsigned char )*(bv->fm)] & 1) {
            {
#line 300
            tmp___0 = zstrtol((char const   *)bv->fm, & bv->fm, 10);
#line 300
            arg = (int )tmp___0;
            }
          } else
#line 301
          if (arg < 0) {
#line 303
            arg *= -1;
          }
#line 305
          test = 0;
#line 306
          ss = pwd;
#line 307
          tc = (int )*(bv->fm);
          {
#line 310
          if (tc == 126) {
#line 310
            goto case_126;
          }
#line 310
          if (tc == 46) {
#line 310
            goto case_126;
          }
#line 310
          if (tc == 99) {
#line 310
            goto case_126;
          }
#line 316
          if (tc == 67) {
#line 316
            goto case_67;
          }
#line 316
          if (tc == 47) {
#line 316
            goto case_67;
          }
#line 330
          if (tc == 119) {
#line 330
            goto case_119;
          }
#line 330
          if (tc == 68) {
#line 330
            goto case_119;
          }
#line 330
          if (tc == 100) {
#line 330
            goto case_119;
          }
#line 330
          if (tc == 84) {
#line 330
            goto case_119;
          }
#line 330
          if (tc == 116) {
#line 330
            goto case_119;
          }
#line 351
          if (tc == 63) {
#line 351
            goto case_63;
          }
#line 355
          if (tc == 35) {
#line 355
            goto case_35;
          }
#line 359
          if (tc == 103) {
#line 359
            goto case_103;
          }
#line 363
          if (tc == 106) {
#line 363
            goto case_106;
          }
#line 370
          if (tc == 108) {
#line 370
            goto case_108;
          }
#line 378
          if (tc == 101) {
#line 378
            goto case_101;
          }
#line 389
          if (tc == 76) {
#line 389
            goto case_76;
          }
#line 393
          if (tc == 83) {
#line 393
            goto case_83;
          }
#line 397
          if (tc == 118) {
#line 397
            goto case_118;
          }
#line 401
          if (tc == 86) {
#line 401
            goto case_86;
          }
#line 407
          if (tc == 95) {
#line 407
            goto case_95;
          }
#line 410
          if (tc == 33) {
#line 410
            goto case_33;
          }
#line 413
          goto switch_default;
          case_126: /* CIL Label */ 
          case_46: /* CIL Label */ 
          case_99: /* CIL Label */ 
          {
#line 311
          nd = finddir(ss);
          }
#line 311
          if (nd) {
            {
#line 312
            arg --;
#line 313
            tmp___1 = strlen((char const   *)nd->dir);
#line 313
            ss += tmp___1;
            }
          }
          case_67: /* CIL Label */ 
          case_47: /* CIL Label */ 
#line 318
          tmp___2 = ss;
#line 318
          ss ++;
#line 318
          if ((int )*tmp___2 == 47) {
#line 318
            if (*ss) {
#line 319
              arg --;
            }
          }
          {
#line 320
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 320
            if (! *ss) {
#line 320
              goto while_break___0;
            }
#line 321
            if ((int )*ss == 47) {
#line 322
              arg --;
            }
#line 320
            ss ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 323
          if (arg <= 0) {
#line 324
            test = 1;
          }
#line 325
          goto switch_break;
          case_119: /* CIL Label */ 
          case_68: /* CIL Label */ 
          case_100: /* CIL Label */ 
          case_84: /* CIL Label */ 
          case_116: /* CIL Label */ 
          {
#line 331
          timet = time((time_t *)((void *)0));
#line 332
          tm = localtime((time_t const   *)(& timet));
          }
          {
#line 334
          if (tc == 116) {
#line 334
            goto case_116___0;
          }
#line 337
          if (tc == 84) {
#line 337
            goto case_84___0;
          }
#line 340
          if (tc == 100) {
#line 340
            goto case_100___0;
          }
#line 343
          if (tc == 68) {
#line 343
            goto case_68___0;
          }
#line 346
          if (tc == 119) {
#line 346
            goto case_119___0;
          }
#line 333
          goto switch_break___0;
          case_116___0: /* CIL Label */ 
#line 335
          test = arg == tm->tm_min;
#line 336
          goto switch_break___0;
          case_84___0: /* CIL Label */ 
#line 338
          test = arg == tm->tm_hour;
#line 339
          goto switch_break___0;
          case_100___0: /* CIL Label */ 
#line 341
          test = arg == tm->tm_mday;
#line 342
          goto switch_break___0;
          case_68___0: /* CIL Label */ 
#line 344
          test = arg == tm->tm_mon;
#line 345
          goto switch_break___0;
          case_119___0: /* CIL Label */ 
#line 347
          test = arg == tm->tm_wday;
#line 348
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
#line 350
          goto switch_break;
          case_63: /* CIL Label */ 
#line 352
          if (lastval == (zlong )arg) {
#line 353
            test = 1;
          }
#line 354
          goto switch_break;
          case_35: /* CIL Label */ 
          {
#line 356
          tmp___3 = geteuid();
          }
#line 356
          if (tmp___3 == (uid_t )arg) {
#line 357
            test = 1;
          }
#line 358
          goto switch_break;
          case_103: /* CIL Label */ 
          {
#line 360
          tmp___4 = getegid();
          }
#line 360
          if (tmp___4 == (gid_t )arg) {
#line 361
            test = 1;
          }
#line 362
          goto switch_break;
          case_106: /* CIL Label */ 
#line 364
          numjobs = 0;
#line 364
          j = 1;
          {
#line 364
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 364
            if (! (j <= maxjob)) {
#line 364
              goto while_break___1;
            }
#line 365
            if ((jobtab + j)->stat) {
#line 365
              if ((jobtab + j)->procs) {
#line 365
                if (! ((jobtab + j)->stat & 32)) {
#line 366
                  numjobs ++;
                }
              }
            }
#line 364
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 367
          if (numjobs >= arg) {
#line 368
            test = 1;
          }
#line 369
          goto switch_break;
          case_108: /* CIL Label */ 
          {
#line 371
          *(bv->bp) = (char )'\000';
#line 372
          countprompt(bv->bufline, & t0, (int *)0, 0);
          }
#line 373
          if (minus) {
#line 374
            t0 = (int )(zterm_columns - (zlong )t0);
          }
#line 375
          if (t0 >= arg) {
#line 376
            test = 1;
          }
#line 377
          goto switch_break;
          case_101: /* CIL Label */ 
#line 380
          fsptr = funcstack;
#line 381
          test = arg;
          {
#line 382
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 382
            if (fsptr) {
#line 382
              if (! (test > 0)) {
#line 382
                goto while_break___2;
              }
            } else {
#line 382
              goto while_break___2;
            }
#line 383
            test --;
#line 384
            fsptr = fsptr->prev;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 386
          test = ! test;
#line 388
          goto switch_break;
          case_76: /* CIL Label */ 
#line 390
          if (shlvl >= (zlong )arg) {
#line 391
            test = 1;
          }
#line 392
          goto switch_break;
          case_83: /* CIL Label */ 
          {
#line 394
          tmp___5 = time((time_t *)((void *)0));
          }
#line 394
          if (tmp___5 - shtimer.tv_sec >= (time_t )arg) {
#line 395
            test = 1;
          }
#line 396
          goto switch_break;
          case_118: /* CIL Label */ 
          {
#line 398
          tmp___6 = arrlen_ge(psvar, (unsigned int )arg);
          }
#line 398
          if (tmp___6) {
#line 399
            test = 1;
          }
#line 400
          goto switch_break;
          case_86: /* CIL Label */ 
#line 402
          if (psvar) {
#line 402
            if (*psvar) {
              {
#line 402
              tmp___8 = arrlen_ge(psvar, (unsigned int )arg);
              }
#line 402
              if (tmp___8) {
#line 403
                if (arg) {
#line 403
                  tmp___7 = arg;
                } else {
#line 403
                  tmp___7 = 1;
                }
#line 403
                if (*(*(psvar + (tmp___7 - 1)))) {
#line 404
                  test = 1;
                }
              }
            }
          }
#line 406
          goto switch_break;
          case_95: /* CIL Label */ 
#line 408
          test = cmdsp >= arg;
#line 409
          goto switch_break;
          case_33: /* CIL Label */ 
          {
#line 411
          test = privasserted();
          }
#line 412
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 414
          test = -1;
#line 415
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 417
          if (! *(bv->fm)) {
#line 418
            return (0);
          } else {
#line 417
            (bv->fm) ++;
#line 417
            sep = (int )*(bv->fm);
#line 417
            if (! sep) {
#line 418
              return (0);
            }
          }
#line 419
          (bv->fm) ++;
#line 421
          otruncwidth = bv->truncwidth;
#line 422
          bv->truncwidth = 0;
#line 423
          if (test == 1) {
#line 423
            if (doprint) {
#line 423
              tmp___9 = 1;
            } else {
#line 423
              tmp___9 = 0;
            }
          } else {
#line 423
            tmp___9 = 0;
          }
          {
#line 423
          tmp___10 = putpromptchar(tmp___9, sep, txtchangep);
          }
#line 423
          if (tmp___10) {
#line 423
            (bv->fm) ++;
#line 423
            if (*(bv->fm)) {
#line 423
              if (test == 0) {
#line 423
                if (doprint) {
#line 423
                  tmp___11 = 1;
                } else {
#line 423
                  tmp___11 = 0;
                }
              } else {
#line 423
                tmp___11 = 0;
              }
              {
#line 423
              tmp___12 = putpromptchar(tmp___11, ')', txtchangep);
              }
#line 423
              if (! tmp___12) {
#line 427
                bv->truncwidth = otruncwidth;
#line 428
                return (0);
              }
            } else {
#line 427
              bv->truncwidth = otruncwidth;
#line 428
              return (0);
            }
          } else {
#line 427
            bv->truncwidth = otruncwidth;
#line 428
            return (0);
          }
#line 430
          bv->truncwidth = otruncwidth;
#line 431
          goto __Cont;
        }
#line 433
        if (! doprint) {
          {
#line 435
          if ((int )*(bv->fm) == 91) {
#line 435
            goto case_91;
          }
#line 439
          if ((int )*(bv->fm) == 60) {
#line 439
            goto case_60;
          }
#line 442
          if ((int )*(bv->fm) == 62) {
#line 442
            goto case_62;
          }
#line 445
          if ((int )*(bv->fm) == 68) {
#line 445
            goto case_68___1;
          }
#line 449
          goto switch_default___0;
          case_91: /* CIL Label */ 
          {
#line 436
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 436
            (bv->fm) ++;
#line 436
            if (! ((int )typtab[(unsigned char )*(bv->fm)] & 1)) {
#line 436
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 437
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 437
            (bv->fm) ++;
#line 437
            if (! ((int )*(bv->fm) != 93)) {
#line 437
              goto while_break___4;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 438
          goto __Cont;
          case_60: /* CIL Label */ 
          {
#line 440
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 440
            (bv->fm) ++;
#line 440
            if (! ((int )*(bv->fm) != 60)) {
#line 440
              goto while_break___5;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 441
          goto __Cont;
          case_62: /* CIL Label */ 
          {
#line 443
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 443
            (bv->fm) ++;
#line 443
            if (! ((int )*(bv->fm) != 62)) {
#line 443
              goto while_break___6;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
#line 444
          goto __Cont;
          case_68___1: /* CIL Label */ 
#line 446
          if ((int )*(bv->fm + 1) == 123) {
            {
#line 447
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 447
              (bv->fm) ++;
#line 447
              if (! ((int )*(bv->fm) != 125)) {
#line 447
                goto while_break___7;
              }
            }
            while_break___7: /* CIL Label */ ;
            }
          }
#line 448
          goto __Cont;
          switch_default___0: /* CIL Label */ 
#line 450
          goto __Cont;
          switch_break___1: /* CIL Label */ ;
          }
        }
        {
#line 453
        if ((int )*(bv->fm) == 126) {
#line 453
          goto case_126___0;
        }
#line 457
        if ((int )*(bv->fm) == 47) {
#line 457
          goto case_47___0;
        }
#line 457
        if ((int )*(bv->fm) == 100) {
#line 457
          goto case_47___0;
        }
#line 461
        if ((int )*(bv->fm) == 46) {
#line 461
          goto case_46___0;
        }
#line 461
        if ((int )*(bv->fm) == 99) {
#line 461
          goto case_46___0;
        }
#line 464
        if ((int )*(bv->fm) == 67) {
#line 464
          goto case_67___0;
        }
#line 467
        if ((int )*(bv->fm) == 78) {
#line 467
          goto case_78;
        }
#line 471
        if ((int )*(bv->fm) == 33) {
#line 471
          goto case_33___0;
        }
#line 471
        if ((int )*(bv->fm) == 104) {
#line 471
          goto case_33___0;
        }
#line 476
        if ((int )*(bv->fm) == 106) {
#line 476
          goto case_106___0;
        }
#line 484
        if ((int )*(bv->fm) == 77) {
#line 484
          goto case_77;
        }
#line 490
        if ((int )*(bv->fm) == 109) {
#line 490
          goto case_109;
        }
#line 511
        if ((int )*(bv->fm) == 83) {
#line 511
          goto case_83___0;
        }
#line 516
        if ((int )*(bv->fm) == 115) {
#line 516
          goto case_115;
        }
#line 521
        if ((int )*(bv->fm) == 66) {
#line 521
          goto case_66;
        }
#line 526
        if ((int )*(bv->fm) == 98) {
#line 526
          goto case_98;
        }
#line 531
        if ((int )*(bv->fm) == 85) {
#line 531
          goto case_85;
        }
#line 536
        if ((int )*(bv->fm) == 117) {
#line 536
          goto case_117;
        }
#line 541
        if ((int )*(bv->fm) == 70) {
#line 541
          goto case_70;
        }
#line 552
        if ((int )*(bv->fm) == 102) {
#line 552
          goto case_102;
        }
#line 557
        if ((int )*(bv->fm) == 75) {
#line 557
          goto case_75;
        }
#line 568
        if ((int )*(bv->fm) == 107) {
#line 568
          goto case_107;
        }
#line 573
        if ((int )*(bv->fm) == 91) {
#line 573
          goto case_91___0;
        }
#line 580
        if ((int )*(bv->fm) == 62) {
#line 580
          goto case_62___0;
        }
#line 580
        if ((int )*(bv->fm) == 60) {
#line 580
          goto case_62___0;
        }
#line 592
        if ((int )*(bv->fm) == 123) {
#line 592
          goto case_123;
        }
#line 601
        if ((int )*(bv->fm) == 71) {
#line 601
          goto case_71;
        }
#line 611
        if ((int )*(bv->fm) == 125) {
#line 611
          goto case_125;
        }
#line 625
        if ((int )*(bv->fm) == 68) {
#line 625
          goto case_68___2;
        }
#line 625
        if ((int )*(bv->fm) == 87) {
#line 625
          goto case_68___2;
        }
#line 625
        if ((int )*(bv->fm) == 119) {
#line 625
          goto case_68___2;
        }
#line 625
        if ((int )*(bv->fm) == 42) {
#line 625
          goto case_68___2;
        }
#line 625
        if ((int )*(bv->fm) == 84) {
#line 625
          goto case_68___2;
        }
#line 625
        if ((int )*(bv->fm) == 64) {
#line 625
          goto case_68___2;
        }
#line 625
        if ((int )*(bv->fm) == 116) {
#line 625
          goto case_68___2;
        }
#line 690
        if ((int )*(bv->fm) == 110) {
#line 690
          goto case_110;
        }
#line 693
        if ((int )*(bv->fm) == 108) {
#line 693
          goto case_108___0;
        }
#line 701
        if ((int )*(bv->fm) == 121) {
#line 701
          goto case_121;
        }
#line 709
        if ((int )*(bv->fm) == 76) {
#line 709
          goto case_76___0;
        }
#line 718
        if ((int )*(bv->fm) == 63) {
#line 718
          goto case_63___0;
        }
#line 728
        if ((int )*(bv->fm) == 41) {
#line 728
          goto case_41;
        }
#line 728
        if ((int )*(bv->fm) == 37) {
#line 728
          goto case_41;
        }
#line 732
        if ((int )*(bv->fm) == 35) {
#line 732
          goto case_35___0;
        }
#line 736
        if ((int )*(bv->fm) == 118) {
#line 736
          goto case_118___0;
        }
#line 744
        if ((int )*(bv->fm) == 69) {
#line 744
          goto case_69;
        }
#line 747
        if ((int )*(bv->fm) == 94) {
#line 747
          goto case_94;
        }
#line 773
        if ((int )*(bv->fm) == 95) {
#line 773
          goto case_95___0;
        }
#line 799
        if ((int )*(bv->fm) == 114) {
#line 799
          goto case_114;
        }
#line 803
        if ((int )*(bv->fm) == 82) {
#line 803
          goto case_82;
        }
#line 807
        if ((int )*(bv->fm) == 101) {
#line 807
          goto case_101___0;
        }
#line 820
        if ((int )*(bv->fm) == 73) {
#line 820
          goto case_73;
        }
#line 843
        if ((int )*(bv->fm) == 105) {
#line 843
          goto case_105;
        }
#line 852
        if ((int )*(bv->fm) == 120) {
#line 852
          goto case_120;
        }
#line 861
        if ((int )*(bv->fm) == 0) {
#line 861
          goto case_0;
        }
#line 863
        if ((int )*(bv->fm) == -125) {
#line 863
          goto case_neg_125;
        }
#line 452
        goto switch_break___2;
        case_126___0: /* CIL Label */ 
        {
#line 454
        promptpath(pwd, arg, 1);
        }
#line 455
        goto switch_break___2;
        case_47___0: /* CIL Label */ 
        case_100___1: /* CIL Label */ 
        {
#line 458
        promptpath(pwd, arg, 0);
        }
#line 459
        goto switch_break___2;
        case_46___0: /* CIL Label */ 
        case_99___0: /* CIL Label */ 
#line 462
        if (arg) {
#line 462
          tmp___13 = arg;
        } else {
#line 462
          tmp___13 = 1;
        }
        {
#line 462
        promptpath(pwd, tmp___13, 1);
        }
#line 463
        goto switch_break___2;
        case_67___0: /* CIL Label */ 
#line 465
        if (arg) {
#line 465
          tmp___14 = arg;
        } else {
#line 465
          tmp___14 = 1;
        }
        {
#line 465
        promptpath(pwd, tmp___14, 0);
        }
#line 466
        goto switch_break___2;
        case_78: /* CIL Label */ 
#line 468
        if (scriptname) {
#line 468
          tmp___15 = scriptname;
        } else {
#line 468
          tmp___15 = argzero;
        }
        {
#line 468
        promptpath(tmp___15, arg, 0);
        }
#line 469
        goto switch_break___2;
        case_33___0: /* CIL Label */ 
        case_104: /* CIL Label */ 
        {
#line 472
        addbufspc((int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3);
#line 473
        convbase(bv->bp, curhist, 10);
#line 474
        tmp___16 = strlen((char const   *)bv->bp);
#line 474
        bv->bp += tmp___16;
        }
#line 475
        goto switch_break___2;
        case_106___0: /* CIL Label */ 
#line 477
        numjobs = 0;
#line 477
        j = 1;
        {
#line 477
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 477
          if (! (j <= maxjob)) {
#line 477
            goto while_break___8;
          }
#line 478
          if ((jobtab + j)->stat) {
#line 478
            if ((jobtab + j)->procs) {
#line 478
              if (! ((jobtab + j)->stat & 32)) {
#line 479
                numjobs ++;
              }
            }
          }
#line 477
          j ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 480
        addbufspc((int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3);
#line 481
        sprintf((char */* __restrict  */)bv->bp, (char const   */* __restrict  */)"%d",
                numjobs);
#line 482
        tmp___17 = strlen((char const   *)bv->bp);
#line 482
        bv->bp += tmp___17;
        }
#line 483
        goto switch_break___2;
        case_77: /* CIL Label */ 
        {
#line 485
        queueing_enabled ++;
#line 486
        hostnam = getsparam((char *)"HOST");
        }
#line 486
        if (hostnam) {
          {
#line 487
          stradd(hostnam);
          }
        }
        {
#line 488
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 488
          queueing_enabled --;
#line 488
          if (! queueing_enabled) {
            {
#line 488
            while (1) {
              while_continue___10: /* CIL Label */ ;
              {
#line 488
              while (1) {
                while_continue___11: /* CIL Label */ ;
#line 488
                if (! (queue_front != queue_rear)) {
#line 488
                  goto while_break___11;
                }
                {
#line 488
                queue_front = (queue_front + 1) % 128;
#line 488
                oset = signal_setmask(signal_mask_queue[queue_front]);
#line 488
                zhandler(signal_queue[queue_front]);
#line 488
                signal_setmask(oset);
                }
              }
              while_break___11: /* CIL Label */ ;
              }
#line 488
              goto while_break___10;
            }
            while_break___10: /* CIL Label */ ;
            }
          }
#line 488
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 489
        goto switch_break___2;
        case_109: /* CIL Label */ 
#line 491
        if (! arg) {
#line 492
          arg ++;
        }
        {
#line 493
        queueing_enabled ++;
#line 494
        hostnam = getsparam((char *)"HOST");
        }
#line 494
        if (! hostnam) {
          {
#line 495
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 495
            queueing_enabled --;
#line 495
            if (! queueing_enabled) {
              {
#line 495
              while (1) {
                while_continue___13: /* CIL Label */ ;
                {
#line 495
                while (1) {
                  while_continue___14: /* CIL Label */ ;
#line 495
                  if (! (queue_front != queue_rear)) {
#line 495
                    goto while_break___14;
                  }
                  {
#line 495
                  queue_front = (queue_front + 1) % 128;
#line 495
                  oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 495
                  zhandler(signal_queue[queue_front]);
#line 495
                  signal_setmask(oset___0);
                  }
                }
                while_break___14: /* CIL Label */ ;
                }
#line 495
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
            }
#line 495
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 496
          goto switch_break___2;
        }
#line 498
        if (arg < 0) {
          {
#line 499
          tmp___18 = strlen((char const   *)hostnam);
#line 499
          ss = hostnam + tmp___18;
          }
          {
#line 499
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 499
            if (! ((unsigned long )ss > (unsigned long )hostnam)) {
#line 499
              goto while_break___15;
            }
#line 500
            if ((int )*(ss + -1) == 46) {
#line 500
              arg ++;
#line 500
              if (! arg) {
#line 501
                goto while_break___15;
              }
            }
#line 499
            ss --;
          }
          while_break___15: /* CIL Label */ ;
          }
          {
#line 502
          stradd(ss);
          }
        } else {
#line 504
          ss = hostnam;
          {
#line 504
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 504
            if (! *ss) {
#line 504
              goto while_break___16;
            }
#line 505
            if ((int )*ss == 46) {
#line 505
              arg --;
#line 505
              if (! arg) {
#line 506
                goto while_break___16;
              }
            }
#line 504
            ss ++;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 507
          if (*ss) {
            {
#line 507
            tmp___19 = dupstrpfx((char const   *)hostnam, (int )(ss - hostnam));
#line 507
            tmp___20 = tmp___19;
            }
          } else {
#line 507
            tmp___20 = hostnam;
          }
          {
#line 507
          stradd(tmp___20);
          }
        }
        {
#line 509
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 509
          queueing_enabled --;
#line 509
          if (! queueing_enabled) {
            {
#line 509
            while (1) {
              while_continue___18: /* CIL Label */ ;
              {
#line 509
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 509
                if (! (queue_front != queue_rear)) {
#line 509
                  goto while_break___19;
                }
                {
#line 509
                queue_front = (queue_front + 1) % 128;
#line 509
                oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 509
                zhandler(signal_queue[queue_front]);
#line 509
                signal_setmask(oset___1);
                }
              }
              while_break___19: /* CIL Label */ ;
              }
#line 509
              goto while_break___18;
            }
            while_break___18: /* CIL Label */ ;
            }
          }
#line 509
          goto while_break___17;
        }
        while_break___17: /* CIL Label */ ;
        }
#line 510
        goto switch_break___2;
        case_83___0: /* CIL Label */ 
#line 512
        if (txtchangep) {
#line 512
          *txtchangep &= 4294967231U;
#line 512
          tmp___21 = *txtchangep | 2U;
#line 512
          *txtchangep = tmp___21;
#line 512
          if (tmp___21) {
#line 512
            tmp___22 = 1;
          } else {
#line 512
            tmp___22 = 0;
          }
        } else {
#line 512
          tmp___22 = 0;
        }
        {
#line 513
        txtattrmask |= 2U;
#line 514
        tsetcap(19, 2);
        }
#line 515
        goto switch_break___2;
        case_115: /* CIL Label */ 
#line 517
        if (txtchangep) {
#line 517
          *txtchangep &= 4294967293U;
#line 517
          tmp___23 = *txtchangep | 64U;
#line 517
          *txtchangep = tmp___23;
#line 517
          if (tmp___23) {
#line 517
            tmp___24 = 1;
          } else {
#line 517
            tmp___24 = 0;
          }
        } else {
#line 517
          tmp___24 = 0;
        }
        {
#line 518
        txtattrmask &= 4294967293U;
#line 519
        tsetcap(22, 6);
        }
#line 520
        goto switch_break___2;
        case_66: /* CIL Label */ 
#line 522
        if (txtchangep) {
#line 522
          *txtchangep &= 4294967263U;
#line 522
          tmp___25 = *txtchangep | 1U;
#line 522
          *txtchangep = tmp___25;
#line 522
          if (tmp___25) {
#line 522
            tmp___26 = 1;
          } else {
#line 522
            tmp___26 = 0;
          }
        } else {
#line 522
          tmp___26 = 0;
        }
        {
#line 523
        txtattrmask |= 1U;
#line 524
        tsetcap(18, 6);
        }
#line 525
        goto switch_break___2;
        case_98: /* CIL Label */ 
#line 527
        if (txtchangep) {
#line 527
          *txtchangep &= 4294967294U;
#line 527
          tmp___27 = *txtchangep | 32U;
#line 527
          *txtchangep = tmp___27;
#line 527
          if (tmp___27) {
#line 527
            tmp___28 = 1;
          } else {
#line 527
            tmp___28 = 0;
          }
        } else {
#line 527
          tmp___28 = 0;
        }
        {
#line 528
        txtattrmask &= 4294967294U;
#line 529
        tsetcap(21, 6);
        }
#line 530
        goto switch_break___2;
        case_85: /* CIL Label */ 
#line 532
        if (txtchangep) {
#line 532
          *txtchangep &= 4294967167U;
#line 532
          tmp___29 = *txtchangep | 4U;
#line 532
          *txtchangep = tmp___29;
#line 532
          if (tmp___29) {
#line 532
            tmp___30 = 1;
          } else {
#line 532
            tmp___30 = 0;
          }
        } else {
#line 532
          tmp___30 = 0;
        }
        {
#line 533
        txtattrmask |= 4U;
#line 534
        tsetcap(20, 2);
        }
#line 535
        goto switch_break___2;
        case_117: /* CIL Label */ 
#line 537
        if (txtchangep) {
#line 537
          *txtchangep &= 4294967291U;
#line 537
          tmp___31 = *txtchangep | 128U;
#line 537
          *txtchangep = tmp___31;
#line 537
          if (tmp___31) {
#line 537
            tmp___32 = 1;
          } else {
#line 537
            tmp___32 = 0;
          }
        } else {
#line 537
          tmp___32 = 0;
        }
        {
#line 538
        txtattrmask &= 4294967291U;
#line 539
        tsetcap(23, 6);
        }
#line 540
        goto switch_break___2;
        case_70: /* CIL Label */ 
        {
#line 542
        arg = parsecolorchar(arg, 1);
        }
#line 543
        if (arg >= 0) {
#line 543
          if (! (arg & 256)) {
#line 544
            if (txtchangep) {
#line 544
              *txtchangep &= 4293922559U;
#line 544
              tmp___33 = *txtchangep | (unsigned int )(arg & 269479944);
#line 544
              *txtchangep = tmp___33;
#line 544
              if (tmp___33) {
#line 544
                tmp___34 = 1;
              } else {
#line 544
                tmp___34 = 0;
              }
            } else {
#line 544
              tmp___34 = 0;
            }
            {
#line 546
            txtattrmask &= 4293922815U;
#line 547
            txtattrmask |= (unsigned int )(arg & 269479944);
#line 548
            set_colour_attribute(arg, 0, 2);
            }
#line 549
            goto switch_break___2;
          }
        }
        case_102: /* CIL Label */ 
#line 553
        if (txtchangep) {
#line 553
          *txtchangep &= 4025487351U;
#line 553
          tmp___35 = *txtchangep | 256U;
#line 553
          *txtchangep = tmp___35;
#line 553
          if (tmp___35) {
#line 553
            tmp___36 = 1;
          } else {
#line 553
            tmp___36 = 0;
          }
        } else {
#line 553
          tmp___36 = 0;
        }
        {
#line 554
        txtattrmask &= 4025487351U;
#line 555
        set_colour_attribute(256, 0, 2);
        }
#line 556
        goto switch_break___2;
        case_75: /* CIL Label */ 
        {
#line 558
        arg = parsecolorchar(arg, 0);
        }
#line 559
        if (arg >= 0) {
#line 559
          if (! (arg & 512)) {
#line 560
            if (txtchangep) {
#line 560
              *txtchangep &= 4027579903U;
#line 560
              tmp___37 = *txtchangep | (unsigned int )(arg & 804257808);
#line 560
              *txtchangep = tmp___37;
#line 560
              if (tmp___37) {
#line 560
                tmp___38 = 1;
              } else {
#line 560
                tmp___38 = 0;
              }
            } else {
#line 560
              tmp___38 = 0;
            }
            {
#line 562
            txtattrmask &= 4027580415U;
#line 563
            txtattrmask |= (unsigned int )(arg & 804257808);
#line 564
            set_colour_attribute(arg, 1, 2);
            }
#line 565
            goto switch_break___2;
          }
        }
        case_107: /* CIL Label */ 
#line 569
        if (txtchangep) {
#line 569
          *txtchangep &= 3490709487U;
#line 569
          tmp___39 = *txtchangep | 512U;
#line 569
          *txtchangep = tmp___39;
#line 569
          if (tmp___39) {
#line 569
            tmp___40 = 1;
          } else {
#line 569
            tmp___40 = 0;
          }
        } else {
#line 569
          tmp___40 = 0;
        }
        {
#line 570
        txtattrmask &= 3490709487U;
#line 571
        set_colour_attribute(512, 1, 2);
        }
#line 572
        goto switch_break___2;
        case_91___0: /* CIL Label */ 
#line 574
        (bv->fm) ++;
#line 574
        if ((int )typtab[(unsigned char )*(bv->fm)] & 1) {
          {
#line 575
          tmp___41 = zstrtol((char const   *)bv->fm, & bv->fm, 10);
#line 575
          arg = (int )tmp___41;
          }
        }
        {
#line 576
        tmp___42 = prompttrunc(arg, ']', doprint, endchar, txtchangep);
        }
#line 576
        if (! tmp___42) {
#line 577
          return ((int )*(bv->fm));
        }
#line 578
        goto switch_break___2;
        case_62___0: /* CIL Label */ 
        case_60___0: /* CIL Label */ 
#line 582
        if (minus) {
          {
#line 583
          *(bv->bp) = (char )'\000';
#line 584
          countprompt(bv->bufline, & t0, (int *)0, 0);
#line 585
          arg = (int )((zterm_columns - (zlong )t0) + (zlong )arg);
          }
#line 586
          if (arg <= 0) {
#line 587
            arg = 1;
          }
        }
        {
#line 589
        tmp___43 = prompttrunc(arg, (int )*(bv->fm), doprint, endchar, txtchangep);
        }
#line 589
        if (! tmp___43) {
#line 590
          return ((int )*(bv->fm));
        }
#line 591
        goto switch_break___2;
        case_123: /* CIL Label */ 
#line 593
        tmp___45 = bv->dontcount;
#line 593
        (bv->dontcount) ++;
#line 593
        if (! tmp___45) {
          {
#line 594
          addbufspc(1);
#line 595
          tmp___44 = bv->bp;
#line 595
          (bv->bp) ++;
#line 595
          *tmp___44 = (char)-120;
          }
        }
#line 597
        if (arg <= 0) {
#line 598
          goto switch_break___2;
        }
        case_71: /* CIL Label */ 
#line 602
        if (arg > 0) {
          {
#line 603
          addbufspc(arg);
          }
          {
#line 604
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 604
            tmp___47 = arg;
#line 604
            arg --;
#line 604
            if (! tmp___47) {
#line 604
              goto while_break___20;
            }
#line 605
            tmp___46 = bv->bp;
#line 605
            (bv->bp) ++;
#line 605
            *tmp___46 = (char)-95;
          }
          while_break___20: /* CIL Label */ ;
          }
        } else {
          {
#line 607
          addbufspc(1);
#line 608
          tmp___48 = bv->bp;
#line 608
          (bv->bp) ++;
#line 608
          *tmp___48 = (char)-95;
          }
        }
#line 610
        goto switch_break___2;
        case_125: /* CIL Label */ 
#line 612
        if (bv->trunccount) {
#line 612
          if (bv->trunccount >= bv->dontcount) {
#line 613
            return ((int )*(bv->fm));
          }
        }
#line 614
        if (bv->dontcount) {
#line 614
          (bv->dontcount) --;
#line 614
          if (! bv->dontcount) {
            {
#line 615
            addbufspc(1);
#line 616
            tmp___49 = bv->bp;
#line 616
            (bv->bp) ++;
#line 616
            *tmp___49 = (char)-118;
            }
          }
        }
#line 618
        goto switch_break___2;
        case_68___2: /* CIL Label */ 
        case_87: /* CIL Label */ 
        case_119___1: /* CIL Label */ 
        case_42: /* CIL Label */ 
        case_84___1: /* CIL Label */ 
        case_64: /* CIL Label */ 
        case_116___1: /* CIL Label */ 
#line 627
        tmbuf = (char *)((void *)0);
        {
#line 630
        if ((int )*(bv->fm) == 84) {
#line 630
          goto case_84___2;
        }
#line 633
        if ((int )*(bv->fm) == 42) {
#line 633
          goto case_42___0;
        }
#line 636
        if ((int )*(bv->fm) == 119) {
#line 636
          goto case_119___2;
        }
#line 639
        if ((int )*(bv->fm) == 87) {
#line 639
          goto case_87___0;
        }
#line 642
        if ((int )*(bv->fm) == 68) {
#line 642
          goto case_68___3;
        }
#line 663
        goto switch_default___1;
        case_84___2: /* CIL Label */ 
#line 631
        tmfmt = (char *)"%K:%M";
#line 632
        goto switch_break___3;
        case_42___0: /* CIL Label */ 
#line 634
        tmfmt = (char *)"%K:%M:%S";
#line 635
        goto switch_break___3;
        case_119___2: /* CIL Label */ 
#line 637
        tmfmt = (char *)"%a %f";
#line 638
        goto switch_break___3;
        case_87___0: /* CIL Label */ 
#line 640
        tmfmt = (char *)"%m/%d/%y";
#line 641
        goto switch_break___3;
        case_68___3: /* CIL Label */ 
#line 643
        if ((int )*(bv->fm + 1) == 123) {
#line 644
          ss = bv->fm + 2;
          {
#line 644
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 644
            if (*ss) {
#line 644
              if (! ((int )*ss != 125)) {
#line 644
                goto while_break___21;
              }
            } else {
#line 644
              goto while_break___21;
            }
#line 645
            if ((int )*ss == 92) {
#line 645
              if (*(ss + 1)) {
#line 646
                ss ++;
              }
            }
#line 644
            ss ++;
          }
          while_break___21: /* CIL Label */ ;
          }
          {
#line 647
          tmp___50 = zalloc((size_t )(ss - bv->fm));
#line 647
          tmbuf = (char *)tmp___50;
#line 647
          tmfmt = tmbuf;
#line 647
          dd = tmfmt;
#line 648
          ss = bv->fm + 2;
          }
          {
#line 648
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 648
            if (*ss) {
#line 648
              if (! ((int )*ss != 125)) {
#line 648
                goto while_break___22;
              }
            } else {
#line 648
              goto while_break___22;
            }
#line 650
            if ((int )*ss == 92) {
#line 650
              if (*(ss + 1)) {
#line 651
                ss ++;
              }
            }
#line 652
            tmp___51 = dd;
#line 652
            dd ++;
#line 652
            *tmp___51 = *ss;
#line 648
            ss ++;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 654
          *dd = (char)0;
#line 655
          bv->fm = ss - ! *ss;
#line 656
          if (! *tmfmt) {
            {
#line 657
            free((void *)tmbuf);
            }
#line 658
            goto __Cont;
          }
        } else {
#line 661
          tmfmt = (char *)"%y-%m-%d";
        }
#line 662
        goto switch_break___3;
        switch_default___1: /* CIL Label */ 
#line 664
        tmfmt = (char *)"%l:%M%p";
#line 665
        goto switch_break___3;
        switch_break___3: /* CIL Label */ ;
        }
        {
#line 667
        gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )(& dummy_tz));
#line 668
        tm = localtime((time_t const   *)(& tv.tv_sec));
#line 676
        j = 0;
#line 676
        tmp___52 = strlen((char const   *)tmfmt);
#line 676
        t0 = (int )(tmp___52 * 8UL);
        }
        {
#line 676
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 676
          if (! (j < 3)) {
#line 676
            goto while_break___23;
          }
          {
#line 677
          addbufspc(t0);
#line 678
          len = ztrftime(bv->bp, t0, tmfmt, tm, tv.tv_usec);
          }
#line 678
          if (len >= 0) {
#line 680
            goto while_break___23;
          }
#line 676
          j ++;
#line 676
          t0 *= 2;
        }
        while_break___23: /* CIL Label */ ;
        }
#line 684
        if (len >= 0) {
          {
#line 685
          metafy(bv->bp, len, 5);
          }
        }
        {
#line 686
        tmp___53 = strlen((char const   *)bv->bp);
#line 686
        bv->bp += tmp___53;
#line 687
        zsfree(tmbuf);
        }
#line 688
        goto switch_break___2;
        case_110: /* CIL Label */ 
        {
#line 691
        tmp___54 = get_username();
#line 691
        stradd(tmp___54);
        }
#line 692
        goto switch_break___2;
        case_108___0: /* CIL Label */ 
#line 694
        if (*ttystrname) {
          {
#line 695
          tmp___56 = strncmp((char const   *)ttystrname, "/dev/tty", (size_t )8);
          }
#line 695
          if (tmp___56) {
#line 695
            ss = ttystrname + 5;
          } else {
#line 695
            ss = ttystrname + 8;
          }
          {
#line 697
          stradd(ss);
          }
        } else {
          {
#line 699
          stradd((char *)"()");
          }
        }
#line 700
        goto switch_break___2;
        case_121: /* CIL Label */ 
#line 702
        if (*ttystrname) {
          {
#line 703
          tmp___58 = strncmp((char const   *)ttystrname, "/dev/", (size_t )5);
          }
#line 703
          if (tmp___58) {
#line 703
            ss = ttystrname;
          } else {
#line 703
            ss = ttystrname + 5;
          }
          {
#line 705
          stradd(ss);
          }
        } else {
          {
#line 707
          stradd((char *)"()");
          }
        }
#line 708
        goto switch_break___2;
        case_76___0: /* CIL Label */ 
        {
#line 710
        addbufspc((int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3);
#line 714
        sprintf((char */* __restrict  */)bv->bp, (char const   */* __restrict  */)"%ld",
                shlvl);
#line 716
        tmp___59 = strlen((char const   *)bv->bp);
#line 716
        bv->bp += tmp___59;
        }
#line 717
        goto switch_break___2;
        case_63___0: /* CIL Label */ 
        {
#line 719
        addbufspc((int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3);
#line 723
        sprintf((char */* __restrict  */)bv->bp, (char const   */* __restrict  */)"%ld",
                lastval);
#line 725
        tmp___60 = strlen((char const   *)bv->bp);
#line 725
        bv->bp += tmp___60;
        }
#line 726
        goto switch_break___2;
        case_41: /* CIL Label */ 
        case_37: /* CIL Label */ 
        {
#line 729
        addbufspc(1);
#line 730
        tmp___61 = bv->bp;
#line 730
        (bv->bp) ++;
#line 730
        *tmp___61 = *(bv->fm);
        }
#line 731
        goto switch_break___2;
        case_35___0: /* CIL Label */ 
        {
#line 733
        addbufspc(1);
#line 734
        tmp___62 = bv->bp;
#line 734
        (bv->bp) ++;
#line 734
        tmp___64 = privasserted();
        }
#line 734
        if (tmp___64) {
#line 734
          *tmp___62 = (char )'#';
        } else {
#line 734
          *tmp___62 = (char )'%';
        }
#line 735
        goto switch_break___2;
        case_118___0: /* CIL Label */ 
#line 737
        if (! arg) {
#line 738
          arg = 1;
        } else
#line 739
        if (arg < 0) {
          {
#line 740
          tmp___65 = arrlen(psvar);
#line 740
          arg += tmp___65 + 1;
          }
        }
#line 741
        if (arg > 0) {
          {
#line 741
          tmp___66 = arrlen_ge(psvar, (unsigned int )arg);
          }
#line 741
          if (tmp___66) {
            {
#line 742
            stradd(*(psvar + (arg - 1)));
            }
          }
        }
#line 743
        goto switch_break___2;
        case_69: /* CIL Label */ 
        {
#line 745
        tsetcap(14, 2);
        }
#line 746
        goto switch_break___2;
        case_94: /* CIL Label */ 
#line 748
        if (cmdsp) {
#line 749
          if (arg >= 0) {
#line 750
            if (arg > cmdsp) {
#line 751
              arg = cmdsp;
            } else
#line 750
            if (arg == 0) {
#line 751
              arg = cmdsp;
            }
#line 752
            t0 = cmdsp - 1;
            {
#line 752
            while (1) {
              while_continue___24: /* CIL Label */ ;
#line 752
              tmp___68 = arg;
#line 752
              arg --;
#line 752
              if (! tmp___68) {
#line 752
                goto while_break___24;
              }
              {
#line 753
              stradd(cmdnames[*(cmdstack + t0)]);
              }
#line 754
              if (arg) {
                {
#line 755
                addbufspc(1);
#line 756
                tmp___67 = bv->bp;
#line 756
                (bv->bp) ++;
#line 756
                *tmp___67 = (char )' ';
                }
              }
#line 752
              t0 --;
            }
            while_break___24: /* CIL Label */ ;
            }
          } else {
#line 760
            arg = - arg;
#line 761
            if (arg > cmdsp) {
#line 762
              arg = cmdsp;
            }
#line 763
            t0 = arg - 1;
            {
#line 763
            while (1) {
              while_continue___25: /* CIL Label */ ;
#line 763
              tmp___70 = arg;
#line 763
              arg --;
#line 763
              if (! tmp___70) {
#line 763
                goto while_break___25;
              }
              {
#line 764
              stradd(cmdnames[*(cmdstack + t0)]);
              }
#line 765
              if (arg) {
                {
#line 766
                addbufspc(1);
#line 767
                tmp___69 = bv->bp;
#line 767
                (bv->bp) ++;
#line 767
                *tmp___69 = (char )' ';
                }
              }
#line 763
              t0 --;
            }
            while_break___25: /* CIL Label */ ;
            }
          }
        }
#line 772
        goto switch_break___2;
        case_95___0: /* CIL Label */ 
#line 774
        if (cmdsp) {
#line 775
          if (arg >= 0) {
#line 776
            if (arg > cmdsp) {
#line 777
              arg = cmdsp;
            } else
#line 776
            if (arg == 0) {
#line 777
              arg = cmdsp;
            }
#line 778
            t0 = cmdsp - arg;
            {
#line 778
            while (1) {
              while_continue___26: /* CIL Label */ ;
#line 778
              tmp___72 = arg;
#line 778
              arg --;
#line 778
              if (! tmp___72) {
#line 778
                goto while_break___26;
              }
              {
#line 779
              stradd(cmdnames[*(cmdstack + t0)]);
              }
#line 780
              if (arg) {
                {
#line 781
                addbufspc(1);
#line 782
                tmp___71 = bv->bp;
#line 782
                (bv->bp) ++;
#line 782
                *tmp___71 = (char )' ';
                }
              }
#line 778
              t0 ++;
            }
            while_break___26: /* CIL Label */ ;
            }
          } else {
#line 786
            arg = - arg;
#line 787
            if (arg > cmdsp) {
#line 788
              arg = cmdsp;
            }
#line 789
            t0 = 0;
            {
#line 789
            while (1) {
              while_continue___27: /* CIL Label */ ;
#line 789
              tmp___74 = arg;
#line 789
              arg --;
#line 789
              if (! tmp___74) {
#line 789
                goto while_break___27;
              }
              {
#line 790
              stradd(cmdnames[*(cmdstack + t0)]);
              }
#line 791
              if (arg) {
                {
#line 792
                addbufspc(1);
#line 793
                tmp___73 = bv->bp;
#line 793
                (bv->bp) ++;
#line 793
                *tmp___73 = (char )' ';
                }
              }
#line 789
              t0 ++;
            }
            while_break___27: /* CIL Label */ ;
            }
          }
        }
#line 798
        goto switch_break___2;
        case_114: /* CIL Label */ 
#line 800
        if (bv->rstring) {
          {
#line 801
          stradd(bv->rstring);
          }
        }
#line 802
        goto switch_break___2;
        case_82: /* CIL Label */ 
#line 804
        if (bv->Rstring) {
          {
#line 805
          stradd(bv->Rstring);
          }
        }
#line 806
        goto switch_break___2;
        case_101___0: /* CIL Label */ 
#line 809
        depth = 0;
#line 810
        fsptr___0 = funcstack;
        {
#line 811
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 811
          if (! fsptr___0) {
#line 811
            goto while_break___28;
          }
#line 812
          depth ++;
#line 813
          fsptr___0 = fsptr___0->prev;
        }
        while_break___28: /* CIL Label */ ;
        }
        {
#line 815
        addbufspc((int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3);
#line 816
        sprintf((char */* __restrict  */)bv->bp, (char const   */* __restrict  */)"%d",
                depth);
#line 817
        tmp___75 = strlen((char const   *)bv->bp);
#line 817
        bv->bp += tmp___75;
        }
#line 818
        goto switch_break___2;
        case_73: /* CIL Label */ 
#line 821
        if (funcstack) {
#line 821
          if (funcstack->tp != 0) {
#line 821
            if (intrap) {
#line 821
              if (! trapisfunc) {
#line 821
                if (! (traplocallevel == locallevel)) {
#line 821
                  goto _L___0;
                }
              } else {
#line 821
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
#line 828
              flineno = lineno + funcstack->flineno;
#line 830
              if (funcstack->tp == 2) {
#line 831
                lineno --;
              }
              {
#line 832
              addbufspc((int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3);
#line 836
              sprintf((char */* __restrict  */)bv->bp, (char const   */* __restrict  */)"%ld",
                      flineno);
#line 838
              tmp___76 = strlen((char const   *)bv->bp);
#line 838
              bv->bp += tmp___76;
              }
#line 839
              goto switch_break___2;
            }
          }
        }
        case_105: /* CIL Label */ 
        {
#line 844
        addbufspc((int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3);
#line 848
        sprintf((char */* __restrict  */)bv->bp, (char const   */* __restrict  */)"%ld",
                lineno);
#line 850
        tmp___77 = strlen((char const   *)bv->bp);
#line 850
        bv->bp += tmp___77;
        }
#line 851
        goto switch_break___2;
        case_120: /* CIL Label */ 
#line 853
        if (funcstack) {
#line 853
          if (funcstack->tp != 0) {
#line 853
            if (intrap) {
#line 853
              if (! trapisfunc) {
#line 853
                if (traplocallevel == locallevel) {
#line 853
                  goto _L___4;
                } else {
#line 853
                  goto _L___3;
                }
              } else {
#line 853
                goto _L___3;
              }
            } else {
              _L___3: /* CIL Label */ 
#line 855
              if (funcstack->filename) {
#line 855
                tmp___78 = (char const   *)funcstack->filename;
              } else {
#line 855
                tmp___78 = "";
              }
              {
#line 855
              promptpath((char *)tmp___78, arg, 0);
              }
            }
          } else {
#line 853
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
#line 858
          if (scriptfilename) {
#line 858
            tmp___79 = scriptfilename;
          } else {
#line 858
            tmp___79 = argzero;
          }
          {
#line 858
          promptpath(tmp___79, arg, 0);
          }
        }
#line 860
        goto switch_break___2;
        case_0: /* CIL Label */ 
#line 862
        return (0);
        case_neg_125: /* CIL Label */ 
#line 864
        (bv->fm) ++;
#line 865
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
      } else {
#line 283
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 867
    if ((int )*(bv->fm) == 33) {
#line 867
      if (opts[140]) {
#line 868
        if (doprint) {
#line 869
          if ((int )*(bv->fm + 1) == 33) {
            {
#line 870
            (bv->fm) ++;
#line 871
            addbufspc(1);
#line 872
            pputc((char )'!');
            }
          } else {
            {
#line 874
            addbufspc((int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3);
#line 875
            convbase(bv->bp, curhist, 10);
#line 876
            tmp___80 = strlen((char const   *)bv->bp);
#line 876
            bv->bp += tmp___80;
            }
          }
        }
      } else {
#line 867
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
#line 880
      if ((int )*(bv->fm) == -125) {
#line 880
        (bv->fm) ++;
#line 880
        tmp___81 = (int )*(bv->fm) ^ 32;
      } else {
#line 880
        tmp___81 = (int )*(bv->fm);
      }
#line 880
      c = (char )tmp___81;
#line 882
      if (doprint) {
        {
#line 883
        addbufspc(1);
#line 884
        pputc(c);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 281
    (bv->fm) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 889
  return ((int )*(bv->fm));
}
}
#line 896 "/tmp/zsh-5.4.2/Src/prompt.c"
static void pputc(char c ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 899
  if ((int )typtab[(unsigned char )c] & (1 << 12)) {
#line 900
    tmp = bv->bp;
#line 900
    (bv->bp) ++;
#line 900
    *tmp = (char)-125;
#line 901
    c = (char )((int )c ^ 32);
  }
#line 903
  tmp___0 = bv->bp;
#line 903
  (bv->bp) ++;
#line 903
  *tmp___0 = c;
#line 904
  if ((int )c == 10) {
#line 904
    if (! bv->dontcount) {
#line 905
      bv->bufline = bv->bp;
    }
  }
#line 906
  return;
}
}
#line 911 "/tmp/zsh-5.4.2/Src/prompt.c"
static void addbufspc(int need ) 
{ 
  int bo ;
  int bo1 ;
  long tmp ;
  ptrdiff_t bufline_off ;
  long tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 914
  need *= 2;
#line 915
  if ((bv->bp - bv->buf) + (long )need > (long )bv->bufspc) {
#line 916
    bo = (int )(bv->bp - bv->buf);
#line 917
    if (bv->bp1) {
#line 917
      tmp = bv->bp1 - bv->buf;
    } else {
#line 917
      tmp = -1L;
    }
#line 917
    bo1 = (int )tmp;
#line 918
    if (bv->bufline) {
#line 918
      tmp___0 = bv->bufline - bv->buf;
    } else {
#line 918
      tmp___0 = -1L;
    }
#line 918
    bufline_off = tmp___0;
#line 920
    if (need & 255) {
#line 921
      need = (need | 255) + 1;
    }
    {
#line 922
    tmp___1 = bv->bufspc + need;
#line 922
    bv->bufspc = tmp___1;
#line 922
    tmp___2 = realloc((void *)bv->buf, (size_t )tmp___1);
#line 922
    bv->buf = (char *)tmp___2;
#line 923
    memset((void *)((bv->buf + bv->bufspc) - need), 0, (size_t )need);
#line 924
    bv->bp = bv->buf + bo;
    }
#line 925
    if (bo1 != -1) {
#line 926
      bv->bp1 = bv->buf + bo1;
    }
#line 927
    if (bufline_off != -1L) {
#line 928
      bv->bufline = bv->buf + bufline_off;
    }
  }
#line 930
  return;
}
}
#line 936 "/tmp/zsh-5.4.2/Src/prompt.c"
void stradd(char *d___0 ) 
{ 
  char *ums ;
  char *ups ;
  int upslen ;
  int eol ;
  mbstate_t mbs ;
  wchar_t cc ;
  char *pc ;
  size_t cnt ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 941
  eol = 0;
#line 944
  memset((void *)(& mbs), 0, sizeof(mbs));
#line 945
  ums = ztrdup((char const   *)d___0);
#line 946
  ups = unmetafy(ums, & upslen);
  }
  {
#line 952
  while (1) {
    while_continue: /* CIL Label */ ;
#line 952
    if (! (upslen > 0)) {
#line 952
      goto while_break;
    }
#line 955
    if (eol) {
#line 955
      tmp___0 = (size_t )-1;
    } else {
      {
#line 955
      tmp = mbrtowc((wchar_t */* __restrict  */)(& cc), (char const   */* __restrict  */)ups,
                    (size_t )upslen, (mbstate_t */* __restrict  */)(& mbs));
#line 955
      tmp___0 = tmp;
      }
    }
#line 955
    cnt = tmp___0;
    {
#line 958
    if (cnt == 0xfffffffffffffffeUL) {
#line 958
      goto case_18446744073709551614;
    }
#line 961
    if (cnt == 0xffffffffffffffffUL) {
#line 961
      goto case_18446744073709551615;
    }
#line 967
    if (cnt == 0UL) {
#line 967
      goto case_0;
    }
#line 970
    goto switch_default;
    case_18446744073709551614: /* CIL Label */ 
#line 959
    eol = 1;
    case_18446744073709551615: /* CIL Label */ 
    {
#line 963
    pc = nicechar((int )*ups);
#line 964
    cnt = (size_t )1;
#line 965
    memset((void *)(& mbs), 0, sizeof(mbs));
    }
#line 966
    goto switch_break;
    case_0: /* CIL Label */ 
#line 968
    cnt = (size_t )1;
    switch_default: /* CIL Label */ 
    {
#line 972
    mb_charinit();
#line 973
    pc = wcs_nicechar(cc, (size_t *)((void *)0), (char **)((void *)0));
    }
#line 974
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 977
    tmp___1 = strlen((char const   *)pc);
#line 977
    addbufspc((int )tmp___1);
#line 979
    upslen = (int )((size_t )upslen - cnt);
#line 980
    ups += cnt;
    }
    {
#line 983
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 983
      if (! *pc) {
#line 983
        goto while_break___0;
      }
#line 984
      tmp___2 = bv->bp;
#line 984
      (bv->bp) ++;
#line 984
      tmp___3 = pc;
#line 984
      pc ++;
#line 984
      *tmp___2 = *tmp___3;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 987
  free((void *)ums);
  }
#line 998
  return;
}
}
#line 1003 "/tmp/zsh-5.4.2/Src/prompt.c"
void tsetcap(int cap , int flags ) 
{ 
  char *tmp ;
  int glitch ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 1006
  if (tclen[cap]) {
#line 1006
    if (! opts[166]) {
#line 1006
      if (! (termflags & 7)) {
        {
#line 1009
        if ((flags & 3) == 1) {
#line 1009
          goto case_1;
        }
#line 1016
        if ((flags & 3) == 2) {
#line 1016
          goto case_2;
        }
#line 1013
        goto switch_default;
        case_1: /* CIL Label */ 
        {
#line 1010
        tputs((char const   *)tcstr[cap], 1, & putraw);
        }
#line 1011
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1014
        tputs((char const   *)tcstr[cap], 1, & putshout);
        }
#line 1015
        goto switch_break;
        case_2: /* CIL Label */ 
#line 1017
        if (! bv->dontcount) {
          {
#line 1018
          addbufspc(1);
#line 1019
          tmp = bv->bp;
#line 1019
          (bv->bp) ++;
#line 1019
          *tmp = (char)-120;
          }
        }
        {
#line 1021
        tputs((char const   *)tcstr[cap], 1, & putstr);
        }
#line 1022
        if (! bv->dontcount) {
#line 1023
          glitch = 0;
#line 1025
          if (cap == 19) {
            {
#line 1026
            glitch = tgetnum("sg");
            }
          } else
#line 1025
          if (cap == 22) {
            {
#line 1026
            glitch = tgetnum("sg");
            }
          } else
#line 1027
          if (cap == 20) {
            {
#line 1028
            glitch = tgetnum("ug");
            }
          } else
#line 1027
          if (cap == 23) {
            {
#line 1028
            glitch = tgetnum("ug");
            }
          }
#line 1029
          if (glitch < 0) {
#line 1030
            glitch = 0;
          }
          {
#line 1031
          addbufspc(glitch + 1);
          }
          {
#line 1032
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1032
            tmp___1 = glitch;
#line 1032
            glitch --;
#line 1032
            if (! tmp___1) {
#line 1032
              goto while_break;
            }
#line 1033
            tmp___0 = bv->bp;
#line 1033
            (bv->bp) ++;
#line 1033
            *tmp___0 = (char)-95;
          }
          while_break: /* CIL Label */ ;
          }
#line 1034
          tmp___2 = bv->bp;
#line 1034
          (bv->bp) ++;
#line 1034
          *tmp___2 = (char)-118;
        }
#line 1036
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 1039
        if (flags & 4) {
#line 1040
          flags &= -5;
#line 1041
          if (txtattrmask & 1U) {
#line 1041
            if (cap != 18) {
              {
#line 1042
              tsetcap(18, flags);
              }
            }
          }
#line 1043
          if (txtattrmask & 2U) {
            {
#line 1044
            tsetcap(19, flags);
            }
          }
#line 1045
          if (txtattrmask & 4U) {
            {
#line 1046
            tsetcap(20, flags);
            }
          }
#line 1047
          if (txtattrmask & 8U) {
            {
#line 1048
            set_colour_attribute((int )txtattrmask, 0, 2);
            }
          }
#line 1049
          if (txtattrmask & 16U) {
            {
#line 1050
            set_colour_attribute((int )txtattrmask, 1, 2);
            }
          }
        }
      }
    }
  }
#line 1053
  return;
}
}
#line 1056 "/tmp/zsh-5.4.2/Src/prompt.c"
int putstr(int d___0 ) 
{ 


  {
  {
#line 1059
  addbufspc(1);
#line 1060
  pputc((char )d___0);
  }
#line 1061
  return (0);
}
}
#line 1075 "/tmp/zsh-5.4.2/Src/prompt.c"
void countprompt(char *str , int *wp , int *hp , int overf ) 
{ 
  int w ;
  int h ;
  int s ;
  int wcw ;
  int multi ;
  char inchar ;
  mbstate_t mbs ;
  wchar_t wc ;
  size_t tmp ;

  {
  {
#line 1078
  w = 0;
#line 1078
  h = 1;
#line 1079
  s = 1;
#line 1081
  multi = 0;
#line 1086
  memset((void *)(& mbs), 0, sizeof(mbs));
  }
  {
#line 1089
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1089
    if (! *str) {
#line 1089
      goto while_break;
    }
#line 1090
    if ((zlong )w >= zterm_columns) {
#line 1090
      if (overf >= 0) {
#line 1091
        w = 0;
#line 1092
        h ++;
      }
    }
#line 1098
    if ((int )*str == -120) {
#line 1099
      s = 0;
    } else
#line 1100
    if ((int )*str == -118) {
#line 1101
      s = 1;
    } else
#line 1102
    if ((int )*str == -95) {
#line 1103
      w ++;
    } else
#line 1104
    if (s) {
#line 1105
      if ((int )*str == -125) {
#line 1107
        str ++;
#line 1107
        inchar = (char )((int )*str ^ 32);
      } else {
#line 1119
        if (! multi) {
#line 1121
          if ((int )*str == 9) {
#line 1122
            w = (w | 7) + 1;
#line 1123
            goto __Cont;
          } else
#line 1124
          if ((int )*str == 10) {
#line 1125
            w = 0;
#line 1126
            h ++;
#line 1127
            goto __Cont;
          }
        }
#line 1132
        inchar = *str;
      }
      {
#line 1137
      tmp = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)(& inchar),
                    (size_t )1, (mbstate_t */* __restrict  */)(& mbs));
      }
      {
#line 1138
      if (tmp == 0xfffffffffffffffeUL) {
#line 1138
        goto case_18446744073709551614;
      }
#line 1142
      if (tmp == 0xffffffffffffffffUL) {
#line 1142
        goto case_18446744073709551615;
      }
#line 1148
      if (tmp == 0UL) {
#line 1148
        goto case_0;
      }
#line 1151
      goto switch_default;
      case_18446744073709551614: /* CIL Label */ 
#line 1140
      multi = 1;
#line 1141
      goto switch_break;
      case_18446744073709551615: /* CIL Label */ 
      {
#line 1143
      memset((void *)(& mbs), 0, sizeof(mbs));
#line 1145
      multi = 0;
#line 1146
      w ++;
      }
#line 1147
      goto switch_break;
      case_0: /* CIL Label */ 
#line 1149
      multi = 0;
#line 1150
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1156
      wcw = wcwidth(wc);
      }
#line 1157
      if (wcw >= 0) {
#line 1158
        w += wcw;
      } else {
#line 1160
        w ++;
      }
#line 1161
      multi = 0;
#line 1162
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1089
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1174
  if ((zlong )w >= zterm_columns) {
#line 1174
    if (overf >= 0) {
#line 1175
      if (! overf) {
#line 1176
        w = 0;
#line 1177
        h ++;
      } else
#line 1175
      if ((zlong )w > zterm_columns) {
#line 1176
        w = 0;
#line 1177
        h ++;
      }
    }
  }
#line 1180
  if (wp) {
#line 1181
    *wp = w;
  }
#line 1182
  if (hp) {
#line 1183
    *hp = h;
  }
#line 1184
  return;
}
}
#line 1187 "/tmp/zsh-5.4.2/Src/prompt.c"
static int prompttrunc(int arg , int truncchar , int doprint , int endchar , unsigned int *txtchangep ) 
{ 
  char ch ;
  char *ptr___0 ;
  char *truncstr ;
  int truncatleft ;
  int w ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *t ;
  int fullen ;
  int twidth ;
  int maxwidth ;
  int ntrunc ;
  size_t tmp___2 ;
  char *fulltextptr ;
  char *fulltext ;
  int remw ;
  mbstate_t mbs ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char inchar ;
  wchar_t cc ;
  int wcw ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *skiptext ;
  mbstate_t mbs___0 ;
  char *tmp___10 ;
  char inchar___0 ;
  wchar_t cc___0 ;
  int wcw___0 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;

  {
#line 1191
  if (arg > 0) {
#line 1192
    ch = *(bv->fm);
#line 1193
    truncatleft = (int )ch == 60;
#line 1194
    w = (int )(bv->bp - bv->buf);
#line 1201
    if (bv->truncwidth) {
      {
#line 1202
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1202
        (bv->fm) --;
#line 1202
        if (! ((int )*(bv->fm) != 37)) {
#line 1202
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1204
      (bv->fm) --;
#line 1205
      return (0);
    }
#line 1208
    bv->truncwidth = arg;
#line 1209
    if ((int )*(bv->fm) != 93) {
#line 1210
      (bv->fm) ++;
    }
    {
#line 1211
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1211
      if (*(bv->fm)) {
#line 1211
        if (! ((int )*(bv->fm) != truncchar)) {
#line 1211
          goto while_break___0;
        }
      } else {
#line 1211
        goto while_break___0;
      }
#line 1212
      if ((int )*(bv->fm) == 92) {
#line 1212
        if (*(bv->fm + 1)) {
#line 1213
          (bv->fm) ++;
        }
      }
      {
#line 1214
      addbufspc(1);
#line 1215
      tmp = bv->bp;
#line 1215
      (bv->bp) ++;
#line 1215
      tmp___0 = bv->fm;
#line 1215
      (bv->fm) ++;
#line 1215
      *tmp = *tmp___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1217
    if (! *(bv->fm)) {
#line 1218
      return (0);
    }
#line 1219
    if (bv->bp - bv->buf == (long )w) {
#line 1219
      if (truncchar == 93) {
        {
#line 1220
        addbufspc(1);
#line 1221
        tmp___1 = bv->bp;
#line 1221
        (bv->bp) ++;
#line 1221
        *tmp___1 = (char )'<';
        }
      }
    }
    {
#line 1223
    ptr___0 = bv->buf + w;
#line 1230
    truncstr = ztrduppfx((char const   *)ptr___0, (int )(bv->bp - ptr___0));
#line 1232
    bv->bp = ptr___0;
#line 1233
    w = (int )(bv->bp - bv->buf);
#line 1234
    (bv->fm) ++;
#line 1235
    bv->trunccount = bv->dontcount;
#line 1236
    putpromptchar(doprint, endchar, txtchangep);
#line 1237
    bv->trunccount = 0;
#line 1238
    ptr___0 = bv->buf + w;
#line 1239
    *(bv->bp) = (char )'\000';
#line 1256
    countprompt(ptr___0, & w, (int *)0, -1);
    }
#line 1257
    if (w > bv->truncwidth) {
      {
#line 1267
      t = truncstr;
#line 1268
      fullen = (int )(bv->bp - ptr___0);
#line 1270
      tmp___2 = strlen((char const   *)t);
#line 1270
      ntrunc = (int )tmp___2;
#line 1272
      twidth = mb_metastrlenend(t, 1, (char *)((void *)0));
      }
#line 1273
      if (twidth < bv->truncwidth) {
        {
#line 1274
        maxwidth = bv->truncwidth - twidth;
#line 1280
        addbufspc(ntrunc + 1);
#line 1282
        ptr___0 = bv->bp - fullen;
        }
#line 1284
        if (truncatleft) {
          {
#line 1301
          memset((void *)(& mbs), 0, sizeof(mbs));
#line 1304
          fulltext = ptr___0 + ntrunc;
#line 1304
          fulltextptr = fulltext;
#line 1305
          memmove((void *)fulltext, (void const   *)ptr___0, (size_t )fullen);
#line 1306
          *(fulltext + fullen) = (char )'\000';
          }
          {
#line 1309
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1309
            if (! *t) {
#line 1309
              goto while_break___1;
            }
#line 1310
            tmp___3 = ptr___0;
#line 1310
            ptr___0 ++;
#line 1310
            tmp___4 = t;
#line 1310
            t ++;
#line 1310
            *tmp___3 = *tmp___4;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1317
          remw = w;
          {
#line 1318
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1318
            if (remw > maxwidth) {
#line 1318
              if (! *fulltextptr) {
#line 1318
                goto while_break___2;
              }
            } else {
#line 1318
              goto while_break___2;
            }
#line 1319
            if ((int )*fulltextptr == -120) {
              {
#line 1329
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1330
                tmp___5 = ptr___0;
#line 1330
                ptr___0 ++;
#line 1330
                *tmp___5 = *fulltextptr;
#line 1331
                if ((int )*fulltextptr == 0) {
#line 1333
                  goto while_break___3;
                } else {
#line 1331
                  tmp___6 = fulltextptr;
#line 1331
                  fulltextptr ++;
#line 1331
                  if ((int )*tmp___6 == -118) {
#line 1333
                    goto while_break___3;
                  }
                }
#line 1334
                if ((int )*(fulltextptr + -1) == -95) {
#line 1335
                  remw --;
                }
              }
              while_break___3: /* CIL Label */ ;
              }
            } else {
#line 1352
              if ((int )*fulltextptr == -125) {
#line 1353
                fulltextptr ++;
#line 1353
                inchar = (char )((int )*fulltextptr ^ 32);
              } else {
#line 1355
                inchar = *fulltextptr;
              }
              {
#line 1356
              fulltextptr ++;
#line 1357
              tmp___7 = mbrtowc((wchar_t */* __restrict  */)(& cc), (char const   */* __restrict  */)(& inchar),
                                (size_t )1, (mbstate_t */* __restrict  */)(& mbs));
              }
              {
#line 1358
              if (tmp___7 == 0xfffffffffffffffeUL) {
#line 1358
                goto case_18446744073709551614;
              }
#line 1361
              if (tmp___7 == 0xffffffffffffffffUL) {
#line 1361
                goto case_18446744073709551615;
              }
#line 1365
              if (tmp___7 == 0UL) {
#line 1365
                goto case_0;
              }
#line 1369
              goto switch_default;
              case_18446744073709551614: /* CIL Label */ 
#line 1360
              goto switch_break;
              case_18446744073709551615: /* CIL Label */ 
              {
#line 1363
              memset((void *)(& mbs), 0, sizeof(mbs));
              }
              case_0: /* CIL Label */ 
#line 1367
              remw --;
#line 1368
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 1370
              wcw = wcwidth(cc);
              }
#line 1371
              if (wcw >= 0) {
#line 1372
                remw -= wcw;
              } else {
#line 1374
                remw --;
              }
#line 1375
              goto switch_break;
              switch_break: /* CIL Label */ ;
              }
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1391
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1391
            if (! *fulltextptr) {
#line 1391
              goto while_break___4;
            }
#line 1392
            tmp___8 = ptr___0;
#line 1392
            ptr___0 ++;
#line 1392
            tmp___9 = fulltextptr;
#line 1392
            fulltextptr ++;
#line 1392
            *tmp___8 = *tmp___9;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1394
          bv->bp = ptr___0;
        } else {
          {
#line 1401
          skiptext = ptr___0;
#line 1404
          memset((void *)(& mbs___0), 0, sizeof(mbs___0));
          }
          {
#line 1407
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1407
            if (maxwidth > 0) {
#line 1407
              if (! *skiptext) {
#line 1407
                goto while_break___5;
              }
            } else {
#line 1407
              goto while_break___5;
            }
#line 1408
            if ((int )*skiptext == -120) {
              {
#line 1410
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1411
                if ((int )*skiptext == 0) {
#line 1413
                  goto while_break___6;
                } else {
#line 1411
                  tmp___10 = skiptext;
#line 1411
                  skiptext ++;
#line 1411
                  if ((int )*tmp___10 == -118) {
#line 1413
                    goto while_break___6;
                  }
                }
#line 1414
                if ((int )*(skiptext + -1) == -95) {
#line 1415
                  maxwidth --;
                }
              }
              while_break___6: /* CIL Label */ ;
              }
            } else {
#line 1423
              if ((int )*skiptext == -125) {
#line 1424
                skiptext ++;
#line 1424
                inchar___0 = (char )((int )*skiptext ^ 32);
              } else {
#line 1426
                inchar___0 = *skiptext;
              }
              {
#line 1427
              skiptext ++;
#line 1428
              tmp___11 = mbrtowc((wchar_t */* __restrict  */)(& cc___0), (char const   */* __restrict  */)(& inchar___0),
                                 (size_t )1, (mbstate_t */* __restrict  */)(& mbs___0));
              }
              {
#line 1429
              if (tmp___11 == 0xfffffffffffffffeUL) {
#line 1429
                goto case_18446744073709551614___0;
              }
#line 1432
              if (tmp___11 == 0xffffffffffffffffUL) {
#line 1432
                goto case_18446744073709551615___0;
              }
#line 1436
              if (tmp___11 == 0UL) {
#line 1436
                goto case_0___0;
              }
#line 1440
              goto switch_default___0;
              case_18446744073709551614___0: /* CIL Label */ 
#line 1431
              goto switch_break___0;
              case_18446744073709551615___0: /* CIL Label */ 
              {
#line 1434
              memset((void *)(& mbs___0), 0, sizeof(mbs___0));
              }
              case_0___0: /* CIL Label */ 
#line 1438
              maxwidth --;
#line 1439
              goto switch_break___0;
              switch_default___0: /* CIL Label */ 
              {
#line 1441
              wcw___0 = wcwidth(cc___0);
              }
#line 1442
              if (wcw___0 >= 0) {
#line 1443
                maxwidth -= wcw___0;
              } else {
#line 1445
                maxwidth --;
              }
#line 1446
              goto switch_break___0;
              switch_break___0: /* CIL Label */ ;
              }
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1466
          ptr___0 = skiptext;
          {
#line 1467
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 1467
            if (! *t) {
#line 1467
              goto while_break___7;
            }
#line 1468
            tmp___12 = ptr___0;
#line 1468
            ptr___0 ++;
#line 1468
            tmp___13 = t;
#line 1468
            t ++;
#line 1468
            *tmp___12 = *tmp___13;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 1469
          bv->bp = ptr___0;
#line 1470
          if (*skiptext) {
            {
#line 1472
            tmp___14 = strlen((char const   *)skiptext);
#line 1472
            memmove((void *)bv->bp, (void const   *)skiptext, tmp___14 + 1UL);
#line 1473
            skiptext = bv->bp;
            }
            {
#line 1478
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 1478
              if (! *skiptext) {
#line 1478
                goto while_break___8;
              }
#line 1479
              if ((int )*skiptext == -120) {
                {
#line 1480
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 1481
                  tmp___15 = bv->bp;
#line 1481
                  (bv->bp) ++;
#line 1481
                  *tmp___15 = *skiptext;
#line 1482
                  if ((int )*skiptext == -118) {
#line 1484
                    goto while_break___9;
                  } else
#line 1482
                  if ((int )*skiptext == 0) {
#line 1484
                    goto while_break___9;
                  }
#line 1485
                  skiptext ++;
                }
                while_break___9: /* CIL Label */ ;
                }
              } else {
#line 1489
                skiptext ++;
              }
            }
            while_break___8: /* CIL Label */ ;
            }
          }
        }
      } else {
        {
#line 1495
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1495
          if (! *t) {
#line 1495
            goto while_break___10;
          }
#line 1496
          tmp___16 = ptr___0;
#line 1496
          ptr___0 ++;
#line 1496
          tmp___17 = t;
#line 1496
          t ++;
#line 1496
          *tmp___16 = *tmp___17;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 1497
        bv->bp = ptr___0;
      }
#line 1499
      *(bv->bp) = (char )'\000';
    }
    {
#line 1501
    zsfree(truncstr);
#line 1502
    bv->truncwidth = 0;
    }
#line 1508
    if (! *(bv->fm)) {
#line 1509
      return (0);
    }
#line 1510
    if ((int )*(bv->fm) != endchar) {
      {
#line 1511
      (bv->fm) ++;
#line 1516
      tmp___18 = putpromptchar(doprint, endchar, txtchangep);
      }
#line 1516
      if (! tmp___18) {
#line 1517
        return (0);
      }
    }
#line 1520
    (bv->fm) --;
  } else {
#line 1522
    if ((int )*(bv->fm) != endchar) {
#line 1523
      (bv->fm) ++;
    }
    {
#line 1524
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1524
      if (*(bv->fm)) {
#line 1524
        if (! ((int )*(bv->fm) != truncchar)) {
#line 1524
          goto while_break___11;
        }
      } else {
#line 1524
        goto while_break___11;
      }
#line 1525
      if ((int )*(bv->fm) == 92) {
#line 1525
        if (*(bv->fm + 1)) {
#line 1526
          (bv->fm) ++;
        }
      }
#line 1527
      (bv->fm) ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1529
    if (bv->truncwidth) {
#line 1530
      return (0);
    } else
#line 1529
    if (! *(bv->fm)) {
#line 1530
      return (0);
    }
  }
#line 1532
  return (1);
}
}
#line 1536 "/tmp/zsh-5.4.2/Src/prompt.c"
void cmdpush(int cmdtok ) 
{ 
  int tmp ;

  {
#line 1539
  if (cmdsp >= 0) {
#line 1539
    if (cmdsp < 256) {
#line 1540
      tmp = cmdsp;
#line 1540
      cmdsp ++;
#line 1540
      *(cmdstack + tmp) = (unsigned char )cmdtok;
    }
  }
#line 1541
  return;
}
}
#line 1544 "/tmp/zsh-5.4.2/Src/prompt.c"
void cmdpop(void) 
{ 


  {
#line 1547
  if (cmdsp <= 0) {
    {
#line 1549
    fflush(stderr);
    }
  } else {
#line 1551
    cmdsp --;
  }
#line 1552
  return;
}
}
#line 1563 "/tmp/zsh-5.4.2/Src/prompt.c"
static char const   *ansi_colours[10]  = 
#line 1563
  {      "black",      "red",      "green",      "yellow", 
        "blue",      "magenta",      "cyan",      "white", 
        "default",      (char const   *)((void *)0)};
#line 1575 "/tmp/zsh-5.4.2/Src/prompt.c"
static struct highlight  const  highlights[5]  = {      {"none", 0, 31}, 
        {"bold", 1, 0}, 
        {"standout", 2, 0}, 
        {"underline", 4, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 1591 "/tmp/zsh-5.4.2/Src/prompt.c"
static int match_named_colour(char const   **teststrp ) 
{ 
  char const   *teststr ;
  char const   *end ;
  char const   **cptr ;
  int len ;
  int tmp ;

  {
#line 1594
  teststr = *teststrp;
#line 1597
  end = teststr;
  {
#line 1597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1597
    if (! ((int )typtab[(unsigned char )*end] & (1 << 6))) {
#line 1597
      goto while_break;
    }
#line 1597
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1599
  len = (int )(end - teststr);
#line 1600
  *teststrp = end;
#line 1602
  cptr = ansi_colours;
  {
#line 1602
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1602
    if (! *cptr) {
#line 1602
      goto while_break___0;
    }
    {
#line 1603
    tmp = strncmp(teststr, *cptr, (size_t )len);
    }
#line 1603
    if (! tmp) {
#line 1604
      return ((int )(cptr - ansi_colours));
    }
#line 1602
    cptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1607
  return (-1);
}
}
#line 1619 "/tmp/zsh-5.4.2/Src/prompt.c"
int match_colour(char const   **teststrp , int is_fg , int colour ) 
{ 
  int shft ;
  int on ;
  int named ;
  int tc ;
  int tmp ;
  zlong tmp___0 ;
  int tmp___1 ;

  {
#line 1622
  named = 0;
#line 1624
  if (teststrp) {
#line 1625
    named = (int )typtab[(unsigned char )*(*teststrp)] & (1 << 6);
#line 1625
    if (named) {
      {
#line 1626
      colour = match_named_colour(teststrp);
      }
#line 1627
      if (colour == 8) {
#line 1629
        if (is_fg) {
#line 1629
          tmp = 256;
        } else {
#line 1629
          tmp = 512;
        }
#line 1629
        return (tmp);
      }
    } else {
      {
#line 1633
      tmp___0 = zstrtol(*teststrp, (char **)teststrp, 10);
#line 1633
      colour = (int )tmp___0;
      }
    }
  }
#line 1635
  if (colour < 0) {
#line 1636
    return (-1);
  } else
#line 1635
  if (colour >= 256) {
#line 1636
    return (-1);
  }
#line 1637
  if (is_fg) {
#line 1638
    shft = 12;
#line 1639
    on = 8;
#line 1640
    tc = 32;
  } else {
#line 1642
    shft = 20;
#line 1643
    on = 16;
#line 1644
    tc = 33;
  }
#line 1651
  if (! named) {
#line 1651
    if (tclen[tc]) {
#line 1652
      if (tccolours >= 0) {
#line 1652
        if (colour >= tccolours) {
#line 1657
          if (colour > 7) {
#line 1658
            return (-1);
          }
        } else {
#line 1652
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1664
        if (is_fg) {
#line 1664
          tmp___1 = 268435456;
        } else {
#line 1664
          tmp___1 = 536870912;
        }
#line 1664
        on |= tmp___1;
      }
    }
  }
#line 1668
  return (on | (colour << shft));
}
}
#line 1677 "/tmp/zsh-5.4.2/Src/prompt.c"
void match_highlight(char const   *teststr , int *on_var ) 
{ 
  int found ;
  struct highlight  const  *hl ;
  int is_fg ;
  int atr ;
  char const   *val ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1680
  found = 1;
#line 1682
  *on_var = 0;
  {
#line 1683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1683
    if (found) {
#line 1683
      if (! *teststr) {
#line 1683
        goto while_break;
      }
    } else {
#line 1683
      goto while_break;
    }
    {
#line 1686
    found = 0;
#line 1687
    tmp___1 = strpfx("fg=", teststr);
    }
#line 1687
    if (tmp___1) {
#line 1687
      goto _L;
    } else {
      {
#line 1687
      tmp___2 = strpfx("bg=", teststr);
      }
#line 1687
      if (tmp___2) {
        _L: /* CIL Label */ 
        {
#line 1688
        is_fg = (int const   )*(teststr + 0) == 102;
#line 1690
        teststr += 3;
#line 1691
        atr = match_colour(& teststr, is_fg, 0);
        }
#line 1692
        if ((int const   )*teststr == 44) {
#line 1693
          teststr ++;
        } else
#line 1694
        if (*teststr) {
#line 1695
          goto while_break;
        }
#line 1696
        found = 1;
#line 1698
        if (atr >= 0) {
#line 1699
          *on_var |= atr;
        }
      } else {
#line 1701
        hl = highlights;
        {
#line 1701
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1701
          if (! hl->name) {
#line 1701
            goto while_break___0;
          }
          {
#line 1702
          tmp___0 = strpfx((char const   *)hl->name, teststr);
          }
#line 1702
          if (tmp___0) {
            {
#line 1703
            tmp = strlen((char const   *)hl->name);
#line 1703
            val = teststr + tmp;
            }
#line 1705
            if ((int const   )*val == 44) {
#line 1706
              val ++;
            } else
#line 1707
            if (*val) {
#line 1708
              goto while_break___0;
            }
#line 1710
            *on_var |= (int )hl->mask_on;
#line 1711
            *on_var &= (int )(~ hl->mask_off);
#line 1712
            teststr = val;
#line 1713
            found = 1;
          }
#line 1701
          hl ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1718
  return;
}
}
#line 1725 "/tmp/zsh-5.4.2/Src/prompt.c"
static int output_colour(int colour , int fg_bg , int use_tc , char *buf___7 ) 
{ 
  int atrlen ;
  int len ;
  char *ptr___0 ;
  char const   *tmp ;
  char digbuf[(int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3] ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 1728
  atrlen = 3;
#line 1729
  ptr___0 = buf___7;
#line 1730
  if (buf___7) {
#line 1731
    if (fg_bg == 0) {
#line 1731
      tmp = "fg=";
    } else {
#line 1731
      tmp = "bg=";
    }
    {
#line 1731
    strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)tmp);
#line 1732
    ptr___0 += 3;
    }
  }
#line 1735
  if (use_tc) {
#line 1735
    goto _L;
  } else
#line 1735
  if (colour > 7) {
    _L: /* CIL Label */ 
    {
#line 1737
    sprintf((char */* __restrict  */)(digbuf), (char const   */* __restrict  */)"%d",
            colour);
#line 1738
    tmp___0 = strlen((char const   *)(digbuf));
#line 1738
    len = (int )tmp___0;
#line 1739
    atrlen += len;
    }
#line 1740
    if (buf___7) {
      {
#line 1741
      strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)(digbuf));
      }
    }
  } else {
    {
#line 1743
    tmp___1 = strlen(ansi_colours[colour]);
#line 1743
    len = (int )tmp___1;
#line 1744
    atrlen += len;
    }
#line 1745
    if (buf___7) {
      {
#line 1746
      strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)ansi_colours[colour]);
      }
    }
  }
#line 1749
  return (atrlen);
}
}
#line 1762 "/tmp/zsh-5.4.2/Src/prompt.c"
int output_highlight(int atr , char *buf___7 ) 
{ 
  struct highlight  const  *hp ;
  int atrlen ;
  int len ;
  char *ptr___0 ;
  size_t tmp ;

  {
#line 1766
  atrlen = 0;
#line 1767
  ptr___0 = buf___7;
#line 1769
  if (atr & 8) {
    {
#line 1770
    len = output_colour((atr & 1044480) >> 12, 0, atr & 268435456, ptr___0);
#line 1774
    atrlen += len;
    }
#line 1775
    if (buf___7) {
#line 1776
      ptr___0 += len;
    }
  }
#line 1778
  if (atr & 16) {
#line 1779
    if (atrlen) {
#line 1780
      atrlen ++;
#line 1781
      if (buf___7) {
        {
#line 1782
        strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)",");
#line 1783
        ptr___0 ++;
        }
      }
    }
    {
#line 1786
    len = output_colour((atr & 267386880) >> 20, 1, atr & 536870912, ptr___0);
#line 1790
    atrlen += len;
    }
#line 1791
    if (buf___7) {
#line 1792
      ptr___0 += len;
    }
  }
#line 1794
  hp = highlights;
  {
#line 1794
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1794
    if (! hp->name) {
#line 1794
      goto while_break;
    }
#line 1795
    if (hp->mask_on & (int const   )atr) {
#line 1796
      if (atrlen) {
#line 1797
        atrlen ++;
#line 1798
        if (buf___7) {
          {
#line 1799
          strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)",");
#line 1800
          ptr___0 ++;
          }
        }
      }
      {
#line 1803
      tmp = strlen((char const   *)hp->name);
#line 1803
      len = (int )tmp;
#line 1804
      atrlen += len;
      }
#line 1805
      if (buf___7) {
        {
#line 1806
        strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)hp->name);
#line 1807
        ptr___0 += len;
        }
      }
    }
#line 1794
    hp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1812
  if (atrlen == 0) {
#line 1813
    if (buf___7) {
      {
#line 1814
      strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)"none");
      }
    }
#line 1815
    return (4);
  }
#line 1817
  return (atrlen);
}
}
#line 1841 "/tmp/zsh-5.4.2/Src/prompt.c"
static struct colour_sequences fg_bg_sequences[2]  ;
#line 1849 "/tmp/zsh-5.4.2/Src/prompt.c"
static char *colseq_buf  ;
#line 1854 "/tmp/zsh-5.4.2/Src/prompt.c"
static int colseq_buf_allocs  ;
#line 1857 "/tmp/zsh-5.4.2/Src/prompt.c"
void set_default_colour_sequences(void) 
{ 


  {
  {
#line 1860
  fg_bg_sequences[0].start = ztrdup("\033[3");
#line 1861
  fg_bg_sequences[0].end = ztrdup("m");
#line 1862
  fg_bg_sequences[0].def = ztrdup("9");
#line 1864
  fg_bg_sequences[1].start = ztrdup("\033[4");
#line 1865
  fg_bg_sequences[1].end = ztrdup("m");
#line 1866
  fg_bg_sequences[1].def = ztrdup("9");
  }
#line 1867
  return;
}
}
#line 1869 "/tmp/zsh-5.4.2/Src/prompt.c"
static void set_colour_code(char *str , char **var ) 
{ 
  char *keyseq ;
  int len ;

  {
  {
#line 1875
  zsfree(*var);
#line 1876
  keyseq = getkeystring(str, & len, 7, (int *)((void *)0));
#line 1877
  *var = metafy(keyseq, len, 3);
  }
#line 1878
  return;
}
}
#line 1883 "/tmp/zsh-5.4.2/Src/prompt.c"
void allocate_colour_buffer(void) 
{ 
  char **atrs ;
  int lenfg ;
  int lenbg ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;

  {
#line 1889
  tmp = colseq_buf_allocs;
#line 1889
  colseq_buf_allocs ++;
#line 1889
  if (tmp) {
#line 1890
    return;
  }
  {
#line 1892
  atrs = getaparam((char *)"zle_highlight");
  }
#line 1893
  if (atrs) {
    {
#line 1894
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1894
      if (! *atrs) {
#line 1894
        goto while_break;
      }
      {
#line 1895
      tmp___5 = strpfx("fg_start_code:", (char const   *)*atrs);
      }
#line 1895
      if (tmp___5) {
        {
#line 1896
        set_colour_code(*atrs + 14, & fg_bg_sequences[0].start);
        }
      } else {
        {
#line 1897
        tmp___4 = strpfx("fg_default_code:", (char const   *)*atrs);
        }
#line 1897
        if (tmp___4) {
          {
#line 1898
          set_colour_code(*atrs + 16, & fg_bg_sequences[0].def);
          }
        } else {
          {
#line 1899
          tmp___3 = strpfx("fg_end_code:", (char const   *)*atrs);
          }
#line 1899
          if (tmp___3) {
            {
#line 1900
            set_colour_code(*atrs + 12, & fg_bg_sequences[0].end);
            }
          } else {
            {
#line 1901
            tmp___2 = strpfx("bg_start_code:", (char const   *)*atrs);
            }
#line 1901
            if (tmp___2) {
              {
#line 1902
              set_colour_code(*atrs + 14, & fg_bg_sequences[1].start);
              }
            } else {
              {
#line 1903
              tmp___1 = strpfx("bg_default_code:", (char const   *)*atrs);
              }
#line 1903
              if (tmp___1) {
                {
#line 1904
                set_colour_code(*atrs + 16, & fg_bg_sequences[1].def);
                }
              } else {
                {
#line 1905
                tmp___0 = strpfx("bg_end_code:", (char const   *)*atrs);
                }
#line 1905
                if (tmp___0) {
                  {
#line 1906
                  set_colour_code(*atrs + 12, & fg_bg_sequences[1].end);
                  }
                }
              }
            }
          }
        }
      }
#line 1894
      atrs ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1911
  tmp___6 = strlen((char const   *)fg_bg_sequences[0].def);
#line 1911
  lenfg = (int )tmp___6;
  }
#line 1913
  if (lenfg < 1) {
#line 1914
    lenfg = 1;
  }
  {
#line 1915
  tmp___7 = strlen((char const   *)fg_bg_sequences[0].start);
#line 1915
  tmp___8 = strlen((char const   *)fg_bg_sequences[0].end);
#line 1915
  lenfg = (int )((size_t )lenfg + (tmp___7 + tmp___8));
#line 1918
  tmp___9 = strlen((char const   *)fg_bg_sequences[1].def);
#line 1918
  lenbg = (int )tmp___9;
  }
#line 1920
  if (lenbg < 1) {
#line 1921
    lenbg = 1;
  }
  {
#line 1922
  tmp___10 = strlen((char const   *)fg_bg_sequences[1].start);
#line 1922
  tmp___11 = strlen((char const   *)fg_bg_sequences[1].end);
#line 1922
  lenbg = (int )((size_t )lenbg + (tmp___10 + tmp___11));
  }
#line 1925
  if (lenfg > lenbg) {
#line 1925
    len = lenfg;
  } else {
#line 1925
    len = lenbg;
  }
  {
#line 1926
  tmp___12 = zalloc((size_t )(len + 1));
#line 1926
  colseq_buf = (char *)tmp___12;
  }
#line 1927
  return;
}
}
#line 1932 "/tmp/zsh-5.4.2/Src/prompt.c"
void free_colour_buffer(void) 
{ 


  {
#line 1935
  colseq_buf_allocs --;
#line 1935
  if (colseq_buf_allocs) {
#line 1936
    return;
  }
  {
#line 1940
  free((void *)colseq_buf);
#line 1941
  colseq_buf = (char *)((void *)0);
  }
#line 1942
  return;
}
}
#line 1956 "/tmp/zsh-5.4.2/Src/prompt.c"
void set_colour_attribute(int atr , int fg_bg , int flags ) 
{ 
  char *ptr___0 ;
  int do_free ;
  int is_prompt ;
  int tmp ;
  int colour ;
  int tc ;
  int def ;
  int use_termcap ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 1960
  if (flags & 2) {
#line 1960
    tmp = 1;
  } else {
#line 1960
    tmp = 0;
  }
#line 1960
  is_prompt = tmp;
#line 1963
  if (fg_bg == 0) {
#line 1964
    colour = (atr & 1044480) >> 12;
#line 1965
    tc = 32;
#line 1966
    def = atr & 256;
#line 1967
    use_termcap = atr & 268435456;
  } else {
#line 1969
    colour = (atr & 267386880) >> 20;
#line 1970
    tc = 33;
#line 1971
    def = atr & 512;
#line 1972
    use_termcap = atr & 536870912;
  }
#line 1984
  if (! def) {
#line 1984
    if (colour > 7) {
#line 1984
      goto _L___0;
    } else
#line 1984
    if (use_termcap) {
      _L___0: /* CIL Label */ 
#line 1989
      if (tclen[tc]) {
#line 1989
        if (tccolours < 0) {
#line 1989
          goto _L;
        } else
#line 1989
        if (colour < tccolours) {
          _L: /* CIL Label */ 
#line 1991
          if (is_prompt) {
#line 1993
            if (! bv->dontcount) {
              {
#line 1994
              addbufspc(1);
#line 1995
              tmp___0 = bv->bp;
#line 1995
              (bv->bp) ++;
#line 1995
              *tmp___0 = (char)-120;
              }
            }
            {
#line 1997
            tmp___1 = tgoto((char const   *)tcstr[tc], colour, colour);
#line 1997
            tputs((char const   *)tmp___1, 1, & putstr);
            }
#line 1998
            if (! bv->dontcount) {
              {
#line 1999
              addbufspc(1);
#line 2000
              tmp___2 = bv->bp;
#line 2000
              (bv->bp) ++;
#line 2000
              *tmp___2 = (char)-118;
              }
            }
          } else {
            {
#line 2003
            tmp___3 = tgoto((char const   *)tcstr[tc], colour, colour);
#line 2003
            tputs((char const   *)tmp___3, 1, & putshout);
            }
          }
#line 2006
          return;
        }
      }
#line 2012
      if (colour > 7) {
#line 2013
        return;
      }
    }
  }
#line 2016
  do_free = (unsigned long )colseq_buf == (unsigned long )((void *)0);
#line 2016
  if (do_free) {
    {
#line 2018
    allocate_colour_buffer();
    }
  }
  {
#line 2021
  strcpy((char */* __restrict  */)colseq_buf, (char const   */* __restrict  */)fg_bg_sequences[fg_bg].start);
#line 2023
  tmp___4 = strlen((char const   *)colseq_buf);
#line 2023
  ptr___0 = colseq_buf + tmp___4;
  }
#line 2024
  if (def) {
    {
#line 2025
    strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)fg_bg_sequences[fg_bg].def);
    }
    {
#line 2026
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2026
      if (! *ptr___0) {
#line 2026
        goto while_break;
      }
#line 2027
      ptr___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 2029
    tmp___5 = ptr___0;
#line 2029
    ptr___0 ++;
#line 2029
    *tmp___5 = (char )(colour + 48);
  }
  {
#line 2030
  strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)fg_bg_sequences[fg_bg].end);
  }
#line 2032
  if (is_prompt) {
#line 2033
    if (! bv->dontcount) {
      {
#line 2034
      addbufspc(1);
#line 2035
      tmp___6 = bv->bp;
#line 2035
      (bv->bp) ++;
#line 2035
      *tmp___6 = (char)-120;
      }
    }
    {
#line 2037
    tputs((char const   *)colseq_buf, 1, & putstr);
    }
#line 2038
    if (! bv->dontcount) {
      {
#line 2039
      addbufspc(1);
#line 2040
      tmp___7 = bv->bp;
#line 2040
      (bv->bp) ++;
#line 2040
      *tmp___7 = (char)-118;
      }
    }
  } else {
    {
#line 2043
    tputs((char const   *)colseq_buf, 1, & putshout);
    }
  }
#line 2045
  if (do_free) {
    {
#line 2046
    free_colour_buffer();
    }
  }
#line 2047
  return;
}
}
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 101 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int iswalpha(wint_t __wc ) ;
#line 104
extern  __attribute__((__nothrow__)) int iswcntrl(wint_t __wc ) ;
#line 108
extern  __attribute__((__nothrow__)) int iswdigit(wint_t __wc ) ;
#line 112
extern  __attribute__((__nothrow__)) int iswgraph(wint_t __wc ) ;
#line 117
extern  __attribute__((__nothrow__)) int iswlower(wint_t __wc ) ;
#line 125
extern  __attribute__((__nothrow__)) int iswpunct(wint_t __wc ) ;
#line 135
extern  __attribute__((__nothrow__)) int iswupper(wint_t __wc ) ;
#line 140
extern  __attribute__((__nothrow__)) int iswxdigit(wint_t __wc ) ;
#line 169
extern  __attribute__((__nothrow__)) wint_t towupper(wint_t __wc ) ;
#line 6 "./glob.epro"
int pathpos ;
#line 7
char *pathbuf ;
#line 5 "./pattern.epro"
char const   *zpc_strings[19] ;
#line 6 "./pattern.epro"
char zpc_disables[19]  ;
#line 7 "./pattern.epro"
char zpc_special[19]  ;
#line 8
void patcompstart(void) ;
#line 10
int patgetglobflags(char **strp , long *assertp , int *ignore ) ;
#line 11
int range_type(char *start , int len ) ;
#line 12
int pattern_range_to_string(char *rangestr , char *outstr ) ;
#line 13 "./pattern.epro"
int errsfound  ;
#line 14 "./pattern.epro"
int forceerrs  ;
#line 15
void pattrystart(void) ;
#line 16
char *patallocstr(Patprog prog , char *string , int stringlen , int unmetalen , int force ,
                  Patstralloc patstralloc ) ;
#line 18
int pattrylen(Patprog prog , char *string , int len , int unmetalen , Patstralloc patstralloc ,
              int offset ) ;
#line 19
int pattryrefs(Patprog prog , char *string , int stringlen , int unmetalenin , Patstralloc patstralloc ,
               int patoffset , int *nump , int *begp , int *endp ) ;
#line 20
int patmatchlen(void) ;
#line 22
int mb_patmatchrange(char *range , wchar_t ch , int zmb_ind , wint_t *indptr , int *mtp ) ;
#line 23
int mb_patmatchindex(char *range , wint_t ind , wint_t *chr , int *mtp ) ;
#line 25
int patmatchrange(char *range , int ch , int *indptr , int *mtp ) ;
#line 29
void freepatprog(Patprog prog ) ;
#line 30
int pat_enables(char const   *cmd , char **patp , int enable ) ;
#line 31
unsigned int savepatterndisables(void) ;
#line 32
void startpatternscope(void) ;
#line 33
void restorepatterndisables(unsigned int disables ) ;
#line 34
void endpatternscope(void) ;
#line 35
void clearpatterndisables(void) ;
#line 36
int haswilds(char *str ) ;
#line 2 "./pattern.pro"
static void patadd(char *add___0 , int ch , long n , int paflags ) ;
#line 3
static long patcompswitch(int paren , int *flagp ) ;
#line 4
static long patcompbranch(int *flagp , int paren ) ;
#line 5
static long patcomppiece(int *flagp , int paren ) ;
#line 6
static long patcompnot(int paren , int *flagsp ) ;
#line 7
static long patnode(long op___0 ) ;
#line 8
static void patinsert(long op___0 , int opnd , char *xtra , int sz___0 ) ;
#line 9
static void pattail(long p , long val ) ;
#line 10
static void patoptail(long p , long val ) ;
#line 11
static void patmungestring(char **string , int *stringlen , int *unmetalenin ) ;
#line 12
static int patmatch(Upat prog ) ;
#line 17
static int patrepeat(Upat p , char *charstart ) ;
#line 248 "/tmp/zsh-5.4.2/Src/pattern.c"
static char const   zpc_chars[19]  = 
#line 248 "/tmp/zsh-5.4.2/Src/pattern.c"
  {      (char const   )'/',      (char const   )'\000',      (char const   )(char)-114,      (char const   )(char)-118, 
        (char const   )(char)-104,      (char const   )(char)-120,      (char const   )(char)-105,      (char const   )(char)-121, 
        (char const   )(char)-111,      (char const   )(char)-108,      (char const   )(char)-122,      (char const   )(char)-124, 
        (char const   )(char)-96,      (char const   )(char)-105,      (char const   )(char)-121,      (char const   )'+', 
        (char const   )(char)-100,      (char const   )'!',      (char const   )'@'};
#line 258 "/tmp/zsh-5.4.2/Src/pattern.c"
char const   *zpc_strings[19]  = 
#line 258
  {      (char const   *)((void *)0),      (char const   *)((void *)0),      "|",      (char const   *)((void *)0), 
        "~",      "(",      "?",      "*", 
        "[",      "<",      "^",      "#", 
        (char const   *)((void *)0),      "?(",      "*(",      "+(", 
        "!(",      "\\!(",      "@("};
#line 274 "/tmp/zsh-5.4.2/Src/pattern.c"
static struct zpc_disables_save *zpc_disables_stack  ;
#line 295 "/tmp/zsh-5.4.2/Src/pattern.c"
static char *patstart  ;
#line 295 "/tmp/zsh-5.4.2/Src/pattern.c"
static char *patparse  ;
#line 296 "/tmp/zsh-5.4.2/Src/pattern.c"
static int patnpar  ;
#line 297 "/tmp/zsh-5.4.2/Src/pattern.c"
static char *patcode  ;
#line 298 "/tmp/zsh-5.4.2/Src/pattern.c"
static long patsize  ;
#line 299 "/tmp/zsh-5.4.2/Src/pattern.c"
static char *patout  ;
#line 300 "/tmp/zsh-5.4.2/Src/pattern.c"
static long patalloc  ;
#line 303 "/tmp/zsh-5.4.2/Src/pattern.c"
static int patflags  ;
#line 304 "/tmp/zsh-5.4.2/Src/pattern.c"
static int patglobflags  ;
#line 321 "/tmp/zsh-5.4.2/Src/pattern.c"
static mbstate_t shiftstate  ;
#line 327 "/tmp/zsh-5.4.2/Src/pattern.c"
static wchar_t metacharinc(char **x ) 
{ 
  char *inptr ;
  char inchar ;
  size_t ret ;
  wchar_t wc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 330
  inptr = *x;
#line 332
  ret = (size_t )-1;
#line 341
  if (! (patglobflags & 4096)) {
#line 341
    goto _L;
  } else
#line 341
  if (! ((int )((unsigned char )*inptr) & 128)) {
    _L: /* CIL Label */ 
#line 343
    if ((int )typtab[(unsigned char )*inptr] & (1 << 4)) {
#line 344
      tmp = inptr;
#line 344
      inptr ++;
#line 344
      inchar = ztokens[(int )*tmp - -124];
    } else
#line 345
    if ((int )*inptr == -125) {
#line 346
      inptr ++;
#line 347
      tmp___0 = inptr;
#line 347
      inptr ++;
#line 347
      inchar = (char )((int )*tmp___0 ^ 32);
    } else {
#line 349
      tmp___1 = inptr;
#line 349
      inptr ++;
#line 349
      inchar = *tmp___1;
    }
#line 351
    *x = inptr;
#line 352
    return ((wchar_t )((unsigned char )inchar));
  }
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! *inptr) {
#line 355
      goto while_break;
    }
#line 356
    if ((int )typtab[(unsigned char )*inptr] & (1 << 4)) {
#line 357
      tmp___2 = inptr;
#line 357
      inptr ++;
#line 357
      inchar = ztokens[(int )*tmp___2 - -124];
    } else
#line 358
    if ((int )*inptr == -125) {
#line 359
      inptr ++;
#line 360
      tmp___3 = inptr;
#line 360
      inptr ++;
#line 360
      inchar = (char )((int )*tmp___3 ^ 32);
    } else {
#line 362
      tmp___4 = inptr;
#line 362
      inptr ++;
#line 362
      inchar = *tmp___4;
    }
    {
#line 364
    ret = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)(& inchar),
                  (size_t )1, (mbstate_t */* __restrict  */)(& shiftstate));
    }
#line 366
    if (ret == 0xffffffffffffffffUL) {
#line 367
      goto while_break;
    }
#line 368
    if (ret == 0xfffffffffffffffeUL) {
#line 369
      goto while_continue;
    }
#line 370
    *x = inptr;
#line 371
    return (wc);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  memset((void *)(& shiftstate), 0, sizeof(shiftstate));
#line 377
  tmp___5 = *x;
#line 377
  (*x) ++;
  }
#line 377
  return (56320 + (int )((unsigned char )*tmp___5));
}
}
#line 403 "/tmp/zsh-5.4.2/Src/pattern.c"
static void patadd(char *add___0 , int ch , long n , int paflags ) 
{ 
  long newpatsize ;
  long newpatalloc ;
  long tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  long tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  long tmp___10 ;
  char *tmp___11 ;

  {
#line 407
  newpatsize = patsize + n;
#line 408
  if (! (paflags & 1)) {
#line 409
    newpatsize = (long )((((unsigned long )newpatsize + sizeof(union upat )) - 1UL) & ~ (sizeof(union upat ) - 1UL));
  }
#line 411
  if (patalloc < newpatsize) {
#line 412
    if (newpatsize > patalloc) {
#line 412
      tmp = newpatsize;
    } else {
#line 412
      tmp = patalloc;
    }
    {
#line 412
    newpatalloc = 2L * tmp;
#line 414
    tmp___0 = zrealloc((void *)patout, (size_t )newpatalloc);
#line 414
    patout = (char *)tmp___0;
#line 415
    patcode = patout + patsize;
#line 416
    patalloc = newpatalloc;
    }
  }
#line 418
  patsize = newpatsize;
#line 419
  if (add___0) {
#line 420
    if (paflags & 2) {
      {
#line 425
      while (1) {
        while_continue: /* CIL Label */ ;
#line 425
        tmp___7 = n;
#line 425
        n --;
#line 425
        if (! tmp___7) {
#line 425
          goto while_break;
        }
#line 426
        if ((int )typtab[(unsigned char )*add___0] & (1 << 4)) {
#line 427
          tmp___1 = patcode;
#line 427
          patcode ++;
#line 427
          tmp___2 = add___0;
#line 427
          add___0 ++;
#line 427
          *tmp___1 = ztokens[(int )*tmp___2 - -124];
        } else
#line 428
        if ((int )*add___0 == -125) {
#line 429
          add___0 ++;
#line 430
          tmp___3 = patcode;
#line 430
          patcode ++;
#line 430
          tmp___4 = add___0;
#line 430
          add___0 ++;
#line 430
          *tmp___3 = (char )((int )*tmp___4 ^ 32);
        } else {
#line 432
          tmp___5 = patcode;
#line 432
          patcode ++;
#line 432
          tmp___6 = add___0;
#line 432
          add___0 ++;
#line 432
          *tmp___5 = *tmp___6;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 436
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 436
        tmp___10 = n;
#line 436
        n --;
#line 436
        if (! tmp___10) {
#line 436
          goto while_break___0;
        }
#line 437
        tmp___8 = patcode;
#line 437
        patcode ++;
#line 437
        tmp___9 = add___0;
#line 437
        add___0 ++;
#line 437
        *tmp___8 = *tmp___9;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 440
    tmp___11 = patcode;
#line 440
    patcode ++;
#line 440
    *tmp___11 = (char )ch;
  }
#line 441
  patcode = patout + patsize;
#line 442
  return;
}
}
#line 444 "/tmp/zsh-5.4.2/Src/pattern.c"
static long rn_offs  ;
#line 455 "/tmp/zsh-5.4.2/Src/pattern.c"
static void patcompcharsset(void) 
{ 
  char *spp ;
  char *disp ;
  int i ;

  {
  {
#line 462
  memcpy((void */* __restrict  */)(zpc_special), (void const   */* __restrict  */)(zpc_chars),
         (size_t )19);
#line 464
  i = 0;
#line 464
  spp = zpc_special;
#line 464
  disp = zpc_disables;
  }
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (! (i < 19)) {
#line 464
      goto while_break;
    }
#line 467
    if (*disp) {
#line 468
      *spp = (char)-94;
    }
#line 464
    i ++;
#line 464
    spp ++;
#line 464
    disp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  if (! opts[53]) {
#line 473
    zpc_special[11] = (char)-94;
#line 473
    zpc_special[10] = zpc_special[11];
#line 473
    zpc_special[4] = zpc_special[10];
  }
#line 476
  if (! opts[97]) {
#line 482
    zpc_special[18] = (char)-94;
#line 482
    zpc_special[17] = zpc_special[18];
#line 482
    zpc_special[16] = zpc_special[17];
#line 482
    zpc_special[15] = zpc_special[16];
#line 482
    zpc_special[14] = zpc_special[15];
#line 482
    zpc_special[13] = zpc_special[14];
  }
#line 492
  if (opts[159]) {
#line 501
    zpc_special[9] = (char)-94;
#line 501
    zpc_special[5] = zpc_special[9];
  }
#line 503
  return;
}
}
#line 508 "/tmp/zsh-5.4.2/Src/pattern.c"
void patcompstart(void) 
{ 


  {
  {
#line 511
  patcompcharsset();
  }
#line 512
  if (opts[26]) {
#line 513
    patglobflags = 0;
  } else {
#line 515
    patglobflags = 512;
  }
#line 516
  if (opts[117]) {
#line 517
    patglobflags |= 4096;
  }
#line 518
  return;
}
}
#line 531 "/tmp/zsh-5.4.2/Src/pattern.c"
Patprog patcompile(char *exp , int inflags , char **endexp ) 
{ 
  int flags ;
  long len ;
  long startoff ;
  Upat pscan ;
  char *lng ;
  char *strp ;
  Patprog p ;
  void *tmp ;
  sigset_t oset ;
  long tmp___0 ;
  char *dst ;
  Upat next___0 ;
  Upat tmp___1 ;
  char *opnd ;
  char *mtest ;
  long oplen ;
  long ilen ;
  int nmeta ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  long tmp___7 ;
  Upat tmp___8 ;
  Upat tmp___9 ;
  Upat tmp___10 ;
  Patprog newp ;
  void *tmp___11 ;
  Patprog newp___0 ;
  void *tmp___12 ;
  sigset_t oset___0 ;

  {
#line 534
  flags = 0;
#line 535
  len = 0L;
#line 538
  strp = (char *)((void *)0);
#line 541
  queueing_enabled ++;
#line 543
  startoff = (long )sizeof(struct patprog );
#line 545
  startoff = (long )((((unsigned long )startoff + sizeof(union upat )) - 1UL) & ~ (sizeof(union upat ) - 1UL));
#line 548
  if (patalloc != 256L) {
    {
#line 549
    patalloc = 256L;
#line 549
    tmp = zrealloc((void *)patout, (size_t )patalloc);
#line 549
    patout = (char *)tmp;
    }
  }
#line 550
  patcode = patout + startoff;
#line 551
  patsize = patcode - patout;
#line 552
  patparse = exp;
#line 552
  patstart = patparse;
#line 557
  patnpar = 1;
#line 558
  patflags = inflags & -2081;
#line 560
  if (! (patflags & 1)) {
    {
#line 561
    patcompcharsset();
#line 562
    zpc_special[0] = (char)-94;
#line 563
    remnulargs(patparse);
    }
#line 564
    if (opts[117]) {
#line 565
      patglobflags = 4096;
    } else {
#line 567
      patglobflags = 0;
    }
  }
#line 569
  if (patflags & 4096) {
#line 570
    patglobflags |= 256;
  }
#line 574
  ((Patprog )patout)->globflags = patglobflags;
#line 576
  if (! (patflags & 4)) {
#line 578
    if (! (patglobflags & -4097)) {
#line 595
      if ((int )*exp == -95) {
#line 596
        exp ++;
      }
#line 597
      strp = exp;
      {
#line 597
      while (1) {
        while_continue: /* CIL Label */ ;
#line 597
        if (*strp) {
#line 597
          if (! (patflags & 1)) {
#line 597
            goto _L;
          } else
#line 597
          if ((int )*strp != 47) {
            _L: /* CIL Label */ 
#line 597
            if (! (! ((int )typtab[(unsigned char )*strp] & (1 << 4)))) {
#line 597
              goto while_break;
            }
          } else {
#line 597
            goto while_break;
          }
        } else {
#line 597
          goto while_break;
        }
#line 597
        strp ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 602
    if (! strp) {
#line 602
      goto _L___0;
    } else
#line 602
    if (*strp) {
#line 602
      if ((int )*strp != 47) {
        _L___0: /* CIL Label */ 
        {
#line 604
        strp = (char *)((void *)0);
#line 605
        tmp___0 = patcompswitch(0, & flags);
        }
#line 605
        if (tmp___0 == 0L) {
          {
#line 606
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 606
            queueing_enabled --;
#line 606
            if (! queueing_enabled) {
              {
#line 606
              while (1) {
                while_continue___1: /* CIL Label */ ;
                {
#line 606
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 606
                  if (! (queue_front != queue_rear)) {
#line 606
                    goto while_break___2;
                  }
                  {
#line 606
                  queue_front = (queue_front + 1) % 128;
#line 606
                  oset = signal_setmask(signal_mask_queue[queue_front]);
#line 606
                  zhandler(signal_queue[queue_front]);
#line 606
                  signal_setmask(oset);
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
#line 606
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
#line 606
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 607
          return ((Patprog )((void *)0));
        }
      } else {
        {
#line 616
        patparse = strp;
#line 617
        len = strp - exp;
#line 618
        patadd(exp, 0, len + 1L, 0);
#line 619
        *(patout + (startoff + len)) = (char )'\000';
#line 620
        patflags |= 32;
        }
      }
    } else {
      {
#line 616
      patparse = strp;
#line 617
      len = strp - exp;
#line 618
      patadd(exp, 0, len + 1L, 0);
#line 619
      *(patout + (startoff + len)) = (char )'\000';
#line 620
      patflags |= 32;
      }
    }
  }
#line 625
  p = (Patprog )patout;
#line 626
  p->startoff = startoff;
#line 627
  p->patstartch = (char )'\000';
#line 628
  p->globend = patglobflags;
#line 629
  p->flags = patflags;
#line 630
  p->mustoff = 0L;
#line 631
  p->size = patsize;
#line 632
  p->patmlen = len;
#line 633
  p->patnpar = patnpar - 1;
#line 635
  if (! strp) {
#line 636
    pscan = (Upat )(patout + startoff);
#line 638
    if (! (patflags & 4)) {
#line 638
      rn_offs = pscan->l >> 8;
#line 638
      if (rn_offs) {
#line 638
        if ((pscan->l & 255L) == 3L) {
#line 638
          tmp___9 = pscan - rn_offs;
        } else {
#line 638
          tmp___9 = pscan + rn_offs;
        }
#line 638
        tmp___10 = tmp___9;
      } else {
#line 638
        tmp___10 = (Upat )((void *)0);
      }
#line 638
      if ((tmp___10->l & 255L) == 0L) {
#line 640
        pscan ++;
#line 642
        if (flags & 4) {
#line 647
          dst = patout + startoff;
#line 649
          p->flags |= 32;
          {
#line 650
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 650
            if (! pscan) {
#line 650
              goto while_break___3;
            }
#line 651
            rn_offs = pscan->l >> 8;
#line 651
            if (rn_offs) {
#line 651
              if ((pscan->l & 255L) == 3L) {
#line 651
                tmp___1 = pscan - rn_offs;
              } else {
#line 651
                tmp___1 = pscan + rn_offs;
              }
#line 651
              next___0 = tmp___1;
            } else {
#line 651
              next___0 = (Upat )((void *)0);
            }
#line 652
            if ((pscan->l & 255L) == 4L) {
#line 653
              opnd = (char *)(pscan + 2);
#line 654
              oplen = (pscan + 1)->l;
#line 655
              nmeta = 0;
#line 666
              mtest = opnd;
#line 666
              ilen = oplen;
              {
#line 666
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 666
                if (! ilen) {
#line 666
                  goto while_break___4;
                }
#line 668
                if ((int )typtab[(unsigned char )*mtest] & (1 << 12)) {
#line 669
                  nmeta ++;
                }
#line 666
                mtest ++;
#line 666
                ilen --;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 670
              if (nmeta) {
                {
#line 671
                patadd((char *)((void *)0), 0, (long )nmeta, 0);
#line 672
                p = (Patprog )patout;
#line 673
                opnd = dupstring_wlen((char const   *)opnd, (unsigned int )oplen);
#line 674
                dst = patout + startoff;
                }
              }
              {
#line 677
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 677
                tmp___7 = oplen;
#line 677
                oplen --;
#line 677
                if (! tmp___7) {
#line 677
                  goto while_break___5;
                }
#line 678
                if ((int )typtab[(unsigned char )*opnd] & (1 << 12)) {
#line 679
                  tmp___2 = dst;
#line 679
                  dst ++;
#line 679
                  *tmp___2 = (char)-125;
#line 680
                  tmp___3 = dst;
#line 680
                  dst ++;
#line 680
                  tmp___4 = opnd;
#line 680
                  opnd ++;
#line 680
                  *tmp___3 = (char )((int )*tmp___4 ^ 32);
                } else {
#line 682
                  tmp___5 = dst;
#line 682
                  dst ++;
#line 682
                  tmp___6 = opnd;
#line 682
                  opnd ++;
#line 682
                  *tmp___5 = *tmp___6;
                }
              }
              while_break___5: /* CIL Label */ ;
              }
#line 686
              goto while_break___3;
            }
#line 650
            pscan = next___0;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 689
          p->size = dst - patout;
#line 691
          p->patmlen = p->size - startoff;
        } else {
#line 694
          if ((pscan->l & 255L) == 4L) {
#line 694
            if (! p->globflags) {
#line 694
              if ((pscan + 1)->l) {
#line 696
                p->patstartch = *((char *)(pscan + 2));
              }
            }
          }
#line 702
          if (flags & 2) {
#line 702
            if (! p->globflags) {
#line 703
              lng = (char *)((void *)0);
#line 704
              len = 0L;
              {
#line 705
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 705
                if (! pscan) {
#line 705
                  goto while_break___6;
                }
#line 706
                if ((pscan->l & 255L) == 4L) {
#line 706
                  if ((pscan + 1)->l >= len) {
#line 708
                    lng = (char *)(pscan + 2);
#line 709
                    len = (pscan + 1)->l;
                  }
                }
#line 705
                rn_offs = pscan->l >> 8;
#line 705
                if (rn_offs) {
#line 705
                  if ((pscan->l & 255L) == 3L) {
#line 705
                    tmp___8 = pscan - rn_offs;
                  } else {
#line 705
                    tmp___8 = pscan + rn_offs;
                  }
#line 705
                  pscan = tmp___8;
                } else {
#line 705
                  pscan = (Upat )((void *)0);
                }
              }
              while_break___6: /* CIL Label */ ;
              }
#line 711
              if (lng) {
#line 712
                p->mustoff = lng - patout;
#line 713
                p->patmlen = len;
              }
            }
          }
        }
      }
    }
  }
#line 726
  if (patflags & 256) {
    {
#line 727
    tmp___11 = zalloc((size_t )patsize);
#line 727
    newp = (Patprog )tmp___11;
#line 728
    memcpy((void */* __restrict  */)((char *)newp), (void const   */* __restrict  */)((char *)p),
           (size_t )patsize);
#line 729
    p = newp;
    }
  } else
#line 730
  if (! (patflags & 64)) {
    {
#line 731
    tmp___12 = zhalloc((size_t )patsize);
#line 731
    newp___0 = (Patprog )tmp___12;
#line 732
    memcpy((void */* __restrict  */)((char *)newp___0), (void const   */* __restrict  */)((char *)p),
           (size_t )patsize);
#line 733
    p = newp___0;
    }
  }
#line 736
  if (endexp) {
#line 737
    *endexp = patparse;
  }
  {
#line 739
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 739
    queueing_enabled --;
#line 739
    if (! queueing_enabled) {
      {
#line 739
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 739
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 739
          if (! (queue_front != queue_rear)) {
#line 739
            goto while_break___9;
          }
          {
#line 739
          queue_front = (queue_front + 1) % 128;
#line 739
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 739
          zhandler(signal_queue[queue_front]);
#line 739
          signal_setmask(oset___0);
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 739
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 739
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 740
  return (p);
}
}
#line 749 "/tmp/zsh-5.4.2/Src/pattern.c"
static long patcompswitch(int paren , int *flagp ) 
{ 
  long starter ;
  long br ;
  long ender ;
  long excsync ;
  int parno ;
  int flags ;
  int gfchanged ;
  long savglobflags ;
  Upat ptr___0 ;
  int tmp ;
  long tmp___0 ;
  int tilde ;
  char *tmp___1 ;
  long gfnode ;
  long newbr ;
  union upat up ;
  union upat up___0 ;
  long tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  Upat tmp___6 ;
  char *tmp___7 ;
  long tmp___8 ;

  {
#line 752
  excsync = 0L;
#line 753
  parno = 0;
#line 754
  gfchanged = 0;
#line 755
  savglobflags = (long )patglobflags;
#line 758
  *flagp = 0;
#line 760
  if (paren) {
#line 760
    if (patglobflags & 1024) {
#line 760
      if (patnpar <= 9) {
        {
#line 767
        tmp = patnpar;
#line 767
        patnpar ++;
#line 767
        parno = tmp;
#line 768
        starter = patnode((long )(128 + parno));
        }
      } else {
#line 770
        starter = 0L;
      }
    } else {
#line 770
      starter = 0L;
    }
  } else {
#line 770
    starter = 0L;
  }
  {
#line 772
  br = patnode(32L);
#line 773
  tmp___0 = patcompbranch(& flags, paren);
  }
#line 773
  if (! tmp___0) {
#line 774
    return (0L);
  }
#line 775
  if (patglobflags != (int )savglobflags) {
#line 776
    gfchanged ++;
  }
#line 777
  if (starter) {
    {
#line 778
    pattail(starter, br);
    }
  } else {
#line 780
    starter = br;
  }
#line 782
  *flagp |= flags & 6;
  {
#line 784
  while (1) {
    while_continue: /* CIL Label */ ;
#line 784
    if (! ((int )*patparse == (int )zpc_chars[2])) {
#line 784
      if ((int )*patparse == (int )zpc_special[4]) {
#line 784
        if (! ((int )*(patparse + 1) == 47)) {
          {
#line 784
          tmp___3 = memchr((void const   *)(zpc_special), (int )*(patparse + 1), (size_t )5);
          }
#line 784
          if (tmp___3) {
#line 784
            goto while_break;
          }
        }
      } else {
#line 784
        goto while_break;
      }
    }
#line 788
    tmp___1 = patparse;
#line 788
    patparse ++;
#line 788
    tilde = (int )*tmp___1 == (int )zpc_special[4];
#line 789
    gfnode = 0L;
#line 791
    *flagp &= -5;
#line 793
    if (tilde) {
#line 799
      if (! excsync) {
        {
#line 800
        excsync = patnode(1L);
#line 801
        patoptail(br, excsync);
        }
      }
#line 809
      patglobflags &= -256;
#line 810
      if (! (patflags & 2)) {
        {
#line 811
        br = patnode(48L);
        }
      } else
#line 810
      if (paren) {
        {
#line 811
        br = patnode(48L);
        }
      } else {
        {
#line 819
        br = patnode(49L);
#line 820
        patflags |= 2048;
        }
      }
      {
#line 822
      up.p = (unsigned char *)((void *)0);
#line 823
      patadd((char *)(& up), 0, (long )sizeof(up), 0);
      }
#line 825
      if (! paren) {
#line 825
        if ((int )zpc_special[0] == 47) {
#line 826
          tilde ++;
#line 827
          zpc_special[0] = (char)-94;
        }
      }
    } else {
      {
#line 830
      excsync = 0L;
#line 831
      br = patnode(32L);
      }
#line 836
      if (! paren) {
#line 837
        patglobflags = 0;
#line 838
        if (((Patprog )patout)->globflags) {
          {
#line 856
          gfnode = patnode(8L);
#line 857
          up___0.l = (long )patglobflags;
#line 858
          patadd((char *)(& up___0), 0, (long )sizeof(union upat ), 0);
          }
        }
      } else {
#line 861
        patglobflags = (int )savglobflags;
      }
    }
    {
#line 864
    newbr = patcompbranch(& flags, paren);
    }
#line 865
    if (tilde == 2) {
#line 867
      zpc_special[0] = (char )'/';
    }
#line 869
    if (! newbr) {
#line 870
      return (0L);
    }
#line 871
    if (gfnode) {
      {
#line 872
      pattail(gfnode, newbr);
      }
    }
#line 873
    if (! tilde) {
#line 873
      if (patglobflags != (int )savglobflags) {
#line 874
        gfchanged ++;
      }
    }
    {
#line 875
    pattail(starter, br);
    }
#line 876
    if (excsync) {
      {
#line 877
      tmp___2 = patnode(2L);
#line 877
      patoptail(br, tmp___2);
      }
    }
#line 878
    *flagp |= flags & 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 887
  if (paren) {
#line 887
    if (parno) {
#line 887
      tmp___4 = 144 + parno;
    } else {
#line 887
      tmp___4 = 5;
    }
#line 887
    tmp___5 = tmp___4;
  } else {
#line 887
    tmp___5 = 0;
  }
  {
#line 887
  ender = patnode((long )tmp___5);
#line 888
  pattail(starter, ender);
#line 894
  ptr___0 = (Upat )patout + starter;
  }
  {
#line 894
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 894
    if (! ptr___0) {
#line 894
      goto while_break___0;
    }
#line 895
    if (! ((ptr___0->l & 48L) == 48L)) {
      {
#line 896
      patoptail(ptr___0 - (Upat )patout, ender);
      }
    }
#line 894
    rn_offs = ptr___0->l >> 8;
#line 894
    if (rn_offs) {
#line 894
      if ((ptr___0->l & 255L) == 3L) {
#line 894
        tmp___6 = ptr___0 - rn_offs;
      } else {
#line 894
        tmp___6 = ptr___0 + rn_offs;
      }
#line 894
      ptr___0 = tmp___6;
    } else {
#line 894
      ptr___0 = (Upat )((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 899
  if (paren) {
#line 899
    tmp___7 = patparse;
#line 899
    patparse ++;
#line 899
    if ((int )*tmp___7 != -118) {
#line 902
      return (0L);
    } else {
#line 899
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 899
  if (! paren) {
#line 899
    if (*patparse) {
#line 899
      if (patflags & 1) {
#line 899
        if (! ((int )*patparse == 47)) {
#line 902
          return (0L);
        }
      } else {
#line 902
        return (0L);
      }
    }
  }
#line 904
  if (paren) {
#line 904
    if (gfchanged) {
      {
#line 911
      tmp___8 = patnode(8L);
#line 911
      pattail(ender, tmp___8);
#line 912
      patglobflags = (int )savglobflags;
#line 913
      patadd((char *)(& savglobflags), 0, (long )sizeof(long ), 0);
      }
    }
  }
#line 916
  return (starter);
}
}
#line 926 "/tmp/zsh-5.4.2/Src/pattern.c"
static long patcompbranch(int *flagp , int paren ) 
{ 
  long chain ;
  long latest ;
  long starter ;
  int flags ;
  char *pp1 ;
  int oldglobflags ;
  int ignore ;
  long assert ;
  int tmp ;
  int tmp___0 ;
  union upat up ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 929
  latest = 0L;
#line 930
  flags = 0;
#line 932
  *flagp = 4;
#line 934
  chain = 0L;
#line 934
  starter = chain;
  {
#line 935
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 935
    tmp___1 = memchr((void const   *)(zpc_special), (int )*patparse, (size_t )5);
    }
#line 935
    if (tmp___1) {
#line 935
      if ((int )*patparse == (int )zpc_special[4]) {
#line 935
        if ((int )*(patparse + 1) != 47) {
          {
#line 935
          tmp___2 = memchr((void const   *)(zpc_special), (int )*(patparse + 1), (size_t )5);
          }
#line 935
          if (! tmp___2) {
#line 935
            goto while_break;
          }
        } else {
#line 935
          goto while_break;
        }
      } else {
#line 935
        goto while_break;
      }
    }
#line 938
    if ((int )*patparse == (int )zpc_special[5]) {
#line 938
      if ((int )*(patparse + 1) == (int )zpc_special[11]) {
#line 938
        goto _L;
      } else {
#line 938
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 938
    if ((int )*patparse == (int )zpc_special[18]) {
#line 938
      if ((int )*(patparse + 1) == -120) {
#line 938
        if ((int )*(patparse + 2) == (int )zpc_special[11]) {
          _L: /* CIL Label */ 
#line 943
          pp1 = patparse;
#line 944
          oldglobflags = patglobflags;
#line 946
          if ((int )*patparse == 64) {
#line 946
            tmp = 3;
          } else {
#line 946
            tmp = 2;
          }
          {
#line 946
          patparse += tmp;
#line 947
          tmp___0 = patgetglobflags(& patparse, & assert, & ignore);
          }
#line 947
          if (! tmp___0) {
#line 948
            return (0L);
          }
#line 949
          if (! ignore) {
#line 950
            if (assert) {
              {
#line 955
              latest = patnode(assert);
#line 956
              flags = 0;
              }
            } else {
#line 958
              if ((unsigned long )pp1 == (unsigned long )patstart) {
#line 962
                ((Patprog )patout)->globflags = patglobflags;
#line 963
                goto while_continue;
              } else
#line 964
              if (! *patparse) {
#line 968
                goto while_break;
              }
#line 974
              if (oldglobflags != patglobflags) {
                {
#line 977
                latest = patnode(8L);
#line 978
                up.l = (long )patglobflags;
#line 979
                patadd((char *)(& up), 0, (long )sizeof(union upat ), 0);
                }
              } else {
#line 982
                goto while_continue;
              }
            }
          } else
#line 985
          if (! *patparse) {
#line 986
            goto while_break;
          } else {
#line 988
            goto while_continue;
          }
        } else {
#line 938
          goto _L___1;
        }
      } else {
#line 938
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 989
    if ((int )*patparse == (int )zpc_special[10]) {
      {
#line 995
      patparse ++;
#line 996
      latest = patcompnot(0, & flags);
      }
    } else {
      {
#line 998
      latest = patcomppiece(& flags, paren);
      }
    }
#line 999
    if (! latest) {
#line 1000
      return (0L);
    }
#line 1001
    if (! starter) {
#line 1002
      starter = latest;
    }
#line 1003
    if (! (flags & 4)) {
#line 1004
      *flagp &= -5;
    }
#line 1005
    if (! chain) {
#line 1006
      *flagp |= flags & 2;
    } else {
      {
#line 1008
      pattail(chain, latest);
      }
    }
#line 1009
    chain = latest;
  }
  while_break: /* CIL Label */ ;
  }
#line 1012
  if (! chain) {
    {
#line 1013
    starter = patnode(5L);
    }
  }
#line 1015
  return (starter);
}
}
#line 1021 "/tmp/zsh-5.4.2/Src/pattern.c"
int patgetglobflags(char **strp , long *assertp , int *ignore ) 
{ 
  char *nptr ;
  char *ptr___0 ;
  zlong ret ;

  {
#line 1024
  ptr___0 = *strp;
#line 1027
  *assertp = 0L;
#line 1028
  *ignore = 1;
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1030
    if (*ptr___0) {
#line 1030
      if (! ((int )*ptr___0 != -118)) {
#line 1030
        goto while_break;
      }
    } else {
#line 1030
      goto while_break;
    }
#line 1031
    if ((int )*ptr___0 == 113) {
      {
#line 1033
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1033
        if (*ptr___0) {
#line 1033
          if (! ((int )*ptr___0 != -118)) {
#line 1033
            goto while_break___0;
          }
        } else {
#line 1033
          goto while_break___0;
        }
#line 1034
        ptr___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1035
      goto while_break;
    } else {
#line 1037
      *ignore = 0;
      {
#line 1039
      if ((int )*ptr___0 == 97) {
#line 1039
        goto case_97;
      }
#line 1053
      if ((int )*ptr___0 == 108) {
#line 1053
        goto case_108;
      }
#line 1058
      if ((int )*ptr___0 == 105) {
#line 1058
        goto case_105;
      }
#line 1063
      if ((int )*ptr___0 == 73) {
#line 1063
        goto case_73;
      }
#line 1068
      if ((int )*ptr___0 == 98) {
#line 1068
        goto case_98;
      }
#line 1073
      if ((int )*ptr___0 == 66) {
#line 1073
        goto case_66;
      }
#line 1078
      if ((int )*ptr___0 == 109) {
#line 1078
        goto case_109;
      }
#line 1083
      if ((int )*ptr___0 == 77) {
#line 1083
        goto case_77;
      }
#line 1088
      if ((int )*ptr___0 == 115) {
#line 1088
        goto case_115;
      }
#line 1092
      if ((int )*ptr___0 == 101) {
#line 1092
        goto case_101;
      }
#line 1096
      if ((int )*ptr___0 == 117) {
#line 1096
        goto case_117;
      }
#line 1100
      if ((int )*ptr___0 == 85) {
#line 1100
        goto case_85;
      }
#line 1104
      goto switch_default;
      case_97: /* CIL Label */ 
      {
#line 1041
      ptr___0 ++;
#line 1041
      ret = zstrtol((char const   *)ptr___0, & nptr, 10);
      }
#line 1047
      if (ret < 0L) {
#line 1048
        return (0);
      } else
#line 1047
      if (ret > 254L) {
#line 1048
        return (0);
      } else
#line 1047
      if ((unsigned long )ptr___0 == (unsigned long )nptr) {
#line 1048
        return (0);
      }
#line 1049
      patglobflags = (int )((long )(patglobflags & -256) | (ret & 255L));
#line 1050
      ptr___0 = nptr - 1;
#line 1051
      goto switch_break;
      case_108: /* CIL Label */ 
#line 1055
      patglobflags = (patglobflags & -513) | 256;
#line 1056
      goto switch_break;
      case_105: /* CIL Label */ 
#line 1060
      patglobflags = (patglobflags & -257) | 512;
#line 1061
      goto switch_break;
      case_73: /* CIL Label */ 
#line 1065
      patglobflags &= -769;
#line 1066
      goto switch_break;
      case_98: /* CIL Label */ 
#line 1070
      patglobflags |= 1024;
#line 1071
      goto switch_break;
      case_66: /* CIL Label */ 
#line 1075
      patglobflags &= -1025;
#line 1076
      goto switch_break;
      case_109: /* CIL Label */ 
#line 1080
      patglobflags |= 2048;
#line 1081
      goto switch_break;
      case_77: /* CIL Label */ 
#line 1085
      patglobflags &= -2049;
#line 1086
      goto switch_break;
      case_115: /* CIL Label */ 
#line 1089
      *assertp = 9L;
#line 1090
      goto switch_break;
      case_101: /* CIL Label */ 
#line 1093
      *assertp = 10L;
#line 1094
      goto switch_break;
      case_117: /* CIL Label */ 
#line 1097
      patglobflags |= 4096;
#line 1098
      goto switch_break;
      case_85: /* CIL Label */ 
#line 1101
      patglobflags &= -4097;
#line 1102
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1105
      return (0);
      switch_break: /* CIL Label */ ;
      }
    }
#line 1030
    ptr___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1109
  if ((int )*ptr___0 != -118) {
#line 1110
    return (0);
  }
#line 1112
  if (*assertp) {
#line 1112
    if ((int )*(*strp + 1) != -118) {
#line 1113
      return (0);
    }
  }
#line 1114
  *strp = ptr___0 + 1;
#line 1115
  return (1);
}
}
#line 1119 "/tmp/zsh-5.4.2/Src/pattern.c"
static char const   *colon_stuffs[20]  = 
#line 1119
  {      "alpha",      "alnum",      "ascii",      "blank", 
        "cntrl",      "digit",      "graph",      "lower", 
        "print",      "punct",      "space",      "upper", 
        "xdigit",      "IDENT",      "IFS",      "IFSSPACE", 
        "WORD",      "INCOMPLETE",      "INVALID",      (char const   *)((void *)0)};
#line 1132 "/tmp/zsh-5.4.2/Src/pattern.c"
int range_type(char *start , int len ) 
{ 
  char const   **csp ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1137
  csp = colon_stuffs;
  {
#line 1137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1137
    if (! *csp) {
#line 1137
      goto while_break;
    }
    {
#line 1138
    tmp = strlen(*csp);
    }
#line 1138
    if (tmp == (size_t )len) {
      {
#line 1138
      tmp___0 = strncmp((char const   *)start, *csp, (size_t )len);
      }
#line 1138
      if (! tmp___0) {
#line 1139
        return ((int )((csp - colon_stuffs) + 1L));
      }
    }
#line 1137
    csp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1142
  return (20);
}
}
#line 1163 "/tmp/zsh-5.4.2/Src/pattern.c"
int pattern_range_to_string(char *rangestr , char *outstr ) 
{ 
  int len ;
  int swtype ;
  char *tmp ;
  char *tmp___0 ;
  int i ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *found ;
  int newlen ;
  size_t tmp___5 ;
  char *tmp___6 ;

  {
#line 1166
  len = 0;
  {
#line 1168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1168
    if (! *rangestr) {
#line 1168
      goto while_break;
    }
#line 1169
    if ((int )typtab[(unsigned char )*rangestr] & (1 << 12)) {
#line 1170
      swtype = (int )((unsigned char )*rangestr) - 131;
#line 1172
      if (swtype == 0) {
#line 1174
        if (outstr) {
#line 1176
          tmp = outstr;
#line 1176
          outstr ++;
#line 1176
          *tmp = (char)-125;
#line 1177
          tmp___0 = outstr;
#line 1177
          outstr ++;
#line 1177
          *tmp___0 = (char )((int )*(rangestr + 1) ^ 32);
        }
#line 1179
        len += 2;
#line 1180
        rangestr += 2;
      } else
#line 1181
      if (swtype == 21) {
#line 1185
        i = 0;
        {
#line 1185
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1185
          if (! (i < 2)) {
#line 1185
            goto while_break___0;
          }
#line 1186
          if ((int )*rangestr == -125) {
#line 1187
            if (outstr) {
#line 1188
              tmp___1 = outstr;
#line 1188
              outstr ++;
#line 1188
              *tmp___1 = (char)-125;
#line 1189
              tmp___2 = outstr;
#line 1189
              outstr ++;
#line 1189
              *tmp___2 = *(rangestr + 1);
            }
#line 1191
            len += 2;
#line 1192
            rangestr += 2;
          } else {
#line 1194
            if (outstr) {
#line 1195
              tmp___3 = outstr;
#line 1195
              outstr ++;
#line 1195
              *tmp___3 = *rangestr;
            }
#line 1196
            len ++;
#line 1197
            rangestr ++;
          }
#line 1200
          if (i == 0) {
#line 1201
            if (outstr) {
#line 1202
              tmp___4 = outstr;
#line 1202
              outstr ++;
#line 1202
              *tmp___4 = (char )'-';
            }
#line 1203
            len ++;
          }
#line 1185
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 1206
      if (swtype >= 1) {
#line 1206
        if (swtype <= 19) {
          {
#line 1208
          found = colon_stuffs[swtype - 1];
#line 1209
          tmp___5 = strlen(found);
#line 1209
          newlen = (int )tmp___5;
          }
#line 1210
          if (outstr) {
            {
#line 1211
            strcpy((char */* __restrict  */)outstr, (char const   */* __restrict  */)"[:");
#line 1212
            outstr += 2;
#line 1213
            memcpy((void */* __restrict  */)outstr, (void const   */* __restrict  */)found,
                   (size_t )newlen);
#line 1214
            outstr += newlen;
#line 1215
            strcpy((char */* __restrict  */)outstr, (char const   */* __restrict  */)":]");
#line 1216
            outstr += 2;
            }
          }
#line 1218
          len += newlen + 4;
#line 1219
          rangestr ++;
        } else {
#line 1223
          rangestr ++;
        }
      } else {
#line 1223
        rangestr ++;
      }
    } else {
#line 1227
      if (outstr) {
#line 1228
        tmp___6 = outstr;
#line 1228
        outstr ++;
#line 1228
        *tmp___6 = *rangestr;
      }
#line 1229
      len ++;
#line 1230
      rangestr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1234
  if (outstr) {
#line 1235
    *outstr = (char )'\000';
  }
#line 1236
  return (len);
}
}
#line 1245 "/tmp/zsh-5.4.2/Src/pattern.c"
static long patcomppiece(int *flagp , int paren ) 
{ 
  long starter ;
  long next___0 ;
  long op___0 ;
  long opnd ;
  int flags ;
  int flags2 ;
  int kshchar ;
  int len ;
  int ch ;
  int patch ;
  int nmeta ;
  int hash ;
  int count ;
  union upat up ;
  char *nptr ;
  char *str0 ;
  char *ptr___0 ;
  char *patprev ;
  zrange_t from ;
  zrange_t to ;
  char *charstart ;
  void *tmp ;
  void *tmp___0 ;
  long slen ;
  int morelen ;
  char *tmp___1 ;
  zlong tmp___2 ;
  zlong tmp___3 ;
  int tmp___4 ;
  union upat countargs[5] ;
  char *opp ;
  zlong tmp___5 ;
  zlong tmp___6 ;
  long tmp___7 ;
  Upat uptr ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;

  {
#line 1248
  starter = 0L;
#line 1256
  flags = 0;
#line 1257
  patprev = patparse;
#line 1257
  str0 = patprev;
  {
#line 1258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1263
    kshchar = '\000';
#line 1264
    if (*patparse) {
#line 1264
      if ((int )*(patparse + 1) == -120) {
#line 1265
        if ((int )*patparse == (int )zpc_special[15]) {
#line 1266
          kshchar = (int )((unsigned char )'+');
        } else
#line 1267
        if ((int )*patparse == (int )zpc_special[16]) {
#line 1268
          kshchar = (int )((unsigned char )'!');
        } else
#line 1269
        if ((int )*patparse == (int )zpc_special[17]) {
#line 1270
          kshchar = (int )((unsigned char )'!');
        } else
#line 1271
        if ((int )*patparse == (int )zpc_special[18]) {
#line 1272
          kshchar = (int )((unsigned char )'@');
        } else
#line 1273
        if ((int )*patparse == (int )zpc_special[14]) {
#line 1274
          kshchar = (int )((unsigned char )'*');
        } else
#line 1275
        if ((int )*patparse == (int )zpc_special[13]) {
#line 1276
          kshchar = (int )((unsigned char )'?');
        }
      }
    }
#line 1284
    if ((int )zpc_special[5] != -94) {
#line 1284
      goto _L;
    } else
#line 1284
    if ((int )*patparse != -118) {
#line 1284
      goto _L;
    } else
#line 1284
    if (paren) {
      _L: /* CIL Label */ 
#line 1297
      if (kshchar) {
#line 1302
        goto while_break;
      } else {
        {
#line 1297
        tmp = memchr((void const   *)(zpc_special), (int )*patparse, (size_t )13);
        }
#line 1297
        if (tmp) {
#line 1297
          if ((int )*patparse != (int )zpc_special[4]) {
#line 1302
            goto while_break;
          } else
#line 1297
          if ((int )*(patparse + 1) == 47) {
#line 1302
            goto while_break;
          } else {
            {
#line 1297
            tmp___0 = memchr((void const   *)(zpc_special), (int )*(patparse + 1),
                             (size_t )5);
            }
#line 1297
            if (! tmp___0) {
#line 1302
              goto while_break;
            }
          }
        }
      }
    }
    {
#line 1307
    patprev = patparse;
#line 1308
    metacharinc(& patparse);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1311
  if ((unsigned long )patparse > (unsigned long )str0) {
#line 1312
    slen = patparse - str0;
#line 1316
    kshchar = '\000';
#line 1320
    flags |= 4;
#line 1323
    morelen = (unsigned long )patprev > (unsigned long )str0;
#line 1328
    if ((int )*patparse == (int )zpc_special[11]) {
#line 1328
      goto _L___0;
    } else
#line 1328
    if ((int )*patparse == (int )zpc_special[5]) {
#line 1328
      if ((int )*(patparse + 1) == (int )zpc_special[11]) {
#line 1328
        if ((int )*(patparse + 2) == 99) {
#line 1328
          goto _L___0;
        } else {
#line 1328
          goto _L___2;
        }
      } else {
#line 1328
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1328
    if ((int )*patparse == (int )zpc_special[18]) {
#line 1328
      if ((int )*(patparse + 1) == -120) {
#line 1328
        if ((int )*(patparse + 2) == (int )zpc_special[11]) {
#line 1328
          if ((int )*(patparse + 3) == 99) {
            _L___0: /* CIL Label */ 
#line 1328
            if (morelen) {
#line 1336
              patparse = patprev;
            }
          }
        }
      }
    }
#line 1341
    if (! morelen) {
#line 1342
      flags |= 1;
    }
    {
#line 1343
    starter = patnode(4L);
#line 1346
    nmeta = 0;
    }
#line 1348
    if ((int )*str0 == -95) {
#line 1349
      str0 ++;
    }
#line 1350
    ptr___0 = str0;
    {
#line 1350
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1350
      if (! ((unsigned long )ptr___0 < (unsigned long )patparse)) {
#line 1350
        goto while_break___0;
      }
#line 1351
      if ((int )*ptr___0 == -125) {
#line 1352
        nmeta ++;
#line 1353
        ptr___0 ++;
      }
#line 1350
      ptr___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1356
    slen = (patparse - str0) - (long )nmeta;
#line 1358
    patadd((char *)(& slen), 0, (long )sizeof(long ), 0);
#line 1365
    patadd(str0, 0, slen, 2);
#line 1366
    nptr = (char *)(((Upat )patout + starter) + 2);
    }
#line 1377
    if (patglobflags & 1023) {
#line 1397
      if (! (patflags & 1)) {
#line 1398
        flags &= -5;
      } else
#line 1399
      if ((int )*(nptr + 0) == 46) {
#line 1399
        if (! (slen == 1L)) {
#line 1399
          if ((int )*(nptr + 1) == 46) {
#line 1399
            if (! (slen == 2L)) {
#line 1401
              flags &= -5;
            }
          } else {
#line 1401
            flags &= -5;
          }
        }
      } else {
#line 1401
        flags &= -5;
      }
    }
  } else {
#line 1404
    if (kshchar) {
#line 1405
      patparse ++;
    }
    {
#line 1407
    patch = (int )*patparse;
#line 1408
    metacharinc(& patparse);
    }
    {
#line 1410
    if (patch == -105) {
#line 1410
      goto case_neg_105;
    }
#line 1416
    if (patch == -121) {
#line 1416
      goto case_neg_121;
    }
#line 1423
    if (patch == -111) {
#line 1423
      goto case_neg_111;
    }
#line 1487
    if (patch == -120) {
#line 1487
      goto case_neg_120;
    }
#line 1512
    if (patch == -108) {
#line 1512
      goto case_neg_108;
    }
#line 1558
    if (patch == -124) {
#line 1558
      goto case_neg_124;
    }
#line 1568
    if (patch == -96) {
#line 1568
      goto case_neg_96;
    }
#line 1409
    goto switch_break;
    case_neg_105: /* CIL Label */ 
    {
#line 1413
    flags |= 1;
#line 1414
    starter = patnode(64L);
    }
#line 1415
    goto switch_break;
    case_neg_121: /* CIL Label */ 
    {
#line 1420
    kshchar = -1;
#line 1421
    starter = patnode(67L);
    }
#line 1422
    goto switch_break;
    case_neg_111: /* CIL Label */ 
#line 1426
    flags |= 1;
#line 1427
    if ((int )*patparse == -122) {
      {
#line 1428
      patparse ++;
#line 1429
      starter = patnode(66L);
      }
    } else
#line 1427
    if ((int )*patparse == -100) {
      {
#line 1428
      patparse ++;
#line 1429
      starter = patnode(66L);
      }
    } else {
      {
#line 1431
      starter = patnode(65L);
      }
    }
#line 1441
    if ((int )*patparse == -110) {
      {
#line 1441
      tmp___1 = strchr((char const   *)(patparse + 1), -110);
      }
#line 1441
      if (tmp___1) {
        {
#line 1442
        patparse ++;
#line 1443
        patadd((char *)((void *)0), ']', 1L, 1);
        }
      }
    }
    {
#line 1445
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1445
      if (*patparse) {
#line 1445
        if (! ((int )*patparse != -110)) {
#line 1445
          goto while_break___1;
        }
      } else {
#line 1445
        goto while_break___1;
      }
#line 1447
      if ((int )*patparse == -111) {
#line 1447
        if ((int )*(patparse + 1) == 58) {
          {
#line 1447
          nptr = strchr((char const   *)(patparse + 2), ':');
          }
#line 1447
          if (nptr) {
#line 1447
            if ((int )*(nptr + 1) == -110) {
              {
#line 1451
              patparse += 2;
#line 1452
              len = (int )(nptr - patparse);
#line 1453
              ch = range_type(patparse, len);
#line 1454
              patparse = nptr + 2;
              }
#line 1455
              if (ch != 20) {
                {
#line 1456
                patadd((char *)((void *)0), 131 + ch, 1L, 1);
                }
              }
#line 1457
              goto while_continue___1;
            }
          }
        }
      }
      {
#line 1459
      charstart = patparse;
#line 1460
      metacharinc(& patparse);
      }
#line 1462
      if ((int )*patparse == -101) {
#line 1462
        if (*(patparse + 1)) {
#line 1462
          if ((int )*(patparse + 1) != -110) {
            {
#line 1464
            patadd((char *)((void *)0), 152, 1L, 1);
            }
#line 1465
            if ((int )typtab[(unsigned char )*charstart] & (1 << 4)) {
              {
#line 1466
              patadd((char *)0, (int )((unsigned char )ztokens[(int )*charstart - -124]),
                     1L, 1);
              }
            } else {
              {
#line 1469
              patadd(charstart, 0, patparse - charstart, 1);
              }
            }
            {
#line 1471
            patparse ++;
#line 1471
            charstart = patparse;
#line 1472
            metacharinc(& patparse);
            }
          }
        }
      }
#line 1474
      if ((int )typtab[(unsigned char )*charstart] & (1 << 4)) {
        {
#line 1475
        patadd((char *)0, (int )((unsigned char )ztokens[(int )*charstart - -124]),
               1L, 1);
        }
      } else {
        {
#line 1478
        patadd(charstart, 0, patparse - charstart, 1);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1481
    if ((int )*patparse != -110) {
#line 1482
      return (0L);
    }
    {
#line 1483
    patparse ++;
#line 1485
    patadd((char *)((void *)0), 0, 1L, 0);
    }
#line 1486
    goto switch_break;
    case_neg_120: /* CIL Label */ ;
#line 1492
    if (kshchar == 33) {
      {
#line 1506
      starter = patcompnot(1, & flags2);
      }
#line 1506
      if (! starter) {
#line 1507
        return (0L);
      }
    } else {
      {
#line 1508
      starter = patcompswitch(1, & flags2);
      }
#line 1508
      if (! starter) {
#line 1509
        return (0L);
      }
    }
#line 1510
    flags |= flags2 & 2;
#line 1511
    goto switch_break;
    case_neg_108: /* CIL Label */ 
#line 1517
    len = 0;
#line 1518
    if ((int )typtab[(unsigned char )*patparse] & 1) {
      {
#line 1519
      tmp___2 = zstrtol((char const   *)patparse, & nptr, 10);
#line 1519
      from = tmp___2;
#line 1521
      patparse = nptr;
#line 1522
      len |= 1;
      }
    }
#line 1525
    patparse ++;
#line 1526
    if ((int )typtab[(unsigned char )*patparse] & 1) {
      {
#line 1527
      tmp___3 = zstrtol((char const   *)patparse, & nptr, 10);
#line 1527
      to = tmp___3;
#line 1529
      patparse = nptr;
#line 1530
      len |= 2;
      }
    }
#line 1532
    if ((int )*patparse != -107) {
#line 1533
      return (0L);
    }
#line 1534
    patparse ++;
    {
#line 1536
    if (len == 3) {
#line 1536
      goto case_3;
    }
#line 1541
    if (len == 2) {
#line 1541
      goto case_2;
    }
#line 1545
    if (len == 1) {
#line 1545
      goto case_1;
    }
#line 1549
    if (len == 0) {
#line 1549
      goto case_0;
    }
#line 1535
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 1537
    starter = patnode(68L);
#line 1538
    patadd((char *)(& from), 0, (long )sizeof(from), 0);
#line 1539
    patadd((char *)(& to), 0, (long )sizeof(to), 0);
    }
#line 1540
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 1542
    starter = patnode(70L);
#line 1543
    patadd((char *)(& to), 0, (long )sizeof(to), 0);
    }
#line 1544
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 1546
    starter = patnode(69L);
#line 1547
    patadd((char *)(& from), 0, (long )sizeof(from), 0);
    }
#line 1548
    goto switch_break___0;
    case_0: /* CIL Label */ 
    {
#line 1550
    starter = patnode(71L);
    }
#line 1551
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1557
    goto switch_break;
    case_neg_124: /* CIL Label */ ;
#line 1566
    return (0L);
#line 1567
    goto switch_break;
    case_neg_96: /* CIL Label */ 
    {
#line 1573
    next___0 = patcomppiece(flagp, paren);
#line 1578
    *flagp &= -5;
    }
#line 1579
    return (next___0);
#line 1580
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1590
  count = 0;
#line 1591
  hash = (int )*patparse == (int )zpc_special[11];
#line 1591
  if (! hash) {
#line 1591
    if ((int )*patparse == (int )zpc_special[5]) {
#line 1591
      if ((int )*(patparse + 1) == (int )zpc_special[11]) {
#line 1591
        if ((int )*(patparse + 2) == 99) {
#line 1591
          tmp___4 = 1;
        } else {
#line 1591
          goto _L___4;
        }
      } else {
#line 1591
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1591
    if ((int )*patparse == (int )zpc_special[18]) {
#line 1591
      if ((int )*(patparse + 1) == -120) {
#line 1591
        if ((int )*(patparse + 2) == (int )zpc_special[11]) {
#line 1591
          if ((int )*(patparse + 3) == 99) {
#line 1591
            tmp___4 = 1;
          } else {
#line 1591
            tmp___4 = 0;
          }
        } else {
#line 1591
          tmp___4 = 0;
        }
      } else {
#line 1591
        tmp___4 = 0;
      }
    } else {
#line 1591
      tmp___4 = 0;
    }
#line 1591
    count = tmp___4;
#line 1591
    if (! count) {
#line 1591
      if (kshchar <= 0) {
#line 1600
        *flagp = flags;
#line 1601
        return (starter);
      } else
#line 1591
      if (kshchar == 64) {
#line 1600
        *flagp = flags;
#line 1601
        return (starter);
      } else
#line 1591
      if (kshchar == 33) {
#line 1600
        *flagp = flags;
#line 1601
        return (starter);
      }
    }
  }
#line 1605
  if (kshchar) {
#line 1605
    if (hash) {
#line 1606
      return (0L);
    } else
#line 1605
    if (count) {
#line 1606
      return (0L);
    }
  }
#line 1608
  if (kshchar == 42) {
#line 1609
    op___0 = 6L;
#line 1610
    *flagp = 2;
  } else
#line 1611
  if (kshchar == 43) {
#line 1612
    op___0 = 7L;
#line 1613
    *flagp = 2;
  } else
#line 1614
  if (kshchar == 63) {
#line 1615
    op___0 = 0L;
#line 1616
    *flagp = 0;
  } else
#line 1617
  if (count) {
#line 1618
    op___0 = 12L;
#line 1619
    patparse += 3;
#line 1620
    *flagp = 2;
  } else {
#line 1621
    patparse ++;
#line 1621
    if ((int )*patparse == (int )zpc_special[11]) {
#line 1622
      op___0 = 7L;
#line 1623
      patparse ++;
#line 1624
      *flagp = 2;
    } else {
#line 1626
      op___0 = 6L;
#line 1627
      *flagp = 2;
    }
  }
#line 1640
  if (op___0 == 12L) {
    {
#line 1643
    opp = patparse;
#line 1645
    countargs[0].l = 12L;
#line 1646
    countargs[1].l = 0L;
#line 1647
    tmp___5 = zstrtol((char const   *)patparse, & patparse, 10);
#line 1647
    countargs[2].l = tmp___5;
    }
#line 1648
    if ((unsigned long )patparse == (unsigned long )opp) {
#line 1650
      countargs[2].l = 0L;
    }
#line 1652
    if ((int )*patparse != 44) {
#line 1652
      if ((int )*patparse != -102) {
#line 1654
        if ((int )*patparse != -118) {
#line 1655
          return (0L);
        }
#line 1656
        countargs[3].l = countargs[2].l;
      } else {
#line 1652
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
      {
#line 1658
      patparse ++;
#line 1658
      opp = patparse;
#line 1659
      tmp___6 = zstrtol((char const   *)patparse, & patparse, 10);
#line 1659
      countargs[3].l = tmp___6;
      }
#line 1660
      if ((int )*patparse != -118) {
#line 1661
        return (0L);
      }
#line 1662
      if ((unsigned long )patparse == (unsigned long )opp) {
#line 1664
        countargs[3].l = -1L;
      }
    }
    {
#line 1667
    patparse ++;
#line 1668
    countargs[4].p = (unsigned char *)((void *)0);
#line 1670
    patinsert(11L, (int )starter, (char *)(countargs), (int )sizeof(countargs));
#line 1678
    opnd = (starter + 1L) + 5L;
#line 1679
    tmp___7 = patnode(3L);
#line 1679
    pattail(opnd, tmp___7);
#line 1680
    pattail(opnd, starter + 1L);
#line 1686
    next___0 = patnode(5L);
#line 1687
    pattail(starter, next___0);
#line 1688
    pattail(starter + 1L, next___0);
    }
  } else
#line 1689
  if (flags & 1) {
#line 1689
    if (op___0 == 6L) {
#line 1689
      goto _L___10;
    } else
#line 1689
    if (op___0 == 7L) {
      _L___10: /* CIL Label */ 
#line 1689
      if ((((Upat )patout + starter)->l & 255L) == 64L) {
#line 1694
        uptr = (Upat )patout + starter;
#line 1695
        if (op___0 == 7L) {
          {
#line 1697
          uptr->l = (uptr->l & -256L) | 64L;
#line 1698
          tmp___8 = patnode(67L);
#line 1698
          pattail(starter, tmp___8);
          }
        } else {
#line 1700
          uptr->l = (uptr->l & -256L) | 67L;
        }
      } else {
#line 1689
        goto _L___9;
      }
    } else {
#line 1689
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 1702
  if (flags & 1) {
#line 1702
    if (op___0) {
#line 1702
      if (! (patglobflags & 255)) {
        {
#line 1704
        patinsert(op___0, (int )starter, (char *)((void *)0), 0);
        }
      } else {
#line 1702
        goto _L___7;
      }
    } else {
#line 1702
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 1705
  if (op___0 == 6L) {
    {
#line 1707
    up.p = (unsigned char *)((void *)0);
#line 1708
    patinsert(33L, (int )starter, (char *)(& up), (int )sizeof(up));
#line 1710
    tmp___9 = patnode(3L);
#line 1710
    patoptail(starter, tmp___9);
#line 1711
    patoptail(starter, starter);
#line 1712
    tmp___10 = patnode(32L);
#line 1712
    pattail(starter, tmp___10);
#line 1713
    tmp___11 = patnode(5L);
#line 1713
    pattail(starter, tmp___11);
    }
  } else
#line 1714
  if (op___0 == 7L) {
    {
#line 1716
    next___0 = patnode(33L);
#line 1717
    up.p = (unsigned char *)((void *)0);
#line 1718
    patadd((char *)(& up), 0, (long )sizeof(up), 0);
#line 1719
    pattail(starter, next___0);
#line 1720
    tmp___12 = patnode(3L);
#line 1720
    pattail(tmp___12, starter);
#line 1721
    tmp___13 = patnode(32L);
#line 1721
    pattail(next___0, tmp___13);
#line 1722
    tmp___14 = patnode(5L);
#line 1722
    pattail(starter, tmp___14);
    }
  } else
#line 1723
  if (kshchar == 63) {
    {
#line 1725
    patinsert(32L, (int )starter, (char *)((void *)0), 0);
#line 1726
    tmp___15 = patnode(32L);
#line 1726
    pattail(starter, tmp___15);
#line 1727
    next___0 = patnode(5L);
#line 1728
    pattail(starter, next___0);
#line 1729
    patoptail(starter, next___0);
    }
  }
#line 1731
  if ((int )*patparse == (int )zpc_special[11]) {
#line 1732
    return (0L);
  }
#line 1734
  return (starter);
}
}
#line 1743 "/tmp/zsh-5.4.2/Src/pattern.c"
static long patcompnot(int paren , int *flagsp ) 
{ 
  union upat up ;
  long excsync ;
  long br ;
  long excl ;
  long n ;
  long starter ;
  int dummy___0 ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1751
  *flagsp = 2;
#line 1753
  starter = patnode(32L);
#line 1754
  br = patnode(67L);
#line 1755
  excsync = patnode(1L);
#line 1756
  pattail(br, excsync);
#line 1757
  excl = patnode(48L);
#line 1757
  pattail(starter, excl);
#line 1758
  up.p = (unsigned char *)((void *)0);
#line 1759
  patadd((char *)(& up), 0, (long )sizeof(up), 0);
  }
#line 1760
  if (paren) {
    {
#line 1760
    tmp = patcompswitch(1, & dummy___0);
#line 1760
    br = tmp;
    }
  } else {
    {
#line 1760
    tmp___0 = patcompbranch(& dummy___0, 0);
#line 1760
    br = tmp___0;
    }
  }
#line 1760
  if (! br) {
#line 1761
    return (0L);
  }
  {
#line 1762
  tmp___1 = patnode(2L);
#line 1762
  pattail(br, tmp___1);
#line 1763
  n = patnode(5L);
#line 1764
  pattail(excsync, n);
#line 1765
  pattail(excl, n);
  }
#line 1767
  return (starter);
}
}
#line 1773 "/tmp/zsh-5.4.2/Src/pattern.c"
static long patnode(long op___0 ) 
{ 
  long starter ;
  union upat up ;

  {
  {
#line 1776
  starter = (Upat )patcode - (Upat )patout;
#line 1779
  up.l = op___0;
#line 1780
  patadd((char *)(& up), 0, (long )sizeof(union upat ), 0);
  }
#line 1781
  return (starter);
}
}
#line 1790 "/tmp/zsh-5.4.2/Src/pattern.c"
static void patinsert(long op___0 , int opnd , char *xtra , int sz___0 ) 
{ 
  char *src ;
  char *dst ;
  char *opdst ;
  union upat buf___7 ;
  union upat *lptr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1796
  buf___7.l = 0L;
#line 1797
  patadd((char *)(& buf___7), 0, (long )sizeof(buf___7), 0);
  }
#line 1798
  if (sz___0) {
    {
#line 1799
    patadd(xtra, 0, (long )sz___0, 0);
    }
  }
#line 1800
  src = (patcode - sizeof(union upat )) - sz___0;
#line 1801
  dst = patcode;
#line 1802
  opdst = patout + (unsigned long )opnd * sizeof(union upat );
  {
#line 1803
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1803
    if (! ((unsigned long )src > (unsigned long )opdst)) {
#line 1803
      goto while_break;
    }
#line 1804
    dst --;
#line 1804
    src --;
#line 1804
    *dst = *src;
  }
  while_break: /* CIL Label */ ;
  }
#line 1807
  lptr = (Upat )opdst;
#line 1808
  lptr->l = op___0;
#line 1809
  opdst += sizeof(union upat );
  {
#line 1810
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1810
    tmp___1 = sz___0;
#line 1810
    sz___0 --;
#line 1810
    if (! tmp___1) {
#line 1810
      goto while_break___0;
    }
#line 1811
    tmp = opdst;
#line 1811
    opdst ++;
#line 1811
    tmp___0 = xtra;
#line 1811
    xtra ++;
#line 1811
    *tmp = *tmp___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1812
  return;
}
}
#line 1817 "/tmp/zsh-5.4.2/Src/pattern.c"
static void pattail(long p , long val ) 
{ 
  Upat scan ;
  Upat temp ;
  long offset ;
  Upat tmp ;

  {
#line 1823
  scan = (Upat )patout + p;
  {
#line 1824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1825
    rn_offs = scan->l >> 8;
#line 1825
    if (rn_offs) {
#line 1825
      if ((scan->l & 255L) == 3L) {
#line 1825
        tmp = scan - rn_offs;
      } else {
#line 1825
        tmp = scan + rn_offs;
      }
#line 1825
      temp = tmp;
    } else {
#line 1825
      temp = (Upat )((void *)0);
    }
#line 1825
    if (! temp) {
#line 1826
      goto while_break;
    }
#line 1827
    scan = temp;
  }
  while_break: /* CIL Label */ ;
  }
#line 1830
  if ((scan->l & 255L) == 3L) {
#line 1830
    offset = (scan - (Upat )patout) - val;
  } else {
#line 1830
    offset = val - (scan - (Upat )patout);
  }
#line 1833
  scan->l |= offset << 8;
#line 1834
  return;
}
}
#line 1839 "/tmp/zsh-5.4.2/Src/pattern.c"
static void patoptail(long p , long val ) 
{ 
  Upat ptr___0 ;
  int op___0 ;

  {
#line 1842
  ptr___0 = (Upat )patout + p;
#line 1843
  op___0 = (int )(ptr___0->l & 255L);
#line 1844
  if (! p) {
#line 1845
    return;
  } else
#line 1844
  if (! (ptr___0->l & 32L)) {
#line 1845
    return;
  }
#line 1846
  if (op___0 == 32) {
    {
#line 1847
    pattail(p + 1L, val);
    }
  } else {
    {
#line 1849
    pattail((p + 1L) + 1L, val);
    }
  }
#line 1850
  return;
}
}
#line 1872 "/tmp/zsh-5.4.2/Src/pattern.c"
static struct rpat pattrystate  ;
#line 1892 "/tmp/zsh-5.4.2/Src/pattern.c"
static wchar_t charref(char *x , char *y , int *zmb_ind ) 
{ 
  wchar_t wc ;
  size_t ret ;

  {
#line 1898
  if (! (patglobflags & 4096)) {
#line 1899
    return ((wchar_t )((unsigned char )*x));
  } else
#line 1898
  if (! ((int )((unsigned char )*x) & 128)) {
#line 1899
    return ((wchar_t )((unsigned char )*x));
  }
  {
#line 1901
  ret = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)x,
                (size_t )(y - x), (mbstate_t */* __restrict  */)(& shiftstate));
  }
#line 1903
  if (ret == 0xffffffffffffffffUL) {
#line 1903
    goto _L;
  } else
#line 1903
  if (ret == 0xfffffffffffffffeUL) {
    _L: /* CIL Label */ 
    {
#line 1906
    memset((void *)(& shiftstate), 0, sizeof(shiftstate));
    }
#line 1907
    if (zmb_ind) {
#line 1908
      if (ret == 0xffffffffffffffffUL) {
#line 1908
        *zmb_ind = 2;
      } else {
#line 1908
        *zmb_ind = 1;
      }
    }
#line 1909
    return (56320 + (int )((unsigned char )*x));
  }
#line 1912
  if (zmb_ind) {
#line 1913
    *zmb_ind = 0;
  }
#line 1914
  return (wc);
}
}
#line 1919 "/tmp/zsh-5.4.2/Src/pattern.c"
static char *charnext(char *x , char *y ) 
{ 
  wchar_t wc ;
  size_t ret ;
  size_t tmp ;

  {
#line 1925
  if (! (patglobflags & 4096)) {
#line 1926
    return (x + 1);
  } else
#line 1925
  if (! ((int )((unsigned char )*x) & 128)) {
#line 1926
    return (x + 1);
  }
  {
#line 1928
  ret = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)x,
                (size_t )(y - x), (mbstate_t */* __restrict  */)(& shiftstate));
  }
#line 1930
  if (ret == 0xffffffffffffffffUL) {
    {
#line 1933
    memset((void *)(& shiftstate), 0, sizeof(shiftstate));
    }
#line 1934
    return (x + 1);
  } else
#line 1930
  if (ret == 0xfffffffffffffffeUL) {
    {
#line 1933
    memset((void *)(& shiftstate), 0, sizeof(shiftstate));
    }
#line 1934
    return (x + 1);
  }
#line 1938
  if (ret) {
#line 1938
    tmp = ret;
  } else {
#line 1938
    tmp = (size_t )1;
  }
#line 1938
  return (x + tmp);
}
}
#line 1947 "/tmp/zsh-5.4.2/Src/pattern.c"
static wchar_t charrefinc(char **x , char *y , int *z ) 
{ 
  wchar_t wc ;
  size_t ret ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1953
  if (! (patglobflags & 4096)) {
#line 1954
    tmp = *x;
#line 1954
    (*x) ++;
#line 1954
    return ((wchar_t )((unsigned char )*tmp));
  } else
#line 1953
  if (! ((int )((unsigned char )*(*x)) & 128)) {
#line 1954
    tmp = *x;
#line 1954
    (*x) ++;
#line 1954
    return ((wchar_t )((unsigned char )*tmp));
  }
  {
#line 1956
  ret = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)*x,
                (size_t )(y - *x), (mbstate_t */* __restrict  */)(& shiftstate));
  }
#line 1958
  if (ret == 0xffffffffffffffffUL) {
    {
#line 1960
    *z = 1;
#line 1962
    memset((void *)(& shiftstate), 0, sizeof(shiftstate));
#line 1963
    tmp___0 = *x;
#line 1963
    (*x) ++;
    }
#line 1963
    return (56320 + (int )((unsigned char )*tmp___0));
  } else
#line 1958
  if (ret == 0xfffffffffffffffeUL) {
    {
#line 1960
    *z = 1;
#line 1962
    memset((void *)(& shiftstate), 0, sizeof(shiftstate));
#line 1963
    tmp___0 = *x;
#line 1963
    (*x) ++;
    }
#line 1963
    return (56320 + (int )((unsigned char )*tmp___0));
  }
#line 1967
  if (ret) {
#line 1967
    tmp___1 = ret;
  } else {
#line 1967
    tmp___1 = (size_t )1;
  }
#line 1967
  *x += tmp___1;
#line 1969
  return (wc);
}
}
#line 1980 "/tmp/zsh-5.4.2/Src/pattern.c"
static ptrdiff_t charsub(char *x , char *y ) 
{ 
  ptrdiff_t res ;
  size_t ret ;
  wchar_t wc ;

  {
#line 1983
  res = (ptrdiff_t )0;
#line 1987
  if (! opts[117]) {
#line 1988
    return (y - x);
  }
  {
#line 1990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1990
    if (! ((unsigned long )x < (unsigned long )y)) {
#line 1990
      goto while_break;
    }
    {
#line 1991
    ret = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)x,
                  (size_t )(y - x), (mbstate_t */* __restrict  */)(& shiftstate));
    }
#line 1993
    if (ret == 0xffffffffffffffffUL) {
#line 1995
      return (res + (y - x));
    } else
#line 1993
    if (ret == 0xfffffffffffffffeUL) {
#line 1995
      return (res + (y - x));
    }
#line 1999
    if (! ret) {
#line 2000
      ret = (size_t )1;
    }
#line 2001
    res ++;
#line 2002
    x += ret;
  }
  while_break: /* CIL Label */ ;
  }
#line 2005
  return (res);
}
}
#line 2034 "/tmp/zsh-5.4.2/Src/pattern.c"
void pattrystart(void) 
{ 


  {
#line 2037
  forceerrs = -1;
#line 2038
  errsfound = 0;
#line 2039
  return;
}
}
#line 2051 "/tmp/zsh-5.4.2/Src/pattern.c"
static void patmungestring(char **string , int *stringlen , int *unmetalenin ) 
{ 
  size_t tmp ;

  {
#line 2057
  if (*stringlen > 0) {
#line 2057
    if ((int )*(*string) == -95) {
#line 2058
      (*string) ++;
#line 2063
      if (*unmetalenin > 0) {
#line 2064
        (*unmetalenin) --;
      }
#line 2065
      if (*stringlen > 0) {
#line 2066
        (*stringlen) --;
      }
    }
  }
#line 2070
  if (*stringlen < 0) {
    {
#line 2071
    tmp = strlen((char const   *)*string);
#line 2071
    *stringlen = (int )tmp;
    }
  }
#line 2072
  return;
}
}
#line 2104 "/tmp/zsh-5.4.2/Src/pattern.c"
char *patallocstr(Patprog prog , char *string , int stringlen , int unmetalen , int force ,
                  Patstralloc patstralloc ) 
{ 
  int needfullpath ;
  int tmp ;
  char *dst ;
  char *ptr___0 ;
  int i ;
  int icopy ;
  int ncopy ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 2109
  if (force) {
    {
#line 2110
    patmungestring(& string, & stringlen, & unmetalen);
    }
  }
#line 2117
  if (prog->flags & 2048) {
#line 2117
    if (pathpos) {
#line 2117
      tmp = 1;
    } else {
#line 2117
      tmp = 0;
    }
  } else {
#line 2117
    tmp = 0;
  }
#line 2117
  needfullpath = tmp;
#line 2120
  if (unmetalen < 0) {
    {
#line 2121
    patstralloc->unmetalen = ztrsub((char const   *)(string + stringlen), (char const   *)string);
    }
  } else {
#line 2123
    patstralloc->unmetalen = unmetalen;
  }
#line 2124
  if (needfullpath) {
    {
#line 2125
    patstralloc->unmetalenp = ztrsub((char const   *)(pathbuf + pathpos), (char const   *)pathbuf);
    }
#line 2126
    if (! patstralloc->unmetalenp) {
#line 2127
      needfullpath = 0;
    }
  } else {
#line 2129
    patstralloc->unmetalenp = 0;
  }
#line 2131
  patstralloc->progstrunmeta = (char *)((void *)0);
#line 2132
  patstralloc->progstrunmetalen = 0;
#line 2141
  if (force) {
#line 2141
    goto _L___0;
  } else
#line 2141
  if (! (prog->flags & 36)) {
#line 2141
    if (needfullpath) {
#line 2141
      goto _L___0;
    } else
#line 2141
    if (patstralloc->unmetalen != stringlen) {
      _L___0: /* CIL Label */ 
      {
#line 2152
      tmp___1 = zhalloc((size_t )(patstralloc->unmetalen + patstralloc->unmetalenp));
#line 2152
      tmp___0 = (char *)tmp___1;
#line 2152
      patstralloc->alloced = tmp___0;
#line 2152
      dst = tmp___0;
      }
#line 2155
      if (needfullpath) {
#line 2157
        ptr___0 = pathbuf;
#line 2158
        ncopy = patstralloc->unmetalenp;
      } else {
#line 2161
        ptr___0 = string;
#line 2162
        ncopy = patstralloc->unmetalen;
      }
#line 2164
      icopy = 0;
      {
#line 2164
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2164
        if (! (icopy < 2)) {
#line 2164
          goto while_break;
        }
#line 2165
        i = 0;
        {
#line 2165
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2165
          if (! (i < ncopy)) {
#line 2165
            goto while_break___0;
          }
#line 2166
          if ((int )*ptr___0 == -125) {
#line 2167
            ptr___0 ++;
#line 2168
            tmp___2 = dst;
#line 2168
            dst ++;
#line 2168
            tmp___3 = ptr___0;
#line 2168
            ptr___0 ++;
#line 2168
            *tmp___2 = (char )((int )*tmp___3 ^ 32);
          } else {
#line 2170
            tmp___4 = dst;
#line 2170
            dst ++;
#line 2170
            tmp___5 = ptr___0;
#line 2170
            ptr___0 ++;
#line 2170
            *tmp___4 = *tmp___5;
          }
#line 2165
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2173
        if (! needfullpath) {
#line 2174
          goto while_break;
        }
#line 2176
        ptr___0 = string;
#line 2177
        ncopy = patstralloc->unmetalen;
#line 2164
        icopy ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 2182
      patstralloc->alloced = (char *)((void *)0);
    }
  } else {
#line 2182
    patstralloc->alloced = (char *)((void *)0);
  }
#line 2185
  return (patstralloc->alloced);
}
}
#line 2194 "/tmp/zsh-5.4.2/Src/pattern.c"
int pattry(Patprog prog , char *string ) 
{ 
  int tmp ;

  {
  {
#line 2197
  tmp = pattryrefs(prog, string, -1, -1, (Patstralloc )((void *)0), 0, (int *)((void *)0),
                   (int *)((void *)0), (int *)((void *)0));
  }
#line 2197
  return (tmp);
}
}
#line 2207 "/tmp/zsh-5.4.2/Src/pattern.c"
int pattrylen(Patprog prog , char *string , int len , int unmetalen , Patstralloc patstralloc ,
              int offset ) 
{ 
  int tmp ;

  {
  {
#line 2211
  tmp = pattryrefs(prog, string, len, unmetalen, patstralloc, offset, (int *)((void *)0),
                   (int *)((void *)0), (int *)((void *)0));
  }
#line 2211
  return (tmp);
}
}
#line 2265 "/tmp/zsh-5.4.2/Src/pattern.c"
int pattryrefs(Patprog prog , char *string , int stringlen , int unmetalenin , Patstralloc patstralloc ,
               int patoffset , int *nump , int *begp , int *endp ) 
{ 
  int i ;
  int maxnpos ;
  int ret ;
  int origlen ;
  char **sp___0 ;
  char **ep___0 ;
  char *ptr___0 ;
  char *progstr ;
  struct patstralloc patstralloc_struct ;
  char *tmp ;
  int pstrlen ;
  char *pstr ;
  int lendiff ;
  int tmp___0 ;
  int tmp___1 ;
  char *str ;
  int mlen ;
  ptrdiff_t tmp___2 ;
  char *testptr ;
  char *teststop ;
  char *patptr ;
  int patlen ;
  int found ;
  int tmp___3 ;
  char *str___0 ;
  int mlen___0 ;
  ptrdiff_t tmp___4 ;
  int *tmp___5 ;
  ptrdiff_t tmp___6 ;
  int *tmp___7 ;
  ptrdiff_t tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int palen ;
  char **matcharr ;
  char **mbeginarr ;
  char **mendarr ;
  char numbuf[(int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3] ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  ptrdiff_t tmp___14 ;
  ptrdiff_t tmp___15 ;
  ptrdiff_t tmp___16 ;
  int tmp___17 ;

  {
#line 2270
  maxnpos = 0;
#line 2273
  progstr = (char *)prog + prog->startoff;
#line 2276
  if (nump) {
#line 2277
    maxnpos = *nump;
#line 2278
    *nump = 0;
  }
#line 2281
  if (! patstralloc) {
    {
#line 2282
    patmungestring(& string, & stringlen, & unmetalenin);
    }
  }
#line 2283
  origlen = stringlen;
#line 2285
  if (patstralloc) {
#line 2290
    pattrystate.patinpath = (char *)((void *)0);
#line 2291
    pattrystate.patinstart = string;
  } else {
    {
#line 2294
    patstralloc = & patstralloc_struct;
#line 2295
    tmp = patallocstr(prog, string, stringlen, unmetalenin, 0, patstralloc);
    }
#line 2295
    if (tmp) {
#line 2296
      pattrystate.patinstart = patstralloc->alloced + patstralloc->unmetalenp;
#line 2297
      stringlen = patstralloc->unmetalen;
    } else {
#line 2299
      pattrystate.patinstart = string;
    }
#line 2300
    if (patstralloc->unmetalenp) {
#line 2301
      pattrystate.patinpath = patstralloc->alloced;
    } else {
#line 2303
      pattrystate.patinpath = (char *)((void *)0);
    }
  }
#line 2306
  patflags = prog->flags;
#line 2307
  pattrystate.patinend = pattrystate.patinstart + stringlen;
#line 2314
  if (prog->flags & 36) {
#line 2321
    if (patstralloc->alloced) {
#line 2328
      if (! patstralloc->progstrunmeta) {
        {
#line 2330
        patstralloc->progstrunmeta = dupstrpfx((char const   *)progstr, (int )prog->patmlen);
#line 2332
        unmetafy(patstralloc->progstrunmeta, & patstralloc->progstrunmetalen);
        }
      }
#line 2335
      pstr = patstralloc->progstrunmeta;
#line 2336
      pstrlen = patstralloc->progstrunmetalen;
    } else {
#line 2341
      pstr = progstr;
#line 2342
      pstrlen = (int )prog->patmlen;
    }
#line 2344
    if (prog->flags & 4) {
#line 2349
      ret = 1;
    } else {
#line 2355
      lendiff = stringlen - pstrlen;
#line 2356
      if (lendiff < 0) {
#line 2358
        ret = 0;
      } else {
        {
#line 2359
        tmp___1 = memcmp((void const   *)pstr, (void const   *)pattrystate.patinstart,
                         (size_t )pstrlen);
        }
#line 2359
        if (tmp___1) {
#line 2368
          ret = 0;
        } else {
#line 2365
          if (! lendiff) {
#line 2365
            tmp___0 = 1;
          } else
#line 2365
          if (prog->flags & 8) {
#line 2365
            tmp___0 = 1;
          } else {
#line 2365
            tmp___0 = 0;
          }
#line 2365
          ret = tmp___0;
        }
      }
    }
#line 2371
    if (ret) {
#line 2376
      if (prog->flags & 16) {
#line 2376
        if ((int )*(pattrystate.patinstart) == 46) {
#line 2377
          ret = 0;
        } else {
#line 2376
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 2385
        pattrystate.patinlen = pstrlen;
#line 2387
        patglobflags = prog->globend;
#line 2389
        if (patglobflags & 2048) {
#line 2389
          if (! (patflags & 1)) {
#line 2394
            if (patstralloc->alloced) {
              {
#line 2399
              str = metafy(pattrystate.patinstart, pstrlen, 3);
#line 2400
              tmp___2 = charsub(pattrystate.patinstart, pattrystate.patinstart + pstrlen);
#line 2400
              mlen = (int )tmp___2;
              }
            } else {
              {
#line 2402
              str = ztrduppfx((char const   *)pattrystate.patinstart, pattrystate.patinlen);
#line 2407
              mb_charinit();
#line 2408
              mlen = mb_metastrlenend(pattrystate.patinstart, 0, pattrystate.patinstart + pattrystate.patinlen);
              }
            }
            {
#line 2412
            setsparam((char *)"MATCH", str);
#line 2413
            setiparam((char *)"MBEGIN", (zlong )(patoffset + ! opts[95]));
#line 2415
            setiparam((char *)"MEND", (zlong )(((mlen + patoffset) + ! opts[95]) - 1));
            }
          }
        }
      }
    }
  } else {
#line 2426
    ret = 1;
#line 2427
    if (! (prog->flags & 128)) {
#line 2427
      if (prog->mustoff) {
#line 2431
        patptr = (char *)prog + prog->mustoff;
#line 2432
        patlen = (int )prog->patmlen;
#line 2433
        found = 0;
#line 2435
        if (patlen > stringlen) {
#line 2437
          ret = 0;
        } else {
#line 2439
          teststop = pattrystate.patinend - patlen;
#line 2441
          testptr = pattrystate.patinstart;
          {
#line 2441
          while (1) {
            while_continue: /* CIL Label */ ;
#line 2441
            if (! ((unsigned long )testptr <= (unsigned long )teststop)) {
#line 2441
              goto while_break;
            }
            {
#line 2443
            tmp___3 = memcmp((void const   *)testptr, (void const   *)patptr, (size_t )patlen);
            }
#line 2443
            if (! tmp___3) {
#line 2444
              found = 1;
#line 2445
              goto while_break;
            }
#line 2441
            testptr ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 2449
          if (! found) {
#line 2450
            ret = 0;
          }
        }
      }
    }
#line 2453
    if (! ret) {
#line 2454
      return (0);
    }
#line 2456
    patglobflags = prog->globflags;
#line 2457
    if (! (patflags & 1)) {
#line 2458
      forceerrs = -1;
#line 2459
      errsfound = 0;
    }
    {
#line 2461
    pattrystate.globdots = ! (patflags & 16);
#line 2462
    pattrystate.parsfound = 0;
#line 2464
    pattrystate.patinput = pattrystate.patinstart;
#line 2466
    tmp___17 = patmatch((Upat )progstr);
    }
#line 2466
    if (tmp___17) {
#line 2471
      patglobflags = prog->globend;
#line 2478
      pattrystate.patinlen = (int )(pattrystate.patinput - pattrystate.patinstart);
#line 2485
      if ((unsigned long )patstralloc == (unsigned long )(& patstralloc_struct)) {
#line 2485
        if (patstralloc->unmetalen != origlen) {
#line 2487
          ptr___0 = pattrystate.patinstart;
          {
#line 2487
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2487
            if (! ((unsigned long )ptr___0 < (unsigned long )pattrystate.patinput)) {
#line 2487
              goto while_break___0;
            }
#line 2488
            if ((int )typtab[(unsigned char )*ptr___0] & (1 << 12)) {
#line 2489
              (pattrystate.patinlen) ++;
            }
#line 2487
            ptr___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
#line 2496
      if (patglobflags & 2048) {
#line 2496
        if (! (patflags & 1)) {
          {
#line 2504
          tmp___4 = charsub(pattrystate.patinstart, pattrystate.patinput);
#line 2504
          mlen___0 = (int )tmp___4;
#line 2506
          str___0 = metafy(pattrystate.patinstart, (int )(pattrystate.patinput - pattrystate.patinstart),
                           3);
#line 2507
          setsparam((char *)"MATCH", str___0);
#line 2508
          setiparam((char *)"MBEGIN", (zlong )(patoffset + ! opts[95]));
#line 2509
          setiparam((char *)"MEND", (zlong )(((mlen___0 + patoffset) + ! opts[95]) - 1));
          }
        }
      }
#line 2513
      if (prog->patnpar) {
#line 2513
        if (nump) {
#line 2518
          *nump = prog->patnpar;
#line 2520
          sp___0 = pattrystate.patbeginp;
#line 2521
          ep___0 = pattrystate.patendp;
#line 2523
          i = 0;
          {
#line 2523
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2523
            if (i < prog->patnpar) {
#line 2523
              if (! (i < maxnpos)) {
#line 2523
                goto while_break___1;
              }
            } else {
#line 2523
              goto while_break___1;
            }
#line 2524
            if (pattrystate.parsfound & (1 << i)) {
#line 2525
              if (begp) {
                {
#line 2526
                tmp___5 = begp;
#line 2526
                begp ++;
#line 2526
                tmp___6 = charsub(pattrystate.patinstart, *sp___0);
#line 2526
                *tmp___5 = (int )(tmp___6 + (ptrdiff_t )patoffset);
                }
              }
#line 2527
              if (endp) {
                {
#line 2528
                tmp___7 = endp;
#line 2528
                endp ++;
#line 2528
                tmp___8 = charsub(pattrystate.patinstart, *ep___0);
#line 2528
                *tmp___7 = (int )((tmp___8 + (ptrdiff_t )patoffset) - 1L);
                }
              }
            } else {
#line 2531
              if (begp) {
#line 2532
                tmp___9 = begp;
#line 2532
                begp ++;
#line 2532
                *tmp___9 = -1;
              }
#line 2533
              if (endp) {
#line 2534
                tmp___10 = endp;
#line 2534
                endp ++;
#line 2534
                *tmp___10 = -1;
              }
            }
#line 2537
            sp___0 ++;
#line 2538
            ep___0 ++;
#line 2523
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 2513
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2540
      if (prog->patnpar) {
#line 2540
        if (! (patflags & 1)) {
          {
#line 2544
          palen = prog->patnpar + 1;
#line 2548
          tmp___11 = zshcalloc((unsigned long )palen * sizeof(char *));
#line 2548
          matcharr = (char **)tmp___11;
#line 2549
          tmp___12 = zshcalloc((unsigned long )palen * sizeof(char *));
#line 2549
          mbeginarr = (char **)tmp___12;
#line 2550
          tmp___13 = zshcalloc((unsigned long )palen * sizeof(char *));
#line 2550
          mendarr = (char **)tmp___13;
#line 2552
          sp___0 = pattrystate.patbeginp;
#line 2553
          ep___0 = pattrystate.patendp;
#line 2555
          i = 0;
          }
          {
#line 2555
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2555
            if (! (i < prog->patnpar)) {
#line 2555
              goto while_break___2;
            }
#line 2556
            if (pattrystate.parsfound & (1 << i)) {
              {
#line 2557
              *(matcharr + i) = metafy(*sp___0, (int )(*ep___0 - *sp___0), 3);
#line 2567
              tmp___14 = charsub(pattrystate.patinstart, *sp___0);
#line 2567
              sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%ld",
                      (tmp___14 + (ptrdiff_t )patoffset) + (ptrdiff_t )(! opts[95]));
#line 2571
              *(mbeginarr + i) = ztrdup((char const   *)(numbuf));
#line 2572
              tmp___15 = charsub(pattrystate.patinstart, *ep___0);
#line 2572
              sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%ld",
                      ((tmp___15 + (ptrdiff_t )patoffset) + (ptrdiff_t )(! opts[95])) - 1L);
#line 2576
              *(mendarr + i) = ztrdup((char const   *)(numbuf));
              }
            } else {
              {
#line 2582
              *(matcharr + i) = ztrdup("");
#line 2583
              *(mbeginarr + i) = ztrdup("-1");
#line 2584
              *(mendarr + i) = ztrdup("-1");
              }
            }
#line 2586
            sp___0 ++;
#line 2587
            ep___0 ++;
#line 2555
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 2589
          setaparam((char *)"match", matcharr);
#line 2590
          setaparam((char *)"mbegin", mbeginarr);
#line 2591
          setaparam((char *)"mend", mendarr);
          }
        }
      }
#line 2594
      if (! nump) {
#line 2594
        if (endp) {
          {
#line 2598
          tmp___16 = charsub(pattrystate.patinstart, pattrystate.patinput);
#line 2598
          *endp = (int )(tmp___16 + (ptrdiff_t )patoffset);
          }
        }
      }
#line 2601
      ret = 1;
    } else {
#line 2603
      ret = 0;
    }
  }
#line 2606
  return (ret);
}
}
#line 2618 "/tmp/zsh-5.4.2/Src/pattern.c"
int patmatchlen(void) 
{ 


  {
#line 2621
  return (pattrystate.patinlen);
}
}
#line 2663 "/tmp/zsh-5.4.2/Src/pattern.c"
static char *exactpos  ;
#line 2663 "/tmp/zsh-5.4.2/Src/pattern.c"
static char *exactend  ;
#line 2673 "/tmp/zsh-5.4.2/Src/pattern.c"
static int patmatch(Upat prog ) 
{ 
  Upat scan ;
  Upat next___0 ;
  Upat opnd ;
  char *start ;
  char *save ;
  char *chrop ;
  char *chrend ;
  char *compend ;
  int savglobflags ;
  int op___0 ;
  int no ;
  int min ;
  int fail ;
  int saverrsfound ;
  zrange_t from ;
  zrange_t to ;
  zrange_t comp ;
  patint_t nextch ;
  int q ;
  int savpatflags ;
  int savpatglobflags ;
  char *savexactpos ;
  char *savexactend ;
  struct rpat savpattrystate ;
  sigset_t oset ;
  Upat tmp ;
  char *savpatinput ;
  char *savchrop ;
  int badin ;
  int badpa ;
  patint_t chin ;
  wchar_t tmp___0 ;
  patint_t chpa ;
  wchar_t tmp___1 ;
  wint_t tmp___3 ;
  wint_t tmp___4 ;
  int tmp___5 ;
  wint_t tmp___7 ;
  wint_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  wint_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int zmb_ind ;
  wchar_t cr ;
  wchar_t tmp___15 ;
  char *scanop ;
  int tmp___16 ;
  int tmp___17 ;
  int out_of_range ;
  int digit ;
  zrange_t c10 ;
  zrange_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned char *syncptr ;
  Upat after ;
  Upat syncstrp ;
  char *origpatinend ;
  unsigned char *oldsyncstr ;
  char *matchpt ;
  int ret ;
  int savglobdots ;
  int matchederrs ;
  int savparsfound ;
  void *tmp___23 ;
  unsigned char *syncpt ;
  char *savpatinstart ;
  int savforce ;
  int savpatflags___0 ;
  int synclen ;
  Upat tmp___24 ;
  int tmp___25 ;
  Upat tmp___26 ;
  Upat tmp___27 ;
  int ret___0 ;
  int pfree ;
  Upat ptrp ;
  unsigned char *ptr___0 ;
  Upat tmp___28 ;
  void *tmp___29 ;
  Upat tmp___30 ;
  Upat tmp___31 ;
  Upat tmp___32 ;
  char *lastcharstart ;
  char *charstart ;
  void *tmp___33 ;
  wchar_t tmp___34 ;
  char *nextop ;
  int nextlen ;
  int ptlen ;
  int lenmatch ;
  char *tmp___35 ;
  char *tmp___36 ;
  Upat tmp___37 ;
  Upat tmp___38 ;
  wchar_t tmp___39 ;
  patint_t charmatch_cache ;
  int tmp___40 ;
  wchar_t tmp___41 ;
  wint_t tmp___43 ;
  wint_t tmp___44 ;
  int tmp___45 ;
  wint_t tmp___47 ;
  wint_t tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  wint_t tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  long *curptr ;
  long savecount ;
  unsigned char *saveptr ;
  int ret___1 ;
  long cur ;
  long min___0 ;
  long max ;
  int tmp___56 ;
  char *patinput_thistime ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  char *savexact ;
  int tmp___60 ;
  char *nextexact ;
  char *nextin ;
  patint_t cin0 ;
  wchar_t tmp___61 ;
  patint_t cpa0 ;
  wchar_t tmp___62 ;
  patint_t cin1 ;
  wchar_t tmp___63 ;
  patint_t cpa1 ;
  wchar_t tmp___64 ;
  int tmp___65 ;
  wint_t tmp___67 ;
  wint_t tmp___68 ;
  int tmp___69 ;
  wint_t tmp___71 ;
  wint_t tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  wint_t tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  wint_t tmp___80 ;
  wint_t tmp___81 ;
  int tmp___82 ;
  wint_t tmp___84 ;
  wint_t tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  wint_t tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int savpatflags___1 ;
  int savpatglobflags___0 ;
  char *savexactpos___0 ;
  char *savexactend___0 ;
  struct rpat savpattrystate___0 ;
  sigset_t oset___0 ;

  {
#line 2677
  scan = prog;
#line 2679
  fail = 0;
#line 2682
  q = queueing_enabled;
  {
#line 2701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2701
    if (queue_front != queue_rear) {
#line 2701
      savpatflags = patflags;
#line 2701
      savpatglobflags = patglobflags;
#line 2701
      savexactpos = exactpos;
#line 2701
      savexactend = exactend;
#line 2701
      savpattrystate = pattrystate;
      {
#line 2701
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2701
        queueing_enabled = 0;
        {
#line 2701
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 2701
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2701
            if (! (queue_front != queue_rear)) {
#line 2701
              goto while_break___2;
            }
            {
#line 2701
            queue_front = (queue_front + 1) % 128;
#line 2701
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 2701
            zhandler(signal_queue[queue_front]);
#line 2701
            signal_setmask(oset);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2701
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2701
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2701
      queueing_enabled = q;
#line 2701
      exactpos = savexactpos;
#line 2701
      exactend = savexactend;
#line 2701
      patflags = savpatflags;
#line 2701
      patglobflags = savpatglobflags;
#line 2701
      pattrystate = savpattrystate;
    }
#line 2701
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2703
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2703
    if (scan) {
#line 2703
      if (! (! errflag)) {
#line 2703
        goto while_break___3;
      }
    } else {
#line 2703
      goto while_break___3;
    }
#line 2704
    rn_offs = scan->l >> 8;
#line 2704
    if (rn_offs) {
#line 2704
      if ((scan->l & 255L) == 3L) {
#line 2704
        tmp = scan - rn_offs;
      } else {
#line 2704
        tmp = scan + rn_offs;
      }
#line 2704
      next___0 = tmp;
    } else {
#line 2704
      next___0 = (Upat )((void *)0);
    }
#line 2706
    if (! pattrystate.globdots) {
#line 2706
      if (scan->l & 64L) {
#line 2706
        if ((unsigned long )pattrystate.patinput == (unsigned long )pattrystate.patinstart) {
#line 2706
          if ((unsigned long )pattrystate.patinput < (unsigned long )pattrystate.patinend) {
#line 2706
            if ((int )*(pattrystate.patinput) == 46) {
#line 2708
              return (0);
            }
          }
        }
      }
    }
    {
#line 2711
    if ((scan->l & 255L) == 64L) {
#line 2711
      goto case_64;
    }
#line 2717
    if ((scan->l & 255L) == 4L) {
#line 2717
      goto case_4;
    }
#line 2761
    if ((scan->l & 255L) == 66L) {
#line 2761
      goto case_66;
    }
#line 2761
    if ((scan->l & 255L) == 65L) {
#line 2761
      goto case_66;
    }
#line 2792
    if ((scan->l & 255L) == 70L) {
#line 2792
      goto case_70;
    }
#line 2792
    if ((scan->l & 255L) == 69L) {
#line 2792
      goto case_70;
    }
#line 2792
    if ((scan->l & 255L) == 68L) {
#line 2792
      goto case_70;
    }
#line 2891
    if ((scan->l & 255L) == 71L) {
#line 2891
      goto case_71;
    }
#line 2912
    if ((scan->l & 255L) == 5L) {
#line 2912
      goto case_5;
    }
#line 2914
    if ((scan->l & 255L) == 3L) {
#line 2914
      goto case_3;
    }
#line 2916
    if ((scan->l & 255L) == 8L) {
#line 2916
      goto case_8;
    }
#line 2928
    if ((scan->l & 255L) == 137L) {
#line 2928
      goto case_137;
    }
#line 2928
    if ((scan->l & 255L) == 136L) {
#line 2928
      goto case_137;
    }
#line 2928
    if ((scan->l & 255L) == 135L) {
#line 2928
      goto case_137;
    }
#line 2928
    if ((scan->l & 255L) == 134L) {
#line 2928
      goto case_137;
    }
#line 2928
    if ((scan->l & 255L) == 133L) {
#line 2928
      goto case_137;
    }
#line 2928
    if ((scan->l & 255L) == 132L) {
#line 2928
      goto case_137;
    }
#line 2928
    if ((scan->l & 255L) == 131L) {
#line 2928
      goto case_137;
    }
#line 2928
    if ((scan->l & 255L) == 130L) {
#line 2928
      goto case_137;
    }
#line 2928
    if ((scan->l & 255L) == 129L) {
#line 2928
      goto case_137;
    }
#line 2928
    if ((scan->l & 255L) == 128L) {
#line 2928
      goto case_137;
    }
#line 2954
    if ((scan->l & 255L) == 153L) {
#line 2954
      goto case_153;
    }
#line 2954
    if ((scan->l & 255L) == 152L) {
#line 2954
      goto case_153;
    }
#line 2954
    if ((scan->l & 255L) == 151L) {
#line 2954
      goto case_153;
    }
#line 2954
    if ((scan->l & 255L) == 150L) {
#line 2954
      goto case_153;
    }
#line 2954
    if ((scan->l & 255L) == 149L) {
#line 2954
      goto case_153;
    }
#line 2954
    if ((scan->l & 255L) == 148L) {
#line 2954
      goto case_153;
    }
#line 2954
    if ((scan->l & 255L) == 147L) {
#line 2954
      goto case_153;
    }
#line 2954
    if ((scan->l & 255L) == 146L) {
#line 2954
      goto case_153;
    }
#line 2954
    if ((scan->l & 255L) == 145L) {
#line 2954
      goto case_153;
    }
#line 2954
    if ((scan->l & 255L) == 144L) {
#line 2954
      goto case_153;
    }
#line 2967
    if ((scan->l & 255L) == 1L) {
#line 2967
      goto case_1;
    }
#line 2994
    if ((scan->l & 255L) == 2L) {
#line 2994
      goto case_2;
    }
#line 3006
    if ((scan->l & 255L) == 33L) {
#line 3006
      goto case_33;
    }
#line 3006
    if ((scan->l & 255L) == 32L) {
#line 3006
      goto case_33;
    }
#line 3234
    if ((scan->l & 255L) == 67L) {
#line 3234
      goto case_67;
    }
#line 3247
    if ((scan->l & 255L) == 7L) {
#line 3247
      goto case_7;
    }
#line 3247
    if ((scan->l & 255L) == 6L) {
#line 3247
      goto case_7;
    }
#line 3354
    if ((scan->l & 255L) == 9L) {
#line 3354
      goto case_9;
    }
#line 3358
    if ((scan->l & 255L) == 10L) {
#line 3358
      goto case_10;
    }
#line 3362
    if ((scan->l & 255L) == 11L) {
#line 3362
      goto case_11;
    }
#line 3381
    if ((scan->l & 255L) == 12L) {
#line 3381
      goto case_12;
    }
#line 3413
    if ((scan->l & 255L) == 0L) {
#line 3413
      goto case_0;
    }
#line 2710
    goto switch_break;
    case_64: /* CIL Label */ 
#line 2712
    if ((unsigned long )pattrystate.patinput == (unsigned long )pattrystate.patinend) {
#line 2713
      fail = 1;
    } else {
      {
#line 2715
      pattrystate.patinput = charnext(pattrystate.patinput, pattrystate.patinend);
      }
    }
#line 2716
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2722
    if (exactpos) {
#line 2723
      chrop = exactpos;
#line 2724
      chrend = exactend;
    } else {
#line 2726
      chrop = (char *)(scan + 2);
#line 2727
      chrend = chrop + (scan + 1)->l;
    }
#line 2729
    exactpos = (char *)((void *)0);
    {
#line 2730
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2730
      if ((unsigned long )chrop < (unsigned long )chrend) {
#line 2730
        if (! ((unsigned long )pattrystate.patinput < (unsigned long )pattrystate.patinend)) {
#line 2730
          goto while_break___4;
        }
      } else {
#line 2730
        goto while_break___4;
      }
      {
#line 2731
      savpatinput = pattrystate.patinput;
#line 2732
      savchrop = chrop;
#line 2733
      badin = 0;
#line 2733
      badpa = 0;
#line 2745
      tmp___0 = charrefinc(& pattrystate.patinput, pattrystate.patinend, & badin);
#line 2745
      chin = (patint_t )tmp___0;
#line 2746
      tmp___1 = charrefinc(& chrop, chrend, & badpa);
#line 2746
      chpa = (patint_t )tmp___1;
      }
#line 2747
      if (chin == chpa) {
#line 2747
        goto _L;
      } else {
#line 2747
        if (patglobflags & 512) {
          {
#line 2747
          tmp___5 = iswupper(chin);
          }
#line 2747
          if (tmp___5) {
            {
#line 2747
            tmp___3 = towlower(chin);
#line 2747
            tmp___4 = tmp___3;
            }
          } else {
#line 2747
            tmp___4 = chin;
          }
          {
#line 2747
          tmp___9 = iswupper(chpa);
          }
#line 2747
          if (tmp___9) {
            {
#line 2747
            tmp___7 = towlower(chpa);
#line 2747
            tmp___8 = tmp___7;
            }
          } else {
#line 2747
            tmp___8 = chpa;
          }
#line 2747
          tmp___14 = tmp___4 == tmp___8;
        } else {
#line 2747
          if (patglobflags & 256) {
            {
#line 2747
            tmp___10 = iswlower(chpa);
            }
#line 2747
            if (tmp___10) {
              {
#line 2747
              tmp___11 = towupper(chpa);
              }
#line 2747
              if (tmp___11 == chin) {
#line 2747
                tmp___12 = 1;
              } else {
#line 2747
                tmp___12 = 0;
              }
            } else {
#line 2747
              tmp___12 = 0;
            }
#line 2747
            tmp___13 = tmp___12;
          } else {
#line 2747
            tmp___13 = 0;
          }
#line 2747
          tmp___14 = tmp___13;
        }
#line 2747
        if (tmp___14) {
          _L: /* CIL Label */ 
#line 2747
          if (badin != badpa) {
#line 2748
            fail = 1;
#line 2749
            pattrystate.patinput = savpatinput;
#line 2750
            chrop = savchrop;
#line 2751
            goto while_break___4;
          }
        } else {
#line 2748
          fail = 1;
#line 2749
          pattrystate.patinput = savpatinput;
#line 2750
          chrop = savchrop;
#line 2751
          goto while_break___4;
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2754
    if ((unsigned long )chrop < (unsigned long )chrend) {
#line 2755
      exactpos = chrop;
#line 2756
      exactend = chrend;
#line 2757
      fail = 1;
    }
#line 2759
    goto switch_break;
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 2762
    if ((unsigned long )pattrystate.patinput == (unsigned long )pattrystate.patinend) {
#line 2763
      fail = 1;
    } else {
      {
#line 2767
      tmp___15 = charref(pattrystate.patinput, pattrystate.patinend, & zmb_ind);
#line 2767
      cr = tmp___15;
#line 2768
      scanop = (char *)(scan + 1);
      }
#line 2769
      if (patglobflags & 4096) {
        {
#line 2770
        tmp___16 = mb_patmatchrange(scanop, cr, zmb_ind, (wint_t *)((void *)0), (int *)((void *)0));
        }
#line 2770
        if (tmp___16 ^ ((scan->l & 255L) == 65L)) {
#line 2772
          fail = 1;
        } else {
          {
#line 2774
          pattrystate.patinput = charnext(pattrystate.patinput, pattrystate.patinend);
          }
        }
      } else {
        {
#line 2775
        tmp___17 = patmatchrange(scanop, cr, (int *)((void *)0), (int *)((void *)0));
        }
#line 2775
        if (tmp___17 ^ ((scan->l & 255L) == 65L)) {
#line 2777
          fail = 1;
        } else {
          {
#line 2779
          pattrystate.patinput = charnext(pattrystate.patinput, pattrystate.patinend);
          }
        }
      }
    }
#line 2789
    goto switch_break;
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
#line 2801
    op___0 = (int )(scan->l & 255L);
#line 2802
    start = (char *)(scan + 1);
#line 2803
    to = (zrange_t )0;
#line 2803
    from = to;
#line 2804
    if (op___0 != 70) {
#line 2809
      from = *((zrange_t *)start);
#line 2811
      start += sizeof(zrange_t );
    }
#line 2813
    if (op___0 != 69) {
#line 2817
      to = *((zrange_t *)start);
    }
#line 2820
    compend = pattrystate.patinput;
#line 2820
    start = compend;
#line 2821
    comp = (zrange_t )0;
    {
#line 2822
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2822
      if ((unsigned long )pattrystate.patinput < (unsigned long )pattrystate.patinend) {
#line 2822
        if (! ((int )typtab[(unsigned char )*(pattrystate.patinput)] & 1)) {
#line 2822
          goto while_break___5;
        }
      } else {
#line 2822
        goto while_break___5;
      }
#line 2823
      out_of_range = 0;
#line 2824
      digit = (int )*(pattrystate.patinput) - 48;
#line 2825
      if (comp > 922337203685477580L) {
#line 2826
        out_of_range = 1;
      } else {
#line 2828
        if (comp) {
#line 2828
          tmp___18 = comp * 10L;
        } else {
#line 2828
          tmp___18 = (zrange_t )0;
        }
#line 2828
        c10 = tmp___18;
#line 2829
        if (9223372036854775807L - c10 < (long )digit) {
#line 2830
          out_of_range = 1;
        } else {
#line 2832
          comp = c10;
#line 2833
          comp += (zrange_t )digit;
        }
      }
#line 2836
      (pattrystate.patinput) ++;
#line 2837
      compend ++;
#line 2839
      if (out_of_range) {
#line 2839
        goto _L___0;
      } else
#line 2839
      if (comp & (1L << (sizeof(comp) * 8UL - 2UL))) {
        _L___0: /* CIL Label */ 
#line 2857
        if (op___0 == 69) {
          {
#line 2858
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2858
            if ((unsigned long )pattrystate.patinput < (unsigned long )pattrystate.patinend) {
#line 2858
              if (! ((int )typtab[(unsigned char )*(pattrystate.patinput)] & 1)) {
#line 2858
                goto while_break___6;
              }
            } else {
#line 2858
              goto while_break___6;
            }
#line 2859
            (pattrystate.patinput) ++;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2863
    save = pattrystate.patinput;
#line 2864
    no = 0;
    {
#line 2865
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2865
      if (! ((unsigned long )pattrystate.patinput > (unsigned long )start)) {
#line 2865
        goto while_break___7;
      }
#line 2867
      if (comp < from) {
#line 2867
        if ((unsigned long )pattrystate.patinput <= (unsigned long )compend) {
#line 2868
          goto while_break___7;
        }
      }
#line 2869
      if (op___0 == 69) {
#line 2869
        goto _L___1;
      } else
#line 2869
      if (comp <= to) {
        _L___1: /* CIL Label */ 
        {
#line 2869
        tmp___19 = patmatch(next___0);
        }
#line 2869
        if (tmp___19) {
#line 2870
          return (1);
        }
      }
#line 2872
      if (! no) {
#line 2872
        if ((next___0->l & 255L) == 4L) {
#line 2872
          if (! (next___0 + 1)->l) {
#line 2872
            goto _L___2;
          } else
#line 2872
          if (! ((int )typtab[(unsigned char )*((char *)(next___0 + 2))] & 1)) {
            _L___2: /* CIL Label */ 
#line 2872
            if (! (patglobflags & 255)) {
#line 2876
              return (0);
            }
          }
        }
      }
#line 2877
      save --;
#line 2877
      pattrystate.patinput = save;
#line 2878
      no ++;
#line 2885
      if ((unsigned long )pattrystate.patinput < (unsigned long )compend) {
#line 2886
        comp /= 10L;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2888
    pattrystate.patinput = start;
#line 2889
    fail = 1;
#line 2890
    goto switch_break;
    case_71: /* CIL Label */ 
#line 2893
    start = pattrystate.patinput;
    {
#line 2894
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2894
      if ((unsigned long )pattrystate.patinput < (unsigned long )pattrystate.patinend) {
#line 2894
        if (! ((int )typtab[(unsigned char )*(pattrystate.patinput)] & 1)) {
#line 2894
          goto while_break___8;
        }
      } else {
#line 2894
        goto while_break___8;
      }
#line 2895
      (pattrystate.patinput) ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 2896
    save = pattrystate.patinput;
#line 2897
    no = 0;
    {
#line 2898
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2898
      if (! ((unsigned long )pattrystate.patinput > (unsigned long )start)) {
#line 2898
        goto while_break___9;
      }
      {
#line 2899
      tmp___20 = patmatch(next___0);
      }
#line 2899
      if (tmp___20) {
#line 2900
        return (1);
      }
#line 2901
      if (! no) {
#line 2901
        if ((next___0->l & 255L) == 4L) {
#line 2901
          if (! (next___0 + 1)->l) {
#line 2901
            goto _L___3;
          } else
#line 2901
          if (! ((int )typtab[(unsigned char )*((char *)(next___0 + 2))] & 1)) {
            _L___3: /* CIL Label */ 
#line 2901
            if (! (patglobflags & 255)) {
#line 2905
              return (0);
            }
          }
        }
      }
#line 2906
      save --;
#line 2906
      pattrystate.patinput = save;
#line 2907
      no ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 2909
    pattrystate.patinput = start;
#line 2910
    fail = 1;
#line 2911
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2913
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2915
    goto switch_break;
    case_8: /* CIL Label */ 
#line 2917
    patglobflags = (int )(scan + 1)->l;
#line 2918
    goto switch_break;
    case_137: /* CIL Label */ 
    case_136: /* CIL Label */ 
    case_135: /* CIL Label */ 
    case_134: /* CIL Label */ 
    case_133: /* CIL Label */ 
    case_132: /* CIL Label */ 
    case_131: /* CIL Label */ 
    case_130: /* CIL Label */ 
    case_129: /* CIL Label */ 
    case_128: /* CIL Label */ 
    {
#line 2929
    no = (int )((scan->l & 255L) - 128L);
#line 2930
    save = pattrystate.patinput;
#line 2932
    tmp___21 = patmatch(next___0);
    }
#line 2932
    if (tmp___21) {
#line 2937
      if (no) {
#line 2937
        if (! (pattrystate.parsfound & (1 << (no - 1)))) {
#line 2938
          pattrystate.patbeginp[no - 1] = save;
#line 2939
          pattrystate.parsfound |= 1 << (no - 1);
        }
      }
#line 2941
      return (1);
    } else {
#line 2943
      return (0);
    }
#line 2944
    goto switch_break;
    case_153: /* CIL Label */ 
    case_152: /* CIL Label */ 
    case_151: /* CIL Label */ 
    case_150: /* CIL Label */ 
    case_149: /* CIL Label */ 
    case_148: /* CIL Label */ 
    case_147: /* CIL Label */ 
    case_146: /* CIL Label */ 
    case_145: /* CIL Label */ 
    case_144: /* CIL Label */ 
    {
#line 2955
    no = (int )((scan->l & 255L) - 144L);
#line 2956
    save = pattrystate.patinput;
#line 2958
    tmp___22 = patmatch(next___0);
    }
#line 2958
    if (tmp___22) {
#line 2959
      if (no) {
#line 2959
        if (! (pattrystate.parsfound & (1 << (no + 15)))) {
#line 2960
          pattrystate.patendp[no - 1] = save;
#line 2961
          pattrystate.parsfound |= 1 << (no + 15);
        }
      }
#line 2963
      return (1);
    } else {
#line 2965
      return (0);
    }
#line 2966
    goto switch_break;
    case_1: /* CIL Label */ 
#line 2972
    after = scan + 1;
#line 2977
    syncptr = (after + 1)->p + (pattrystate.patinput - pattrystate.patinstart);
#line 2982
    if (*syncptr) {
#line 2982
      if (errsfound + 1 >= (int )*syncptr) {
#line 2983
        return (0);
      }
    }
#line 2991
    *syncptr = (unsigned char )(errsfound + 1);
#line 2993
    goto switch_break;
    case_2: /* CIL Label */ 
#line 3002
    fail = (unsigned long )pattrystate.patinput < (unsigned long )pattrystate.patinend;
#line 3002
    if (! fail) {
#line 3003
      return (1);
    }
#line 3004
    goto switch_break;
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 3008
    if (! (next___0->l & 32L)) {
#line 3012
      next___0 = scan + 1;
    } else {
      {
#line 3014
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 3015
        save = pattrystate.patinput;
#line 3016
        savglobflags = patglobflags;
#line 3017
        saverrsfound = errsfound;
#line 3018
        if ((next___0->l & 48L) == 48L) {
          {
#line 3047
          matchpt = (char *)((void *)0);
#line 3048
          matchederrs = 0;
#line 3049
          savparsfound = pattrystate.parsfound;
#line 3052
          syncstrp = next___0 + 1;
#line 3060
          oldsyncstr = syncstrp->p;
#line 3061
          tmp___23 = zshcalloc((size_t )((pattrystate.patinend - pattrystate.patinstart) + 1L));
#line 3061
          syncstrp->p = (unsigned char *)tmp___23;
#line 3063
          origpatinend = pattrystate.patinend;
          }
          {
#line 3064
          while (1) {
            while_continue___11: /* CIL Label */ ;
            {
#line 3064
            ret = patmatch(scan + 1);
            }
#line 3064
            if (! ret) {
#line 3064
              goto while_break___11;
            }
#line 3067
            savforce = forceerrs;
#line 3068
            savpatflags___0 = patflags;
#line 3069
            forceerrs = -1;
#line 3070
            savglobdots = pattrystate.globdots;
#line 3071
            matchederrs = errsfound;
#line 3072
            matchpt = pattrystate.patinput;
#line 3073
            pattrystate.globdots = 1;
#line 3082
            syncpt = syncstrp->p;
            {
#line 3082
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 3082
              if (! (! *syncpt)) {
#line 3082
                goto while_break___12;
              }
#line 3082
              syncpt ++;
            }
            while_break___12: /* CIL Label */ ;
            }
#line 3084
            synclen = (int )(syncpt - syncstrp->p);
#line 3085
            if ((unsigned long )(pattrystate.patinstart + synclen) != (unsigned long )pattrystate.patinend) {
#line 3093
              pattrystate.patinend = pattrystate.patinstart + synclen;
#line 3098
              patflags |= 1024;
            }
#line 3100
            savpatinstart = pattrystate.patinstart;
#line 3101
            rn_offs = scan->l >> 8;
#line 3101
            if (rn_offs) {
#line 3101
              if ((scan->l & 255L) == 3L) {
#line 3101
                tmp___24 = scan - rn_offs;
              } else {
#line 3101
                tmp___24 = scan + rn_offs;
              }
#line 3101
              next___0 = tmp___24;
            } else {
#line 3101
              next___0 = (Upat )((void *)0);
            }
            {
#line 3102
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 3102
              if (next___0) {
#line 3102
                if (! ((next___0->l & 48L) == 48L)) {
#line 3102
                  goto while_break___13;
                }
              } else {
#line 3102
                goto while_break___13;
              }
#line 3103
              pattrystate.patinput = save;
#line 3110
              patglobflags &= -256;
#line 3111
              errsfound = 0;
#line 3112
              opnd = (next___0 + 1) + 1;
#line 3113
              if ((next___0->l & 255L) == 49L) {
#line 3113
                if (pattrystate.patinpath) {
#line 3124
                  pattrystate.patinstart = pattrystate.patinpath;
#line 3124
                  pattrystate.patinput = pattrystate.patinstart;
                }
              }
              {
#line 3126
              tmp___25 = patmatch(opnd);
              }
#line 3126
              if (tmp___25) {
#line 3127
                ret = 0;
#line 3133
                pattrystate.parsfound = savparsfound;
              }
#line 3135
              if (pattrystate.patinpath) {
#line 3136
                pattrystate.patinput = savpatinstart + (pattrystate.patinput - pattrystate.patinstart);
#line 3138
                pattrystate.patinstart = savpatinstart;
              }
#line 3140
              if (! ret) {
#line 3141
                goto while_break___13;
              }
#line 3142
              rn_offs = next___0->l >> 8;
#line 3142
              if (rn_offs) {
#line 3142
                if ((next___0->l & 255L) == 3L) {
#line 3142
                  tmp___26 = next___0 - rn_offs;
                } else {
#line 3142
                  tmp___26 = next___0 + rn_offs;
                }
#line 3142
                next___0 = tmp___26;
              } else {
#line 3142
                next___0 = (Upat )((void *)0);
              }
            }
            while_break___13: /* CIL Label */ ;
            }
#line 3147
            pattrystate.patinend = origpatinend;
#line 3148
            patflags = savpatflags___0;
#line 3149
            pattrystate.globdots = savglobdots;
#line 3150
            forceerrs = savforce;
#line 3151
            if (ret) {
#line 3152
              goto while_break___11;
            }
#line 3153
            pattrystate.patinput = save;
#line 3154
            patglobflags = savglobflags;
#line 3155
            errsfound = saverrsfound;
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 3157
          zfree((void *)((char *)syncstrp->p), (int )((pattrystate.patinend - pattrystate.patinstart) + 1L));
#line 3159
          syncstrp->p = oldsyncstr;
          }
#line 3160
          if (ret) {
#line 3161
            pattrystate.patinput = matchpt;
#line 3162
            errsfound = matchederrs;
#line 3163
            return (1);
          }
          {
#line 3165
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 3165
            rn_offs = scan->l >> 8;
#line 3165
            if (rn_offs) {
#line 3165
              if ((scan->l & 255L) == 3L) {
#line 3165
                tmp___27 = scan - rn_offs;
              } else {
#line 3165
                tmp___27 = scan + rn_offs;
              }
#line 3165
              scan = tmp___27;
            } else {
#line 3165
              scan = (Upat )((void *)0);
            }
#line 3165
            if (scan) {
#line 3165
              if (! ((scan->l & 48L) == 48L)) {
#line 3165
                goto while_break___14;
              }
            } else {
#line 3165
              goto while_break___14;
            }
          }
          while_break___14: /* CIL Label */ ;
          }
        } else {
#line 3169
          ret___0 = 1;
#line 3169
          pfree = 0;
#line 3170
          ptrp = (Upat )((void *)0);
#line 3172
          if ((scan->l & 255L) == 33L) {
#line 3188
            opnd = scan + 1;
#line 3189
            tmp___28 = opnd;
#line 3189
            opnd ++;
#line 3189
            ptrp = tmp___28;
#line 3190
            if (! ptrp->p) {
              {
#line 3191
              tmp___29 = zshcalloc((size_t )((pattrystate.patinend - pattrystate.patinstart) + 1L));
#line 3191
              ptrp->p = (unsigned char *)tmp___29;
#line 3193
              pfree = 1;
              }
            }
#line 3195
            ptr___0 = ptrp->p + (pattrystate.patinput - pattrystate.patinstart);
#line 3208
            if (*ptr___0) {
#line 3208
              if (errsfound + 1 >= (int )*ptr___0) {
#line 3209
                ret___0 = 0;
              }
            }
#line 3210
            *ptr___0 = (unsigned char )(errsfound + 1);
          } else {
#line 3212
            opnd = scan + 1;
          }
#line 3213
          if (ret___0) {
            {
#line 3214
            ret___0 = patmatch(opnd);
            }
          }
#line 3215
          if (pfree) {
            {
#line 3216
            zfree((void *)((char *)ptrp->p), (int )((pattrystate.patinend - pattrystate.patinstart) + 1L));
#line 3218
            ptrp->p = (unsigned char *)((void *)0);
            }
          }
#line 3220
          if (ret___0) {
#line 3221
            return (1);
          }
#line 3222
          rn_offs = scan->l >> 8;
#line 3222
          if (rn_offs) {
#line 3222
            if ((scan->l & 255L) == 3L) {
#line 3222
              tmp___30 = scan - rn_offs;
            } else {
#line 3222
              tmp___30 = scan + rn_offs;
            }
#line 3222
            scan = tmp___30;
          } else {
#line 3222
            scan = (Upat )((void *)0);
          }
        }
#line 3224
        pattrystate.patinput = save;
#line 3225
        patglobflags = savglobflags;
#line 3226
        errsfound = saverrsfound;
#line 3229
        rn_offs = scan->l >> 8;
#line 3229
        if (rn_offs) {
#line 3229
          if ((scan->l & 255L) == 3L) {
#line 3229
            tmp___31 = scan - rn_offs;
          } else {
#line 3229
            tmp___31 = scan + rn_offs;
          }
#line 3229
          next___0 = tmp___31;
        } else {
#line 3229
          next___0 = (Upat )((void *)0);
        }
#line 3014
        if (scan) {
#line 3014
          if (! (scan->l & 32L)) {
#line 3014
            goto while_break___10;
          }
        } else {
#line 3014
          goto while_break___10;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 3231
      return (0);
    }
#line 3233
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 3236
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 3236
      if (! ((next___0->l & 255L) == 67L)) {
#line 3236
        goto while_break___15;
      }
#line 3242
      scan = next___0;
#line 3243
      rn_offs = scan->l >> 8;
#line 3243
      if (rn_offs) {
#line 3243
        if ((scan->l & 255L) == 3L) {
#line 3243
          tmp___32 = scan - rn_offs;
        } else {
#line 3243
          tmp___32 = scan + rn_offs;
        }
#line 3243
        next___0 = tmp___32;
      } else {
#line 3243
        next___0 = (Upat )((void *)0);
      }
    }
    while_break___15: /* CIL Label */ ;
    }
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    {
#line 3254
    op___0 = (int )(scan->l & 255L);
#line 3256
    start = pattrystate.patinput;
#line 3263
    tmp___33 = zhalloc(sizeof(char ) * (unsigned long )(pattrystate.patinend - pattrystate.patinput));
#line 3263
    charstart = (char *)tmp___33;
#line 3264
    memset((void *)charstart, 0, (size_t )(pattrystate.patinend - pattrystate.patinput));
    }
#line 3266
    if (op___0 == 67) {
#line 3267
      no = 0;
      {
#line 3267
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 3267
        if (! ((unsigned long )pattrystate.patinput < (unsigned long )pattrystate.patinend)) {
#line 3267
          goto while_break___16;
        }
        {
#line 3270
        *(charstart + (pattrystate.patinput - start)) = (char)1;
#line 3271
        no ++;
#line 3267
        pattrystate.patinput = charnext(pattrystate.patinput, pattrystate.patinend);
        }
      }
      while_break___16: /* CIL Label */ ;
      }
#line 3274
      if ((next___0->l & 255L) == 0L) {
#line 3275
        return (1);
      }
    } else {
#line 3279
      if (! pattrystate.globdots) {
#line 3279
        if ((scan + 1)->l & 64L) {
#line 3279
          if ((unsigned long )pattrystate.patinput == (unsigned long )pattrystate.patinstart) {
#line 3279
            if ((unsigned long )pattrystate.patinput < (unsigned long )pattrystate.patinend) {
              {
#line 3279
              tmp___34 = charref(pattrystate.patinput, pattrystate.patinend, (int *)((void *)0));
              }
#line 3279
              if (tmp___34 == 46) {
#line 3282
                return (0);
              }
            }
          }
        }
      }
      {
#line 3283
      no = patrepeat(scan + 1, charstart);
      }
    }
#line 3285
    if (op___0 == 7) {
#line 3285
      min = 1;
    } else {
#line 3285
      min = 0;
    }
#line 3290
    if ((next___0->l & 255L) == 4L) {
#line 3290
      if ((next___0 + 1)->l) {
#line 3290
        if (! (patglobflags & 255)) {
#line 3292
          nextop = (char *)(next___0 + 2);
#line 3295
          nextlen = (int )(next___0 + 1)->l;
#line 3302
          rn_offs = next___0->l >> 8;
#line 3302
          if (rn_offs) {
#line 3302
            if ((next___0->l & 255L) == 3L) {
#line 3302
              tmp___37 = next___0 - rn_offs;
            } else {
#line 3302
              tmp___37 = next___0 + rn_offs;
            }
#line 3302
            tmp___38 = tmp___37;
          } else {
#line 3302
            tmp___38 = (Upat )((void *)0);
          }
#line 3302
          if ((tmp___38->l & 255L) == 0L) {
#line 3302
            if (! (patflags & 8)) {
#line 3304
              ptlen = (int )(pattrystate.patinend - pattrystate.patinput);
#line 3305
              if (min) {
                {
#line 3305
                tmp___35 = charnext(start, pattrystate.patinend);
#line 3305
                tmp___36 = tmp___35;
                }
              } else {
#line 3305
                tmp___36 = start;
              }
#line 3305
              lenmatch = (int )(pattrystate.patinend - tmp___36);
#line 3308
              if ((next___0 + 1)->l > (long )lenmatch) {
#line 3310
                return (0);
              } else
#line 3308
              if ((next___0 + 1)->l < (long )ptlen) {
#line 3310
                return (0);
              }
#line 3312
              pattrystate.patinput += (long )ptlen - (next___0 + 1)->l;
#line 3318
              goto switch_break;
            }
          }
          {
#line 3320
          tmp___39 = charref(nextop, nextop + nextlen, (int *)((void *)0));
#line 3320
          nextch = (patint_t )tmp___39;
          }
        } else {
#line 3322
          nextch = 4294967295U;
        }
      } else {
#line 3322
        nextch = 4294967295U;
      }
    } else {
#line 3322
      nextch = 4294967295U;
    }
#line 3323
    savglobflags = patglobflags;
#line 3324
    saverrsfound = errsfound;
#line 3325
    lastcharstart = charstart + (pattrystate.patinput - start);
#line 3326
    if (no >= min) {
      {
#line 3327
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 3329
        if (nextch == 4294967295U) {
#line 3329
          goto _L___4;
        } else
#line 3329
        if ((unsigned long )pattrystate.patinput < (unsigned long )pattrystate.patinend) {
          {
#line 3329
          tmp___41 = charref(pattrystate.patinput, pattrystate.patinend, (int *)((void *)0));
#line 3329
          charmatch_cache = (patint_t )tmp___41;
          }
#line 3329
          if (charmatch_cache == nextch) {
#line 3329
            tmp___55 = 1;
          } else {
#line 3329
            if (patglobflags & 512) {
              {
#line 3329
              tmp___45 = iswupper(charmatch_cache);
              }
#line 3329
              if (tmp___45) {
                {
#line 3329
                tmp___43 = towlower(charmatch_cache);
#line 3329
                tmp___44 = tmp___43;
                }
              } else {
#line 3329
                tmp___44 = charmatch_cache;
              }
              {
#line 3329
              tmp___49 = iswupper(nextch);
              }
#line 3329
              if (tmp___49) {
                {
#line 3329
                tmp___47 = towlower(nextch);
#line 3329
                tmp___48 = tmp___47;
                }
              } else {
#line 3329
                tmp___48 = nextch;
              }
#line 3329
              tmp___54 = tmp___44 == tmp___48;
            } else {
#line 3329
              if (patglobflags & 256) {
                {
#line 3329
                tmp___50 = iswlower(nextch);
                }
#line 3329
                if (tmp___50) {
                  {
#line 3329
                  tmp___51 = towupper(nextch);
                  }
#line 3329
                  if (tmp___51 == charmatch_cache) {
#line 3329
                    tmp___52 = 1;
                  } else {
#line 3329
                    tmp___52 = 0;
                  }
                } else {
#line 3329
                  tmp___52 = 0;
                }
#line 3329
                tmp___53 = tmp___52;
              } else {
#line 3329
                tmp___53 = 0;
              }
#line 3329
              tmp___54 = tmp___53;
            }
#line 3329
            if (tmp___54) {
#line 3329
              tmp___55 = 1;
            } else {
#line 3329
              tmp___55 = 0;
            }
          }
#line 3329
          if (tmp___55) {
            _L___4: /* CIL Label */ 
            {
#line 3333
            tmp___40 = patmatch(next___0);
            }
#line 3333
            if (tmp___40) {
#line 3334
              return (1);
            }
          }
        }
#line 3336
        no --;
#line 3336
        if (no < min) {
#line 3337
          goto while_break___17;
        }
        {
#line 3339
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 3339
          lastcharstart --;
#line 3339
          if (*lastcharstart) {
#line 3339
            goto while_break___18;
          }
        }
        while_break___18: /* CIL Label */ ;
        }
#line 3342
        pattrystate.patinput = start + (lastcharstart - charstart);
#line 3343
        patglobflags = savglobflags;
#line 3344
        errsfound = saverrsfound;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
#line 3353
    return (0);
    case_9: /* CIL Label */ 
#line 3355
    if ((unsigned long )pattrystate.patinput != (unsigned long )pattrystate.patinstart) {
#line 3356
      fail = 1;
    } else
#line 3355
    if (patflags & 512) {
#line 3356
      fail = 1;
    }
#line 3357
    goto switch_break;
    case_10: /* CIL Label */ 
#line 3359
    if ((unsigned long )pattrystate.patinput < (unsigned long )pattrystate.patinend) {
#line 3360
      fail = 1;
    } else
#line 3359
    if (patflags & 1024) {
#line 3360
      fail = 1;
    }
#line 3361
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 3370
    curptr = & ((scan + 1) + 1)->l;
#line 3371
    savecount = *curptr;
#line 3372
    saveptr = (scan + 4)->p;
#line 3375
    *curptr = 0L;
#line 3376
    ret___1 = patmatch(scan + 1);
#line 3377
    *curptr = savecount;
#line 3378
    (scan + 4)->p = saveptr;
    }
#line 3379
    return (ret___1);
    case_12: /* CIL Label */ 
#line 3384
    cur = (scan + 1)->l;
#line 3385
    min___0 = (scan + 2)->l;
#line 3386
    max = (scan + 3)->l;
#line 3388
    if (cur) {
#line 3388
      if (cur >= min___0) {
#line 3388
        if ((unsigned long )((unsigned char *)pattrystate.patinput) == (unsigned long )(scan + 4)->p) {
          {
#line 3397
          tmp___56 = patmatch(next___0);
          }
#line 3397
          return (tmp___56);
        }
      }
    }
#line 3399
    (scan + 4)->p = (unsigned char *)pattrystate.patinput;
#line 3401
    if (max < 0L) {
#line 3401
      goto _L___5;
    } else
#line 3401
    if (cur < max) {
      _L___5: /* CIL Label */ 
      {
#line 3402
      patinput_thistime = pattrystate.patinput;
#line 3403
      (scan + 1)->l = cur + 1L;
#line 3404
      tmp___57 = patmatch(scan + 5);
      }
#line 3404
      if (tmp___57) {
#line 3405
        return (1);
      }
#line 3406
      (scan + 1)->l = cur;
#line 3407
      pattrystate.patinput = patinput_thistime;
    }
#line 3409
    if (cur < min___0) {
#line 3410
      return (0);
    }
    {
#line 3411
    tmp___58 = patmatch(next___0);
    }
#line 3411
    return (tmp___58);
    case_0: /* CIL Label */ 
#line 3414
    if ((unsigned long )pattrystate.patinput < (unsigned long )pattrystate.patinend) {
#line 3414
      if (! (patflags & 8)) {
#line 3414
        tmp___59 = 1;
      } else {
#line 3414
        tmp___59 = 0;
      }
    } else {
#line 3414
      tmp___59 = 0;
    }
#line 3414
    fail = tmp___59;
#line 3414
    if (! fail) {
#line 3415
      return (1);
    }
#line 3416
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3425
    if (fail) {
#line 3426
      if (errsfound < (patglobflags & 255)) {
#line 3426
        if (forceerrs == -1) {
#line 3426
          goto _L___8;
        } else
#line 3426
        if (errsfound < forceerrs) {
          _L___8: /* CIL Label */ 
#line 3447
          savexact = exactpos;
#line 3448
          save = pattrystate.patinput;
#line 3449
          savglobflags = patglobflags;
#line 3450
          errsfound ++;
#line 3450
          saverrsfound = errsfound;
#line 3451
          fail = 0;
#line 3457
          if ((unsigned long )pattrystate.patinput < (unsigned long )pattrystate.patinend) {
            {
#line 3458
            pattrystate.patinput = charnext(pattrystate.patinput, pattrystate.patinend);
            }
#line 3463
            if ((scan->l & 255L) != 4L) {
#line 3464
              goto while_continue___3;
            }
            {
#line 3465
            tmp___60 = patmatch(scan);
            }
#line 3465
            if (tmp___60) {
#line 3466
              return (1);
            }
          }
#line 3469
          if ((scan->l & 255L) == 4L) {
            {
#line 3470
            nextexact = savexact;
#line 3473
            nextexact = charnext(nextexact, exactend);
            }
#line 3475
            if ((unsigned long )save < (unsigned long )pattrystate.patinend) {
              {
#line 3476
              nextin = save;
#line 3477
              nextin = charnext(nextin, pattrystate.patinend);
#line 3478
              patglobflags = savglobflags;
#line 3479
              errsfound = saverrsfound;
#line 3480
              exactpos = savexact;
              }
#line 3486
              if ((unsigned long )save < (unsigned long )pattrystate.patinend) {
#line 3486
                if ((unsigned long )nextin < (unsigned long )pattrystate.patinend) {
#line 3486
                  if ((unsigned long )nextexact < (unsigned long )exactend) {
                    {
#line 3488
                    tmp___61 = charref(save, pattrystate.patinend, (int *)((void *)0));
#line 3488
                    cin0 = (patint_t )tmp___61;
#line 3489
                    tmp___62 = charref(exactpos, exactend, (int *)((void *)0));
#line 3489
                    cpa0 = (patint_t )tmp___62;
#line 3490
                    tmp___63 = charref(nextin, pattrystate.patinend, (int *)((void *)0));
#line 3490
                    cin1 = (patint_t )tmp___63;
#line 3491
                    tmp___64 = charref(nextexact, exactend, (int *)((void *)0));
#line 3491
                    cpa1 = (patint_t )tmp___64;
                    }
#line 3493
                    if (cin0 == cpa1) {
#line 3493
                      goto _L___7;
                    } else {
#line 3493
                      if (patglobflags & 512) {
                        {
#line 3493
                        tmp___69 = iswupper(cin0);
                        }
#line 3493
                        if (tmp___69) {
                          {
#line 3493
                          tmp___67 = towlower(cin0);
#line 3493
                          tmp___68 = tmp___67;
                          }
                        } else {
#line 3493
                          tmp___68 = cin0;
                        }
                        {
#line 3493
                        tmp___73 = iswupper(cpa1);
                        }
#line 3493
                        if (tmp___73) {
                          {
#line 3493
                          tmp___71 = towlower(cpa1);
#line 3493
                          tmp___72 = tmp___71;
                          }
                        } else {
#line 3493
                          tmp___72 = cpa1;
                        }
#line 3493
                        tmp___78 = tmp___68 == tmp___72;
                      } else {
#line 3493
                        if (patglobflags & 256) {
                          {
#line 3493
                          tmp___74 = iswlower(cpa1);
                          }
#line 3493
                          if (tmp___74) {
                            {
#line 3493
                            tmp___75 = towupper(cpa1);
                            }
#line 3493
                            if (tmp___75 == cin0) {
#line 3493
                              tmp___76 = 1;
                            } else {
#line 3493
                              tmp___76 = 0;
                            }
                          } else {
#line 3493
                            tmp___76 = 0;
                          }
#line 3493
                          tmp___77 = tmp___76;
                        } else {
#line 3493
                          tmp___77 = 0;
                        }
#line 3493
                        tmp___78 = tmp___77;
                      }
#line 3493
                      if (tmp___78) {
                        _L___7: /* CIL Label */ 
#line 3493
                        if (cin1 == cpa0) {
#line 3493
                          goto _L___6;
                        } else {
#line 3493
                          if (patglobflags & 512) {
                            {
#line 3493
                            tmp___82 = iswupper(cin1);
                            }
#line 3493
                            if (tmp___82) {
                              {
#line 3493
                              tmp___80 = towlower(cin1);
#line 3493
                              tmp___81 = tmp___80;
                              }
                            } else {
#line 3493
                              tmp___81 = cin1;
                            }
                            {
#line 3493
                            tmp___86 = iswupper(cpa0);
                            }
#line 3493
                            if (tmp___86) {
                              {
#line 3493
                              tmp___84 = towlower(cpa0);
#line 3493
                              tmp___85 = tmp___84;
                              }
                            } else {
#line 3493
                              tmp___85 = cpa0;
                            }
#line 3493
                            tmp___91 = tmp___81 == tmp___85;
                          } else {
#line 3493
                            if (patglobflags & 256) {
                              {
#line 3493
                              tmp___87 = iswlower(cpa0);
                              }
#line 3493
                              if (tmp___87) {
                                {
#line 3493
                                tmp___88 = towupper(cpa0);
                                }
#line 3493
                                if (tmp___88 == cin1) {
#line 3493
                                  tmp___89 = 1;
                                } else {
#line 3493
                                  tmp___89 = 0;
                                }
                              } else {
#line 3493
                                tmp___89 = 0;
                              }
#line 3493
                              tmp___90 = tmp___89;
                            } else {
#line 3493
                              tmp___90 = 0;
                            }
#line 3493
                            tmp___91 = tmp___90;
                          }
#line 3493
                          if (tmp___91) {
                            _L___6: /* CIL Label */ 
                            {
#line 3495
                            pattrystate.patinput = nextin;
#line 3496
                            pattrystate.patinput = charnext(pattrystate.patinput,
                                                            pattrystate.patinend);
#line 3497
                            exactpos = nextexact;
#line 3498
                            exactpos = charnext(exactpos, exactend);
#line 3499
                            tmp___65 = patmatch(scan);
                            }
#line 3499
                            if (tmp___65) {
#line 3500
                              return (1);
                            }
#line 3502
                            patglobflags = savglobflags;
#line 3503
                            errsfound = saverrsfound;
                          }
                        }
                      }
                    }
                  }
                }
              }
              {
#line 3510
              pattrystate.patinput = nextin;
#line 3511
              exactpos = nextexact;
#line 3512
              tmp___92 = patmatch(scan);
              }
#line 3512
              if (tmp___92) {
#line 3513
                return (1);
              }
#line 3515
              pattrystate.patinput = save;
#line 3516
              patglobflags = savglobflags;
#line 3517
              errsfound = saverrsfound;
#line 3518
              exactpos = savexact;
            }
            {
#line 3527
            exactpos = charnext(exactpos, exactend);
            }
#line 3528
            goto while_continue___3;
          }
        }
      }
#line 3531
      exactpos = (char *)((void *)0);
#line 3532
      return (0);
    }
#line 3535
    scan = next___0;
    {
#line 3538
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 3538
      if (queue_front != queue_rear) {
#line 3538
        savpatflags___1 = patflags;
#line 3538
        savpatglobflags___0 = patglobflags;
#line 3538
        savexactpos___0 = exactpos;
#line 3538
        savexactend___0 = exactend;
#line 3538
        savpattrystate___0 = pattrystate;
        {
#line 3538
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 3538
          queueing_enabled = 0;
          {
#line 3538
          while (1) {
            while_continue___21: /* CIL Label */ ;
            {
#line 3538
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 3538
              if (! (queue_front != queue_rear)) {
#line 3538
                goto while_break___22;
              }
              {
#line 3538
              queue_front = (queue_front + 1) % 128;
#line 3538
              oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 3538
              zhandler(signal_queue[queue_front]);
#line 3538
              signal_setmask(oset___0);
              }
            }
            while_break___22: /* CIL Label */ ;
            }
#line 3538
            goto while_break___21;
          }
          while_break___21: /* CIL Label */ ;
          }
#line 3538
          goto while_break___20;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 3538
        queueing_enabled = q;
#line 3538
        exactpos = savexactpos___0;
#line 3538
        exactend = savexactend___0;
#line 3538
        patflags = savpatflags___1;
#line 3538
        patglobflags = savpatglobflags___0;
#line 3538
        pattrystate = savpattrystate___0;
      }
#line 3538
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3541
  return (0);
}
}
#line 3571 "/tmp/zsh-5.4.2/Src/pattern.c"
int mb_patmatchrange(char *range , wchar_t ch , int zmb_ind , wint_t *indptr , int *mtp ) 
{ 
  wchar_t r1 ;
  wchar_t r2 ;
  int swtype ;
  char *tmp ;
  wchar_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  wchar_t tmp___15 ;

  {
#line 3576
  if (indptr) {
#line 3577
    *indptr = (wint_t )0;
  }
  {
#line 3583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3583
    if (! *range) {
#line 3583
      goto while_break;
    }
#line 3584
    if ((int )typtab[(unsigned char )*range] & (1 << 12)) {
#line 3585
      tmp = range;
#line 3585
      range ++;
#line 3585
      swtype = (int )((unsigned char )*tmp) - 131;
#line 3586
      if (mtp) {
#line 3587
        *mtp = swtype;
      }
      {
#line 3589
      if (swtype == 0) {
#line 3589
        goto case_0;
      }
#line 3595
      if (swtype == 1) {
#line 3595
        goto case_1;
      }
#line 3599
      if (swtype == 2) {
#line 3599
        goto case_2;
      }
#line 3603
      if (swtype == 3) {
#line 3603
        goto case_3;
      }
#line 3607
      if (swtype == 4) {
#line 3607
        goto case_4;
      }
#line 3611
      if (swtype == 5) {
#line 3611
        goto case_5;
      }
#line 3615
      if (swtype == 6) {
#line 3615
        goto case_6;
      }
#line 3619
      if (swtype == 7) {
#line 3619
        goto case_7;
      }
#line 3623
      if (swtype == 8) {
#line 3623
        goto case_8;
      }
#line 3627
      if (swtype == 9) {
#line 3627
        goto case_9;
      }
#line 3631
      if (swtype == 10) {
#line 3631
        goto case_10;
      }
#line 3635
      if (swtype == 11) {
#line 3635
        goto case_11;
      }
#line 3639
      if (swtype == 12) {
#line 3639
        goto case_12;
      }
#line 3643
      if (swtype == 13) {
#line 3643
        goto case_13;
      }
#line 3647
      if (swtype == 14) {
#line 3647
        goto case_14;
      }
#line 3651
      if (swtype == 15) {
#line 3651
        goto case_15;
      }
#line 3655
      if (swtype == 16) {
#line 3655
        goto case_16;
      }
#line 3660
      if (swtype == 17) {
#line 3660
        goto case_17;
      }
#line 3664
      if (swtype == 21) {
#line 3664
        goto case_21;
      }
#line 3681
      if (swtype == 18) {
#line 3681
        goto case_18;
      }
#line 3685
      if (swtype == 19) {
#line 3685
        goto case_19;
      }
#line 3689
      if (swtype == 20) {
#line 3689
        goto case_20;
      }
#line 3692
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 3591
      range --;
#line 3592
      tmp___0 = metacharinc(& range);
      }
#line 3592
      if (tmp___0 == ch) {
#line 3593
        return (1);
      }
#line 3594
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 3596
      tmp___1 = iswalpha((wint_t )ch);
      }
#line 3596
      if (tmp___1) {
#line 3597
        return (1);
      }
#line 3598
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 3600
      tmp___2 = iswalnum((wint_t )ch);
      }
#line 3600
      if (tmp___2) {
#line 3601
        return (1);
      }
#line 3602
      goto switch_break;
      case_3: /* CIL Label */ 
#line 3604
      if ((ch & -128) == 0) {
#line 3605
        return (1);
      }
#line 3606
      goto switch_break;
      case_4: /* CIL Label */ 
#line 3608
      if (ch == 32) {
#line 3609
        return (1);
      } else
#line 3608
      if (ch == 9) {
#line 3609
        return (1);
      }
#line 3610
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 3612
      tmp___3 = iswcntrl((wint_t )ch);
      }
#line 3612
      if (tmp___3) {
#line 3613
        return (1);
      }
#line 3614
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 3616
      tmp___4 = iswdigit((wint_t )ch);
      }
#line 3616
      if (tmp___4) {
#line 3617
        return (1);
      }
#line 3618
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 3620
      tmp___5 = iswgraph((wint_t )ch);
      }
#line 3620
      if (tmp___5) {
#line 3621
        return (1);
      }
#line 3622
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 3624
      tmp___6 = iswlower((wint_t )ch);
      }
#line 3624
      if (tmp___6) {
#line 3625
        return (1);
      }
#line 3626
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 3628
      tmp___7 = iswprint((wint_t )ch);
      }
#line 3628
      if (tmp___7) {
#line 3629
        return (1);
      }
#line 3630
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 3632
      tmp___8 = iswpunct((wint_t )ch);
      }
#line 3632
      if (tmp___8) {
#line 3633
        return (1);
      }
#line 3634
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 3636
      tmp___9 = iswspace((wint_t )ch);
      }
#line 3636
      if (tmp___9) {
#line 3637
        return (1);
      }
#line 3638
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 3640
      tmp___10 = iswupper((wint_t )ch);
      }
#line 3640
      if (tmp___10) {
#line 3641
        return (1);
      }
#line 3642
      goto switch_break;
      case_13: /* CIL Label */ 
      {
#line 3644
      tmp___11 = iswxdigit((wint_t )ch);
      }
#line 3644
      if (tmp___11) {
#line 3645
        return (1);
      }
#line 3646
      goto switch_break;
      case_14: /* CIL Label */ 
      {
#line 3648
      tmp___12 = wcsitype(ch, 1 << 7);
      }
#line 3648
      if (tmp___12) {
#line 3649
        return (1);
      }
#line 3650
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 3652
      tmp___13 = wcsitype(ch, 1 << 5);
      }
#line 3652
      if (tmp___13) {
#line 3653
        return (1);
      }
#line 3654
      goto switch_break;
      case_16: /* CIL Label */ 
#line 3657
      if (ch < 128) {
#line 3657
        if ((int )typtab[(unsigned char )ch] & (1 << 13)) {
#line 3658
          return (1);
        }
      }
#line 3659
      goto switch_break;
      case_17: /* CIL Label */ 
      {
#line 3661
      tmp___14 = wcsitype(ch, 1 << 10);
      }
#line 3661
      if (tmp___14) {
#line 3662
        return (1);
      }
#line 3663
      goto switch_break;
      case_21: /* CIL Label */ 
      {
#line 3665
      r1 = metacharinc(& range);
#line 3666
      r2 = metacharinc(& range);
      }
#line 3667
      if (r1 <= ch) {
#line 3667
        if (ch <= r2) {
#line 3668
          if (indptr) {
#line 3669
            *indptr += (wint_t )(ch - r1);
          }
#line 3670
          return (1);
        }
      }
#line 3673
      if (indptr) {
#line 3673
        if (r1 < r2) {
#line 3678
          *indptr += (wint_t )(r2 - r1);
        }
      }
#line 3680
      goto switch_break;
      case_18: /* CIL Label */ 
#line 3682
      if (zmb_ind == 1) {
#line 3683
        return (1);
      }
#line 3684
      goto switch_break;
      case_19: /* CIL Label */ 
#line 3686
      if (zmb_ind == 2) {
#line 3687
        return (1);
      }
#line 3688
      goto switch_break;
      case_20: /* CIL Label */ ;
#line 3691
      goto switch_break;
      switch_default: /* CIL Label */ ;
#line 3694
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 3696
      tmp___15 = metacharinc(& range);
      }
#line 3696
      if (tmp___15 == ch) {
#line 3697
        if (mtp) {
#line 3698
          *mtp = 0;
        }
#line 3699
        return (1);
      }
    }
#line 3701
    if (indptr) {
#line 3702
      (*indptr) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3704
  return (0);
}
}
#line 3719 "/tmp/zsh-5.4.2/Src/pattern.c"
int mb_patmatchindex(char *range , wint_t ind , wint_t *chr , int *mtp ) 
{ 
  wchar_t r1 ;
  wchar_t r2 ;
  wchar_t rchr ;
  wint_t rdiff ;
  int swtype ;
  char *tmp ;
  wint_t tmp___0 ;

  {
#line 3725
  *chr = 4294967295U;
#line 3726
  *mtp = 0;
  {
#line 3728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3728
    if (! *range) {
#line 3728
      goto while_break;
    }
#line 3729
    if ((int )typtab[(unsigned char )*range] & (1 << 12)) {
#line 3730
      tmp = range;
#line 3730
      range ++;
#line 3730
      swtype = (int )((unsigned char )*tmp) - 131;
      {
#line 3732
      if (swtype == 0) {
#line 3732
        goto case_0;
      }
#line 3759
      if (swtype == 19) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 18) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 17) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 16) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 15) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 14) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 13) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 12) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 11) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 10) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 9) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 8) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 7) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 6) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 5) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 4) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 3) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 2) {
#line 3759
        goto case_19;
      }
#line 3759
      if (swtype == 1) {
#line 3759
        goto case_19;
      }
#line 3766
      if (swtype == 21) {
#line 3766
        goto case_21;
      }
#line 3777
      if (swtype == 20) {
#line 3777
        goto case_20;
      }
#line 3780
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 3733
      range --;
#line 3734
      rchr = metacharinc(& range);
      }
#line 3735
      if (! ind) {
#line 3736
        *chr = (wint_t )rchr;
#line 3737
        return (1);
      }
#line 3739
      goto switch_break;
      case_19: /* CIL Label */ 
      case_18: /* CIL Label */ 
      case_17: /* CIL Label */ 
      case_16: /* CIL Label */ 
      case_15: /* CIL Label */ 
      case_14: /* CIL Label */ 
      case_13: /* CIL Label */ 
      case_12: /* CIL Label */ 
      case_11: /* CIL Label */ 
      case_10: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_8: /* CIL Label */ 
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 3760
      if (! ind) {
#line 3761
        *mtp = swtype;
#line 3762
        return (1);
      }
#line 3764
      goto switch_break;
      case_21: /* CIL Label */ 
      {
#line 3767
      r1 = metacharinc(& range);
#line 3768
      r2 = metacharinc(& range);
#line 3769
      rdiff = (wint_t )r2 - (wint_t )r1;
      }
#line 3770
      if (rdiff >= ind) {
#line 3771
        *chr = (wint_t )r1 + ind;
#line 3772
        return (1);
      }
#line 3775
      ind -= rdiff;
#line 3776
      goto switch_break;
      case_20: /* CIL Label */ ;
#line 3779
      goto switch_break;
      switch_default: /* CIL Label */ ;
#line 3782
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 3785
      rchr = metacharinc(& range);
      }
#line 3786
      if (! ind) {
#line 3787
        *chr = (wint_t )rchr;
#line 3788
        return (1);
      }
    }
#line 3791
    tmp___0 = ind;
#line 3791
    ind --;
#line 3791
    if (! tmp___0) {
#line 3792
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3796
  return (0);
}
}
#line 3808 "/tmp/zsh-5.4.2/Src/pattern.c"
int patmatchrange(char *range , int ch , int *indptr , int *mtp ) 
{ 
  int r1 ;
  int r2 ;
  int swtype ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 3813
  if (indptr) {
#line 3814
    *indptr = 0;
  }
  {
#line 3820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3820
    if (! *range) {
#line 3820
      goto while_break;
    }
#line 3821
    if ((int )typtab[(unsigned char )*range] & (1 << 12)) {
#line 3822
      swtype = (int )((unsigned char )*range) - 131;
#line 3823
      if (mtp) {
#line 3824
        *mtp = swtype;
      }
      {
#line 3826
      if (swtype == 0) {
#line 3826
        goto case_0;
      }
#line 3830
      if (swtype == 1) {
#line 3830
        goto case_1;
      }
#line 3834
      if (swtype == 2) {
#line 3834
        goto case_2;
      }
#line 3838
      if (swtype == 3) {
#line 3838
        goto case_3;
      }
#line 3842
      if (swtype == 4) {
#line 3842
        goto case_4;
      }
#line 3846
      if (swtype == 5) {
#line 3846
        goto case_5;
      }
#line 3850
      if (swtype == 6) {
#line 3850
        goto case_6;
      }
#line 3854
      if (swtype == 7) {
#line 3854
        goto case_7;
      }
#line 3858
      if (swtype == 8) {
#line 3858
        goto case_8;
      }
#line 3862
      if (swtype == 9) {
#line 3862
        goto case_9;
      }
#line 3866
      if (swtype == 10) {
#line 3866
        goto case_10;
      }
#line 3870
      if (swtype == 11) {
#line 3870
        goto case_11;
      }
#line 3874
      if (swtype == 12) {
#line 3874
        goto case_12;
      }
#line 3878
      if (swtype == 13) {
#line 3878
        goto case_13;
      }
#line 3882
      if (swtype == 14) {
#line 3882
        goto case_14;
      }
#line 3886
      if (swtype == 15) {
#line 3886
        goto case_15;
      }
#line 3890
      if (swtype == 16) {
#line 3890
        goto case_16;
      }
#line 3894
      if (swtype == 17) {
#line 3894
        goto case_17;
      }
#line 3898
      if (swtype == 21) {
#line 3898
        goto case_21;
      }
#line 3914
      if (swtype == 19) {
#line 3914
        goto case_19;
      }
#line 3914
      if (swtype == 18) {
#line 3914
        goto case_19;
      }
#line 3917
      if (swtype == 20) {
#line 3917
        goto case_20;
      }
#line 3920
      goto switch_default;
      case_0: /* CIL Label */ 
#line 3827
      range ++;
#line 3827
      if ((int )((unsigned char )((int )*range ^ 32)) == ch) {
#line 3828
        return (1);
      }
#line 3829
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 3831
      tmp = __ctype_b_loc();
      }
#line 3831
      if ((int const   )*(*tmp + ch) & 1024) {
#line 3832
        return (1);
      }
#line 3833
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 3835
      tmp___0 = __ctype_b_loc();
      }
#line 3835
      if ((int const   )*(*tmp___0 + ch) & 8) {
#line 3836
        return (1);
      }
#line 3837
      goto switch_break;
      case_3: /* CIL Label */ 
#line 3839
      if ((ch & -128) == 0) {
#line 3840
        return (1);
      }
#line 3841
      goto switch_break;
      case_4: /* CIL Label */ 
#line 3843
      if (ch == 32) {
#line 3844
        return (1);
      } else
#line 3843
      if (ch == 9) {
#line 3844
        return (1);
      }
#line 3845
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 3847
      tmp___1 = __ctype_b_loc();
      }
#line 3847
      if ((int const   )*(*tmp___1 + ch) & 2) {
#line 3848
        return (1);
      }
#line 3849
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 3851
      tmp___2 = __ctype_b_loc();
      }
#line 3851
      if ((int const   )*(*tmp___2 + ch) & 2048) {
#line 3852
        return (1);
      }
#line 3853
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 3855
      tmp___3 = __ctype_b_loc();
      }
#line 3855
      if ((int const   )*(*tmp___3 + ch) & 32768) {
#line 3856
        return (1);
      }
#line 3857
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 3859
      tmp___4 = __ctype_b_loc();
      }
#line 3859
      if ((int const   )*(*tmp___4 + ch) & 512) {
#line 3860
        return (1);
      }
#line 3861
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 3863
      tmp___5 = __ctype_b_loc();
      }
#line 3863
      if ((int const   )*(*tmp___5 + ch) & 16384) {
#line 3864
        return (1);
      }
#line 3865
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 3867
      tmp___6 = __ctype_b_loc();
      }
#line 3867
      if ((int const   )*(*tmp___6 + ch) & 4) {
#line 3868
        return (1);
      }
#line 3869
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 3871
      tmp___7 = __ctype_b_loc();
      }
#line 3871
      if ((int const   )*(*tmp___7 + ch) & 8192) {
#line 3872
        return (1);
      }
#line 3873
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 3875
      tmp___8 = __ctype_b_loc();
      }
#line 3875
      if ((int const   )*(*tmp___8 + ch) & 256) {
#line 3876
        return (1);
      }
#line 3877
      goto switch_break;
      case_13: /* CIL Label */ 
      {
#line 3879
      tmp___9 = __ctype_b_loc();
      }
#line 3879
      if ((int const   )*(*tmp___9 + ch) & 4096) {
#line 3880
        return (1);
      }
#line 3881
      goto switch_break;
      case_14: /* CIL Label */ 
#line 3883
      if ((int )typtab[(unsigned char )ch] & (1 << 7)) {
#line 3884
        return (1);
      }
#line 3885
      goto switch_break;
      case_15: /* CIL Label */ 
#line 3887
      if ((int )typtab[(unsigned char )ch] & (1 << 5)) {
#line 3888
        return (1);
      }
#line 3889
      goto switch_break;
      case_16: /* CIL Label */ 
#line 3891
      if ((int )typtab[(unsigned char )ch] & (1 << 13)) {
#line 3892
        return (1);
      }
#line 3893
      goto switch_break;
      case_17: /* CIL Label */ 
#line 3895
      if ((int )typtab[(unsigned char )ch] & (1 << 10)) {
#line 3896
        return (1);
      }
#line 3897
      goto switch_break;
      case_21: /* CIL Label */ 
#line 3899
      range ++;
#line 3900
      if ((int )*range == -125) {
#line 3900
        tmp___10 = (int )*(range + 1) ^ 32;
      } else {
#line 3900
        tmp___10 = (int )*range;
      }
      {
#line 3900
      r1 = (int )((unsigned char )tmp___10);
#line 3901
      metacharinc(& range);
      }
#line 3902
      if ((int )*range == -125) {
#line 3902
        tmp___11 = (int )*(range + 1) ^ 32;
      } else {
#line 3902
        tmp___11 = (int )*range;
      }
#line 3902
      r2 = (int )((unsigned char )tmp___11);
#line 3903
      if ((int )*range == -125) {
#line 3904
        range ++;
      }
#line 3905
      if (r1 <= ch) {
#line 3905
        if (ch <= r2) {
#line 3906
          if (indptr) {
#line 3907
            *indptr += ch - r1;
          }
#line 3908
          return (1);
        }
      }
#line 3910
      if (indptr) {
#line 3910
        if (r1 < r2) {
#line 3911
          *indptr += r2 - r1;
        }
      }
#line 3912
      goto switch_break;
      case_19: /* CIL Label */ 
      case_18: /* CIL Label */ 
#line 3916
      goto switch_break;
      case_20: /* CIL Label */ ;
#line 3919
      goto switch_break;
      switch_default: /* CIL Label */ ;
#line 3922
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 3924
    if ((int )((unsigned char )*range) == ch) {
#line 3925
      if (mtp) {
#line 3926
        *mtp = 0;
      }
#line 3927
      return (1);
    }
#line 3929
    if (indptr) {
#line 3930
      (*indptr) ++;
    }
#line 3820
    range ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3932
  return (0);
}
}
#line 4042 "/tmp/zsh-5.4.2/Src/pattern.c"
static int patrepeat(Upat p , char *charstart ) 
{ 
  int count ;
  patint_t tch ;
  patint_t charmatch_cache ;
  char *scan ;
  char *opnd ;
  wchar_t tmp ;
  wchar_t tmp___0 ;
  wint_t tmp___2 ;
  wint_t tmp___3 ;
  int tmp___4 ;
  wint_t tmp___6 ;
  wint_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  wint_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int zmb_ind ;
  wchar_t cr ;
  wchar_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 4044
  count = 0;
#line 4048
  scan = pattrystate.patinput;
#line 4049
  opnd = (char *)(p + 1);
  {
#line 4058
  if ((p->l & 255L) == 4L) {
#line 4058
    goto case_4;
  }
#line 4069
  if ((p->l & 255L) == 66L) {
#line 4069
    goto case_66;
  }
#line 4069
  if ((p->l & 255L) == 65L) {
#line 4069
    goto case_66;
  }
#line 4051
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 4060
  tmp = charref((char *)(p + 2), (char *)(p + 2) + (p + 1)->l, (int *)((void *)0));
#line 4060
  tch = (patint_t )tmp;
  }
  {
#line 4061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4061
    if ((unsigned long )scan < (unsigned long )pattrystate.patinend) {
      {
#line 4061
      tmp___0 = charref(scan, pattrystate.patinend, (int *)((void *)0));
#line 4061
      charmatch_cache = (patint_t )tmp___0;
      }
#line 4061
      if (charmatch_cache == tch) {
#line 4061
        tmp___14 = 1;
      } else {
#line 4061
        if (patglobflags & 512) {
          {
#line 4061
          tmp___4 = iswupper(charmatch_cache);
          }
#line 4061
          if (tmp___4) {
            {
#line 4061
            tmp___2 = towlower(charmatch_cache);
#line 4061
            tmp___3 = tmp___2;
            }
          } else {
#line 4061
            tmp___3 = charmatch_cache;
          }
          {
#line 4061
          tmp___8 = iswupper(tch);
          }
#line 4061
          if (tmp___8) {
            {
#line 4061
            tmp___6 = towlower(tch);
#line 4061
            tmp___7 = tmp___6;
            }
          } else {
#line 4061
            tmp___7 = tch;
          }
#line 4061
          tmp___13 = tmp___3 == tmp___7;
        } else {
#line 4061
          if (patglobflags & 256) {
            {
#line 4061
            tmp___9 = iswlower(tch);
            }
#line 4061
            if (tmp___9) {
              {
#line 4061
              tmp___10 = towupper(tch);
              }
#line 4061
              if (tmp___10 == charmatch_cache) {
#line 4061
                tmp___11 = 1;
              } else {
#line 4061
                tmp___11 = 0;
              }
            } else {
#line 4061
              tmp___11 = 0;
            }
#line 4061
            tmp___12 = tmp___11;
          } else {
#line 4061
            tmp___12 = 0;
          }
#line 4061
          tmp___13 = tmp___12;
        }
#line 4061
        if (tmp___13) {
#line 4061
          tmp___14 = 1;
        } else {
#line 4061
          tmp___14 = 0;
        }
      }
#line 4061
      if (! tmp___14) {
#line 4061
        goto while_break;
      }
    } else {
#line 4061
      goto while_break;
    }
    {
#line 4063
    *(charstart + (scan - pattrystate.patinput)) = (char)1;
#line 4064
    count ++;
#line 4065
    scan = charnext(scan, pattrystate.patinend);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4067
  goto switch_break;
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  {
#line 4070
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4070
    if (! ((unsigned long )scan < (unsigned long )pattrystate.patinend)) {
#line 4070
      goto while_break___0;
    }
    {
#line 4073
    tmp___15 = charref(scan, pattrystate.patinend, & zmb_ind);
#line 4073
    cr = tmp___15;
    }
#line 4074
    if (patglobflags & 4096) {
      {
#line 4075
      tmp___16 = mb_patmatchrange(opnd, cr, zmb_ind, (wint_t *)((void *)0), (int *)((void *)0));
      }
#line 4075
      if (tmp___16 ^ ((p->l & 255L) == 65L)) {
#line 4077
        goto while_break___0;
      }
    } else {
      {
#line 4078
      tmp___17 = patmatchrange(opnd, cr, (int *)((void *)0), (int *)((void *)0));
      }
#line 4078
      if (tmp___17 ^ ((p->l & 255L) == 65L)) {
#line 4080
        goto while_break___0;
      }
    }
    {
#line 4086
    *(charstart + (scan - pattrystate.patinput)) = (char)1;
#line 4087
    count ++;
#line 4088
    scan = charnext(scan, pattrystate.patinend);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4090
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4099
  pattrystate.patinput = scan;
#line 4100
  return (count);
}
}
#line 4106 "/tmp/zsh-5.4.2/Src/pattern.c"
void freepatprog(Patprog prog ) 
{ 


  {
#line 4109
  if (prog) {
#line 4109
    if ((unsigned long )prog != (unsigned long )((Patprog )1)) {
#line 4109
      if ((unsigned long )prog != (unsigned long )((Patprog )2)) {
        {
#line 4110
        zfree((void *)prog, (int )prog->size);
        }
      }
    }
  }
#line 4111
  return;
}
}
#line 4116 "/tmp/zsh-5.4.2/Src/pattern.c"
int pat_enables(char const   *cmd , char **patp , int enable ) 
{ 
  int ret ;
  char const   **stringp ;
  char *disp ;
  int done ;
  int tmp ;
  int tmp___0 ;

  {
#line 4119
  ret = 0;
#line 4123
  if (! *patp) {
#line 4124
    done = 0;
#line 4125
    stringp = zpc_strings;
#line 4125
    disp = zpc_disables;
    {
#line 4125
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4125
      if (! ((unsigned long )stringp < (unsigned long )(zpc_strings + 19))) {
#line 4125
        goto while_break;
      }
#line 4128
      if (! *stringp) {
#line 4129
        goto __Cont;
      }
#line 4130
      if (enable) {
#line 4130
        tmp = (int )*disp;
      } else {
#line 4130
        tmp = ! *disp;
      }
#line 4130
      if (tmp) {
#line 4131
        goto __Cont;
      }
#line 4132
      if (done) {
        {
#line 4133
        _IO_putc(' ', stdout);
        }
      }
      {
#line 4134
      printf((char const   */* __restrict  */)"\'%s\'", *stringp);
#line 4135
      done = 1;
      }
      __Cont: /* CIL Label */ 
#line 4125
      stringp ++;
#line 4125
      disp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 4137
    if (done) {
      {
#line 4138
      _IO_putc('\n', stdout);
      }
    }
#line 4139
    return (0);
  }
  {
#line 4142
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4142
    if (! *patp) {
#line 4142
      goto while_break___0;
    }
#line 4143
    stringp = zpc_strings;
#line 4143
    disp = zpc_disables;
    {
#line 4143
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4143
      if (! ((unsigned long )stringp < (unsigned long )(zpc_strings + 19))) {
#line 4143
        goto while_break___1;
      }
#line 4146
      if (*stringp) {
        {
#line 4146
        tmp___0 = strcmp(*stringp, (char const   *)*patp);
        }
#line 4146
        if (! tmp___0) {
#line 4147
          *disp = (char )(! enable);
#line 4148
          goto while_break___1;
        }
      }
#line 4143
      stringp ++;
#line 4143
      disp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4151
    if ((unsigned long )stringp == (unsigned long )(zpc_strings + 19)) {
      {
#line 4152
      zerrnam(cmd, "invalid pattern: %s", *patp);
#line 4153
      ret = 1;
      }
    }
#line 4142
    patp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4157
  return (ret);
}
}
#line 4165 "/tmp/zsh-5.4.2/Src/pattern.c"
unsigned int savepatterndisables(void) 
{ 
  unsigned int disables ;
  unsigned int bit ;
  char *disp ;

  {
#line 4171
  disables = 0U;
#line 4172
  bit = 1U;
#line 4172
  disp = zpc_disables;
  {
#line 4172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4172
    if (! ((unsigned long )disp < (unsigned long )(zpc_disables + 19))) {
#line 4172
      goto while_break;
    }
#line 4175
    if (*disp) {
#line 4176
      disables |= bit;
    }
#line 4172
    bit <<= 1;
#line 4172
    disp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4178
  return (disables);
}
}
#line 4186 "/tmp/zsh-5.4.2/Src/pattern.c"
void startpatternscope(void) 
{ 
  Zpc_disables_save newdis ;
  void *tmp ;

  {
  {
#line 4191
  tmp = zalloc(sizeof(*newdis));
#line 4191
  newdis = (Zpc_disables_save )tmp;
#line 4192
  newdis->next = zpc_disables_stack;
#line 4193
  newdis->disables = savepatterndisables();
#line 4195
  zpc_disables_stack = newdis;
  }
#line 4196
  return;
}
}
#line 4203 "/tmp/zsh-5.4.2/Src/pattern.c"
void restorepatterndisables(unsigned int disables ) 
{ 
  char *disp ;
  unsigned int bit ;

  {
#line 4209
  bit = 1U;
#line 4209
  disp = zpc_disables;
  {
#line 4209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4209
    if (! ((unsigned long )disp < (unsigned long )(zpc_disables + 19))) {
#line 4209
      goto while_break;
    }
#line 4212
    if (disables & bit) {
#line 4213
      *disp = (char)1;
    } else {
#line 4215
      *disp = (char)0;
    }
#line 4209
    bit <<= 1;
#line 4209
    disp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4217
  return;
}
}
#line 4224 "/tmp/zsh-5.4.2/Src/pattern.c"
void endpatternscope(void) 
{ 
  Zpc_disables_save olddis ;

  {
#line 4229
  olddis = zpc_disables_stack;
#line 4230
  zpc_disables_stack = olddis->next;
#line 4232
  if (opts[108]) {
    {
#line 4233
    restorepatterndisables(olddis->disables);
    }
  }
  {
#line 4235
  zfree((void *)olddis, (int )sizeof(*olddis));
  }
#line 4236
  return;
}
}
#line 4241 "/tmp/zsh-5.4.2/Src/pattern.c"
void clearpatterndisables(void) 
{ 


  {
  {
#line 4244
  memset((void *)(zpc_disables), 0, (size_t )19);
  }
#line 4245
  return;
}
}
#line 4251 "/tmp/zsh-5.4.2/Src/pattern.c"
int haswilds(char *str ) 
{ 
  char *start ;

  {
#line 4257
  if ((int )*str == -111) {
#line 4257
    goto _L;
  } else
#line 4257
  if ((int )*str == -110) {
    _L: /* CIL Label */ 
#line 4257
    if (! *(str + 1)) {
#line 4258
      return (0);
    }
  }
#line 4263
  if ((int )*(str + 0) == 37) {
#line 4263
    if ((int )*(str + 1) == -105) {
#line 4264
      *(str + 1) = (char )'?';
    }
  }
#line 4269
  start = str;
  {
#line 4270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4270
    if (! *str) {
#line 4270
      goto while_break;
    }
    {
#line 4272
    if ((int )*str == -120) {
#line 4272
      goto case_neg_120;
    }
#line 4284
    if ((int )*str == -114) {
#line 4284
      goto case_neg_114;
    }
#line 4289
    if ((int )*str == -121) {
#line 4289
      goto case_neg_121;
    }
#line 4294
    if ((int )*str == -111) {
#line 4294
      goto case_neg_111;
    }
#line 4299
    if ((int )*str == -108) {
#line 4299
      goto case_neg_108;
    }
#line 4304
    if ((int )*str == -105) {
#line 4304
      goto case_neg_105;
    }
#line 4309
    if ((int )*str == -124) {
#line 4309
      goto case_neg_124;
    }
#line 4314
    if ((int )*str == -122) {
#line 4314
      goto case_neg_122;
    }
#line 4271
    goto switch_break;
    case_neg_120: /* CIL Label */ 
#line 4273
    if (! opts[159]) {
#line 4273
      if (! zpc_disables[5]) {
#line 4281
        return (1);
      } else {
#line 4273
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 4273
    if ((unsigned long )str > (unsigned long )start) {
#line 4273
      if (opts[97]) {
#line 4273
        if ((int )*(str + -1) == -105) {
#line 4273
          if (! zpc_disables[13]) {
#line 4281
            return (1);
          } else {
#line 4273
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 4273
        if ((int )*(str + -1) == -121) {
#line 4273
          if (! zpc_disables[14]) {
#line 4281
            return (1);
          } else {
#line 4273
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 4273
        if ((int )*(str + -1) == 43) {
#line 4273
          if (! zpc_disables[15]) {
#line 4281
            return (1);
          } else {
#line 4273
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 4273
        if ((int )*(str + -1) == -100) {
#line 4273
          if (! zpc_disables[16]) {
#line 4281
            return (1);
          } else {
#line 4273
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 4273
        if ((int )*(str + -1) == 33) {
#line 4273
          if (! zpc_disables[17]) {
#line 4281
            return (1);
          } else {
#line 4273
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 4273
        if ((int )*(str + -1) == 64) {
#line 4273
          if (! zpc_disables[18]) {
#line 4281
            return (1);
          }
        }
      }
    }
#line 4282
    goto switch_break;
    case_neg_114: /* CIL Label */ 
#line 4285
    if (! zpc_disables[2]) {
#line 4286
      return (1);
    }
#line 4287
    goto switch_break;
    case_neg_121: /* CIL Label */ 
#line 4290
    if (! zpc_disables[7]) {
#line 4291
      return (1);
    }
#line 4292
    goto switch_break;
    case_neg_111: /* CIL Label */ 
#line 4295
    if (! zpc_disables[8]) {
#line 4296
      return (1);
    }
#line 4297
    goto switch_break;
    case_neg_108: /* CIL Label */ 
#line 4300
    if (! zpc_disables[9]) {
#line 4301
      return (1);
    }
#line 4302
    goto switch_break;
    case_neg_105: /* CIL Label */ 
#line 4305
    if (! zpc_disables[6]) {
#line 4306
      return (1);
    }
#line 4307
    goto switch_break;
    case_neg_124: /* CIL Label */ 
#line 4310
    if (opts[53]) {
#line 4310
      if (! zpc_disables[11]) {
#line 4311
        return (1);
      }
    }
#line 4312
    goto switch_break;
    case_neg_122: /* CIL Label */ 
#line 4315
    if (opts[53]) {
#line 4315
      if (! zpc_disables[10]) {
#line 4316
        return (1);
      }
    }
#line 4317
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 4270
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4320
  return (0);
}
}
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 622
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 252 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 276
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 23 "./builtin.epro"
int eval_autoload(Shfunc shf , char *name , Options ops , int func ) ;
#line 25
Eprog mkautofn(Shfunc shf ) ;
#line 49
char **testargs ;
#line 51
void testlex(void) ;
#line 28 "./exec.epro"
Eprog parse_string(char *s , int reset_lineno ) ;
#line 62
Eprog getfpfunc(char *s , int *ksh , char **fdir , char **alt_path , int test_only ) ;
#line 5 "./hashtable.epro"
unsigned int hasher(char const   *str ) ;
#line 40 "./hist.epro"
void herrflush(void) ;
#line 19 "./input.epro"
char *input_hasalias(void) ;
#line 6 "./lex.epro"
char *zshlextext ;
#line 7
char *tokstr ;
#line 8
enum lextok tok ;
#line 9
int tokfd ;
#line 10
zlong toklineno ;
#line 15
int nocorrect ;
#line 25
int noaliases ;
#line 31
void zshlex(void) ;
#line 18 "./linklist.epro"
LinkList newsizedlist(int size ) ;
#line 20
LinkNode linknodebydatum(LinkList list , void *dat ) ;
#line 79 "./params.epro"
int isident(char *s ) ;
#line 5 "./parse.epro"
int incmdpos  ;
#line 6 "./parse.epro"
int aliasspaceflag  ;
#line 7 "./parse.epro"
int incond  ;
#line 8 "./parse.epro"
int inredir  ;
#line 9 "./parse.epro"
int incasepat  ;
#line 10 "./parse.epro"
int isnewlin  ;
#line 11 "./parse.epro"
int infor  ;
#line 12 "./parse.epro"
int inrepeat_  ;
#line 13 "./parse.epro"
int intypeset  ;
#line 14 "./parse.epro"
struct heredocs *hdocs  ;
#line 15 "./parse.epro"
int eclen  ;
#line 16 "./parse.epro"
int ecused  ;
#line 17 "./parse.epro"
int ecnpats  ;
#line 18 "./parse.epro"
Wordcode ecbuf  ;
#line 19 "./parse.epro"
Eccstr ecstrs  ;
#line 20 "./parse.epro"
int ecsoffs  ;
#line 21 "./parse.epro"
int ecssub  ;
#line 22 "./parse.epro"
int ecnfunc  ;
#line 23
void parse_context_save(struct parse_stack *ps , int toplevel ) ;
#line 24
void parse_context_restore(struct parse_stack  const  *ps , int toplevel ) ;
#line 25
void init_parse_status(void) ;
#line 26
void init_parse(void) ;
#line 28
Eprog parse_event(int endtok ) ;
#line 29
int par_event(int endtok ) ;
#line 30
Eprog parse_list(void) ;
#line 31
Eprog parse_cond(void) ;
#line 32
void setheredoc(int pc , int type___0 , char *str , char *termstr , char *munged_termstr ) ;
#line 33
void (*condlex)(void) ;
#line 38
char *ecrawstr(Eprog p , Wordcode pc , int *tokflag ) ;
#line 39
char **ecgetarr(Estate s , int num , int dup___0 , int *tokflag ) ;
#line 40
LinkList ecgetlist(Estate s , int num , int dup___0 , int *tokflag ) ;
#line 42
Eprog eccopyredirs(Estate s ) ;
#line 43 "./parse.epro"
struct eprog dummy_eprog  ;
#line 44
void init_eprog(void) ;
#line 45
int bin_zcompile(char *nam , char **args , Options ops , int func  __attribute__((__unused__)) ) ;
#line 53
Eprog try_dump_file(char *path___0 , char *name , char *file , int *ksh , int test_only ) ;
#line 54
Eprog try_source_file(char *file ) ;
#line 55
void incrdumpcount(FuncDump f ) ;
#line 56
void decrdumpcount(FuncDump f ) ;
#line 59
int dump_autoload(char *nam , char *file , int on , Options ops , int func ) ;
#line 2 "./parse.pro"
static void set_list_code(int p , int type___0 , int cmplx ) ;
#line 3
static void set_sublist_code(int p , int type___0 , int flags , int skip , int cmplx ) ;
#line 4
static void par_list(int *cmplx ) ;
#line 5
static void par_list1(int *cmplx ) ;
#line 6
static int par_sublist(int *cmplx ) ;
#line 7
static int par_sublist2(int *cmplx ) ;
#line 8
static int par_pline(int *cmplx ) ;
#line 9
static int par_cmd(int *cmplx , int zsh_construct ) ;
#line 10
static void par_for(int *cmplx ) ;
#line 11
static void par_case(int *cmplx ) ;
#line 12
static void par_if(int *cmplx ) ;
#line 13
static void par_while(int *cmplx ) ;
#line 14
static void par_repeat(int *cmplx ) ;
#line 15
static void par_subsh(int *cmplx , int zsh_construct ) ;
#line 16
static void par_funcdef(int *cmplx ) ;
#line 17
static void par_time(void) ;
#line 18
static void par_dinbrack(void) ;
#line 19
static int par_simple(int *cmplx , int nr ) ;
#line 20
static int par_redir(int *rp , char *idstring ) ;
#line 21
static int par_wordlist(void) ;
#line 22
static int par_nl_wordlist(void) ;
#line 23
static int par_cond(void) ;
#line 24
static int par_cond_1(void) ;
#line 25
static int par_cond_2(void) ;
#line 26
static int par_cond_double(char *a , char *b ) ;
#line 27
static int get_cond_num(char *tst ) ;
#line 28
static int par_cond_triple(char *a , char *b , char *c ) ;
#line 29
static int par_cond_multi(char *a , LinkList l ) ;
#line 30
static void yyerror(int noerr ) ;
#line 31
static Wordcode load_dump_header(char *nam , char *name , int err ) ;
#line 32
static int build_dump(char *nam , char *dump , char **files , int ali , int map ,
                      int flags ) ;
#line 33
static int build_cur_dump(char *nam , char *dump , char **names , int match , int map ,
                          int what ) ;
#line 42
static Eprog check_dump_file(char *file , struct stat *sbuf , char *name , int *ksh ,
                             int test_only ) ;
#line 43
static void freedump(FuncDump f ) ;
#line 272 "/tmp/zsh-5.4.2/Src/parse.c"
void parse_context_save(struct parse_stack *ps , int toplevel ) 
{ 


  {
#line 277
  ps->incmdpos = incmdpos;
#line 278
  ps->aliasspaceflag = aliasspaceflag;
#line 279
  ps->incond = incond;
#line 280
  ps->inredir = inredir;
#line 281
  ps->incasepat = incasepat;
#line 282
  ps->isnewlin = isnewlin;
#line 283
  ps->infor = infor;
#line 284
  ps->inrepeat_ = inrepeat_;
#line 285
  ps->intypeset = intypeset;
#line 287
  ps->hdocs = hdocs;
#line 288
  ps->eclen = eclen;
#line 289
  ps->ecused = ecused;
#line 290
  ps->ecnpats = ecnpats;
#line 291
  ps->ecbuf = ecbuf;
#line 292
  ps->ecstrs = ecstrs;
#line 293
  ps->ecsoffs = ecsoffs;
#line 294
  ps->ecssub = ecssub;
#line 295
  ps->ecnfunc = ecnfunc;
#line 296
  ecbuf = (Wordcode )((void *)0);
#line 297
  hdocs = (struct heredocs *)((void *)0);
#line 298
  return;
}
}
#line 303 "/tmp/zsh-5.4.2/Src/parse.c"
void parse_context_restore(struct parse_stack  const  *ps , int toplevel ) 
{ 


  {
#line 308
  if (ecbuf) {
    {
#line 309
    zfree((void *)ecbuf, eclen);
    }
  }
#line 311
  incmdpos = (int )ps->incmdpos;
#line 312
  aliasspaceflag = (int )ps->aliasspaceflag;
#line 313
  incond = (int )ps->incond;
#line 314
  inredir = (int )ps->inredir;
#line 315
  incasepat = (int )ps->incasepat;
#line 316
  isnewlin = (int )ps->isnewlin;
#line 317
  infor = (int )ps->infor;
#line 318
  inrepeat_ = (int )ps->inrepeat_;
#line 319
  intypeset = (int )ps->intypeset;
#line 321
  hdocs = (struct heredocs *)ps->hdocs;
#line 322
  eclen = (int )ps->eclen;
#line 323
  ecused = (int )ps->ecused;
#line 324
  ecnpats = (int )ps->ecnpats;
#line 325
  ecbuf = (Wordcode )ps->ecbuf;
#line 326
  ecstrs = (Eccstr )ps->ecstrs;
#line 327
  ecsoffs = (int )ps->ecsoffs;
#line 328
  ecssub = (int )ps->ecssub;
#line 329
  ecnfunc = (int )ps->ecnfunc;
#line 331
  errflag &= -2;
#line 332
  return;
}
}
#line 336 "/tmp/zsh-5.4.2/Src/parse.c"
static void ecadjusthere(int p , int d___0 ) 
{ 
  struct heredocs *h ;

  {
#line 341
  h = hdocs;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! h) {
#line 341
      goto while_break;
    }
#line 342
    if (h->pc >= p) {
#line 343
      h->pc += d___0;
    }
#line 341
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  return;
}
}
#line 348 "/tmp/zsh-5.4.2/Src/parse.c"
static void ecispace(int p , int n ) 
{ 
  int m ;
  int a ;
  int tmp ;
  void *tmp___0 ;

  {
#line 353
  if (eclen - ecused < n) {
#line 354
    if (eclen < 32768) {
#line 354
      tmp = eclen;
    } else {
#line 354
      tmp = 1024;
    }
#line 354
    a = tmp;
#line 356
    if (n > a) {
#line 356
      a = n;
    }
    {
#line 358
    tmp___0 = zrealloc((void *)((char *)ecbuf), (unsigned long )(eclen + a) * sizeof(wordcode ));
#line 358
    ecbuf = (Wordcode )tmp___0;
#line 359
    eclen += a;
    }
  }
#line 361
  m = ecused - p;
#line 361
  if (m > 0) {
    {
#line 362
    memmove((void *)((ecbuf + p) + n), (void const   *)(ecbuf + p), (unsigned long )m * sizeof(wordcode ));
    }
  }
  {
#line 363
  ecused += n;
#line 364
  ecadjusthere(p, n);
  }
#line 365
  return;
}
}
#line 369 "/tmp/zsh-5.4.2/Src/parse.c"
static int ecadd(wordcode c ) 
{ 
  int a ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 372
  if (eclen - ecused < 1) {
#line 373
    if (eclen < 32768) {
#line 373
      tmp = eclen;
    } else {
#line 373
      tmp = 1024;
    }
    {
#line 373
    a = tmp;
#line 375
    tmp___0 = zrealloc((void *)((char *)ecbuf), (unsigned long )(eclen + a) * sizeof(wordcode ));
#line 375
    ecbuf = (Wordcode )tmp___0;
#line 376
    eclen += a;
    }
  }
#line 378
  *(ecbuf + ecused) = c;
#line 380
  tmp___1 = ecused;
#line 380
  ecused ++;
#line 380
  return (tmp___1);
}
}
#line 385 "/tmp/zsh-5.4.2/Src/parse.c"
static void ecdel(int p ) 
{ 
  int n ;

  {
#line 388
  n = (ecused - p) - 1;
#line 390
  if (n > 0) {
    {
#line 391
    memmove((void *)(ecbuf + p), (void const   *)((ecbuf + p) + 1), (unsigned long )n * sizeof(wordcode ));
    }
  }
  {
#line 392
  ecused --;
#line 393
  ecadjusthere(p, -1);
  }
#line 394
  return;
}
}
#line 398 "/tmp/zsh-5.4.2/Src/parse.c"
static wordcode ecstrcode(char *s ) 
{ 
  int l ;
  int t ;
  unsigned int val ;
  unsigned int tmp ;
  wordcode c ;
  int tmp___0 ;
  Eccstr p ;
  Eccstr *pp ;
  int cmp ;
  Eccstr tmp___1 ;
  void *tmp___2 ;
  Eccstr tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 403
  tmp = hasher((char const   *)s);
#line 403
  val = tmp;
#line 405
  tmp___5 = strlen((char const   *)s);
#line 405
  l = (int )(tmp___5 + 1UL);
  }
#line 405
  if (l) {
#line 405
    if (l <= 4) {
      {
#line 406
      t = has_token((char const   *)s);
      }
#line 407
      if (t) {
#line 407
        tmp___0 = 3;
      } else {
#line 407
        tmp___0 = 2;
      }
#line 407
      c = (wordcode )tmp___0;
      {
#line 409
      if (l == 4) {
#line 409
        goto case_4;
      }
#line 410
      if (l == 3) {
#line 410
        goto case_3;
      }
#line 411
      if (l == 2) {
#line 411
        goto case_2;
      }
#line 412
      if (l == 1) {
#line 412
        goto case_1;
      }
#line 408
      goto switch_break;
      case_4: /* CIL Label */ 
#line 409
      c |= (wordcode )((unsigned char )*(s + 2)) << 19;
      case_3: /* CIL Label */ 
#line 410
      c |= (wordcode )((unsigned char )*(s + 1)) << 11;
      case_2: /* CIL Label */ 
#line 411
      c |= (wordcode )((unsigned char )*(s + 0)) << 3;
#line 411
      goto switch_break;
      case_1: /* CIL Label */ 
#line 412
      if (t) {
#line 412
        c = (wordcode )7;
      } else {
#line 412
        c = (wordcode )6;
      }
#line 412
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 414
      return (c);
    } else {
#line 405
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 419
    pp = & ecstrs;
    {
#line 419
    while (1) {
      while_continue: /* CIL Label */ ;
#line 419
      p = *pp;
#line 419
      if (! p) {
#line 419
        goto while_break;
      }
#line 420
      cmp = p->nfunc - ecnfunc;
#line 420
      if (! cmp) {
#line 420
        cmp = p->hashval - (int )val;
#line 420
        if (! cmp) {
          {
#line 420
          cmp = strcmp((char const   *)p->str, (char const   *)s);
          }
#line 420
          if (! cmp) {
#line 421
            return (p->offs);
          }
        }
      }
#line 423
      if (cmp < 0) {
#line 423
        pp = & p->left;
      } else {
#line 423
        pp = & p->right;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 426
    t = has_token((char const   *)s);
#line 428
    tmp___2 = zhalloc(sizeof(*p));
#line 428
    tmp___1 = (Eccstr )tmp___2;
#line 428
    *pp = tmp___1;
#line 428
    p = tmp___1;
#line 429
    tmp___3 = (Eccstr )0;
#line 429
    p->right = tmp___3;
#line 429
    p->left = tmp___3;
    }
#line 430
    if (t) {
#line 430
      tmp___4 = 1;
    } else {
#line 430
      tmp___4 = 0;
    }
#line 430
    p->offs = (wordcode )(((ecsoffs - ecssub) << 2) | tmp___4);
#line 431
    p->aoffs = (wordcode )ecsoffs;
#line 432
    p->str = s;
#line 433
    p->nfunc = ecnfunc;
#line 434
    p->hashval = (int )val;
#line 435
    ecsoffs += l;
#line 437
    return (p->offs);
  }
}
}
#line 458 "/tmp/zsh-5.4.2/Src/parse.c"
void init_parse_status(void) 
{ 


  {
#line 468
  intypeset = 0;
#line 468
  infor = intypeset;
#line 468
  inredir = infor;
#line 468
  incond = inredir;
#line 468
  incasepat = incond;
#line 469
  inrepeat_ = 0;
#line 470
  incmdpos = 1;
#line 471
  return;
}
}
#line 476 "/tmp/zsh-5.4.2/Src/parse.c"
void init_parse(void) 
{ 
  void *tmp ;
  sigset_t oset ;

  {
#line 479
  queueing_enabled ++;
#line 481
  if (ecbuf) {
    {
#line 481
    zfree((void *)ecbuf, eclen);
    }
  }
  {
#line 483
  eclen = 256;
#line 483
  tmp = zalloc((unsigned long )eclen * sizeof(wordcode ));
#line 483
  ecbuf = (Wordcode )tmp;
#line 484
  ecused = 0;
#line 485
  ecstrs = (Eccstr )((void *)0);
#line 486
  ecnpats = 0;
#line 486
  ecsoffs = ecnpats;
#line 487
  ecssub = 0;
#line 488
  ecnfunc = 0;
#line 490
  init_parse_status();
  }
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    queueing_enabled --;
#line 492
    if (! queueing_enabled) {
      {
#line 492
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 492
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 492
          if (! (queue_front != queue_rear)) {
#line 492
            goto while_break___1;
          }
          {
#line 492
          queue_front = (queue_front + 1) % 128;
#line 492
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 492
          zhandler(signal_queue[queue_front]);
#line 492
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 492
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 492
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 499 "/tmp/zsh-5.4.2/Src/parse.c"
static void copy_ecstr(Eccstr s , char *p ) 
{ 
  size_t tmp ;

  {
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! s) {
#line 502
      goto while_break;
    }
    {
#line 503
    tmp = strlen((char const   *)s->str);
#line 503
    memcpy((void */* __restrict  */)(p + s->aoffs), (void const   */* __restrict  */)s->str,
           tmp + 1UL);
#line 504
    copy_ecstr(s->left, p);
#line 505
    s = s->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 507
  return;
}
}
#line 509 "/tmp/zsh-5.4.2/Src/parse.c"
static Eprog bld_eprog(int heap ) 
{ 
  Eprog ret ;
  int l ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  sigset_t oset ;

  {
  {
#line 515
  queueing_enabled ++;
#line 517
  ecadd(0U);
  }
#line 519
  if (heap) {
    {
#line 519
    tmp = zhalloc(sizeof(*ret));
#line 519
    ret = (Eprog )tmp;
    }
  } else {
    {
#line 519
    tmp___0 = zalloc(sizeof(*ret));
#line 519
    ret = (Eprog )tmp___0;
    }
  }
#line 520
  ret->len = (int )(((unsigned long )ecnpats * sizeof(Patprog ) + (unsigned long )ecused * sizeof(wordcode )) + (unsigned long )ecsoffs);
#line 523
  ret->npats = ecnpats;
#line 524
  if (heap) {
#line 524
    ret->nref = -1;
  } else {
#line 524
    ret->nref = 1;
  }
#line 525
  if (heap) {
    {
#line 525
    tmp___1 = zhalloc((size_t )ret->len);
#line 525
    ret->pats = (Patprog *)tmp___1;
    }
  } else {
    {
#line 525
    tmp___2 = zshcalloc((size_t )ret->len);
#line 525
    ret->pats = (Patprog *)tmp___2;
    }
  }
#line 527
  ret->prog = (Wordcode )(ret->pats + ecnpats);
#line 528
  ret->strs = (char *)(ret->prog + ecused);
#line 529
  ret->shf = (Shfunc )((void *)0);
#line 530
  if (heap) {
#line 530
    ret->flags = 2;
  } else {
#line 530
    ret->flags = 1;
  }
#line 531
  ret->dump = (FuncDump )((void *)0);
#line 532
  l = 0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (l < ecnpats)) {
#line 532
      goto while_break;
    }
#line 533
    *(ret->pats + l) = (Patprog )1;
#line 532
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 534
  memcpy((void */* __restrict  */)ret->prog, (void const   */* __restrict  */)ecbuf,
         (unsigned long )ecused * sizeof(wordcode ));
#line 535
  copy_ecstr(ecstrs, ret->strs);
#line 537
  zfree((void *)ecbuf, eclen);
#line 538
  ecbuf = (Wordcode )((void *)0);
  }
  {
#line 540
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 540
    queueing_enabled --;
#line 540
    if (! queueing_enabled) {
      {
#line 540
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 540
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 540
          if (! (queue_front != queue_rear)) {
#line 540
            goto while_break___2;
          }
          {
#line 540
          queue_front = (queue_front + 1) % 128;
#line 540
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 540
          zhandler(signal_queue[queue_front]);
#line 540
          signal_setmask(oset);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 540
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 540
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 542
  return (ret);
}
}
#line 546 "/tmp/zsh-5.4.2/Src/parse.c"
int empty_eprog(Eprog p ) 
{ 
  int tmp ;

  {
#line 549
  if (! p) {
#line 549
    tmp = 1;
  } else
#line 549
  if (! p->prog) {
#line 549
    tmp = 1;
  } else
#line 549
  if (*(p->prog) == 0U) {
#line 549
    tmp = 1;
  } else {
#line 549
    tmp = 0;
  }
#line 549
  return (tmp);
}
}
#line 552 "/tmp/zsh-5.4.2/Src/parse.c"
static void clear_hdocs(void) 
{ 
  struct heredocs *p ;
  struct heredocs *n ;

  {
#line 557
  p = hdocs;
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! p) {
#line 557
      goto while_break;
    }
    {
#line 558
    n = p->next;
#line 559
    zfree((void *)p, (int )sizeof(struct heredocs ));
#line 557
    p = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 561
  hdocs = (struct heredocs *)((void *)0);
#line 562
  return;
}
}
#line 575 "/tmp/zsh-5.4.2/Src/parse.c"
Eprog parse_event(int endtok ) 
{ 
  int tmp ;
  Eprog tmp___0 ;

  {
  {
#line 578
  tok = (enum lextok )37;
#line 579
  incmdpos = 1;
#line 580
  aliasspaceflag = 0;
#line 581
  zshlex();
#line 582
  init_parse();
#line 584
  tmp = par_event(endtok);
  }
#line 584
  if (! tmp) {
    {
#line 585
    clear_hdocs();
    }
#line 586
    return ((Eprog )((void *)0));
  }
#line 588
  if (endtok != 37) {
#line 590
    return (& dummy_eprog);
  }
  {
#line 592
  tmp___0 = bld_eprog(1);
  }
#line 592
  return (tmp___0);
}
}
#line 596 "/tmp/zsh-5.4.2/Src/parse.c"
int par_event(int endtok ) 
{ 
  int r ;
  int p ;
  int c ;
  int tmp ;
  int oec ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 599
  r = 0;
#line 599
  c = 0;
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    if (! ((unsigned int )tok == 1U)) {
#line 601
      goto while_break;
    }
#line 602
    if (isnewlin > 0) {
#line 602
      if (endtok == 37) {
#line 603
        return (0);
      }
    }
    {
#line 604
    zshlex();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 606
  if ((unsigned int )tok == 37U) {
#line 607
    return (0);
  }
#line 608
  if ((unsigned int )tok == (unsigned int )endtok) {
#line 609
    return (1);
  }
  {
#line 611
  p = ecadd((wordcode )0);
#line 613
  tmp = par_sublist(& c);
  }
#line 613
  if (tmp) {
#line 614
    if ((unsigned int )tok == 37U) {
      {
#line 615
      set_list_code(p, 1 << 1, c);
#line 616
      r = 1;
      }
    } else
#line 614
    if ((unsigned int )tok == (unsigned int )endtok) {
      {
#line 615
      set_list_code(p, 1 << 1, c);
#line 616
      r = 1;
      }
    } else
#line 617
    if ((unsigned int )tok == 1U) {
      {
#line 618
      set_list_code(p, 1 << 1, c);
      }
#line 619
      if (isnewlin <= 0) {
        {
#line 620
        zshlex();
        }
      } else
#line 619
      if (endtok != 37) {
        {
#line 620
        zshlex();
        }
      }
#line 621
      r = 1;
    } else
#line 622
    if ((unsigned int )tok == 5U) {
      {
#line 623
      set_list_code(p, 1 << 2, c);
#line 624
      zshlex();
#line 625
      r = 1;
      }
    } else
#line 626
    if ((unsigned int )tok == 30U) {
      {
#line 627
      set_list_code(p, (1 << 2) | (1 << 3), c);
#line 628
      zshlex();
#line 629
      r = 1;
      }
    }
  }
#line 632
  if (! r) {
#line 633
    tok = (enum lextok )38;
#line 634
    if (errflag) {
      {
#line 635
      yyerror(0);
#line 636
      ecused --;
      }
#line 637
      return (0);
    }
    {
#line 639
    yyerror(1);
#line 640
    herrflush();
    }
#line 641
    if (noerrs != 2) {
#line 642
      errflag |= 1;
    }
#line 643
    ecused --;
#line 644
    return (0);
  } else {
    {
#line 646
    oec = ecused;
#line 648
    tmp___1 = par_event(endtok);
    }
#line 648
    if (! tmp___1) {
#line 649
      ecused = oec;
#line 650
      *(ecbuf + p) |= (unsigned int )((1 << 4) << 5);
#line 651
      if (errflag) {
#line 651
        tmp___0 = 0;
      } else {
#line 651
        tmp___0 = 1;
      }
#line 651
      return (tmp___0);
    }
  }
#line 654
  return (1);
}
}
#line 658 "/tmp/zsh-5.4.2/Src/parse.c"
Eprog parse_list(void) 
{ 
  int c ;
  Eprog tmp ;

  {
  {
#line 661
  c = 0;
#line 663
  tok = (enum lextok )37;
#line 664
  init_parse();
#line 665
  zshlex();
#line 666
  par_list(& c);
  }
#line 667
  if ((unsigned int )tok != 37U) {
    {
#line 668
    clear_hdocs();
#line 669
    tok = (enum lextok )38;
#line 670
    yyerror(0);
    }
#line 671
    return ((Eprog )((void *)0));
  }
  {
#line 673
  tmp = bld_eprog(1);
  }
#line 673
  return (tmp);
}
}
#line 683 "/tmp/zsh-5.4.2/Src/parse.c"
Eprog parse_cond(void) 
{ 
  int tmp ;
  Eprog tmp___0 ;

  {
  {
#line 686
  init_parse();
#line 688
  tmp = par_cond();
  }
#line 688
  if (! tmp) {
    {
#line 689
    clear_hdocs();
    }
#line 690
    return ((Eprog )((void *)0));
  }
  {
#line 692
  tmp___0 = bld_eprog(1);
  }
#line 692
  return (tmp___0);
}
}
#line 699 "/tmp/zsh-5.4.2/Src/parse.c"
static void set_list_code(int p , int type___0 , int cmplx ) 
{ 
  int ispipe ;

  {
#line 702
  if (! cmplx) {
#line 702
    if (type___0 == 1 << 1) {
#line 702
      goto _L;
    } else
#line 702
    if (type___0 == ((1 << 1) | (1 << 4))) {
      _L: /* CIL Label */ 
#line 702
      if (((*(ecbuf + (p + 1)) >> 5) & 3U) == 0U) {
        {
#line 704
        ispipe = ! (((*(ecbuf + (p + 1)) >> 5) & 28U) & 16U);
#line 705
        *(ecbuf + p) = 1U | ((wordcode )((type___0 | (1 << 5)) | (((ecused - 2) - p) << 6)) << 5);
#line 706
        ecdel(p + 1);
        }
#line 707
        if (ispipe) {
#line 708
          *(ecbuf + (p + 1)) = (*(ecbuf + (p + 1)) >> 5) >> 1;
        }
      } else {
#line 710
        *(ecbuf + p) = 1U | ((wordcode )type___0 << 5);
      }
    } else {
#line 710
      *(ecbuf + p) = 1U | ((wordcode )type___0 << 5);
    }
  } else {
#line 710
    *(ecbuf + p) = 1U | ((wordcode )type___0 << 5);
  }
#line 711
  return;
}
}
#line 716 "/tmp/zsh-5.4.2/Src/parse.c"
static void set_sublist_code(int p , int type___0 , int flags , int skip , int cmplx ) 
{ 


  {
#line 719
  if (cmplx) {
#line 720
    *(ecbuf + p) = 2U | ((wordcode )((type___0 | flags) | (skip << 5)) << 5);
  } else {
#line 722
    *(ecbuf + p) = 2U | ((wordcode )((type___0 | (flags | 16)) | (skip << 5)) << 5);
#line 723
    *(ecbuf + (p + 1)) = (*(ecbuf + (p + 1)) >> 5) >> 1;
  }
#line 725
  return;
}
}
#line 732 "/tmp/zsh-5.4.2/Src/parse.c"
static void par_list(int *cmplx ) 
{ 
  int p ;
  int lp ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 735
  lp = -1;
  rec: 
  {
#line 739
  while (1) {
    while_continue: /* CIL Label */ ;
#line 739
    if (! ((unsigned int )tok == 1U)) {
#line 739
      goto while_break;
    }
    {
#line 740
    zshlex();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 742
  p = ecadd((wordcode )0);
#line 743
  c = 0;
#line 745
  tmp___1 = par_sublist(& c);
  }
#line 745
  if (tmp___1) {
#line 746
    *cmplx |= c;
#line 747
    if ((unsigned int )tok == 1U) {
#line 747
      goto _L;
    } else
#line 747
    if ((unsigned int )tok == 5U) {
#line 747
      goto _L;
    } else
#line 747
    if ((unsigned int )tok == 30U) {
      _L: /* CIL Label */ 
#line 748
      if ((unsigned int )tok != 1U) {
#line 749
        *cmplx = 1;
      }
#line 750
      if ((unsigned int )tok == 1U) {
#line 750
        tmp___0 = 1 << 1;
      } else {
#line 750
        if ((unsigned int )tok == 5U) {
#line 750
          tmp = 1 << 2;
        } else {
#line 750
          tmp = (1 << 2) | (1 << 3);
        }
#line 750
        tmp___0 = tmp;
      }
      {
#line 750
      set_list_code(p, tmp___0, c);
#line 753
      incmdpos = 1;
      }
      {
#line 754
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 755
        zshlex();
        }
#line 754
        if (! ((unsigned int )tok == 1U)) {
#line 754
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 757
      lp = p;
#line 758
      goto rec;
    } else {
      {
#line 760
      set_list_code(p, (1 << 1) | (1 << 4), c);
      }
    }
  } else {
#line 762
    ecused --;
#line 763
    if (lp >= 0) {
#line 764
      *(ecbuf + lp) |= (unsigned int )((1 << 4) << 5);
    }
  }
#line 766
  return;
}
}
#line 769 "/tmp/zsh-5.4.2/Src/parse.c"
static void par_list1(int *cmplx ) 
{ 
  int p ;
  int tmp ;
  int c ;
  int tmp___0 ;

  {
  {
#line 772
  tmp = ecadd((wordcode )0);
#line 772
  p = tmp;
#line 772
  c = 0;
#line 774
  tmp___0 = par_sublist(& c);
  }
#line 774
  if (tmp___0) {
    {
#line 775
    set_list_code(p, (1 << 1) | (1 << 4), c);
#line 776
    *cmplx |= c;
    }
  } else {
#line 778
    ecused --;
  }
#line 779
  return;
}
}
#line 786 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_sublist(int *cmplx ) 
{ 
  int f ;
  int p ;
  int c ;
  int e ;
  enum lextok qtok ;
  int sl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 789
  c = 0;
#line 791
  p = ecadd((wordcode )0);
#line 793
  f = par_sublist2(& c);
  }
#line 793
  if (f != -1) {
#line 794
    e = ecused;
#line 796
    *cmplx |= c;
#line 797
    if ((unsigned int )tok == 8U) {
#line 797
      goto _L;
    } else
#line 797
    if ((unsigned int )tok == 9U) {
      _L: /* CIL Label */ 
#line 798
      qtok = tok;
#line 801
      if ((unsigned int )tok == 8U) {
#line 801
        tmp = 11;
      } else {
#line 801
        tmp = 12;
      }
      {
#line 801
      cmdpush(tmp);
#line 802
      zshlex();
      }
      {
#line 803
      while (1) {
        while_continue: /* CIL Label */ ;
#line 803
        if (! ((unsigned int )tok == 1U)) {
#line 803
          goto while_break;
        }
        {
#line 804
        zshlex();
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 805
      sl = par_sublist(cmplx);
      }
#line 806
      if (sl) {
#line 806
        if ((unsigned int )qtok == 8U) {
#line 806
          tmp___0 = 2;
        } else {
#line 806
          tmp___0 = 1;
        }
#line 806
        tmp___1 = tmp___0;
      } else {
#line 806
        tmp___1 = 0;
      }
      {
#line 806
      set_sublist_code(p, tmp___1, f, (e - 1) - p, c);
#line 810
      cmdpop();
      }
    } else {
      {
#line 812
      set_sublist_code(p, 0, f, (e - 1) - p, c);
      }
    }
#line 813
    return (1);
  } else {
#line 815
    ecused --;
#line 816
    return (0);
  }
}
}
#line 825 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_sublist2(int *cmplx ) 
{ 
  int f ;
  int tmp ;

  {
#line 828
  f = 0;
#line 830
  if ((unsigned int )tok == 44U) {
    {
#line 831
    *cmplx = 1;
#line 832
    f |= 4;
#line 833
    zshlex();
    }
  } else
#line 834
  if ((unsigned int )tok == 39U) {
    {
#line 835
    *cmplx = 1;
#line 836
    f |= 8;
#line 837
    zshlex();
    }
  }
  {
#line 839
  tmp = par_pline(cmplx);
  }
#line 839
  if (! tmp) {
#line 839
    if (! f) {
#line 840
      return (-1);
    }
  }
#line 842
  return (f);
}
}
#line 850 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_pline(int *cmplx ) 
{ 
  int p ;
  zlong line ;
  int tmp ;
  zlong tmp___0 ;
  int tmp___1 ;
  int r ;
  int tmp___2 ;
  int tmp___3 ;
  zlong tmp___4 ;
  int tmp___5 ;
  zlong tmp___6 ;

  {
  {
#line 854
  line = toklineno;
#line 856
  p = ecadd((wordcode )0);
#line 858
  tmp = par_cmd(cmplx, 0);
  }
#line 858
  if (! tmp) {
#line 859
    ecused --;
#line 860
    return (0);
  }
#line 862
  if ((unsigned int )tok == 25U) {
    {
#line 863
    *cmplx = 1;
#line 864
    cmdpush(13);
#line 865
    zshlex();
    }
    {
#line 866
    while (1) {
      while_continue: /* CIL Label */ ;
#line 866
      if (! ((unsigned int )tok == 1U)) {
#line 866
        goto while_break;
      }
      {
#line 867
      zshlex();
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 868
    if (line >= 0L) {
#line 868
      tmp___0 = line + 1L;
    } else {
#line 868
      tmp___0 = (zlong )0;
    }
    {
#line 868
    *(ecbuf + p) = 3U | ((wordcode )(1L | (tmp___0 << 1)) << 5);
#line 869
    ecispace(p + 1, 1);
#line 870
    *(ecbuf + (p + 1)) = (wordcode )((ecused - 1) - p);
#line 871
    tmp___1 = par_pline(cmplx);
    }
#line 871
    if (! tmp___1) {
#line 872
      tok = (enum lextok )38;
    }
    {
#line 874
    cmdpop();
    }
#line 875
    return (1);
  } else
#line 876
  if ((unsigned int )tok == 26U) {
#line 879
    r = p + 1;
    {
#line 879
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 879
      if (! ((*(ecbuf + r) & (wordcode )((1 << 5) - 1)) == 4U)) {
#line 879
        goto while_break___0;
      }
#line 879
      if ((int )((*(ecbuf + r) >> 5) & 32U)) {
#line 879
        tmp___2 = 4;
      } else {
#line 879
        tmp___2 = 3;
      }
#line 879
      if ((int )((*(ecbuf + r) >> 5) & 64U)) {
#line 879
        tmp___3 = 2;
      } else {
#line 879
        tmp___3 = 0;
      }
#line 879
      r += tmp___2 + tmp___3;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 882
    ecispace(r, 3);
#line 883
    *(ecbuf + r) = 4U | (14U << 5);
#line 884
    *(ecbuf + (r + 1)) = (wordcode )2;
#line 885
    *(ecbuf + (r + 2)) = ecstrcode((char *)"1");
#line 887
    *cmplx = 1;
#line 888
    cmdpush(14);
#line 889
    zshlex();
    }
    {
#line 890
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 890
      if (! ((unsigned int )tok == 1U)) {
#line 890
        goto while_break___1;
      }
      {
#line 891
      zshlex();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 892
    if (line >= 0L) {
#line 892
      tmp___4 = line + 1L;
    } else {
#line 892
      tmp___4 = (zlong )0;
    }
    {
#line 892
    *(ecbuf + p) = 3U | ((wordcode )(1L | (tmp___4 << 1)) << 5);
#line 893
    ecispace(p + 1, 1);
#line 894
    *(ecbuf + (p + 1)) = (wordcode )((ecused - 1) - p);
#line 895
    tmp___5 = par_pline(cmplx);
    }
#line 895
    if (! tmp___5) {
#line 896
      tok = (enum lextok )38;
    }
    {
#line 898
    cmdpop();
    }
#line 899
    return (1);
  } else {
#line 901
    if (line >= 0L) {
#line 901
      tmp___6 = line + 1L;
    } else {
#line 901
      tmp___6 = (zlong )0;
    }
#line 901
    *(ecbuf + p) = 3U | ((wordcode )(tmp___6 << 1) << 5);
#line 902
    return (1);
  }
}
}
#line 995 "/tmp/zsh-5.4.2/Src/parse.c"
static int inpartime  =    0;
#line 914 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_cmd(int *cmplx , int zsh_construct ) 
{ 
  int r ;
  int nr ;
  int tmp ;
  wordcode tmp___0 ;
  int sr ;

  {
#line 917
  nr = 0;
#line 919
  r = ecused;
#line 921
  if ((unsigned int )tok >= 10U) {
#line 921
    if ((unsigned int )tok <= 24U) {
#line 922
      *cmplx = 1;
      {
#line 923
      while (1) {
        while_continue: /* CIL Label */ ;
#line 923
        if ((unsigned int )tok >= 10U) {
#line 923
          if (! ((unsigned int )tok <= 24U)) {
#line 923
            goto while_break;
          }
        } else {
#line 923
          goto while_break;
        }
        {
#line 924
        tmp = par_redir(& r, (char *)((void *)0));
#line 924
        nr += tmp;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 928
  if ((unsigned int )tok == 52U) {
#line 928
    goto case_52;
  }
#line 933
  if ((unsigned int )tok == 53U) {
#line 933
    goto case_53;
  }
#line 938
  if ((unsigned int )tok == 58U) {
#line 938
    goto case_58;
  }
#line 944
  if ((unsigned int )tok == 43U) {
#line 944
    goto case_43;
  }
#line 949
  if ((unsigned int )tok == 55U) {
#line 949
    goto case_55;
  }
#line 952
  if ((unsigned int )tok == 62U) {
#line 952
    goto case_62;
  }
#line 957
  if ((unsigned int )tok == 61U) {
#line 957
    goto case_61;
  }
#line 962
  if ((unsigned int )tok == 57U) {
#line 962
    goto case_57;
  }
#line 967
  if ((unsigned int )tok == 6U) {
#line 967
    goto case_6;
  }
#line 973
  if ((unsigned int )tok == 41U) {
#line 973
    goto case_41;
  }
#line 978
  if ((unsigned int )tok == 54U) {
#line 978
    goto case_54;
  }
#line 983
  if ((unsigned int )tok == 40U) {
#line 983
    goto case_40;
  }
#line 988
  if ((unsigned int )tok == 28U) {
#line 988
    goto case_28;
  }
#line 993
  if ((unsigned int )tok == 60U) {
#line 993
    goto case_60;
  }
#line 1007
  goto switch_default;
  case_52: /* CIL Label */ 
  {
#line 929
  cmdpush(0);
#line 930
  par_for(cmplx);
#line 931
  cmdpop();
  }
#line 932
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 934
  cmdpush(15);
#line 935
  par_for(cmplx);
#line 936
  cmdpop();
  }
#line 937
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 939
  *cmplx = 1;
#line 940
  cmdpush(3);
#line 941
  par_for(cmplx);
#line 942
  cmdpop();
  }
#line 943
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 945
  cmdpush(16);
#line 946
  par_case(cmplx);
#line 947
  cmdpop();
  }
#line 948
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 950
  par_if(cmplx);
  }
#line 951
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 953
  cmdpush(1);
#line 954
  par_while(cmplx);
#line 955
  cmdpop();
  }
#line 956
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 958
  cmdpush(4);
#line 959
  par_while(cmplx);
#line 960
  cmdpop();
  }
#line 961
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 963
  cmdpush(2);
#line 964
  par_repeat(cmplx);
#line 965
  cmdpop();
  }
#line 966
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 968
  *cmplx = 1;
#line 969
  cmdpush(18);
#line 970
  par_subsh(cmplx, zsh_construct);
#line 971
  cmdpop();
  }
#line 972
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 974
  cmdpush(19);
#line 975
  par_subsh(cmplx, zsh_construct);
#line 976
  cmdpop();
  }
#line 977
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 979
  cmdpush(17);
#line 980
  par_funcdef(cmplx);
#line 981
  cmdpop();
  }
#line 982
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 984
  cmdpush(10);
#line 985
  par_dinbrack();
#line 986
  cmdpop();
  }
#line 987
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 989
  ecadd(19U);
#line 990
  tmp___0 = ecstrcode(tokstr);
#line 990
  ecadd(tmp___0);
#line 991
  zshlex();
  }
#line 992
  goto switch_break;
  case_60: /* CIL Label */ 
#line 997
  if (! inpartime) {
    {
#line 998
    *cmplx = 1;
#line 999
    inpartime = 1;
#line 1000
    par_time();
#line 1001
    inpartime = 0;
    }
#line 1002
    goto switch_break;
  }
#line 1005
  tok = (enum lextok )34;
  switch_default: /* CIL Label */ 
  {
#line 1011
  sr = par_simple(cmplx, nr);
  }
#line 1011
  if (sr) {
#line 1016
    if (sr > 1) {
#line 1017
      *cmplx = 1;
#line 1018
      r += sr - 1;
    }
  } else
#line 1012
  if (! nr) {
#line 1013
    return (0);
  }
#line 1022
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1024
  if ((unsigned int )tok >= 10U) {
#line 1024
    if ((unsigned int )tok <= 24U) {
#line 1025
      *cmplx = 1;
      {
#line 1026
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1026
        if ((unsigned int )tok >= 10U) {
#line 1026
          if (! ((unsigned int )tok <= 24U)) {
#line 1026
            goto while_break___0;
          }
        } else {
#line 1026
          goto while_break___0;
        }
        {
#line 1027
        par_redir(& r, (char *)((void *)0));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1029
  incmdpos = 1;
#line 1030
  incasepat = 0;
#line 1031
  incond = 0;
#line 1032
  intypeset = 0;
#line 1033
  return (1);
}
}
#line 1043 "/tmp/zsh-5.4.2/Src/parse.c"
static void par_for(int *cmplx ) 
{ 
  int oecused ;
  int csh ;
  int p ;
  int sel ;
  int type___0 ;
  wordcode tmp ;
  wordcode tmp___0 ;
  wordcode tmp___1 ;
  int np ;
  int n ;
  int posix_in ;
  int ona ;
  int onc ;
  int tmp___2 ;
  wordcode tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int eu ;
  int eu___0 ;
  int eu___1 ;
  int eu___2 ;

  {
  {
#line 1046
  oecused = ecused;
#line 1046
  csh = (unsigned int )tok == 53U;
#line 1046
  sel = (unsigned int )tok == 58U;
#line 1049
  p = ecadd((wordcode )0);
#line 1051
  incmdpos = 0;
  }
#line 1052
  if ((unsigned int )tok == 52U) {
#line 1052
    infor = 2;
  } else {
#line 1052
    infor = 0;
  }
  {
#line 1053
  zshlex();
  }
#line 1054
  if ((unsigned int )tok == 28U) {
    {
#line 1055
    zshlex();
    }
#line 1056
    if ((unsigned int )tok != 28U) {
#line 1057
      tok = (enum lextok )38;
#line 1057
      ecused = oecused;
#line 1057
      return;
    }
    {
#line 1058
    tmp = ecstrcode(tokstr);
#line 1058
    ecadd(tmp);
#line 1059
    zshlex();
    }
#line 1060
    if ((unsigned int )tok != 28U) {
#line 1061
      tok = (enum lextok )38;
#line 1061
      ecused = oecused;
#line 1061
      return;
    }
    {
#line 1062
    tmp___0 = ecstrcode(tokstr);
#line 1062
    ecadd(tmp___0);
#line 1063
    zshlex();
    }
#line 1064
    if ((unsigned int )tok != 29U) {
#line 1065
      tok = (enum lextok )38;
#line 1065
      ecused = oecused;
#line 1065
      return;
    }
    {
#line 1066
    tmp___1 = ecstrcode(tokstr);
#line 1066
    ecadd(tmp___1);
#line 1067
    infor = 0;
#line 1068
    incmdpos = 1;
#line 1069
    zshlex();
#line 1070
    type___0 = 2;
    }
  } else {
#line 1072
    np = 0;
#line 1072
    ona = noaliases;
#line 1072
    onc = nocorrect;
#line 1073
    infor = 0;
#line 1074
    if ((unsigned int )tok != 34U) {
#line 1075
      tok = (enum lextok )38;
#line 1075
      ecused = oecused;
#line 1075
      return;
    } else {
      {
#line 1074
      tmp___2 = isident(tokstr);
      }
#line 1074
      if (! tmp___2) {
#line 1075
        tok = (enum lextok )38;
#line 1075
        ecused = oecused;
#line 1075
        return;
      }
    }
#line 1076
    if (! sel) {
      {
#line 1077
      np = ecadd((wordcode )0);
      }
    }
#line 1078
    n = 0;
#line 1079
    incmdpos = 1;
#line 1080
    nocorrect = 1;
#line 1080
    noaliases = nocorrect;
    {
#line 1081
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1082
      n ++;
#line 1083
      tmp___3 = ecstrcode(tokstr);
#line 1083
      ecadd(tmp___3);
#line 1084
      zshlex();
      }
#line 1085
      if ((unsigned int )tok != 34U) {
#line 1086
        goto while_break;
      } else {
        {
#line 1085
        tmp___4 = strcmp((char const   *)tokstr, "in");
        }
#line 1085
        if (tmp___4) {
#line 1085
          if (sel) {
#line 1086
            goto while_break;
          }
        } else {
#line 1086
          goto while_break;
        }
      }
      {
#line 1087
      tmp___5 = isident(tokstr);
      }
#line 1087
      if (tmp___5) {
#line 1087
        if (errflag) {
#line 1089
          noaliases = ona;
#line 1090
          nocorrect = onc;
#line 1091
          tok = (enum lextok )38;
#line 1091
          ecused = oecused;
#line 1091
          return;
        }
      } else {
#line 1089
        noaliases = ona;
#line 1090
        nocorrect = onc;
#line 1091
        tok = (enum lextok )38;
#line 1091
        ecused = oecused;
#line 1091
        return;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1094
    noaliases = ona;
#line 1095
    nocorrect = onc;
#line 1096
    if (! sel) {
#line 1097
      *(ecbuf + np) = (wordcode )n;
    }
#line 1098
    posix_in = isnewlin;
    {
#line 1099
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1099
      if (! isnewlin) {
#line 1099
        goto while_break___0;
      }
      {
#line 1100
      zshlex();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1101
    if ((unsigned int )tok == 34U) {
      {
#line 1101
      tmp___6 = strcmp((char const   *)tokstr, "in");
      }
#line 1101
      if (tmp___6) {
#line 1101
        goto _L___0;
      } else {
        {
#line 1102
        incmdpos = 0;
#line 1103
        zshlex();
#line 1104
        np = ecadd((wordcode )0);
#line 1105
        n = par_wordlist();
        }
#line 1106
        if ((unsigned int )tok != 1U) {
#line 1107
          tok = (enum lextok )38;
#line 1107
          ecused = oecused;
#line 1107
          return;
        }
#line 1108
        *(ecbuf + np) = (wordcode )n;
#line 1109
        if (sel) {
#line 1109
          type___0 = 1;
        } else {
#line 1109
          type___0 = 1;
        }
      }
    } else
    _L___0: /* CIL Label */ 
#line 1110
    if (! posix_in) {
#line 1110
      if ((unsigned int )tok == 6U) {
        {
#line 1111
        incmdpos = 0;
#line 1112
        zshlex();
#line 1113
        np = ecadd((wordcode )0);
#line 1114
        n = par_nl_wordlist();
        }
#line 1115
        if ((unsigned int )tok != 7U) {
#line 1116
          tok = (enum lextok )38;
#line 1116
          ecused = oecused;
#line 1116
          return;
        }
        {
#line 1117
        *(ecbuf + np) = (wordcode )n;
#line 1118
        incmdpos = 1;
#line 1119
        zshlex();
        }
#line 1120
        if (sel) {
#line 1120
          type___0 = 1;
        } else {
#line 1120
          type___0 = 1;
        }
      } else {
#line 1110
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1122
    if (sel) {
#line 1122
      type___0 = 0;
    } else {
#line 1122
      type___0 = 0;
    }
  }
#line 1124
  incmdpos = 1;
  {
#line 1125
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1125
    if (! ((unsigned int )tok == 1U)) {
#line 1125
      goto while_break___1;
    }
    {
#line 1126
    zshlex();
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1127
  if ((unsigned int )tok == 45U) {
    {
#line 1128
    zshlex();
    }
    {
#line 1129
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1129
      eu = ecused;
#line 1129
      par_list(cmplx);
      }
#line 1129
      if (eu == ecused) {
        {
#line 1129
        ecadd(0U);
        }
      }
#line 1129
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1130
    if ((unsigned int )tok != 46U) {
#line 1131
      tok = (enum lextok )38;
#line 1131
      ecused = oecused;
#line 1131
      return;
    }
    {
#line 1132
    incmdpos = 0;
#line 1133
    zshlex();
    }
  } else
#line 1134
  if ((unsigned int )tok == 41U) {
    {
#line 1135
    zshlex();
    }
    {
#line 1136
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1136
      eu___0 = ecused;
#line 1136
      par_list(cmplx);
      }
#line 1136
      if (eu___0 == ecused) {
        {
#line 1136
        ecadd(0U);
        }
      }
#line 1136
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1137
    if ((unsigned int )tok != 42U) {
#line 1138
      tok = (enum lextok )38;
#line 1138
      ecused = oecused;
#line 1138
      return;
    }
    {
#line 1139
    incmdpos = 0;
#line 1140
    zshlex();
    }
  } else
#line 1141
  if (csh) {
#line 1141
    goto _L___1;
  } else
#line 1141
  if (opts[43]) {
    _L___1: /* CIL Label */ 
    {
#line 1142
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1142
      eu___1 = ecused;
#line 1142
      par_list(cmplx);
      }
#line 1142
      if (eu___1 == ecused) {
        {
#line 1142
        ecadd(0U);
        }
      }
#line 1142
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1143
    if ((unsigned int )tok != 49U) {
#line 1144
      tok = (enum lextok )38;
#line 1144
      ecused = oecused;
#line 1144
      return;
    }
    {
#line 1145
    incmdpos = 0;
#line 1146
    zshlex();
    }
  } else
#line 1147
  if (! opts[163]) {
#line 1148
    tok = (enum lextok )38;
#line 1148
    ecused = oecused;
#line 1148
    return;
  } else {
    {
#line 1150
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1150
      eu___2 = ecused;
#line 1150
      par_list1(cmplx);
      }
#line 1150
      if (eu___2 == ecused) {
        {
#line 1150
        ecadd(0U);
        }
      }
#line 1150
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1152
  if (sel) {
#line 1152
    *(ecbuf + p) = 13U | ((wordcode )(type___0 | (((ecused - 1) - p) << 1)) << 5);
  } else {
#line 1152
    *(ecbuf + p) = 12U | ((wordcode )(type___0 | (((ecused - 1) - p) << 2)) << 5);
  }
#line 1155
  return;
}
}
#line 1165 "/tmp/zsh-5.4.2/Src/parse.c"
static void par_case(int *cmplx ) 
{ 
  int oecused ;
  int brflag ;
  int p ;
  int pp ;
  int palts ;
  int type___0 ;
  int nalts ;
  int ona ;
  int onc ;
  wordcode tmp ;
  int tmp___0 ;
  char *str ;
  int skip_zshlex ;
  int tmp___1 ;
  wordcode tmp___2 ;
  int tmp___3 ;
  wordcode tmp___4 ;
  int tmp___5 ;
  int pct ;
  int sl ;
  char *s ;
  size_t tmp___6 ;
  wordcode tmp___7 ;
  int tmp___8 ;
  int eu ;

  {
  {
#line 1168
  oecused = ecused;
#line 1171
  p = ecadd((wordcode )0);
#line 1173
  incmdpos = 0;
#line 1174
  zshlex();
  }
#line 1175
  if ((unsigned int )tok != 34U) {
#line 1176
    tok = (enum lextok )38;
#line 1176
    ecused = oecused;
#line 1176
    return;
  }
  {
#line 1177
  tmp = ecstrcode(tokstr);
#line 1177
  ecadd(tmp);
#line 1179
  incmdpos = 1;
#line 1180
  ona = noaliases;
#line 1181
  onc = nocorrect;
#line 1182
  nocorrect = 1;
#line 1182
  noaliases = nocorrect;
#line 1183
  zshlex();
  }
  {
#line 1184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1184
    if (! ((unsigned int )tok == 1U)) {
#line 1184
      goto while_break;
    }
    {
#line 1185
    zshlex();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1186
  if ((unsigned int )tok == 34U) {
    {
#line 1186
    tmp___0 = strcmp((char const   *)tokstr, "in");
    }
#line 1186
    if (tmp___0) {
#line 1186
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1186
  if ((unsigned int )tok != 41U) {
#line 1188
    noaliases = ona;
#line 1189
    nocorrect = onc;
#line 1190
    tok = (enum lextok )38;
#line 1190
    ecused = oecused;
#line 1190
    return;
  }
  {
#line 1192
  brflag = (unsigned int )tok == 41U;
#line 1193
  incasepat = 1;
#line 1194
  incmdpos = 0;
#line 1195
  noaliases = ona;
#line 1196
  nocorrect = onc;
#line 1197
  zshlex();
  }
  {
#line 1199
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1203
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1203
      if (! ((unsigned int )tok == 1U)) {
#line 1203
        goto while_break___1;
      }
      {
#line 1204
      zshlex();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1205
    if ((unsigned int )tok == 42U) {
#line 1206
      goto while_break___0;
    }
#line 1207
    if ((unsigned int )tok == 6U) {
      {
#line 1208
      zshlex();
      }
    }
#line 1209
    if ((unsigned int )tok == 25U) {
      {
#line 1210
      str = dupstring("");
#line 1211
      skip_zshlex = 1;
      }
    } else {
#line 1213
      if ((unsigned int )tok != 34U) {
#line 1214
        tok = (enum lextok )38;
#line 1214
        ecused = oecused;
#line 1214
        return;
      }
      {
#line 1215
      tmp___1 = strcmp((char const   *)tokstr, "esac");
      }
#line 1215
      if (! tmp___1) {
#line 1216
        goto while_break___0;
      }
      {
#line 1217
      str = dupstring((char const   *)tokstr);
#line 1218
      skip_zshlex = 0;
      }
    }
    {
#line 1220
    type___0 = 1;
#line 1221
    pp = ecadd((wordcode )0);
#line 1222
    palts = ecadd((wordcode )0);
#line 1223
    nalts = 0;
#line 1257
    incasepat = -1;
#line 1258
    incmdpos = 1;
    }
#line 1259
    if (! skip_zshlex) {
      {
#line 1260
      zshlex();
      }
    }
    {
#line 1261
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1262
      if ((unsigned int )tok == 7U) {
        {
#line 1263
        tmp___2 = ecstrcode(str);
#line 1263
        ecadd(tmp___2);
#line 1264
        tmp___3 = ecnpats;
#line 1264
        ecnpats ++;
#line 1264
        ecadd((wordcode )tmp___3);
#line 1265
        nalts ++;
#line 1267
        incasepat = 0;
#line 1268
        incmdpos = 1;
#line 1269
        zshlex();
        }
#line 1270
        goto while_break___2;
      } else
#line 1271
      if ((unsigned int )tok == 25U) {
        {
#line 1272
        tmp___4 = ecstrcode(str);
#line 1272
        ecadd(tmp___4);
#line 1273
        tmp___5 = ecnpats;
#line 1273
        ecnpats ++;
#line 1273
        ecadd((wordcode )tmp___5);
#line 1274
        nalts ++;
#line 1276
        incasepat = 1;
#line 1277
        incmdpos = 0;
        }
      } else {
#line 1279
        if (! nalts) {
#line 1279
          if ((int )*(str + 0) == -120) {
#line 1280
            pct = 0;
#line 1283
            s = str;
            {
#line 1283
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1283
              if (! *s) {
#line 1283
                goto while_break___3;
              }
#line 1284
              if ((int )*s == -120) {
#line 1285
                pct ++;
              }
#line 1286
              if (! pct) {
#line 1287
                goto while_break___3;
              }
#line 1288
              if (pct == 1) {
#line 1289
                if ((int )*s == -114) {
#line 1289
                  goto _L___0;
                } else
#line 1289
                if ((int )*s == -120) {
                  _L___0: /* CIL Label */ 
                  {
#line 1290
                  while (1) {
                    while_continue___4: /* CIL Label */ ;
#line 1290
                    if (! ((int )typtab[(unsigned char )*(s + 1)] & (1 << 2))) {
#line 1290
                      goto while_break___4;
                    }
                    {
#line 1291
                    chuck(s + 1);
                    }
                  }
                  while_break___4: /* CIL Label */ ;
                  }
                }
#line 1292
                if ((int )*s == -114) {
#line 1292
                  goto _L___1;
                } else
#line 1292
                if ((int )*s == -118) {
                  _L___1: /* CIL Label */ 
                  {
#line 1293
                  while (1) {
                    while_continue___5: /* CIL Label */ ;
#line 1293
                    if ((int )typtab[(unsigned char )*(s + -1)] & (1 << 2)) {
#line 1293
                      if (! ((unsigned long )s < (unsigned long )(str + 1))) {
#line 1293
                        if (! ((int )*(s + -2) != -125)) {
#line 1293
                          goto while_break___5;
                        }
                      }
                    } else {
#line 1293
                      goto while_break___5;
                    }
                    {
#line 1295
                    s --;
#line 1295
                    chuck(s);
                    }
                  }
                  while_break___5: /* CIL Label */ ;
                  }
                }
              }
#line 1297
              if ((int )*s == -118) {
#line 1298
                pct --;
              }
#line 1283
              s ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 1300
            if (*s) {
#line 1301
              tok = (enum lextok )38;
#line 1301
              ecused = oecused;
#line 1301
              return;
            } else
#line 1300
            if (pct) {
#line 1301
              tok = (enum lextok )38;
#line 1301
              ecused = oecused;
#line 1301
              return;
            } else
#line 1300
            if ((unsigned long )s == (unsigned long )str) {
#line 1301
              tok = (enum lextok )38;
#line 1301
              ecused = oecused;
#line 1301
              return;
            }
            {
#line 1303
            tmp___6 = strlen((char const   *)str);
#line 1303
            sl = (int )tmp___6;
#line 1306
            *(str + (sl - 1)) = (char )'\000';
#line 1307
            chuck(str);
#line 1308
            tmp___7 = ecstrcode(str);
#line 1308
            ecadd(tmp___7);
#line 1309
            tmp___8 = ecnpats;
#line 1309
            ecnpats ++;
#line 1309
            ecadd((wordcode )tmp___8);
#line 1310
            nalts ++;
            }
#line 1311
            goto while_break___2;
          }
        }
#line 1313
        tok = (enum lextok )38;
#line 1313
        ecused = oecused;
#line 1313
        return;
      }
      {
#line 1316
      zshlex();
      }
      {
#line 1318
      if ((unsigned int )tok == 34U) {
#line 1318
        goto case_34;
      }
#line 1325
      if ((unsigned int )tok == 25U) {
#line 1325
        goto case_25;
      }
#line 1325
      if ((unsigned int )tok == 7U) {
#line 1325
        goto case_25;
      }
#line 1330
      goto switch_default;
      case_34: /* CIL Label */ 
      {
#line 1320
      str = dupstring((char const   *)tokstr);
#line 1321
      zshlex();
      }
#line 1322
      goto switch_break;
      case_25: /* CIL Label */ 
      case_7: /* CIL Label */ 
      {
#line 1327
      str = dupstring("");
      }
#line 1328
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1332
      tok = (enum lextok )38;
#line 1332
      ecused = oecused;
#line 1332
      return;
#line 1333
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1336
    incasepat = 0;
    {
#line 1337
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 1337
      eu = ecused;
#line 1337
      par_list(cmplx);
      }
#line 1337
      if (eu == ecused) {
        {
#line 1337
        ecadd(0U);
        }
      }
#line 1337
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1338
    if ((unsigned int )tok == 31U) {
#line 1339
      type___0 = 2;
    } else
#line 1340
    if ((unsigned int )tok == 32U) {
#line 1341
      type___0 = 3;
    }
#line 1342
    *(ecbuf + pp) = 16U | ((wordcode )(type___0 | (((ecused - 1) - pp) << 3)) << 5);
#line 1343
    *(ecbuf + palts) = (wordcode )nalts;
#line 1344
    if ((unsigned int )tok == 50U) {
#line 1344
      if (! brflag) {
#line 1345
        goto while_break___0;
      } else {
#line 1344
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1344
    if ((unsigned int )tok == 42U) {
#line 1344
      if (brflag) {
#line 1345
        goto while_break___0;
      }
    }
#line 1346
    if ((unsigned int )tok != 4U) {
#line 1346
      if ((unsigned int )tok != 31U) {
#line 1346
        if ((unsigned int )tok != 32U) {
#line 1347
          tok = (enum lextok )38;
#line 1347
          ecused = oecused;
#line 1347
          return;
        }
      }
    }
    {
#line 1348
    incasepat = 1;
#line 1349
    incmdpos = 0;
#line 1350
    zshlex();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1352
  incmdpos = 1;
#line 1353
  incasepat = 0;
#line 1354
  zshlex();
#line 1356
  *(ecbuf + p) = 16U | ((wordcode )(((ecused - 1) - p) << 3) << 5);
  }
#line 1357
  return;
}
}
#line 1367 "/tmp/zsh-5.4.2/Src/parse.c"
static void par_if(int *cmplx ) 
{ 
  int oecused ;
  int p ;
  int pp ;
  int type___0 ;
  int usebrace ;
  enum lextok xtok ;
  unsigned char nc ;
  int tmp ;
  int eu ;
  int eu___0 ;
  int eu___1 ;
  int eu___2 ;
  int eu___3 ;
  int eu___4 ;

  {
  {
#line 1370
  oecused = ecused;
#line 1370
  usebrace = 0;
#line 1374
  p = ecadd((wordcode )0);
  }
  {
#line 1376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1377
    xtok = tok;
#line 1378
    if ((unsigned int )xtok == 55U) {
#line 1378
      tmp = 5;
    } else {
#line 1378
      tmp = 8;
    }
    {
#line 1378
    cmdpush(tmp);
    }
#line 1379
    if ((unsigned int )xtok == 51U) {
      {
#line 1380
      incmdpos = 0;
#line 1381
      zshlex();
      }
#line 1382
      goto while_break;
    }
    {
#line 1384
    zshlex();
    }
#line 1385
    if ((unsigned int )xtok == 48U) {
#line 1386
      goto while_break;
    }
    {
#line 1387
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1387
      if (! ((unsigned int )tok == 1U)) {
#line 1387
        goto while_break___0;
      }
      {
#line 1388
      zshlex();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1389
    if (! ((unsigned int )xtok == 55U)) {
#line 1389
      if (! ((unsigned int )xtok == 47U)) {
        {
#line 1390
        cmdpop();
#line 1391
        tok = (enum lextok )38;
#line 1391
        ecused = oecused;
        }
#line 1391
        return;
      }
    }
    {
#line 1393
    pp = ecadd((wordcode )0);
    }
#line 1394
    if ((unsigned int )xtok == 55U) {
#line 1394
      type___0 = 1;
    } else {
#line 1394
      type___0 = 2;
    }
    {
#line 1395
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1395
      eu = ecused;
#line 1395
      par_list(cmplx);
      }
#line 1395
      if (eu == ecused) {
        {
#line 1395
        ecadd(0U);
        }
      }
#line 1395
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1396
    incmdpos = 1;
#line 1397
    if ((unsigned int )tok == 37U) {
      {
#line 1398
      cmdpop();
#line 1399
      tok = (enum lextok )38;
#line 1399
      ecused = oecused;
      }
#line 1399
      return;
    }
    {
#line 1401
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1401
      if (! ((unsigned int )tok == 1U)) {
#line 1401
        goto while_break___2;
      }
      {
#line 1402
      zshlex();
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1403
    xtok = (enum lextok )51;
#line 1404
    if ((int )*(cmdstack + (cmdsp - 1)) == 5) {
#line 1404
      nc = (unsigned char)6;
    } else {
#line 1404
      nc = (unsigned char)26;
    }
#line 1405
    if ((unsigned int )tok == 59U) {
      {
#line 1406
      usebrace = 0;
#line 1407
      cmdpop();
#line 1408
      cmdpush((int )nc);
#line 1409
      zshlex();
      }
      {
#line 1410
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1410
        eu___0 = ecused;
#line 1410
        par_list(cmplx);
        }
#line 1410
        if (eu___0 == ecused) {
          {
#line 1410
          ecadd(0U);
          }
        }
#line 1410
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1411
      *(ecbuf + pp) = 17U | ((wordcode )(type___0 | (((ecused - 1) - pp) << 2)) << 5);
#line 1412
      incmdpos = 1;
#line 1413
      cmdpop();
      }
    } else
#line 1414
    if ((unsigned int )tok == 41U) {
      {
#line 1415
      usebrace = 1;
#line 1416
      cmdpop();
#line 1417
      cmdpush((int )nc);
#line 1418
      zshlex();
      }
      {
#line 1419
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1419
        eu___1 = ecused;
#line 1419
        par_list(cmplx);
        }
#line 1419
        if (eu___1 == ecused) {
          {
#line 1419
          ecadd(0U);
          }
        }
#line 1419
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1420
      if ((unsigned int )tok != 42U) {
        {
#line 1421
        cmdpop();
#line 1422
        tok = (enum lextok )38;
#line 1422
        ecused = oecused;
        }
#line 1422
        return;
      }
      {
#line 1424
      *(ecbuf + pp) = 17U | ((wordcode )(type___0 | (((ecused - 1) - pp) << 2)) << 5);
#line 1426
      zshlex();
#line 1427
      incmdpos = 1;
      }
#line 1428
      if ((unsigned int )tok == 1U) {
#line 1429
        goto while_break;
      }
      {
#line 1430
      cmdpop();
      }
    } else
#line 1431
    if (! opts[163]) {
      {
#line 1432
      cmdpop();
#line 1433
      tok = (enum lextok )38;
#line 1433
      ecused = oecused;
      }
#line 1433
      return;
    } else {
      {
#line 1435
      cmdpop();
#line 1436
      cmdpush((int )nc);
      }
      {
#line 1437
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 1437
        eu___2 = ecused;
#line 1437
        par_list1(cmplx);
        }
#line 1437
        if (eu___2 == ecused) {
          {
#line 1437
          ecadd(0U);
          }
        }
#line 1437
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1438
      *(ecbuf + pp) = 17U | ((wordcode )(type___0 | (((ecused - 1) - pp) << 2)) << 5);
#line 1439
      incmdpos = 1;
#line 1440
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1443
  cmdpop();
  }
#line 1444
  if ((unsigned int )xtok == 48U) {
#line 1444
    goto _L___0;
  } else
#line 1444
  if ((unsigned int )tok == 48U) {
    _L___0: /* CIL Label */ 
    {
#line 1445
    pp = ecadd((wordcode )0);
#line 1446
    cmdpush(7);
    }
    {
#line 1447
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1447
      if (! ((unsigned int )tok == 1U)) {
#line 1447
        goto while_break___6;
      }
      {
#line 1448
      zshlex();
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1449
    if ((unsigned int )tok == 41U) {
#line 1449
      if (usebrace) {
        {
#line 1450
        zshlex();
        }
        {
#line 1451
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 1451
          eu___3 = ecused;
#line 1451
          par_list(cmplx);
          }
#line 1451
          if (eu___3 == ecused) {
            {
#line 1451
            ecadd(0U);
            }
          }
#line 1451
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1452
        if ((unsigned int )tok != 42U) {
          {
#line 1453
          cmdpop();
#line 1454
          tok = (enum lextok )38;
#line 1454
          ecused = oecused;
          }
#line 1454
          return;
        }
      } else {
#line 1449
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1457
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 1457
        eu___4 = ecused;
#line 1457
        par_list(cmplx);
        }
#line 1457
        if (eu___4 == ecused) {
          {
#line 1457
          ecadd(0U);
          }
        }
#line 1457
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1458
      if ((unsigned int )tok != 51U) {
        {
#line 1459
        cmdpop();
#line 1460
        tok = (enum lextok )38;
#line 1460
        ecused = oecused;
        }
#line 1460
        return;
      }
    }
    {
#line 1463
    incmdpos = 0;
#line 1464
    *(ecbuf + pp) = 17U | ((wordcode )(3 | (((ecused - 1) - pp) << 2)) << 5);
#line 1465
    zshlex();
#line 1466
    cmdpop();
    }
  }
#line 1468
  *(ecbuf + p) = 17U | ((wordcode )(((ecused - 1) - p) << 2) << 5);
#line 1469
  return;
}
}
#line 1477 "/tmp/zsh-5.4.2/Src/parse.c"
static void par_while(int *cmplx ) 
{ 
  int oecused ;
  int p ;
  int type___0 ;
  int tmp ;
  int eu ;
  int eu___0 ;
  int eu___1 ;
  int eu___2 ;

  {
#line 1480
  oecused = ecused;
#line 1481
  if ((unsigned int )tok == 61U) {
#line 1481
    tmp = 1;
  } else {
#line 1481
    tmp = 0;
  }
  {
#line 1481
  type___0 = tmp;
#line 1483
  p = ecadd((wordcode )0);
#line 1484
  zshlex();
  }
  {
#line 1485
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1485
    eu = ecused;
#line 1485
    par_list(cmplx);
    }
#line 1485
    if (eu == ecused) {
      {
#line 1485
      ecadd(0U);
      }
    }
#line 1485
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1486
  incmdpos = 1;
  {
#line 1487
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1487
    if (! ((unsigned int )tok == 1U)) {
#line 1487
      goto while_break___0;
    }
    {
#line 1488
    zshlex();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1489
  if ((unsigned int )tok == 45U) {
    {
#line 1490
    zshlex();
    }
    {
#line 1491
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1491
      eu___0 = ecused;
#line 1491
      par_list(cmplx);
      }
#line 1491
      if (eu___0 == ecused) {
        {
#line 1491
        ecadd(0U);
        }
      }
#line 1491
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1492
    if ((unsigned int )tok != 46U) {
#line 1493
      tok = (enum lextok )38;
#line 1493
      ecused = oecused;
#line 1493
      return;
    }
    {
#line 1494
    incmdpos = 0;
#line 1495
    zshlex();
    }
  } else
#line 1496
  if ((unsigned int )tok == 41U) {
    {
#line 1497
    zshlex();
    }
    {
#line 1498
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1498
      eu___1 = ecused;
#line 1498
      par_list(cmplx);
      }
#line 1498
      if (eu___1 == ecused) {
        {
#line 1498
        ecadd(0U);
        }
      }
#line 1498
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1499
    if ((unsigned int )tok != 42U) {
#line 1500
      tok = (enum lextok )38;
#line 1500
      ecused = oecused;
#line 1500
      return;
    }
    {
#line 1501
    incmdpos = 0;
#line 1502
    zshlex();
    }
  } else
#line 1503
  if (opts[43]) {
    {
#line 1504
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1504
      eu___2 = ecused;
#line 1504
      par_list(cmplx);
      }
#line 1504
      if (eu___2 == ecused) {
        {
#line 1504
        ecadd(0U);
        }
      }
#line 1504
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1505
    if ((unsigned int )tok != 49U) {
#line 1506
      tok = (enum lextok )38;
#line 1506
      ecused = oecused;
#line 1506
      return;
    }
    {
#line 1507
    zshlex();
    }
  } else {
#line 1509
    tok = (enum lextok )38;
#line 1509
    ecused = oecused;
#line 1509
    return;
  }
#line 1511
  *(ecbuf + p) = 14U | ((wordcode )(type___0 | (((ecused - 1) - p) << 1)) << 5);
#line 1512
  return;
}
}
#line 1519 "/tmp/zsh-5.4.2/Src/parse.c"
static void par_repeat(int *cmplx ) 
{ 
  int oecused ;
  int p ;
  wordcode tmp ;
  int eu ;
  int eu___0 ;
  int eu___1 ;
  int eu___2 ;

  {
  {
#line 1523
  oecused = ecused;
#line 1525
  p = ecadd((wordcode )0);
#line 1527
  incmdpos = 0;
#line 1528
  zshlex();
  }
#line 1529
  if ((unsigned int )tok != 34U) {
#line 1530
    tok = (enum lextok )38;
#line 1530
    ecused = oecused;
#line 1530
    return;
  }
  {
#line 1531
  tmp = ecstrcode(tokstr);
#line 1531
  ecadd(tmp);
#line 1532
  incmdpos = 1;
#line 1533
  zshlex();
  }
  {
#line 1534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1534
    if (! ((unsigned int )tok == 1U)) {
#line 1534
      goto while_break;
    }
    {
#line 1535
    zshlex();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1536
  if ((unsigned int )tok == 45U) {
    {
#line 1537
    zshlex();
    }
    {
#line 1538
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1538
      eu = ecused;
#line 1538
      par_list(cmplx);
      }
#line 1538
      if (eu == ecused) {
        {
#line 1538
        ecadd(0U);
        }
      }
#line 1538
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1539
    if ((unsigned int )tok != 46U) {
#line 1540
      tok = (enum lextok )38;
#line 1540
      ecused = oecused;
#line 1540
      return;
    }
    {
#line 1541
    incmdpos = 0;
#line 1542
    zshlex();
    }
  } else
#line 1543
  if ((unsigned int )tok == 41U) {
    {
#line 1544
    zshlex();
    }
    {
#line 1545
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1545
      eu___0 = ecused;
#line 1545
      par_list(cmplx);
      }
#line 1545
      if (eu___0 == ecused) {
        {
#line 1545
        ecadd(0U);
        }
      }
#line 1545
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1546
    if ((unsigned int )tok != 42U) {
#line 1547
      tok = (enum lextok )38;
#line 1547
      ecused = oecused;
#line 1547
      return;
    }
    {
#line 1548
    incmdpos = 0;
#line 1549
    zshlex();
    }
  } else
#line 1550
  if (opts[43]) {
    {
#line 1551
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1551
      eu___1 = ecused;
#line 1551
      par_list(cmplx);
      }
#line 1551
      if (eu___1 == ecused) {
        {
#line 1551
        ecadd(0U);
        }
      }
#line 1551
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1552
    if ((unsigned int )tok != 49U) {
#line 1553
      tok = (enum lextok )38;
#line 1553
      ecused = oecused;
#line 1553
      return;
    }
    {
#line 1554
    zshlex();
    }
  } else
#line 1555
  if (! opts[163]) {
#line 1556
    tok = (enum lextok )38;
#line 1556
    ecused = oecused;
#line 1556
    return;
  } else {
    {
#line 1558
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1558
      eu___2 = ecused;
#line 1558
      par_list1(cmplx);
      }
#line 1558
      if (eu___2 == ecused) {
        {
#line 1558
        ecadd(0U);
        }
      }
#line 1558
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1560
  *(ecbuf + p) = 15U | ((wordcode )((ecused - 1) - p) << 5);
#line 1561
  return;
}
}
#line 1573 "/tmp/zsh-5.4.2/Src/parse.c"
static void par_subsh(int *cmplx , int zsh_construct ) 
{ 
  enum lextok otok ;
  int oecused ;
  int p ;
  int pp ;
  int tmp ;
  int eu ;
  int tmp___0 ;

  {
  {
#line 1576
  otok = tok;
#line 1577
  oecused = ecused;
#line 1579
  p = ecadd((wordcode )0);
#line 1581
  pp = ecadd((wordcode )0);
#line 1582
  zshlex();
#line 1583
  par_list(cmplx);
#line 1584
  ecadd(0U);
  }
#line 1585
  if ((unsigned int )otok == 6U) {
#line 1585
    tmp = 7;
  } else {
#line 1585
    tmp = 42;
  }
#line 1585
  if ((unsigned int )tok != (unsigned int )tmp) {
#line 1586
    tok = (enum lextok )38;
#line 1586
    ecused = oecused;
#line 1586
    return;
  }
  {
#line 1587
  incmdpos = ! zsh_construct;
#line 1588
  zshlex();
  }
#line 1591
  if ((unsigned int )otok == 41U) {
#line 1591
    if ((unsigned int )tok == 34U) {
      {
#line 1591
      tmp___0 = strcmp((char const   *)tokstr, "always");
      }
#line 1591
      if (tmp___0) {
#line 1591
        goto _L___0;
      } else {
#line 1592
        *(ecbuf + pp) = 21U | ((wordcode )((ecused - 1) - pp) << 5);
#line 1593
        incmdpos = 1;
        {
#line 1594
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 1595
          zshlex();
          }
#line 1594
          if (! ((unsigned int )tok == 1U)) {
#line 1594
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 1598
        if ((unsigned int )tok != 41U) {
#line 1599
          tok = (enum lextok )38;
#line 1599
          ecused = oecused;
#line 1599
          return;
        }
        {
#line 1600
        cmdpop();
#line 1601
        cmdpush(31);
#line 1603
        zshlex();
        }
        {
#line 1604
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1604
          eu = ecused;
#line 1604
          par_list(cmplx);
          }
#line 1604
          if (eu == ecused) {
            {
#line 1604
            ecadd(0U);
            }
          }
#line 1604
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1605
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1605
          if (! ((unsigned int )tok == 1U)) {
#line 1605
            goto while_break___1;
          }
          {
#line 1606
          zshlex();
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1608
        incmdpos = 1;
#line 1610
        if ((unsigned int )tok != 42U) {
#line 1611
          tok = (enum lextok )38;
#line 1611
          ecused = oecused;
#line 1611
          return;
        }
        {
#line 1612
        zshlex();
#line 1613
        *(ecbuf + p) = 21U | ((wordcode )((ecused - 1) - p) << 5);
        }
      }
    } else {
#line 1591
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1615
  if ((unsigned int )otok == 6U) {
#line 1615
    *(ecbuf + p) = 8U | ((wordcode )((ecused - 1) - p) << 5);
  } else {
#line 1615
    *(ecbuf + p) = 9U | ((wordcode )((ecused - 1) - p) << 5);
  }
#line 1618
  return;
}
}
#line 1626 "/tmp/zsh-5.4.2/Src/parse.c"
static void par_funcdef(int *cmplx ) 
{ 
  int oecused ;
  int num ;
  int onp ;
  int p ;
  int c ;
  int so ;
  int oecssub ;
  zlong oldlineno ;
  wordcode tmp ;
  int parg ;
  int tmp___0 ;
  wordcode tmp___1 ;

  {
  {
#line 1629
  oecused = ecused;
#line 1629
  num = 0;
#line 1629
  c = 0;
#line 1630
  oecssub = ecssub;
#line 1631
  oldlineno = lineno;
#line 1633
  lineno = (zlong )0;
#line 1634
  nocorrect = 1;
#line 1635
  incmdpos = 0;
#line 1636
  zshlex();
#line 1638
  p = ecadd((wordcode )0);
#line 1639
  ecadd((wordcode )0);
  }
  {
#line 1641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1641
    if (! ((unsigned int )tok == 34U)) {
#line 1641
      goto while_break;
    }
#line 1642
    if ((int )*tokstr == -113) {
#line 1642
      goto _L;
    } else
#line 1642
    if ((int )*tokstr == 123) {
      _L: /* CIL Label */ 
#line 1642
      if (! *(tokstr + 1)) {
#line 1644
        tok = (enum lextok )41;
#line 1645
        goto while_break;
      }
    }
    {
#line 1647
    tmp = ecstrcode(tokstr);
#line 1647
    ecadd(tmp);
#line 1648
    num ++;
#line 1649
    zshlex();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1651
  ecadd((wordcode )0);
#line 1652
  ecadd((wordcode )0);
#line 1653
  ecadd((wordcode )0);
#line 1655
  nocorrect = 0;
#line 1656
  incmdpos = 1;
  }
#line 1657
  if ((unsigned int )tok == 27U) {
    {
#line 1658
    zshlex();
    }
  }
  {
#line 1659
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1659
    if (! ((unsigned int )tok == 1U)) {
#line 1659
      goto while_break___0;
    }
    {
#line 1660
    zshlex();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1662
  ecnfunc ++;
#line 1663
  so = ecsoffs;
#line 1663
  ecssub = so;
#line 1664
  onp = ecnpats;
#line 1665
  ecnpats = 0;
#line 1667
  if ((unsigned int )tok == 41U) {
    {
#line 1668
    zshlex();
#line 1669
    par_list(& c);
    }
#line 1670
    if ((unsigned int )tok != 42U) {
#line 1671
      lineno += oldlineno;
#line 1672
      ecnpats = onp;
#line 1673
      ecssub = oecssub;
#line 1674
      tok = (enum lextok )38;
#line 1674
      ecused = oecused;
#line 1674
      return;
    }
#line 1676
    if (num == 0) {
#line 1678
      incmdpos = 0;
    }
    {
#line 1680
    zshlex();
    }
  } else
#line 1681
  if (! opts[163]) {
#line 1682
    lineno += oldlineno;
#line 1683
    ecnpats = onp;
#line 1684
    ecssub = oecssub;
#line 1685
    tok = (enum lextok )38;
#line 1685
    ecused = oecused;
#line 1685
    return;
  } else {
    {
#line 1687
    par_list1(& c);
    }
  }
  {
#line 1689
  ecadd(0U);
#line 1690
  *(ecbuf + ((p + num) + 2)) = (wordcode )(so - oecssub);
#line 1691
  *(ecbuf + ((p + num) + 3)) = (wordcode )(ecsoffs - so);
#line 1692
  *(ecbuf + ((p + num) + 4)) = (wordcode )ecnpats;
#line 1693
  *(ecbuf + (p + 1)) = (wordcode )num;
#line 1695
  ecnpats = onp;
#line 1696
  ecssub = oecssub;
#line 1697
  ecnfunc ++;
#line 1699
  *(ecbuf + p) = 11U | ((wordcode )((ecused - 1) - p) << 5);
  }
#line 1701
  if (num == 0) {
    {
#line 1703
    tmp___0 = ecadd((wordcode )0);
#line 1703
    parg = tmp___0;
#line 1704
    ecadd((wordcode )0);
    }
    {
#line 1705
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1705
      if (! ((unsigned int )tok == 34U)) {
#line 1705
        goto while_break___1;
      }
      {
#line 1706
      tmp___1 = ecstrcode(tokstr);
#line 1706
      ecadd(tmp___1);
#line 1707
      num ++;
#line 1708
      zshlex();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1710
    if (num > 0) {
#line 1711
      *cmplx = 1;
    }
#line 1712
    *(ecbuf + parg) = (wordcode )(ecused - parg);
#line 1713
    *(ecbuf + (parg + 1)) = (wordcode )num;
  }
#line 1715
  lineno += oldlineno;
#line 1716
  return;
}
}
#line 1723 "/tmp/zsh-5.4.2/Src/parse.c"
static void par_time(void) 
{ 
  int p ;
  int f ;
  int c ;

  {
  {
#line 1726
  c = 0;
#line 1728
  zshlex();
#line 1730
  p = ecadd((wordcode )0);
#line 1731
  ecadd((wordcode )0);
#line 1732
  f = par_sublist2(& c);
  }
#line 1732
  if (f < 0) {
#line 1733
    ecused --;
#line 1734
    *(ecbuf + p) = 10U;
  } else {
    {
#line 1736
    *(ecbuf + p) = 10U | (1U << 5);
#line 1737
    set_sublist_code(p + 1, 0, f, (ecused - 2) - p, c);
    }
  }
#line 1739
  return;
}
}
#line 1746 "/tmp/zsh-5.4.2/Src/parse.c"
static void par_dinbrack(void) 
{ 
  int oecused ;

  {
  {
#line 1749
  oecused = ecused;
#line 1751
  incond = 1;
#line 1752
  incmdpos = 0;
#line 1753
  zshlex();
#line 1754
  par_cond();
  }
#line 1755
  if ((unsigned int )tok != 33U) {
#line 1756
    tok = (enum lextok )38;
#line 1756
    ecused = oecused;
#line 1756
    return;
  }
  {
#line 1757
  incond = 0;
#line 1758
  incmdpos = 1;
#line 1759
  zshlex();
  }
#line 1760
  return;
}
}
#line 1772 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_simple(int *cmplx , int nr ) 
{ 
  int oecused ;
  int isnull ;
  int r ;
  int argc ;
  int p ;
  int isfunc ;
  int sr ;
  int c ;
  int nrediradd ;
  int assignments ;
  int ppost ;
  int is_typeset ;
  char *hasalias ;
  char *tmp ;
  wordcode postassigns ;
  char *ptr___0 ;
  char *name ;
  char *str ;
  char *tmp___0 ;
  wordcode tmp___1 ;
  wordcode tmp___2 ;
  int oldcmdpos ;
  int n ;
  int type2 ;
  size_t tmp___3 ;
  wordcode tmp___4 ;
  int redir_var ;
  char *eptr ;
  size_t tmp___5 ;
  char *ptr___1 ;
  char *toksave ;
  char *idstring ;
  char *tmp___6 ;
  wordcode tmp___7 ;
  char *tmp___8 ;
  wordcode tmp___9 ;
  wordcode tmp___10 ;
  wordcode tmp___11 ;
  char *ptr___2 ;
  char *name___0 ;
  char *str___0 ;
  wordcode tmp___12 ;
  wordcode tmp___13 ;
  wordcode tmp___14 ;
  int n___0 ;
  int parr ;
  wordcode tmp___15 ;
  wordcode tmp___16 ;
  zlong oldlineno ;
  int onp ;
  int so ;
  int oecssub ;
  char *tmp___17 ;
  int c___0 ;
  int ll ;
  int sl ;
  int c___1 ;
  int tmp___18 ;
  int parg ;
  int tmp___19 ;
  wordcode tmp___20 ;

  {
  {
#line 1775
  oecused = ecused;
#line 1775
  isnull = 1;
#line 1775
  argc = 0;
#line 1775
  isfunc = 0;
#line 1775
  sr = 0;
#line 1776
  c = *cmplx;
#line 1776
  assignments = 0;
#line 1776
  ppost = 0;
#line 1776
  is_typeset = 0;
#line 1777
  tmp = input_hasalias();
#line 1777
  hasalias = tmp;
#line 1778
  postassigns = (wordcode )0;
#line 1780
  r = ecused;
  }
  {
#line 1781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1782
    if ((unsigned int )tok == 56U) {
#line 1783
      c = 1;
#line 1783
      *cmplx = c;
#line 1784
      nocorrect = 1;
    } else
#line 1785
    if ((unsigned int )tok == 35U) {
#line 1788
      name = tokstr;
#line 1789
      ptr___0 = tokstr;
      {
#line 1789
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1789
        if (*ptr___0) {
#line 1789
          if ((int )*ptr___0 != -111) {
#line 1789
            if ((int )*ptr___0 != 61) {
#line 1789
              if (! ((int )*ptr___0 != 43)) {
#line 1789
                goto while_break___0;
              }
            } else {
#line 1789
              goto while_break___0;
            }
          } else {
#line 1789
            goto while_break___0;
          }
        } else {
#line 1789
          goto while_break___0;
        }
#line 1789
        ptr___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1792
      if ((int )*ptr___0 == -111) {
        {
#line 1792
        skipparens((char)-111, (char)-110, & ptr___0);
        }
      }
#line 1793
      if ((int )*ptr___0 == 43) {
        {
#line 1794
        tmp___0 = ptr___0;
#line 1794
        ptr___0 ++;
#line 1794
        *tmp___0 = (char )'\000';
#line 1795
        ecadd(5U | ((wordcode )(1 << 1) << 5));
        }
      } else {
        {
#line 1797
        ecadd(5U);
        }
      }
#line 1799
      if ((int )*ptr___0 == 61) {
#line 1800
        *ptr___0 = (char )'\000';
#line 1801
        str = ptr___0 + 1;
      } else {
        {
#line 1803
        equalsplit(tokstr, & str);
        }
      }
#line 1804
      ptr___0 = str;
      {
#line 1804
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1804
        if (! *ptr___0) {
#line 1804
          goto while_break___1;
        }
#line 1810
        if ((int )*(ptr___0 + 1) == -120) {
#line 1810
          if ((int )*ptr___0 == -115) {
#line 1812
            *cmplx = 1;
#line 1813
            goto while_break___1;
          } else
#line 1810
          if ((int )*ptr___0 == -108) {
#line 1812
            *cmplx = 1;
#line 1813
            goto while_break___1;
          } else
#line 1810
          if ((int )*ptr___0 == -106) {
#line 1812
            *cmplx = 1;
#line 1813
            goto while_break___1;
          }
        }
#line 1804
        ptr___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1816
      tmp___1 = ecstrcode(name);
#line 1816
      ecadd(tmp___1);
#line 1817
      tmp___2 = ecstrcode(str);
#line 1817
      ecadd(tmp___2);
#line 1818
      isnull = 0;
#line 1819
      assignments = 1;
      }
    } else
#line 1820
    if ((unsigned int )tok == 36U) {
      {
#line 1821
      oldcmdpos = incmdpos;
#line 1827
      c = 1;
#line 1827
      *cmplx = c;
#line 1828
      p = ecadd((wordcode )0);
#line 1829
      incmdpos = 0;
#line 1830
      tmp___3 = strlen((char const   *)tokstr);
#line 1830
      type2 = (int )(tmp___3 - 1UL);
      }
#line 1830
      if (type2) {
#line 1830
        if ((int )*(tokstr + type2) == 43) {
#line 1831
          *(tokstr + type2) = (char )'\000';
#line 1832
          type2 = 1;
        } else {
#line 1834
          type2 = 0;
        }
      } else {
#line 1834
        type2 = 0;
      }
      {
#line 1835
      tmp___4 = ecstrcode(tokstr);
#line 1835
      ecadd(tmp___4);
#line 1836
      cmdpush(20);
#line 1837
      zshlex();
#line 1838
      n = par_nl_wordlist();
#line 1839
      *(ecbuf + p) = 5U | ((wordcode )((1 | (type2 << 1)) | (n << 2)) << 5);
#line 1840
      cmdpop();
      }
#line 1841
      if ((unsigned int )tok != 7U) {
#line 1842
        tok = (enum lextok )38;
#line 1842
        ecused = oecused;
#line 1842
        return (0);
      }
#line 1843
      incmdpos = oldcmdpos;
#line 1844
      isnull = 0;
#line 1845
      assignments = 1;
    } else {
#line 1847
      goto while_break;
    }
    {
#line 1848
    zshlex();
    }
#line 1849
    if (! hasalias) {
      {
#line 1850
      hasalias = input_hasalias();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1852
  if ((unsigned int )tok == 5U) {
#line 1853
    tok = (enum lextok )38;
#line 1853
    ecused = oecused;
#line 1853
    return (0);
  } else
#line 1852
  if ((unsigned int )tok == 30U) {
#line 1853
    tok = (enum lextok )38;
#line 1853
    ecused = oecused;
#line 1853
    return (0);
  }
  {
#line 1855
  p = ecadd(6U);
  }
  {
#line 1857
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1858
    if ((unsigned int )tok == 34U) {
#line 1858
      goto _L___0;
    } else
#line 1858
    if ((unsigned int )tok == 63U) {
      _L___0: /* CIL Label */ 
#line 1859
      redir_var = 0;
#line 1861
      *cmplx = 1;
#line 1862
      incmdpos = 0;
#line 1864
      if ((unsigned int )tok == 63U) {
#line 1865
        is_typeset = 1;
#line 1865
        intypeset = is_typeset;
      }
#line 1867
      if (! opts[88]) {
#line 1867
        if ((int )*tokstr == -113) {
          {
#line 1870
          tmp___5 = strlen((char const   *)tokstr);
#line 1870
          eptr = (tokstr + tmp___5) - 1;
#line 1871
          ptr___1 = eptr;
          }
#line 1873
          if ((int )*ptr___1 == -112) {
#line 1873
            if ((unsigned long )ptr___1 > (unsigned long )(tokstr + 1)) {
              {
#line 1875
              tmp___8 = itype_end((char const   *)(tokstr + 1), 1 << 7, 0);
              }
#line 1875
              if ((unsigned long )tmp___8 >= (unsigned long )ptr___1) {
                {
#line 1877
                toksave = tokstr;
#line 1878
                tmp___6 = dupstrpfx((char const   *)(tokstr + 1), (int )((eptr - tokstr) - 1L));
#line 1878
                idstring = tmp___6;
#line 1879
                redir_var = 1;
#line 1880
                zshlex();
                }
#line 1881
                if (! hasalias) {
                  {
#line 1882
                  hasalias = input_hasalias();
                  }
                }
#line 1884
                if ((unsigned int )tok >= 10U) {
#line 1884
                  if ((unsigned int )tok <= 24U) {
#line 1884
                    if (tokfd == -1) {
                      {
#line 1886
                      c = 1;
#line 1886
                      *cmplx = c;
#line 1887
                      nrediradd = par_redir(& r, idstring);
#line 1888
                      p += nrediradd;
#line 1889
                      sr += nrediradd;
                      }
                    } else {
                      {
#line 1893
                      tmp___7 = ecstrcode(toksave);
#line 1893
                      ecadd(tmp___7);
#line 1894
                      argc ++;
                      }
                    }
                  } else {
                    {
#line 1893
                    tmp___7 = ecstrcode(toksave);
#line 1893
                    ecadd(tmp___7);
#line 1894
                    argc ++;
                    }
                  }
                } else {
                  {
#line 1893
                  tmp___7 = ecstrcode(toksave);
#line 1893
                  ecadd(tmp___7);
#line 1894
                  argc ++;
                  }
                }
              }
            }
          }
        }
      }
#line 1900
      if (! redir_var) {
#line 1902
        if (postassigns) {
          {
#line 1909
          postassigns ++;
#line 1910
          ecadd(5U | ((wordcode )(1 << 1) << 5));
#line 1911
          tmp___9 = ecstrcode(tokstr);
#line 1911
          ecadd(tmp___9);
#line 1912
          tmp___10 = ecstrcode((char *)"");
#line 1912
          ecadd(tmp___10);
          }
        } else {
          {
#line 1914
          tmp___11 = ecstrcode(tokstr);
#line 1914
          ecadd(tmp___11);
#line 1915
          argc ++;
          }
        }
        {
#line 1917
        zshlex();
        }
#line 1918
        if (! hasalias) {
          {
#line 1919
          hasalias = input_hasalias();
          }
        }
      }
    } else
#line 1921
    if ((unsigned int )tok >= 10U) {
#line 1921
      if ((unsigned int )tok <= 24U) {
        {
#line 1922
        c = 1;
#line 1922
        *cmplx = c;
#line 1923
        nrediradd = par_redir(& r, (char *)((void *)0));
#line 1924
        p += nrediradd;
        }
#line 1925
        if (ppost) {
#line 1926
          ppost += nrediradd;
        }
#line 1927
        sr += nrediradd;
      } else {
#line 1921
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1928
    if ((unsigned int )tok == 35U) {
#line 1931
      tmp___12 = postassigns;
#line 1931
      postassigns ++;
#line 1931
      if (! tmp___12) {
        {
#line 1932
        ppost = ecadd((wordcode )0);
        }
      }
#line 1934
      name___0 = tokstr;
#line 1935
      ptr___2 = tokstr;
      {
#line 1935
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1935
        if (*ptr___2) {
#line 1935
          if ((int )*ptr___2 != -111) {
#line 1935
            if ((int )*ptr___2 != 61) {
#line 1935
              if (! ((int )*ptr___2 != 43)) {
#line 1935
                goto while_break___3;
              }
            } else {
#line 1935
              goto while_break___3;
            }
          } else {
#line 1935
            goto while_break___3;
          }
        } else {
#line 1935
          goto while_break___3;
        }
#line 1935
        ptr___2 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1937
      if ((int )*ptr___2 == -111) {
        {
#line 1937
        skipparens((char)-111, (char)-110, & ptr___2);
        }
      }
      {
#line 1938
      ecadd(5U);
      }
#line 1940
      if ((int )*ptr___2 == 61) {
#line 1941
        *ptr___2 = (char )'\000';
#line 1942
        str___0 = ptr___2 + 1;
      } else {
        {
#line 1944
        equalsplit(tokstr, & str___0);
        }
      }
      {
#line 1945
      tmp___13 = ecstrcode(name___0);
#line 1945
      ecadd(tmp___13);
#line 1946
      tmp___14 = ecstrcode(str___0);
#line 1946
      ecadd(tmp___14);
#line 1947
      zshlex();
      }
#line 1948
      if (! hasalias) {
        {
#line 1949
        hasalias = input_hasalias();
        }
      }
    } else
#line 1950
    if ((unsigned int )tok == 36U) {
#line 1953
      tmp___15 = postassigns;
#line 1953
      postassigns ++;
#line 1953
      if (! tmp___15) {
        {
#line 1954
        ppost = ecadd((wordcode )0);
        }
      }
      {
#line 1956
      parr = ecadd((wordcode )0);
#line 1957
      tmp___16 = ecstrcode(tokstr);
#line 1957
      ecadd(tmp___16);
#line 1958
      cmdpush(20);
#line 1965
      intypeset = 0;
#line 1966
      zshlex();
#line 1967
      n___0 = par_nl_wordlist();
#line 1968
      *(ecbuf + parr) = 5U | ((wordcode )(1 | (n___0 << 2)) << 5);
#line 1969
      cmdpop();
#line 1970
      intypeset = 1;
      }
#line 1971
      if ((unsigned int )tok != 7U) {
#line 1972
        tok = (enum lextok )38;
#line 1972
        ecused = oecused;
#line 1972
        return (0);
      }
      {
#line 1973
      zshlex();
      }
    } else
#line 1974
    if ((unsigned int )tok == 27U) {
#line 1975
      oldlineno = lineno;
#line 1976
      oecssub = ecssub;
#line 1979
      if (! opts[118]) {
#line 1979
        if (argc > 1) {
#line 1980
          tok = (enum lextok )38;
#line 1980
          ecused = oecused;
#line 1980
          return (0);
        }
      }
#line 1982
      if (assignments) {
#line 1983
        tok = (enum lextok )38;
#line 1983
        ecused = oecused;
#line 1983
        return (0);
      } else
#line 1982
      if (postassigns) {
#line 1983
        tok = (enum lextok )38;
#line 1983
        ecused = oecused;
#line 1983
        return (0);
      }
#line 1984
      if (hasalias) {
#line 1984
        if (! opts[2]) {
#line 1984
          if (argc) {
            {
#line 1984
            tmp___17 = input_hasalias();
            }
#line 1984
            if ((unsigned long )hasalias != (unsigned long )tmp___17) {
              {
#line 1986
              zwarn("defining function based on alias `%s\'", hasalias);
#line 1987
              tok = (enum lextok )38;
#line 1987
              ecused = oecused;
              }
#line 1987
              return (0);
            }
          }
        }
      }
      {
#line 1990
      *cmplx = c;
#line 1991
      lineno = (zlong )0;
#line 1992
      incmdpos = 1;
#line 1993
      cmdpush(17);
#line 1994
      zshlex();
      }
      {
#line 1995
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1995
        if (! ((unsigned int )tok == 1U)) {
#line 1995
          goto while_break___4;
        }
        {
#line 1996
        zshlex();
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1998
      ecispace(p + 1, 1);
#line 1999
      *(ecbuf + (p + 1)) = (wordcode )argc;
#line 2000
      ecadd((wordcode )0);
#line 2001
      ecadd((wordcode )0);
#line 2002
      ecadd((wordcode )0);
#line 2004
      ecnfunc ++;
#line 2005
      so = ecsoffs;
#line 2005
      ecssub = so;
#line 2006
      onp = ecnpats;
#line 2007
      ecnpats = 0;
      }
#line 2009
      if ((unsigned int )tok == 41U) {
        {
#line 2010
        c___0 = 0;
#line 2012
        zshlex();
#line 2013
        par_list(& c___0);
        }
#line 2014
        if ((unsigned int )tok != 42U) {
          {
#line 2015
          cmdpop();
#line 2016
          lineno += oldlineno;
#line 2017
          ecnpats = onp;
#line 2018
          ecssub = oecssub;
#line 2019
          tok = (enum lextok )38;
#line 2019
          ecused = oecused;
          }
#line 2019
          return (0);
        }
#line 2021
        if (argc == 0) {
#line 2023
          incmdpos = 0;
        }
        {
#line 2025
        zshlex();
        }
      } else {
        {
#line 2027
        c___1 = 0;
#line 2029
        ll = ecadd((wordcode )0);
#line 2030
        sl = ecadd((wordcode )0);
#line 2031
        ecadd(3U);
#line 2033
        tmp___18 = par_cmd(& c___1, argc == 0);
        }
#line 2033
        if (! tmp___18) {
          {
#line 2034
          cmdpop();
#line 2035
          tok = (enum lextok )38;
#line 2035
          ecused = oecused;
          }
#line 2035
          return (0);
        }
#line 2037
        if (argc == 0) {
#line 2046
          incmdpos = 0;
        }
        {
#line 2049
        set_sublist_code(sl, 0, 0, (ecused - 1) - sl, c___1);
#line 2050
        set_list_code(ll, (1 << 1) | (1 << 4), c___1);
        }
      }
      {
#line 2052
      cmdpop();
#line 2054
      ecadd(0U);
#line 2055
      *(ecbuf + ((p + argc) + 2)) = (wordcode )(so - oecssub);
#line 2056
      *(ecbuf + ((p + argc) + 3)) = (wordcode )(ecsoffs - so);
#line 2057
      *(ecbuf + ((p + argc) + 4)) = (wordcode )ecnpats;
#line 2059
      ecnpats = onp;
#line 2060
      ecssub = oecssub;
#line 2061
      ecnfunc ++;
#line 2063
      *(ecbuf + p) = 11U | ((wordcode )((ecused - 1) - p) << 5);
      }
#line 2065
      if (argc == 0) {
        {
#line 2067
        tmp___19 = ecadd((wordcode )0);
#line 2067
        parg = tmp___19;
#line 2068
        ecadd((wordcode )0);
        }
        {
#line 2069
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2069
          if (! ((unsigned int )tok == 34U)) {
#line 2069
            if ((unsigned int )tok >= 10U) {
#line 2069
              if (! ((unsigned int )tok <= 24U)) {
#line 2069
                goto while_break___5;
              }
            } else {
#line 2069
              goto while_break___5;
            }
          }
#line 2070
          if ((unsigned int )tok == 34U) {
            {
#line 2072
            tmp___20 = ecstrcode(tokstr);
#line 2072
            ecadd(tmp___20);
#line 2073
            argc ++;
#line 2074
            zshlex();
            }
          } else {
            {
#line 2076
            c = 1;
#line 2076
            *cmplx = c;
#line 2077
            nrediradd = par_redir(& r, (char *)((void *)0));
#line 2078
            p += nrediradd;
            }
#line 2079
            if (ppost) {
#line 2080
              ppost += nrediradd;
            }
#line 2081
            sr += nrediradd;
#line 2082
            parg += nrediradd;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2085
        if (argc > 0) {
#line 2086
          *cmplx = 1;
        }
#line 2087
        *(ecbuf + parg) = (wordcode )(ecused - parg);
#line 2088
        *(ecbuf + (parg + 1)) = (wordcode )argc;
      }
#line 2090
      lineno += oldlineno;
#line 2092
      isfunc = 1;
#line 2093
      isnull = 0;
#line 2094
      goto while_break___2;
    } else {
#line 2096
      goto while_break___2;
    }
#line 2097
    isnull = 0;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2099
  if (isnull) {
#line 2099
    if (! (sr + nr)) {
#line 2100
      ecused = p;
#line 2101
      return (0);
    }
  }
#line 2103
  incmdpos = 1;
#line 2104
  intypeset = 0;
#line 2106
  if (! isfunc) {
#line 2107
    if (is_typeset) {
#line 2108
      *(ecbuf + p) = 7U | ((wordcode )argc << 5);
#line 2109
      if (postassigns) {
#line 2110
        *(ecbuf + ppost) = postassigns;
      } else {
        {
#line 2112
        ecadd((wordcode )0);
        }
      }
    } else {
#line 2114
      *(ecbuf + p) = 6U | ((wordcode )argc << 5);
    }
  }
#line 2117
  return (sr + 1);
}
}
#line 2126 "/tmp/zsh-5.4.2/Src/parse.c"
static int redirtab[15]  = 
#line 2126
  {      0,      1,      2,      3, 
        9,      8,      10,      11, 
        13,      14,      4,      5, 
        6,      7,      12};
#line 2145 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_redir(int *rp , char *idstring ) 
{ 
  int r ;
  int type___0 ;
  int fd1 ;
  int oldcmdpos ;
  int oldnc ;
  int ncodes ;
  char *name ;
  struct heredocs **hd ;
  int htype ;
  void *tmp ;

  {
#line 2148
  r = *rp;
#line 2151
  oldcmdpos = incmdpos;
#line 2152
  incmdpos = 0;
#line 2153
  oldnc = nocorrect;
#line 2154
  if ((unsigned int )tok != 14U) {
#line 2154
    if ((unsigned int )tok != 15U) {
#line 2155
      nocorrect = 1;
    }
  }
  {
#line 2156
  type___0 = redirtab[(unsigned int )tok - 10U];
#line 2157
  fd1 = tokfd;
#line 2158
  zshlex();
  }
#line 2159
  if ((unsigned int )tok != 34U) {
#line 2159
    if ((unsigned int )tok != 35U) {
#line 2160
      tok = (enum lextok )38;
#line 2160
      ecused = ecused;
#line 2160
      return (0);
    }
  }
#line 2161
  incmdpos = oldcmdpos;
#line 2162
  nocorrect = oldnc;
#line 2165
  if (fd1 == -1) {
#line 2166
    if (type___0 >= 8) {
#line 2166
      if (type___0 <= 13) {
#line 2166
        fd1 = 0;
      } else {
#line 2166
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2166
    if (type___0 == 16) {
#line 2166
      fd1 = 0;
    } else {
#line 2166
      fd1 = 1;
    }
  }
#line 2168
  name = tokstr;
  {
#line 2172
  if (type___0 == 11) {
#line 2172
    goto case_11;
  }
#line 2172
  if (type___0 == 10) {
#line 2172
    goto case_11;
  }
#line 2216
  if (type___0 == 1) {
#line 2216
    goto case_1;
  }
#line 2216
  if (type___0 == 0) {
#line 2216
    goto case_1;
  }
#line 2223
  if (type___0 == 9) {
#line 2223
    goto case_9;
  }
#line 2230
  if (type___0 == 8) {
#line 2230
    goto case_8;
  }
#line 2170
  goto switch_break;
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 2175
  htype = type___0;
#line 2181
  if (idstring) {
#line 2183
    type___0 |= 32;
#line 2184
    ncodes = 6;
  } else {
#line 2187
    ncodes = 5;
  }
  {
#line 2191
  ecispace(r, ncodes);
#line 2192
  *rp = r + ncodes;
#line 2193
  *(ecbuf + r) = 4U | ((wordcode )(type___0 | 64) << 5);
#line 2194
  *(ecbuf + (r + 1)) = (wordcode )fd1;
  }
#line 2201
  if (idstring) {
    {
#line 2202
    *(ecbuf + (r + 5)) = ecstrcode(idstring);
    }
  }
#line 2204
  hd = & hdocs;
  {
#line 2204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2204
    if (! *hd) {
#line 2204
      goto while_break;
    }
#line 2204
    hd = & (*hd)->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2206
  tmp = zalloc(sizeof(struct heredocs ));
#line 2206
  *hd = (struct heredocs *)tmp;
#line 2207
  (*hd)->next = (struct heredocs *)((void *)0);
#line 2208
  (*hd)->type = htype;
#line 2209
  (*hd)->pc = r;
#line 2210
  (*hd)->str = tokstr;
#line 2212
  zshlex();
  }
#line 2213
  return (ncodes);
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2217
  if ((int )*(tokstr + 0) == -106) {
#line 2217
    if ((int )*(tokstr + 1) == -120) {
#line 2219
      type___0 = 17;
    } else {
#line 2217
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2220
  if ((int )*(tokstr + 0) == -108) {
#line 2220
    if ((int )*(tokstr + 1) == -120) {
#line 2221
      tok = (enum lextok )38;
#line 2221
      ecused = ecused;
#line 2221
      return (0);
    }
  }
#line 2222
  goto switch_break;
  case_9: /* CIL Label */ 
#line 2224
  if ((int )*(tokstr + 0) == -108) {
#line 2224
    if ((int )*(tokstr + 1) == -120) {
#line 2226
      type___0 = 16;
    } else {
#line 2224
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2227
  if ((int )*(tokstr + 0) == -106) {
#line 2227
    if ((int )*(tokstr + 1) == -120) {
#line 2228
      tok = (enum lextok )38;
#line 2228
      ecused = ecused;
#line 2228
      return (0);
    }
  }
#line 2229
  goto switch_break;
  case_8: /* CIL Label */ 
#line 2231
  if ((int )*(tokstr + 0) == -108) {
#line 2231
    goto _L___2;
  } else
#line 2231
  if ((int )*(tokstr + 0) == -106) {
    _L___2: /* CIL Label */ 
#line 2231
    if ((int )*(tokstr + 1) == -120) {
#line 2233
      if ((int )*(tokstr + 0) == -108) {
#line 2233
        type___0 = 16;
      } else {
#line 2233
        type___0 = 17;
      }
    }
  }
#line 2234
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2236
  zshlex();
  }
#line 2240
  if (idstring) {
#line 2242
    type___0 |= 32;
#line 2243
    ncodes = 4;
  } else {
#line 2246
    ncodes = 3;
  }
  {
#line 2248
  ecispace(r, ncodes);
#line 2249
  *rp = r + ncodes;
#line 2250
  *(ecbuf + r) = 4U | ((wordcode )type___0 << 5);
#line 2251
  *(ecbuf + (r + 1)) = (wordcode )fd1;
#line 2252
  *(ecbuf + (r + 2)) = ecstrcode(name);
  }
#line 2253
  if (idstring) {
    {
#line 2254
    *(ecbuf + (r + 3)) = ecstrcode(idstring);
    }
  }
#line 2256
  return (ncodes);
}
}
#line 2260 "/tmp/zsh-5.4.2/Src/parse.c"
void setheredoc(int pc , int type___0 , char *str , char *termstr , char *munged_termstr ) 
{ 


  {
  {
#line 2263
  *(ecbuf + pc) = 4U | ((wordcode )(type___0 | 64) << 5);
#line 2264
  *(ecbuf + (pc + 2)) = ecstrcode(str);
#line 2265
  *(ecbuf + (pc + 3)) = ecstrcode(termstr);
#line 2266
  *(ecbuf + (pc + 4)) = ecstrcode(munged_termstr);
  }
#line 2267
  return;
}
}
#line 2274 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_wordlist(void) 
{ 
  int num ;
  wordcode tmp ;

  {
#line 2277
  num = 0;
  {
#line 2278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2278
    if (! ((unsigned int )tok == 34U)) {
#line 2278
      goto while_break;
    }
    {
#line 2279
    tmp = ecstrcode(tokstr);
#line 2279
    ecadd(tmp);
#line 2280
    num ++;
#line 2281
    zshlex();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2283
  return (num);
}
}
#line 2291 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_nl_wordlist(void) 
{ 
  int num ;
  wordcode tmp ;

  {
#line 2294
  num = 0;
  {
#line 2296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2296
    if (! ((unsigned int )tok == 34U)) {
#line 2296
      if (! ((unsigned int )tok == 1U)) {
#line 2296
        goto while_break;
      }
    }
#line 2297
    if ((unsigned int )tok != 1U) {
      {
#line 2298
      tmp = ecstrcode(tokstr);
#line 2298
      ecadd(tmp);
#line 2299
      num ++;
      }
    }
    {
#line 2301
    zshlex();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2303
  return (num);
}
}
#line 2312 "/tmp/zsh-5.4.2/Src/parse.c"
void (*condlex)(void)  =    & zshlex;
#line 2321 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_cond(void) 
{ 
  int p ;
  int r ;

  {
  {
#line 2324
  p = ecused;
#line 2326
  r = par_cond_1();
  }
  {
#line 2327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2327
    if ((unsigned int )tok == 1U) {
#line 2327
      if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2327
        if (! ((int )*zshlextext != 59)) {
#line 2327
          goto while_break;
        }
      } else {
#line 2327
        goto while_break;
      }
    } else {
#line 2327
      goto while_break;
    }
    {
#line 2328
    (*condlex)();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2329
  if ((unsigned int )tok == 8U) {
    {
#line 2330
    (*condlex)();
    }
    {
#line 2331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2331
      if ((unsigned int )tok == 1U) {
#line 2331
        if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2331
          if (! ((int )*zshlextext != 59)) {
#line 2331
            goto while_break___0;
          }
        } else {
#line 2331
          goto while_break___0;
        }
      } else {
#line 2331
        goto while_break___0;
      }
      {
#line 2332
      (*condlex)();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2333
    ecispace(p, 1);
#line 2334
    par_cond();
#line 2335
    *(ecbuf + p) = 18U | ((wordcode )(2 | (((ecused - 1) - p) << 7)) << 5);
    }
#line 2336
    return (1);
  }
#line 2338
  return (r);
}
}
#line 2346 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_cond_1(void) 
{ 
  int r ;
  int p ;

  {
  {
#line 2349
  p = ecused;
#line 2351
  r = par_cond_2();
  }
  {
#line 2352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2352
    if ((unsigned int )tok == 1U) {
#line 2352
      if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2352
        if (! ((int )*zshlextext != 59)) {
#line 2352
          goto while_break;
        }
      } else {
#line 2352
        goto while_break;
      }
    } else {
#line 2352
      goto while_break;
    }
    {
#line 2353
    (*condlex)();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2354
  if ((unsigned int )tok == 9U) {
    {
#line 2355
    (*condlex)();
    }
    {
#line 2356
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2356
      if ((unsigned int )tok == 1U) {
#line 2356
        if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2356
          if (! ((int )*zshlextext != 59)) {
#line 2356
            goto while_break___0;
          }
        } else {
#line 2356
          goto while_break___0;
        }
      } else {
#line 2356
        goto while_break___0;
      }
      {
#line 2357
      (*condlex)();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2358
    ecispace(p, 1);
#line 2359
    par_cond_1();
#line 2360
    *(ecbuf + p) = 18U | ((wordcode )(1 | (((ecused - 1) - p) << 7)) << 5);
    }
#line 2361
    return (1);
  }
#line 2363
  return (r);
}
}
#line 2372 "/tmp/zsh-5.4.2/Src/parse.c"
static int check_cond(char const   *input , char const   *cond ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2374
  if (! ((int const   )*(input + 0) == 45)) {
#line 2374
    if (! ((int const   )*(input + 0) == -101)) {
#line 2375
      return (0);
    }
  }
  {
#line 2376
  tmp = strcmp(input + 1, cond);
  }
#line 2376
  if (tmp) {
#line 2376
    tmp___0 = 0;
  } else {
#line 2376
    tmp___0 = 1;
  }
#line 2376
  return (tmp___0);
}
}
#line 2388 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_cond_2(void) 
{ 
  char *s1 ;
  char *s2 ;
  char *s3 ;
  int dble ;
  int n_testargs ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int r ;
  size_t tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  enum lextok xtok ;
  int tmp___21 ;
  wordcode tmp___22 ;
  wordcode tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  LinkList tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  LinkList l ;
  LinkList tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;

  {
#line 2392
  dble = 0;
#line 2393
  if ((unsigned long )condlex == (unsigned long )(& testlex)) {
    {
#line 2393
    tmp = arrlen(testargs);
#line 2393
    tmp___0 = tmp + 1;
    }
  } else {
#line 2393
    tmp___0 = 0;
  }
#line 2393
  n_testargs = tmp___0;
#line 2395
  if (n_testargs) {
#line 2397
    if ((unsigned int )tok == 0U) {
      {
#line 2399
      tmp___1 = dupstring("");
#line 2399
      tmp___2 = dupstring("-n");
#line 2399
      tmp___3 = par_cond_double(tmp___2, tmp___1);
      }
#line 2399
      return (tmp___3);
    }
#line 2400
    if (n_testargs == 1) {
      {
#line 2402
      s1 = tokstr;
#line 2403
      (*condlex)();
      }
#line 2405
      if (! opts[131]) {
        {
#line 2405
        tmp___6 = check_cond((char const   *)s1, "t");
        }
#line 2405
        if (tmp___6) {
          {
#line 2406
          tmp___4 = dupstring("1");
#line 2406
          tmp___5 = par_cond_double(s1, tmp___4);
          }
#line 2406
          return (tmp___5);
        }
      }
      {
#line 2407
      tmp___7 = dupstring("-n");
#line 2407
      tmp___8 = par_cond_double(tmp___7, s1);
      }
#line 2407
      return (tmp___8);
    }
#line 2409
    if (n_testargs > 2) {
      {
#line 2412
      tmp___10 = strcmp((char const   *)*testargs, "=");
      }
#line 2412
      if (tmp___10) {
        {
#line 2412
        tmp___11 = strcmp((char const   *)*testargs, "==");
        }
#line 2412
        if (tmp___11) {
          {
#line 2412
          tmp___12 = strcmp((char const   *)*testargs, "!=");
          }
#line 2412
          if (tmp___12) {
#line 2412
            if ((int )*(*testargs) == 45) {
#line 2412
              goto _L___0;
            } else
#line 2412
            if ((int )*(*testargs) == -101) {
              _L___0: /* CIL Label */ 
              {
#line 2412
              tmp___13 = get_cond_num(*testargs + 1);
              }
#line 2412
              if (tmp___13 >= 0) {
                _L: /* CIL Label */ 
                {
#line 2416
                s1 = tokstr;
#line 2417
                (*condlex)();
#line 2418
                s2 = tokstr;
#line 2419
                (*condlex)();
#line 2420
                s3 = tokstr;
#line 2421
                (*condlex)();
#line 2422
                tmp___9 = par_cond_triple(s1, s2, s3);
                }
#line 2422
                return (tmp___9);
              }
            }
          } else {
#line 2412
            goto _L;
          }
        } else {
#line 2412
          goto _L;
        }
      } else {
#line 2412
        goto _L;
      }
    }
  } else {
    {
#line 2430
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2430
      if ((unsigned int )tok == 1U) {
#line 2430
        if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2430
          if (! ((int )*zshlextext != 59)) {
#line 2430
            goto while_break;
          }
        } else {
#line 2430
          goto while_break;
        }
      } else {
#line 2430
        goto while_break;
      }
      {
#line 2431
      (*condlex)();
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2432
  if ((unsigned int )tok == 39U) {
#line 2437
    if (n_testargs > 1) {
      {
#line 2437
      tmp___15 = check_cond((char const   *)*testargs, "a");
      }
#line 2437
      if (! tmp___15) {
        {
#line 2437
        tmp___16 = check_cond((char const   *)*testargs, "o");
        }
#line 2437
        if (! tmp___16) {
          {
#line 2440
          (*condlex)();
#line 2441
          ecadd(18U);
#line 2442
          tmp___14 = par_cond_2();
          }
#line 2442
          return (tmp___14);
        }
      }
    } else {
      {
#line 2440
      (*condlex)();
#line 2441
      ecadd(18U);
#line 2442
      tmp___14 = par_cond_2();
      }
#line 2442
      return (tmp___14);
    }
  }
#line 2445
  if ((unsigned int )tok == 6U) {
    {
#line 2448
    (*condlex)();
    }
    {
#line 2449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2449
      if ((unsigned int )tok == 1U) {
#line 2449
        if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2449
          if (! ((int )*zshlextext != 59)) {
#line 2449
            goto while_break___0;
          }
        } else {
#line 2449
          goto while_break___0;
        }
      } else {
#line 2449
        goto while_break___0;
      }
      {
#line 2450
      (*condlex)();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2451
    r = par_cond();
    }
    {
#line 2452
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2452
      if ((unsigned int )tok == 1U) {
#line 2452
        if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2452
          if (! ((int )*zshlextext != 59)) {
#line 2452
            goto while_break___1;
          }
        } else {
#line 2452
          goto while_break___1;
        }
      } else {
#line 2452
        goto while_break___1;
      }
      {
#line 2453
      (*condlex)();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2454
    if ((unsigned int )tok != 7U) {
#line 2455
      tok = (enum lextok )38;
#line 2455
      ecused = ecused;
#line 2455
      return (0);
    }
    {
#line 2456
    (*condlex)();
    }
#line 2457
    return (r);
  }
#line 2459
  s1 = tokstr;
#line 2460
  if (s1) {
#line 2460
    if ((int )*s1 == 45) {
#line 2460
      goto _L___2;
    } else
#line 2460
    if ((int )*s1 == -101) {
      _L___2: /* CIL Label */ 
#line 2460
      if (! n_testargs) {
#line 2460
        goto _L___1;
      } else {
        {
#line 2460
        tmp___17 = strspn((char const   *)(s1 + 1), "abcdefghknoprstuvwxzLONGS");
        }
#line 2460
        if (tmp___17 == 1UL) {
          _L___1: /* CIL Label */ 
#line 2460
          if (! *(s1 + 2)) {
#line 2460
            tmp___18 = 1;
          } else {
#line 2460
            tmp___18 = 0;
          }
        } else {
#line 2460
          tmp___18 = 0;
        }
      }
    } else {
#line 2460
      tmp___18 = 0;
    }
  } else {
#line 2460
    tmp___18 = 0;
  }
#line 2460
  dble = tmp___18;
#line 2464
  if ((unsigned int )tok != 34U) {
#line 2466
    if (s1) {
#line 2466
      if ((unsigned int )tok != 38U) {
#line 2466
        if (! dble) {
#line 2466
          goto _L___3;
        } else
#line 2466
        if (n_testargs) {
          _L___3: /* CIL Label */ 
          {
#line 2468
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 2468
            (*condlex)();
            }
#line 2468
            if ((unsigned int )tok == 1U) {
#line 2468
              if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2468
                if (! ((int )*zshlextext != 59)) {
#line 2468
                  goto while_break___2;
                }
              } else {
#line 2468
                goto while_break___2;
              }
            } else {
#line 2468
              goto while_break___2;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 2469
          tmp___19 = dupstring("-n");
#line 2469
          tmp___20 = par_cond_double(tmp___19, s1);
          }
#line 2469
          return (tmp___20);
        } else {
#line 2471
          tok = (enum lextok )38;
#line 2471
          ecused = ecused;
#line 2471
          return (0);
        }
      } else {
#line 2471
        tok = (enum lextok )38;
#line 2471
        ecused = ecused;
#line 2471
        return (0);
      }
    } else {
#line 2471
      tok = (enum lextok )38;
#line 2471
      ecused = ecused;
#line 2471
      return (0);
    }
  }
  {
#line 2473
  (*condlex)();
  }
#line 2474
  if (n_testargs == 2) {
#line 2474
    if ((unsigned int )tok != 34U) {
#line 2474
      if (tokstr) {
#line 2474
        if ((int )*(s1 + 0) == 45) {
#line 2480
          tok = (enum lextok )34;
        } else
#line 2474
        if ((int )*(s1 + 0) == -101) {
#line 2480
          tok = (enum lextok )34;
        } else {
#line 2474
          goto _L___6;
        }
      } else {
#line 2474
        goto _L___6;
      }
    } else {
#line 2474
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ 
    {
#line 2482
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2482
      if ((unsigned int )tok == 1U) {
#line 2482
        if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2482
          if (! ((int )*zshlextext != 59)) {
#line 2482
            goto while_break___3;
          }
        } else {
#line 2482
          goto while_break___3;
        }
      } else {
#line 2482
        goto while_break___3;
      }
      {
#line 2483
      (*condlex)();
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 2484
  if ((unsigned int )tok == 14U) {
#line 2484
    goto _L___7;
  } else
#line 2484
  if ((unsigned int )tok == 10U) {
    _L___7: /* CIL Label */ 
#line 2485
    xtok = tok;
    {
#line 2486
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 2486
      (*condlex)();
      }
#line 2486
      if ((unsigned int )tok == 1U) {
#line 2486
        if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2486
          if (! ((int )*zshlextext != 59)) {
#line 2486
            goto while_break___4;
          }
        } else {
#line 2486
          goto while_break___4;
        }
      } else {
#line 2486
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2487
    if ((unsigned int )tok != 34U) {
#line 2488
      tok = (enum lextok )38;
#line 2488
      ecused = ecused;
#line 2488
      return (0);
    }
#line 2489
    s3 = tokstr;
    {
#line 2490
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 2490
      (*condlex)();
      }
#line 2490
      if ((unsigned int )tok == 1U) {
#line 2490
        if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2490
          if (! ((int )*zshlextext != 59)) {
#line 2490
            goto while_break___5;
          }
        } else {
#line 2490
          goto while_break___5;
        }
      } else {
#line 2490
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2491
    if ((unsigned int )xtok == 14U) {
#line 2491
      tmp___21 = 6;
    } else {
#line 2491
      tmp___21 = 7;
    }
    {
#line 2491
    ecadd(18U | ((wordcode )tmp___21 << 5));
#line 2492
    tmp___22 = ecstrcode(s1);
#line 2492
    ecadd(tmp___22);
#line 2493
    tmp___23 = ecstrcode(s3);
#line 2493
    ecadd(tmp___23);
    }
#line 2494
    return (1);
  }
#line 2496
  if ((unsigned int )tok != 34U) {
#line 2501
    if ((unsigned int )tok != 38U) {
#line 2502
      if (! dble) {
        {
#line 2503
        tmp___24 = dupstring("-n");
#line 2503
        tmp___25 = par_cond_double(tmp___24, s1);
        }
#line 2503
        return (tmp___25);
      } else
#line 2502
      if (n_testargs) {
        {
#line 2503
        tmp___24 = dupstring("-n");
#line 2503
        tmp___25 = par_cond_double(tmp___24, s1);
        }
#line 2503
        return (tmp___25);
      } else {
        {
#line 2505
        tmp___26 = newlinklist();
#line 2505
        tmp___27 = par_cond_multi(s1, tmp___26);
        }
#line 2505
        return (tmp___27);
      }
    } else {
#line 2507
      tok = (enum lextok )38;
#line 2507
      ecused = ecused;
#line 2507
      return (0);
    }
  }
#line 2509
  s2 = tokstr;
#line 2510
  if (! n_testargs) {
#line 2511
    if (s2) {
#line 2511
      if ((int )*s2 == 45) {
#line 2511
        goto _L___8;
      } else
#line 2511
      if ((int )*s2 == -101) {
        _L___8: /* CIL Label */ 
#line 2511
        if (! *(s2 + 2)) {
#line 2511
          tmp___28 = 1;
        } else {
#line 2511
          tmp___28 = 0;
        }
      } else {
#line 2511
        tmp___28 = 0;
      }
    } else {
#line 2511
      tmp___28 = 0;
    }
#line 2511
    dble = tmp___28;
  }
#line 2512
  incond ++;
  {
#line 2513
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 2513
    (*condlex)();
    }
#line 2513
    if ((unsigned int )tok == 1U) {
#line 2513
      if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2513
        if (! ((int )*zshlextext != 59)) {
#line 2513
          goto while_break___6;
        }
      } else {
#line 2513
        goto while_break___6;
      }
    } else {
#line 2513
      goto while_break___6;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2514
  incond --;
#line 2515
  if ((unsigned int )tok == 34U) {
#line 2515
    if (! dble) {
#line 2516
      s3 = tokstr;
      {
#line 2517
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 2517
        (*condlex)();
        }
#line 2517
        if ((unsigned int )tok == 1U) {
#line 2517
          if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2517
            if (! ((int )*zshlextext != 59)) {
#line 2517
              goto while_break___7;
            }
          } else {
#line 2517
            goto while_break___7;
          }
        } else {
#line 2517
          goto while_break___7;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 2518
      if ((unsigned int )tok == 34U) {
        {
#line 2519
        tmp___29 = newlinklist();
#line 2519
        l = tmp___29;
#line 2521
        insertlinknode(l, l->list.last, (void *)s2);
#line 2522
        insertlinknode(l, l->list.last, (void *)s3);
        }
        {
#line 2524
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2524
          if (! ((unsigned int )tok == 34U)) {
#line 2524
            goto while_break___8;
          }
          {
#line 2525
          insertlinknode(l, l->list.last, (void *)tokstr);
          }
          {
#line 2526
          while (1) {
            while_continue___9: /* CIL Label */ ;
            {
#line 2526
            (*condlex)();
            }
#line 2526
            if ((unsigned int )tok == 1U) {
#line 2526
              if ((unsigned long )condlex != (unsigned long )(& testlex)) {
#line 2526
                if (! ((int )*zshlextext != 59)) {
#line 2526
                  goto while_break___9;
                }
              } else {
#line 2526
                goto while_break___9;
              }
            } else {
#line 2526
              goto while_break___9;
            }
          }
          while_break___9: /* CIL Label */ ;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 2528
        tmp___30 = par_cond_multi(s1, l);
        }
#line 2528
        return (tmp___30);
      } else {
        {
#line 2530
        tmp___31 = par_cond_triple(s1, s2, s3);
        }
#line 2530
        return (tmp___31);
      }
    } else {
      {
#line 2532
      tmp___32 = par_cond_double(s1, s2);
      }
#line 2532
      return (tmp___32);
    }
  } else {
    {
#line 2532
    tmp___32 = par_cond_double(s1, s2);
    }
#line 2532
    return (tmp___32);
  }
}
}
#line 2536 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_cond_double(char *a , char *b ) 
{ 
  wordcode tmp ;
  wordcode tmp___0 ;
  wordcode tmp___1 ;
  size_t tmp___2 ;

  {
#line 2539
  if ((int )*(a + 0) == 45) {
#line 2539
    goto _L___0;
  } else
#line 2539
  if ((int )*(a + 0) == -101) {
    _L___0: /* CIL Label */ 
#line 2539
    if (! *(a + 1)) {
      _L: /* CIL Label */ 
      {
#line 2540
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 2540
        zwarn("parse error: condition expected: %s", a);
#line 2540
        herrflush();
        }
#line 2540
        if (noerrs != 2) {
#line 2540
          errflag |= 1;
        }
#line 2540
        tok = (enum lextok )38;
#line 2540
        ecused = ecused;
#line 2540
        return (0);
#line 2540
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 2541
    if (! *(a + 2)) {
      {
#line 2541
      tmp___2 = strspn((char const   *)(a + 1), "abcdefgknoprstuvwxzhLONGS");
      }
#line 2541
      if (tmp___2 == 1UL) {
        {
#line 2542
        ecadd(18U | ((wordcode )((int )*(a + 1)) << 5));
#line 2543
        tmp = ecstrcode(b);
#line 2543
        ecadd(tmp);
        }
      } else {
        {
#line 2545
        ecadd(18U | ((wordcode )(18 | (1 << 7)) << 5));
#line 2546
        tmp___0 = ecstrcode(a);
#line 2546
        ecadd(tmp___0);
#line 2547
        tmp___1 = ecstrcode(b);
#line 2547
        ecadd(tmp___1);
        }
      }
    } else {
      {
#line 2545
      ecadd(18U | ((wordcode )(18 | (1 << 7)) << 5));
#line 2546
      tmp___0 = ecstrcode(a);
#line 2546
      ecadd(tmp___0);
#line 2547
      tmp___1 = ecstrcode(b);
#line 2547
      ecadd(tmp___1);
      }
    }
  } else {
#line 2539
    goto _L;
  }
#line 2549
  return (1);
}
}
#line 2556 "/tmp/zsh-5.4.2/Src/parse.c"
static char *condstrs[10]  = 
#line 2556
  {      (char *)"nt",      (char *)"ot",      (char *)"ef",      (char *)"eq", 
        (char *)"ne",      (char *)"lt",      (char *)"gt",      (char *)"le", 
        (char *)"ge",      (char *)((void *)0)};
#line 2553 "/tmp/zsh-5.4.2/Src/parse.c"
static int get_cond_num(char *tst ) 
{ 
  int t0 ;
  int tmp ;

  {
#line 2562
  t0 = 0;
  {
#line 2562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2562
    if (! condstrs[t0]) {
#line 2562
      goto while_break;
    }
    {
#line 2563
    tmp = strcmp((char const   *)condstrs[t0], (char const   *)tst);
    }
#line 2563
    if (! tmp) {
#line 2564
      return (t0);
    }
#line 2562
    t0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2565
  return (-1);
}
}
#line 2569 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_cond_triple(char *a , char *b , char *c ) 
{ 
  int t0 ;
  wordcode tmp ;
  wordcode tmp___0 ;
  int tmp___1 ;
  wordcode tmp___2 ;
  wordcode tmp___3 ;
  int tmp___4 ;
  wordcode tmp___5 ;
  wordcode tmp___6 ;
  int tmp___7 ;
  wordcode tmp___8 ;
  wordcode tmp___9 ;
  wordcode tmp___10 ;
  wordcode tmp___11 ;
  wordcode tmp___12 ;
  wordcode tmp___13 ;
  wordcode tmp___14 ;
  wordcode tmp___15 ;
  wordcode tmp___16 ;
  wordcode tmp___17 ;

  {
#line 2574
  if ((int )*(b + 0) == -115) {
#line 2574
    goto _L___14;
  } else
#line 2574
  if ((int )*(b + 0) == 61) {
    _L___14: /* CIL Label */ 
#line 2574
    if (! *(b + 1)) {
      {
#line 2575
      ecadd(18U | (3U << 5));
#line 2576
      tmp = ecstrcode(a);
#line 2576
      ecadd(tmp);
#line 2577
      tmp___0 = ecstrcode(c);
#line 2577
      ecadd(tmp___0);
#line 2578
      tmp___1 = ecnpats;
#line 2578
      ecnpats ++;
#line 2578
      ecadd((wordcode )tmp___1);
      }
    } else {
#line 2574
      goto _L___13;
    }
  } else
  _L___13: /* CIL Label */ 
#line 2579
  if ((int )*(b + 0) == -115) {
#line 2579
    goto _L___12;
  } else
#line 2579
  if ((int )*(b + 0) == 61) {
    _L___12: /* CIL Label */ 
#line 2579
    if ((int )*(b + 1) == -115) {
#line 2579
      goto _L___11;
    } else
#line 2579
    if ((int )*(b + 1) == 61) {
      _L___11: /* CIL Label */ 
#line 2579
      if (! *(b + 2)) {
        {
#line 2581
        ecadd(18U | (4U << 5));
#line 2582
        tmp___2 = ecstrcode(a);
#line 2582
        ecadd(tmp___2);
#line 2583
        tmp___3 = ecstrcode(c);
#line 2583
        ecadd(tmp___3);
#line 2584
        tmp___4 = ecnpats;
#line 2584
        ecnpats ++;
#line 2584
        ecadd((wordcode )tmp___4);
        }
      } else {
#line 2579
        goto _L___10;
      }
    } else {
#line 2579
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 2585
  if ((int )*(b + 0) == 33) {
#line 2585
    if ((int )*(b + 1) == -115) {
#line 2585
      goto _L___8;
    } else
#line 2585
    if ((int )*(b + 1) == 61) {
      _L___8: /* CIL Label */ 
#line 2585
      if (! *(b + 2)) {
        {
#line 2586
        ecadd(18U | (5U << 5));
#line 2587
        tmp___5 = ecstrcode(a);
#line 2587
        ecadd(tmp___5);
#line 2588
        tmp___6 = ecstrcode(c);
#line 2588
        ecadd(tmp___6);
#line 2589
        tmp___7 = ecnpats;
#line 2589
        ecnpats ++;
#line 2589
        ecadd((wordcode )tmp___7);
        }
      } else {
#line 2585
        goto _L___7;
      }
    } else {
#line 2585
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 2590
  if ((int )*(b + 0) == -115) {
#line 2590
    goto _L___5;
  } else
#line 2590
  if ((int )*(b + 0) == 61) {
    _L___5: /* CIL Label */ 
#line 2590
    if ((int )*(b + 1) == 126) {
#line 2590
      goto _L___4;
    } else
#line 2590
    if ((int )*(b + 1) == -104) {
      _L___4: /* CIL Label */ 
#line 2590
      if (! *(b + 2)) {
        {
#line 2594
        ecadd(18U | (17U << 5));
#line 2595
        tmp___8 = ecstrcode(a);
#line 2595
        ecadd(tmp___8);
#line 2596
        tmp___9 = ecstrcode(c);
#line 2596
        ecadd(tmp___9);
        }
      } else {
#line 2590
        goto _L___3;
      }
    } else {
#line 2590
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 2597
  if ((int )*(b + 0) == 45) {
#line 2597
    goto _L___1;
  } else
#line 2597
  if ((int )*(b + 0) == -101) {
    _L___1: /* CIL Label */ 
    {
#line 2598
    t0 = get_cond_num(b + 1);
    }
#line 2598
    if (t0 > -1) {
      {
#line 2599
      ecadd(18U | ((wordcode )(t0 + 8) << 5));
#line 2600
      tmp___10 = ecstrcode(a);
#line 2600
      ecadd(tmp___10);
#line 2601
      tmp___11 = ecstrcode(c);
#line 2601
      ecadd(tmp___11);
      }
    } else {
      {
#line 2603
      ecadd(18U | (19U << 5));
#line 2604
      tmp___12 = ecstrcode(b);
#line 2604
      ecadd(tmp___12);
#line 2605
      tmp___13 = ecstrcode(a);
#line 2605
      ecadd(tmp___13);
#line 2606
      tmp___14 = ecstrcode(c);
#line 2606
      ecadd(tmp___14);
      }
    }
  } else
#line 2608
  if ((int )*(a + 0) == 45) {
#line 2608
    goto _L___0;
  } else
#line 2608
  if ((int )*(a + 0) == -101) {
    _L___0: /* CIL Label */ 
#line 2608
    if (*(a + 1)) {
      {
#line 2609
      ecadd(18U | ((wordcode )(18 | (2 << 7)) << 5));
#line 2610
      tmp___15 = ecstrcode(a);
#line 2610
      ecadd(tmp___15);
#line 2611
      tmp___16 = ecstrcode(b);
#line 2611
      ecadd(tmp___16);
#line 2612
      tmp___17 = ecstrcode(c);
#line 2612
      ecadd(tmp___17);
      }
    } else {
#line 2608
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 2614
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2614
      zwarn("condition expected: %s", b);
#line 2614
      herrflush();
      }
#line 2614
      if (noerrs != 2) {
#line 2614
        errflag |= 1;
      }
#line 2614
      tok = (enum lextok )38;
#line 2614
      ecused = ecused;
#line 2614
      return (0);
#line 2614
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2616
  return (1);
}
}
#line 2620 "/tmp/zsh-5.4.2/Src/parse.c"
static int par_cond_multi(char *a , LinkList l ) 
{ 
  LinkNode n ;
  int tmp ;
  wordcode tmp___0 ;
  wordcode tmp___1 ;

  {
#line 2623
  if ((int )*(a + 0) == 45) {
#line 2623
    goto _L___0;
  } else
#line 2623
  if ((int )*(a + 0) == -101) {
    _L___0: /* CIL Label */ 
#line 2623
    if (! *(a + 1)) {
      _L: /* CIL Label */ 
      {
#line 2624
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 2624
        zwarn("condition expected: %s", a);
#line 2624
        herrflush();
        }
#line 2624
        if (noerrs != 2) {
#line 2624
          errflag |= 1;
        }
#line 2624
        tok = (enum lextok )38;
#line 2624
        ecused = ecused;
#line 2624
        return (0);
#line 2624
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 2628
      tmp = countlinknodes(l);
#line 2628
      ecadd(18U | ((wordcode )(18 | (tmp << 7)) << 5));
#line 2629
      tmp___0 = ecstrcode(a);
#line 2629
      ecadd(tmp___0);
#line 2630
      n = l->list.first;
      }
      {
#line 2630
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2630
        if (! n) {
#line 2630
          goto while_break___0;
        }
        {
#line 2631
        tmp___1 = ecstrcode((char *)n->dat);
#line 2631
        ecadd(tmp___1);
#line 2630
        n = n->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 2623
    goto _L;
  }
#line 2633
  return (1);
}
}
#line 2637 "/tmp/zsh-5.4.2/Src/parse.c"
static void yyerror(int noerr ) 
{ 
  int t0 ;
  char *t ;

  {
  {
#line 2643
  t = dupstring((char const   *)zshlextext);
  }
#line 2643
  if (t) {
    {
#line 2644
    untokenize(t);
    }
  }
#line 2646
  t0 = 0;
  {
#line 2646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2646
    if (! (t0 != 20)) {
#line 2646
      goto while_break;
    }
#line 2647
    if (! t) {
#line 2648
      goto while_break;
    } else
#line 2647
    if (! *(t + t0)) {
#line 2648
      goto while_break;
    } else
#line 2647
    if ((int )*(t + t0) == 10) {
#line 2648
      goto while_break;
    }
#line 2646
    t0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2649
  if (! (histdone & 2)) {
#line 2649
    if (! (errflag & 2)) {
#line 2650
      if (t0 == 20) {
        {
#line 2651
        zwarn("parse error near `%l...\'", t, 20);
        }
      } else
#line 2652
      if (t0) {
        {
#line 2653
        zwarn("parse error near `%l\'", t, t0);
        }
      } else {
        {
#line 2655
        zwarn("parse error");
        }
      }
    }
  }
#line 2657
  if (! noerr) {
#line 2657
    if (noerrs != 2) {
#line 2658
      errflag |= 1;
    }
  }
#line 2659
  return;
}
}
#line 2672 "/tmp/zsh-5.4.2/Src/parse.c"
Eprog dupeprog(Eprog p , int heap ) 
{ 
  Eprog r ;
  int i ;
  Patprog *pp ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  Patprog *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 2679
  if ((unsigned long )p == (unsigned long )(& dummy_eprog)) {
#line 2680
    return (p);
  }
#line 2682
  if (heap) {
    {
#line 2682
    tmp = zhalloc(sizeof(*r));
#line 2682
    r = (Eprog )tmp;
    }
  } else {
    {
#line 2682
    tmp___0 = zalloc(sizeof(*r));
#line 2682
    r = (Eprog )tmp___0;
    }
  }
#line 2683
  if (heap) {
#line 2683
    tmp___1 = 2;
  } else {
#line 2683
    tmp___1 = 1;
  }
#line 2683
  r->flags = tmp___1 | (p->flags & 8);
#line 2684
  r->dump = (FuncDump )((void *)0);
#line 2685
  r->len = p->len;
#line 2686
  r->npats = p->npats;
#line 2692
  if (heap) {
#line 2692
    r->nref = -1;
  } else {
#line 2692
    r->nref = 1;
  }
#line 2693
  if (heap) {
    {
#line 2693
    tmp___3 = hcalloc((size_t )r->len);
#line 2693
    tmp___2 = (Patprog *)tmp___3;
    }
  } else {
    {
#line 2693
    tmp___4 = zshcalloc((size_t )r->len);
#line 2693
    tmp___2 = (Patprog *)tmp___4;
    }
  }
  {
#line 2693
  r->pats = tmp___2;
#line 2693
  pp = tmp___2;
#line 2695
  r->prog = (Wordcode )(r->pats + r->npats);
#line 2696
  r->strs = (char *)r->prog + (p->strs - (char *)p->prog);
#line 2697
  memcpy((void */* __restrict  */)r->prog, (void const   */* __restrict  */)p->prog,
         (unsigned long )r->len - (unsigned long )p->npats * sizeof(Patprog ));
#line 2698
  r->shf = (Shfunc )((void *)0);
#line 2700
  i = r->npats;
  }
  {
#line 2700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2700
    tmp___5 = i;
#line 2700
    i --;
#line 2700
    if (! tmp___5) {
#line 2700
      goto while_break;
    }
#line 2701
    *pp = (Patprog )1;
#line 2700
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2703
  return (r);
}
}
#line 2718 "/tmp/zsh-5.4.2/Src/parse.c"
void useeprog(Eprog p ) 
{ 


  {
#line 2721
  if (p) {
#line 2721
    if ((unsigned long )p != (unsigned long )(& dummy_eprog)) {
#line 2721
      if (p->nref >= 0) {
#line 2722
        (p->nref) ++;
      }
    }
  }
#line 2723
  return;
}
}
#line 2728 "/tmp/zsh-5.4.2/Src/parse.c"
void freeeprog(Eprog p ) 
{ 
  int i ;
  Patprog *pp ;
  int tmp ;

  {
#line 2734
  if (p) {
#line 2734
    if ((unsigned long )p != (unsigned long )(& dummy_eprog)) {
#line 2742
      if (p->nref > 0) {
#line 2742
        (p->nref) --;
#line 2742
        if (! p->nref) {
#line 2743
          i = p->npats;
#line 2743
          pp = p->pats;
          {
#line 2743
          while (1) {
            while_continue: /* CIL Label */ ;
#line 2743
            tmp = i;
#line 2743
            i --;
#line 2743
            if (! tmp) {
#line 2743
              goto while_break;
            }
            {
#line 2744
            freepatprog(*pp);
#line 2743
            pp ++;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 2745
          if (p->dump) {
            {
#line 2746
            decrdumpcount(p->dump);
#line 2747
            zfree((void *)p->pats, (int )((unsigned long )p->npats * sizeof(Patprog )));
            }
          } else {
            {
#line 2749
            zfree((void *)p->pats, p->len);
            }
          }
          {
#line 2750
          zfree((void *)p, (int )sizeof(*p));
          }
        }
      }
    }
  }
#line 2753
  return;
}
}
#line 2759 "/tmp/zsh-5.4.2/Src/parse.c"
static char buf___1[4]  ;
#line 2756 "/tmp/zsh-5.4.2/Src/parse.c"
char *ecgetstr(Estate s , int dup___0 , int *tokflag ) 
{ 
  wordcode c ;
  Wordcode tmp ;
  char *r ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 2760
  tmp = s->pc;
#line 2760
  (s->pc) ++;
#line 2760
  c = *tmp;
#line 2763
  if (c == 6U) {
#line 2764
    r = (char *)"";
  } else
#line 2763
  if (c == 7U) {
#line 2764
    r = (char *)"";
  } else
#line 2765
  if (c & 2U) {
    {
#line 2766
    buf___1[0] = (char )((c >> 3) & 255U);
#line 2767
    buf___1[1] = (char )((c >> 11) & 255U);
#line 2768
    buf___1[2] = (char )((c >> 19) & 255U);
#line 2769
    buf___1[3] = (char )'\000';
#line 2770
    r = dupstring((char const   *)(buf___1));
#line 2771
    dup___0 = 0;
    }
  } else {
#line 2773
    r = s->strs + (c >> 2);
  }
#line 2775
  if (tokflag) {
#line 2776
    *tokflag = (int )(c & 1U);
  }
#line 2788
  if (dup___0 == 1) {
    {
#line 2788
    tmp___0 = dupstring((char const   *)r);
#line 2788
    tmp___1 = tmp___0;
    }
  } else
#line 2788
  if (dup___0) {
#line 2788
    if (c & 1U) {
      {
#line 2788
      tmp___0 = dupstring((char const   *)r);
#line 2788
      tmp___1 = tmp___0;
      }
    } else {
#line 2788
      tmp___1 = r;
    }
  } else {
#line 2788
    tmp___1 = r;
  }
#line 2788
  return (tmp___1);
}
}
#line 2795 "/tmp/zsh-5.4.2/Src/parse.c"
static char buf___2[4]  ;
#line 2792 "/tmp/zsh-5.4.2/Src/parse.c"
char *ecrawstr(Eprog p , Wordcode pc , int *tokflag ) 
{ 
  wordcode c ;

  {
#line 2796
  c = *pc;
#line 2798
  if (c == 6U) {
#line 2798
    goto _L;
  } else
#line 2798
  if (c == 7U) {
    _L: /* CIL Label */ 
#line 2799
    if (tokflag) {
#line 2800
      *tokflag = (int )(c & 1U);
    }
#line 2801
    return ((char *)"");
  } else
#line 2802
  if (c & 2U) {
#line 2803
    buf___2[0] = (char )((c >> 3) & 255U);
#line 2804
    buf___2[1] = (char )((c >> 11) & 255U);
#line 2805
    buf___2[2] = (char )((c >> 19) & 255U);
#line 2806
    buf___2[3] = (char )'\000';
#line 2807
    if (tokflag) {
#line 2808
      *tokflag = (int )(c & 1U);
    }
#line 2809
    return (buf___2);
  } else {
#line 2811
    if (tokflag) {
#line 2812
      *tokflag = (int )(c & 1U);
    }
#line 2813
    return (p->strs + (c >> 2));
  }
}
}
#line 2818 "/tmp/zsh-5.4.2/Src/parse.c"
char **ecgetarr(Estate s , int num , int dup___0 , int *tokflag ) 
{ 
  char **ret ;
  char **rp ;
  int tf ;
  int tmp ;
  void *tmp___0 ;
  char **tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2822
  tf = 0;
#line 2822
  tmp = 0;
#line 2824
  tmp___0 = zhalloc((unsigned long )(num + 1) * sizeof(char *));
#line 2824
  rp = (char **)tmp___0;
#line 2824
  ret = rp;
  }
  {
#line 2826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2826
    tmp___2 = num;
#line 2826
    num --;
#line 2826
    if (! tmp___2) {
#line 2826
      goto while_break;
    }
    {
#line 2827
    tmp___1 = rp;
#line 2827
    rp ++;
#line 2827
    *tmp___1 = ecgetstr(s, dup___0, & tmp);
#line 2828
    tf |= tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2830
  *rp = (char *)((void *)0);
#line 2831
  if (tokflag) {
#line 2832
    *tokflag = tf;
  }
#line 2834
  return (ret);
}
}
#line 2838 "/tmp/zsh-5.4.2/Src/parse.c"
LinkList ecgetlist(Estate s , int num , int dup___0 , int *tokflag ) 
{ 
  LinkList ret ;
  int i ;
  int tf ;
  int tmp ;
  char *tmp___0 ;

  {
#line 2841
  if (num) {
    {
#line 2843
    tf = 0;
#line 2843
    tmp = 0;
#line 2845
    ret = newsizedlist(num);
#line 2846
    i = 0;
    }
    {
#line 2846
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2846
      if (! (i < num)) {
#line 2846
        goto while_break;
      }
      {
#line 2847
      tmp___0 = ecgetstr(s, dup___0, & tmp);
#line 2847
      (ret->list.first + i)->dat = (void *)tmp___0;
#line 2848
      tf |= tmp;
#line 2846
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2850
    if (tokflag) {
#line 2851
      *tokflag = tf;
    }
#line 2852
    return (ret);
  }
#line 2854
  if (tokflag) {
#line 2855
    *tokflag = 0;
  }
#line 2856
  return ((LinkList )((void *)0));
}
}
#line 2860 "/tmp/zsh-5.4.2/Src/parse.c"
LinkList ecgetredirs(Estate s ) 
{ 
  LinkList ret ;
  LinkList tmp ;
  wordcode code ;
  Wordcode tmp___0 ;
  Redir r ;
  void *tmp___1 ;
  Wordcode tmp___2 ;
  Wordcode tmp___3 ;

  {
  {
#line 2863
  tmp = newlinklist();
#line 2863
  ret = tmp;
#line 2864
  tmp___0 = s->pc;
#line 2864
  (s->pc) ++;
#line 2864
  code = *tmp___0;
  }
  {
#line 2866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2866
    if (! ((code & (wordcode )((1 << 5) - 1)) == 4U)) {
#line 2866
      goto while_break;
    }
    {
#line 2867
    tmp___1 = zhalloc(sizeof(*r));
#line 2867
    r = (Redir )tmp___1;
#line 2869
    r->type = (int )((code >> 5) & 31U);
#line 2870
    tmp___2 = s->pc;
#line 2870
    (s->pc) ++;
#line 2870
    r->fd1 = (int )*tmp___2;
#line 2871
    r->name = ecgetstr(s, 1, (int *)((void *)0));
    }
#line 2872
    if ((int )((code >> 5) & 64U)) {
      {
#line 2873
      r->flags = 1;
#line 2874
      r->here_terminator = ecgetstr(s, 1, (int *)((void *)0));
#line 2875
      r->munged_here_terminator = ecgetstr(s, 1, (int *)((void *)0));
      }
    } else {
#line 2877
      r->flags = 0;
#line 2878
      r->here_terminator = (char *)((void *)0);
#line 2879
      r->munged_here_terminator = (char *)((void *)0);
    }
#line 2881
    if ((int )((code >> 5) & 32U)) {
      {
#line 2882
      r->varid = ecgetstr(s, 1, (int *)((void *)0));
      }
    } else {
#line 2884
      r->varid = (char *)((void *)0);
    }
    {
#line 2886
    insertlinknode(ret, ret->list.last, (void *)r);
#line 2888
    tmp___3 = s->pc;
#line 2888
    (s->pc) ++;
#line 2888
    code = *tmp___3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2890
  (s->pc) --;
#line 2892
  return (ret);
}
}
#line 2904 "/tmp/zsh-5.4.2/Src/parse.c"
Eprog eccopyredirs(Estate s ) 
{ 
  Wordcode pc ;
  wordcode code ;
  int ncode ;
  int ncodes ;
  int r ;
  int tmp ;
  int tmp___0 ;
  Wordcode tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  Eprog tmp___10 ;

  {
#line 2907
  pc = s->pc;
#line 2908
  code = *pc;
#line 2909
  ncodes = 0;
#line 2911
  if ((code & (wordcode )((1 << 5) - 1)) != 4U) {
#line 2912
    return ((Eprog )((void *)0));
  }
  {
#line 2914
  init_parse();
  }
  {
#line 2916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2916
    if (! ((code & (wordcode )((1 << 5) - 1)) == 4U)) {
#line 2916
      goto while_break;
    }
#line 2924
    if ((int )((code >> 5) & 64U)) {
#line 2925
      ncode = 5;
    } else {
#line 2927
      ncode = 3;
    }
#line 2928
    if ((int )((code >> 5) & 32U)) {
#line 2929
      ncode ++;
    }
#line 2930
    pc += ncode;
#line 2931
    ncodes += ncode;
#line 2932
    code = *pc;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2934
  r = ecused;
#line 2935
  ecispace(r, ncodes);
#line 2937
  code = *(s->pc);
  }
  {
#line 2938
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2938
    if (! ((code & (wordcode )((1 << 5) - 1)) == 4U)) {
#line 2938
      goto while_break___0;
    }
    {
#line 2939
    (s->pc) ++;
#line 2941
    tmp = r;
#line 2941
    r ++;
#line 2941
    *(ecbuf + tmp) = code;
#line 2943
    tmp___0 = r;
#line 2943
    r ++;
#line 2943
    tmp___1 = s->pc;
#line 2943
    (s->pc) ++;
#line 2943
    *(ecbuf + tmp___0) = *tmp___1;
#line 2946
    tmp___2 = r;
#line 2946
    r ++;
#line 2946
    tmp___3 = ecgetstr(s, 0, (int *)((void *)0));
#line 2946
    *(ecbuf + tmp___2) = ecstrcode(tmp___3);
    }
#line 2947
    if ((int )((code >> 5) & 64U)) {
      {
#line 2950
      tmp___4 = r;
#line 2950
      r ++;
#line 2950
      tmp___5 = ecgetstr(s, 0, (int *)((void *)0));
#line 2950
      *(ecbuf + tmp___4) = ecstrcode(tmp___5);
#line 2952
      tmp___6 = r;
#line 2952
      r ++;
#line 2952
      tmp___7 = ecgetstr(s, 0, (int *)((void *)0));
#line 2952
      *(ecbuf + tmp___6) = ecstrcode(tmp___7);
      }
    }
#line 2954
    if ((int )((code >> 5) & 32U)) {
      {
#line 2955
      tmp___8 = r;
#line 2955
      r ++;
#line 2955
      tmp___9 = ecgetstr(s, 0, (int *)((void *)0));
#line 2955
      *(ecbuf + tmp___8) = ecstrcode(tmp___9);
      }
    }
#line 2957
    code = *(s->pc);
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2961
  tmp___10 = bld_eprog(0);
  }
#line 2961
  return (tmp___10);
}
}
#line 2967 "/tmp/zsh-5.4.2/Src/parse.c"
static wordcode dummy_eprog_code  ;
#line 2970 "/tmp/zsh-5.4.2/Src/parse.c"
void init_eprog(void) 
{ 


  {
#line 2973
  dummy_eprog_code = 0U;
#line 2974
  dummy_eprog.len = (int )sizeof(wordcode );
#line 2975
  dummy_eprog.prog = & dummy_eprog_code;
#line 2976
  dummy_eprog.strs = (char *)((void *)0);
#line 2977
  return;
}
}
#line 3068 "/tmp/zsh-5.4.2/Src/parse.c"
static FDHead dump_find_func(Wordcode h , char *name ) 
{ 
  FDHead n ;
  FDHead e ;
  int tmp ;

  {
#line 3071
  e = (FDHead )(h + *(h + 12));
#line 3073
  n = (FDHead )(h + 12);
  {
#line 3073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3073
    if (! ((unsigned long )n < (unsigned long )e)) {
#line 3073
      goto while_break;
    }
    {
#line 3074
    tmp = strcmp((char const   *)name, (char const   *)((char *)(n + 1) + (n->flags >> 2)));
    }
#line 3074
    if (! tmp) {
#line 3075
      return (n);
    }
#line 3073
    n = (FDHead )((Wordcode )n + n->hlen);
  }
  while_break: /* CIL Label */ ;
  }
#line 3077
  return ((FDHead )((void *)0));
}
}
#line 3081 "/tmp/zsh-5.4.2/Src/parse.c"
int bin_zcompile(char *nam , char **args , Options ops , int func  __attribute__((__unused__)) ) 
{ 
  int map ;
  int flags ;
  int ret ;
  char *dump ;
  int tmp ;
  Wordcode f ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  FDHead tmp___4 ;
  FDHead h ;
  FDHead e ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  sigset_t oset ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  sigset_t oset___0 ;

  {
#line 3087
  if ((int )ops->ind[107] != 0) {
#line 3087
    if ((int )ops->ind[122] != 0) {
      {
#line 3092
      zwarnnam((char const   *)nam, "illegal combination of options");
      }
#line 3093
      return (1);
    } else {
#line 3087
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 3087
  if ((int )ops->ind[82] != 0) {
#line 3087
    if ((int )ops->ind[77] != 0) {
      {
#line 3092
      zwarnnam((char const   *)nam, "illegal combination of options");
      }
#line 3093
      return (1);
    } else {
#line 3087
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3087
  if ((int )ops->ind[99] != 0) {
#line 3087
    if ((int )ops->ind[85] != 0) {
      {
#line 3092
      zwarnnam((char const   *)nam, "illegal combination of options");
      }
#line 3093
      return (1);
    } else
#line 3087
    if ((int )ops->ind[107] != 0) {
      {
#line 3092
      zwarnnam((char const   *)nam, "illegal combination of options");
      }
#line 3093
      return (1);
    } else
#line 3087
    if ((int )ops->ind[122] != 0) {
      {
#line 3092
      zwarnnam((char const   *)nam, "illegal combination of options");
      }
#line 3093
      return (1);
    } else {
#line 3087
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3087
  if (! ((int )ops->ind[99] != 0)) {
#line 3087
    if (! ((int )ops->ind[97] != 0)) {
#line 3087
      if ((int )ops->ind[109] != 0) {
        {
#line 3092
        zwarnnam((char const   *)nam, "illegal combination of options");
        }
#line 3093
        return (1);
      }
    }
  }
#line 3095
  if ((int )ops->ind[99] != 0) {
#line 3095
    goto _L___2;
  } else
#line 3095
  if ((int )ops->ind[97] != 0) {
    _L___2: /* CIL Label */ 
#line 3095
    if (opts[96]) {
      {
#line 3096
      zwarnnam((char const   *)nam, "functions will use zsh style autoloading");
      }
    }
  }
#line 3098
  if ((int )ops->ind[107] != 0) {
#line 3098
    flags = 1;
  } else {
#line 3098
    if ((int )ops->ind[122] != 0) {
#line 3098
      tmp = 2;
    } else {
#line 3098
      tmp = 0;
    }
#line 3098
    flags = tmp;
  }
#line 3101
  if ((int )ops->ind[116] != 0) {
#line 3104
    if (! *args) {
      {
#line 3105
      zwarnnam((char const   *)nam, "too few arguments");
      }
#line 3106
      return (1);
    }
    {
#line 3108
    tmp___3 = strsfx((char *)".zwc", *args);
    }
#line 3108
    if (tmp___3) {
#line 3108
      tmp___2 = *args;
    } else {
      {
#line 3108
      tmp___1 = dyncat((char const   *)*args, ".zwc");
#line 3108
      tmp___2 = tmp___1;
      }
    }
    {
#line 3108
    f = load_dump_header(nam, tmp___2, 1);
    }
#line 3108
    if (! f) {
#line 3110
      return (1);
    }
#line 3112
    if (*(args + 1)) {
#line 3113
      args ++;
      {
#line 3113
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3113
        if (! *args) {
#line 3113
          goto while_break;
        }
        {
#line 3114
        tmp___4 = dump_find_func(f, *args);
        }
#line 3114
        if (! tmp___4) {
#line 3115
          return (1);
        }
#line 3113
        args ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 3116
      return (0);
    } else {
#line 3118
      e = (FDHead )(f + *(f + 12));
#line 3120
      if ((wordcode )*((unsigned char *)(f + 1) + 0) & 1U) {
#line 3120
        tmp___5 = "mapped";
      } else {
#line 3120
        tmp___5 = "read";
      }
      {
#line 3120
      printf((char const   */* __restrict  */)"zwc file (%s) for zsh-%s\n", tmp___5,
             (char *)(f + 2));
#line 3122
      h = (FDHead )(f + 12);
      }
      {
#line 3122
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3122
        if (! ((unsigned long )h < (unsigned long )e)) {
#line 3122
          goto while_break___0;
        }
        {
#line 3123
        printf((char const   */* __restrict  */)"%s\n", (char *)(h + 1));
#line 3122
        h = (FDHead )((Wordcode )h + h->hlen);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3124
      return (0);
    }
  }
#line 3127
  if (! *args) {
    {
#line 3128
    zwarnnam((char const   *)nam, "too few arguments");
    }
#line 3129
    return (1);
  }
#line 3131
  if ((int )ops->ind[77] != 0) {
#line 3131
    map = 2;
  } else {
#line 3131
    if ((int )ops->ind[82] != 0) {
#line 3131
      tmp___6 = 0;
    } else {
#line 3131
      tmp___6 = 1;
    }
#line 3131
    map = tmp___6;
  }
#line 3133
  if (! *(args + 1)) {
#line 3133
    if (! ((int )ops->ind[99] != 0)) {
#line 3133
      if (! ((int )ops->ind[97] != 0)) {
        {
#line 3134
        queueing_enabled ++;
#line 3135
        tmp___7 = dyncat((char const   *)*args, ".zwc");
#line 3135
        ret = build_dump(nam, tmp___7, args, (int )ops->ind[85] != 0, map, flags);
        }
        {
#line 3137
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3137
          queueing_enabled --;
#line 3137
          if (! queueing_enabled) {
            {
#line 3137
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 3137
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 3137
                if (! (queue_front != queue_rear)) {
#line 3137
                  goto while_break___3;
                }
                {
#line 3137
                queue_front = (queue_front + 1) % 128;
#line 3137
                oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3137
                zhandler(signal_queue[queue_front]);
#line 3137
                signal_setmask(oset);
                }
              }
              while_break___3: /* CIL Label */ ;
              }
#line 3137
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
#line 3137
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3138
        return (ret);
      }
    }
  }
  {
#line 3140
  tmp___10 = strsfx((char *)".zwc", *args);
  }
#line 3140
  if (tmp___10) {
#line 3140
    dump = *args;
  } else {
    {
#line 3140
    tmp___9 = dyncat((char const   *)*args, ".zwc");
#line 3140
    dump = tmp___9;
    }
  }
#line 3142
  queueing_enabled ++;
#line 3143
  if ((int )ops->ind[99] != 0) {
#line 3143
    goto _L___3;
  } else
#line 3143
  if ((int )ops->ind[97] != 0) {
    _L___3: /* CIL Label */ 
#line 3143
    if ((int )ops->ind[99] != 0) {
#line 3143
      tmp___11 = 1;
    } else {
#line 3143
      tmp___11 = 0;
    }
#line 3143
    if ((int )ops->ind[97] != 0) {
#line 3143
      tmp___12 = 2;
    } else {
#line 3143
      tmp___12 = 0;
    }
    {
#line 3143
    tmp___13 = build_cur_dump(nam, dump, args + 1, (int )ops->ind[109] != 0, map,
                              tmp___11 | tmp___12);
#line 3143
    ret = tmp___13;
    }
  } else {
    {
#line 3143
    tmp___14 = build_dump(nam, dump, args + 1, (int )ops->ind[85] != 0, map, flags);
#line 3143
    ret = tmp___14;
    }
  }
  {
#line 3148
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 3148
    queueing_enabled --;
#line 3148
    if (! queueing_enabled) {
      {
#line 3148
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 3148
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 3148
          if (! (queue_front != queue_rear)) {
#line 3148
            goto while_break___6;
          }
          {
#line 3148
          queue_front = (queue_front + 1) % 128;
#line 3148
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 3148
          zhandler(signal_queue[queue_front]);
#line 3148
          signal_setmask(oset___0);
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 3148
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 3148
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 3150
  return (ret);
}
}
#line 3157 "/tmp/zsh-5.4.2/Src/parse.c"
static Wordcode load_dump_header(char *nam , char *name , int err ) 
{ 
  int fd ;
  int v ;
  wordcode buf___7[13] ;
  int len ;
  Wordcode head ;
  void *tmp ;
  int o ;
  __off_t tmp___0 ;
  ssize_t tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 3160
  v = 1;
#line 3163
  fd = open((char const   *)name, 0);
  }
#line 3163
  if (fd < 0) {
#line 3164
    if (err) {
      {
#line 3165
      zwarnnam((char const   *)nam, "can\'t open zwc file: %s", name);
      }
    }
#line 3166
    return ((Wordcode )((void *)0));
  }
  {
#line 3168
  tmp___4 = read(fd, (void *)(buf___7), 13UL * sizeof(wordcode ));
  }
#line 3168
  if ((unsigned long )tmp___4 != 13UL * sizeof(wordcode )) {
#line 3168
    goto _L;
  } else {
#line 3168
    if (buf___7[0] != 67438087U) {
#line 3168
      if (buf___7[0] != 117835012U) {
#line 3168
        tmp___5 = 1;
      } else {
#line 3168
        tmp___5 = 0;
      }
    } else {
#line 3168
      tmp___5 = 0;
    }
#line 3168
    v = tmp___5;
#line 3168
    if (v) {
#line 3168
      goto _L;
    } else {
      {
#line 3168
      tmp___6 = strcmp((char const   *)((char *)(buf___7 + 2)), "5.4.2");
      }
#line 3168
      if (tmp___6) {
        _L: /* CIL Label */ 
#line 3172
        if (err) {
#line 3173
          if (! v) {
            {
#line 3174
            zwarnnam((char const   *)nam, "zwc file has wrong version (zsh-%s): %s",
                     (char *)(buf___7 + 2), name);
            }
          } else {
            {
#line 3177
            zwarnnam((char const   *)nam, "invalid zwc file: %s", name);
            }
          }
        }
        {
#line 3179
        close(fd);
        }
#line 3180
        return ((Wordcode )((void *)0));
      } else {
#line 3185
        if (buf___7[0] == 67438087U) {
          {
#line 3186
          len = (int )((unsigned long )buf___7[12] * sizeof(wordcode ));
#line 3187
          tmp = zhalloc((size_t )len);
#line 3187
          head = (Wordcode )tmp;
          }
        } else {
          {
#line 3190
          o = (int )(((wordcode )*((unsigned char *)(buf___7 + 1) + 1) + ((wordcode )*((unsigned char *)(buf___7 + 1) + 2) << 8)) + ((wordcode )*((unsigned char *)(buf___7 + 1) + 3) << 16));
#line 3192
          tmp___0 = lseek(fd, (__off_t )o, 0);
          }
#line 3192
          if (tmp___0 == -1L) {
            {
#line 3195
            zwarnnam((char const   *)nam, "invalid zwc file: %s", name);
#line 3196
            close(fd);
            }
#line 3197
            return ((Wordcode )((void *)0));
          } else {
            {
#line 3192
            tmp___1 = read(fd, (void *)(buf___7), 13UL * sizeof(wordcode ));
            }
#line 3192
            if ((unsigned long )tmp___1 != 13UL * sizeof(wordcode )) {
              {
#line 3195
              zwarnnam((char const   *)nam, "invalid zwc file: %s", name);
#line 3196
              close(fd);
              }
#line 3197
              return ((Wordcode )((void *)0));
            }
          }
          {
#line 3199
          len = (int )((unsigned long )buf___7[12] * sizeof(wordcode ));
#line 3200
          tmp___2 = zhalloc((size_t )len);
#line 3200
          head = (Wordcode )tmp___2;
          }
        }
        {
#line 3202
        memcpy((void */* __restrict  */)head, (void const   */* __restrict  */)(buf___7),
               13UL * sizeof(wordcode ));
#line 3204
        len = (int )((unsigned long )len - 13UL * sizeof(wordcode ));
#line 3205
        tmp___3 = read(fd, (void *)(head + 13), (size_t )len);
        }
#line 3205
        if (tmp___3 != (ssize_t )len) {
          {
#line 3206
          close(fd);
#line 3207
          zwarnnam((char const   *)nam, "invalid zwc file: %s", name);
          }
#line 3208
          return ((Wordcode )((void *)0));
        }
        {
#line 3210
        close(fd);
        }
#line 3211
        return (head);
      }
    }
  }
}
}
#line 3217 "/tmp/zsh-5.4.2/Src/parse.c"
static void fdswap(Wordcode p , int n ) 
{ 
  wordcode c ;
  int tmp ;

  {
  {
#line 3222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3222
    tmp = n;
#line 3222
    n --;
#line 3222
    if (! tmp) {
#line 3222
      goto while_break;
    }
#line 3223
    c = *p;
#line 3224
    *p = ((((c & 255U) << 24) | ((c & 65280U) << 8)) | ((c & 16711680U) >> 8)) | ((c & 4278190080U) >> 24);
#line 3222
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3229
  return;
}
}
#line 3233 "/tmp/zsh-5.4.2/Src/parse.c"
static void write_dump(int dfd , LinkList progs , int map , int hlen , int tlen ) 
{ 
  LinkNode node ;
  WCFunc wcf ;
  int other ;
  int ohlen ;
  int tmp ;
  wordcode pre[12] ;
  char *tail ;
  char *n ;
  struct fdhead head ;
  Eprog prog ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 3238
  other = 0;
#line 3244
  if (map == 1) {
#line 3245
    map = tlen >= 4096;
  }
  {
#line 3247
  memset((void *)(pre), 0, sizeof(wordcode ) * 12UL);
#line 3249
  ohlen = hlen;
  }
  {
#line 3249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3250
    if (other) {
#line 3250
      pre[0] = (wordcode )117835012;
    } else {
#line 3250
      pre[0] = (wordcode )67438087;
    }
#line 3251
    if (map) {
#line 3251
      tmp___0 = 1;
    } else {
#line 3251
      tmp___0 = 0;
    }
#line 3251
    *((unsigned char *)(pre + 1) + 0) = (unsigned char )(tmp___0 | other);
    {
#line 3252
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3252
      *((unsigned char *)(pre + 1) + 1) = (unsigned char )(tlen & 255);
#line 3252
      *((unsigned char *)(pre + 1) + 2) = (unsigned char )((tlen >> 8) & 255);
#line 3252
      *((unsigned char *)(pre + 1) + 3) = (unsigned char )((tlen >> 16) & 255);
#line 3252
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3253
    strcpy((char */* __restrict  */)((char *)(pre + 2)), (char const   */* __restrict  */)"5.4.2");
#line 3254
    write_loop(dfd, (char const   *)((char *)(pre)), 12UL * sizeof(wordcode ));
#line 3256
    node = progs->list.first;
    }
    {
#line 3256
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3256
      if (! node) {
#line 3256
        goto while_break___1;
      }
      {
#line 3257
      wcf = (WCFunc )node->dat;
#line 3258
      n = wcf->name;
#line 3259
      prog = wcf->prog;
#line 3260
      head.start = (wordcode )hlen;
#line 3261
      hlen = (int )((unsigned long )hlen + ((((unsigned long )prog->len - (unsigned long )prog->npats * sizeof(Patprog )) + sizeof(wordcode )) - 1UL) / sizeof(wordcode ));
#line 3263
      head.len = (wordcode )((unsigned long )prog->len - (unsigned long )prog->npats * sizeof(Patprog ));
#line 3264
      head.npats = (wordcode )prog->npats;
#line 3265
      head.strs = (wordcode )(prog->strs - (char *)prog->prog);
#line 3266
      tmp___1 = strlen((char const   *)n);
#line 3266
      head.hlen = (wordcode )(sizeof(struct fdhead ) / sizeof(wordcode ) + (tmp___1 + sizeof(wordcode )) / sizeof(wordcode ));
#line 3268
      tail = strrchr((char const   *)n, '/');
      }
#line 3268
      if (tail) {
#line 3269
        tail ++;
      } else {
#line 3271
        tail = n;
      }
#line 3272
      head.flags = (wordcode )((long )wcf->flags | ((tail - n) << 2));
#line 3273
      if (other) {
        {
#line 3274
        fdswap((Wordcode )(& head), (int )(sizeof(head) / sizeof(wordcode )));
        }
      }
      {
#line 3275
      write_loop(dfd, (char const   *)((char *)(& head)), sizeof(head));
#line 3276
      tmp___2 = strlen((char const   *)n);
#line 3276
      tmp = (int )(tmp___2 + 1UL);
#line 3277
      write_loop(dfd, (char const   *)n, (size_t )tmp);
#line 3278
      tmp = (int )((unsigned long )tmp & (sizeof(wordcode ) - 1UL));
      }
#line 3278
      if (tmp) {
        {
#line 3279
        write_loop(dfd, (char const   *)((char *)(& head)), sizeof(wordcode ) - (unsigned long )tmp);
        }
      }
#line 3256
      node = node->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3281
    node = progs->list.first;
    {
#line 3281
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3281
      if (! node) {
#line 3281
        goto while_break___2;
      }
#line 3282
      prog = ((WCFunc )node->dat)->prog;
#line 3283
      tmp = (int )(((((unsigned long )prog->len - (unsigned long )prog->npats * sizeof(Patprog )) + sizeof(wordcode )) - 1UL) / sizeof(wordcode ));
#line 3285
      if (other) {
        {
#line 3286
        fdswap(prog->prog, (int )((Wordcode )prog->strs - prog->prog));
        }
      }
      {
#line 3287
      write_loop(dfd, (char const   *)((char *)prog->prog), (unsigned long )tmp * sizeof(wordcode ));
#line 3281
      node = node->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3289
    if (other) {
#line 3290
      goto while_break;
    }
#line 3291
    other = 2;
#line 3249
    hlen = ohlen;
  }
  while_break: /* CIL Label */ ;
  }
#line 3293
  return;
}
}
#line 3296 "/tmp/zsh-5.4.2/Src/parse.c"
static int build_dump(char *nam , char *dump , char **files , int ali , int map ,
                      int flags ) 
{ 
  int dfd ;
  int fd ;
  int hlen ;
  int tlen ;
  int flen ;
  int ona ;
  LinkList progs ;
  char *file ;
  Eprog prog ;
  WCFunc wcf ;
  int tmp ;
  struct stat st___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __off_t tmp___3 ;
  void *tmp___4 ;
  ssize_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 3299
  ona = noaliases;
#line 3305
  tmp = strsfx((char *)".zwc", dump);
  }
#line 3305
  if (! tmp) {
    {
#line 3306
    dump = dyncat((char const   *)dump, ".zwc");
    }
  }
  {
#line 3308
  unlink((char const   *)dump);
#line 3309
  dfd = open((char const   *)dump, 65, 292);
  }
#line 3309
  if (dfd < 0) {
    {
#line 3310
    zwarnnam((char const   *)nam, "can\'t write zwc file: %s", dump);
    }
#line 3311
    return (1);
  }
  {
#line 3313
  progs = newlinklist();
#line 3314
  noaliases = ali;
#line 3316
  hlen = 12;
#line 3316
  tlen = 0;
  }
  {
#line 3316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3316
    if (! *files) {
#line 3316
      goto while_break;
    }
    {
#line 3319
    tmp___1 = check_cond((char const   *)*files, "k");
    }
#line 3319
    if (tmp___1) {
#line 3320
      flags = (flags & -4) | 1;
#line 3321
      goto __Cont;
    } else {
      {
#line 3322
      tmp___0 = check_cond((char const   *)*files, "z");
      }
#line 3322
      if (tmp___0) {
#line 3323
        flags = (flags & -4) | 2;
#line 3324
        goto __Cont;
      }
    }
    {
#line 3326
    fd = open((char const   *)*files, 0);
    }
#line 3326
    if (fd < 0) {
#line 3326
      goto _L;
    } else {
      {
#line 3326
      tmp___2 = fstat(fd, & st___0);
      }
#line 3326
      if (tmp___2 != 0) {
#line 3326
        goto _L;
      } else
#line 3326
      if (! ((st___0.st_mode & 61440U) == 32768U)) {
#line 3326
        goto _L;
      } else {
        {
#line 3326
        tmp___3 = lseek(fd, (__off_t )0, 2);
#line 3326
        flen = (int )tmp___3;
        }
#line 3326
        if (flen == -1) {
          _L: /* CIL Label */ 
#line 3329
          if (fd >= 0) {
            {
#line 3330
            close(fd);
            }
          }
          {
#line 3331
          close(dfd);
#line 3332
          zwarnnam((char const   *)nam, "can\'t open file: %s", *files);
#line 3333
          noaliases = ona;
#line 3334
          unlink((char const   *)dump);
          }
#line 3335
          return (1);
        }
      }
    }
    {
#line 3337
    tmp___4 = zalloc((size_t )(flen + 1));
#line 3337
    file = (char *)tmp___4;
#line 3338
    *(file + flen) = (char )'\000';
#line 3339
    lseek(fd, (__off_t )0, 0);
#line 3340
    tmp___5 = read(fd, (void *)file, (size_t )flen);
    }
#line 3340
    if (tmp___5 != (ssize_t )flen) {
      {
#line 3341
      close(fd);
#line 3342
      close(dfd);
#line 3343
      zfree((void *)file, flen);
#line 3344
      zwarnnam((char const   *)nam, "can\'t read file: %s", *files);
#line 3345
      noaliases = ona;
#line 3346
      unlink((char const   *)dump);
      }
#line 3347
      return (1);
    }
    {
#line 3349
    close(fd);
#line 3350
    file = metafy(file, flen, 0);
#line 3352
    prog = parse_string(file, 1);
    }
#line 3352
    if (prog) {
#line 3352
      if (errflag) {
        _L___0: /* CIL Label */ 
        {
#line 3353
        errflag &= -2;
#line 3354
        close(dfd);
#line 3355
        zfree((void *)file, flen);
#line 3356
        zwarnnam((char const   *)nam, "can\'t read file: %s", *files);
#line 3357
        noaliases = ona;
#line 3358
        unlink((char const   *)dump);
        }
#line 3359
        return (1);
      }
    } else {
#line 3352
      goto _L___0;
    }
    {
#line 3361
    zfree((void *)file, flen);
#line 3363
    tmp___6 = zhalloc(sizeof(*wcf));
#line 3363
    wcf = (WCFunc )tmp___6;
#line 3364
    wcf->name = *files;
#line 3365
    wcf->prog = prog;
    }
#line 3366
    if (prog->flags & 8) {
#line 3366
      wcf->flags = 1;
    } else {
#line 3366
      wcf->flags = flags;
    }
    {
#line 3367
    insertlinknode(progs, progs->list.last, (void *)wcf);
#line 3369
    tmp___7 = strlen((char const   *)*files);
#line 3369
    flen = (int )((tmp___7 + sizeof(wordcode )) / sizeof(wordcode ));
#line 3370
    hlen = (int )((unsigned long )hlen + (sizeof(struct fdhead ) / sizeof(wordcode ) + (unsigned long )flen));
#line 3372
    tlen = (int )((unsigned long )tlen + ((((unsigned long )prog->len - (unsigned long )prog->npats * sizeof(Patprog )) + sizeof(wordcode )) - 1UL) / sizeof(wordcode ));
    }
    __Cont: /* CIL Label */ 
#line 3316
    files ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3375
  noaliases = ona;
#line 3377
  tlen = (int )((unsigned long )(tlen + hlen) * sizeof(wordcode ));
#line 3379
  write_dump(dfd, progs, map, hlen, tlen);
#line 3381
  close(dfd);
  }
#line 3383
  return (0);
}
}
#line 3386 "/tmp/zsh-5.4.2/Src/parse.c"
static int cur_add_func(char *nam , Shfunc shf , LinkList names , LinkList progs ,
                        int *hlen , int *tlen , int what ) 
{ 
  Eprog prog ;
  WCFunc wcf ;
  int ona ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 3393
  if (shf->node.flags & (1 << 9)) {
#line 3394
    ona = noaliases;
#line 3396
    if (! (what & 2)) {
      {
#line 3397
      zwarnnam((char const   *)nam, "function is not loaded: %s", shf->node.nam);
      }
#line 3398
      return (1);
    }
    {
#line 3400
    noaliases = shf->node.flags & (1 << 13);
#line 3401
    prog = getfpfunc(shf->node.nam, (int *)((void *)0), (char **)((void *)0), (char **)((void *)0),
                     0);
    }
#line 3401
    if (prog) {
#line 3401
      if ((unsigned long )prog == (unsigned long )(& dummy_eprog)) {
        {
#line 3403
        noaliases = ona;
#line 3404
        zwarnnam((char const   *)nam, "can\'t load function: %s", shf->node.nam);
        }
#line 3405
        return (1);
      }
    } else {
      {
#line 3403
      noaliases = ona;
#line 3404
      zwarnnam((char const   *)nam, "can\'t load function: %s", shf->node.nam);
      }
#line 3405
      return (1);
    }
#line 3407
    if (prog->dump) {
      {
#line 3408
      prog = dupeprog(prog, 1);
      }
    }
#line 3409
    noaliases = ona;
  } else {
#line 3411
    if (! (what & 1)) {
      {
#line 3412
      zwarnnam((char const   *)nam, "function is already loaded: %s", shf->node.nam);
      }
#line 3413
      return (1);
    }
    {
#line 3415
    prog = dupeprog(shf->funcdef, 1);
    }
  }
  {
#line 3417
  tmp = zhalloc(sizeof(*wcf));
#line 3417
  wcf = (WCFunc )tmp;
#line 3418
  wcf->name = shf->node.nam;
#line 3419
  wcf->prog = prog;
  }
#line 3420
  if (prog->flags & 8) {
#line 3420
    wcf->flags = 1;
  } else {
#line 3420
    wcf->flags = 2;
  }
  {
#line 3421
  insertlinknode(progs, progs->list.last, (void *)wcf);
#line 3422
  insertlinknode(names, names->list.last, (void *)shf->node.nam);
#line 3424
  tmp___0 = strlen((char const   *)shf->node.nam);
#line 3424
  *hlen = (int )((unsigned long )*hlen + (sizeof(struct fdhead ) / sizeof(wordcode ) + (tmp___0 + sizeof(wordcode )) / sizeof(wordcode )));
#line 3426
  *tlen = (int )((unsigned long )*tlen + ((((unsigned long )prog->len - (unsigned long )prog->npats * sizeof(Patprog )) + sizeof(wordcode )) - 1UL) / sizeof(wordcode ));
  }
#line 3429
  return (0);
}
}
#line 3433 "/tmp/zsh-5.4.2/Src/parse.c"
static int build_cur_dump(char *nam , char *dump , char **names , int match , int map ,
                          int what ) 
{ 
  int dfd ;
  int hlen ;
  int tlen ;
  LinkList progs ;
  LinkList lnames ;
  Shfunc shf ;
  int tmp ;
  int i ;
  HashNode hn ;
  int tmp___0 ;
  char *pat ;
  Patprog pprog ;
  int i___0 ;
  HashNode hn___0 ;
  LinkNode tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  HashNode tmp___4 ;
  int tmp___5 ;

  {
  {
#line 3439
  shf = (Shfunc )((void *)0);
#line 3441
  tmp = strsfx((char *)".zwc", dump);
  }
#line 3441
  if (! tmp) {
    {
#line 3442
    dump = dyncat((char const   *)dump, ".zwc");
    }
  }
  {
#line 3444
  unlink((char const   *)dump);
#line 3445
  dfd = open((char const   *)dump, 65, 292);
  }
#line 3445
  if (dfd < 0) {
    {
#line 3446
    zwarnnam((char const   *)nam, "can\'t write zwc file: %s", dump);
    }
#line 3447
    return (1);
  }
  {
#line 3449
  progs = newlinklist();
#line 3450
  lnames = newlinklist();
#line 3452
  hlen = 12;
#line 3453
  tlen = 0;
  }
#line 3455
  if (! *names) {
#line 3459
    i = 0;
    {
#line 3459
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3459
      if (! (i < shfunctab->hsize)) {
#line 3459
        goto while_break;
      }
#line 3460
      hn = *(shfunctab->nodes + i);
      {
#line 3460
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3460
        if (! hn) {
#line 3460
          goto while_break___0;
        }
        {
#line 3461
        tmp___0 = cur_add_func(nam, (Shfunc )hn, lnames, progs, & hlen, & tlen, what);
        }
#line 3461
        if (tmp___0) {
          {
#line 3463
          errflag &= -2;
#line 3464
          close(dfd);
#line 3465
          unlink((char const   *)dump);
          }
#line 3466
          return (1);
        }
#line 3460
        hn = hn->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3459
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 3468
  if (match) {
    {
#line 3474
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3474
      if (! *names) {
#line 3474
        goto while_break___1;
      }
      {
#line 3475
      pat = dupstring((char const   *)*names);
#line 3475
      tokenize(pat);
#line 3477
      pprog = patcompile(pat, 64, (char **)((void *)0));
      }
#line 3477
      if (! pprog) {
        {
#line 3478
        zwarnnam((char const   *)nam, "bad pattern: %s", *names);
#line 3479
        close(dfd);
#line 3480
        unlink((char const   *)dump);
        }
#line 3481
        return (1);
      }
#line 3483
      i___0 = 0;
      {
#line 3483
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3483
        if (! (i___0 < shfunctab->hsize)) {
#line 3483
          goto while_break___2;
        }
#line 3484
        hn___0 = *(shfunctab->nodes + i___0);
        {
#line 3484
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3484
          if (! hn___0) {
#line 3484
            goto while_break___3;
          }
          {
#line 3485
          tmp___1 = linknodebydatum(lnames, (void *)hn___0->nam);
          }
#line 3485
          if (! tmp___1) {
            {
#line 3485
            tmp___2 = pattry(pprog, hn___0->nam);
            }
#line 3485
            if (tmp___2) {
              {
#line 3485
              tmp___3 = cur_add_func(nam, (Shfunc )hn___0, lnames, progs, & hlen,
                                     & tlen, what);
              }
#line 3485
              if (tmp___3) {
                {
#line 3489
                errflag &= -2;
#line 3490
                close(dfd);
#line 3491
                unlink((char const   *)dump);
                }
#line 3492
                return (1);
              }
            }
          }
#line 3484
          hn___0 = hn___0->next;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 3483
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3474
      names ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 3496
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3496
      if (! *names) {
#line 3496
        goto while_break___4;
      }
#line 3497
      if (errflag) {
        {
#line 3499
        zwarnnam((char const   *)nam, "unknown function: %s", *names);
#line 3500
        errflag &= -2;
#line 3501
        close(dfd);
#line 3502
        unlink((char const   *)dump);
        }
#line 3503
        return (1);
      } else {
        {
#line 3497
        tmp___4 = (*(shfunctab->getnode))(shfunctab, (char const   *)*names);
#line 3497
        shf = (Shfunc )tmp___4;
        }
#line 3497
        if (! shf) {
          {
#line 3499
          zwarnnam((char const   *)nam, "unknown function: %s", *names);
#line 3500
          errflag &= -2;
#line 3501
          close(dfd);
#line 3502
          unlink((char const   *)dump);
          }
#line 3503
          return (1);
        }
      }
      {
#line 3505
      tmp___5 = cur_add_func(nam, shf, lnames, progs, & hlen, & tlen, what);
      }
#line 3505
      if (tmp___5) {
        {
#line 3506
        errflag &= -2;
#line 3507
        close(dfd);
#line 3508
        unlink((char const   *)dump);
        }
#line 3509
        return (1);
      }
#line 3496
      names ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 3513
  if ((unsigned long )progs->list.first == (unsigned long )((void *)0)) {
    {
#line 3514
    zwarnnam((char const   *)nam, "no functions");
#line 3515
    errflag &= -2;
#line 3516
    close(dfd);
#line 3517
    unlink((char const   *)dump);
    }
#line 3518
    return (1);
  }
  {
#line 3520
  tlen = (int )((unsigned long )(tlen + hlen) * sizeof(wordcode ));
#line 3522
  write_dump(dfd, progs, map, hlen, tlen);
#line 3524
  close(dfd);
  }
#line 3526
  return (0);
}
}
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 3550 "/tmp/zsh-5.4.2/Src/parse.c"
static FuncDump dumps  ;
#line 3553 "/tmp/zsh-5.4.2/Src/parse.c"
static int zwcstat(char *filename , struct stat *buf___7 ) 
{ 
  FuncDump f ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3556
  tmp___2 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)buf___7);
  }
#line 3556
  if (tmp___2) {
#line 3560
    f = dumps;
    {
#line 3560
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3560
      if (! f) {
#line 3560
        goto while_break;
      }
      {
#line 3561
      tmp = strlen((char const   *)f->filename);
#line 3561
      tmp___0 = strncmp((char const   *)filename, (char const   *)f->filename, tmp);
      }
#line 3561
      if (! tmp___0) {
        {
#line 3561
        tmp___1 = fstat(f->fd, buf___7);
        }
#line 3561
        if (! tmp___1) {
#line 3563
          return (0);
        }
      }
#line 3560
      f = f->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 3566
    return (1);
  } else {
#line 3567
    return (0);
  }
}
}
#line 3580
static void load_dump_file(char *dump , struct stat *sbuf , int other , int len ) ;
#line 3580 "/tmp/zsh-5.4.2/Src/parse.c"
static size_t pgsz  =    (size_t )0;
#line 3572 "/tmp/zsh-5.4.2/Src/parse.c"
static void load_dump_file(char *dump , struct stat *sbuf , int other , int len ) 
{ 
  FuncDump d___0 ;
  Wordcode addr ;
  int fd ;
  int off ;
  int mlen ;
  long tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 3579
  if (other) {
#line 3582
    if (! pgsz) {
      {
#line 3585
      tmp = sysconf(30);
#line 3585
      pgsz = (size_t )tmp;
#line 3594
      pgsz --;
      }
    }
#line 3596
    off = (int )((unsigned long )len & ~ pgsz);
#line 3597
    mlen = len + (len - off);
  } else {
#line 3599
    off = 0;
#line 3600
    mlen = len;
  }
  {
#line 3602
  fd = open((char const   *)dump, 0);
  }
#line 3602
  if (fd < 0) {
#line 3603
    return;
  }
  {
#line 3605
  fd = movefd(fd);
  }
#line 3606
  if (fd == -1) {
#line 3607
    return;
  }
  {
#line 3609
  tmp___0 = mmap((void *)0, (size_t )mlen, 1, 1, fd, (__off_t )off);
#line 3609
  addr = (Wordcode )tmp___0;
  }
#line 3609
  if ((unsigned long )addr == (unsigned long )((Wordcode )-1)) {
    {
#line 3611
    close(fd);
    }
#line 3612
    return;
  }
  {
#line 3614
  tmp___1 = zalloc(sizeof(*d___0));
#line 3614
  d___0 = (FuncDump )tmp___1;
#line 3615
  d___0->next = dumps;
#line 3616
  dumps = d___0;
#line 3617
  d___0->dev = sbuf->st_dev;
#line 3618
  d___0->ino = sbuf->st_ino;
#line 3619
  d___0->fd = fd;
#line 3621
  fcntl(fd, 2, 1);
  }
#line 3623
  if (other) {
#line 3623
    tmp___2 = (unsigned long )(len - off) / sizeof(wordcode );
  } else {
#line 3623
    tmp___2 = 0UL;
  }
  {
#line 3623
  d___0->map = addr + tmp___2;
#line 3624
  d___0->addr = addr;
#line 3625
  d___0->len = len;
#line 3626
  d___0->count = 0;
#line 3627
  d___0->filename = ztrdup((char const   *)dump);
  }
#line 3628
  return;
}
}
#line 3643 "/tmp/zsh-5.4.2/Src/parse.c"
Eprog try_dump_file(char *path___0 , char *name , char *file , int *ksh , int test_only ) 
{ 
  Eprog prog ;
  struct stat std ;
  struct stat stc ;
  struct stat stn ;
  int rd ;
  int rc ;
  int rn ;
  char *dig ;
  char *wc ;
  sigset_t oset ;
  int tmp ;
  sigset_t oset___0 ;
  sigset_t oset___1 ;
  sigset_t oset___2 ;

  {
  {
#line 3651
  tmp = strsfx((char *)".zwc", path___0);
  }
#line 3651
  if (tmp) {
    {
#line 3652
    queueing_enabled ++;
#line 3653
    prog = check_dump_file(path___0, (struct stat *)((void *)0), name, ksh, test_only);
    }
    {
#line 3654
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3654
      queueing_enabled --;
#line 3654
      if (! queueing_enabled) {
        {
#line 3654
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 3654
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3654
            if (! (queue_front != queue_rear)) {
#line 3654
              goto while_break___1;
            }
            {
#line 3654
            queue_front = (queue_front + 1) % 128;
#line 3654
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3654
            zhandler(signal_queue[queue_front]);
#line 3654
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 3654
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 3654
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 3655
    return (prog);
  }
  {
#line 3657
  dig = dyncat((char const   *)path___0, ".zwc");
#line 3658
  wc = dyncat((char const   *)file, ".zwc");
#line 3660
  rd = zwcstat(dig, & std);
#line 3661
  rc = stat((char const   */* __restrict  */)wc, (struct stat */* __restrict  */)(& stc));
#line 3662
  rn = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& stn));
#line 3668
  queueing_enabled ++;
  }
#line 3669
  if (! rd) {
#line 3669
    if (rc) {
#line 3669
      goto _L___0;
    } else
#line 3669
    if (std.st_mtim.tv_sec > stc.st_mtim.tv_sec) {
      _L___0: /* CIL Label */ 
#line 3669
      if (rn) {
#line 3669
        goto _L;
      } else
#line 3669
      if (std.st_mtim.tv_sec > stn.st_mtim.tv_sec) {
        _L: /* CIL Label */ 
        {
#line 3669
        prog = check_dump_file(dig, & std, name, ksh, test_only);
        }
#line 3669
        if (prog) {
          {
#line 3673
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 3673
            queueing_enabled --;
#line 3673
            if (! queueing_enabled) {
              {
#line 3673
              while (1) {
                while_continue___3: /* CIL Label */ ;
                {
#line 3673
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 3673
                  if (! (queue_front != queue_rear)) {
#line 3673
                    goto while_break___4;
                  }
                  {
#line 3673
                  queue_front = (queue_front + 1) % 128;
#line 3673
                  oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 3673
                  zhandler(signal_queue[queue_front]);
#line 3673
                  signal_setmask(oset___0);
                  }
                }
                while_break___4: /* CIL Label */ ;
                }
#line 3673
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
#line 3673
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 3674
          return (prog);
        }
      }
    }
  }
#line 3677
  if (! rc) {
#line 3677
    if (rn) {
#line 3677
      goto _L___1;
    } else
#line 3677
    if (stc.st_mtim.tv_sec > stn.st_mtim.tv_sec) {
      _L___1: /* CIL Label */ 
      {
#line 3677
      prog = check_dump_file(wc, & stc, name, ksh, test_only);
      }
#line 3677
      if (prog) {
        {
#line 3680
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 3680
          queueing_enabled --;
#line 3680
          if (! queueing_enabled) {
            {
#line 3680
            while (1) {
              while_continue___6: /* CIL Label */ ;
              {
#line 3680
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 3680
                if (! (queue_front != queue_rear)) {
#line 3680
                  goto while_break___7;
                }
                {
#line 3680
                queue_front = (queue_front + 1) % 128;
#line 3680
                oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 3680
                zhandler(signal_queue[queue_front]);
#line 3680
                signal_setmask(oset___1);
                }
              }
              while_break___7: /* CIL Label */ ;
              }
#line 3680
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
#line 3680
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 3681
        return (prog);
      }
    }
  }
  {
#line 3685
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 3685
    queueing_enabled --;
#line 3685
    if (! queueing_enabled) {
      {
#line 3685
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 3685
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 3685
          if (! (queue_front != queue_rear)) {
#line 3685
            goto while_break___10;
          }
          {
#line 3685
          queue_front = (queue_front + 1) % 128;
#line 3685
          oset___2 = signal_setmask(signal_mask_queue[queue_front]);
#line 3685
          zhandler(signal_queue[queue_front]);
#line 3685
          signal_setmask(oset___2);
          }
        }
        while_break___10: /* CIL Label */ ;
        }
#line 3685
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 3685
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 3686
  return ((Eprog )((void *)0));
}
}
#line 3692 "/tmp/zsh-5.4.2/Src/parse.c"
Eprog try_source_file(char *file ) 
{ 
  Eprog prog ;
  struct stat stc ;
  struct stat stn ;
  int rc ;
  int rn ;
  char *wc ;
  char *tail ;
  sigset_t oset ;
  int tmp ;
  sigset_t oset___0 ;
  sigset_t oset___1 ;

  {
  {
#line 3700
  tail = strrchr((char const   *)file, '/');
  }
#line 3700
  if (tail) {
#line 3701
    tail ++;
  } else {
#line 3703
    tail = file;
  }
  {
#line 3705
  tmp = strsfx((char *)".zwc", file);
  }
#line 3705
  if (tmp) {
    {
#line 3706
    queueing_enabled ++;
#line 3707
    prog = check_dump_file(file, (struct stat *)((void *)0), tail, (int *)((void *)0),
                           0);
    }
    {
#line 3708
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3708
      queueing_enabled --;
#line 3708
      if (! queueing_enabled) {
        {
#line 3708
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 3708
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3708
            if (! (queue_front != queue_rear)) {
#line 3708
              goto while_break___1;
            }
            {
#line 3708
            queue_front = (queue_front + 1) % 128;
#line 3708
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3708
            zhandler(signal_queue[queue_front]);
#line 3708
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 3708
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 3708
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 3709
    return (prog);
  }
  {
#line 3711
  wc = dyncat((char const   *)file, ".zwc");
#line 3713
  rc = stat((char const   */* __restrict  */)wc, (struct stat */* __restrict  */)(& stc));
#line 3714
  rn = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& stn));
#line 3716
  queueing_enabled ++;
  }
#line 3717
  if (! rc) {
#line 3717
    if (rn) {
#line 3717
      goto _L;
    } else
#line 3717
    if (stc.st_mtim.tv_sec > stn.st_mtim.tv_sec) {
      _L: /* CIL Label */ 
      {
#line 3717
      prog = check_dump_file(wc, & stc, tail, (int *)((void *)0), 0);
      }
#line 3717
      if (prog) {
        {
#line 3719
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3719
          queueing_enabled --;
#line 3719
          if (! queueing_enabled) {
            {
#line 3719
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 3719
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 3719
                if (! (queue_front != queue_rear)) {
#line 3719
                  goto while_break___4;
                }
                {
#line 3719
                queue_front = (queue_front + 1) % 128;
#line 3719
                oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 3719
                zhandler(signal_queue[queue_front]);
#line 3719
                signal_setmask(oset___0);
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 3719
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 3719
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3720
        return (prog);
      }
    }
  }
  {
#line 3722
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 3722
    queueing_enabled --;
#line 3722
    if (! queueing_enabled) {
      {
#line 3722
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 3722
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 3722
          if (! (queue_front != queue_rear)) {
#line 3722
            goto while_break___7;
          }
          {
#line 3722
          queue_front = (queue_front + 1) % 128;
#line 3722
          oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 3722
          zhandler(signal_queue[queue_front]);
#line 3722
          signal_setmask(oset___1);
          }
        }
        while_break___7: /* CIL Label */ ;
        }
#line 3722
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 3722
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 3723
  return ((Eprog )((void *)0));
}
}
#line 3730 "/tmp/zsh-5.4.2/Src/parse.c"
static Eprog check_dump_file(char *file , struct stat *sbuf , char *name , int *ksh ,
                             int test_only ) 
{ 
  int isrec ;
  Wordcode d___0 ;
  FDHead h ;
  FuncDump f ;
  struct stat lsbuf ;
  int tmp ;
  Eprog prog ;
  void *tmp___0 ;
  Patprog *pp ;
  int np ;
  void *tmp___1 ;
  Patprog *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  Eprog prog___0 ;
  Patprog *pp___0 ;
  int np___0 ;
  int fd ;
  int po ;
  wordcode tmp___5 ;
  __off_t tmp___6 ;
  void *tmp___7 ;
  ssize_t tmp___8 ;
  void *tmp___9 ;
  Patprog *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 3734
  isrec = 0;
#line 3740
  if (! sbuf) {
    {
#line 3741
    tmp = zwcstat(file, & lsbuf);
    }
#line 3741
    if (tmp) {
#line 3742
      return ((Eprog )((void *)0));
    }
#line 3743
    sbuf = & lsbuf;
  }
  rec: 
#line 3752
  d___0 = (Wordcode )((void *)0);
#line 3756
  f = dumps;
  {
#line 3756
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3756
    if (! f) {
#line 3756
      goto while_break;
    }
#line 3757
    if (f->dev == sbuf->st_dev) {
#line 3757
      if (f->ino == sbuf->st_ino) {
#line 3758
        d___0 = f->map;
#line 3759
        goto while_break;
      }
    }
#line 3756
    f = f->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 3768
  if (! f) {
#line 3768
    if (isrec) {
#line 3769
      return ((Eprog )((void *)0));
    } else {
      {
#line 3768
      d___0 = load_dump_header((char *)((void *)0), file, 0);
      }
#line 3768
      if (! d___0) {
#line 3769
        return ((Eprog )((void *)0));
      }
    }
  }
  {
#line 3771
  h = dump_find_func(d___0, name);
  }
#line 3771
  if (h) {
#line 3774
    if (test_only) {
#line 3777
      return (& dummy_eprog);
    }
#line 3782
    if (f) {
      {
#line 3783
      tmp___0 = zalloc(sizeof(*prog));
#line 3783
      prog = (Eprog )tmp___0;
#line 3787
      prog->flags = 4;
#line 3788
      prog->len = (int )h->len;
#line 3789
      np = (int )h->npats;
#line 3789
      prog->npats = np;
#line 3790
      prog->nref = 1;
#line 3791
      tmp___1 = zalloc((unsigned long )np * sizeof(Patprog ));
#line 3791
      pp = (Patprog *)tmp___1;
#line 3791
      prog->pats = pp;
#line 3792
      prog->prog = f->map + h->start;
#line 3793
      prog->strs = (char *)prog->prog + h->strs;
#line 3794
      prog->shf = (Shfunc )((void *)0);
#line 3795
      prog->dump = f;
#line 3797
      incrdumpcount(f);
      }
      {
#line 3799
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3799
        tmp___3 = np;
#line 3799
        np --;
#line 3799
        if (! tmp___3) {
#line 3799
          goto while_break___0;
        }
#line 3800
        tmp___2 = pp;
#line 3800
        pp ++;
#line 3800
        *tmp___2 = (Patprog )1;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3802
      if (ksh) {
#line 3803
        if (h->flags & 1U) {
#line 3803
          *ksh = 2;
        } else {
#line 3803
          if (h->flags & 2U) {
#line 3803
            tmp___4 = 0;
          } else {
#line 3803
            tmp___4 = 1;
          }
#line 3803
          *ksh = tmp___4;
        }
      }
#line 3806
      return (prog);
    } else
#line 3807
    if ((wordcode )*((unsigned char *)(d___0 + 1) + 0) & 1U) {
      {
#line 3808
      load_dump_file(file, sbuf, (int )((wordcode )*((unsigned char *)(d___0 + 1) + 0) & 2U),
                     (int )(((wordcode )*((unsigned char *)(d___0 + 1) + 1) + ((wordcode )*((unsigned char *)(d___0 + 1) + 2) << 8)) + ((wordcode )*((unsigned char *)(d___0 + 1) + 3) << 16)));
#line 3809
      isrec = 1;
      }
#line 3810
      goto rec;
    } else {
      {
#line 3818
      po = (int )((unsigned long )h->npats * sizeof(Patprog ));
#line 3820
      fd = open((char const   *)file, 0);
      }
#line 3820
      if (fd < 0) {
#line 3820
        goto _L;
      } else {
#line 3820
        if ((wordcode )*((unsigned char *)(d___0 + 1) + 0) & 2U) {
#line 3820
          tmp___5 = ((wordcode )*((unsigned char *)(d___0 + 1) + 1) + ((wordcode )*((unsigned char *)(d___0 + 1) + 2) << 8)) + ((wordcode )*((unsigned char *)(d___0 + 1) + 3) << 16);
        } else {
#line 3820
          tmp___5 = (wordcode )0;
        }
        {
#line 3820
        tmp___6 = lseek(fd, (__off_t )((unsigned long )h->start * sizeof(wordcode ) + (unsigned long )tmp___5),
                        0);
        }
#line 3820
        if (tmp___6 < 0L) {
          _L: /* CIL Label */ 
#line 3823
          if (fd >= 0) {
            {
#line 3824
            close(fd);
            }
          }
#line 3825
          return ((Eprog )((void *)0));
        }
      }
      {
#line 3827
      tmp___7 = zalloc((size_t )(h->len + (wordcode )po));
#line 3827
      d___0 = (Wordcode )tmp___7;
#line 3829
      tmp___8 = read(fd, (void *)((char *)d___0 + po), (size_t )h->len);
      }
#line 3829
      if (tmp___8 != (ssize_t )((int )h->len)) {
        {
#line 3830
        close(fd);
#line 3831
        zfree((void *)d___0, (int )h->len);
        }
#line 3833
        return ((Eprog )((void *)0));
      }
      {
#line 3835
      close(fd);
#line 3837
      tmp___9 = zalloc(sizeof(*prog___0));
#line 3837
      prog___0 = (Eprog )tmp___9;
#line 3839
      prog___0->flags = 1;
#line 3840
      prog___0->len = (int )(h->len + (wordcode )po);
#line 3841
      np___0 = (int )h->npats;
#line 3841
      prog___0->npats = np___0;
#line 3842
      prog___0->nref = 1;
#line 3843
      pp___0 = (Patprog *)d___0;
#line 3843
      prog___0->pats = pp___0;
#line 3844
      prog___0->prog = (Wordcode )((char *)d___0 + po);
#line 3845
      prog___0->strs = (char *)prog___0->prog + h->strs;
#line 3846
      prog___0->shf = (Shfunc )((void *)0);
#line 3847
      prog___0->dump = f;
      }
      {
#line 3849
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3849
        tmp___11 = np___0;
#line 3849
        np___0 --;
#line 3849
        if (! tmp___11) {
#line 3849
          goto while_break___1;
        }
#line 3850
        tmp___10 = pp___0;
#line 3850
        pp___0 ++;
#line 3850
        *tmp___10 = (Patprog )1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3852
      if (ksh) {
#line 3853
        if (h->flags & 1U) {
#line 3853
          *ksh = 2;
        } else {
#line 3853
          if (h->flags & 2U) {
#line 3853
            tmp___12 = 0;
          } else {
#line 3853
            tmp___12 = 1;
          }
#line 3853
          *ksh = tmp___12;
        }
      }
#line 3856
      return (prog___0);
    }
  }
#line 3859
  return ((Eprog )((void *)0));
}
}
#line 3867 "/tmp/zsh-5.4.2/Src/parse.c"
void incrdumpcount(FuncDump f ) 
{ 


  {
#line 3870
  (f->count) ++;
#line 3871
  return;
}
}
#line 3874 "/tmp/zsh-5.4.2/Src/parse.c"
static void freedump(FuncDump f ) 
{ 


  {
  {
#line 3877
  munmap((void *)f->addr, (size_t )f->len);
#line 3878
  zclose(f->fd);
#line 3879
  zsfree(f->filename);
#line 3880
  zfree((void *)f, (int )sizeof(*f));
  }
#line 3881
  return;
}
}
#line 3886 "/tmp/zsh-5.4.2/Src/parse.c"
void decrdumpcount(FuncDump f ) 
{ 
  FuncDump p ;
  FuncDump q ;

  {
#line 3889
  (f->count) --;
#line 3890
  if (! f->count) {
#line 3893
    q = (FuncDump )((void *)0);
#line 3893
    p = dumps;
    {
#line 3893
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3893
      if (p) {
#line 3893
        if (! ((unsigned long )p != (unsigned long )f)) {
#line 3893
          goto while_break;
        }
      } else {
#line 3893
        goto while_break;
      }
#line 3893
      q = p;
#line 3893
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 3894
    if (p) {
#line 3895
      if (q) {
#line 3896
        q->next = p->next;
      } else {
#line 3898
        dumps = p->next;
      }
      {
#line 3899
      freedump(f);
      }
    }
  }
#line 3902
  return;
}
}
#line 3940 "/tmp/zsh-5.4.2/Src/parse.c"
int dump_autoload(char *nam , char *file , int on , Options ops , int func ) 
{ 
  Wordcode h ;
  FDHead n ;
  FDHead e ;
  Shfunc shf ;
  int ret ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3946
  ret = 0;
#line 3948
  tmp = strsfx((char *)".zwc", file);
  }
#line 3948
  if (! tmp) {
    {
#line 3949
    file = dyncat((char const   *)file, ".zwc");
    }
  }
  {
#line 3951
  h = load_dump_header(nam, file, 1);
  }
#line 3951
  if (! h) {
#line 3952
    return (1);
  }
#line 3954
  n = (FDHead )(h + 12);
#line 3954
  e = (FDHead )(h + *(h + 12));
  {
#line 3954
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3954
    if (! ((unsigned long )n < (unsigned long )e)) {
#line 3954
      goto while_break;
    }
    {
#line 3956
    tmp___0 = zshcalloc(sizeof(*shf));
#line 3956
    shf = (Shfunc )tmp___0;
#line 3957
    shf->node.flags = on;
#line 3958
    shf->funcdef = mkautofn(shf);
#line 3959
    shf->sticky = (Emulation_options )((void *)0);
#line 3960
    tmp___1 = ztrdup((char const   *)((char *)(n + 1) + (n->flags >> 2)));
#line 3960
    (*(shfunctab->addnode))(shfunctab, tmp___1, (void *)shf);
    }
#line 3961
    if ((int )ops->ind[88] != 0) {
      {
#line 3961
      tmp___2 = eval_autoload(shf, shf->node.nam, ops, func);
      }
#line 3961
      if (tmp___2) {
#line 3962
        ret = 1;
      }
    }
#line 3954
    n = (FDHead )((Wordcode )n + n->hlen);
  }
  while_break: /* CIL Label */ ;
  }
#line 3964
  return (ret);
}
}
#line 548 "/usr/include/unistd.h"
extern char **environ ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 703
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 713
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 720
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 730
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 851
extern char *getlogin(void) ;
#line 880
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
#line 197 "/usr/include/grp.h"
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 455 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 631
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 650
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
#line 654
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unsetenv)(char const   *__name ) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int uname(struct utsname *__name ) ;
#line 15 "./builtin.epro"
void set_pwd_env(void) ;
#line 6 "./hashtable.epro"
extern HashTable newhashtable(int size , char const   *name  __attribute__((__unused__)) ,
                              void (*printinfo)(HashTable  )  __attribute__((__unused__)) ) ;
#line 8
extern void addhashnode(HashTable ht , char *nam , void *nodeptr ) ;
#line 13
void disablehashnode(HashNode hn , int flags  __attribute__((__unused__)) ) ;
#line 14
void enablehashnode(HashNode hn , int flags  __attribute__((__unused__)) ) ;
#line 17
extern void emptyhashtable(HashTable ht ) ;
#line 20 "./hist.epro"
zlong histsiz ;
#line 21
zlong savehistsiz ;
#line 70
void resizehistents(void) ;
#line 80
int saveandpophiststack(int pop_through , int writeflags ) ;
#line 20 "./jobs.epro"
int numpipestats ;
#line 21
int pipestats[256] ;
#line 15 "./loop.epro"
zlong try_errflag ;
#line 16
zlong try_interrupt ;
#line 8 "./math.epro"
int lastbase ;
#line 14
zlong mathevalarg(char *s , char **ss ) ;
#line 14 "./mem.epro"
void *zheapptr(void *p ) ;
#line 6 "./module.epro"
char **module_path ;
#line 67
int ensurefeature(char const   *modname , char const   *prefix , char const   *feature ) ;
#line 16 "./options.epro"
char *dashgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 5 "./params.epro"
int locallevel  ;
#line 6 "./params.epro"
char **pparams  ;
#line 7 "./params.epro"
char **cdpath  ;
#line 8 "./params.epro"
char **fpath  ;
#line 9 "./params.epro"
char **mailpath  ;
#line 10 "./params.epro"
char **manpath  ;
#line 11 "./params.epro"
char **psvar  ;
#line 12 "./params.epro"
char **watch  ;
#line 13 "./params.epro"
char **zsh_eval_context  ;
#line 14 "./params.epro"
char **path  ;
#line 15 "./params.epro"
char **fignore  ;
#line 16 "./params.epro"
char *argzero  ;
#line 17 "./params.epro"
char *posixzero  ;
#line 18 "./params.epro"
char *home  ;
#line 19 "./params.epro"
char *nullcmd  ;
#line 20 "./params.epro"
char *oldpwd  ;
#line 21 "./params.epro"
char *zoptarg  ;
#line 22 "./params.epro"
char *prompt  ;
#line 23 "./params.epro"
char *prompt2  ;
#line 24 "./params.epro"
char *prompt3  ;
#line 25 "./params.epro"
char *prompt4  ;
#line 26 "./params.epro"
char *readnullcmd  ;
#line 27 "./params.epro"
char *rprompt  ;
#line 28 "./params.epro"
char *rprompt2  ;
#line 29 "./params.epro"
char *sprompt  ;
#line 30 "./params.epro"
char *wordchars  ;
#line 31 "./params.epro"
char *ifs  ;
#line 32 "./params.epro"
char *postedit  ;
#line 33 "./params.epro"
char *term  ;
#line 34 "./params.epro"
char *zsh_terminfo  ;
#line 35 "./params.epro"
char *zsh_terminfodirs  ;
#line 36 "./params.epro"
char *ttystrname  ;
#line 37 "./params.epro"
char *pwd  ;
#line 38 "./params.epro"
zlong lastval  ;
#line 39 "./params.epro"
zlong mypid  ;
#line 40 "./params.epro"
zlong lastpid  ;
#line 41 "./params.epro"
zlong zterm_columns  ;
#line 42 "./params.epro"
zlong zterm_lines  ;
#line 43 "./params.epro"
zlong rprompt_indent  ;
#line 44 "./params.epro"
zlong ppid  ;
#line 45 "./params.epro"
zlong zsh_subshell  ;
#line 46 "./params.epro"
zlong lineno  ;
#line 47 "./params.epro"
zlong zoptind  ;
#line 48 "./params.epro"
zlong shlvl  ;
#line 49 "./params.epro"
unsigned char bangchar  ;
#line 50 "./params.epro"
unsigned char hatchar  ;
#line 51 "./params.epro"
unsigned char hashchar  ;
#line 52
unsigned char keyboardhackchar ;
#line 53 "./params.epro"
struct timeval shtimer  ;
#line 54 "./params.epro"
int termflags  ;
#line 55
struct gsu_scalar  const  stdscalar_gsu ;
#line 56
struct gsu_scalar  const  varscalar_gsu ;
#line 57
struct gsu_scalar  const  nullsetscalar_gsu ;
#line 58
struct gsu_integer  const  stdinteger_gsu ;
#line 59
struct gsu_integer  const  varinteger_gsu ;
#line 60
struct gsu_integer  const  nullsetinteger_gsu ;
#line 61
struct gsu_float  const  stdfloat_gsu ;
#line 62
struct gsu_array  const  stdarray_gsu ;
#line 64
struct gsu_hash  const  stdhash_gsu ;
#line 65
struct gsu_hash  const  nullsethash_gsu ;
#line 66 "./params.epro"
HashTable paramtab  ;
#line 67 "./params.epro"
HashTable realparamtab  ;
#line 68
HashTable newparamtable(int size , char const   *name ) ;
#line 69
HashTable copyparamtable(HashTable ht , char *name ) ;
#line 70
void deleteparamtable(HashTable t ) ;
#line 71
void scancountparams(HashNode hn  __attribute__((__unused__)) , int flags ) ;
#line 73
int issetvar(char *name ) ;
#line 74
void createparamtable(void) ;
#line 75
void assigngetset(Param pm ) ;
#line 77
Param createspecialhash(char *name , HashNode (*get)(HashTable  , char const   * ) ,
                        void (*scan)(HashTable  , void (*)(HashNode  , int  ) , int  ) ,
                        int flags ) ;
#line 78
void copyparam(Param tpm , Param pm , int fakecopy ) ;
#line 81
Value getvalue(Value v , char **pptr , int bracks ) ;
#line 85
zlong getintvalue(Value v ) ;
#line 86
mnumber getnumvalue(Value v ) ;
#line 87
void export_param(Param pm ) ;
#line 88
void setstrvalue(Value v , char *val ) ;
#line 89
void assignstrvalue(Value v , char *val , int flags ) ;
#line 90
void setnumvalue(Value v , mnumber val ) ;
#line 91
void setarrvalue(Value v , char **val ) ;
#line 93
mnumber getnparam(char *s ) ;
#line 97
char **gethparam(char *s ) ;
#line 98
char **gethkparam(char *s ) ;
#line 99
Param assignsparam(char *s , char *val , int flags ) ;
#line 101
Param assignaparam(char *s , char **val , int flags ) ;
#line 104
Param assignnparam(char *s , mnumber val , int flags ) ;
#line 105
Param setnparam(char *s , mnumber val ) ;
#line 106
Param assigniparam(char *s , zlong val , int flags ) ;
#line 108
Param setiparam_no_convert(char *s , zlong val ) ;
#line 109
void unsetparam(char *s ) ;
#line 110
int unsetparam_pm(Param pm , int altflag , int exp ) ;
#line 111
void stdunsetfn(Param pm , int exp  __attribute__((__unused__)) ) ;
#line 112
zlong intgetfn(Param pm ) ;
#line 113
char *strgetfn(Param pm ) ;
#line 114
void strsetfn(Param pm , char *x ) ;
#line 115
char **arrgetfn(Param pm ) ;
#line 116
void arrsetfn(Param pm , char **x ) ;
#line 117
HashTable hashgetfn(Param pm ) ;
#line 118
void hashsetfn(Param pm , HashTable x ) ;
#line 119
void nullsethashfn(Param pm  __attribute__((__unused__)) , HashTable x ) ;
#line 120
void arrhashsetfn(Param pm , char **val , int augment ) ;
#line 121
void nullstrsetfn(Param pm  __attribute__((__unused__)) , char *x ) ;
#line 122
void nullintsetfn(Param pm  __attribute__((__unused__)) , zlong x  __attribute__((__unused__)) ) ;
#line 123
void nullunsetfn(Param pm  __attribute__((__unused__)) , int exp  __attribute__((__unused__)) ) ;
#line 124
zlong intvargetfn(Param pm ) ;
#line 125
void intvarsetfn(Param pm , zlong x ) ;
#line 126
void zlevarsetfn(Param pm , zlong x ) ;
#line 127
void strvarsetfn(Param pm , char *x ) ;
#line 128
char *strvargetfn(Param pm ) ;
#line 129
char **arrvargetfn(Param pm ) ;
#line 130
void arrvarsetfn(Param pm , char **x ) ;
#line 131
char *colonarrgetfn(Param pm ) ;
#line 132
void colonarrsetfn(Param pm , char *x ) ;
#line 133
char *tiedarrgetfn(Param pm ) ;
#line 134
void tiedarrsetfn(Param pm , char *x ) ;
#line 135
void tiedarrunsetfn(Param pm , int exp  __attribute__((__unused__)) ) ;
#line 137
void uniqarray(char **x ) ;
#line 139
zlong poundgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 140
zlong randomgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 141
void randomsetfn(Param pm  __attribute__((__unused__)) , zlong v ) ;
#line 142
zlong intsecondsgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 143
void intsecondssetfn(Param pm  __attribute__((__unused__)) , zlong x ) ;
#line 144
double floatsecondsgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 145
void floatsecondssetfn(Param pm  __attribute__((__unused__)) , double x ) ;
#line 146
double getrawseconds(void) ;
#line 147
void setrawseconds(double x ) ;
#line 148
int setsecondstype(Param pm , int on , int off ) ;
#line 149
char *usernamegetfn(Param pm  __attribute__((__unused__)) ) ;
#line 150
void usernamesetfn(Param pm  __attribute__((__unused__)) , char *x ) ;
#line 151
zlong uidgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 152
void uidsetfn(Param pm  __attribute__((__unused__)) , zlong x ) ;
#line 153
zlong euidgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 154
void euidsetfn(Param pm  __attribute__((__unused__)) , zlong x ) ;
#line 155
zlong gidgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 156
void gidsetfn(Param pm  __attribute__((__unused__)) , zlong x ) ;
#line 157
zlong egidgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 158
void egidsetfn(Param pm  __attribute__((__unused__)) , zlong x ) ;
#line 160
char *ifsgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 161
void ifssetfn(Param pm  __attribute__((__unused__)) , char *x ) ;
#line 162
void lc_allsetfn(Param pm , char *x ) ;
#line 163
void langsetfn(Param pm , char *x ) ;
#line 164
void lcsetfn(Param pm , char *x ) ;
#line 165
zlong histsizegetfn(Param pm  __attribute__((__unused__)) ) ;
#line 166
void histsizesetfn(Param pm  __attribute__((__unused__)) , zlong v ) ;
#line 167
zlong savehistsizegetfn(Param pm  __attribute__((__unused__)) ) ;
#line 168
void savehistsizesetfn(Param pm  __attribute__((__unused__)) , zlong v ) ;
#line 169
void errnosetfn(Param pm  __attribute__((__unused__)) , zlong x ) ;
#line 170
zlong errnogetfn(Param pm  __attribute__((__unused__)) ) ;
#line 171
char *keyboardhackgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 172
void keyboardhacksetfn(Param pm  __attribute__((__unused__)) , char *x ) ;
#line 173
char *histcharsgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 174
void histcharssetfn(Param pm  __attribute__((__unused__)) , char *x ) ;
#line 175
char *homegetfn(Param pm  __attribute__((__unused__)) ) ;
#line 176
void homesetfn(Param pm  __attribute__((__unused__)) , char *x ) ;
#line 177
char *wordcharsgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 178
void wordcharssetfn(Param pm  __attribute__((__unused__)) , char *x ) ;
#line 179
char *underscoregetfn(Param pm  __attribute__((__unused__)) ) ;
#line 180
char *termgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 181
void termsetfn(Param pm  __attribute__((__unused__)) , char *x ) ;
#line 182
char *terminfogetfn(Param pm  __attribute__((__unused__)) ) ;
#line 183
void terminfosetfn(Param pm , char *x ) ;
#line 184
char *terminfodirsgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 185
void terminfodirssetfn(Param pm , char *x ) ;
#line 186
void arrfixenv(char *s , char **t ) ;
#line 187
int zputenv(char *str ) ;
#line 191
void addenv(Param pm , char *value ) ;
#line 193
void delenv(Param pm ) ;
#line 194
void convbase_ptr(char *s , zlong v , int base , int *ndigits ) ;
#line 197
char *convfloat(double dval , int digits , int flags , FILE *fout ) ;
#line 199
void startparamscope(void) ;
#line 200
void endparamscope(void) ;
#line 201
void freeparamnode(HashNode hn ) ;
#line 202
void printparamnode(HashNode hn , int printflags ) ;
#line 2 "./params.pro"
static HashNode getparamnode(HashTable ht , char const   *nam ) ;
#line 3
static void scancopyparams(HashNode hn , int flags  __attribute__((__unused__)) ) ;
#line 4
static void scanparamvals(HashNode hn , int flags ) ;
#line 5
static char **getvaluearr(Value v ) ;
#line 6
static void shempty(void) ;
#line 7
static zlong getarg(char **str , int *inv , Value v , int a2 , zlong *w , int *prevcharlen ,
                    int *nextcharlen ) ;
#line 8
static void check_warn_pm(Param pm , char const   *pmtype , int created , int may_warn_about_nested_vars ) ;
#line 9
static void intsetfn(Param pm , zlong x ) ;
#line 10
static double floatgetfn(Param pm ) ;
#line 11
static void floatsetfn(Param pm , double x ) ;
#line 12
static void simple_arrayuniq(char **x , int freeok ) ;
#line 13
static void arrayuniq_freenode(HashNode hn ) ;
#line 14
static void arrayuniq(char **x , int freeok ) ;
#line 15
static void setlang(char *x ) ;
#line 16
static void argzerosetfn(Param pm  __attribute__((__unused__)) , char *x ) ;
#line 17
static char *argzerogetfn(Param pm  __attribute__((__unused__)) ) ;
#line 18
static char **pipestatgetfn(Param pm  __attribute__((__unused__)) ) ;
#line 19
static void pipestatsetfn(Param pm  __attribute__((__unused__)) , char **x ) ;
#line 23
static void copyenvstr(char *s , char *value , int flags ) ;
#line 24
static char *mkenvstr(char *name , char *value , int flags ) ;
#line 25
static void scanendscope(HashNode hn , int flags  __attribute__((__unused__)) ) ;
#line 117 "/tmp/zsh-5.4.2/Src/params.c"
unsigned char keyboardhackchar  =    (unsigned char )'\000';
#line 133
static void rprompt_indent_unsetfn(Param pm , int exp ) ;
#line 139 "/tmp/zsh-5.4.2/Src/params.c"
struct gsu_scalar  const  stdscalar_gsu  =    {& strgetfn, & strsetfn, & stdunsetfn};
#line 142 "/tmp/zsh-5.4.2/Src/params.c"
struct gsu_scalar  const  varscalar_gsu  =    {& strvargetfn, & strvarsetfn, & stdunsetfn};
#line 145 "/tmp/zsh-5.4.2/Src/params.c"
struct gsu_scalar  const  nullsetscalar_gsu  =    {& strgetfn, & nullstrsetfn, (void (*)(Param  , int  ))((void *)0)};
#line 149 "/tmp/zsh-5.4.2/Src/params.c"
struct gsu_integer  const  stdinteger_gsu  =    {& intgetfn, & intsetfn, & stdunsetfn};
#line 152 "/tmp/zsh-5.4.2/Src/params.c"
struct gsu_integer  const  varinteger_gsu  =    {& intvargetfn, & intvarsetfn, & stdunsetfn};
#line 155 "/tmp/zsh-5.4.2/Src/params.c"
struct gsu_integer  const  nullsetinteger_gsu  =    {& intgetfn, (void (*)(Param  , zlong  ))((void *)0), (void (*)(Param  , int  ))((void *)0)};
#line 159 "/tmp/zsh-5.4.2/Src/params.c"
struct gsu_float  const  stdfloat_gsu  =    {& floatgetfn, & floatsetfn, & stdunsetfn};
#line 163 "/tmp/zsh-5.4.2/Src/params.c"
struct gsu_array  const  stdarray_gsu  =    {& arrgetfn, & arrsetfn, & stdunsetfn};
#line 166 "/tmp/zsh-5.4.2/Src/params.c"
struct gsu_array  const  vararray_gsu  =    {& arrvargetfn, & arrvarsetfn, & stdunsetfn};
#line 170 "/tmp/zsh-5.4.2/Src/params.c"
struct gsu_hash  const  stdhash_gsu  =    {& hashgetfn, & hashsetfn, & stdunsetfn};
#line 173 "/tmp/zsh-5.4.2/Src/params.c"
struct gsu_hash  const  nullsethash_gsu  =    {& hashgetfn, & nullsethashfn, & nullunsetfn};
#line 178 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  pound_gsu  =    {& poundgetfn, & nullintsetfn, & stdunsetfn};
#line 180 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  errno_gsu  =    {& errnogetfn, & errnosetfn, & stdunsetfn};
#line 182 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  gid_gsu  =    {& gidgetfn, & gidsetfn, & stdunsetfn};
#line 184 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  egid_gsu  =    {& egidgetfn, & egidsetfn, & stdunsetfn};
#line 186 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  histsize_gsu  =    {& histsizegetfn, & histsizesetfn, & stdunsetfn};
#line 188 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  random_gsu  =    {& randomgetfn, & randomsetfn, & stdunsetfn};
#line 190 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  savehist_gsu  =    {& savehistsizegetfn, & savehistsizesetfn, & stdunsetfn};
#line 192 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  intseconds_gsu  =    {& intsecondsgetfn, & intsecondssetfn, & stdunsetfn};
#line 194 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_float  const  floatseconds_gsu  =    {& floatsecondsgetfn, & floatsecondssetfn, & stdunsetfn};
#line 196 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  uid_gsu  =    {& uidgetfn, & uidsetfn, & stdunsetfn};
#line 198 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  euid_gsu  =    {& euidgetfn, & euidsetfn, & stdunsetfn};
#line 200 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  ttyidle_gsu  =    {& ttyidlegetfn, & nullintsetfn, & stdunsetfn};
#line 203 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  argzero_gsu  =    {& argzerogetfn, & argzerosetfn, & nullunsetfn};
#line 205 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  username_gsu  =    {& usernamegetfn, & usernamesetfn, & stdunsetfn};
#line 207 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  dash_gsu  =    {& dashgetfn, & nullstrsetfn, & stdunsetfn};
#line 209 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  histchars_gsu  =    {& histcharsgetfn, & histcharssetfn, & stdunsetfn};
#line 211 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  home_gsu  =    {& homegetfn, & homesetfn, & stdunsetfn};
#line 213 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  term_gsu  =    {& termgetfn, & termsetfn, & stdunsetfn};
#line 215 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  terminfo_gsu  =    {& terminfogetfn, & terminfosetfn, & stdunsetfn};
#line 217 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  terminfodirs_gsu  =    {& terminfodirsgetfn, & terminfodirssetfn, & stdunsetfn};
#line 219 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  wordchars_gsu  =    {& wordcharsgetfn, & wordcharssetfn, & stdunsetfn};
#line 221 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  ifs_gsu  =    {& ifsgetfn, & ifssetfn, & stdunsetfn};
#line 223 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  underscore_gsu  =    {& underscoregetfn, & nullstrsetfn, & stdunsetfn};
#line 225 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  keyboard_hack_gsu  =    {& keyboardhackgetfn, & keyboardhacksetfn, & stdunsetfn};
#line 228 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  lc_blah_gsu  =    {& strgetfn, & lcsetfn, & stdunsetfn};
#line 230 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  lang_gsu  =    {& strgetfn, & langsetfn, & stdunsetfn};
#line 232 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  lc_all_gsu  =    {& strgetfn, & lc_allsetfn, & stdunsetfn};
#line 236 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  varint_readonly_gsu  =    {& intvargetfn, & nullintsetfn, & stdunsetfn};
#line 238 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  zlevar_gsu  =    {& intvargetfn, & zlevarsetfn, & stdunsetfn};
#line 241 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_scalar  const  colonarr_gsu  =    {& colonarrgetfn, & colonarrsetfn, & stdunsetfn};
#line 244 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  argc_gsu  =    {& poundgetfn, & nullintsetfn, & stdunsetfn};
#line 246 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_array  const  pipestatus_gsu  =    {& pipestatgetfn, & pipestatsetfn, & stdunsetfn};
#line 249 "/tmp/zsh-5.4.2/Src/params.c"
static struct gsu_integer  const  rprompt_indent_gsu  =    {& intvargetfn, & zlevarsetfn, & rprompt_indent_unsetfn};
#line 274 "/tmp/zsh-5.4.2/Src/params.c"
static initparam special_params[91]  = 
#line 274
  {      {{(HashNode )((void *)0), (char *)"#", ((1 << 1) | (1 << 22)) | (1 << 10)}, {(void *)0},
      {(GsuScalar )((void *)(& pound_gsu))}, 10, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"ERRNO", ((1 << 1) | (1 << 22)) | (1 << 25)},
      {(void *)0}, {(GsuScalar )((void *)(& errno_gsu))}, 10, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"GID", (((1 << 1) | (1 << 22)) | (1 << 23)) | (1 << 24)},
      {(void *)0}, {(GsuScalar )((void *)(& gid_gsu))}, 10, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"EGID", (((1 << 1) | (1 << 22)) | (1 << 23)) | (1 << 24)},
      {(void *)0}, {(GsuScalar )((void *)(& egid_gsu))}, 10, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"HISTSIZE", ((1 << 1) | (1 << 22)) | (1 << 24)},
      {(void *)0}, {(GsuScalar )((void *)(& histsize_gsu))}, 10, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"RANDOM", (1 << 1) | (1 << 22)}, {(void *)0},
      {(GsuScalar )((void *)(& random_gsu))}, 10, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"SAVEHIST", ((1 << 1) | (1 << 22)) | (1 << 24)},
      {(void *)0}, {(GsuScalar )((void *)(& savehist_gsu))}, 10, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"SECONDS", (1 << 1) | (1 << 22)}, {(void *)0},
      {(GsuScalar )((void *)(& intseconds_gsu))}, 10, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"UID", (((1 << 1) | (1 << 22)) | (1 << 23)) | (1 << 24)},
      {(void *)0}, {(GsuScalar )((void *)(& uid_gsu))}, 10, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"EUID", (((1 << 1) | (1 << 22)) | (1 << 23)) | (1 << 24)},
      {(void *)0}, {(GsuScalar )((void *)(& euid_gsu))}, 10, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"TTYIDLE", ((1 << 1) | (1 << 22)) | (1 << 10)},
      {(void *)0}, {(GsuScalar )((void *)(& ttyidle_gsu))}, 10, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"USERNAME", ((1 << 22) | (1 << 23)) | (1 << 24)},
      {(void *)0}, {(GsuScalar )((void *)(& username_gsu))}, 0, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"-", (1 << 22) | (1 << 10)}, {(void *)0}, {(GsuScalar )((void *)(& dash_gsu))},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"histchars", (1 << 22) | (1 << 23)}, {(void *)0},
      {(GsuScalar )((void *)(& histchars_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"HOME", (1 << 22) | (1 << 25)}, {(void *)0},
      {(GsuScalar )((void *)(& home_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"TERM", (1 << 22) | (1 << 25)}, {(void *)0},
      {(GsuScalar )((void *)(& term_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"TERMINFO", (1 << 22) | (1 << 25)}, {(void *)0},
      {(GsuScalar )((void *)(& terminfo_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"TERMINFO_DIRS", (1 << 22) | (1 << 25)}, {(void *)0},
      {(GsuScalar )((void *)(& terminfodirs_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"WORDCHARS", 1 << 22}, {(void *)0}, {(GsuScalar )((void *)(& wordchars_gsu))},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"IFS", ((1 << 22) | (1 << 23)) | (1 << 24)},
      {(void *)0}, {(GsuScalar )((void *)(& ifs_gsu))}, 0, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"_", (1 << 22) | (1 << 23)}, {(void *)0}, {(GsuScalar )((void *)(& underscore_gsu))},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"KEYBOARD_HACK", (1 << 22) | (1 << 23)}, {(void *)0},
      {(GsuScalar )((void *)(& keyboard_hack_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"0", 1 << 22}, {(void *)0}, {(GsuScalar )((void *)(& argzero_gsu))},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"LANG", (1 << 22) | (1 << 25)}, {(void *)0},
      {(GsuScalar )((void *)(& lang_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"LC_ALL", (1 << 22) | (1 << 25)}, {(void *)0},
      {(GsuScalar )((void *)(& lc_all_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"LC_COLLATE", (1 << 22) | (1 << 25)}, {(void *)0},
      {(GsuScalar )((void *)(& lc_blah_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"LC_CTYPE", (1 << 22) | (1 << 25)}, {(void *)0},
      {(GsuScalar )((void *)(& lc_blah_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"LC_MESSAGES", (1 << 22) | (1 << 25)}, {(void *)0},
      {(GsuScalar )((void *)(& lc_blah_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"LC_NUMERIC", (1 << 22) | (1 << 25)}, {(void *)0},
      {(GsuScalar )((void *)(& lc_blah_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"LC_TIME", (1 << 22) | (1 << 25)}, {(void *)0},
      {(GsuScalar )((void *)(& lc_blah_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"!", ((1 << 1) | (1 << 10)) | (1 << 22)}, {(void *)(& lastpid)},
      {(GsuScalar )((void *)(& varint_readonly_gsu))}, 10, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"$", ((1 << 1) | (1 << 10)) | (1 << 22)}, {(void *)(& mypid)},
      {(GsuScalar )((void *)(& varint_readonly_gsu))}, 10, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"?", ((1 << 1) | (1 << 10)) | (1 << 22)}, {(void *)(& lastval)},
      {(GsuScalar )((void *)(& varint_readonly_gsu))}, 10, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"HISTCMD", ((1 << 1) | (1 << 10)) | (1 << 22)},
      {(void *)(& curhist)}, {(GsuScalar )((void *)(& varint_readonly_gsu))}, 10,
      0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"LINENO", ((1 << 1) | (1 << 10)) | (1 << 22)},
      {(void *)(& lineno)}, {(GsuScalar )((void *)(& varint_readonly_gsu))}, 10, 0,
      (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"PPID", ((1 << 1) | (1 << 10)) | (1 << 22)},
      {(void *)(& ppid)}, {(GsuScalar )((void *)(& varint_readonly_gsu))}, 10, 0,
      (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"ZSH_SUBSHELL", ((1 << 1) | (1 << 10)) | (1 << 22)},
      {(void *)(& zsh_subshell)}, {(GsuScalar )((void *)(& varint_readonly_gsu))},
      10, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"COLUMNS", (1 << 1) | (1 << 22)}, {(void *)(& zterm_columns)},
      {(GsuScalar )((void *)(& zlevar_gsu))}, 10, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"LINES", (1 << 1) | (1 << 22)}, {(void *)(& zterm_lines)},
      {(GsuScalar )((void *)(& zlevar_gsu))}, 10, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"ZLE_RPROMPT_INDENT", ((1 << 1) | (1 << 22)) | (1 << 25)},
      {(void *)(& rprompt_indent)}, {(GsuScalar )((void *)(& rprompt_indent_gsu))},
      10, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"SHLVL", (1 << 1) | (1 << 22)}, {(void *)(& shlvl)},
      {(GsuScalar )((void *)(& varinteger_gsu))}, 10, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"OPTIND", ((1 << 1) | (1 << 22)) | (1 << 23)},
      {(void *)(& zoptind)}, {(GsuScalar )((void *)(& varinteger_gsu))}, 10, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"TRY_BLOCK_ERROR", ((1 << 1) | (1 << 22)) | (1 << 23)},
      {(void *)(& try_errflag)}, {(GsuScalar )((void *)(& varinteger_gsu))}, 10, 0,
      (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"TRY_BLOCK_INTERRUPT", ((1 << 1) | (1 << 22)) | (1 << 23)},
      {(void *)(& try_interrupt)}, {(GsuScalar )((void *)(& varinteger_gsu))}, 10,
      0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"OPTARG", 1 << 22}, {(void *)(& zoptarg)},
      {(GsuScalar )((void *)(& varscalar_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"NULLCMD", 1 << 22}, {(void *)(& nullcmd)},
      {(GsuScalar )((void *)(& varscalar_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"POSTEDIT", (1 << 22) | (1 << 25)}, {(void *)(& postedit)},
      {(GsuScalar )((void *)(& varscalar_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"READNULLCMD", 1 << 22}, {(void *)(& readnullcmd)},
      {(GsuScalar )((void *)(& varscalar_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"PS1", 1 << 22}, {(void *)(& prompt)}, {(GsuScalar )((void *)(& varscalar_gsu))},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"RPS1", (1 << 22) | (1 << 25)}, {(void *)(& rprompt)},
      {(GsuScalar )((void *)(& varscalar_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"RPROMPT", (1 << 22) | (1 << 25)}, {(void *)(& rprompt)},
      {(GsuScalar )((void *)(& varscalar_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"PS2", 1 << 22}, {(void *)(& prompt2)}, {(GsuScalar )((void *)(& varscalar_gsu))},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"RPS2", (1 << 22) | (1 << 25)}, {(void *)(& rprompt2)},
      {(GsuScalar )((void *)(& varscalar_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"RPROMPT2", (1 << 22) | (1 << 25)}, {(void *)(& rprompt2)},
      {(GsuScalar )((void *)(& varscalar_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"PS3", 1 << 22}, {(void *)(& prompt3)}, {(GsuScalar )((void *)(& varscalar_gsu))},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"PS4", (1 << 22) | (1 << 19)}, {(void *)(& prompt4)},
      {(GsuScalar )((void *)(& varscalar_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"SPROMPT", 1 << 22}, {(void *)(& sprompt)},
      {(GsuScalar )((void *)(& varscalar_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"*", (((((1 | (1 << 22)) | (1 << 23)) | (1 << 10)) | 1) | (1 << 22)) | (1 << 23)},
      {(void *)(& pparams)}, {(GsuScalar )((void *)(& vararray_gsu))}, 0, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"@", (((((1 | (1 << 22)) | (1 << 23)) | (1 << 10)) | 1) | (1 << 22)) | (1 << 23)},
      {(void *)(& pparams)}, {(GsuScalar )((void *)(& vararray_gsu))}, 0, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)((void *)0), 0}, {(void *)0}, {(GsuScalar )((void *)0)},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"CDPATH", 1 << 22}, {(void *)(& cdpath)}, {(GsuScalar )((void *)(& colonarr_gsu))},
      0, 0, (char *)((void *)0), (char *)"cdpath", (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"FIGNORE", 1 << 22}, {(void *)(& fignore)},
      {(GsuScalar )((void *)(& colonarr_gsu))}, 0, 0, (char *)((void *)0), (char *)"fignore",
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"FPATH", 1 << 22}, {(void *)(& fpath)}, {(GsuScalar )((void *)(& colonarr_gsu))},
      0, 0, (char *)((void *)0), (char *)"fpath", (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"MAILPATH", 1 << 22}, {(void *)(& mailpath)},
      {(GsuScalar )((void *)(& colonarr_gsu))}, 0, 0, (char *)((void *)0), (char *)"mailpath",
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"WATCH", 1 << 22}, {(void *)(& watch)}, {(GsuScalar )((void *)(& colonarr_gsu))},
      0, 0, (char *)((void *)0), (char *)"watch", (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"PATH", (1 << 24) | (1 << 22)}, {(void *)(& path)},
      {(GsuScalar )((void *)(& colonarr_gsu))}, 0, 0, (char *)((void *)0), (char *)"path",
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"PSVAR", 1 << 22}, {(void *)(& psvar)}, {(GsuScalar )((void *)(& colonarr_gsu))},
      0, 0, (char *)((void *)0), (char *)"psvar", (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"ZSH_EVAL_CONTEXT", (1 << 10) | (1 << 22)},
      {(void *)(& zsh_eval_context)}, {(GsuScalar )((void *)(& colonarr_gsu))}, 0,
      0, (char *)((void *)0), (char *)"zsh_eval_context", (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0),
       (char *)"MODULE_PATH", ((1 << 23) | (1 << 24)) | (1 << 22)}, {(void *)(& module_path)},
      {(GsuScalar )((void *)(& colonarr_gsu))}, 0, 0, (char *)((void *)0), (char *)"module_path",
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"ARGC", ((1 << 1) | (1 << 22)) | (1 << 10)},
      {(void *)0}, {(GsuScalar )((void *)(& argc_gsu))}, 10, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"HISTCHARS", (1 << 22) | (1 << 23)}, {(void *)0},
      {(GsuScalar )((void *)(& histchars_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"status", ((1 << 1) | (1 << 10)) | (1 << 22)},
      {(void *)(& lastval)}, {(GsuScalar )((void *)(& varint_readonly_gsu))}, 10,
      0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"prompt", 1 << 22}, {(void *)(& prompt)}, {(GsuScalar )((void *)(& varscalar_gsu))},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"PROMPT", 1 << 22}, {(void *)(& prompt)}, {(GsuScalar )((void *)(& varscalar_gsu))},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"PROMPT2", 1 << 22}, {(void *)(& prompt2)},
      {(GsuScalar )((void *)(& varscalar_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"PROMPT3", 1 << 22}, {(void *)(& prompt3)},
      {(GsuScalar )((void *)(& varscalar_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"PROMPT4", 1 << 22}, {(void *)(& prompt4)},
      {(GsuScalar )((void *)(& varscalar_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"MANPATH", 1 << 22}, {(void *)(& manpath)},
      {(GsuScalar )((void *)(& colonarr_gsu))}, 0, 0, (char *)((void *)0), (char *)"manpath",
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"argv", (1 | (1 << 22)) | (1 << 23)}, {(void *)(& pparams)},
      {(GsuScalar )((void *)(& vararray_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"fignore", (1 | (1 << 22)) | (1 << 23)}, {(void *)(& fignore)},
      {(GsuScalar )((void *)(& vararray_gsu))}, 0, 0, (char *)((void *)0), (char *)"FIGNORE",
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"cdpath", (1 | (1 << 22)) | (1 << 23)}, {(void *)(& cdpath)},
      {(GsuScalar )((void *)(& vararray_gsu))}, 0, 0, (char *)((void *)0), (char *)"CDPATH",
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"fpath", (1 | (1 << 22)) | (1 << 23)}, {(void *)(& fpath)},
      {(GsuScalar )((void *)(& vararray_gsu))}, 0, 0, (char *)((void *)0), (char *)"FPATH",
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"mailpath", (1 | (1 << 22)) | (1 << 23)}, {(void *)(& mailpath)},
      {(GsuScalar )((void *)(& vararray_gsu))}, 0, 0, (char *)((void *)0), (char *)"MAILPATH",
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"manpath", (1 | (1 << 22)) | (1 << 23)}, {(void *)(& manpath)},
      {(GsuScalar )((void *)(& vararray_gsu))}, 0, 0, (char *)((void *)0), (char *)"MANPATH",
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"psvar", (1 | (1 << 22)) | (1 << 23)}, {(void *)(& psvar)},
      {(GsuScalar )((void *)(& vararray_gsu))}, 0, 0, (char *)((void *)0), (char *)"PSVAR",
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"watch", (1 | (1 << 22)) | (1 << 23)}, {(void *)(& watch)},
      {(GsuScalar )((void *)(& vararray_gsu))}, 0, 0, (char *)((void *)0), (char *)"WATCH",
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"zsh_eval_context", (((1 << 10) | 1) | (1 << 22)) | (1 << 23)},
      {(void *)(& zsh_eval_context)}, {(GsuScalar )((void *)(& vararray_gsu))}, 0,
      0, (char *)((void *)0), (char *)"ZSH_EVAL_CONTEXT", (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0),
       (char *)"module_path", (((1 << 24) | 1) | (1 << 22)) | (1 << 23)}, {(void *)(& module_path)},
      {(GsuScalar )((void *)(& vararray_gsu))}, 0, 0, (char *)((void *)0), (char *)"MODULE_PATH",
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"path", (((1 << 24) | 1) | (1 << 22)) | (1 << 23)},
      {(void *)(& path)}, {(GsuScalar )((void *)(& vararray_gsu))}, 0, 0, (char *)((void *)0),
      (char *)"PATH", (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"pipestatus", 1 | (1 << 22)}, {(void *)0},
      {(GsuScalar )((void *)(& pipestatus_gsu))}, 10, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)((void *)0), 0}, {(void *)0}, {(GsuScalar )((void *)0)},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}};
#line 430 "/tmp/zsh-5.4.2/Src/params.c"
static initparam special_params_sh[10]  = 
#line 430
  {      {{(HashNode )((void *)0), (char *)"CDPATH", 1 << 22}, {(void *)(& cdpath)}, {(GsuScalar )((void *)(& colonarr_gsu))},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"FIGNORE", 1 << 22}, {(void *)(& fignore)},
      {(GsuScalar )((void *)(& colonarr_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"FPATH", 1 << 22}, {(void *)(& fpath)}, {(GsuScalar )((void *)(& colonarr_gsu))},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"MAILPATH", 1 << 22}, {(void *)(& mailpath)},
      {(GsuScalar )((void *)(& colonarr_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"WATCH", 1 << 22}, {(void *)(& watch)}, {(GsuScalar )((void *)(& colonarr_gsu))},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"PATH", (1 << 24) | (1 << 22)}, {(void *)(& path)},
      {(GsuScalar )((void *)(& colonarr_gsu))}, 0, 0, (char *)((void *)0), (char *)((void *)0),
      (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"PSVAR", 1 << 22}, {(void *)(& psvar)}, {(GsuScalar )((void *)(& colonarr_gsu))},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"ZSH_EVAL_CONTEXT", (1 << 10) | (1 << 22)},
      {(void *)(& zsh_eval_context)}, {(GsuScalar )((void *)(& colonarr_gsu))}, 0,
      0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)"MODULE_PATH", ((1 << 23) | (1 << 24)) | (1 << 22)},
      {(void *)(& module_path)}, {(GsuScalar )((void *)(& colonarr_gsu))}, 0, 0, (char *)((void *)0),
      (char *)((void *)0), (Param )((void *)0), 0}, 
        {{(HashNode )((void *)0), (char *)((void *)0), 0}, {(void *)0}, {(GsuScalar )((void *)0)},
      0, 0, (char *)((void *)0), (char *)((void *)0), (Param )((void *)0), 0}};
#line 451 "/tmp/zsh-5.4.2/Src/params.c"
static initparam argvparam_pm  = 
#line 451
     {{(HashNode )((void *)0), (char *)"", ((((1 | (1 << 22)) | (1 << 23)) | 1) | (1 << 22)) | (1 << 23)},
    {(void *)(& pparams)}, {(GsuScalar )((void *)(& vararray_gsu))}, 0, 0, (char *)((void *)0),
    (char *)((void *)0), (Param )((void *)0), 0};
#line 460 "/tmp/zsh-5.4.2/Src/params.c"
static Param argvparam  ;
#line 468 "/tmp/zsh-5.4.2/Src/params.c"
HashTable newparamtable(int size , char const   *name ) 
{ 
  HashTable ht ;

  {
#line 472
  if (! size) {
#line 473
    size = 17;
  }
  {
#line 474
  ht = newhashtable(size, name, (void (*)(HashTable  ))((void *)0));
#line 476
  ht->hash = & hasher;
#line 477
  ht->emptytable = & emptyhashtable;
#line 478
  ht->filltable = (void (*)(HashTable  ))((void *)0);
#line 479
  ht->cmpnodes = (int (*)(char const   * , char const   * ))(& strcmp);
#line 480
  ht->addnode = & addhashnode;
#line 481
  ht->getnode = & getparamnode;
#line 482
  ht->getnode2 = & gethashnode2;
#line 483
  ht->removenode = & removehashnode;
#line 484
  ht->disablenode = (void (*)(HashNode  , int  ))((void *)0);
#line 485
  ht->enablenode = (void (*)(HashNode  , int  ))((void *)0);
#line 486
  ht->freenode = & freeparamnode;
#line 487
  ht->printnode = & printparamnode;
  }
#line 489
  return (ht);
}
}
#line 493 "/tmp/zsh-5.4.2/Src/params.c"
static HashNode getparamnode(HashTable ht , char const   *nam ) 
{ 
  HashNode hn ;
  HashNode tmp ;
  Param pm ;
  char *mn ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 496
  tmp = gethashnode2(ht, nam);
#line 496
  hn = tmp;
#line 497
  pm = (Param )hn;
  }
#line 499
  if (pm) {
#line 499
    if (pm->u.str) {
#line 499
      if (pm->node.flags & (1 << 27)) {
        {
#line 500
        tmp___0 = dupstring((char const   *)pm->u.str);
#line 500
        mn = tmp___0;
        }
#line 502
        if (pm->node.flags & (1 << 28)) {
#line 502
          tmp___1 = (char const   *)((void *)0);
        } else {
#line 502
          tmp___1 = nam;
        }
        {
#line 502
        ensurefeature((char const   *)mn, "p:", tmp___1);
#line 504
        hn = gethashnode2(ht, nam);
        }
#line 505
        if (! hn) {
          {
#line 511
          zerr("autoloading module %s failed to define parameter: %s", mn, nam);
          }
        }
      }
    }
  }
#line 515
  return (hn);
}
}
#line 520 "/tmp/zsh-5.4.2/Src/params.c"
static HashTable outtable  ;
#line 523 "/tmp/zsh-5.4.2/Src/params.c"
static void scancopyparams(HashNode hn , int flags  __attribute__((__unused__)) ) 
{ 
  Param pm ;
  Param tpm ;
  void *tmp ;

  {
  {
#line 527
  pm = (Param )hn;
#line 528
  tmp = zshcalloc(sizeof(*tpm));
#line 528
  tpm = (Param )tmp;
#line 529
  tpm->node.nam = ztrdup((char const   *)pm->node.nam);
#line 530
  copyparam(tpm, pm, 0);
#line 531
  addhashnode(outtable, tpm->node.nam, (void *)tpm);
  }
#line 532
  return;
}
}
#line 535 "/tmp/zsh-5.4.2/Src/params.c"
HashTable copyparamtable(HashTable ht , char *name ) 
{ 
  HashTable nht ;
  HashTable tmp ;

  {
  {
#line 538
  tmp = newparamtable(ht->hsize, (char const   *)name);
#line 538
  nht = tmp;
#line 539
  outtable = nht;
#line 540
  scanhashtable(ht, 0, 0, 0, & scancopyparams, 0);
#line 541
  outtable = (HashTable )((void *)0);
  }
#line 542
  return (nht);
}
}
#line 547 "/tmp/zsh-5.4.2/Src/params.c"
static int delunset  ;
#line 552 "/tmp/zsh-5.4.2/Src/params.c"
void deleteparamtable(HashTable t ) 
{ 
  int odelunset ;

  {
  {
#line 557
  odelunset = delunset;
#line 558
  delunset = 1;
#line 559
  deletehashtable(t);
#line 560
  delunset = odelunset;
  }
#line 561
  return;
}
}
#line 563 "/tmp/zsh-5.4.2/Src/params.c"
static unsigned int numparamvals  ;
#line 566 "/tmp/zsh-5.4.2/Src/params.c"
void scancountparams(HashNode hn  __attribute__((__unused__)) , int flags ) 
{ 


  {
#line 569
  numparamvals ++;
#line 570
  if (flags & (1 << 1)) {
#line 570
    if (flags & 1) {
#line 571
      numparamvals ++;
    }
  }
#line 572
  return;
}
}
#line 574 "/tmp/zsh-5.4.2/Src/params.c"
static Patprog scanprog  ;
#line 575 "/tmp/zsh-5.4.2/Src/params.c"
static char *scanstr  ;
#line 576 "/tmp/zsh-5.4.2/Src/params.c"
static char **paramvals  ;
#line 577 "/tmp/zsh-5.4.2/Src/params.c"
static Param foundparam  ;
#line 580 "/tmp/zsh-5.4.2/Src/params.c"
static void scanparamvals(HashNode hn , int flags ) 
{ 
  struct value v ;
  Patprog prog ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 586
  if (numparamvals) {
#line 586
    if (! (flags & (1 << 5))) {
#line 586
      if (flags & (((1 << 4) | (1 << 3)) | (1 << 7))) {
#line 588
        return;
      }
    }
  }
#line 589
  v.pm = (Param )hn;
#line 590
  if (flags & (1 << 7)) {
    {
#line 591
    tmp___0 = dupstring((char const   *)(v.pm)->node.nam);
#line 591
    tmp = tmp___0;
#line 593
    tokenize(tmp);
#line 594
    remnulargs(tmp);
#line 596
    prog = patcompile(tmp, 0, (char **)((void *)0));
    }
#line 596
    if (prog) {
      {
#line 596
      tmp___1 = pattry(prog, scanstr);
      }
#line 596
      if (! tmp___1) {
#line 597
        return;
      }
    } else {
#line 597
      return;
    }
  } else
#line 598
  if (flags & (1 << 3)) {
    {
#line 598
    tmp___2 = pattry(scanprog, (v.pm)->node.nam);
    }
#line 598
    if (! tmp___2) {
#line 599
      return;
    }
  }
#line 601
  foundparam = v.pm;
#line 602
  if (flags & (1 << 1)) {
#line 603
    tmp___3 = numparamvals;
#line 603
    numparamvals ++;
#line 603
    *(paramvals + tmp___3) = (v.pm)->node.nam;
#line 604
    if (! (flags & (1 | (1 << 4)))) {
#line 605
      return;
    }
  }
  {
#line 607
  v.isarr = ((v.pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) & (1 | (1 << 4));
#line 608
  v.flags = 0;
#line 609
  v.start = 0;
#line 610
  v.end = -1;
#line 611
  *(paramvals + numparamvals) = getstrvalue(& v);
  }
#line 612
  if (flags & (1 << 4)) {
    {
#line 613
    tmp___5 = pattry(scanprog, *(paramvals + numparamvals));
    }
#line 613
    if (tmp___5) {
#line 614
      if (flags & 1) {
#line 614
        tmp___4 = 1;
      } else {
#line 614
        tmp___4 = ! (flags & (1 << 1));
      }
#line 614
      numparamvals += (unsigned int )tmp___4;
    } else
#line 616
    if (flags & (1 << 1)) {
#line 617
      numparamvals --;
    }
  } else {
#line 619
    numparamvals ++;
  }
#line 620
  foundparam = (Param )((void *)0);
#line 621
  return;
}
}
#line 624 "/tmp/zsh-5.4.2/Src/params.c"
char **paramvalarr(HashTable ht , int flags ) 
{ 
  void *tmp ;

  {
#line 629
  numparamvals = 0U;
#line 630
  if (ht) {
    {
#line 631
    scanhashtable(ht, 0, 0, 1 << 25, & scancountparams, flags);
    }
  }
  {
#line 632
  tmp = zhalloc((unsigned long )(numparamvals + 1U) * sizeof(char *));
#line 632
  paramvals = (char **)tmp;
  }
#line 633
  if (ht) {
    {
#line 634
    numparamvals = 0U;
#line 635
    scanhashtable(ht, 0, 0, 1 << 25, & scanparamvals, flags);
    }
  }
#line 637
  *(paramvals + numparamvals) = (char *)0;
#line 638
  return (paramvals);
}
}
#line 645 "/tmp/zsh-5.4.2/Src/params.c"
static char **getvaluearr(Value v ) 
{ 
  char **tmp ;
  HashTable tmp___0 ;

  {
#line 648
  if (v->arr) {
#line 649
    return (v->arr);
  } else
#line 650
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
    {
#line 651
    tmp = (*(((v->pm)->gsu.a)->getfn))(v->pm);
#line 651
    v->arr = tmp;
    }
#line 651
    return (tmp);
  } else
#line 652
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
    {
#line 653
    tmp___0 = (*(((v->pm)->gsu.h)->getfn))(v->pm);
#line 653
    v->arr = paramvalarr(tmp___0, v->isarr);
#line 655
    v->start = 0;
#line 656
    v->end = (int )(numparamvals + 1U);
    }
#line 657
    return (v->arr);
  } else {
#line 659
    return ((char **)((void *)0));
  }
}
}
#line 667 "/tmp/zsh-5.4.2/Src/params.c"
int issetvar(char *name ) 
{ 
  struct value vbuf ;
  Value v ;
  int slice ;
  char **arr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char tmp___2 ;

  {
  {
#line 675
  v = getvalue(& vbuf, & name, 1);
  }
#line 675
  if (v) {
#line 675
    if (*name) {
#line 676
      return (0);
    }
  } else {
#line 676
    return (0);
  }
#line 677
  if (v->isarr & ~ (1 << 9)) {
#line 678
    return (v->end > 1);
  }
#line 680
  if (v->start != 0) {
#line 680
    tmp = 1;
  } else
#line 680
  if (v->end != -1) {
#line 680
    tmp = 1;
  } else {
#line 680
    tmp = 0;
  }
#line 680
  slice = tmp;
#line 681
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) != 1) {
#line 681
    goto _L;
  } else
#line 681
  if (! slice) {
    _L: /* CIL Label */ 
#line 682
    if (! slice) {
#line 682
      if (! ((v->pm)->node.flags & (1 << 25))) {
#line 682
        tmp___0 = 1;
      } else {
#line 682
        tmp___0 = 0;
      }
    } else {
#line 682
      tmp___0 = 0;
    }
#line 682
    return (tmp___0);
  }
#line 684
  if (! v->end) {
#line 685
    return (0);
  }
  {
#line 687
  arr = getvaluearr(v);
  }
#line 687
  if (! arr) {
#line 688
    return (0);
  }
#line 689
  if (v->end < 0) {
#line 689
    tmp___1 = - v->end;
  } else {
#line 689
    tmp___1 = v->end;
  }
  {
#line 689
  tmp___2 = arrlen_ge(arr, (unsigned int )tmp___1);
  }
#line 689
  return ((int )tmp___2);
}
}
#line 698 "/tmp/zsh-5.4.2/Src/params.c"
static int split_env_string(char *env , char **name , char **value ) 
{ 
  char *str ;
  char *tenv ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 703
  if (! env) {
#line 704
    return (0);
  } else
#line 703
  if (! name) {
#line 704
    return (0);
  } else
#line 703
  if (! value) {
#line 704
    return (0);
  }
  {
#line 706
  tmp = strlen((char const   *)env);
#line 706
  tmp___0 = zhalloc(tmp + 1UL);
#line 706
  tenv = strcpy((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)env);
#line 707
  str = tenv;
  }
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (*str) {
#line 707
      if (! ((int )*str != 61)) {
#line 707
        goto while_break;
      }
    } else {
#line 707
      goto while_break;
    }
#line 708
    if ((int )((unsigned char )*str) >= 128) {
#line 714
      return (0);
    }
#line 707
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 717
  if ((unsigned long )str != (unsigned long )tenv) {
#line 717
    if ((int )*str == 61) {
#line 718
      *str = (char )'\000';
#line 719
      *name = tenv;
#line 720
      *value = str + 1;
#line 721
      return (1);
    } else {
#line 723
      return (0);
    }
  } else {
#line 723
    return (0);
  }
}
}
#line 732 "/tmp/zsh-5.4.2/Src/params.c"
static int dontimport(int flags ) 
{ 


  {
#line 735
  if (flags & (1 << 23)) {
#line 736
    return (1);
  }
#line 738
  if (flags & (1 << 12)) {
#line 739
    return (1);
  }
#line 741
  if (flags & (1 << 19)) {
#line 741
    if (opts[139]) {
#line 742
      return (1);
    }
  }
#line 744
  return (0);
}
}
#line 752 "/tmp/zsh-5.4.2/Src/params.c"
void createparamtable(void) 
{ 
  Param ip ;
  Param pm ;
  char **envp2 ;
  char **sigptr ;
  char **t ;
  char buf___7[50] ;
  char *str ;
  char *iname ;
  char *ivalue ;
  char *hostnam ;
  int oae ;
  struct utsname unamebuf ;
  char *machinebuf ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  HashNode tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  HashNode tmp___16 ;
  HashNode tmp___17 ;
  HashNode tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  void *tmp___28 ;
  char **tmp___29 ;
  char *tmp___30 ;
  char **tmp___31 ;

  {
  {
#line 765
  oae = (int )opts[3];
#line 771
  realparamtab = newparamtable(151, "paramtab");
#line 771
  paramtab = realparamtab;
#line 774
  ip = special_params;
  }
  {
#line 774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 774
    if (! ip->node.nam) {
#line 774
      goto while_break;
    }
    {
#line 775
    tmp = ztrdup((char const   *)ip->node.nam);
#line 775
    (*(paramtab->addnode))(paramtab, tmp, (void *)ip);
#line 774
    ip ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 776
  if (emulation & ((1 << 3) | (1 << 2))) {
#line 777
    ip = special_params_sh;
    {
#line 777
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 777
      if (! ip->node.nam) {
#line 777
        goto while_break___0;
      }
      {
#line 778
      tmp___0 = ztrdup((char const   *)ip->node.nam);
#line 778
      (*(paramtab->addnode))(paramtab, tmp___0, (void *)ip);
#line 777
      ip ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 780
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 780
      ip ++;
#line 780
      if (! ip->node.nam) {
#line 780
        goto while_break___1;
      }
      {
#line 781
      tmp___1 = ztrdup((char const   *)ip->node.nam);
#line 781
      (*(paramtab->addnode))(paramtab, tmp___1, (void *)ip);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 784
  argvparam = & argvparam_pm;
#line 786
  noerrs = 2;
#line 792
  opts[3] = (char)0;
#line 793
  setiparam((char *)"MAILCHECK", (zlong )60);
#line 794
  setiparam((char *)"LOGCHECK", (zlong )60);
#line 795
  setiparam((char *)"KEYTIMEOUT", (zlong )40);
#line 796
  setiparam((char *)"LISTMAX", (zlong )100);
#line 807
  tmp___2 = ztrdup_metafy("/tmp/zsh");
#line 807
  setsparam((char *)"TMPPREFIX", tmp___2);
#line 808
  tmp___3 = ztrdup_metafy("%J  %U user %S system %P cpu %*E total");
#line 808
  setsparam((char *)"TIMEFMT", tmp___3);
#line 809
  tmp___4 = ztrdup_metafy((char const   *)default_watchfmt);
#line 809
  setsparam((char *)"WATCHFMT", tmp___4);
#line 811
  tmp___5 = zalloc((size_t )256);
#line 811
  hostnam = (char *)tmp___5;
#line 812
  gethostname(hostnam, (size_t )256);
#line 813
  tmp___6 = ztrdup_metafy((char const   *)hostnam);
#line 813
  setsparam((char *)"HOST", tmp___6);
#line 814
  zfree((void *)hostnam, 256);
#line 816
  str = getlogin();
  }
#line 816
  if (str) {
#line 816
    if (*str) {
#line 816
      tmp___7 = str;
    } else {
#line 816
      tmp___7 = cached_username;
    }
  } else {
#line 816
    tmp___7 = cached_username;
  }
  {
#line 816
  tmp___8 = ztrdup_metafy((char const   *)tmp___7);
#line 816
  setsparam((char *)"LOGNAME", tmp___8);
#line 830
  pushheap();
#line 835
  envp2 = environ;
  }
  {
#line 835
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 835
    if (! *envp2) {
#line 835
      goto while_break___2;
    }
    {
#line 840
    tmp___15 = split_env_string(*envp2, & iname, & ivalue);
    }
#line 840
    if (tmp___15) {
#line 841
      if (! ((int )typtab[(unsigned char )*iname] & 1)) {
        {
#line 841
        tmp___13 = isident(iname);
        }
#line 841
        if (tmp___13) {
          {
#line 841
          tmp___14 = strchr((char const   *)iname, '[');
          }
#line 841
          if (! tmp___14) {
            {
#line 847
            tmp___10 = (*(paramtab->getnode))(paramtab, (char const   *)iname);
#line 847
            pm = (Param )tmp___10;
            }
#line 847
            if (pm) {
              {
#line 847
              tmp___11 = dontimport(pm->node.flags);
              }
#line 847
              if (! tmp___11) {
                _L: /* CIL Label */ 
                {
#line 847
                tmp___12 = metafy(ivalue, -1, 3);
#line 847
                pm = assignsparam(iname, tmp___12, 8);
                }
#line 847
                if (pm) {
#line 851
                  pm->node.flags |= 1 << 12;
#line 852
                  if (pm->node.flags & (1 << 22)) {
                    {
#line 853
                    tmp___9 = getsparam(pm->node.nam);
#line 853
                    pm->env = mkenvstr(pm->node.nam, tmp___9, pm->node.flags);
                    }
                  } else {
                    {
#line 856
                    pm->env = ztrdup((char const   *)*envp2);
                    }
                  }
                }
              }
            } else {
#line 847
              goto _L;
            }
          }
        }
      }
    }
#line 835
    envp2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 864
  popheap();
#line 868
  opts[3] = (char )oae;
#line 874
  tmp___16 = (*(paramtab->getnode))(paramtab, "HOME");
#line 874
  pm = (Param )tmp___16;
  }
#line 875
  if (emulation & (1 << 4)) {
#line 877
    pm->node.flags &= ~ (1 << 25);
#line 878
    if (! (pm->node.flags & (1 << 12))) {
      {
#line 879
      addenv(pm, home);
      }
    }
  } else
#line 880
  if (! home) {
#line 881
    pm->node.flags |= 1 << 25;
  }
  {
#line 882
  tmp___17 = (*(paramtab->getnode))(paramtab, "LOGNAME");
#line 882
  pm = (Param )tmp___17;
  }
#line 883
  if (! (pm->node.flags & (1 << 12))) {
    {
#line 884
    addenv(pm, pm->u.str);
    }
  }
  {
#line 885
  tmp___18 = (*(paramtab->getnode))(paramtab, "SHLVL");
#line 885
  pm = (Param )tmp___18;
#line 886
  shlvl ++;
#line 886
  sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%d",
          (int )shlvl);
#line 888
  addenv(pm, buf___7);
#line 891
  set_pwd_env();
#line 893
  tmp___20 = uname(& unamebuf);
  }
#line 893
  if (tmp___20) {
    {
#line 893
    tmp___19 = ztrdup("unknown");
#line 893
    setsparam((char *)"CPUTYPE", tmp___19);
    }
  } else {
    {
#line 896
    machinebuf = ztrdup_metafy((char const   *)(unamebuf.machine));
#line 897
    setsparam((char *)"CPUTYPE", machinebuf);
    }
  }
  {
#line 903
  tmp___21 = ztrdup_metafy("x86_64");
#line 903
  setsparam((char *)"MACHTYPE", tmp___21);
#line 904
  tmp___22 = ztrdup_metafy("linux-gnu");
#line 904
  setsparam((char *)"OSTYPE", tmp___22);
#line 905
  tmp___23 = ztrdup_metafy((char const   *)ttystrname);
#line 905
  setsparam((char *)"TTY", tmp___23);
#line 906
  tmp___24 = ztrdup_metafy("unknown");
#line 906
  setsparam((char *)"VENDOR", tmp___24);
#line 907
  tmp___25 = ztrdup((char const   *)posixzero);
#line 907
  setsparam((char *)"ZSH_ARGZERO", tmp___25);
#line 908
  tmp___26 = ztrdup_metafy("5.4.2");
#line 908
  setsparam((char *)"ZSH_VERSION", tmp___26);
#line 909
  tmp___27 = ztrdup_metafy("zsh-5.4.2-0-g6ff4787");
#line 909
  setsparam((char *)"ZSH_PATCHLEVEL", tmp___27);
#line 910
  tmp___28 = zalloc(35UL * sizeof(char *));
#line 910
  sigptr = (char **)tmp___28;
#line 910
  setaparam((char *)"signals", sigptr);
#line 911
  t = sigs;
  }
  {
#line 911
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 911
    tmp___29 = sigptr;
#line 911
    sigptr ++;
#line 911
    tmp___31 = t;
#line 911
    t ++;
#line 911
    tmp___30 = ztrdup_metafy((char const   *)*tmp___31);
#line 911
    *tmp___29 = tmp___30;
    }
#line 911
    if (! tmp___30) {
#line 911
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 913
  noerrs = 0;
#line 914
  return;
}
}
#line 919 "/tmp/zsh-5.4.2/Src/params.c"
void assigngetset(Param pm ) 
{ 


  {
  {
#line 923
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 923
    goto case_0;
  }
#line 926
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 926
    goto case_exp;
  }
#line 930
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 930
    goto case_exp___0;
  }
#line 930
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 930
    goto case_exp___0;
  }
#line 933
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 933
    goto case_1;
  }
#line 936
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
#line 936
    goto case_exp___2;
  }
#line 939
  goto switch_default;
  case_0: /* CIL Label */ 
#line 924
  pm->gsu.s = & stdscalar_gsu;
#line 925
  goto switch_break;
  case_exp: /* CIL Label */ 
#line 927
  pm->gsu.i = & stdinteger_gsu;
#line 928
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  case_exp___1: /* CIL Label */ 
#line 931
  pm->gsu.f = & stdfloat_gsu;
#line 932
  goto switch_break;
  case_1: /* CIL Label */ 
#line 934
  pm->gsu.a = & stdarray_gsu;
#line 935
  goto switch_break;
  case_exp___2: /* CIL Label */ 
#line 937
  pm->gsu.h = & stdhash_gsu;
#line 938
  goto switch_break;
  switch_default: /* CIL Label */ ;
#line 941
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 943
  return;
}
}
#line 954 "/tmp/zsh-5.4.2/Src/params.c"
Param createparam(char *name , int flags ) 
{ 
  Param pm ;
  Param oldpm ;
  HashNode tmp ;
  HashNode tmp___0 ;
  HashNode tmp___1 ;
  Param altpm ;
  HashNode tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  Param tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;

  {
#line 959
  if ((unsigned long )paramtab != (unsigned long )realparamtab) {
#line 960
    flags = (flags & ~ (1 << 12)) | (1 << 29);
  }
#line 962
  if ((unsigned long )name != (unsigned long )(nulstring)) {
#line 963
    if ((unsigned long )paramtab == (unsigned long )realparamtab) {
      {
#line 963
      tmp = gethashnode2(paramtab, (char const   *)name);
#line 963
      tmp___1 = tmp;
      }
    } else {
      {
#line 963
      tmp___0 = (*(paramtab->getnode))(paramtab, (char const   *)name);
#line 963
      tmp___1 = tmp___0;
      }
    }
#line 963
    oldpm = (Param )tmp___1;
#line 970
    if (oldpm) {
#line 970
      if (oldpm->level == locallevel) {
#line 970
        goto _L___1;
      } else
#line 970
      if (! (flags & (1 << 21))) {
        _L___1: /* CIL Label */ 
#line 971
        if (opts[131]) {
#line 971
          if (oldpm->node.flags & (1 << 10)) {
            {
#line 972
            zerr("read-only variable: %s", name);
            }
#line 973
            return ((Param )((void *)0));
          }
        }
#line 975
        if (oldpm->node.flags & (1 << 24)) {
#line 975
          if (opts[154]) {
            {
#line 976
            zerr("%s: restricted", name);
            }
#line 977
            return ((Param )((void *)0));
          }
        }
#line 979
        if (! (oldpm->node.flags & (1 << 25))) {
#line 979
          goto _L;
        } else
#line 979
        if (oldpm->node.flags & (1 << 22)) {
#line 979
          goto _L;
        } else
#line 979
        if (opts[131]) {
#line 979
          if (oldpm->node.flags & (1 << 12)) {
            _L: /* CIL Label */ 
#line 983
            oldpm->node.flags &= ~ (1 << 25);
#line 984
            if (oldpm->node.flags & (1 << 22)) {
#line 984
              if (oldpm->ename) {
                {
#line 985
                tmp___2 = (*(paramtab->getnode))(paramtab, (char const   *)oldpm->ename);
#line 985
                altpm = (Param )tmp___2;
                }
#line 987
                if (altpm) {
#line 988
                  altpm->node.flags &= ~ (1 << 25);
                }
              }
            }
#line 990
            return ((Param )((void *)0));
          }
        }
#line 993
        pm = oldpm;
#line 994
        tmp___3 = 0;
#line 994
        pm->width = tmp___3;
#line 994
        pm->base = tmp___3;
#line 995
        oldpm = pm->old;
      } else {
#line 970
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 997
      tmp___4 = zshcalloc(sizeof(*pm));
#line 997
      pm = (Param )tmp___4;
#line 998
      tmp___5 = oldpm;
#line 998
      pm->old = tmp___5;
      }
#line 998
      if (tmp___5) {
#line 1003
        if (oldpm->env) {
          {
#line 1004
          delenv(oldpm);
          }
        }
        {
#line 1005
        (*(paramtab->removenode))(paramtab, (char const   *)name);
        }
      }
      {
#line 1007
      tmp___6 = ztrdup((char const   *)name);
#line 1007
      (*(paramtab->addnode))(paramtab, tmp___6, (void *)pm);
      }
    }
#line 1010
    if (opts[3]) {
#line 1010
      if (! (flags & (1 << 29))) {
#line 1011
        flags |= 1 << 12;
      }
    }
  } else {
    {
#line 1013
    tmp___7 = hcalloc(sizeof(*pm));
#line 1013
    pm = (Param )tmp___7;
#line 1014
    pm->node.nam = nulstring;
    }
  }
#line 1016
  pm->node.flags = flags & ~ (1 << 21);
#line 1018
  if (! (pm->node.flags & (1 << 22))) {
    {
#line 1019
    assigngetset(pm);
    }
  }
#line 1020
  return (pm);
}
}
#line 1026 "/tmp/zsh-5.4.2/Src/params.c"
static void shempty(void) 
{ 


  {
#line 1029
  return;
}
}
#line 1042 "/tmp/zsh-5.4.2/Src/params.c"
Param createspecialhash(char *name , HashNode (*get)(HashTable  , char const   * ) ,
                        void (*scan)(HashTable  , void (*)(HashNode  , int  ) , int  ) ,
                        int flags ) 
{ 
  Param pm ;
  HashTable ht ;
  HashNode (*tmp)(HashTable  , char const   * ) ;

  {
  {
#line 1048
  pm = createparam(name, ((1 << 22) | (1 << 4)) | flags);
  }
#line 1048
  if (! pm) {
#line 1049
    return ((Param )((void *)0));
  }
#line 1065
  if (pm->old) {
#line 1066
    pm->level = locallevel;
  }
#line 1067
  if (flags & (1 << 10)) {
#line 1067
    pm->gsu.h = & stdhash_gsu;
  } else {
#line 1067
    pm->gsu.h = & nullsethash_gsu;
  }
  {
#line 1069
  ht = newhashtable(0, (char const   *)name, (void (*)(HashTable  ))((void *)0));
#line 1069
  pm->u.hash = ht;
#line 1071
  ht->hash = & hasher;
#line 1072
  ht->emptytable = (void (*)(HashTable  ))(& shempty);
#line 1073
  ht->filltable = (void (*)(HashTable  ))((void *)0);
#line 1074
  ht->addnode = (void (*)(HashTable  , char * , void * ))(& shempty);
#line 1075
  tmp = get;
#line 1075
  ht->getnode2 = tmp;
#line 1075
  ht->getnode = tmp;
#line 1076
  ht->removenode = (HashNode (*)(HashTable  , char const   * ))(& shempty);
#line 1077
  ht->disablenode = (void (*)(HashNode  , int  ))((void *)0);
#line 1078
  ht->enablenode = (void (*)(HashNode  , int  ))((void *)0);
#line 1079
  ht->freenode = (void (*)(HashNode  ))(& shempty);
#line 1080
  ht->printnode = & printparamnode;
#line 1081
  ht->scantab = scan;
  }
#line 1083
  return (pm);
}
}
#line 1096 "/tmp/zsh-5.4.2/Src/params.c"
void copyparam(Param tpm , Param pm , int fakecopy ) 
{ 
  char *tmp ;
  char **tmp___0 ;
  HashTable tmp___1 ;

  {
#line 1105
  tpm->node.flags = pm->node.flags;
#line 1106
  tpm->base = pm->base;
#line 1107
  tpm->width = pm->width;
#line 1108
  tpm->level = pm->level;
#line 1109
  if (! fakecopy) {
#line 1110
    tpm->node.flags &= ~ (1 << 22);
  }
  {
#line 1112
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 1112
    goto case_0;
  }
#line 1115
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 1115
    goto case_exp;
  }
#line 1119
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 1119
    goto case_exp___0;
  }
#line 1119
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 1119
    goto case_exp___0;
  }
#line 1122
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 1122
    goto case_1;
  }
#line 1125
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
#line 1125
    goto case_exp___2;
  }
#line 1111
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1113
  tmp = (*((pm->gsu.s)->getfn))(pm);
#line 1113
  tpm->u.str = ztrdup((char const   *)tmp);
  }
#line 1114
  goto switch_break;
  case_exp: /* CIL Label */ 
  {
#line 1116
  tpm->u.val = (*((pm->gsu.i)->getfn))(pm);
  }
#line 1117
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  case_exp___1: /* CIL Label */ 
  {
#line 1120
  tpm->u.dval = (*((pm->gsu.f)->getfn))(pm);
  }
#line 1121
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1123
  tmp___0 = (*((pm->gsu.a)->getfn))(pm);
#line 1123
  tpm->u.arr = zarrdup(tmp___0);
  }
#line 1124
  goto switch_break;
  case_exp___2: /* CIL Label */ 
  {
#line 1126
  tmp___1 = (*((pm->gsu.h)->getfn))(pm);
#line 1126
  tpm->u.hash = copyparamtable(tmp___1, pm->node.nam);
  }
#line 1127
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1138
  if (! fakecopy) {
    {
#line 1139
    assigngetset(tpm);
    }
  }
#line 1140
  return;
}
}
#line 1145 "/tmp/zsh-5.4.2/Src/params.c"
int isident(char *s ) 
{ 
  char *ss ;

  {
#line 1150
  if (! *s) {
#line 1151
    return (0);
  }
#line 1153
  if ((int )typtab[(unsigned char )*s] & 1) {
#line 1155
    s ++;
#line 1155
    ss = s;
    {
#line 1155
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1155
      if (! *ss) {
#line 1155
        goto while_break;
      }
#line 1156
      if (! ((int )typtab[(unsigned char )*ss] & 1)) {
#line 1157
        goto while_break;
      }
#line 1155
      ss ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1160
    ss = itype_end((char const   *)s, 1 << 7, 0);
    }
  }
#line 1165
  if (! *ss) {
#line 1166
    return (1);
  }
#line 1167
  if ((unsigned long )s == (unsigned long )ss) {
#line 1168
    return (0);
  }
#line 1169
  if ((int )*ss != 91) {
#line 1170
    return (0);
  }
  {
#line 1173
  ss ++;
#line 1173
  ss = parse_subscript(ss, 1, ']');
  }
#line 1173
  if (! ss) {
#line 1174
    return (0);
  }
  {
#line 1175
  untokenize(s);
  }
#line 1176
  return (! *(ss + 1));
}
}
#line 1205 "/tmp/zsh-5.4.2/Src/params.c"
static zlong getarg(char **str , int *inv , Value v , int a2 , zlong *w , int *prevcharlen ,
                    int *nextcharlen ) 
{ 
  int hasbeg ;
  int word ;
  int rev ;
  int ind ;
  int down ;
  int l ;
  int i ;
  int ishash ;
  int keymatch ;
  int needtok ;
  int arglen ;
  int len ;
  int inpar ;
  char *s ;
  char *sep ;
  char *t ;
  char sav ;
  char *d___0 ;
  char **ta ;
  char **p ;
  char *tt ;
  char c ;
  zlong num ;
  zlong beg ;
  zlong r ;
  zlong quote_arg ;
  Patprog pprog ;
  int tmp ;
  int escapes ;
  int waste ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  HashTable ht ;
  HashTable tmp___4 ;
  HashTable tht ;
  Param tmp___5 ;
  HashNode tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int lastcharlen ;
  zlong nchars ;
  zlong nchars___0 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  int slen ;
  size_t tmp___22 ;
  char *de ;
  int nmatches ;
  char *lastpos ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int lastcharlen___0 ;
  int nmatches___0 ;
  char *lastpos___0 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;

  {
#line 1209
  hasbeg = 0;
#line 1209
  word = 0;
#line 1209
  rev = 0;
#line 1209
  ind = 0;
#line 1209
  down = 0;
#line 1210
  keymatch = 0;
#line 1210
  needtok = 0;
#line 1210
  inpar = 0;
#line 1211
  s = *str;
#line 1211
  sep = (char *)((void *)0);
#line 1212
  num = (zlong )1;
#line 1212
  beg = (zlong )0;
#line 1212
  r = (zlong )0;
#line 1212
  quote_arg = (zlong )0;
#line 1213
  pprog = (Patprog )((void *)0);
#line 1220
  if (! opts[52]) {
#line 1220
    tmp = 1;
  } else
#line 1220
  if (v->pm) {
#line 1220
    if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
#line 1220
      tmp = 1;
    } else {
#line 1220
      tmp = 0;
    }
  } else {
#line 1220
    tmp = 0;
  }
#line 1220
  ishash = tmp;
#line 1222
  if (prevcharlen) {
#line 1223
    *prevcharlen = 1;
  }
#line 1224
  if (nextcharlen) {
#line 1225
    *nextcharlen = 1;
  }
#line 1228
  if (v->pm) {
#line 1228
    if ((int )*s == 40) {
#line 1228
      goto _L;
    } else
#line 1228
    if ((int )*s == -120) {
      _L: /* CIL Label */ 
#line 1229
      escapes = 0;
#line 1231
      s ++;
      {
#line 1231
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1231
        if ((int )*s != 41) {
#line 1231
          if ((int )*s != -118) {
#line 1231
            if (! ((unsigned long )s != (unsigned long )*str)) {
#line 1231
              goto while_break;
            }
          } else {
#line 1231
            goto while_break;
          }
        } else {
#line 1231
          goto while_break;
        }
        {
#line 1233
        if ((int )*s == 114) {
#line 1233
          goto case_114;
        }
#line 1237
        if ((int )*s == 82) {
#line 1237
          goto case_82;
        }
#line 1241
        if ((int )*s == 107) {
#line 1241
          goto case_107;
        }
#line 1246
        if ((int )*s == 75) {
#line 1246
          goto case_75;
        }
#line 1251
        if ((int )*s == 105) {
#line 1251
          goto case_105;
        }
#line 1255
        if ((int )*s == 73) {
#line 1255
          goto case_73;
        }
#line 1259
        if ((int )*s == 119) {
#line 1259
          goto case_119;
        }
#line 1264
        if ((int )*s == 102) {
#line 1264
          goto case_102;
        }
#line 1268
        if ((int )*s == 101) {
#line 1268
          goto case_101;
        }
#line 1271
        if ((int )*s == 110) {
#line 1271
          goto case_110;
        }
#line 1283
        if ((int )*s == 98) {
#line 1283
          goto case_98;
        }
#line 1295
        if ((int )*s == 112) {
#line 1295
          goto case_112;
        }
#line 1298
        if ((int )*s == 115) {
#line 1298
          goto case_115;
        }
#line 1312
        goto flagerr;
        case_114: /* CIL Label */ 
#line 1234
        rev = 1;
#line 1235
        ind = 0;
#line 1235
        down = ind;
#line 1235
        keymatch = down;
#line 1236
        goto switch_break;
        case_82: /* CIL Label */ 
#line 1238
        down = 1;
#line 1238
        rev = down;
#line 1239
        ind = 0;
#line 1239
        keymatch = ind;
#line 1240
        goto switch_break;
        case_107: /* CIL Label */ 
#line 1242
        keymatch = ishash;
#line 1243
        rev = 1;
#line 1244
        ind = 0;
#line 1244
        down = ind;
#line 1245
        goto switch_break;
        case_75: /* CIL Label */ 
#line 1247
        keymatch = ishash;
#line 1248
        down = 1;
#line 1248
        rev = down;
#line 1249
        ind = 0;
#line 1250
        goto switch_break;
        case_105: /* CIL Label */ 
#line 1252
        ind = 1;
#line 1252
        rev = ind;
#line 1253
        keymatch = 0;
#line 1253
        down = keymatch;
#line 1254
        goto switch_break;
        case_73: /* CIL Label */ 
#line 1256
        down = 1;
#line 1256
        ind = down;
#line 1256
        rev = ind;
#line 1257
        keymatch = 0;
#line 1258
        goto switch_break;
        case_119: /* CIL Label */ 
#line 1262
        word = 1;
#line 1263
        goto switch_break;
        case_102: /* CIL Label */ 
#line 1265
        word = 1;
#line 1266
        sep = (char *)"\n";
#line 1267
        goto switch_break;
        case_101: /* CIL Label */ 
#line 1269
        quote_arg = (zlong )1;
#line 1270
        goto switch_break;
        case_110: /* CIL Label */ 
        {
#line 1272
        s ++;
#line 1272
        t = get_strarg(s, & arglen);
        }
#line 1273
        if (! *t) {
#line 1274
          goto flagerr;
        }
        {
#line 1275
        sav = *t;
#line 1276
        *t = (char )'\000';
#line 1277
        num = mathevalarg(s + arglen, & d___0);
        }
#line 1278
        if (! num) {
#line 1279
          num = (zlong )1;
        }
#line 1280
        *t = sav;
#line 1281
        s = (t + arglen) - 1;
#line 1282
        goto switch_break;
        case_98: /* CIL Label */ 
        {
#line 1284
        hasbeg = 1;
#line 1285
        s ++;
#line 1285
        t = get_strarg(s, & arglen);
        }
#line 1286
        if (! *t) {
#line 1287
          goto flagerr;
        }
        {
#line 1288
        sav = *t;
#line 1289
        *t = (char )'\000';
#line 1290
        beg = mathevalarg(s + arglen, & d___0);
        }
#line 1290
        if (beg > 0L) {
#line 1291
          beg --;
        }
#line 1292
        *t = sav;
#line 1293
        s = (t + arglen) - 1;
#line 1294
        goto switch_break;
        case_112: /* CIL Label */ 
#line 1296
        escapes = 1;
#line 1297
        goto switch_break;
        case_115: /* CIL Label */ 
        {
#line 1301
        s ++;
#line 1301
        t = get_strarg(s, & arglen);
        }
#line 1302
        if (! *t) {
#line 1303
          goto flagerr;
        }
#line 1304
        sav = *t;
#line 1305
        *t = (char )'\000';
#line 1306
        s += arglen;
#line 1307
        if (escapes) {
          {
#line 1307
          tmp___0 = getkeystring(s, & waste, 3, (int *)((void *)0));
#line 1307
          sep = tmp___0;
          }
        } else {
          {
#line 1307
          tmp___1 = dupstring((char const   *)s);
#line 1307
          sep = tmp___1;
          }
        }
#line 1309
        *t = sav;
#line 1310
        s = (t + arglen) - 1;
#line 1311
        goto switch_break;
        flagerr: 
        switch_default: /* CIL Label */ 
#line 1314
        num = (zlong )1;
#line 1315
        keymatch = 0;
#line 1315
        down = keymatch;
#line 1315
        ind = down;
#line 1315
        rev = ind;
#line 1315
        word = rev;
#line 1316
        sep = (char *)((void *)0);
#line 1317
        s = *str - 1;
        switch_break: /* CIL Label */ ;
        }
#line 1231
        s ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1320
      if ((unsigned long )s != (unsigned long )*str) {
#line 1321
        s ++;
      }
    }
  }
#line 1323
  if (num < 0L) {
#line 1324
    down = ! down;
#line 1325
    num = - num;
  }
#line 1327
  if (v->isarr & (1 << 1)) {
#line 1328
    if (ind) {
#line 1328
      tmp___2 = 1;
    } else
#line 1328
    if (! (v->isarr & 1)) {
#line 1328
      tmp___2 = 1;
    } else {
#line 1328
      tmp___2 = 0;
    }
#line 1328
    *inv = tmp___2;
  } else
#line 1329
  if (v->isarr & 1) {
#line 1330
    *inv = 0;
  } else {
#line 1332
    if (v->isarr) {
#line 1333
      if (ind) {
#line 1334
        v->isarr |= 1 << 1;
#line 1335
        v->isarr &= -2;
      } else
#line 1336
      if (rev) {
#line 1337
        v->isarr |= 1;
      }
#line 1342
      if (! down) {
#line 1342
        if (keymatch) {
#line 1342
          if (ishash) {
#line 1343
            v->isarr &= ~ (1 << 5);
          }
        }
      }
    }
#line 1345
    *inv = ind;
  }
#line 1348
  t = s;
#line 1348
  i = 0;
  {
#line 1348
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1348
    c = *t;
#line 1348
    if (c) {
#line 1348
      if ((int )c != -110) {
#line 1348
        if (! ishash) {
#line 1348
          if (! ((int )c != 44)) {
#line 1348
            goto _L___1;
          }
        }
      } else
      _L___1: /* CIL Label */ 
#line 1348
      if (! i) {
#line 1348
        if (! inpar) {
#line 1348
          goto while_break___0;
        }
      }
    } else {
#line 1348
      goto while_break___0;
    }
#line 1353
    if ((int )typtab[(unsigned char )c] & (1 << 14)) {
#line 1354
      c = *(t + 1);
#line 1355
      if ((int )c == 91) {
#line 1355
        goto _L___0;
      } else
#line 1355
      if ((int )c == 93) {
#line 1355
        goto _L___0;
      } else
#line 1355
      if ((int )c == 40) {
#line 1355
        goto _L___0;
      } else
#line 1355
      if ((int )c == 41) {
#line 1355
        goto _L___0;
      } else
#line 1355
      if ((int )c == 123) {
#line 1355
        goto _L___0;
      } else
#line 1355
      if ((int )c == 125) {
        _L___0: /* CIL Label */ 
#line 1359
        if (ishash) {
#line 1359
          if (i) {
#line 1360
            *t = ztokens[(int )*t - -124];
          }
        }
#line 1361
        needtok = 1;
#line 1362
        t ++;
      } else
#line 1363
      if ((int )c != 34) {
#line 1364
        *t = ztokens[(int )*t - -124];
      }
#line 1365
      goto __Cont;
    }
#line 1368
    if ((int )c == 91) {
#line 1369
      i ++;
    } else
#line 1368
    if ((int )c == -111) {
#line 1369
      i ++;
    } else
#line 1370
    if ((int )c == 93) {
#line 1371
      i --;
    } else
#line 1370
    if ((int )c == -110) {
#line 1371
      i --;
    }
#line 1372
    if ((int )c == 40) {
#line 1373
      inpar ++;
    } else
#line 1372
    if ((int )c == -120) {
#line 1373
      inpar ++;
    } else
#line 1374
    if ((int )c == 41) {
#line 1375
      inpar --;
    } else
#line 1374
    if ((int )c == -118) {
#line 1375
      inpar --;
    }
#line 1376
    if ((int )typtab[(unsigned char )c] & (1 << 11)) {
#line 1377
      needtok = 1;
    }
    __Cont: /* CIL Label */ 
#line 1348
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1379
  if (! c) {
#line 1380
    return ((zlong )0);
  }
#line 1381
  tt = t;
#line 1381
  *str = tt;
#line 1388
  if (! opts[52]) {
#line 1389
    return ((zlong )0);
  }
  {
#line 1391
  s = dupstrpfx((char const   *)s, (int )(t - s));
  }
#line 1397
  if (ishash) {
#line 1397
    if (keymatch) {
      {
#line 1398
      remnulargs(s);
      }
    } else
#line 1397
    if (! rev) {
      {
#line 1398
      remnulargs(s);
      }
    }
  }
#line 1399
  if (needtok) {
    {
#line 1400
    s = dupstring((char const   *)s);
#line 1401
    tmp___3 = parsestr(& s);
    }
#line 1401
    if (tmp___3) {
#line 1402
      return ((zlong )0);
    }
    {
#line 1403
    singsub(& s);
    }
  } else
#line 1404
  if (rev) {
    {
#line 1405
    remnulargs(s);
    }
  }
#line 1406
  if (! rev) {
#line 1407
    if (ishash) {
      {
#line 1408
      tmp___4 = (*(((v->pm)->gsu.h)->getfn))(v->pm);
#line 1408
      ht = tmp___4;
      }
#line 1409
      if (! ht) {
        {
#line 1410
        ht = newparamtable(17, (char const   *)(v->pm)->node.nam);
#line 1411
        (*(((v->pm)->gsu.h)->setfn))(v->pm, ht);
        }
      }
      {
#line 1413
      untokenize(s);
#line 1414
      tmp___6 = (*(ht->getnode))(ht, (char const   *)s);
#line 1414
      tmp___5 = (Param )tmp___6;
#line 1414
      v->pm = tmp___5;
      }
#line 1414
      if (! tmp___5) {
        {
#line 1415
        tht = paramtab;
#line 1416
        paramtab = ht;
#line 1417
        v->pm = createparam(s, 1 << 25);
#line 1418
        paramtab = tht;
        }
      }
#line 1420
      if (*inv) {
#line 1420
        v->isarr = 1 << 2;
      } else {
#line 1420
        v->isarr = 0;
      }
#line 1421
      v->start = 0;
#line 1422
      *inv = 0;
#line 1423
      tmp___7 = -1;
#line 1423
      v->end = tmp___7;
#line 1423
      *w = (zlong )tmp___7;
#line 1424
      if (opts[95]) {
#line 1424
        r = (zlong )1;
      } else {
#line 1424
        r = (zlong )0;
      }
    } else {
      {
#line 1426
      r = mathevalarg(s, & s);
      }
#line 1427
      if (opts[95]) {
#line 1427
        if (r >= 0L) {
#line 1428
          r ++;
        }
      }
    }
#line 1430
    if (word) {
#line 1430
      if (! v->isarr) {
        {
#line 1431
        t = getstrvalue(v);
#line 1431
        s = t;
#line 1432
        i = wordcount(s, sep, 0);
        }
#line 1433
        if (r < 0L) {
#line 1434
          r += (zlong )(i + 1);
        }
#line 1435
        if (r < 1L) {
#line 1436
          r = (zlong )1;
        }
#line 1437
        if (r > (zlong )i) {
#line 1438
          r = (zlong )i;
        }
#line 1439
        if (! s) {
#line 1440
          return ((zlong )0);
        } else
#line 1439
        if (! *s) {
#line 1440
          return ((zlong )0);
        }
        {
#line 1441
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1441
          d___0 = findword(& s, sep);
          }
#line 1441
          if (d___0) {
#line 1441
            r --;
#line 1441
            if (! r) {
#line 1441
              goto while_break___1;
            }
          } else {
#line 1441
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1442
        if (! d___0) {
#line 1443
          return ((zlong )0);
        }
#line 1445
        if (! a2) {
#line 1445
          if ((int )*tt != 44) {
#line 1446
            *w = s - t;
          }
        }
#line 1448
        if (a2) {
#line 1448
          tmp___8 = s;
        } else {
#line 1448
          tmp___8 = d___0 + 1;
        }
#line 1448
        return (tmp___8 - t);
      } else {
#line 1430
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1449
    if (! v->isarr) {
#line 1449
      if (! word) {
        {
#line 1450
        lastcharlen = 1;
#line 1451
        s = getstrvalue(v);
        }
#line 1459
        if (r > 0L) {
          {
#line 1460
          nchars = r;
#line 1462
          mb_charinit();
#line 1463
          t = s;
          }
          {
#line 1463
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1463
            if (nchars) {
#line 1463
              if (! *t) {
#line 1463
                goto while_break___2;
              }
            } else {
#line 1463
              goto while_break___2;
            }
            {
#line 1464
            lastcharlen = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
#line 1464
            t += lastcharlen;
#line 1463
            nchars --;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1466
          r = (t - s) + nchars;
#line 1467
          if (prevcharlen) {
#line 1467
            if (! nchars) {
#line 1468
              *prevcharlen = lastcharlen;
            }
          }
#line 1469
          if (nextcharlen) {
#line 1469
            if (*t) {
              {
#line 1470
              *nextcharlen = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
              }
            }
          }
        } else
#line 1471
        if (r == 0L) {
#line 1472
          if (prevcharlen) {
#line 1473
            *prevcharlen = 0;
          }
#line 1474
          if (nextcharlen) {
#line 1474
            if (*s) {
              {
#line 1475
              mb_charinit();
#line 1476
              *nextcharlen = mb_metacharlenconv((char const   *)s, (wint_t *)((void *)0));
              }
            }
          }
        } else {
          {
#line 1479
          tmp___9 = mb_metastrlenend(s, 0, (char *)((void *)0));
#line 1479
          nchars___0 = (zlong )tmp___9 + r;
          }
#line 1481
          if (nchars___0 < 0L) {
            {
#line 1483
            tmp___10 = strlen((char const   *)s);
#line 1483
            r -= (zlong )tmp___10;
            }
          } else {
            {
#line 1485
            mb_charinit();
#line 1486
            t = s;
            }
            {
#line 1486
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1486
              if (nchars___0) {
#line 1486
                if (! *t) {
#line 1486
                  goto while_break___3;
                }
              } else {
#line 1486
                goto while_break___3;
              }
              {
#line 1487
              lastcharlen = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
#line 1487
              t += lastcharlen;
#line 1486
              nchars___0 --;
              }
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 1488
            tmp___11 = strlen((char const   *)t);
#line 1488
            r = - ((zlong )tmp___11);
            }
#line 1489
            if (prevcharlen) {
#line 1490
              *prevcharlen = lastcharlen;
            }
#line 1491
            if (nextcharlen) {
#line 1491
              if (*t) {
                {
#line 1492
                *nextcharlen = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
                }
              }
            }
          }
        }
      }
    }
  } else {
#line 1497
    if (! v->isarr) {
#line 1497
      if (! word) {
        {
#line 1498
        tmp___12 = strlen((char const   *)s);
#line 1498
        l = (int )tmp___12;
        }
#line 1499
        if (a2) {
#line 1500
          if (! l) {
            {
#line 1501
            tmp___13 = hcalloc((size_t )(l + 2));
#line 1501
            d___0 = (char *)tmp___13;
#line 1502
            *d___0 = (char )'*';
#line 1503
            strcpy((char */* __restrict  */)(d___0 + 1), (char const   */* __restrict  */)s);
#line 1504
            s = d___0;
            }
          } else
#line 1500
          if ((int )*s != 42) {
            {
#line 1501
            tmp___13 = hcalloc((size_t )(l + 2));
#line 1501
            d___0 = (char *)tmp___13;
#line 1502
            *d___0 = (char )'*';
#line 1503
            strcpy((char */* __restrict  */)(d___0 + 1), (char const   */* __restrict  */)s);
#line 1504
            s = d___0;
            }
          }
        } else
#line 1507
        if (! l) {
          {
#line 1508
          tmp___14 = hcalloc((size_t )(l + 2));
#line 1508
          d___0 = (char *)tmp___14;
#line 1509
          strcpy((char */* __restrict  */)d___0, (char const   */* __restrict  */)s);
#line 1510
          strcat((char */* __restrict  */)d___0, (char const   */* __restrict  */)"*");
#line 1511
          s = d___0;
          }
        } else
#line 1507
        if ((int )*(s + (l - 1)) != 42) {
          {
#line 1508
          tmp___14 = hcalloc((size_t )(l + 2));
#line 1508
          d___0 = (char *)tmp___14;
#line 1509
          strcpy((char */* __restrict  */)d___0, (char const   */* __restrict  */)s);
#line 1510
          strcat((char */* __restrict  */)d___0, (char const   */* __restrict  */)"*");
#line 1511
          s = d___0;
          }
        } else
#line 1507
        if (l > 1) {
#line 1507
          if ((int )*(s + (l - 2)) == 92) {
            {
#line 1508
            tmp___14 = hcalloc((size_t )(l + 2));
#line 1508
            d___0 = (char *)tmp___14;
#line 1509
            strcpy((char */* __restrict  */)d___0, (char const   */* __restrict  */)s);
#line 1510
            strcat((char */* __restrict  */)d___0, (char const   */* __restrict  */)"*");
#line 1511
            s = d___0;
            }
          }
        }
      }
    }
#line 1515
    if (! keymatch) {
#line 1516
      if (quote_arg) {
        {
#line 1517
        untokenize(s);
        }
      } else {
        {
#line 1519
        tokenize(s);
        }
      }
      {
#line 1520
      remnulargs(s);
#line 1521
      pprog = patcompile(s, 0, (char **)((void *)0));
      }
    } else {
#line 1523
      pprog = (Patprog )((void *)0);
    }
#line 1525
    if (v->isarr) {
#line 1526
      if (ishash) {
#line 1527
        scanprog = pprog;
#line 1528
        scanstr = s;
#line 1529
        if (keymatch) {
#line 1530
          v->isarr |= 1 << 7;
        } else {
#line 1532
          if (! pprog) {
#line 1533
            return ((zlong )1);
          }
#line 1534
          if (ind) {
#line 1535
            v->isarr |= 1 << 3;
          } else {
#line 1537
            v->isarr |= 1 << 4;
          }
        }
#line 1539
        if (down) {
#line 1540
          v->isarr |= 1 << 5;
        }
        {
#line 1541
        ta = getvaluearr(v);
        }
#line 1541
        if (ta) {
#line 1541
          if (*ta) {
#line 1541
            goto _L___3;
          } else
#line 1541
          if (v->isarr & (1 << 5)) {
#line 1541
            if (v->isarr & (((1 << 3) | (1 << 4)) | (1 << 7))) {
              _L___3: /* CIL Label */ 
#line 1545
              if (v->flags & 1) {
#line 1545
                *inv = 1;
              } else {
#line 1545
                *inv = 0;
              }
#line 1546
              *w = (zlong )v->end;
#line 1547
              scanprog = (Patprog )((void *)0);
#line 1548
              return ((zlong )1);
            }
          }
        }
#line 1550
        scanprog = (Patprog )((void *)0);
      } else {
        {
#line 1552
        ta = getarrvalue(v);
        }
      }
#line 1553
      if (! ta) {
#line 1554
        return ((zlong )(! down));
      } else
#line 1553
      if (! *ta) {
#line 1554
        return ((zlong )(! down));
      }
      {
#line 1555
      len = arrlen(ta);
      }
#line 1556
      if (beg < 0L) {
#line 1557
        beg += (zlong )len;
      }
#line 1558
      if (down) {
#line 1559
        if (beg < 0L) {
#line 1560
          return ((zlong )0);
        }
      } else
#line 1561
      if (beg >= (zlong )len) {
#line 1562
        return ((zlong )(len + 1));
      }
#line 1563
      if (beg >= 0L) {
#line 1563
        if (beg < (zlong )len) {
#line 1564
          if (down) {
#line 1565
            if (! hasbeg) {
#line 1566
              beg = (zlong )(len - 1);
            }
#line 1567
            r = 1L + beg;
#line 1567
            p = ta + beg;
            {
#line 1567
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1567
              if (! ((unsigned long )p >= (unsigned long )ta)) {
#line 1567
                goto while_break___4;
              }
#line 1568
              if (pprog) {
                {
#line 1568
                tmp___15 = pattry(pprog, *p);
                }
#line 1568
                if (tmp___15) {
#line 1568
                  num --;
#line 1568
                  if (! num) {
#line 1569
                    return (r);
                  }
                }
              }
#line 1567
              r --;
#line 1567
              p --;
            }
            while_break___4: /* CIL Label */ ;
            }
          } else {
#line 1572
            r = 1L + beg;
#line 1572
            p = ta + beg;
            {
#line 1572
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 1572
              if (! *p) {
#line 1572
                goto while_break___5;
              }
#line 1573
              if (pprog) {
                {
#line 1573
                tmp___16 = pattry(pprog, *p);
                }
#line 1573
                if (tmp___16) {
#line 1573
                  num --;
#line 1573
                  if (! num) {
#line 1574
                    return (r);
                  }
                }
              }
#line 1572
              r ++;
#line 1572
              p ++;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
        }
      }
    } else
#line 1576
    if (word) {
      {
#line 1577
      s = getstrvalue(v);
#line 1577
      d___0 = s;
#line 1577
      ta = sepsplit(d___0, sep, 1, 1);
#line 1578
      len = arrlen(ta);
      }
#line 1579
      if (beg < 0L) {
#line 1580
        beg += (zlong )len;
      }
#line 1581
      if (down) {
#line 1582
        if (beg < 0L) {
#line 1583
          return ((zlong )0);
        }
      } else
#line 1584
      if (beg >= (zlong )len) {
#line 1585
        return ((zlong )(len + 1));
      }
#line 1586
      if (beg >= 0L) {
#line 1586
        if (beg < (zlong )len) {
#line 1587
          if (down) {
#line 1588
            if (! hasbeg) {
#line 1589
              beg = (zlong )(len - 1);
            }
#line 1590
            r = 1L + beg;
#line 1590
            p = ta + beg;
            {
#line 1590
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 1590
              if (! ((unsigned long )p >= (unsigned long )ta)) {
#line 1590
                goto while_break___6;
              }
#line 1591
              if (pprog) {
                {
#line 1591
                tmp___17 = pattry(pprog, *p);
                }
#line 1591
                if (tmp___17) {
#line 1591
                  num --;
#line 1591
                  if (! num) {
#line 1592
                    goto while_break___6;
                  }
                }
              }
#line 1590
              p --;
#line 1590
              r --;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 1593
            if ((unsigned long )p < (unsigned long )ta) {
#line 1594
              return ((zlong )0);
            }
          } else {
#line 1596
            r = 1L + beg;
#line 1596
            p = ta + beg;
            {
#line 1596
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 1596
              if (! *p) {
#line 1596
                goto while_break___7;
              }
#line 1597
              if (pprog) {
                {
#line 1597
                tmp___18 = pattry(pprog, *p);
                }
#line 1597
                if (tmp___18) {
#line 1597
                  num --;
#line 1597
                  if (! num) {
#line 1598
                    goto while_break___7;
                  }
                }
              }
#line 1596
              r ++;
#line 1596
              p ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 1599
            if (! *p) {
#line 1600
              return ((zlong )0);
            }
          }
        }
      }
#line 1603
      if (a2) {
#line 1604
        r ++;
      }
#line 1605
      i = 0;
      {
#line 1605
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 1605
        t = findword(& d___0, sep);
        }
#line 1605
        if (t) {
#line 1605
          if (! *t) {
#line 1605
            goto while_break___8;
          }
        } else {
#line 1605
          goto while_break___8;
        }
#line 1606
        r --;
#line 1606
        if (! r) {
#line 1607
          if (a2) {
#line 1607
            tmp___19 = -1;
          } else {
#line 1607
            tmp___19 = 1;
          }
#line 1607
          r = (t - s) + (long )tmp___19;
#line 1608
          if (! a2) {
#line 1608
            if ((int )*tt != 44) {
              {
#line 1609
              tmp___20 = strlen((char const   *)*(ta + i));
#line 1609
              *w = (zlong )(((size_t )r + tmp___20) - 1UL);
              }
            }
          }
#line 1610
          return (r);
        }
#line 1605
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1612
      if (a2) {
#line 1612
        tmp___21 = -1;
      } else {
#line 1612
        tmp___21 = 0;
      }
#line 1612
      return ((zlong )tmp___21);
    } else {
      {
#line 1616
      d___0 = getstrvalue(v);
      }
#line 1617
      if (! d___0) {
#line 1618
        return ((zlong )0);
      } else
#line 1617
      if (! *d___0) {
#line 1618
        return ((zlong )0);
      }
      {
#line 1623
      len = mb_metastrlenend(d___0, 0, (char *)((void *)0));
#line 1624
      tmp___22 = strlen((char const   *)d___0);
#line 1624
      slen = (int )tmp___22;
      }
#line 1625
      if (beg < 0L) {
#line 1626
        beg += (zlong )len;
      }
      {
#line 1627
      mb_charinit();
      }
#line 1628
      if (beg >= 0L) {
#line 1628
        if (beg < (zlong )len) {
#line 1629
          de = d___0 + slen;
#line 1631
          if (a2) {
#line 1637
            if (down) {
#line 1638
              nmatches = 0;
#line 1639
              lastpos = (char *)((void *)0);
#line 1641
              if (! hasbeg) {
#line 1642
                beg = (zlong )len;
              }
#line 1648
              t = d___0;
#line 1648
              r = (zlong )0;
              {
#line 1648
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 1648
                if (! (r <= beg)) {
#line 1648
                  goto while_break___9;
                }
#line 1649
                sav = *t;
#line 1650
                *t = (char )'\000';
#line 1651
                if (pprog) {
                  {
#line 1651
                  tmp___23 = pattry(pprog, d___0);
                  }
#line 1651
                  if (tmp___23) {
#line 1652
                    nmatches ++;
#line 1653
                    lastpos = t;
                  }
                }
#line 1655
                *t = sav;
#line 1656
                if ((unsigned long )t == (unsigned long )de) {
#line 1657
                  goto while_break___9;
                }
                {
#line 1658
                tmp___24 = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
#line 1658
                t += tmp___24;
#line 1648
                r ++;
                }
              }
              while_break___9: /* CIL Label */ ;
              }
#line 1661
              if ((zlong )nmatches >= num) {
#line 1662
                if (num > 1L) {
                  {
#line 1663
                  nmatches = (int )((zlong )nmatches - num);
#line 1664
                  mb_charinit();
#line 1665
                  t = d___0;
#line 1665
                  r = (zlong )0;
                  }
                  {
#line 1665
                  while (1) {
                    while_continue___10: /* CIL Label */ ;
#line 1666
                    sav = *t;
#line 1667
                    *t = (char )'\000';
#line 1668
                    if (pprog) {
                      {
#line 1668
                      tmp___25 = pattry(pprog, d___0);
                      }
#line 1668
                      if (tmp___25) {
#line 1668
                        tmp___26 = nmatches;
#line 1668
                        nmatches --;
#line 1668
                        if (tmp___26 == 0) {
#line 1670
                          lastpos = t;
#line 1671
                          *t = sav;
#line 1672
                          goto while_break___10;
                        }
                      }
                    }
                    {
#line 1674
                    *t = sav;
#line 1675
                    tmp___27 = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
#line 1675
                    t += tmp___27;
#line 1665
                    r ++;
                    }
                  }
                  while_break___10: /* CIL Label */ ;
                  }
                }
#line 1680
                return (lastpos - d___0);
              }
            } else {
#line 1688
              t = d___0;
              {
#line 1688
              while (1) {
                while_continue___11: /* CIL Label */ ;
#line 1688
                if (beg) {
#line 1688
                  if (! ((unsigned long )t <= (unsigned long )de)) {
#line 1688
                    goto while_break___11;
                  }
                } else {
#line 1688
                  goto while_break___11;
                }
                {
#line 1689
                tmp___28 = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
#line 1689
                t += tmp___28;
#line 1688
                beg --;
                }
              }
              while_break___11: /* CIL Label */ ;
              }
              {
#line 1690
              while (1) {
                while_continue___12: /* CIL Label */ ;
#line 1691
                sav = *t;
#line 1692
                *t = (char )'\000';
#line 1693
                if (pprog) {
                  {
#line 1693
                  tmp___29 = pattry(pprog, d___0);
                  }
#line 1693
                  if (tmp___29) {
#line 1693
                    num --;
#line 1693
                    if (! num) {
#line 1694
                      *t = sav;
#line 1700
                      return (t - d___0);
                    }
                  }
                }
#line 1702
                *t = sav;
#line 1703
                if ((unsigned long )t == (unsigned long )de) {
#line 1704
                  goto while_break___12;
                }
                {
#line 1705
                tmp___30 = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
#line 1705
                t += tmp___30;
                }
              }
              while_break___12: /* CIL Label */ ;
              }
            }
          } else
#line 1715
          if (down) {
#line 1716
            nmatches___0 = 0;
#line 1717
            lastpos___0 = (char *)((void *)0);
#line 1719
            if (! hasbeg) {
#line 1720
              beg = (zlong )len;
            }
#line 1731
            t = d___0;
#line 1731
            r = (zlong )0;
            {
#line 1731
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 1731
              if (! (r <= beg)) {
#line 1731
                goto while_break___13;
              }
#line 1732
              if (pprog) {
                {
#line 1732
                tmp___31 = pattry(pprog, t);
                }
#line 1732
                if (tmp___31) {
#line 1733
                  nmatches___0 ++;
#line 1734
                  lastpos___0 = t;
                }
              }
#line 1736
              if ((unsigned long )t == (unsigned long )de) {
#line 1737
                goto while_break___13;
              }
              {
#line 1738
              tmp___32 = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
#line 1738
              t += tmp___32;
#line 1731
              r ++;
              }
            }
            while_break___13: /* CIL Label */ ;
            }
#line 1741
            if ((zlong )nmatches___0 >= num) {
#line 1742
              if (num > 1L) {
                {
#line 1747
                nmatches___0 = (int )((zlong )nmatches___0 - num);
#line 1748
                mb_charinit();
#line 1749
                t = d___0;
#line 1749
                r = (zlong )0;
                }
                {
#line 1749
                while (1) {
                  while_continue___14: /* CIL Label */ ;
#line 1750
                  if (pprog) {
                    {
#line 1750
                    tmp___33 = pattry(pprog, t);
                    }
#line 1750
                    if (tmp___33) {
#line 1750
                      tmp___34 = nmatches___0;
#line 1750
                      nmatches___0 --;
#line 1750
                      if (tmp___34 == 0) {
#line 1752
                        lastpos___0 = t;
#line 1753
                        goto while_break___14;
                      }
                    }
                  }
                  {
#line 1755
                  tmp___35 = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
#line 1755
                  t += tmp___35;
#line 1749
                  r ++;
                  }
                }
                while_break___14: /* CIL Label */ ;
                }
              }
              {
#line 1761
              lastcharlen___0 = mb_metacharlenconv((char const   *)lastpos___0, (wint_t *)((void *)0));
#line 1761
              lastpos___0 += lastcharlen___0;
              }
#line 1763
              if (prevcharlen) {
#line 1764
                *prevcharlen = lastcharlen___0;
              }
#line 1765
              if (nextcharlen) {
                {
#line 1766
                *nextcharlen = mb_metacharlenconv((char const   *)lastpos___0, (wint_t *)((void *)0));
                }
              }
#line 1767
              return (lastpos___0 - d___0);
            }
#line 1770
            r = beg + 1L;
#line 1770
            t = d___0 + beg;
            {
#line 1770
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 1770
              if (! ((unsigned long )t >= (unsigned long )d___0)) {
#line 1770
                goto while_break___15;
              }
#line 1771
              if (pprog) {
                {
#line 1771
                tmp___36 = pattry(pprog, t);
                }
#line 1771
                if (tmp___36) {
#line 1771
                  num --;
#line 1771
                  if (! num) {
#line 1773
                    return (r);
                  }
                }
              }
#line 1770
              r --;
#line 1770
              t --;
            }
            while_break___15: /* CIL Label */ ;
            }
          } else {
#line 1776
            t = d___0;
            {
#line 1776
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 1776
              if (beg) {
#line 1776
                if (! ((unsigned long )t <= (unsigned long )de)) {
#line 1776
                  goto while_break___16;
                }
              } else {
#line 1776
                goto while_break___16;
              }
              {
#line 1777
              tmp___37 = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
#line 1777
              t += tmp___37;
#line 1776
              beg --;
              }
            }
            while_break___16: /* CIL Label */ ;
            }
            {
#line 1778
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 1779
              if (pprog) {
                {
#line 1779
                tmp___38 = pattry(pprog, t);
                }
#line 1779
                if (tmp___38) {
#line 1779
                  num --;
#line 1779
                  if (! num) {
                    {
#line 1781
                    lastcharlen___0 = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
#line 1781
                    t += lastcharlen___0;
                    }
#line 1782
                    if (prevcharlen) {
#line 1783
                      *prevcharlen = lastcharlen___0;
                    }
#line 1784
                    if (nextcharlen) {
                      {
#line 1785
                      *nextcharlen = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
                      }
                    }
#line 1786
                    return (t - d___0);
                  }
                }
              }
#line 1788
              if ((unsigned long )t == (unsigned long )de) {
#line 1789
                goto while_break___17;
              }
              {
#line 1790
              tmp___39 = mb_metacharlenconv((char const   *)t, (wint_t *)((void *)0));
#line 1790
              t += tmp___39;
              }
            }
            while_break___17: /* CIL Label */ ;
            }
          }
        }
      }
#line 1795
      if (down) {
#line 1795
        tmp___40 = 0;
      } else {
#line 1795
        tmp___40 = slen + 1;
      }
#line 1795
      return ((zlong )tmp___40);
    }
  }
#line 1798
  return (r);
}
}
#line 1814 "/tmp/zsh-5.4.2/Src/params.c"
int getindex(char **pptr , Value v , int flags ) 
{ 
  int start ;
  int end ;
  int inv ;
  char *s ;
  char *tbrack ;
  char *tmp ;
  zlong we___0 ;
  zlong dummy___0 ;
  int startprevlen ;
  int startnextlen ;
  zlong tmp___0 ;
  char *t ;
  char *p ;
  int nstart ;
  char *target ;
  int tmp___1 ;
  zlong startoff ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int com ;
  zlong tmp___5 ;

  {
  {
#line 1817
  inv = 0;
#line 1818
  s = *pptr;
#line 1820
  tmp = s;
#line 1820
  s ++;
#line 1820
  *tmp = (char )'[';
#line 1822
  s = parse_subscript(s, flags & (1 << 8), ']');
#line 1826
  tbrack = *pptr + 1;
  }
  {
#line 1826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1826
    if (*tbrack) {
#line 1826
      if (! ((unsigned long )tbrack != (unsigned long )s)) {
#line 1826
        goto while_break;
      }
    } else {
#line 1826
      goto while_break;
    }
#line 1827
    if ((int )typtab[(unsigned char )*tbrack] & (1 << 14)) {
#line 1827
      tbrack ++;
#line 1827
      if (! *tbrack) {
#line 1828
        goto while_break;
      }
    }
#line 1829
    if ((int )typtab[(unsigned char )*tbrack] & (1 << 4)) {
#line 1830
      *tbrack = ztokens[(int )*tbrack - -124];
    }
#line 1826
    tbrack ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1833
  if (*tbrack) {
#line 1834
    *tbrack = (char)-110;
  } else {
    {
#line 1836
    zerr("invalid subscript");
#line 1837
    *pptr = tbrack;
    }
#line 1838
    return (1);
  }
#line 1840
  s = *pptr + 1;
#line 1841
  if ((int )*(s + 0) == 42) {
#line 1841
    goto _L___2;
  } else
#line 1841
  if ((int )*(s + 0) == 64) {
    _L___2: /* CIL Label */ 
#line 1841
    if ((unsigned long )(s + 1) == (unsigned long )tbrack) {
#line 1842
      if (v->isarr) {
#line 1842
        goto _L___0;
      } else
#line 1842
      if (v) {
#line 1842
        if (! v->pm) {
#line 1842
          goto _L___0;
        } else
#line 1842
        if ((v->pm)->node.flags & (1 << 25)) {
#line 1842
          goto _L___0;
        } else
#line 1842
        if (! (v->pm)->node.nam) {
#line 1842
          goto _L___0;
        } else
#line 1842
        if (! *((v->pm)->node.nam)) {
          _L___0: /* CIL Label */ 
#line 1842
          if ((int )*(s + 0) == 64) {
#line 1843
            v->isarr |= (int )(4294967295U << 15);
          }
        }
      }
#line 1844
      v->start = 0;
#line 1845
      v->end = -1;
#line 1846
      s += 2;
    } else {
#line 1841
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 1848
    we___0 = (zlong )0;
#line 1851
    tmp___0 = getarg(& s, & inv, v, 0, & we___0, & startprevlen, & startnextlen);
#line 1851
    start = (int )tmp___0;
    }
#line 1853
    if (inv) {
#line 1854
      if (! v->isarr) {
#line 1854
        if (start != 0) {
          {
#line 1856
          t = getstrvalue(v);
          }
#line 1863
          if (start > 0) {
            {
#line 1864
            nstart = 0;
#line 1865
            target = (t + start) - startprevlen;
#line 1867
            p = t;
#line 1868
            mb_charinit();
            }
            {
#line 1869
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1869
              if (! *p) {
#line 1869
                goto while_break___0;
              }
              {
#line 1874
              tmp___1 = mb_metacharlenconv((char const   *)p, (wint_t *)((void *)0));
#line 1874
              p += tmp___1;
              }
#line 1875
              if ((unsigned long )p < (unsigned long )target) {
#line 1876
                nstart ++;
              } else {
#line 1878
                if ((unsigned long )p == (unsigned long )target) {
#line 1879
                  nstart ++;
                } else {
#line 1881
                  p = target;
                }
#line 1882
                goto while_break___0;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 1886
            start = (int )(((long )nstart + (target - p)) + 1L);
          } else {
            {
#line 1888
            tmp___2 = strlen((char const   *)t);
#line 1888
            startoff = (zlong )((size_t )start + tmp___2);
            }
#line 1892
            if (startoff < 0L) {
#line 1894
              start = (int )startoff;
            } else {
              {
#line 1897
              mb_charinit();
#line 1898
              p = t;
              }
              {
#line 1898
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 1898
                if (! ((unsigned long )p < (unsigned long )(t + startoff))) {
#line 1898
                  goto while_break___1;
                }
                {
#line 1899
                tmp___3 = mb_metacharlenconv((char const   *)p, (wint_t *)((void *)0));
#line 1899
                p += tmp___3;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
              {
#line 1900
              tmp___4 = mb_metastrlenend(p, 0, (char *)((void *)0));
#line 1900
              start = - tmp___4;
              }
            }
          }
        }
      }
#line 1904
      if (start > 0) {
#line 1904
        if (opts[95]) {
#line 1905
          start --;
        } else
#line 1904
        if ((v->pm)->node.flags & (1 << 4)) {
#line 1905
          start --;
        }
      }
#line 1906
      if (v->isarr != 1 << 2) {
#line 1907
        v->flags |= 1;
#line 1908
        v->isarr = 0;
#line 1909
        v->start = start;
#line 1910
        v->end = start + 1;
      }
#line 1912
      if ((int )*s == 44) {
        {
#line 1913
        zerr("invalid subscript");
#line 1914
        *tbrack = (char )']';
#line 1915
        *pptr = tbrack + 1;
        }
#line 1916
        return (1);
      }
#line 1918
      if ((unsigned long )s == (unsigned long )tbrack) {
#line 1919
        s ++;
      }
    } else {
#line 1923
      com = (int )*s == 44;
#line 1923
      if (com) {
        {
#line 1924
        s ++;
#line 1925
        tmp___5 = getarg(& s, & inv, v, 1, & dummy___0, (int *)((void *)0), (int *)((void *)0));
#line 1925
        end = (int )tmp___5;
        }
      } else
#line 1927
      if (we___0) {
#line 1927
        end = (int )we___0;
      } else {
#line 1927
        end = start;
      }
#line 1929
      if (start != end) {
#line 1930
        com = 1;
      }
#line 1936
      if (start > 0) {
#line 1937
        start -= startprevlen;
      } else
#line 1938
      if (start == 0) {
#line 1938
        if (end == 0) {
#line 1947
          if (opts[100]) {
#line 1953
            end = startnextlen;
          } else {
#line 1960
            v->flags |= 2;
#line 1961
            start = -1;
#line 1962
            com = 1;
          }
        }
      }
#line 1965
      if ((unsigned long )s == (unsigned long )tbrack) {
#line 1966
        s ++;
#line 1967
        if (v->isarr) {
#line 1967
          if (! com) {
#line 1967
            if (! (v->isarr & (1 << 5))) {
#line 1971
              v->isarr = 0;
            } else
#line 1967
            if (! (v->isarr & (((1 << 3) | (1 << 4)) | (1 << 7)))) {
#line 1971
              v->isarr = 0;
            }
          }
        }
#line 1972
        v->start = start;
#line 1973
        v->end = end;
      } else {
#line 1975
        s = *pptr;
      }
    }
  }
#line 1978
  *tbrack = (char )']';
#line 1979
  *pptr = s;
#line 1980
  return (0);
}
}
#line 1985 "/tmp/zsh-5.4.2/Src/params.c"
Value getvalue(Value v , char **pptr , int bracks ) 
{ 
  Value tmp ;

  {
  {
#line 1988
  tmp = fetchvalue(v, pptr, bracks, 0);
  }
#line 1988
  return (tmp);
}
}
#line 1992 "/tmp/zsh-5.4.2/Src/params.c"
Value fetchvalue(Value v , char **pptr , int bracks , int flags ) 
{ 
  char *s ;
  char *t ;
  char *ie ;
  char sav ;
  char c ;
  int ppar ;
  zlong tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  Param pm ;
  int isvarat ;
  int tmp___8 ;
  char const   *tmp___9 ;
  HashNode tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;

  {
#line 1997
  ppar = 0;
#line 1999
  t = *pptr;
#line 1999
  s = t;
#line 2001
  c = *s;
#line 2001
  if ((int )typtab[(unsigned char )c] & 1) {
#line 2002
    if (bracks >= 0) {
      {
#line 2003
      tmp = zstrtol((char const   *)s, & s, 10);
#line 2003
      ppar = (int )tmp;
      }
    } else {
#line 2005
      tmp___0 = s;
#line 2005
      s ++;
#line 2005
      ppar = (int )*tmp___0 - 48;
    }
  } else {
    {
#line 2007
    ie = itype_end((char const   *)s, 1 << 7, 0);
    }
#line 2007
    if ((unsigned long )ie != (unsigned long )s) {
#line 2008
      s = ie;
    } else
#line 2009
    if ((int )c == -105) {
#line 2010
      tmp___1 = s;
#line 2010
      s ++;
#line 2010
      *tmp___1 = (char )'?';
    } else
#line 2011
    if ((int )c == -124) {
#line 2012
      tmp___2 = s;
#line 2012
      s ++;
#line 2012
      *tmp___2 = (char )'#';
    } else
#line 2013
    if ((int )c == -123) {
#line 2014
      tmp___3 = s;
#line 2014
      s ++;
#line 2014
      *tmp___3 = (char )'$';
    } else
#line 2015
    if ((int )c == -116) {
#line 2016
      tmp___4 = s;
#line 2016
      s ++;
#line 2016
      *tmp___4 = (char )'$';
    } else
#line 2017
    if ((int )c == -121) {
#line 2018
      tmp___5 = s;
#line 2018
      s ++;
#line 2018
      *tmp___5 = (char )'*';
    } else
#line 2019
    if ((int )c == 45) {
#line 2020
      tmp___6 = s;
#line 2020
      s ++;
#line 2020
      *tmp___6 = (char )'-';
    } else
#line 2019
    if ((int )c == -101) {
#line 2020
      tmp___6 = s;
#line 2020
      s ++;
#line 2020
      *tmp___6 = (char )'-';
    } else
#line 2021
    if ((int )c == 35) {
#line 2023
      s ++;
    } else
#line 2021
    if ((int )c == 63) {
#line 2023
      s ++;
    } else
#line 2021
    if ((int )c == 36) {
#line 2023
      s ++;
    } else
#line 2021
    if ((int )c == 33) {
#line 2023
      s ++;
    } else
#line 2021
    if ((int )c == 64) {
#line 2023
      s ++;
    } else
#line 2021
    if ((int )c == 42) {
#line 2023
      s ++;
    } else {
#line 2025
      return ((Value )((void *)0));
    }
  }
#line 2027
  sav = *s;
#line 2027
  if (sav) {
#line 2028
    *s = (char )'\000';
  }
#line 2029
  if (ppar) {
#line 2030
    if (v) {
      {
#line 2031
      memset((void *)v, 0, sizeof(*v));
      }
    } else {
      {
#line 2033
      tmp___7 = hcalloc(sizeof(*v));
#line 2033
      v = (Value )tmp___7;
      }
    }
#line 2034
    v->pm = argvparam;
#line 2035
    v->flags = 0;
#line 2036
    v->start = ppar - 1;
#line 2037
    v->end = ppar;
#line 2038
    if (sav) {
#line 2039
      *s = sav;
    }
  } else {
#line 2044
    if ((int )*(t + 0) == 64) {
#line 2044
      if (! *(t + 1)) {
#line 2044
        tmp___8 = 1;
      } else {
#line 2044
        tmp___8 = 0;
      }
    } else {
#line 2044
      tmp___8 = 0;
    }
#line 2044
    isvarat = tmp___8;
#line 2045
    if ((int )*t == 48) {
#line 2045
      tmp___9 = "0";
    } else {
#line 2045
      tmp___9 = (char const   *)t;
    }
    {
#line 2045
    tmp___10 = (*(paramtab->getnode))(paramtab, tmp___9);
#line 2045
    pm = (Param )tmp___10;
    }
#line 2046
    if (sav) {
#line 2047
      *s = sav;
    }
#line 2048
    *pptr = s;
#line 2049
    if (! pm) {
#line 2050
      return ((Value )((void *)0));
    } else
#line 2049
    if (pm->node.flags & (1 << 25)) {
#line 2050
      return ((Value )((void *)0));
    }
#line 2051
    if (v) {
      {
#line 2052
      memset((void *)v, 0, sizeof(*v));
      }
    } else {
      {
#line 2054
      tmp___11 = hcalloc(sizeof(*v));
#line 2054
      v = (Value )tmp___11;
      }
    }
#line 2055
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) & (1 | (1 << 4))) {
#line 2057
      if (isvarat) {
#line 2057
        tmp___12 = (int )(4294967295U << 15);
      } else {
#line 2057
        tmp___12 = 0;
      }
#line 2057
      v->isarr = flags | tmp___12;
#line 2061
      if (! v->isarr) {
#line 2062
        v->isarr = 1 << 9;
      }
    }
#line 2064
    v->pm = pm;
#line 2065
    v->flags = 0;
#line 2066
    v->start = 0;
#line 2067
    v->end = -1;
#line 2068
    if (bracks > 0) {
#line 2068
      if ((int )*s == 91) {
#line 2068
        goto _L___0;
      } else
#line 2068
      if ((int )*s == -111) {
        _L___0: /* CIL Label */ 
        {
#line 2069
        tmp___13 = getindex(& s, v, flags);
        }
#line 2069
        if (tmp___13) {
#line 2070
          *pptr = s;
#line 2071
          return (v);
        }
      } else {
#line 2068
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2073
    if (! (flags & (1 << 6))) {
#line 2073
      if (v->isarr) {
        {
#line 2073
        tmp___14 = itype_end((char const   *)t, 1 << 7, 1);
        }
#line 2073
        if ((unsigned long )tmp___14 != (unsigned long )t) {
#line 2073
          if (opts[95]) {
#line 2075
            v->end = 1;
#line 2075
            v->isarr = 0;
          }
        }
      }
    }
  }
#line 2077
  if (! bracks) {
#line 2077
    if (*s) {
#line 2078
      return ((Value )((void *)0));
    }
  }
#line 2079
  *pptr = s;
#line 2109
  return (v);
}
}
#line 2113 "/tmp/zsh-5.4.2/Src/params.c"
char *getstrvalue(Value v ) 
{ 
  char *s ;
  char **ss ;
  char buf___7[(int )(sizeof(zlong ) * 8UL + 4UL)] ;
  int len ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___3 ;
  char tmp___4 ;
  zlong tmp___5 ;
  double tmp___6 ;
  unsigned int fwidth ;
  int tmp___7 ;
  int tmp___8 ;
  char *t ;
  char *tend ;
  unsigned int t0 ;
  int tmp___9 ;
  void *tmp___10 ;
  int zero ;
  unsigned int charlen ;
  int tmp___11 ;
  char *valprefend ;
  int preflen ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  char *eptr ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
#line 2120
  if (! v) {
    {
#line 2121
    tmp = hcalloc((size_t )1);
    }
#line 2121
    return ((char *)tmp);
  }
#line 2123
  if (v->flags & 1) {
#line 2123
    if (! ((v->pm)->node.flags & (1 << 4))) {
      {
#line 2124
      sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%d",
              v->start);
#line 2125
      s = dupstring((char const   *)(buf___7));
      }
#line 2126
      return (s);
    }
  }
  {
#line 2130
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
#line 2130
    goto case_exp;
  }
#line 2138
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 2138
    goto case_1;
  }
#line 2149
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 2149
    goto case_exp___0;
  }
#line 2154
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 2154
    goto case_exp___1;
  }
#line 2154
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 2154
    goto case_exp___1;
  }
#line 2158
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 2158
    goto case_0;
  }
#line 2161
  goto switch_default;
  case_exp: /* CIL Label */ 
#line 2132
  if (! v->isarr) {
#line 2132
    if (emulation & (1 << 2)) {
      {
#line 2133
      s = dupstring("[0]");
#line 2134
      tmp___0 = getindex(& s, v, 0);
      }
#line 2134
      if (tmp___0 == 0) {
        {
#line 2135
        s = getstrvalue(v);
        }
      }
#line 2136
      return (s);
    }
  }
  case_1: /* CIL Label */ 
  {
#line 2139
  ss = getvaluearr(v);
  }
#line 2140
  if (v->isarr) {
    {
#line 2141
    s = sepjoin(ss, (char *)((void *)0), 1);
    }
  } else {
#line 2143
    if (v->start < 0) {
      {
#line 2144
      tmp___1 = arrlen(ss);
#line 2144
      v->start += tmp___1;
      }
    }
    {
#line 2145
    tmp___4 = arrlen_le(ss, (unsigned int )v->start);
    }
#line 2145
    if (tmp___4) {
      {
#line 2145
      tmp___3 = hcalloc((size_t )1);
#line 2145
      s = (char *)tmp___3;
      }
    } else
#line 2145
    if (v->start < 0) {
      {
#line 2145
      tmp___3 = hcalloc((size_t )1);
#line 2145
      s = (char *)tmp___3;
      }
    } else {
#line 2145
      s = *(ss + v->start);
    }
  }
#line 2148
  return (s);
  case_exp___0: /* CIL Label */ 
  {
#line 2150
  tmp___5 = (*(((v->pm)->gsu.i)->getfn))(v->pm);
#line 2150
  convbase(buf___7, tmp___5, (v->pm)->base);
#line 2151
  s = dupstring((char const   *)(buf___7));
  }
#line 2152
  goto switch_break;
  case_exp___1: /* CIL Label */ 
  case_exp___2: /* CIL Label */ 
  {
#line 2155
  tmp___6 = (*(((v->pm)->gsu.f)->getfn))(v->pm);
#line 2155
  s = convfloat(tmp___6, (v->pm)->base, (v->pm)->node.flags, (FILE *)((void *)0));
  }
#line 2157
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 2159
  s = (*(((v->pm)->gsu.s)->getfn))(v->pm);
  }
#line 2160
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2162
  s = (char *)"";
#line 2164
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2167
  if (v->flags & 4) {
#line 2168
    if ((v->pm)->node.flags & (((1 << 5) | (1 << 6)) | (1 << 7))) {
#line 2169
      if ((v->pm)->width) {
#line 2169
        tmp___8 = (v->pm)->width;
      } else {
        {
#line 2169
        tmp___7 = mb_metastrlenend(s, 0, (char *)((void *)0));
#line 2169
        tmp___8 = tmp___7;
        }
      }
#line 2169
      fwidth = (unsigned int )tmp___8;
      {
#line 2175
      if (((v->pm)->node.flags & (((1 << 5) | (1 << 6)) | (1 << 7))) == ((1 << 5) | (1 << 7))) {
#line 2175
        goto case_exp___3;
      }
#line 2175
      if (((v->pm)->node.flags & (((1 << 5) | (1 << 6)) | (1 << 7))) == 1 << 5) {
#line 2175
        goto case_exp___3;
      }
#line 2206
      if (((v->pm)->node.flags & (((1 << 5) | (1 << 6)) | (1 << 7))) == ((1 << 7) | (1 << 6))) {
#line 2206
        goto case_exp___5;
      }
#line 2206
      if (((v->pm)->node.flags & (((1 << 5) | (1 << 6)) | (1 << 7))) == 1 << 7) {
#line 2206
        goto case_exp___5;
      }
#line 2206
      if (((v->pm)->node.flags & (((1 << 5) | (1 << 6)) | (1 << 7))) == 1 << 6) {
#line 2206
        goto case_exp___5;
      }
#line 2170
      goto switch_break___0;
      case_exp___3: /* CIL Label */ 
      case_exp___4: /* CIL Label */ 
#line 2176
      t = s;
#line 2177
      if ((v->pm)->node.flags & (1 << 7)) {
        {
#line 2178
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2178
          if (! ((int )*t == 48)) {
#line 2178
            goto while_break;
          }
#line 2179
          t ++;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
        {
#line 2181
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2181
          if (! ((int )typtab[(unsigned char )*t] & (1 << 2))) {
#line 2181
            goto while_break___0;
          }
#line 2182
          t ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 2183
      mb_charinit();
#line 2184
      tend = t;
#line 2184
      t0 = 0U;
      }
      {
#line 2184
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2184
        if (t0 < fwidth) {
#line 2184
          if (! *tend) {
#line 2184
            goto while_break___1;
          }
        } else {
#line 2184
          goto while_break___1;
        }
        {
#line 2185
        tmp___9 = mb_metacharlenconv((char const   *)tend, (wint_t *)((void *)0));
#line 2185
        tend += tmp___9;
#line 2184
        t0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 2196
      fwidth -= t0;
#line 2197
      t0 = (unsigned int )(tend - t);
#line 2198
      tmp___10 = hcalloc((size_t )((t0 + fwidth) + 1U));
#line 2198
      s = (char *)tmp___10;
#line 2199
      memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)t, (size_t )t0);
      }
#line 2200
      if (fwidth) {
        {
#line 2201
        memset((void *)(s + t0), ' ', (size_t )fwidth);
        }
      }
#line 2202
      *(s + (t0 + fwidth)) = (char )'\000';
#line 2203
      goto switch_break___0;
      case_exp___5: /* CIL Label */ 
      case_exp___6: /* CIL Label */ 
      case_exp___7: /* CIL Label */ 
      {
#line 2208
      zero = 1;
#line 2210
      tmp___11 = mb_metastrlenend(s, 0, (char *)((void *)0));
#line 2210
      charlen = (unsigned int )tmp___11;
      }
#line 2212
      if (charlen < fwidth) {
#line 2213
        valprefend = s;
#line 2215
        if ((v->pm)->node.flags & (1 << 7)) {
#line 2224
          t = s;
          {
#line 2224
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2224
            if (! ((int )typtab[(unsigned char )*t] & (1 << 2))) {
#line 2224
              goto while_break___2;
            }
#line 2224
            t ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2230
          if ((v->pm)->node.flags & (((1 << 1) | (1 << 2)) | (1 << 3))) {
#line 2230
            if ((int )*t == 45) {
#line 2233
              t ++;
            }
          }
#line 2238
          if ((v->pm)->node.flags & (1 << 1)) {
#line 2239
            if (opts[28]) {
#line 2239
              if ((int )*(t + 0) == 48) {
#line 2239
                if ((int )*(t + 1) == 120) {
#line 2241
                  t += 2;
                } else {
#line 2239
                  goto _L___0;
                }
              } else {
#line 2239
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
              {
#line 2242
              valprefend = strchr((char const   *)t, '#');
              }
#line 2242
              if (valprefend) {
#line 2243
                t = valprefend + 1;
              }
            }
          }
#line 2245
          valprefend = t;
#line 2246
          if (! *t) {
#line 2247
            zero = 0;
          } else
#line 2248
          if (! ((v->pm)->node.flags & (((1 << 1) | (1 << 2)) | (1 << 3)))) {
#line 2251
            if (! ((int )typtab[(unsigned char )*t] & 1)) {
#line 2252
              zero = 0;
            }
          }
        }
        {
#line 2255
        fwidth -= charlen;
#line 2257
        tmp___12 = strlen((char const   *)s);
#line 2257
        t0 = (unsigned int )tmp___12;
#line 2258
        tmp___13 = hcalloc((size_t )((fwidth + t0) + 1U));
#line 2258
        t = (char *)tmp___13;
#line 2260
        preflen = (int )(valprefend - s);
        }
#line 2261
        if ((v->pm)->node.flags & (1 << 6)) {
#line 2261
          tmp___14 = ' ';
        } else
#line 2261
        if (! zero) {
#line 2261
          tmp___14 = ' ';
        } else {
#line 2261
          tmp___14 = '0';
        }
        {
#line 2261
        memset((void *)(t + preflen), tmp___14, (size_t )fwidth);
        }
#line 2268
        if (preflen) {
          {
#line 2269
          memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)s, (size_t )preflen);
          }
        }
        {
#line 2270
        memcpy((void */* __restrict  */)((t + preflen) + fwidth), (void const   */* __restrict  */)valprefend,
               (size_t )(t0 - (unsigned int )preflen));
#line 2272
        *(t + (fwidth + t0)) = (char )'\000';
#line 2273
        s = t;
        }
      } else {
#line 2276
        t0 = charlen - fwidth;
        {
#line 2276
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2276
          if (! t0) {
#line 2276
            goto while_break___3;
          }
          {
#line 2277
          tmp___15 = mb_metacharlenconv((char const   *)s, (wint_t *)((void *)0));
#line 2277
          s += tmp___15;
#line 2276
          t0 --;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2280
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
#line 2284
    if (((v->pm)->node.flags & ((1 << 8) | (1 << 9))) == 1 << 8) {
#line 2284
      goto case_exp___8;
    }
#line 2287
    if (((v->pm)->node.flags & ((1 << 8) | (1 << 9))) == 1 << 9) {
#line 2287
      goto case_exp___9;
    }
#line 2283
    goto switch_break___1;
    case_exp___8: /* CIL Label */ 
    {
#line 2285
    s = casemodify(s, 2);
    }
#line 2286
    goto switch_break___1;
    case_exp___9: /* CIL Label */ 
    {
#line 2288
    s = casemodify(s, 1);
    }
#line 2289
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 2292
  if (v->start == 0) {
#line 2292
    if (v->end == -1) {
#line 2293
      return (s);
    }
  }
  {
#line 2295
  tmp___16 = strlen((char const   *)s);
#line 2295
  len = (int )tmp___16;
  }
#line 2296
  if (v->start < 0) {
#line 2297
    v->start += len;
#line 2298
    if (v->start < 0) {
#line 2299
      v->start = 0;
    }
  }
#line 2301
  if (v->end < 0) {
#line 2302
    v->end += len;
#line 2303
    if (v->end >= 0) {
#line 2304
      eptr = s + v->end;
#line 2305
      if (*eptr) {
        {
#line 2306
        tmp___17 = mb_metacharlenconv((char const   *)eptr, (wint_t *)((void *)0));
#line 2306
        v->end += tmp___17;
        }
      }
    }
  }
#line 2310
  if (v->start > len) {
    {
#line 2310
    tmp___18 = dupstring("");
#line 2310
    s = tmp___18;
    }
  } else {
    {
#line 2310
    tmp___19 = dupstring_wlen((char const   *)(s + v->start), (unsigned int )(len - v->start));
#line 2310
    s = tmp___19;
    }
  }
#line 2313
  if (v->end <= v->start) {
#line 2314
    *(s + 0) = (char )'\000';
  } else
#line 2315
  if (v->end - v->start <= len - v->start) {
#line 2316
    *(s + (v->end - v->start)) = (char )'\000';
  }
#line 2318
  return (s);
}
}
#line 2321 "/tmp/zsh-5.4.2/Src/params.c"
static char *nular[2]  = {      (char *)"",      (char *)((void *)0)};
#line 2324 "/tmp/zsh-5.4.2/Src/params.c"
char **getarrvalue(Value v ) 
{ 
  char **s ;
  char **tmp ;
  char **tmp___0 ;
  char buf___7[(int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3] ;
  int tmp___1 ;
  int tmp___2 ;
  char tmp___3 ;

  {
#line 2329
  if (! v) {
    {
#line 2330
    tmp = arrdup(nular);
    }
#line 2330
    return (tmp);
  } else
#line 2331
  if (v) {
#line 2331
    if (! v->pm) {
      {
#line 2332
      tmp___0 = arrdup(& nular[1]);
      }
#line 2332
      return (tmp___0);
    } else
#line 2331
    if ((v->pm)->node.flags & (1 << 25)) {
      {
#line 2332
      tmp___0 = arrdup(& nular[1]);
      }
#line 2332
      return (tmp___0);
    } else
#line 2331
    if (! (v->pm)->node.nam) {
      {
#line 2332
      tmp___0 = arrdup(& nular[1]);
      }
#line 2332
      return (tmp___0);
    } else
#line 2331
    if (! *((v->pm)->node.nam)) {
      {
#line 2332
      tmp___0 = arrdup(& nular[1]);
      }
#line 2332
      return (tmp___0);
    }
  }
#line 2333
  if (v->flags & 1) {
    {
#line 2336
    s = arrdup(nular);
#line 2337
    sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%d",
            v->start);
#line 2338
    *(s + 0) = dupstring((char const   *)(buf___7));
    }
#line 2339
    return (s);
  }
  {
#line 2341
  s = getvaluearr(v);
  }
#line 2342
  if (v->start == 0) {
#line 2342
    if (v->end == -1) {
#line 2343
      return (s);
    }
  }
#line 2344
  if (v->start < 0) {
    {
#line 2345
    tmp___1 = arrlen(s);
#line 2345
    v->start += tmp___1;
    }
  }
#line 2346
  if (v->end < 0) {
    {
#line 2347
    tmp___2 = arrlen(s);
#line 2347
    v->end += tmp___2 + 1;
    }
  }
#line 2350
  if (v->end <= v->start) {
    {
#line 2351
    s = arrdup_max(nular, 0U);
    }
  } else
#line 2353
  if (v->start < 0) {
    {
#line 2354
    s = arrdup_max(nular, 1U);
    }
  } else {
    {
#line 2356
    tmp___3 = arrlen_le(s, (unsigned int )v->start);
    }
#line 2356
    if (tmp___3) {
      {
#line 2360
      s = arrdup_max(nular, (unsigned int )(v->end - (v->start + 1)));
      }
    } else {
      {
#line 2370
      s = arrdup_max(s + v->start, (unsigned int )(v->end - v->start));
      }
    }
  }
#line 2373
  return (s);
}
}
#line 2377 "/tmp/zsh-5.4.2/Src/params.c"
zlong getintvalue(Value v ) 
{ 
  char **arr ;
  char **tmp ;
  char *scal ;
  char *tmp___0 ;
  zlong tmp___1 ;
  zlong tmp___2 ;
  double tmp___3 ;
  char *tmp___4 ;
  zlong tmp___5 ;

  {
#line 2380
  if (! v) {
#line 2381
    return ((zlong )0);
  }
#line 2382
  if (v->flags & 1) {
#line 2383
    return ((zlong )v->start);
  }
#line 2384
  if (v->isarr) {
    {
#line 2385
    tmp = getarrvalue(v);
#line 2385
    arr = tmp;
    }
#line 2386
    if (arr) {
      {
#line 2387
      tmp___0 = sepjoin(arr, (char *)((void *)0), 1);
#line 2387
      scal = tmp___0;
#line 2388
      tmp___1 = mathevali(scal);
      }
#line 2388
      return (tmp___1);
    } else {
#line 2390
      return ((zlong )0);
    }
  }
#line 2392
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
    {
#line 2393
    tmp___2 = (*(((v->pm)->gsu.i)->getfn))(v->pm);
    }
#line 2393
    return (tmp___2);
  }
#line 2394
  if ((v->pm)->node.flags & ((1 << 2) | (1 << 3))) {
    {
#line 2395
    tmp___3 = (*(((v->pm)->gsu.f)->getfn))(v->pm);
    }
#line 2395
    return ((zlong )tmp___3);
  }
  {
#line 2396
  tmp___4 = getstrvalue(v);
#line 2396
  tmp___5 = mathevali(tmp___4);
  }
#line 2396
  return (tmp___5);
}
}
#line 2400 "/tmp/zsh-5.4.2/Src/params.c"
mnumber getnumvalue(Value v ) 
{ 
  mnumber mn ;
  char **arr ;
  char **tmp ;
  char *scal ;
  char *tmp___0 ;
  mnumber tmp___1 ;
  char *tmp___2 ;
  mnumber tmp___3 ;

  {
#line 2404
  mn.type = 1;
#line 2407
  if (! v) {
#line 2408
    mn.u.l = (zlong )0;
  } else
#line 2409
  if (v->flags & 1) {
#line 2410
    mn.u.l = (zlong )v->start;
  } else
#line 2411
  if (v->isarr) {
    {
#line 2412
    tmp = getarrvalue(v);
#line 2412
    arr = tmp;
    }
#line 2413
    if (arr) {
      {
#line 2414
      tmp___0 = sepjoin(arr, (char *)((void *)0), 1);
#line 2414
      scal = tmp___0;
#line 2415
      tmp___1 = matheval(scal);
      }
#line 2415
      return (tmp___1);
    } else {
#line 2417
      mn.u.l = (zlong )0;
    }
  } else
#line 2418
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
    {
#line 2419
    mn.u.l = (*(((v->pm)->gsu.i)->getfn))(v->pm);
    }
  } else
#line 2420
  if ((v->pm)->node.flags & ((1 << 2) | (1 << 3))) {
    {
#line 2421
    mn.type = 2;
#line 2422
    mn.u.d = (*(((v->pm)->gsu.f)->getfn))(v->pm);
    }
  } else {
    {
#line 2424
    tmp___2 = getstrvalue(v);
#line 2424
    tmp___3 = matheval(tmp___2);
    }
#line 2424
    return (tmp___3);
  }
#line 2425
  return (mn);
}
}
#line 2429 "/tmp/zsh-5.4.2/Src/params.c"
void export_param(Param pm ) 
{ 
  char buf___7[(int )(sizeof(zlong ) * 8UL + 4UL)] ;
  char *val ;
  zlong tmp ;
  double tmp___0 ;

  {
#line 2434
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) & (1 | (1 << 4))) {
#line 2445
    return;
  } else
#line 2446
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
    {
#line 2447
    tmp = (*((pm->gsu.i)->getfn))(pm);
#line 2447
    val = buf___7;
#line 2447
    convbase(val, tmp, pm->base);
    }
  } else
#line 2448
  if (pm->node.flags & ((1 << 2) | (1 << 3))) {
    {
#line 2449
    tmp___0 = (*((pm->gsu.f)->getfn))(pm);
#line 2449
    val = convfloat(tmp___0, pm->base, pm->node.flags, (FILE *)((void *)0));
    }
  } else {
    {
#line 2452
    val = (*((pm->gsu.s)->getfn))(pm);
    }
  }
  {
#line 2454
  addenv(pm, val);
  }
#line 2455
  return;
}
}
#line 2458 "/tmp/zsh-5.4.2/Src/params.c"
void setstrvalue(Value v , char *val ) 
{ 


  {
  {
#line 2461
  assignstrvalue(v, val, 0);
  }
#line 2462
  return;
}
}
#line 2465 "/tmp/zsh-5.4.2/Src/params.c"
void assignstrvalue(Value v , char *val , int flags ) 
{ 
  size_t tmp ;
  char *z ;
  char *x ;
  int zlen ;
  int vlen ;
  int newsize ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  Param pm ;
  zlong ival ;
  char *ptr___0 ;
  size_t tmp___4 ;
  mnumber mn ;
  char *ptr___1 ;
  double tmp___5 ;
  size_t tmp___6 ;
  char **ss ;
  void *tmp___7 ;

  {
#line 2468
  if (! opts[52]) {
#line 2469
    return;
  }
#line 2470
  if ((v->pm)->node.flags & (1 << 10)) {
    {
#line 2471
    zerr("read-only variable: %s", (v->pm)->node.nam);
#line 2472
    zsfree(val);
    }
#line 2473
    return;
  }
#line 2475
  if ((v->pm)->node.flags & (1 << 24)) {
#line 2475
    if (opts[154]) {
      {
#line 2476
      zerr("%s: restricted", (v->pm)->node.nam);
#line 2477
      zsfree(val);
      }
#line 2478
      return;
    }
  }
#line 2480
  if ((v->pm)->node.flags & (1 << 4)) {
#line 2480
    if (v->isarr & ((1 << 5) | (1 << 9))) {
      {
#line 2482
      zerr("%s: attempt to set slice of associative array", (v->pm)->node.nam);
#line 2483
      zsfree(val);
      }
#line 2484
      return;
    }
  }
#line 2486
  if (v->flags & 2) {
    {
#line 2487
    zerr("%s: assignment to invalid subscript range", (v->pm)->node.nam);
#line 2488
    zsfree(val);
    }
#line 2489
    return;
  }
#line 2491
  (v->pm)->node.flags &= ~ (1 << 25);
  {
#line 2493
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 2493
    goto case_0;
  }
#line 2565
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 2565
    goto case_exp;
  }
#line 2583
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 2583
    goto case_exp___0;
  }
#line 2583
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 2583
    goto case_exp___0;
  }
#line 2600
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 2600
    goto case_1;
  }
#line 2609
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
#line 2609
    goto case_exp___2;
  }
#line 2492
  goto switch_break;
  case_0: /* CIL Label */ 
#line 2494
  if (v->start == 0) {
#line 2494
    if (v->end == -1) {
      {
#line 2495
      (*(((v->pm)->gsu.s)->setfn))(v->pm, val);
      }
#line 2496
      if ((v->pm)->node.flags & (((1 << 5) | (1 << 6)) | (1 << 7))) {
#line 2496
        if (! (v->pm)->width) {
          {
#line 2498
          tmp = strlen((char const   *)val);
#line 2498
          (v->pm)->width = (int )tmp;
          }
        }
      }
    } else {
#line 2494
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 2503
    z = (*(((v->pm)->gsu.s)->getfn))(v->pm);
#line 2504
    tmp___0 = strlen((char const   *)z);
#line 2504
    zlen = (int )tmp___0;
    }
#line 2506
    if (v->flags & 1) {
#line 2506
      if (! opts[95]) {
#line 2507
        (v->start) --;
#line 2507
        (v->end) --;
      }
    }
#line 2508
    if (v->start < 0) {
#line 2509
      v->start += zlen;
#line 2510
      if (v->start < 0) {
#line 2511
        v->start = 0;
      }
    }
#line 2513
    if (v->start > zlen) {
#line 2514
      v->start = zlen;
    }
#line 2515
    if (v->end < 0) {
#line 2516
      v->end += zlen;
#line 2517
      if (v->end < 0) {
#line 2518
        v->end = 0;
      } else
#line 2519
      if (v->end >= zlen) {
#line 2520
        v->end = zlen;
      } else
#line 2523
      if (opts[117]) {
        {
#line 2524
        tmp___1 = mb_metacharlenconv((char const   *)(z + v->end), (wint_t *)((void *)0));
#line 2524
        v->end += tmp___1;
        }
      } else {
#line 2526
        (v->end) ++;
      }
    } else
#line 2533
    if (v->end > zlen) {
#line 2534
      v->end = zlen;
    }
    {
#line 2536
    tmp___2 = strlen((char const   *)val);
#line 2536
    vlen = (int )tmp___2;
#line 2540
    newsize = (v->start + vlen) + (zlen - v->end);
    }
#line 2543
    if (newsize != zlen) {
#line 2543
      goto _L;
    } else
#line 2543
    if ((unsigned long )((v->pm)->gsu.s)->setfn != (unsigned long )(& strsetfn)) {
      _L: /* CIL Label */ 
      {
#line 2544
      tmp___3 = zalloc((size_t )(newsize + 1));
#line 2544
      x = (char *)tmp___3;
#line 2545
      strncpy((char */* __restrict  */)x, (char const   */* __restrict  */)z, (size_t )v->start);
#line 2546
      strcpy((char */* __restrict  */)(x + v->start), (char const   */* __restrict  */)val);
#line 2547
      strcat((char */* __restrict  */)(x + v->start), (char const   */* __restrict  */)(z + v->end));
#line 2548
      (*(((v->pm)->gsu.s)->setfn))(v->pm, x);
      }
    } else {
      {
#line 2550
      pm = v->pm;
#line 2553
      strncpy((char */* __restrict  */)(z + v->start), (char const   */* __restrict  */)val,
              (size_t )vlen);
      }
#line 2555
      if (! (pm->node.flags & (1 << 29))) {
#line 2555
        if (pm->node.flags & (1 << 30)) {
          {
#line 2558
          pm->node.flags |= 1 << 30;
#line 2559
          adduserdir(pm->node.nam, z, 0, 0);
          }
        } else
#line 2555
        if (opts[11]) {
          {
#line 2558
          pm->node.flags |= 1 << 30;
#line 2559
          adduserdir(pm->node.nam, z, 0, 0);
          }
        }
      }
    }
    {
#line 2562
    zsfree(val);
    }
  }
#line 2564
  goto switch_break;
  case_exp: /* CIL Label */ 
#line 2566
  if (val) {
#line 2568
    if (flags & 8) {
      {
#line 2570
      ival = zstrtol_underscore((char const   *)val, & ptr___0, 0, 1);
      }
    } else {
      {
#line 2572
      ival = mathevali(val);
      }
    }
    {
#line 2573
    (*(((v->pm)->gsu.i)->setfn))(v->pm, ival);
    }
#line 2574
    if ((v->pm)->node.flags & (((1 << 5) | (1 << 6)) | (1 << 7))) {
#line 2574
      if (! (v->pm)->width) {
        {
#line 2576
        tmp___4 = strlen((char const   *)val);
#line 2576
        (v->pm)->width = (int )tmp___4;
        }
      }
    }
    {
#line 2577
    zsfree(val);
    }
  }
#line 2579
  if (! (v->pm)->base) {
#line 2579
    if (lastbase != -1) {
#line 2580
      (v->pm)->base = lastbase;
    }
  }
#line 2581
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  case_exp___1: /* CIL Label */ 
#line 2584
  if (val) {
#line 2586
    if (flags & 8) {
      {
#line 2588
      mn.type = 2;
#line 2589
      mn.u.d = strtod((char const   */* __restrict  */)val, (char **/* __restrict  */)(& ptr___1));
      }
    } else {
      {
#line 2591
      mn = matheval(val);
      }
    }
#line 2592
    if (mn.type & 2) {
#line 2592
      tmp___5 = mn.u.d;
    } else {
#line 2592
      tmp___5 = (double )mn.u.l;
    }
    {
#line 2592
    (*(((v->pm)->gsu.f)->setfn))(v->pm, tmp___5);
    }
#line 2594
    if ((v->pm)->node.flags & (((1 << 5) | (1 << 6)) | (1 << 7))) {
#line 2594
      if (! (v->pm)->width) {
        {
#line 2596
        tmp___6 = strlen((char const   *)val);
#line 2596
        (v->pm)->width = (int )tmp___6;
        }
      }
    }
    {
#line 2597
    zsfree(val);
    }
  }
#line 2599
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2602
  tmp___7 = zalloc(2UL * sizeof(char *));
#line 2602
  ss = (char **)tmp___7;
#line 2604
  *(ss + 0) = val;
#line 2605
  *(ss + 1) = (char *)((void *)0);
#line 2606
  setarrvalue(v, ss);
  }
#line 2608
  goto switch_break;
  case_exp___2: /* CIL Label */ 
#line 2611
  if ((unsigned long )foundparam == (unsigned long )((void *)0)) {
    {
#line 2613
    zerr("%s: attempt to set associative array to scalar", (v->pm)->node.nam);
#line 2615
    zsfree(val);
    }
#line 2616
    return;
  } else {
    {
#line 2619
    (*((foundparam->gsu.s)->setfn))(foundparam, val);
    }
  }
#line 2621
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2623
  if (! (v->pm)->env) {
#line 2623
    if (! ((v->pm)->node.flags & (1 << 12))) {
#line 2623
      if (opts[3]) {
#line 2623
        if (! ((v->pm)->node.flags & (1 << 29))) {
#line 2623
          goto _L___2;
        } else {
#line 2626
          return;
        }
      } else {
#line 2626
        return;
      }
    } else {
#line 2623
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2623
  if ((v->pm)->node.flags & 1) {
#line 2626
    return;
  } else
#line 2623
  if ((v->pm)->ename) {
#line 2626
    return;
  }
  {
#line 2627
  export_param(v->pm);
  }
#line 2628
  return;
}
}
#line 2631 "/tmp/zsh-5.4.2/Src/params.c"
void setnumvalue(Value v , mnumber val ) 
{ 
  char buf___7[(int )(sizeof(zlong ) * 8UL + 4UL)] ;
  char *p ;
  char *tmp ;
  zlong tmp___0 ;
  double tmp___1 ;

  {
#line 2636
  if (! opts[52]) {
#line 2637
    return;
  }
#line 2638
  if ((v->pm)->node.flags & (1 << 10)) {
    {
#line 2639
    zerr("read-only variable: %s", (v->pm)->node.nam);
    }
#line 2640
    return;
  }
#line 2642
  if ((v->pm)->node.flags & (1 << 24)) {
#line 2642
    if (opts[154]) {
      {
#line 2643
      zerr("%s: restricted", (v->pm)->node.nam);
      }
#line 2644
      return;
    }
  }
  {
#line 2648
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 2648
    goto case_1;
  }
#line 2648
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 2648
    goto case_1;
  }
#line 2658
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 2658
    goto case_exp;
  }
#line 2664
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 2664
    goto case_exp___0;
  }
#line 2664
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 2664
    goto case_exp___0;
  }
#line 2646
  goto switch_break;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2649
  if (val.type & 1) {
#line 2649
    goto _L;
  } else
#line 2649
  if (outputradix) {
    _L: /* CIL Label */ 
#line 2650
    if (! (val.type & 1)) {
#line 2651
      val.u.l = (zlong )val.u.d;
    }
    {
#line 2652
    p = convbase_underscore(buf___7, val.u.l, outputradix, outputunderscore);
    }
  } else {
    {
#line 2655
    p = convfloat_underscore(val.u.d, outputunderscore);
    }
  }
  {
#line 2656
  tmp = ztrdup((char const   *)p);
#line 2656
  setstrvalue(v, tmp);
  }
#line 2657
  goto switch_break;
  case_exp: /* CIL Label */ 
#line 2659
  if (val.type & 1) {
#line 2659
    tmp___0 = val.u.l;
  } else {
#line 2659
    tmp___0 = (zlong )val.u.d;
  }
  {
#line 2659
  (*(((v->pm)->gsu.i)->setfn))(v->pm, tmp___0);
#line 2661
  setstrvalue(v, (char *)((void *)0));
  }
#line 2662
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  case_exp___1: /* CIL Label */ 
#line 2665
  if (val.type & 1) {
#line 2665
    tmp___1 = (double )val.u.l;
  } else {
#line 2665
    tmp___1 = val.u.d;
  }
  {
#line 2665
  (*(((v->pm)->gsu.f)->setfn))(v->pm, tmp___1);
#line 2667
  setstrvalue(v, (char *)((void *)0));
  }
#line 2668
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2670
  return;
}
}
#line 2673 "/tmp/zsh-5.4.2/Src/params.c"
void setarrvalue(Value v , char **val ) 
{ 
  char **old ;
  char **tmp ;
  char **new ;
  char **p ;
  char **q ;
  char **r ;
  int pre_assignment_length ;
  int tmp___0 ;
  int post_assignment_length ;
  int i ;
  int tmp___1 ;
  char **tmp___2 ;
  char **tmp___3 ;
  void *tmp___4 ;
  char **tmp___5 ;
  char **tmp___6 ;
  char **tmp___7 ;
  void *tmp___8 ;
  char **tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char **tmp___13 ;
  char **tmp___14 ;
  char **tmp___15 ;
  char **tmp___16 ;

  {
#line 2676
  if (! opts[52]) {
#line 2677
    return;
  }
#line 2678
  if ((v->pm)->node.flags & (1 << 10)) {
    {
#line 2679
    zerr("read-only variable: %s", (v->pm)->node.nam);
#line 2680
    freearray(val);
    }
#line 2681
    return;
  }
#line 2683
  if ((v->pm)->node.flags & (1 << 24)) {
#line 2683
    if (opts[154]) {
      {
#line 2684
      zerr("%s: restricted", (v->pm)->node.nam);
#line 2685
      freearray(val);
      }
#line 2686
      return;
    }
  }
#line 2688
  if (! (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) & (1 | (1 << 4)))) {
    {
#line 2689
    freearray(val);
#line 2690
    zerr("%s: attempt to assign array value to non-array", (v->pm)->node.nam);
    }
#line 2692
    return;
  }
#line 2694
  if (v->flags & 2) {
    {
#line 2695
    zerr("%s: assignment to invalid subscript range", (v->pm)->node.nam);
#line 2696
    freearray(val);
    }
#line 2697
    return;
  }
#line 2700
  if (v->start == 0) {
#line 2700
    if (v->end == -1) {
#line 2701
      if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
        {
#line 2702
        arrhashsetfn(v->pm, val, 0);
        }
      } else {
        {
#line 2704
        (*(((v->pm)->gsu.a)->setfn))(v->pm, val);
        }
      }
    } else {
#line 2700
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 2705
  if (v->start == -1) {
#line 2705
    if (v->end == 0) {
#line 2705
      if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
        {
#line 2707
        arrhashsetfn(v->pm, val, 1);
        }
      } else {
#line 2705
        goto _L___6;
      }
    } else {
#line 2705
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 2708
  if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
    {
#line 2709
    freearray(val);
#line 2710
    zerr("%s: attempt to set slice of associative array", (v->pm)->node.nam);
    }
#line 2712
    return;
  } else {
    {
#line 2714
    tmp = (*(((v->pm)->gsu.a)->getfn))(v->pm);
#line 2714
    old = tmp;
#line 2717
    tmp___0 = arrlen(old);
#line 2717
    pre_assignment_length = tmp___0;
#line 2721
    q = old;
    }
#line 2723
    if (v->flags & 1) {
#line 2723
      if (! opts[95]) {
#line 2724
        if (v->start > 0) {
#line 2725
          (v->start) --;
        }
#line 2726
        (v->end) --;
      }
    }
#line 2728
    if (v->start < 0) {
#line 2729
      v->start += pre_assignment_length;
#line 2730
      if (v->start < 0) {
#line 2731
        v->start = 0;
      }
    }
#line 2733
    if (v->end < 0) {
#line 2734
      v->end += pre_assignment_length + 1;
#line 2735
      if (v->end < 0) {
#line 2736
        v->end = 0;
      }
    }
#line 2738
    if (v->end < v->start) {
#line 2739
      v->end = v->start;
    }
    {
#line 2741
    tmp___1 = arrlen(val);
#line 2741
    post_assignment_length = v->start + tmp___1;
    }
#line 2742
    if (v->end < pre_assignment_length) {
#line 2747
      post_assignment_length += pre_assignment_length - v->end;
    }
#line 2750
    if (pre_assignment_length == post_assignment_length) {
#line 2750
      if ((unsigned long )((v->pm)->gsu.a)->setfn == (unsigned long )(& arrsetfn)) {
#line 2750
        if (0 == ((v->pm)->node.flags & ((1 << 22) | (1 << 13)))) {
#line 2750
          if ((unsigned long )((void *)0) == (unsigned long )(v->pm)->ename) {
#line 2757
            p = old + v->start;
#line 2758
            r = val;
            {
#line 2758
            while (1) {
              while_continue: /* CIL Label */ ;
#line 2758
              if (! *r) {
#line 2758
                goto while_break;
              }
              {
#line 2760
              zsfree(*p);
#line 2762
              tmp___2 = p;
#line 2762
              p ++;
#line 2762
              tmp___3 = r;
#line 2762
              r ++;
#line 2762
              *tmp___2 = *tmp___3;
              }
            }
            while_break: /* CIL Label */ ;
            }
          } else {
#line 2750
            goto _L___4;
          }
        } else {
#line 2750
          goto _L___4;
        }
      } else {
#line 2750
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 2767
    if (post_assignment_length > pre_assignment_length) {
#line 2767
      if (pre_assignment_length <= v->start) {
#line 2767
        if (pre_assignment_length > 0) {
#line 2767
          if ((unsigned long )((v->pm)->gsu.a)->setfn == (unsigned long )(& arrsetfn)) {
            {
#line 2772
            tmp___4 = zrealloc((void *)old, sizeof(char *) * (unsigned long )(post_assignment_length + 1));
#line 2772
            new = (char **)tmp___4;
#line 2772
            p = new;
#line 2775
            p += pre_assignment_length;
            }
#line 2779
            if (pre_assignment_length < v->start) {
#line 2780
              i = pre_assignment_length;
              {
#line 2780
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 2780
                if (! (i < v->start)) {
#line 2780
                  goto while_break___0;
                }
                {
#line 2781
                tmp___5 = p;
#line 2781
                p ++;
#line 2781
                *tmp___5 = ztrdup("");
#line 2780
                i ++;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
            }
#line 2785
            r = val;
            {
#line 2785
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2785
              if (! *r) {
#line 2785
                goto while_break___1;
              }
#line 2787
              tmp___6 = p;
#line 2787
              p ++;
#line 2787
              tmp___7 = r;
#line 2787
              r ++;
#line 2787
              *tmp___6 = *tmp___7;
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 2793
            *p = (char *)((void *)0);
#line 2795
            (v->pm)->u.arr = (char **)((void *)0);
#line 2796
            (*(((v->pm)->gsu.a)->setfn))(v->pm, new);
            }
          } else {
#line 2767
            goto _L___1;
          }
        } else {
#line 2767
          goto _L___1;
        }
      } else {
#line 2767
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 2798
      tmp___8 = zalloc(sizeof(char *) * (unsigned long )(post_assignment_length + 1));
#line 2798
      new = (char **)tmp___8;
#line 2798
      p = new;
#line 2800
      i = 0;
      }
      {
#line 2800
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2800
        if (! (i < v->start)) {
#line 2800
          goto while_break___2;
        }
#line 2801
        tmp___9 = p;
#line 2801
        p ++;
#line 2801
        if (i < pre_assignment_length) {
          {
#line 2801
          tmp___10 = q;
#line 2801
          q ++;
#line 2801
          tmp___11 = ztrdup((char const   *)*tmp___10);
#line 2801
          *tmp___9 = tmp___11;
          }
        } else {
          {
#line 2801
          tmp___12 = ztrdup("");
#line 2801
          *tmp___9 = tmp___12;
          }
        }
#line 2800
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2802
      r = val;
      {
#line 2802
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2802
        if (! *r) {
#line 2802
          goto while_break___3;
        }
#line 2804
        tmp___13 = p;
#line 2804
        p ++;
#line 2804
        tmp___14 = r;
#line 2804
        r ++;
#line 2804
        *tmp___13 = *tmp___14;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2806
      if (v->end < pre_assignment_length) {
#line 2807
        q = old + v->end;
        {
#line 2807
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2807
          if (! *q) {
#line 2807
            goto while_break___4;
          }
          {
#line 2808
          tmp___15 = p;
#line 2808
          p ++;
#line 2808
          tmp___16 = q;
#line 2808
          q ++;
#line 2808
          *tmp___15 = ztrdup((char const   *)*tmp___16);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 2809
      *p = (char *)((void *)0);
#line 2811
      (*(((v->pm)->gsu.a)->setfn))(v->pm, new);
      }
    }
    {
#line 2820
    free((void *)val);
    }
  }
#line 2822
  return;
}
}
#line 2827 "/tmp/zsh-5.4.2/Src/params.c"
zlong getiparam(char *s ) 
{ 
  struct value vbuf ;
  Value v ;
  zlong tmp ;

  {
  {
#line 2833
  v = getvalue(& vbuf, & s, 1);
  }
#line 2833
  if (! v) {
#line 2834
    return ((zlong )0);
  }
  {
#line 2835
  tmp = getintvalue(v);
  }
#line 2835
  return (tmp);
}
}
#line 2841 "/tmp/zsh-5.4.2/Src/params.c"
mnumber getnparam(char *s ) 
{ 
  struct value vbuf ;
  Value v ;
  mnumber mn ;
  mnumber tmp ;

  {
  {
#line 2847
  v = getvalue(& vbuf, & s, 1);
  }
#line 2847
  if (! v) {
#line 2849
    mn.type = 1;
#line 2850
    mn.u.l = (zlong )0;
#line 2851
    return (mn);
  }
  {
#line 2853
  tmp = getnumvalue(v);
  }
#line 2853
  return (tmp);
}
}
#line 2859 "/tmp/zsh-5.4.2/Src/params.c"
char *getsparam(char *s ) 
{ 
  struct value vbuf ;
  Value v ;
  char *tmp ;

  {
  {
#line 2865
  v = getvalue(& vbuf, & s, 0);
  }
#line 2865
  if (! v) {
#line 2866
    return ((char *)((void *)0));
  }
  {
#line 2867
  tmp = getstrvalue(v);
  }
#line 2867
  return (tmp);
}
}
#line 2871 "/tmp/zsh-5.4.2/Src/params.c"
char *getsparam_u(char *s ) 
{ 
  char *tmp ;

  {
  {
#line 2874
  s = getsparam(s);
  }
#line 2874
  if (s) {
    {
#line 2875
    tmp = unmetafy(s, (int *)((void *)0));
    }
#line 2875
    return (tmp);
  }
#line 2876
  return (s);
}
}
#line 2882 "/tmp/zsh-5.4.2/Src/params.c"
char **getaparam(char *s ) 
{ 
  struct value vbuf ;
  Value v ;
  char **tmp ;

  {
#line 2888
  if (! ((int )typtab[(unsigned char )*s] & 1)) {
    {
#line 2888
    v = getvalue(& vbuf, & s, 0);
    }
#line 2888
    if (v) {
#line 2888
      if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
        {
#line 2890
        tmp = (*(((v->pm)->gsu.a)->getfn))(v->pm);
        }
#line 2890
        return (tmp);
      }
    }
  }
#line 2891
  return ((char **)((void *)0));
}
}
#line 2897 "/tmp/zsh-5.4.2/Src/params.c"
char **gethparam(char *s ) 
{ 
  struct value vbuf ;
  Value v ;
  HashTable tmp ;
  char **tmp___0 ;

  {
#line 2903
  if (! ((int )typtab[(unsigned char )*s] & 1)) {
    {
#line 2903
    v = getvalue(& vbuf, & s, 0);
    }
#line 2903
    if (v) {
#line 2903
      if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
        {
#line 2905
        tmp = (*(((v->pm)->gsu.h)->getfn))(v->pm);
#line 2905
        tmp___0 = paramvalarr(tmp, 1);
        }
#line 2905
        return (tmp___0);
      }
    }
  }
#line 2906
  return ((char **)((void *)0));
}
}
#line 2912 "/tmp/zsh-5.4.2/Src/params.c"
char **gethkparam(char *s ) 
{ 
  struct value vbuf ;
  Value v ;
  HashTable tmp ;
  char **tmp___0 ;

  {
#line 2918
  if (! ((int )typtab[(unsigned char )*s] & 1)) {
    {
#line 2918
    v = getvalue(& vbuf, & s, 0);
    }
#line 2918
    if (v) {
#line 2918
      if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
        {
#line 2920
        tmp = (*(((v->pm)->gsu.h)->getfn))(v->pm);
#line 2920
        tmp___0 = paramvalarr(tmp, 1 << 1);
        }
#line 2920
        return (tmp___0);
      }
    }
  }
#line 2921
  return ((char **)((void *)0));
}
}
#line 2940 "/tmp/zsh-5.4.2/Src/params.c"
static void check_warn_pm(Param pm , char const   *pmtype , int created , int may_warn_about_nested_vars ) 
{ 
  Funcstack i ;
  char *msg ;

  {
#line 2946
  if (! may_warn_about_nested_vars) {
#line 2946
    if (! created) {
#line 2947
      return;
    }
  }
#line 2949
  if (created) {
#line 2949
    if (opts[175]) {
#line 2950
      if (locallevel <= forklevel) {
#line 2951
        return;
      } else
#line 2950
      if (pm->level != 0) {
#line 2951
        return;
      }
    } else {
#line 2949
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2952
  if (! created) {
#line 2952
    if (opts[176]) {
#line 2953
      if (pm->level >= locallevel) {
#line 2954
        return;
      }
    } else {
#line 2956
      return;
    }
  } else {
#line 2956
    return;
  }
#line 2958
  if (pm->node.flags & (1 << 22)) {
#line 2959
    return;
  }
#line 2961
  i = funcstack;
  {
#line 2961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2961
    if (! i) {
#line 2961
      goto while_break;
    }
#line 2962
    if (i->tp == 1) {
#line 2965
      if (created) {
#line 2965
        msg = (char *)"%s parameter %s created globally in function %s";
      } else {
#line 2965
        msg = (char *)"%s parameter %s set in enclosing scope in function %s";
      }
      {
#line 2968
      zwarn((char const   *)msg, pmtype, pm->node.nam, i->name);
      }
#line 2969
      goto while_break;
    }
#line 2961
    i = i->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 2972
  return;
}
}
#line 2975 "/tmp/zsh-5.4.2/Src/params.c"
Param assignsparam(char *s , char *val , int flags ) 
{ 
  struct value vbuf ;
  Value v ;
  char *t ;
  char *ss ;
  char *copy ;
  char *var ;
  size_t lvar ;
  mnumber lhs ;
  mnumber rhs ;
  int sstart ;
  int created ;
  int tmp ;
  sigset_t oset ;
  sigset_t oset___0 ;
  sigset_t oset___1 ;
  char **tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  sigset_t oset___2 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  sigset_t oset___3 ;

  {
  {
#line 2980
  t = s;
#line 2984
  created = 0;
#line 2986
  tmp = isident(s);
  }
#line 2986
  if (! tmp) {
    {
#line 2987
    zerr("not an identifier: %s", s);
#line 2988
    zsfree(val);
#line 2989
    errflag |= 1;
    }
#line 2990
    return ((Param )((void *)0));
  }
  {
#line 2992
  queueing_enabled ++;
#line 2993
  ss = strchr((char const   *)s, '[');
  }
#line 2993
  if (ss) {
    {
#line 2994
    *ss = (char )'\000';
#line 2995
    v = getvalue(& vbuf, & s, 1);
    }
#line 2995
    if (v) {
#line 2999
      if ((v->pm)->node.flags & (1 << 10)) {
        {
#line 3000
        zerr("read-only variable: %s", (v->pm)->node.nam);
#line 3001
        *ss = (char )'[';
#line 3002
        zsfree(val);
        }
        {
#line 3003
        while (1) {
          while_continue: /* CIL Label */ ;
#line 3003
          queueing_enabled --;
#line 3003
          if (! queueing_enabled) {
            {
#line 3003
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 3003
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 3003
                if (! (queue_front != queue_rear)) {
#line 3003
                  goto while_break___1;
                }
                {
#line 3003
                queue_front = (queue_front + 1) % 128;
#line 3003
                oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3003
                zhandler(signal_queue[queue_front]);
#line 3003
                signal_setmask(oset);
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 3003
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 3003
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 3004
        return ((Param )((void *)0));
      }
#line 3010
      flags &= -7;
    } else {
      {
#line 2996
      createparam(t, 1);
#line 2997
      created = 1;
      }
    }
#line 3012
    *ss = (char )'[';
#line 3013
    v = (Value )((void *)0);
  } else {
    {
#line 3015
    v = getvalue(& vbuf, & s, 1);
    }
#line 3015
    if (v) {
#line 3018
      if ((v->pm)->node.flags & 1) {
#line 3018
        if (! (flags & 1)) {
#line 3018
          goto _L;
        } else {
#line 3018
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 3018
      if ((v->pm)->node.flags & (1 << 4)) {
        _L: /* CIL Label */ 
#line 3018
        if (! ((v->pm)->node.flags & ((1 << 22) | (1 << 16)))) {
#line 3018
          if (! opts[95]) {
            {
#line 3022
            unsetparam(t);
#line 3023
            createparam(t, 0);
#line 3025
            v = (Value )((void *)0);
            }
          }
        }
      }
    } else {
      {
#line 3016
      createparam(t, 0);
#line 3017
      created = 1;
      }
    }
  }
#line 3028
  if (! v) {
    {
#line 3028
    v = getvalue(& vbuf, & t, 1);
    }
#line 3028
    if (! v) {
      {
#line 3029
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3029
        queueing_enabled --;
#line 3029
        if (! queueing_enabled) {
          {
#line 3029
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 3029
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 3029
              if (! (queue_front != queue_rear)) {
#line 3029
                goto while_break___4;
              }
              {
#line 3029
              queue_front = (queue_front + 1) % 128;
#line 3029
              oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 3029
              zhandler(signal_queue[queue_front]);
#line 3029
              signal_setmask(oset___0);
              }
            }
            while_break___4: /* CIL Label */ ;
            }
#line 3029
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 3029
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 3030
      zsfree(val);
      }
#line 3032
      return ((Param )((void *)0));
    }
  }
#line 3034
  if (flags & 6) {
    {
#line 3035
    check_warn_pm(v->pm, "scalar", created, 1);
    }
  }
#line 3036
  if (flags & 1) {
#line 3037
    if (v->start == 0) {
#line 3037
      if (v->end == -1) {
        {
#line 3039
        if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 3039
          goto case_0;
        }
#line 3044
        if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 3044
          goto case_exp;
        }
#line 3044
        if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 3044
          goto case_exp;
        }
#line 3044
        if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 3044
          goto case_exp;
        }
#line 3062
        if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 3062
          goto case_1;
        }
#line 3038
        goto switch_break;
        case_0: /* CIL Label */ 
#line 3040
        v->start = 2147483647;
#line 3041
        goto switch_break;
        case_exp: /* CIL Label */ 
        case_exp___0: /* CIL Label */ 
        case_exp___1: /* CIL Label */ 
        {
#line 3045
        rhs = matheval(val);
#line 3046
        lhs = getnumvalue(v);
        }
#line 3047
        if (lhs.type == 2) {
#line 3048
          if (rhs.type == 2) {
#line 3049
            lhs.u.d += rhs.u.d;
          } else {
#line 3051
            lhs.u.d += (double )rhs.u.l;
          }
        } else
#line 3053
        if (rhs.type == 1) {
#line 3054
          lhs.u.l += rhs.u.l;
        } else {
#line 3056
          lhs.u.l += (zlong )rhs.u.d;
        }
        {
#line 3058
        setnumvalue(v, lhs);
        }
        {
#line 3059
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 3059
          queueing_enabled --;
#line 3059
          if (! queueing_enabled) {
            {
#line 3059
            while (1) {
              while_continue___6: /* CIL Label */ ;
              {
#line 3059
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 3059
                if (! (queue_front != queue_rear)) {
#line 3059
                  goto while_break___7;
                }
                {
#line 3059
                queue_front = (queue_front + 1) % 128;
#line 3059
                oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 3059
                zhandler(signal_queue[queue_front]);
#line 3059
                signal_setmask(oset___1);
                }
              }
              while_break___7: /* CIL Label */ ;
              }
#line 3059
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
#line 3059
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 3060
        zsfree(val);
        }
#line 3061
        return (v->pm);
        case_1: /* CIL Label */ 
#line 3063
        if (! opts[95]) {
          {
#line 3064
          tmp___0 = (*(((v->pm)->gsu.a)->getfn))(v->pm);
#line 3064
          v->start = arrlen(tmp___0);
#line 3065
          v->end = v->start + 1;
          }
        } else {
#line 3068
          v->end = 1;
#line 3069
          goto kshappend;
        }
#line 3071
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 3037
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 3075
      if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 3075
        goto case_0___0;
      }
#line 3084
      if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 3084
        goto case_exp___2;
      }
#line 3084
      if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 3084
        goto case_exp___2;
      }
#line 3084
      if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 3084
        goto case_exp___2;
      }
#line 3089
      if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 3089
        goto kshappend;
      }
#line 3074
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 3076
      if (v->end > 0) {
#line 3077
        v->start = v->end;
      } else {
        {
#line 3079
        tmp___2 = (*(((v->pm)->gsu.s)->getfn))(v->pm);
#line 3079
        tmp___3 = strlen((char const   *)tmp___2);
#line 3079
        tmp___1 = (int )((tmp___3 + (size_t )v->end) + 1UL);
#line 3079
        v->end = tmp___1;
#line 3079
        v->start = tmp___1;
        }
      }
#line 3081
      goto switch_break___0;
      case_exp___2: /* CIL Label */ 
      case_exp___3: /* CIL Label */ 
      case_exp___4: /* CIL Label */ 
      {
#line 3085
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 3085
        queueing_enabled --;
#line 3085
        if (! queueing_enabled) {
          {
#line 3085
          while (1) {
            while_continue___9: /* CIL Label */ ;
            {
#line 3085
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 3085
              if (! (queue_front != queue_rear)) {
#line 3085
                goto while_break___10;
              }
              {
#line 3085
              queue_front = (queue_front + 1) % 128;
#line 3085
              oset___2 = signal_setmask(signal_mask_queue[queue_front]);
#line 3085
              zhandler(signal_queue[queue_front]);
#line 3085
              signal_setmask(oset___2);
              }
            }
            while_break___10: /* CIL Label */ ;
            }
#line 3085
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
#line 3085
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 3086
      zerr("attempt to add to slice of a numeric variable");
#line 3087
      zsfree(val);
      }
#line 3088
      return ((Param )((void *)0));
      kshappend: 
      case_1___0: /* CIL Label */ 
#line 3092
      if (v->end > 0) {
#line 3092
        sstart = v->end - 1;
      } else {
#line 3092
        sstart = v->end;
      }
      {
#line 3092
      v->start = sstart;
#line 3093
      v->isarr = 0;
#line 3094
      var = getstrvalue(v);
#line 3095
      v->start = sstart;
#line 3096
      copy = val;
#line 3097
      lvar = strlen((char const   *)var);
#line 3098
      tmp___4 = strlen((char const   *)val);
#line 3098
      tmp___5 = zalloc((lvar + tmp___4) + 1UL);
#line 3098
      val = (char *)tmp___5;
#line 3099
      strcpy((char */* __restrict  */)val, (char const   */* __restrict  */)var);
#line 3100
      strcpy((char */* __restrict  */)(val + lvar), (char const   */* __restrict  */)copy);
#line 3101
      zsfree(copy);
      }
#line 3102
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 3107
  assignstrvalue(v, val, flags);
  }
  {
#line 3108
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 3108
    queueing_enabled --;
#line 3108
    if (! queueing_enabled) {
      {
#line 3108
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 3108
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 3108
          if (! (queue_front != queue_rear)) {
#line 3108
            goto while_break___13;
          }
          {
#line 3108
          queue_front = (queue_front + 1) % 128;
#line 3108
          oset___3 = signal_setmask(signal_mask_queue[queue_front]);
#line 3108
          zhandler(signal_queue[queue_front]);
#line 3108
          signal_setmask(oset___3);
          }
        }
        while_break___13: /* CIL Label */ ;
        }
#line 3108
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 3108
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 3109
  return (v->pm);
}
}
#line 3113 "/tmp/zsh-5.4.2/Src/params.c"
Param setsparam(char *s , char *val ) 
{ 
  Param tmp ;

  {
  {
#line 3116
  tmp = assignsparam(s, val, 6);
  }
#line 3116
  return (tmp);
}
}
#line 3120 "/tmp/zsh-5.4.2/Src/params.c"
Param assignaparam(char *s , char **val , int flags ) 
{ 
  struct value vbuf ;
  Value v ;
  char *t ;
  char *ss ;
  int created ;
  int may_warn_about_nested_vars ;
  int tmp ;
  sigset_t oset ;
  int uniq ;
  char **new ;
  int lv ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  sigset_t oset___0 ;
  char **tmp___3 ;
  int tmp___4 ;
  char **tmp___5 ;
  int tmp___6 ;
  sigset_t oset___1 ;

  {
  {
#line 3125
  t = s;
#line 3127
  created = 0;
#line 3128
  may_warn_about_nested_vars = 1;
#line 3130
  tmp = isident(s);
  }
#line 3130
  if (! tmp) {
    {
#line 3131
    zerr("not an identifier: %s", s);
#line 3132
    freearray(val);
#line 3133
    errflag |= 1;
    }
#line 3134
    return ((Param )((void *)0));
  }
  {
#line 3136
  queueing_enabled ++;
#line 3137
  ss = strchr((char const   *)s, '[');
  }
#line 3137
  if (ss) {
    {
#line 3138
    *ss = (char )'\000';
#line 3139
    v = getvalue(& vbuf, & s, 1);
    }
#line 3139
    if (v) {
#line 3143
      may_warn_about_nested_vars = 0;
    } else {
      {
#line 3140
      createparam(t, 1);
#line 3141
      created = 1;
      }
    }
#line 3145
    *ss = (char )'[';
#line 3146
    if (v) {
#line 3146
      if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
        {
#line 3147
        while (1) {
          while_continue: /* CIL Label */ ;
#line 3147
          queueing_enabled --;
#line 3147
          if (! queueing_enabled) {
            {
#line 3147
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 3147
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 3147
                if (! (queue_front != queue_rear)) {
#line 3147
                  goto while_break___1;
                }
                {
#line 3147
                queue_front = (queue_front + 1) % 128;
#line 3147
                oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3147
                zhandler(signal_queue[queue_front]);
#line 3147
                signal_setmask(oset);
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 3147
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 3147
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 3148
        zerr("%s: attempt to set slice of associative array", (v->pm)->node.nam);
#line 3150
        freearray(val);
#line 3151
        errflag |= 1;
        }
#line 3152
        return ((Param )((void *)0));
      }
    }
#line 3154
    v = (Value )((void *)0);
  } else {
    {
#line 3156
    v = fetchvalue(& vbuf, & s, 1, 1 << 6);
    }
#line 3156
    if (v) {
#line 3159
      if (! (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) & (1 | (1 << 4)))) {
#line 3159
        if (! ((v->pm)->node.flags & ((1 << 22) | (1 << 16)))) {
#line 3161
          uniq = (v->pm)->node.flags & (1 << 13);
#line 3162
          if (flags & 1) {
            {
#line 3165
            tmp___0 = arrlen(val);
#line 3165
            lv = tmp___0;
#line 3167
            tmp___1 = zalloc(sizeof(char *) * (unsigned long )(lv + 2));
#line 3167
            new = (char **)tmp___1;
#line 3168
            tmp___2 = getstrvalue(v);
#line 3168
            *new = ztrdup((char const   *)tmp___2);
#line 3169
            memcpy((void */* __restrict  */)(new + 1), (void const   */* __restrict  */)val,
                   sizeof(char *) * (unsigned long )(lv + 1));
#line 3170
            free((void *)val);
#line 3171
            val = new;
            }
          }
          {
#line 3173
          unsetparam(t);
#line 3174
          createparam(t, 1 | uniq);
#line 3175
          v = (Value )((void *)0);
          }
        }
      }
    } else {
      {
#line 3157
      createparam(t, 1);
#line 3158
      created = 1;
      }
    }
  }
#line 3178
  if (! v) {
    {
#line 3179
    v = fetchvalue(& vbuf, & t, 1, 1 << 6);
    }
#line 3179
    if (! v) {
      {
#line 3180
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3180
        queueing_enabled --;
#line 3180
        if (! queueing_enabled) {
          {
#line 3180
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 3180
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 3180
              if (! (queue_front != queue_rear)) {
#line 3180
                goto while_break___4;
              }
              {
#line 3180
              queue_front = (queue_front + 1) % 128;
#line 3180
              oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 3180
              zhandler(signal_queue[queue_front]);
#line 3180
              signal_setmask(oset___0);
              }
            }
            while_break___4: /* CIL Label */ ;
            }
#line 3180
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 3180
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 3181
      freearray(val);
      }
#line 3183
      return ((Param )((void *)0));
    }
  }
#line 3186
  if (flags & 6) {
    {
#line 3187
    check_warn_pm(v->pm, "array", created, may_warn_about_nested_vars);
    }
  }
#line 3188
  if (flags & 1) {
#line 3189
    if (v->start == 0) {
#line 3189
      if (v->end == -1) {
#line 3190
        if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) & 1) {
          {
#line 3191
          tmp___3 = (*(((v->pm)->gsu.a)->getfn))(v->pm);
#line 3191
          v->start = arrlen(tmp___3);
#line 3192
          v->end = v->start + 1;
          }
        } else
#line 3193
        if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) & (1 << 4)) {
#line 3194
          v->start = -1;
#line 3194
          v->end = 0;
        }
      } else {
#line 3189
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3196
    if (v->end > 0) {
#line 3197
      tmp___4 = v->end;
#line 3197
      (v->end) --;
#line 3197
      v->start = tmp___4;
    } else
#line 3198
    if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) & 1) {
      {
#line 3199
      tmp___5 = (*(((v->pm)->gsu.a)->getfn))(v->pm);
#line 3199
      tmp___6 = arrlen(tmp___5);
#line 3199
      v->end = tmp___6 + v->end;
#line 3200
      v->start = v->end + 1;
      }
    }
  }
  {
#line 3205
  setarrvalue(v, val);
  }
  {
#line 3206
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 3206
    queueing_enabled --;
#line 3206
    if (! queueing_enabled) {
      {
#line 3206
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 3206
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 3206
          if (! (queue_front != queue_rear)) {
#line 3206
            goto while_break___7;
          }
          {
#line 3206
          queue_front = (queue_front + 1) % 128;
#line 3206
          oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 3206
          zhandler(signal_queue[queue_front]);
#line 3206
          signal_setmask(oset___1);
          }
        }
        while_break___7: /* CIL Label */ ;
        }
#line 3206
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 3206
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 3207
  return (v->pm);
}
}
#line 3212 "/tmp/zsh-5.4.2/Src/params.c"
Param setaparam(char *s , char **aval ) 
{ 
  Param tmp ;

  {
  {
#line 3215
  tmp = assignaparam(s, aval, 6);
  }
#line 3215
  return (tmp);
}
}
#line 3219 "/tmp/zsh-5.4.2/Src/params.c"
Param sethparam(char *s , char **val ) 
{ 
  struct value vbuf ;
  Value v ;
  char *t ;
  int checkcreate ;
  int tmp ;
  char *tmp___0 ;
  sigset_t oset ;
  sigset_t oset___0 ;
  sigset_t oset___1 ;

  {
  {
#line 3224
  t = s;
#line 3225
  checkcreate = 0;
#line 3227
  tmp = isident(s);
  }
#line 3227
  if (! tmp) {
    {
#line 3228
    zerr("not an identifier: %s", s);
#line 3229
    freearray(val);
#line 3230
    errflag |= 1;
    }
#line 3231
    return ((Param )((void *)0));
  }
  {
#line 3233
  tmp___0 = strchr((char const   *)s, '[');
  }
#line 3233
  if (tmp___0) {
    {
#line 3234
    freearray(val);
#line 3235
    zerr("nested associative arrays not yet supported");
#line 3236
    errflag |= 1;
    }
#line 3237
    return ((Param )((void *)0));
  }
#line 3239
  if (! opts[52]) {
#line 3240
    return ((Param )((void *)0));
  }
  {
#line 3241
  queueing_enabled ++;
#line 3242
  v = fetchvalue(& vbuf, & s, 1, 1 << 6);
  }
#line 3242
  if (v) {
#line 3245
    if (! (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) & (1 << 4))) {
#line 3246
      if (! ((v->pm)->node.flags & (1 << 22))) {
        {
#line 3247
        unsetparam(t);
#line 3249
        createparam(t, 1 << 4);
#line 3250
        v = (Value )((void *)0);
        }
      } else {
        {
#line 3252
        zerr("%s: can\'t change type of a special parameter", t);
        }
        {
#line 3253
        while (1) {
          while_continue: /* CIL Label */ ;
#line 3253
          queueing_enabled --;
#line 3253
          if (! queueing_enabled) {
            {
#line 3253
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 3253
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 3253
                if (! (queue_front != queue_rear)) {
#line 3253
                  goto while_break___1;
                }
                {
#line 3253
                queue_front = (queue_front + 1) % 128;
#line 3253
                oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3253
                zhandler(signal_queue[queue_front]);
#line 3253
                signal_setmask(oset);
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 3253
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 3253
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 3254
        return ((Param )((void *)0));
      }
    }
  } else {
    {
#line 3243
    createparam(t, 1 << 4);
#line 3244
    checkcreate = 1;
    }
  }
#line 3257
  if (! v) {
    {
#line 3258
    v = fetchvalue(& vbuf, & t, 1, 1 << 6);
    }
#line 3258
    if (! v) {
      {
#line 3259
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3259
        queueing_enabled --;
#line 3259
        if (! queueing_enabled) {
          {
#line 3259
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 3259
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 3259
              if (! (queue_front != queue_rear)) {
#line 3259
                goto while_break___4;
              }
              {
#line 3259
              queue_front = (queue_front + 1) % 128;
#line 3259
              oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 3259
              zhandler(signal_queue[queue_front]);
#line 3259
              signal_setmask(oset___0);
              }
            }
            while_break___4: /* CIL Label */ ;
            }
#line 3259
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 3259
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3261
      return ((Param )((void *)0));
    }
  }
  {
#line 3263
  check_warn_pm(v->pm, "associative array", checkcreate, 1);
#line 3264
  setarrvalue(v, val);
  }
  {
#line 3265
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 3265
    queueing_enabled --;
#line 3265
    if (! queueing_enabled) {
      {
#line 3265
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 3265
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 3265
          if (! (queue_front != queue_rear)) {
#line 3265
            goto while_break___7;
          }
          {
#line 3265
          queue_front = (queue_front + 1) % 128;
#line 3265
          oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 3265
          zhandler(signal_queue[queue_front]);
#line 3265
          signal_setmask(oset___1);
          }
        }
        while_break___7: /* CIL Label */ ;
        }
#line 3265
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 3265
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 3266
  return (v->pm);
}
}
#line 3276 "/tmp/zsh-5.4.2/Src/params.c"
Param assignnparam(char *s , mnumber val , int flags ) 
{ 
  struct value vbuf ;
  Value v ;
  char *t ;
  char *ss ;
  Param pm ;
  int was_unset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  HashNode tmp___3 ;
  sigset_t oset ;
  sigset_t oset___0 ;

  {
  {
#line 3281
  t = s;
#line 3283
  was_unset = 0;
#line 3285
  tmp = isident(s);
  }
#line 3285
  if (! tmp) {
    {
#line 3286
    zerr("not an identifier: %s", s);
#line 3287
    errflag |= 1;
    }
#line 3288
    return ((Param )((void *)0));
  }
#line 3290
  if (! opts[52]) {
#line 3291
    return ((Param )((void *)0));
  }
  {
#line 3292
  queueing_enabled ++;
#line 3293
  ss = strchr((char const   *)s, '[');
#line 3294
  v = getvalue(& vbuf, & s, 1);
  }
#line 3295
  if (v) {
#line 3295
    if ((v->pm)->node.flags & (1 | (1 << 4))) {
#line 3295
      if (! ((v->pm)->node.flags & ((1 << 22) | (1 << 16)))) {
#line 3295
        if (! opts[95]) {
#line 3295
          if (! ss) {
            {
#line 3302
            unsetparam_pm(v->pm, 0, 1);
#line 3303
            was_unset = 1;
#line 3304
            s = t;
#line 3305
            v = (Value )((void *)0);
            }
          }
        }
      }
    }
  }
#line 3307
  if (! v) {
    {
#line 3309
    ss = strchr((char const   *)s, '[');
    }
#line 3310
    if (ss) {
#line 3311
      *ss = (char )'\000';
    }
#line 3312
    if (ss) {
#line 3312
      tmp___2 = 1;
    } else {
#line 3312
      if (opts[133]) {
#line 3312
        tmp___1 = 0;
      } else {
#line 3312
        if (val.type & 1) {
#line 3312
          tmp___0 = 1 << 1;
        } else {
#line 3312
          tmp___0 = 1 << 3;
        }
#line 3312
        tmp___1 = tmp___0;
      }
#line 3312
      tmp___2 = tmp___1;
    }
    {
#line 3312
    pm = createparam(t, tmp___2);
    }
#line 3315
    if (! pm) {
      {
#line 3316
      tmp___3 = (*(paramtab->getnode))(paramtab, (char const   *)t);
#line 3316
      pm = (Param )tmp___3;
      }
    }
#line 3318
    if (ss) {
#line 3319
      *ss = (char )'[';
    } else
#line 3320
    if (val.type & 1) {
#line 3321
      pm->base = outputradix;
    }
    {
#line 3323
    v = getvalue(& vbuf, & t, 1);
    }
#line 3323
    if (! v) {
      {
#line 3326
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3326
        queueing_enabled --;
#line 3326
        if (! queueing_enabled) {
          {
#line 3326
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 3326
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 3326
              if (! (queue_front != queue_rear)) {
#line 3326
                goto while_break___1;
              }
              {
#line 3326
              queue_front = (queue_front + 1) % 128;
#line 3326
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3326
              zhandler(signal_queue[queue_front]);
#line 3326
              signal_setmask(oset);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 3326
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 3326
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 3327
      return ((Param )((void *)0));
    }
#line 3329
    if (flags & 6) {
      {
#line 3330
      check_warn_pm(v->pm, "numeric", ! was_unset, 1);
      }
    }
  } else
#line 3332
  if (flags & 6) {
    {
#line 3333
    check_warn_pm(v->pm, "numeric", 0, 1);
    }
  }
  {
#line 3335
  setnumvalue(v, val);
  }
  {
#line 3336
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3336
    queueing_enabled --;
#line 3336
    if (! queueing_enabled) {
      {
#line 3336
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 3336
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 3336
          if (! (queue_front != queue_rear)) {
#line 3336
            goto while_break___4;
          }
          {
#line 3336
          queue_front = (queue_front + 1) % 128;
#line 3336
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 3336
          zhandler(signal_queue[queue_front]);
#line 3336
          signal_setmask(oset___0);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 3336
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 3336
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3337
  return (v->pm);
}
}
#line 3346 "/tmp/zsh-5.4.2/Src/params.c"
Param setnparam(char *s , mnumber val ) 
{ 
  Param tmp ;

  {
  {
#line 3349
  tmp = assignnparam(s, val, 6);
  }
#line 3349
  return (tmp);
}
}
#line 3355 "/tmp/zsh-5.4.2/Src/params.c"
Param assigniparam(char *s , zlong val , int flags ) 
{ 
  mnumber mnval ;
  Param tmp ;

  {
  {
#line 3359
  mnval.type = 1;
#line 3360
  mnval.u.l = val;
#line 3361
  tmp = assignnparam(s, mnval, flags);
  }
#line 3361
  return (tmp);
}
}
#line 3367 "/tmp/zsh-5.4.2/Src/params.c"
Param setiparam(char *s , zlong val ) 
{ 
  mnumber mnval ;
  Param tmp ;

  {
  {
#line 3371
  mnval.type = 1;
#line 3372
  mnval.u.l = val;
#line 3373
  tmp = assignnparam(s, mnval, 6);
  }
#line 3373
  return (tmp);
}
}
#line 3383 "/tmp/zsh-5.4.2/Src/params.c"
Param setiparam_no_convert(char *s , zlong val ) 
{ 
  char buf___7[(int )(sizeof(zlong ) * 8UL + 4UL)] ;
  char *tmp ;
  Param tmp___0 ;

  {
  {
#line 3391
  convbase(buf___7, val, 10);
#line 3392
  tmp = ztrdup((char const   *)(buf___7));
#line 3392
  tmp___0 = assignsparam(s, tmp, 6);
  }
#line 3392
  return (tmp___0);
}
}
#line 3398 "/tmp/zsh-5.4.2/Src/params.c"
void unsetparam(char *s ) 
{ 
  Param pm ;
  HashNode tmp ;
  HashNode tmp___0 ;
  HashNode tmp___1 ;
  sigset_t oset ;

  {
#line 3403
  queueing_enabled ++;
#line 3404
  if ((unsigned long )paramtab == (unsigned long )realparamtab) {
    {
#line 3404
    tmp = (*(paramtab->getnode2))(paramtab, (char const   *)s);
#line 3404
    tmp___1 = tmp;
    }
  } else {
    {
#line 3404
    tmp___0 = (*(paramtab->getnode))(paramtab, (char const   *)s);
#line 3404
    tmp___1 = tmp___0;
    }
  }
#line 3404
  pm = (Param )tmp___1;
#line 3404
  if (pm) {
    {
#line 3408
    unsetparam_pm(pm, 0, 1);
    }
  }
  {
#line 3409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3409
    queueing_enabled --;
#line 3409
    if (! queueing_enabled) {
      {
#line 3409
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 3409
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3409
          if (! (queue_front != queue_rear)) {
#line 3409
            goto while_break___1;
          }
          {
#line 3409
          queue_front = (queue_front + 1) % 128;
#line 3409
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3409
          zhandler(signal_queue[queue_front]);
#line 3409
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3409
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 3409
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3410
  return;
}
}
#line 3419 "/tmp/zsh-5.4.2/Src/params.c"
int unsetparam_pm(Param pm , int altflag , int exp ) 
{ 
  Param oldpm ;
  Param altpm ;
  char *altremove ;
  HashNode tmp ;

  {
#line 3425
  if (pm->node.flags & (1 << 10)) {
#line 3425
    if (pm->level <= locallevel) {
      {
#line 3426
      zerr("read-only variable: %s", pm->node.nam);
      }
#line 3427
      return (1);
    }
  }
#line 3429
  if (pm->node.flags & (1 << 24)) {
#line 3429
    if (opts[154]) {
      {
#line 3430
      zerr("%s: restricted", pm->node.nam);
      }
#line 3431
      return (1);
    }
  }
#line 3434
  if (pm->ename) {
#line 3434
    if (! altflag) {
      {
#line 3435
      altremove = ztrdup((char const   *)pm->ename);
      }
    } else {
#line 3437
      altremove = (char *)((void *)0);
    }
  } else {
#line 3437
    altremove = (char *)((void *)0);
  }
#line 3439
  if (! (pm->node.flags & (1 << 25))) {
    {
#line 3440
    (*((pm->gsu.s)->unsetfn))(pm, exp);
    }
  }
#line 3441
  if (pm->env) {
    {
#line 3442
    delenv(pm);
    }
  }
#line 3445
  if (altremove) {
    {
#line 3446
    tmp = (*(paramtab->getnode))(paramtab, (char const   *)altremove);
#line 3446
    altpm = (Param )tmp;
#line 3448
    oldpm = (Param )((void *)0);
    }
    {
#line 3449
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3449
      if (altpm) {
#line 3449
        if (! (altpm->level > pm->level)) {
#line 3449
          goto while_break;
        }
      } else {
#line 3449
        goto while_break;
      }
#line 3451
      oldpm = altpm;
#line 3452
      altpm = altpm->old;
    }
    while_break: /* CIL Label */ ;
    }
#line 3454
    if (altpm) {
#line 3455
      if (oldpm) {
#line 3455
        if (! altpm->level) {
#line 3456
          oldpm->old = (Param )((void *)0);
#line 3458
          altpm->level = 1;
        }
      }
      {
#line 3460
      unsetparam_pm(altpm, 1, exp);
      }
    }
    {
#line 3463
    zsfree(altremove);
    }
  }
#line 3478
  if (pm->level) {
#line 3478
    if (locallevel >= pm->level) {
#line 3480
      return (0);
    } else {
#line 3478
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3478
  if ((pm->node.flags & ((1 << 22) | (1 << 26))) == 1 << 22) {
#line 3480
    return (0);
  }
  {
#line 3483
  (*(paramtab->removenode))(paramtab, (char const   *)pm->node.nam);
  }
#line 3485
  if (pm->old) {
    {
#line 3486
    oldpm = pm->old;
#line 3487
    (*(paramtab->addnode))(paramtab, oldpm->node.nam, (void *)oldpm);
    }
#line 3488
    if ((oldpm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 3488
      if (! (pm->node.flags & (1 << 29))) {
#line 3488
        if (oldpm->node.flags & (1 << 30)) {
#line 3488
          if ((unsigned long )oldpm->gsu.s == (unsigned long )(& stdscalar_gsu)) {
            {
#line 3492
            adduserdir(oldpm->node.nam, oldpm->u.str, 0, 0);
            }
          }
        }
      }
    }
#line 3493
    if (oldpm->node.flags & (1 << 12)) {
      {
#line 3500
      export_param(oldpm);
      }
    }
  }
  {
#line 3504
  (*(paramtab->freenode))(& pm->node);
  }
#line 3506
  return (0);
}
}
#line 3521 "/tmp/zsh-5.4.2/Src/params.c"
void stdunsetfn(Param pm , int exp  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 3525
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 3525
    goto case_0;
  }
#line 3530
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 3530
    goto case_1;
  }
#line 3535
  if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
#line 3535
    goto case_exp;
  }
#line 3540
  goto switch_default;
  case_0: /* CIL Label */ 
#line 3526
  if ((pm->gsu.s)->setfn) {
    {
#line 3527
    (*((pm->gsu.s)->setfn))(pm, (char *)((void *)0));
    }
  }
#line 3528
  goto switch_break;
  case_1: /* CIL Label */ 
#line 3531
  if ((pm->gsu.a)->setfn) {
    {
#line 3532
    (*((pm->gsu.a)->setfn))(pm, (char **)((void *)0));
    }
  }
#line 3533
  goto switch_break;
  case_exp: /* CIL Label */ 
#line 3536
  if ((pm->gsu.h)->setfn) {
    {
#line 3537
    (*((pm->gsu.h)->setfn))(pm, (HashTable )((void *)0));
    }
  }
#line 3538
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3541
  if (! (pm->node.flags & (1 << 22))) {
#line 3542
    pm->u.str = (char *)((void *)0);
  }
#line 3543
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3545
  if ((pm->node.flags & ((1 << 22) | (1 << 16))) == 1 << 16) {
#line 3546
    if (pm->ename) {
      {
#line 3547
      zsfree(pm->ename);
#line 3548
      pm->ename = (char *)((void *)0);
      }
    }
#line 3550
    pm->node.flags &= ~ (1 << 16);
  }
#line 3552
  pm->node.flags |= 1 << 25;
#line 3553
  return;
}
}
#line 3558 "/tmp/zsh-5.4.2/Src/params.c"
zlong intgetfn(Param pm ) 
{ 


  {
#line 3561
  return (pm->u.val);
}
}
#line 3567 "/tmp/zsh-5.4.2/Src/params.c"
static void intsetfn(Param pm , zlong x ) 
{ 


  {
#line 3570
  pm->u.val = x;
#line 3571
  return;
}
}
#line 3576 "/tmp/zsh-5.4.2/Src/params.c"
static double floatgetfn(Param pm ) 
{ 


  {
#line 3579
  return (pm->u.dval);
}
}
#line 3585 "/tmp/zsh-5.4.2/Src/params.c"
static void floatsetfn(Param pm , double x ) 
{ 


  {
#line 3588
  pm->u.dval = x;
#line 3589
  return;
}
}
#line 3594 "/tmp/zsh-5.4.2/Src/params.c"
char *strgetfn(Param pm ) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
#line 3597
  if (pm->u.str) {
#line 3597
    tmp___0 = pm->u.str;
  } else {
    {
#line 3597
    tmp = hcalloc((size_t )1);
#line 3597
    tmp___0 = (char *)tmp;
    }
  }
#line 3597
  return (tmp___0);
}
}
#line 3603 "/tmp/zsh-5.4.2/Src/params.c"
void strsetfn(Param pm , char *x ) 
{ 


  {
  {
#line 3606
  zsfree(pm->u.str);
#line 3607
  pm->u.str = x;
  }
#line 3608
  if (! (pm->node.flags & (1 << 29))) {
#line 3608
    if (pm->node.flags & (1 << 30)) {
      {
#line 3610
      pm->node.flags |= 1 << 30;
#line 3611
      adduserdir(pm->node.nam, x, 0, 0);
      }
    } else
#line 3608
    if (opts[11]) {
      {
#line 3610
      pm->node.flags |= 1 << 30;
#line 3611
      adduserdir(pm->node.nam, x, 0, 0);
      }
    }
  }
#line 3615
  return;
}
}
#line 3619 "/tmp/zsh-5.4.2/Src/params.c"
static char *nullarray  =    (char *)((void *)0);
#line 3622 "/tmp/zsh-5.4.2/Src/params.c"
char **arrgetfn(Param pm ) 
{ 
  char **tmp ;

  {
#line 3625
  if (pm->u.arr) {
#line 3625
    tmp = pm->u.arr;
  } else {
#line 3625
    tmp = & nullarray;
  }
#line 3625
  return (tmp);
}
}
#line 3631 "/tmp/zsh-5.4.2/Src/params.c"
void arrsetfn(Param pm , char **x ) 
{ 


  {
#line 3634
  if (pm->u.arr) {
#line 3634
    if ((unsigned long )pm->u.arr != (unsigned long )x) {
      {
#line 3635
      freearray(pm->u.arr);
      }
    }
  }
#line 3636
  if (pm->node.flags & (1 << 13)) {
    {
#line 3637
    uniqarray(x);
    }
  }
#line 3638
  pm->u.arr = x;
#line 3640
  if (pm->ename) {
#line 3640
    if (x) {
      {
#line 3641
      arrfixenv(pm->ename, x);
      }
    }
  }
#line 3644
  return;
}
}
#line 3649 "/tmp/zsh-5.4.2/Src/params.c"
HashTable hashgetfn(Param pm ) 
{ 


  {
#line 3652
  return (pm->u.hash);
}
}
#line 3658 "/tmp/zsh-5.4.2/Src/params.c"
void hashsetfn(Param pm , HashTable x ) 
{ 


  {
#line 3661
  if (pm->u.hash) {
#line 3661
    if ((unsigned long )pm->u.hash != (unsigned long )x) {
      {
#line 3662
      deleteparamtable(pm->u.hash);
      }
    }
  }
#line 3663
  pm->u.hash = x;
#line 3664
  return;
}
}
#line 3669 "/tmp/zsh-5.4.2/Src/params.c"
void nullsethashfn(Param pm  __attribute__((__unused__)) , HashTable x ) 
{ 


  {
  {
#line 3672
  deleteparamtable(x);
  }
#line 3673
  return;
}
}
#line 3678 "/tmp/zsh-5.4.2/Src/params.c"
void arrhashsetfn(Param pm , char **val , int augment ) 
{ 
  int alen ;
  int tmp ;
  HashTable opmtab ;
  HashTable ht ;
  char **aptr ;
  Value v ;
  void *tmp___0 ;
  HashNode tmp___1 ;
  char **tmp___2 ;
  char **tmp___3 ;

  {
  {
#line 3684
  tmp = arrlen(val);
#line 3684
  alen = tmp;
#line 3685
  opmtab = paramtab;
#line 3685
  ht = (HashTable )0;
#line 3686
  aptr = val;
#line 3687
  tmp___0 = hcalloc(sizeof(*v));
#line 3687
  v = (Value )tmp___0;
#line 3688
  v->end = -1;
  }
#line 3690
  if (alen % 2) {
    {
#line 3691
    freearray(val);
#line 3692
    zerr("bad set of key/value pairs for associative array");
    }
#line 3693
    return;
  }
#line 3695
  if (augment) {
    {
#line 3696
    paramtab = (*((pm->gsu.h)->getfn))(pm);
#line 3696
    ht = paramtab;
    }
  }
#line 3698
  if (alen) {
#line 3698
    if (! augment) {
      {
#line 3699
      paramtab = newparamtable(17, (char const   *)pm->node.nam);
#line 3699
      ht = paramtab;
      }
    } else
#line 3698
    if (! paramtab) {
      {
#line 3699
      paramtab = newparamtable(17, (char const   *)pm->node.nam);
#line 3699
      ht = paramtab;
      }
    }
  }
  {
#line 3701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3701
    if (! *aptr) {
#line 3701
      goto while_break;
    }
    {
#line 3703
    v->pm = createparam(*aptr, 1 << 25);
    }
#line 3708
    if (! v->pm) {
      {
#line 3709
      tmp___1 = (*(paramtab->getnode))(paramtab, (char const   *)*aptr);
#line 3709
      v->pm = (Param )tmp___1;
      }
    }
    {
#line 3710
    tmp___2 = aptr;
#line 3710
    aptr ++;
#line 3710
    zsfree(*tmp___2);
#line 3712
    tmp___3 = aptr;
#line 3712
    aptr ++;
#line 3712
    setstrvalue(v, *tmp___3);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3714
  paramtab = opmtab;
#line 3715
  (*((pm->gsu.h)->setfn))(pm, ht);
#line 3716
  free((void *)val);
  }
#line 3717
  return;
}
}
#line 3726 "/tmp/zsh-5.4.2/Src/params.c"
void nullstrsetfn(Param pm  __attribute__((__unused__)) , char *x ) 
{ 


  {
  {
#line 3729
  zsfree(x);
  }
#line 3730
  return;
}
}
#line 3733 "/tmp/zsh-5.4.2/Src/params.c"
void nullintsetfn(Param pm  __attribute__((__unused__)) , zlong x  __attribute__((__unused__)) ) 
{ 


  {
#line 3735
  return;
}
}
#line 3738 "/tmp/zsh-5.4.2/Src/params.c"
void nullunsetfn(Param pm  __attribute__((__unused__)) , int exp  __attribute__((__unused__)) ) 
{ 


  {
#line 3740
  return;
}
}
#line 3748 "/tmp/zsh-5.4.2/Src/params.c"
zlong intvargetfn(Param pm ) 
{ 


  {
#line 3751
  return (*(pm->u.valptr));
}
}
#line 3759 "/tmp/zsh-5.4.2/Src/params.c"
void intvarsetfn(Param pm , zlong x ) 
{ 


  {
#line 3762
  *(pm->u.valptr) = x;
#line 3763
  return;
}
}
#line 3770 "/tmp/zsh-5.4.2/Src/params.c"
void zlevarsetfn(Param pm , zlong x ) 
{ 
  zlong *p ;

  {
#line 3773
  p = pm->u.valptr;
#line 3775
  *p = x;
#line 3776
  if ((unsigned long )p == (unsigned long )(& zterm_lines)) {
    {
#line 3777
    adjustwinsize(2 + ((unsigned long )p == (unsigned long )(& zterm_columns)));
    }
  } else
#line 3776
  if ((unsigned long )p == (unsigned long )(& zterm_columns)) {
    {
#line 3777
    adjustwinsize(2 + ((unsigned long )p == (unsigned long )(& zterm_columns)));
    }
  }
#line 3778
  return;
}
}
#line 3783 "/tmp/zsh-5.4.2/Src/params.c"
static void rprompt_indent_unsetfn(Param pm , int exp ) 
{ 


  {
  {
#line 3786
  stdunsetfn(pm, exp);
#line 3787
  rprompt_indent = (zlong )1;
  }
#line 3788
  return;
}
}
#line 3795 "/tmp/zsh-5.4.2/Src/params.c"
void strvarsetfn(Param pm , char *x ) 
{ 
  char **q ;

  {
  {
#line 3798
  q = (char **)pm->u.data;
#line 3800
  zsfree(*q);
#line 3801
  *q = x;
  }
#line 3802
  return;
}
}
#line 3809 "/tmp/zsh-5.4.2/Src/params.c"
char *strvargetfn(Param pm ) 
{ 
  char *s ;
  void *tmp ;

  {
#line 3812
  s = *((char **)pm->u.data);
#line 3814
  if (! s) {
    {
#line 3815
    tmp = hcalloc((size_t )1);
    }
#line 3815
    return ((char *)tmp);
  }
#line 3816
  return (s);
}
}
#line 3825 "/tmp/zsh-5.4.2/Src/params.c"
char **arrvargetfn(Param pm ) 
{ 
  char **arrptr ;
  char **tmp ;

  {
#line 3828
  arrptr = *((char ***)pm->u.data);
#line 3830
  if (arrptr) {
#line 3830
    tmp = arrptr;
  } else {
#line 3830
    tmp = & nullarray;
  }
#line 3830
  return (tmp);
}
}
#line 3840 "/tmp/zsh-5.4.2/Src/params.c"
void arrvarsetfn(Param pm , char **x ) 
{ 
  char ***dptr ;

  {
#line 3843
  dptr = (char ***)pm->u.data;
#line 3845
  if ((unsigned long )*dptr != (unsigned long )x) {
    {
#line 3846
    freearray(*dptr);
    }
  }
#line 3847
  if (pm->node.flags & (1 << 13)) {
    {
#line 3848
    uniqarray(x);
    }
  }
#line 3854
  if (pm->node.flags & (1 << 22)) {
#line 3854
    if (! x) {
      {
#line 3855
      *dptr = mkarray((char *)((void *)0));
      }
    } else {
#line 3857
      *dptr = x;
    }
  } else {
#line 3857
    *dptr = x;
  }
#line 3858
  if (pm->ename) {
#line 3859
    if (x) {
      {
#line 3860
      arrfixenv(pm->ename, x);
      }
    } else
#line 3861
    if ((unsigned long )*dptr == (unsigned long )path) {
#line 3862
      pathchecked = path;
    }
  }
#line 3864
  return;
}
}
#line 3867 "/tmp/zsh-5.4.2/Src/params.c"
char *colonarrgetfn(Param pm ) 
{ 
  char ***dptr ;
  char *tmp ;
  char const   *tmp___0 ;

  {
#line 3870
  dptr = (char ***)pm->u.data;
#line 3871
  if (*dptr) {
    {
#line 3871
    tmp = zjoin(*dptr, ':', 1);
#line 3871
    tmp___0 = (char const   *)tmp;
    }
  } else {
#line 3871
    tmp___0 = "";
  }
#line 3871
  return ((char *)tmp___0);
}
}
#line 3875 "/tmp/zsh-5.4.2/Src/params.c"
void colonarrsetfn(Param pm , char *x ) 
{ 
  char ***dptr ;

  {
#line 3878
  dptr = (char ***)pm->u.data;
#line 3883
  if (*dptr) {
    {
#line 3884
    freearray(*dptr);
    }
  }
#line 3885
  if (x) {
    {
#line 3886
    *dptr = colonsplit(x, pm->node.flags & (1 << 13));
    }
  } else {
    {
#line 3888
    *dptr = mkarray((char *)((void *)0));
    }
  }
  {
#line 3889
  arrfixenv(pm->node.nam, *dptr);
#line 3890
  zsfree(x);
  }
#line 3891
  return;
}
}
#line 3894 "/tmp/zsh-5.4.2/Src/params.c"
char *tiedarrgetfn(Param pm ) 
{ 
  struct tieddata *dptr ;
  char *tmp ;
  char const   *tmp___0 ;

  {
#line 3897
  dptr = (struct tieddata *)pm->u.data;
#line 3898
  if (*(dptr->arrptr)) {
    {
#line 3898
    tmp = zjoin(*(dptr->arrptr), (int )((unsigned char )dptr->joinchar), 1);
#line 3898
    tmp___0 = (char const   *)tmp;
    }
  } else {
#line 3898
    tmp___0 = "";
  }
#line 3898
  return ((char *)tmp___0);
}
}
#line 3902 "/tmp/zsh-5.4.2/Src/params.c"
void tiedarrsetfn(Param pm , char *x ) 
{ 
  struct tieddata *dptr ;
  char sepbuf[3] ;

  {
#line 3905
  dptr = (struct tieddata *)pm->u.data;
#line 3907
  if (*(dptr->arrptr)) {
    {
#line 3908
    freearray(*(dptr->arrptr));
    }
  }
#line 3909
  if (x) {
#line 3911
    if ((int )typtab[(unsigned char )dptr->joinchar] & (1 << 12)) {
#line 3913
      sepbuf[0] = (char)-125;
#line 3914
      sepbuf[1] = (char )(dptr->joinchar ^ 32);
#line 3915
      sepbuf[2] = (char )'\000';
    } else {
#line 3919
      sepbuf[0] = (char )dptr->joinchar;
#line 3920
      sepbuf[1] = (char )'\000';
    }
    {
#line 3922
    *(dptr->arrptr) = sepsplit(x, sepbuf, 0, 0);
    }
#line 3923
    if (pm->node.flags & (1 << 13)) {
      {
#line 3924
      uniqarray(*(dptr->arrptr));
      }
    }
    {
#line 3925
    zsfree(x);
    }
  } else {
#line 3927
    *(dptr->arrptr) = (char **)((void *)0);
  }
#line 3928
  if (pm->ename) {
    {
#line 3929
    arrfixenv(pm->node.nam, *(dptr->arrptr));
    }
  }
#line 3930
  return;
}
}
#line 3933 "/tmp/zsh-5.4.2/Src/params.c"
void tiedarrunsetfn(Param pm , int exp  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 3941
  (*((pm->gsu.s)->setfn))(pm, (char *)((void *)0));
#line 3942
  zfree(pm->u.data, (int )sizeof(struct tieddata ));
#line 3944
  pm->u.data = (void *)0;
#line 3945
  zsfree(pm->ename);
#line 3946
  pm->ename = (char *)((void *)0);
#line 3947
  pm->node.flags &= ~ (1 << 16);
#line 3948
  pm->node.flags |= 1 << 25;
  }
#line 3949
  return;
}
}
#line 3952 "/tmp/zsh-5.4.2/Src/params.c"
static void simple_arrayuniq(char **x , int freeok ) 
{ 
  char **t ;
  char **p ;
  char *hole ;
  int tmp ;
  char **tmp___0 ;
  char *tmp___1 ;

  {
#line 3955
  p = x;
#line 3956
  hole = (char *)"";
  {
#line 3959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3959
    p ++;
#line 3959
    if (! *p) {
#line 3959
      goto while_break;
    }
#line 3960
    t = x;
    {
#line 3960
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3960
      if (! ((unsigned long )t < (unsigned long )p)) {
#line 3960
        goto while_break___0;
      }
#line 3961
      if ((unsigned long )*t != (unsigned long )hole) {
        {
#line 3961
        tmp = strcmp((char const   *)*p, (char const   *)*t);
        }
#line 3961
        if (! tmp) {
#line 3962
          if (freeok) {
            {
#line 3963
            zsfree(*p);
            }
          }
#line 3964
          *p = hole;
#line 3965
          goto while_break___0;
        }
      }
#line 3960
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3968
  t = x;
#line 3968
  p = t;
  {
#line 3968
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3968
    if (! ((unsigned long )*t != (unsigned long )((void *)0))) {
#line 3968
      goto while_break___1;
    }
#line 3969
    if ((unsigned long )*t == (unsigned long )hole) {
      {
#line 3970
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3970
        if (! ((unsigned long )*p == (unsigned long )hole)) {
#line 3970
          goto while_break___2;
        }
#line 3971
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3972
      tmp___1 = *p;
#line 3972
      *t = tmp___1;
#line 3972
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 3973
        tmp___0 = p;
#line 3973
        p ++;
#line 3973
        *tmp___0 = hole;
      }
    } else
#line 3974
    if ((unsigned long )p == (unsigned long )t) {
#line 3975
      p ++;
    }
#line 3968
    t ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3978
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3978
    t ++;
#line 3978
    if (! ((unsigned long )t < (unsigned long )p)) {
#line 3978
      goto while_break___3;
    }
#line 3979
    *t = (char *)((void *)0);
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3980
  return;
}
}
#line 3983 "/tmp/zsh-5.4.2/Src/params.c"
static void arrayuniq_freenode(HashNode hn ) 
{ 


  {
#line 3987
  return;
}
}
#line 3990 "/tmp/zsh-5.4.2/Src/params.c"
HashTable newuniqtable(zlong size ) 
{ 
  HashTable ht ;
  HashTable tmp ;

  {
  {
#line 3993
  tmp = newhashtable((int )size, "arrayuniq", (void (*)(HashTable  ))((void *)0));
#line 3993
  ht = tmp;
#line 3996
  ht->hash = & hasher;
#line 3997
  ht->emptytable = & emptyhashtable;
#line 3998
  ht->filltable = (void (*)(HashTable  ))((void *)0);
#line 3999
  ht->cmpnodes = (int (*)(char const   * , char const   * ))(& strcmp);
#line 4000
  ht->addnode = & addhashnode;
#line 4001
  ht->getnode = & gethashnode2;
#line 4002
  ht->getnode2 = & gethashnode2;
#line 4003
  ht->removenode = & removehashnode;
#line 4004
  ht->disablenode = & disablehashnode;
#line 4005
  ht->enablenode = & enablehashnode;
#line 4006
  ht->freenode = & arrayuniq_freenode;
#line 4007
  ht->printnode = (void (*)(HashNode  , int  ))((void *)0);
  }
#line 4009
  return (ht);
}
}
#line 4013 "/tmp/zsh-5.4.2/Src/params.c"
static void arrayuniq(char **x , int freeok ) 
{ 
  char **it ;
  char **write_it ;
  zlong array_size ;
  int tmp ;
  HashTable ht ;
  HashNode new_node ;
  void *tmp___0 ;
  HashNode tmp___1 ;

  {
  {
#line 4017
  tmp = arrlen(x);
#line 4017
  array_size = (zlong )tmp;
  }
#line 4020
  if (array_size == 0L) {
#line 4021
    return;
  }
#line 4022
  if (array_size < 10L) {
    {
#line 4024
    simple_arrayuniq(x, freeok);
    }
#line 4025
    return;
  } else {
    {
#line 4022
    ht = newuniqtable(array_size + 1L);
    }
#line 4022
    if (! ht) {
      {
#line 4024
      simple_arrayuniq(x, freeok);
      }
#line 4025
      return;
    }
  }
#line 4028
  it = x;
#line 4028
  write_it = x;
  {
#line 4028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4028
    if (! *it) {
#line 4028
      goto while_break;
    }
    {
#line 4029
    tmp___1 = gethashnode2(ht, (char const   *)*it);
    }
#line 4029
    if (tmp___1) {
#line 4043
      if (freeok) {
        {
#line 4044
        zsfree(*it);
        }
      }
#line 4045
      *it = (char *)((void *)0);
    } else {
      {
#line 4030
      tmp___0 = zhalloc(sizeof(struct hashnode ));
#line 4030
      new_node = (HashNode )tmp___0;
      }
#line 4031
      if (! new_node) {
        {
#line 4033
        zerr("out of memory in arrayuniq");
        }
#line 4034
        goto while_break;
      }
      {
#line 4036
      addhashnode2(ht, *it, (void *)new_node);
#line 4037
      *write_it = *it;
      }
#line 4038
      if ((unsigned long )it != (unsigned long )write_it) {
#line 4039
        *it = (char *)((void *)0);
      }
#line 4040
      write_it ++;
    }
#line 4047
    it ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4050
  deletehashtable(ht);
  }
#line 4051
  return;
}
}
#line 4054 "/tmp/zsh-5.4.2/Src/params.c"
void uniqarray(char **x ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 4057
  if (! x) {
#line 4058
    return;
  } else
#line 4057
  if (! *x) {
#line 4058
    return;
  }
  {
#line 4059
  tmp = zheapptr((void *)*x);
  }
#line 4059
  if (tmp) {
#line 4059
    tmp___0 = 0;
  } else {
#line 4059
    tmp___0 = 1;
  }
  {
#line 4059
  arrayuniq(x, tmp___0);
  }
#line 4060
  return;
}
}
#line 4063 "/tmp/zsh-5.4.2/Src/params.c"
void zhuniqarray(char **x ) 
{ 


  {
#line 4066
  if (! x) {
#line 4067
    return;
  } else
#line 4066
  if (! *x) {
#line 4067
    return;
  }
  {
#line 4068
  arrayuniq(x, 0);
  }
#line 4069
  return;
}
}
#line 4074 "/tmp/zsh-5.4.2/Src/params.c"
zlong poundgetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  int tmp ;

  {
  {
#line 4077
  tmp = arrlen(pparams);
  }
#line 4077
  return ((zlong )tmp);
}
}
#line 4083 "/tmp/zsh-5.4.2/Src/params.c"
zlong randomgetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  int tmp ;

  {
  {
#line 4086
  tmp = rand();
  }
#line 4086
  return ((zlong )(tmp & 32767));
}
}
#line 4092 "/tmp/zsh-5.4.2/Src/params.c"
void randomsetfn(Param pm  __attribute__((__unused__)) , zlong v ) 
{ 


  {
  {
#line 4095
  srand((unsigned int )v);
  }
#line 4096
  return;
}
}
#line 4101 "/tmp/zsh-5.4.2/Src/params.c"
zlong intsecondsgetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  struct timeval now ;
  struct timezone dummy_tz ;
  int tmp ;

  {
  {
#line 4107
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )(& dummy_tz));
  }
#line 4109
  if (now.tv_usec < shtimer.tv_usec) {
#line 4109
    tmp = 1;
  } else {
#line 4109
    tmp = 0;
  }
#line 4109
  return ((now.tv_sec - shtimer.tv_sec) - (__time_t )tmp);
}
}
#line 4116 "/tmp/zsh-5.4.2/Src/params.c"
void intsecondssetfn(Param pm  __attribute__((__unused__)) , zlong x ) 
{ 
  struct timeval now ;
  struct timezone dummy_tz ;
  zlong diff ;

  {
  {
#line 4123
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )(& dummy_tz));
#line 4124
  diff = now.tv_sec - x;
#line 4125
  shtimer.tv_sec = diff;
  }
#line 4126
  if (shtimer.tv_sec != diff) {
    {
#line 4127
    zwarn("SECONDS truncated on assignment");
    }
  }
#line 4128
  shtimer.tv_usec = now.tv_usec;
#line 4129
  return;
}
}
#line 4132 "/tmp/zsh-5.4.2/Src/params.c"
double floatsecondsgetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  struct timeval now ;
  struct timezone dummy_tz ;

  {
  {
#line 4138
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )(& dummy_tz));
  }
#line 4140
  return ((double )(now.tv_sec - shtimer.tv_sec) + (double )(now.tv_usec - shtimer.tv_usec) / 1000000.0);
}
}
#line 4145 "/tmp/zsh-5.4.2/Src/params.c"
void floatsecondssetfn(Param pm  __attribute__((__unused__)) , double x ) 
{ 
  struct timeval now ;
  struct timezone dummy_tz ;

  {
  {
#line 4151
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )(& dummy_tz));
#line 4152
  shtimer.tv_sec = now.tv_sec - (zlong )x;
#line 4153
  shtimer.tv_usec = now.tv_usec - (zlong )((x - (double )((zlong )x)) * 1000000.0);
  }
#line 4154
  return;
}
}
#line 4157 "/tmp/zsh-5.4.2/Src/params.c"
double getrawseconds(void) 
{ 


  {
#line 4160
  return ((double )shtimer.tv_sec + (double )shtimer.tv_usec / 1000000.0);
}
}
#line 4164 "/tmp/zsh-5.4.2/Src/params.c"
void setrawseconds(double x ) 
{ 


  {
#line 4167
  shtimer.tv_sec = (zlong )x;
#line 4168
  shtimer.tv_usec = (zlong )((x - (double )((zlong )x)) * 1000000.0);
#line 4169
  return;
}
}
#line 4172 "/tmp/zsh-5.4.2/Src/params.c"
int setsecondstype(Param pm , int on , int off ) 
{ 
  int newflags ;
  int tp ;

  {
#line 4175
  newflags = (pm->node.flags | on) & ~ off;
#line 4176
  tp = newflags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4));
#line 4178
  if (tp == 1 << 2) {
#line 4180
    pm->gsu.f = & floatseconds_gsu;
  } else
#line 4178
  if (tp == 1 << 3) {
#line 4180
    pm->gsu.f = & floatseconds_gsu;
  } else
#line 4182
  if (tp == 1 << 1) {
#line 4184
    pm->gsu.i = & intseconds_gsu;
  } else {
#line 4187
    return (1);
  }
#line 4188
  pm->node.flags = newflags;
#line 4189
  return (0);
}
}
#line 4195 "/tmp/zsh-5.4.2/Src/params.c"
char *usernamegetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  char *tmp ;

  {
  {
#line 4198
  tmp = get_username();
  }
#line 4198
  return (tmp);
}
}
#line 4204 "/tmp/zsh-5.4.2/Src/params.c"
void usernamesetfn(Param pm  __attribute__((__unused__)) , char *x ) 
{ 
  struct passwd *pswd ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4210
  if (x) {
    {
#line 4210
    pswd = getpwnam((char const   *)x);
    }
#line 4210
    if (pswd) {
#line 4210
      if (pswd->pw_uid != cached_uid) {
        {
#line 4212
        initgroups((char const   *)x, pswd->pw_gid);
#line 4214
        tmp___2 = setgid(pswd->pw_gid);
        }
#line 4214
        if (tmp___2) {
          {
#line 4215
          tmp = __errno_location();
#line 4215
          zwarn("failed to change group ID: %e", *tmp);
          }
        } else {
          {
#line 4216
          tmp___1 = setuid(pswd->pw_uid);
          }
#line 4216
          if (tmp___1) {
            {
#line 4217
            tmp___0 = __errno_location();
#line 4217
            zwarn("failed to change user ID: %e", *tmp___0);
            }
          } else {
            {
#line 4219
            zsfree(cached_username);
#line 4220
            cached_username = ztrdup((char const   *)pswd->pw_name);
#line 4221
            cached_uid = pswd->pw_uid;
            }
          }
        }
      }
    }
  }
  {
#line 4225
  zsfree(x);
  }
#line 4226
  return;
}
}
#line 4231 "/tmp/zsh-5.4.2/Src/params.c"
zlong uidgetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  __uid_t tmp ;

  {
  {
#line 4234
  tmp = getuid();
  }
#line 4234
  return ((zlong )tmp);
}
}
#line 4240 "/tmp/zsh-5.4.2/Src/params.c"
void uidsetfn(Param pm  __attribute__((__unused__)) , zlong x ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 4244
  tmp___0 = setuid((uid_t )x);
  }
#line 4244
  if (tmp___0) {
    {
#line 4245
    tmp = __errno_location();
#line 4245
    zerr("failed to change user ID: %e", *tmp);
    }
  }
#line 4247
  return;
}
}
#line 4252 "/tmp/zsh-5.4.2/Src/params.c"
zlong euidgetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  __uid_t tmp ;

  {
  {
#line 4255
  tmp = geteuid();
  }
#line 4255
  return ((zlong )tmp);
}
}
#line 4261 "/tmp/zsh-5.4.2/Src/params.c"
void euidsetfn(Param pm  __attribute__((__unused__)) , zlong x ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 4265
  tmp___0 = seteuid((uid_t )x);
  }
#line 4265
  if (tmp___0) {
    {
#line 4266
    tmp = __errno_location();
#line 4266
    zerr("failed to change effective user ID: %e", *tmp);
    }
  }
#line 4268
  return;
}
}
#line 4273 "/tmp/zsh-5.4.2/Src/params.c"
zlong gidgetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  __gid_t tmp ;

  {
  {
#line 4276
  tmp = getgid();
  }
#line 4276
  return ((zlong )tmp);
}
}
#line 4282 "/tmp/zsh-5.4.2/Src/params.c"
void gidsetfn(Param pm  __attribute__((__unused__)) , zlong x ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 4286
  tmp___0 = setgid((gid_t )x);
  }
#line 4286
  if (tmp___0) {
    {
#line 4287
    tmp = __errno_location();
#line 4287
    zerr("failed to change group ID: %e", *tmp);
    }
  }
#line 4289
  return;
}
}
#line 4294 "/tmp/zsh-5.4.2/Src/params.c"
zlong egidgetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  __gid_t tmp ;

  {
  {
#line 4297
  tmp = getegid();
  }
#line 4297
  return ((zlong )tmp);
}
}
#line 4303 "/tmp/zsh-5.4.2/Src/params.c"
void egidsetfn(Param pm  __attribute__((__unused__)) , zlong x ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 4307
  tmp___0 = setegid((gid_t )x);
  }
#line 4307
  if (tmp___0) {
    {
#line 4308
    tmp = __errno_location();
#line 4308
    zerr("failed to change effective group ID: %e", *tmp);
    }
  }
#line 4310
  return;
}
}
#line 4313 "/tmp/zsh-5.4.2/Src/params.c"
zlong ttyidlegetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  struct stat ttystat ;
  int tmp ;
  time_t tmp___0 ;

  {
#line 4318
  if (SHTTY == -1) {
#line 4319
    return ((zlong )-1);
  } else {
    {
#line 4318
    tmp = fstat(SHTTY, & ttystat);
    }
#line 4318
    if (tmp) {
#line 4319
      return ((zlong )-1);
    }
  }
  {
#line 4320
  tmp___0 = time((time_t *)((void *)0));
  }
#line 4320
  return (tmp___0 - ttystat.st_atim.tv_sec);
}
}
#line 4326 "/tmp/zsh-5.4.2/Src/params.c"
char *ifsgetfn(Param pm  __attribute__((__unused__)) ) 
{ 


  {
#line 4329
  return (ifs);
}
}
#line 4335 "/tmp/zsh-5.4.2/Src/params.c"
void ifssetfn(Param pm  __attribute__((__unused__)) , char *x ) 
{ 


  {
  {
#line 4338
  zsfree(ifs);
#line 4339
  ifs = x;
#line 4340
  inittyptab();
  }
#line 4341
  return;
}
}
#line 4346 "/tmp/zsh-5.4.2/Src/params.c"
static struct localename lc_names[6]  = {      {(char *)"LC_COLLATE", 3}, 
        {(char *)"LC_CTYPE", 0}, 
        {(char *)"LC_MESSAGES", 5}, 
        {(char *)"LC_NUMERIC", 1}, 
        {(char *)"LC_TIME", 2}, 
        {(char *)((void *)0), 0}};
#line 4369 "/tmp/zsh-5.4.2/Src/params.c"
static void setlang(char *x ) 
{ 
  struct localename *ln ;
  char *x2 ;
  char *tmp ;
  char const   *tmp___0 ;
  sigset_t oset ;

  {
  {
#line 4375
  x2 = getsparam_u((char *)"LC_ALL");
  }
#line 4375
  if (x2) {
#line 4375
    if (*x2) {
#line 4376
      return;
    }
  }
#line 4389
  if (x) {
    {
#line 4389
    tmp = unmeta((char const   *)x);
#line 4389
    tmp___0 = (char const   *)tmp;
    }
  } else {
#line 4389
    tmp___0 = "";
  }
  {
#line 4389
  setlocale(6, tmp___0);
#line 4390
  queueing_enabled ++;
#line 4391
  ln = lc_names;
  }
  {
#line 4391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4391
    if (! ln->name) {
#line 4391
      goto while_break;
    }
    {
#line 4392
    x = getsparam_u(ln->name);
    }
#line 4392
    if (x) {
#line 4392
      if (*x) {
        {
#line 4393
        setlocale(ln->category, (char const   *)x);
        }
      }
    }
#line 4391
    ln ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4394
    queueing_enabled --;
#line 4394
    if (! queueing_enabled) {
      {
#line 4394
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 4394
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 4394
          if (! (queue_front != queue_rear)) {
#line 4394
            goto while_break___2;
          }
          {
#line 4394
          queue_front = (queue_front + 1) % 128;
#line 4394
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 4394
          zhandler(signal_queue[queue_front]);
#line 4394
          signal_setmask(oset);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 4394
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 4394
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4395
  return;
}
}
#line 4398 "/tmp/zsh-5.4.2/Src/params.c"
void lc_allsetfn(Param pm , char *x ) 
{ 
  sigset_t oset ;
  char *tmp ;

  {
  {
#line 4401
  strsetfn(pm, x);
  }
#line 4407
  if (! x) {
#line 4407
    goto _L;
  } else
#line 4407
  if (! *x) {
    _L: /* CIL Label */ 
    {
#line 4408
    x = getsparam_u((char *)"LANG");
    }
#line 4409
    if (x) {
#line 4409
      if (*x) {
        {
#line 4410
        queueing_enabled ++;
#line 4411
        setlang(x);
        }
        {
#line 4412
        while (1) {
          while_continue: /* CIL Label */ ;
#line 4412
          queueing_enabled --;
#line 4412
          if (! queueing_enabled) {
            {
#line 4412
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 4412
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 4412
                if (! (queue_front != queue_rear)) {
#line 4412
                  goto while_break___1;
                }
                {
#line 4412
                queue_front = (queue_front + 1) % 128;
#line 4412
                oset = signal_setmask(signal_mask_queue[queue_front]);
#line 4412
                zhandler(signal_queue[queue_front]);
#line 4412
                signal_setmask(oset);
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 4412
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 4412
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  } else {
    {
#line 4416
    tmp = unmeta((char const   *)x);
#line 4416
    setlocale(6, (char const   *)tmp);
    }
  }
#line 4417
  return;
}
}
#line 4420 "/tmp/zsh-5.4.2/Src/params.c"
void langsetfn(Param pm , char *x ) 
{ 
  char *tmp ;

  {
  {
#line 4423
  strsetfn(pm, x);
#line 4424
  tmp = unmeta((char const   *)x);
#line 4424
  setlang(tmp);
  }
#line 4425
  return;
}
}
#line 4428 "/tmp/zsh-5.4.2/Src/params.c"
void lcsetfn(Param pm , char *x ) 
{ 
  char *x2 ;
  struct localename *ln ;
  char *tmp ;
  int tmp___0 ;
  sigset_t oset ;

  {
  {
#line 4434
  strsetfn(pm, x);
#line 4435
  x2 = getsparam((char *)"LC_ALL");
  }
#line 4435
  if (x2) {
#line 4435
    if (*x2) {
#line 4436
      return;
    }
  }
#line 4437
  queueing_enabled ++;
#line 4439
  if (! x) {
    {
#line 4440
    x = getsparam((char *)"LANG");
    }
  } else
#line 4439
  if (! *x) {
    {
#line 4440
    x = getsparam((char *)"LANG");
    }
  }
#line 4447
  if (x) {
#line 4447
    if (*x) {
#line 4448
      ln = lc_names;
      {
#line 4448
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4448
        if (! ln->name) {
#line 4448
          goto while_break;
        }
        {
#line 4449
        tmp___0 = strcmp((char const   *)ln->name, (char const   *)pm->node.nam);
        }
#line 4449
        if (! tmp___0) {
          {
#line 4450
          tmp = unmeta((char const   *)x);
#line 4450
          setlocale(ln->category, (char const   *)tmp);
          }
        }
#line 4448
        ln ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 4452
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4452
    queueing_enabled --;
#line 4452
    if (! queueing_enabled) {
      {
#line 4452
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 4452
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 4452
          if (! (queue_front != queue_rear)) {
#line 4452
            goto while_break___2;
          }
          {
#line 4452
          queue_front = (queue_front + 1) % 128;
#line 4452
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 4452
          zhandler(signal_queue[queue_front]);
#line 4452
          signal_setmask(oset);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 4452
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 4452
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4453
  return;
}
}
#line 4459 "/tmp/zsh-5.4.2/Src/params.c"
static void argzerosetfn(Param pm  __attribute__((__unused__)) , char *x ) 
{ 


  {
#line 4462
  if (x) {
#line 4463
    if (opts[130]) {
      {
#line 4464
      zerr("read-only variable: 0");
      }
    } else {
      {
#line 4466
      zsfree(argzero);
#line 4467
      argzero = ztrdup((char const   *)x);
      }
    }
    {
#line 4469
    zsfree(x);
    }
  }
#line 4471
  return;
}
}
#line 4476 "/tmp/zsh-5.4.2/Src/params.c"
static char *argzerogetfn(Param pm  __attribute__((__unused__)) ) 
{ 


  {
#line 4479
  if (opts[130]) {
#line 4480
    return (posixzero);
  }
#line 4481
  return (argzero);
}
}
#line 4487 "/tmp/zsh-5.4.2/Src/params.c"
zlong histsizegetfn(Param pm  __attribute__((__unused__)) ) 
{ 


  {
#line 4490
  return (histsiz);
}
}
#line 4496 "/tmp/zsh-5.4.2/Src/params.c"
void histsizesetfn(Param pm  __attribute__((__unused__)) , zlong v ) 
{ 


  {
#line 4499
  histsiz = v;
#line 4499
  if (histsiz < 1L) {
#line 4500
    histsiz = (zlong )1;
  }
  {
#line 4501
  resizehistents();
  }
#line 4502
  return;
}
}
#line 4507 "/tmp/zsh-5.4.2/Src/params.c"
zlong savehistsizegetfn(Param pm  __attribute__((__unused__)) ) 
{ 


  {
#line 4510
  return (savehistsiz);
}
}
#line 4516 "/tmp/zsh-5.4.2/Src/params.c"
void savehistsizesetfn(Param pm  __attribute__((__unused__)) , zlong v ) 
{ 


  {
#line 4519
  savehistsiz = v;
#line 4519
  if (savehistsiz < 0L) {
#line 4520
    savehistsiz = (zlong )0;
  }
#line 4521
  return;
}
}
#line 4526 "/tmp/zsh-5.4.2/Src/params.c"
void errnosetfn(Param pm  __attribute__((__unused__)) , zlong x ) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 4529
  tmp = __errno_location();
#line 4529
  *tmp = (int )x;
#line 4530
  tmp___0 = __errno_location();
  }
#line 4530
  if ((zlong )*tmp___0 != x) {
    {
#line 4531
    zwarn("errno truncated on assignment");
    }
  }
#line 4532
  return;
}
}
#line 4537 "/tmp/zsh-5.4.2/Src/params.c"
zlong errnogetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 4540
  tmp = __errno_location();
  }
#line 4540
  return ((zlong )*tmp);
}
}
#line 4549 "/tmp/zsh-5.4.2/Src/params.c"
static char buf___3[2]  ;
#line 4546 "/tmp/zsh-5.4.2/Src/params.c"
char *keyboardhackgetfn(Param pm  __attribute__((__unused__)) ) 
{ 


  {
#line 4551
  buf___3[0] = (char )keyboardhackchar;
#line 4552
  buf___3[1] = (char )'\000';
#line 4553
  return (buf___3);
}
}
#line 4560 "/tmp/zsh-5.4.2/Src/params.c"
void keyboardhacksetfn(Param pm  __attribute__((__unused__)) , char *x ) 
{ 
  int len ;
  int i ;

  {
#line 4563
  if (x) {
    {
#line 4566
    unmetafy(x, & len);
    }
#line 4567
    if (len > 1) {
      {
#line 4568
      len = 1;
#line 4569
      zwarn("Only one KEYBOARD_HACK character can be defined");
      }
    }
#line 4571
    i = 0;
    {
#line 4571
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4571
      if (! (i < len)) {
#line 4571
        goto while_break;
      }
#line 4572
      if (! (((int )((unsigned char )*(x + i)) & -128) == 0)) {
        {
#line 4573
        zwarn("KEYBOARD_HACK can only contain ASCII characters");
        }
#line 4574
        return;
      }
#line 4571
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 4577
    if (len) {
#line 4577
      keyboardhackchar = (unsigned char )*(x + 0);
    } else {
#line 4577
      keyboardhackchar = (unsigned char )'\000';
    }
    {
#line 4578
    free((void *)x);
    }
  } else {
#line 4580
    keyboardhackchar = (unsigned char )'\000';
  }
#line 4581
  return;
}
}
#line 4589 "/tmp/zsh-5.4.2/Src/params.c"
static char buf___4[4]  ;
#line 4586 "/tmp/zsh-5.4.2/Src/params.c"
char *histcharsgetfn(Param pm  __attribute__((__unused__)) ) 
{ 


  {
#line 4591
  buf___4[0] = (char )bangchar;
#line 4592
  buf___4[1] = (char )hatchar;
#line 4593
  buf___4[2] = (char )hashchar;
#line 4594
  buf___4[3] = (char )'\000';
#line 4595
  return (buf___4);
}
}
#line 4601 "/tmp/zsh-5.4.2/Src/params.c"
void histcharssetfn(Param pm  __attribute__((__unused__)) , char *x ) 
{ 
  int len ;
  int i ;

  {
#line 4604
  if (x) {
    {
#line 4607
    unmetafy(x, & len);
    }
#line 4608
    if (len > 3) {
#line 4609
      len = 3;
    }
#line 4610
    i = 0;
    {
#line 4610
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4610
      if (! (i < len)) {
#line 4610
        goto while_break;
      }
#line 4611
      if (! (((int )((unsigned char )*(x + i)) & -128) == 0)) {
        {
#line 4612
        zwarn("HISTCHARS can only contain ASCII characters");
        }
#line 4613
        return;
      }
#line 4610
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 4616
    if (len) {
#line 4616
      bangchar = (unsigned char )*(x + 0);
    } else {
#line 4616
      bangchar = (unsigned char )'\000';
    }
#line 4617
    if (len > 1) {
#line 4617
      hatchar = (unsigned char )*(x + 1);
    } else {
#line 4617
      hatchar = (unsigned char )'\000';
    }
#line 4618
    if (len > 2) {
#line 4618
      hashchar = (unsigned char )*(x + 2);
    } else {
#line 4618
      hashchar = (unsigned char )'\000';
    }
    {
#line 4619
    free((void *)x);
    }
  } else {
#line 4621
    bangchar = (unsigned char )'!';
#line 4622
    hashchar = (unsigned char )'#';
#line 4623
    hatchar = (unsigned char )'^';
  }
  {
#line 4625
  inittyptab();
  }
#line 4626
  return;
}
}
#line 4631 "/tmp/zsh-5.4.2/Src/params.c"
char *homegetfn(Param pm  __attribute__((__unused__)) ) 
{ 


  {
#line 4634
  return (home);
}
}
#line 4640 "/tmp/zsh-5.4.2/Src/params.c"
void homesetfn(Param pm  __attribute__((__unused__)) , char *x ) 
{ 
  char *tmp ;

  {
  {
#line 4643
  zsfree(home);
  }
#line 4644
  if (x) {
#line 4644
    if (opts[31]) {
      {
#line 4644
      home = xsymlink(x, 0);
      }
#line 4644
      if (home) {
        {
#line 4645
        zsfree(x);
        }
      } else {
#line 4644
        goto _L___0;
      }
    } else {
#line 4644
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 4647
  if (x) {
#line 4647
    home = x;
  } else {
    {
#line 4647
    tmp = ztrdup("");
#line 4647
    home = tmp;
    }
  }
  {
#line 4648
  finddir((char *)((void *)0));
  }
#line 4649
  return;
}
}
#line 4654 "/tmp/zsh-5.4.2/Src/params.c"
char *wordcharsgetfn(Param pm  __attribute__((__unused__)) ) 
{ 


  {
#line 4657
  return (wordchars);
}
}
#line 4663 "/tmp/zsh-5.4.2/Src/params.c"
void wordcharssetfn(Param pm  __attribute__((__unused__)) , char *x ) 
{ 


  {
  {
#line 4666
  zsfree(wordchars);
#line 4667
  wordchars = x;
#line 4668
  inittyptab();
  }
#line 4669
  return;
}
}
#line 4674 "/tmp/zsh-5.4.2/Src/params.c"
char *underscoregetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  char *u ;
  char *tmp ;

  {
  {
#line 4677
  tmp = dupstring((char const   *)zunderscore);
#line 4677
  u = tmp;
#line 4679
  untokenize(u);
  }
#line 4680
  return (u);
}
}
#line 4685 "/tmp/zsh-5.4.2/Src/params.c"
static void term_reinit_from_pm(void) 
{ 


  {
#line 4689
  if (! opts[93]) {
#line 4690
    termflags |= 2;
  } else
#line 4689
  if (! *term) {
#line 4690
    termflags |= 2;
  } else {
    {
#line 4692
    init_term();
    }
  }
#line 4693
  return;
}
}
#line 4698 "/tmp/zsh-5.4.2/Src/params.c"
char *termgetfn(Param pm  __attribute__((__unused__)) ) 
{ 


  {
#line 4701
  return (term);
}
}
#line 4707 "/tmp/zsh-5.4.2/Src/params.c"
void termsetfn(Param pm  __attribute__((__unused__)) , char *x ) 
{ 
  char *tmp ;

  {
  {
#line 4710
  zsfree(term);
  }
#line 4711
  if (x) {
#line 4711
    term = x;
  } else {
    {
#line 4711
    tmp = ztrdup("");
#line 4711
    term = tmp;
    }
  }
  {
#line 4712
  term_reinit_from_pm();
  }
#line 4713
  return;
}
}
#line 4718 "/tmp/zsh-5.4.2/Src/params.c"
char *terminfogetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 4721
  if (zsh_terminfo) {
#line 4721
    tmp___0 = zsh_terminfo;
  } else {
    {
#line 4721
    tmp = dupstring("");
#line 4721
    tmp___0 = tmp;
    }
  }
#line 4721
  return (tmp___0);
}
}
#line 4727 "/tmp/zsh-5.4.2/Src/params.c"
void terminfosetfn(Param pm , char *x ) 
{ 


  {
  {
#line 4730
  zsfree(zsh_terminfo);
#line 4731
  zsh_terminfo = x;
  }
#line 4737
  if (pm->node.flags & (1 << 12)) {
#line 4737
    if (x) {
      {
#line 4738
      addenv(pm, x);
      }
    }
  }
  {
#line 4740
  term_reinit_from_pm();
  }
#line 4741
  return;
}
}
#line 4746 "/tmp/zsh-5.4.2/Src/params.c"
char *terminfodirsgetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 4749
  if (zsh_terminfodirs) {
#line 4749
    tmp___0 = zsh_terminfodirs;
  } else {
    {
#line 4749
    tmp = dupstring("");
#line 4749
    tmp___0 = tmp;
    }
  }
#line 4749
  return (tmp___0);
}
}
#line 4755 "/tmp/zsh-5.4.2/Src/params.c"
void terminfodirssetfn(Param pm , char *x ) 
{ 


  {
  {
#line 4758
  zsfree(zsh_terminfodirs);
#line 4759
  zsh_terminfodirs = x;
  }
#line 4765
  if (pm->node.flags & (1 << 12)) {
#line 4765
    if (x) {
      {
#line 4766
      addenv(pm, x);
      }
    }
  }
  {
#line 4768
  term_reinit_from_pm();
  }
#line 4769
  return;
}
}
#line 4773 "/tmp/zsh-5.4.2/Src/params.c"
static char **pipestatgetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  char **x ;
  void *tmp ;
  char buf___7[(int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3] ;
  char **p ;
  int *q ;
  int i ;
  int tmp___0 ;

  {
  {
#line 4776
  tmp = zhalloc((unsigned long )(numpipestats + 1) * sizeof(char *));
#line 4776
  x = (char **)tmp;
#line 4780
  p = x;
#line 4780
  q = pipestats;
#line 4780
  i = numpipestats;
  }
  {
#line 4780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4780
    tmp___0 = i;
#line 4780
    i --;
#line 4780
    if (! tmp___0) {
#line 4780
      goto while_break;
    }
    {
#line 4781
    sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%d",
            *q);
#line 4782
    *p = dupstring((char const   *)(buf___7));
#line 4780
    p ++;
#line 4780
    q ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4784
  *p = (char *)((void *)0);
#line 4786
  return (x);
}
}
#line 4792 "/tmp/zsh-5.4.2/Src/params.c"
static void pipestatsetfn(Param pm  __attribute__((__unused__)) , char **x ) 
{ 
  int i ;

  {
#line 4795
  if (x) {
#line 4798
    i = 0;
    {
#line 4798
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4798
      if (*x) {
#line 4798
        if (! (i < 256)) {
#line 4798
          goto while_break;
        }
      } else {
#line 4798
        goto while_break;
      }
      {
#line 4799
      pipestats[i] = atoi((char const   *)*x);
#line 4798
      i ++;
#line 4798
      x ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 4800
    numpipestats = i;
  } else {
#line 4803
    numpipestats = 0;
  }
#line 4804
  return;
}
}
#line 4807 "/tmp/zsh-5.4.2/Src/params.c"
void arrfixenv(char *s , char **t ) 
{ 
  Param pm ;
  int joinchar ;
  HashNode tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 4813
  if ((unsigned long )t == (unsigned long )path) {
    {
#line 4814
    (*(cmdnamtab->emptytable))(cmdnamtab);
    }
  }
  {
#line 4816
  tmp = (*(paramtab->getnode))(paramtab, (char const   *)s);
#line 4816
  pm = (Param )tmp;
  }
#line 4823
  if (pm->node.flags & (1 << 29)) {
#line 4824
    return;
  }
#line 4826
  if (opts[3]) {
#line 4827
    pm->node.flags |= 1 << 12;
  }
#line 4833
  if (! (pm->node.flags & (1 << 12))) {
#line 4834
    return;
  }
#line 4836
  if (pm->node.flags & (1 << 16)) {
#line 4837
    joinchar = (int )((unsigned char )((struct tieddata *)pm->u.data)->joinchar);
  } else {
#line 4839
    joinchar = ':';
  }
#line 4841
  if (t) {
    {
#line 4841
    tmp___0 = zjoin(t, joinchar, 1);
#line 4841
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 4841
    tmp___1 = "";
  }
  {
#line 4841
  addenv(pm, (char *)tmp___1);
  }
#line 4842
  return;
}
}
#line 4846 "/tmp/zsh-5.4.2/Src/params.c"
int zputenv(char *str ) 
{ 
  char *ptr___0 ;
  int ret ;

  {
#line 4861
  ptr___0 = str;
  {
#line 4861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4861
    if (*ptr___0) {
#line 4861
      if ((int )((unsigned char )*ptr___0) < 128) {
#line 4861
        if (! ((int )*ptr___0 != 61)) {
#line 4861
          goto while_break;
        }
      } else {
#line 4861
        goto while_break;
      }
    } else {
#line 4861
      goto while_break;
    }
#line 4861
    ptr___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4863
  if ((int )((unsigned char )*ptr___0) >= 128) {
#line 4871
    return (1);
  } else
#line 4872
  if (*ptr___0) {
    {
#line 4873
    *ptr___0 = (char )'\000';
#line 4874
    ret = setenv((char const   *)str, (char const   *)(ptr___0 + 1), 1);
#line 4875
    *ptr___0 = (char )'=';
    }
  } else {
    {
#line 4879
    ret = setenv((char const   *)str, (char const   *)ptr___0, 1);
    }
  }
#line 4881
  return (ret);
}
}
#line 4937 "/tmp/zsh-5.4.2/Src/params.c"
char *zgetenv(char *name ) 
{ 
  char *tmp ;

  {
  {
#line 4941
  tmp = getenv((char const   *)name);
  }
#line 4941
  return (tmp);
}
}
#line 4955 "/tmp/zsh-5.4.2/Src/params.c"
static void copyenvstr(char *s , char *value , int flags ) 
{ 
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 4958
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4958
    tmp___4 = s;
#line 4958
    s ++;
#line 4958
    if (! *tmp___4) {
#line 4958
      goto while_break;
    }
#line 4959
    tmp___1 = value;
#line 4959
    value ++;
#line 4959
    tmp___0 = *tmp___1;
#line 4959
    *s = tmp___0;
#line 4959
    if ((int )tmp___0 == -125) {
#line 4960
      tmp = value;
#line 4960
      value ++;
#line 4960
      *s = (char )((int )*tmp ^ 32);
    }
#line 4961
    if (flags & (1 << 8)) {
      {
#line 4962
      tmp___2 = tulower((int )*s);
#line 4962
      *s = (char )tmp___2;
      }
    } else
#line 4963
    if (flags & (1 << 9)) {
      {
#line 4964
      tmp___3 = tuupper((int )*s);
#line 4964
      *s = (char )tmp___3;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4966
  return;
}
}
#line 4969 "/tmp/zsh-5.4.2/Src/params.c"
void addenv(Param pm , char *value ) 
{ 
  char *newenv ;
  int tmp ;

  {
  {
#line 4972
  newenv = (char *)0;
#line 4985
  newenv = mkenvstr(pm->node.nam, value, pm->node.flags);
#line 4986
  tmp = zputenv(newenv);
  }
#line 4986
  if (tmp) {
    {
#line 4987
    zsfree(newenv);
#line 4988
    pm->env = (char *)((void *)0);
    }
#line 4989
    return;
  }
#line 5002
  if (pm->env) {
    {
#line 5003
    zsfree(pm->env);
    }
  }
#line 5004
  pm->env = newenv;
#line 5005
  pm->node.flags |= 1 << 12;
#line 5027
  return;
}
}
#line 5034 "/tmp/zsh-5.4.2/Src/params.c"
static char *mkenvstr(char *name , char *value , int flags ) 
{ 
  char *str ;
  char *s ;
  int len_name ;
  int len_value ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 5037
  s = value;
#line 5038
  len_value = 0;
#line 5040
  tmp = strlen((char const   *)name);
#line 5040
  len_name = (int )tmp;
  }
#line 5041
  if (s) {
    {
#line 5042
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5042
      if (*s) {
#line 5042
        tmp___0 = s;
#line 5042
        s ++;
#line 5042
        if (! ((int )*tmp___0 != -125)) {
#line 5042
          tmp___1 = s;
#line 5042
          s ++;
#line 5042
          if (! ((int )*tmp___1 != 32)) {
#line 5042
            goto while_break;
          }
        }
      } else {
#line 5042
        goto while_break;
      }
#line 5043
      len_value ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 5044
  tmp___2 = zalloc((size_t )((len_name + len_value) + 2));
#line 5044
  str = (char *)tmp___2;
#line 5044
  s = str;
#line 5045
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)name);
#line 5046
  s += len_name;
#line 5047
  *s = (char )'=';
  }
#line 5048
  if (value) {
    {
#line 5049
    copyenvstr(s, value, flags);
    }
  } else {
#line 5051
    s ++;
#line 5051
    *s = (char )'\000';
  }
#line 5052
  return (str);
}
}
#line 5084 "/tmp/zsh-5.4.2/Src/params.c"
void delenv(Param pm ) 
{ 


  {
  {
#line 5088
  unsetenv((char const   *)pm->node.nam);
#line 5089
  zsfree(pm->env);
#line 5093
  pm->env = (char *)((void *)0);
  }
#line 5099
  return;
}
}
#line 5107 "/tmp/zsh-5.4.2/Src/params.c"
void convbase_ptr(char *s , zlong v , int base , int *ndigits ) 
{ 
  int digs ;
  zulong x ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int dig ;
  int tmp___2 ;

  {
#line 5110
  digs = 0;
#line 5113
  if (v < 0L) {
#line 5114
    tmp = s;
#line 5114
    s ++;
#line 5114
    *tmp = (char )'-';
#line 5114
    v = - v;
  }
#line 5115
  if (base >= -1) {
#line 5115
    if (base <= 1) {
#line 5116
      base = -10;
    }
  }
#line 5118
  if (base > 0) {
#line 5119
    if (opts[28]) {
#line 5119
      if (base == 16) {
        {
#line 5120
        sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"0x");
        }
      } else {
#line 5119
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 5121
    if (opts[28]) {
#line 5121
      if (base == 8) {
#line 5121
        if (opts[124]) {
          {
#line 5122
          sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"0");
          }
        } else {
#line 5121
          goto _L___0;
        }
      } else {
#line 5121
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 5123
    if (base != 10) {
      {
#line 5124
      sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%d#",
              base);
      }
    } else {
#line 5126
      *s = (char)0;
    }
    {
#line 5127
    tmp___0 = strlen((char const   *)s);
#line 5127
    s += tmp___0;
    }
  } else {
#line 5129
    base = - base;
  }
#line 5130
  x = (zulong )v;
  {
#line 5130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5130
    if (! x) {
#line 5130
      goto while_break;
    }
#line 5131
    x /= (zulong )base;
#line 5130
    digs ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5132
  if (! digs) {
#line 5133
    digs = 1;
  }
#line 5134
  if (ndigits) {
#line 5135
    *ndigits = digs;
  }
#line 5136
  tmp___1 = digs;
#line 5136
  digs --;
#line 5136
  *(s + tmp___1) = (char )'\000';
#line 5137
  x = (zulong )v;
  {
#line 5138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5138
    if (! (digs >= 0)) {
#line 5138
      goto while_break___0;
    }
#line 5139
    dig = (int )(x % (unsigned long )base);
#line 5141
    tmp___2 = digs;
#line 5141
    digs --;
#line 5141
    if (dig < 10) {
#line 5141
      *(s + tmp___2) = (char )(48 + dig);
    } else {
#line 5141
      *(s + tmp___2) = (char )((dig - 10) + 65);
    }
#line 5142
    x /= (zulong )base;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5144
  return;
}
}
#line 5153 "/tmp/zsh-5.4.2/Src/params.c"
void convbase(char *s , zlong v , int base ) 
{ 


  {
  {
#line 5156
  convbase_ptr(s, v, base, (int *)((void *)0));
  }
#line 5157
  return;
}
}
#line 5167 "/tmp/zsh-5.4.2/Src/params.c"
char *convbase_underscore(char *s , zlong v , int base , int underscore ) 
{ 
  char *retptr ;
  char *sptr ;
  char *dptr ;
  int ndigits ;
  int nunderscore ;
  int mod ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 5173
  convbase_ptr(s, v, base, & ndigits);
  }
#line 5175
  if (underscore <= 0) {
#line 5176
    return (s);
  }
#line 5178
  nunderscore = (ndigits - 1) / underscore;
#line 5179
  if (! nunderscore) {
#line 5180
    return (s);
  }
  {
#line 5181
  tmp = strlen((char const   *)s);
#line 5181
  len = (int )tmp;
#line 5182
  tmp___0 = zhalloc((size_t )((len + nunderscore) + 1));
#line 5182
  retptr = (char *)tmp___0;
#line 5183
  mod = 0;
#line 5184
  memcpy((void */* __restrict  */)retptr, (void const   */* __restrict  */)s, (size_t )(len - ndigits));
#line 5185
  sptr = s + len;
#line 5186
  dptr = (retptr + len) + nunderscore;
#line 5188
  tmp___1 = dptr;
#line 5188
  dptr --;
#line 5188
  tmp___2 = sptr;
#line 5188
  sptr --;
#line 5188
  *tmp___1 = *tmp___2;
  }
  {
#line 5189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5190
    *dptr = *sptr;
#line 5191
    ndigits --;
#line 5191
    if (! ndigits) {
#line 5192
      goto while_break;
    }
#line 5193
    dptr --;
#line 5194
    sptr --;
#line 5195
    mod ++;
#line 5195
    if (mod == underscore) {
#line 5196
      mod = 0;
#line 5197
      tmp___3 = dptr;
#line 5197
      dptr --;
#line 5197
      *tmp___3 = (char )'_';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5201
  return (retptr);
}
}
#line 5211 "/tmp/zsh-5.4.2/Src/params.c"
char *convfloat(double dval , int digits , int flags , FILE *fout ) 
{ 
  char fmt[5] ;
  char *prev_locale ;
  char *ret ;
  char *tmp ;
  char *buf___7 ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 5214
  fmt[0] = (char )'%';
#line 5214
  fmt[1] = (char )'.';
#line 5214
  fmt[2] = (char )'*';
#line 5214
  fmt[3] = (char )'e';
#line 5214
  fmt[4] = (char )'\000';
#line 5227
  if (! (flags & ((1 << 2) | (1 << 3)))) {
#line 5234
    fmt[3] = (char )'g';
#line 5235
    if (! digits) {
#line 5236
      digits = 17;
    }
  } else {
#line 5238
    if (flags & (1 << 3)) {
#line 5239
      fmt[3] = (char )'f';
    }
#line 5240
    if (digits <= 0) {
#line 5241
      digits = 10;
    }
#line 5242
    if (flags & (1 << 2)) {
#line 5247
      digits --;
    }
  }
  {
#line 5251
  tmp = setlocale(1, (char const   *)((void *)0));
#line 5251
  prev_locale = dupstring((char const   *)tmp);
#line 5252
  setlocale(1, "POSIX");
  }
#line 5254
  if (fout) {
    {
#line 5255
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(fmt),
            digits, dval);
#line 5256
    ret = (char *)((void *)0);
    }
  } else {
    {
#line 5258
    tmp___0 = zhalloc(sizeof(char ) * (unsigned long )(512 + digits));
#line 5258
    buf___7 = (char *)tmp___0;
#line 5259
    sprintf((char */* __restrict  */)buf___7, (char const   */* __restrict  */)(fmt),
            digits, dval);
#line 5260
    tmp___1 = strchr((char const   *)buf___7, 'e');
    }
#line 5260
    if (! tmp___1) {
      {
#line 5260
      tmp___2 = strchr((char const   *)buf___7, '.');
      }
#line 5260
      if (! tmp___2) {
        {
#line 5261
        strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)".");
        }
      }
    }
    {
#line 5262
    ret = dupstring((char const   *)buf___7);
    }
  }
#line 5265
  if (prev_locale) {
    {
#line 5265
    setlocale(1, (char const   *)prev_locale);
    }
  }
#line 5267
  return (ret);
}
}
#line 5276 "/tmp/zsh-5.4.2/Src/params.c"
char *convfloat_underscore(double dval , int underscore ) 
{ 
  int ndigits_int ;
  int ndigits_frac ;
  int nunderscore ;
  int len ;
  char *s ;
  char *retptr ;
  char *sptr ;
  char *dptr ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int mod ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 5278
  ndigits_int = 0;
#line 5278
  ndigits_frac = 0;
#line 5281
  s = convfloat(dval, 0, 0, (FILE *)((void *)0));
  }
#line 5282
  if (underscore <= 0) {
#line 5283
    return (s);
  }
#line 5288
  sptr = s;
#line 5289
  if ((int )*sptr == 45) {
#line 5290
    sptr ++;
  }
  {
#line 5291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5291
    if (! ((int )typtab[(unsigned char )*sptr] & 1)) {
#line 5291
      goto while_break;
    }
#line 5292
    ndigits_int ++;
#line 5293
    sptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5295
  if ((int )*sptr == 46) {
#line 5296
    sptr ++;
    {
#line 5297
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5297
      if (! ((int )typtab[(unsigned char )*sptr] & 1)) {
#line 5297
        goto while_break___0;
      }
#line 5298
      ndigits_frac ++;
#line 5299
      sptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 5307
  nunderscore = (ndigits_int - 1) / underscore + (ndigits_frac - 1) / underscore;
#line 5308
  if (! nunderscore) {
#line 5309
    return (s);
  }
  {
#line 5310
  tmp = strlen((char const   *)s);
#line 5310
  len = (int )tmp;
#line 5311
  tmp___0 = zhalloc((size_t )((len + nunderscore) + 1));
#line 5311
  retptr = (char *)tmp___0;
#line 5311
  dptr = retptr;
#line 5317
  sptr = s;
  }
#line 5318
  if ((int )*sptr == 45) {
#line 5319
    tmp___1 = dptr;
#line 5319
    dptr ++;
#line 5319
    tmp___2 = sptr;
#line 5319
    sptr ++;
#line 5319
    *tmp___1 = *tmp___2;
  }
  {
#line 5320
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 5320
    if (! ndigits_int) {
#line 5320
      goto while_break___1;
    }
#line 5321
    tmp___3 = dptr;
#line 5321
    dptr ++;
#line 5321
    tmp___4 = sptr;
#line 5321
    sptr ++;
#line 5321
    *tmp___3 = *tmp___4;
#line 5322
    ndigits_int --;
#line 5322
    if (ndigits_int) {
#line 5322
      if (! (ndigits_int % underscore)) {
#line 5323
        tmp___5 = dptr;
#line 5323
        dptr ++;
#line 5323
        *tmp___5 = (char )'_';
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 5325
  if (ndigits_frac) {
#line 5329
    mod = 0;
#line 5331
    tmp___6 = dptr;
#line 5331
    dptr ++;
#line 5331
    tmp___7 = sptr;
#line 5331
    sptr ++;
#line 5331
    *tmp___6 = *tmp___7;
    {
#line 5332
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 5332
      if (! ndigits_frac) {
#line 5332
        goto while_break___2;
      }
#line 5333
      tmp___8 = dptr;
#line 5333
      dptr ++;
#line 5333
      tmp___9 = sptr;
#line 5333
      sptr ++;
#line 5333
      *tmp___8 = *tmp___9;
#line 5334
      mod ++;
#line 5335
      ndigits_frac --;
#line 5335
      if (ndigits_frac) {
#line 5335
        if (mod == underscore) {
#line 5336
          tmp___10 = dptr;
#line 5336
          dptr ++;
#line 5336
          *tmp___10 = (char )'_';
#line 5337
          mod = 0;
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 5342
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 5342
    tmp___11 = dptr;
#line 5342
    dptr ++;
#line 5342
    tmp___13 = sptr;
#line 5342
    sptr ++;
#line 5342
    tmp___12 = *tmp___13;
#line 5342
    *tmp___11 = tmp___12;
#line 5342
    if (! tmp___12) {
#line 5342
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 5344
  return (retptr);
}
}
#line 5350 "/tmp/zsh-5.4.2/Src/params.c"
void startparamscope(void) 
{ 


  {
#line 5353
  locallevel ++;
#line 5354
  return;
}
}
#line 5359 "/tmp/zsh-5.4.2/Src/params.c"
void endparamscope(void) 
{ 
  sigset_t oset ;

  {
  {
#line 5362
  queueing_enabled ++;
#line 5363
  locallevel --;
#line 5365
  saveandpophiststack(0, 32768);
#line 5366
  scanhashtable(paramtab, 0, 0, 0, & scanendscope, 0);
  }
  {
#line 5367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5367
    queueing_enabled --;
#line 5367
    if (! queueing_enabled) {
      {
#line 5367
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 5367
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 5367
          if (! (queue_front != queue_rear)) {
#line 5367
            goto while_break___1;
          }
          {
#line 5367
          queue_front = (queue_front + 1) % 128;
#line 5367
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 5367
          zhandler(signal_queue[queue_front]);
#line 5367
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 5367
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 5367
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5368
  return;
}
}
#line 5371 "/tmp/zsh-5.4.2/Src/params.c"
static void scanendscope(HashNode hn , int flags  __attribute__((__unused__)) ) 
{ 
  Param pm ;
  Param tpm ;
  int tmp ;

  {
#line 5374
  pm = (Param )hn;
#line 5375
  if (pm->level > locallevel) {
#line 5376
    if ((pm->node.flags & ((1 << 22) | (1 << 26))) == 1 << 22) {
      {
#line 5385
      tpm = pm->old;
#line 5387
      tmp = strcmp((char const   *)pm->node.nam, "SECONDS");
      }
#line 5387
      if (! tmp) {
        {
#line 5389
        setsecondstype(pm, tpm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4)),
                       pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4)));
#line 5394
        setrawseconds(tpm->u.dval);
#line 5395
        tpm->node.flags |= 1 << 28;
        }
      }
#line 5400
      pm->old = tpm->old;
#line 5401
      pm->node.flags = tpm->node.flags & ~ (1 << 28);
#line 5402
      pm->level = tpm->level;
#line 5403
      pm->base = tpm->base;
#line 5404
      pm->width = tpm->width;
#line 5405
      if (pm->env) {
        {
#line 5406
        delenv(pm);
        }
      }
#line 5408
      if (! (tpm->node.flags & ((1 << 28) | (1 << 10)))) {
        {
#line 5410
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 5410
          goto case_0;
        }
#line 5413
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 5413
          goto case_exp;
        }
#line 5417
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 5417
          goto case_exp___0;
        }
#line 5417
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 5417
          goto case_exp___0;
        }
#line 5420
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 5420
          goto case_1;
        }
#line 5423
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
#line 5423
          goto case_exp___2;
        }
#line 5409
        goto switch_break;
        case_0: /* CIL Label */ 
        {
#line 5411
        (*((pm->gsu.s)->setfn))(pm, tpm->u.str);
        }
#line 5412
        goto switch_break;
        case_exp: /* CIL Label */ 
        {
#line 5414
        (*((pm->gsu.i)->setfn))(pm, tpm->u.val);
        }
#line 5415
        goto switch_break;
        case_exp___0: /* CIL Label */ 
        case_exp___1: /* CIL Label */ 
        {
#line 5418
        (*((pm->gsu.f)->setfn))(pm, tpm->u.dval);
        }
#line 5419
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 5421
        (*((pm->gsu.a)->setfn))(pm, tpm->u.arr);
        }
#line 5422
        goto switch_break;
        case_exp___2: /* CIL Label */ 
        {
#line 5424
        (*((pm->gsu.h)->setfn))(pm, tpm->u.hash);
        }
#line 5425
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
      {
#line 5427
      zfree((void *)tpm, (int )sizeof(*tpm));
      }
#line 5429
      if (pm->node.flags & (1 << 12)) {
        {
#line 5430
        export_param(pm);
        }
      }
    } else {
      {
#line 5432
      unsetparam_pm(pm, 0, 0);
      }
    }
  }
#line 5434
  return;
}
}
#line 5442 "/tmp/zsh-5.4.2/Src/params.c"
void freeparamnode(HashNode hn ) 
{ 
  Param pm ;

  {
#line 5445
  pm = (Param )hn;
#line 5452
  if (delunset) {
    {
#line 5453
    (*((pm->gsu.s)->unsetfn))(pm, 1);
    }
  }
  {
#line 5454
  zsfree(pm->node.nam);
  }
#line 5456
  if (pm->node.flags & (1 << 16)) {
    {
#line 5457
    zsfree(pm->ename);
    }
  }
  {
#line 5458
  zfree((void *)pm, (int )sizeof(struct param ));
  }
#line 5459
  return;
}
}
#line 5476 "/tmp/zsh-5.4.2/Src/params.c"
static struct paramtypes  const  pmtypes[15]  = 
#line 5476
  {      {1 << 27, "undefined", 0, 0}, 
        {1 << 1, "integer", 'i', 1}, 
        {1 << 2, "float", 'E', 0}, 
        {1 << 3, "float", 'F', 0}, 
        {1, "array", 'a', 0}, 
        {1 << 4, "association", 'A', 0}, 
        {0, "local", 0, 4}, 
        {1 << 5, "left justified", 'L', 2}, 
        {1 << 6, "right justified", 'R', 2}, 
        {1 << 7, "zero filled", 'Z', 2}, 
        {1 << 8, "lowercase", 'l', 0}, 
        {1 << 9, "uppercase", 'u', 0}, 
        {1 << 10, "readonly", 'r', 0}, 
        {1 << 11, "tagged", 't', 0}, 
        {1 << 12, "exported", 'x', 0}};
#line 5496 "/tmp/zsh-5.4.2/Src/params.c"
static void printparamvalue(Param p , int printflags ) 
{ 
  char *t ;
  char **u ;
  zlong tmp ;
  double tmp___0 ;
  char **tmp___1 ;
  char **tmp___2 ;
  HashTable ht ;
  HashTable tmp___3 ;

  {
#line 5501
  if (printflags & (1 << 3)) {
    {
#line 5502
    putchar(' ');
    }
  } else {
    {
#line 5504
    putchar('=');
    }
  }
  {
#line 5509
  if ((p->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 5509
    goto case_0;
  }
#line 5514
  if ((p->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 5514
    goto case_exp;
  }
#line 5523
  if ((p->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 5523
    goto case_exp___0;
  }
#line 5523
  if ((p->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 5523
    goto case_exp___0;
  }
#line 5527
  if ((p->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 5527
    goto case_1;
  }
#line 5546
  if ((p->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
#line 5546
    goto case_exp___2;
  }
#line 5508
  goto switch_break;
  case_0: /* CIL Label */ 
#line 5511
  if ((p->gsu.s)->getfn) {
    {
#line 5511
    t = (*((p->gsu.s)->getfn))(p);
    }
#line 5511
    if (t) {
      {
#line 5512
      quotedzputs((char const   *)t, stdout);
      }
    }
  }
#line 5513
  goto switch_break;
  case_exp: /* CIL Label */ 
  {
#line 5519
  tmp = (*((p->gsu.i)->getfn))(p);
#line 5519
  printf((char const   */* __restrict  */)"%ld", tmp);
  }
#line 5521
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  case_exp___1: /* CIL Label */ 
  {
#line 5525
  tmp___0 = (*((p->gsu.f)->getfn))(p);
#line 5525
  convfloat(tmp___0, p->base, p->node.flags, stdout);
  }
#line 5526
  goto switch_break;
  case_1: /* CIL Label */ 
#line 5529
  if (! (printflags & (1 << 3))) {
    {
#line 5530
    putchar('(');
#line 5531
    putchar(' ');
    }
  }
  {
#line 5533
  u = (*((p->gsu.a)->getfn))(p);
  }
#line 5534
  if (*u) {
    {
#line 5535
    tmp___1 = u;
#line 5535
    u ++;
#line 5535
    quotedzputs((char const   *)*tmp___1, stdout);
    }
    {
#line 5536
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5536
      if (! *u) {
#line 5536
        goto while_break;
      }
      {
#line 5537
      putchar(' ');
#line 5538
      tmp___2 = u;
#line 5538
      u ++;
#line 5538
      quotedzputs((char const   *)*tmp___2, stdout);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 5541
  if (! (printflags & (1 << 3))) {
    {
#line 5542
    putchar(' ');
#line 5543
    putchar(')');
    }
  }
#line 5545
  goto switch_break;
  case_exp___2: /* CIL Label */ 
#line 5548
  if (! (printflags & (1 << 3))) {
    {
#line 5549
    putchar('(');
#line 5550
    putchar(' ');
    }
  }
  {
#line 5553
  tmp___3 = (*((p->gsu.h)->getfn))(p);
#line 5553
  ht = tmp___3;
  }
#line 5554
  if (ht) {
    {
#line 5555
    scanhashtable(ht, 1, 0, 1 << 25, ht->printnode, 1 << 3);
    }
  }
#line 5558
  if (! (printflags & (1 << 3))) {
    {
#line 5559
    putchar(')');
    }
  }
#line 5560
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 5562
  if (printflags & (1 << 3)) {
    {
#line 5563
    putchar(' ');
    }
  } else {
    {
#line 5565
    putchar('\n');
    }
  }
#line 5566
  return;
}
}
#line 5569 "/tmp/zsh-5.4.2/Src/params.c"
void printparamnode(HashNode hn , int printflags ) 
{ 
  Param p ;
  int doneminus ;
  int i ;
  struct paramtypes  const  *pmptr ;
  int doprint ;

  {
#line 5572
  p = (Param )hn;
#line 5574
  if (p->node.flags & (1 << 25)) {
#line 5575
    if (opts[131]) {
#line 5575
      if (p->node.flags & (1 << 10)) {
#line 5575
        if (printflags & (1 << 5)) {
#line 5582
          printflags |= 1;
        } else {
#line 5575
          goto _L___0;
        }
      } else {
#line 5575
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 5584
    if (p->node.flags & (1 << 12)) {
#line 5585
      printflags |= 1;
    } else {
#line 5587
      return;
    }
  }
#line 5589
  if (p->node.flags & (1 << 27)) {
#line 5590
    printflags |= 1;
  }
#line 5592
  if (printflags & (1 << 5)) {
#line 5593
    if ((p->node.flags & ((1 << 10) | (1 << 22))) == ((1 << 10) | (1 << 22))) {
#line 5600
      return;
    } else
#line 5593
    if (p->node.flags & (1 << 27)) {
#line 5600
      return;
    }
#line 5602
    if (locallevel) {
#line 5602
      if (p->level >= locallevel) {
        {
#line 5603
        printf((char const   */* __restrict  */)"typeset ");
        }
      } else {
#line 5602
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 5604
    if (p->node.flags & (1 << 12)) {
#line 5604
      if (! (p->node.flags & (1 | (1 << 4)))) {
        {
#line 5606
        printf((char const   */* __restrict  */)"export ");
        }
      } else {
#line 5604
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 5607
    if (locallevel) {
      {
#line 5608
      printf((char const   */* __restrict  */)"typeset -g ");
      }
    } else {
      {
#line 5610
      printf((char const   */* __restrict  */)"typeset ");
      }
    }
  }
#line 5614
  if (printflags & ((1 << 1) | (1 << 5))) {
#line 5615
    doneminus = 0;
#line 5618
    pmptr = pmtypes;
#line 5618
    i = 0;
    {
#line 5618
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5618
      if (! (i < (int )(sizeof(pmtypes) / sizeof(struct paramtypes )))) {
#line 5618
        goto while_break;
      }
#line 5619
      doprint = 0;
#line 5620
      if (pmptr->flags & 4) {
#line 5621
        if (p->level) {
#line 5622
          doprint = 1;
        }
      } else
#line 5623
      if (pmptr->binflag != (int const   )(1 << 12)) {
#line 5623
        goto _L___3;
      } else
#line 5623
      if (p->level) {
#line 5623
        goto _L___3;
      } else
#line 5623
      if (p->node.flags & (((1 << 21) | 1) | (1 << 4))) {
        _L___3: /* CIL Label */ 
#line 5623
        if (p->node.flags & (int )pmptr->binflag) {
#line 5626
          doprint = 1;
        }
      }
#line 5628
      if (doprint) {
#line 5629
        if (printflags & (1 << 5)) {
#line 5630
          if (pmptr->typeflag) {
#line 5631
            if (! doneminus) {
              {
#line 5632
              putchar('-');
#line 5633
              doneminus = 1;
              }
            }
            {
#line 5635
            putchar((int )pmptr->typeflag);
            }
          }
        } else {
          {
#line 5638
          printf((char const   */* __restrict  */)"%s ", pmptr->string);
          }
        }
#line 5639
        if (pmptr->flags & 1) {
#line 5639
          if (p->base) {
            {
#line 5640
            printf((char const   */* __restrict  */)"%d ", p->base);
#line 5641
            doneminus = 0;
            }
          }
        }
#line 5643
        if (pmptr->flags & 2) {
#line 5643
          if (p->width) {
            {
#line 5644
            printf((char const   */* __restrict  */)"%d ", p->width);
#line 5645
            doneminus = 0;
            }
          }
        }
      }
#line 5618
      i ++;
#line 5618
      pmptr ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 5649
    if (doneminus) {
      {
#line 5650
      putchar(' ');
      }
    }
  }
#line 5653
  if (printflags & 1) {
    {
#line 5655
    zputs((char const   *)p->node.nam, stdout);
#line 5656
    putchar('\n');
    }
  } else
#line 5653
  if (p->node.flags & (1 << 15)) {
#line 5653
    if (! (printflags & (1 << 4))) {
      {
#line 5655
      zputs((char const   *)p->node.nam, stdout);
#line 5656
      putchar('\n');
      }
    } else {
      {
#line 5658
      quotedzputs((char const   *)p->node.nam, stdout);
#line 5660
      printparamvalue(p, printflags);
      }
    }
  } else {
    {
#line 5658
    quotedzputs((char const   *)p->node.nam, stdout);
#line 5660
    printparamvalue(p, printflags);
    }
  }
#line 5662
  return;
}
}
#line 637 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 632 "/usr/include/stdio.h"
extern int puts(char const   *__s ) ;
#line 10 "./hashtable.epro"
extern HashNode gethashnode(HashTable ht , char const   *nam ) ;
#line 15
extern int scanmatchtable(HashTable ht , Patprog pprog , int sorted , int flags1 ,
                          int flags2 , void (*scanfunc)(HashNode  , int  ) , int scanflags ) ;
#line 5 "./jobs.epro"
pid_t origpgrp ;
#line 60
void acquire_pgrp(void) ;
#line 5 "./options.epro"
int emulation  ;
#line 6 "./options.epro"
Emulation_options sticky  ;
#line 7 "./options.epro"
char opts[180]  ;
#line 8 "./options.epro"
HashTable optiontab  ;
#line 9
void createoptiontable(void) ;
#line 10
void installemulation(int new_emulation , char *new_opts ) ;
#line 11
void emulate(char const   *zsh_name , int fully , int *new_emulation , char *new_opts ) ;
#line 12
int bin_setopt(char *nam , char **args , Options ops  __attribute__((__unused__)) ,
               int isun ) ;
#line 13
int optlookup(char const   *name ) ;
#line 14
int optlookupc(char c ) ;
#line 15
int dosetopt(int optno , int value , int force , char *new_opts ) ;
#line 17
void printoptionstates(int hadplus ) ;
#line 18
void printoptionlist(void) ;
#line 19
void list_emulate_options(char *cmdopts , int fully ) ;
#line 2 "./options.pro"
static void printoptionnode(HashNode hn , int set ) ;
#line 3 "./options.pro"
static char *setemulate_opts  ;
#line 4
static void setemulate(HashNode hn , int fully ) ;
#line 5
static void setoption(HashNode hn , int value ) ;
#line 6
static void restrictparam(char *nam ) ;
#line 7
static void printoptionnodestate(HashNode hn , int hadplus ) ;
#line 8
static void printoptionlist_printoption(HashNode hn , int ignored  __attribute__((__unused__)) ) ;
#line 9
static void printoptionlist_printequiv(int optno ) ;
#line 10 "./options.pro"
static char *print_emulate_opts  ;
#line 11
static void print_emulate_option(HashNode hn , int fully ) ;
#line 79 "/tmp/zsh-5.4.2/Src/options.c"
static struct optname optns[192]  = 
#line 79 "/tmp/zsh-5.4.2/Src/options.c"
  {      {{(HashNode )((void *)0), (char *)"aliases", (1 << 6) | ((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4))},
      1}, 
        {{(HashNode )((void *)0), (char *)"aliasfuncdef", (1 << 6) | ((1 << 2) | (1 << 3))},
      2}, 
        {{(HashNode )((void *)0), (char *)"allexport", 1 << 6}, 3}, 
        {{(HashNode )((void *)0), (char *)"alwayslastprompt", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      4}, 
        {{(HashNode )((void *)0), (char *)"alwaystoend", 0}, 5}, 
        {{(HashNode )((void *)0), (char *)"appendcreate", (1 << 6) | ((1 << 2) | (1 << 3))},
      34}, 
        {{(HashNode )((void *)0), (char *)"appendhistory", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      6}, 
        {{(HashNode )((void *)0), (char *)"autocd", 1 << 6}, 7}, 
        {{(HashNode )((void *)0), (char *)"autocontinue", 0}, 8}, 
        {{(HashNode )((void *)0), (char *)"autolist", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      9}, 
        {{(HashNode )((void *)0), (char *)"automenu", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      10}, 
        {{(HashNode )((void *)0), (char *)"autonamedirs", 0}, 11}, 
        {{(HashNode )((void *)0), (char *)"autoparamkeys", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      12}, 
        {{(HashNode )((void *)0), (char *)"autoparamslash", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      13}, 
        {{(HashNode )((void *)0), (char *)"autopushd", 0}, 14}, 
        {{(HashNode )((void *)0), (char *)"autoremoveslash", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      15}, 
        {{(HashNode )((void *)0), (char *)"autoresume", 0}, 16}, 
        {{(HashNode )((void *)0), (char *)"badpattern", (1 << 6) | (((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) & ~ ((1 << 2) | (1 << 3)))},
      17}, 
        {{(HashNode )((void *)0), (char *)"banghist", ((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) & ~ ((1 << 2) | (1 << 3))},
      18}, 
        {{(HashNode )((void *)0), (char *)"bareglobqual", (1 << 6) | (1 << 4)}, 19}, 
        {{(HashNode )((void *)0), (char *)"bashautolist", 0}, 20}, 
        {{(HashNode )((void *)0), (char *)"bashrematch", 0}, 21}, 
        {{(HashNode )((void *)0), (char *)"beep", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      22}, 
        {{(HashNode )((void *)0), (char *)"bgnice", (1 << 6) | (((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) & ~ ((1 << 2) | (1 << 3)))},
      23}, 
        {{(HashNode )((void *)0), (char *)"braceccl", 1 << 6}, 24}, 
        {{(HashNode )((void *)0), (char *)"bsdecho", (1 << 6) | (1 << 3)}, 25}, 
        {{(HashNode )((void *)0), (char *)"caseglob", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      26}, 
        {{(HashNode )((void *)0), (char *)"casematch", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      27}, 
        {{(HashNode )((void *)0), (char *)"cbases", 0}, 28}, 
        {{(HashNode )((void *)0), (char *)"cprecedences", (1 << 6) | (((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) & ~ (1 << 4))},
      41}, 
        {{(HashNode )((void *)0), (char *)"cdablevars", 1 << 6}, 29}, 
        {{(HashNode )((void *)0), (char *)"chasedots", 1 << 6}, 30}, 
        {{(HashNode )((void *)0), (char *)"chaselinks", 1 << 6}, 31}, 
        {{(HashNode )((void *)0), (char *)"checkjobs", (1 << 6) | (1 << 4)}, 32}, 
        {{(HashNode )((void *)0), (char *)"clobber", (1 << 6) | ((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4))},
      33}, 
        {{(HashNode )((void *)0), (char *)"combiningchars", 0}, 35}, 
        {{(HashNode )((void *)0), (char *)"completealiases", 0}, 36}, 
        {{(HashNode )((void *)0), (char *)"completeinword", 0}, 37}, 
        {{(HashNode )((void *)0), (char *)"continueonerror", 0}, 40}, 
        {{(HashNode )((void *)0), (char *)"correct", 0}, 38}, 
        {{(HashNode )((void *)0), (char *)"correctall", 0}, 39}, 
        {{(HashNode )((void *)0), (char *)"cshjunkiehistory", (1 << 6) | (1 << 1)}, 42}, 
        {{(HashNode )((void *)0),
       (char *)"cshjunkieloops", (1 << 6) | (1 << 1)}, 43}, 
        {{(HashNode )((void *)0), (char *)"cshjunkiequotes", (1 << 6) | (1 << 1)}, 44}, 
        {{(HashNode )((void *)0),
       (char *)"cshnullcmd", (1 << 6) | (1 << 1)}, 45}, 
        {{(HashNode )((void *)0), (char *)"cshnullglob", (1 << 6) | (1 << 1)}, 46}, 
        {{(HashNode )((void *)0), (char *)"debugbeforecmd", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      47}, 
        {{(HashNode )((void *)0), (char *)"emacs", 0}, 48}, 
        {{(HashNode )((void *)0), (char *)"equals", (1 << 6) | (1 << 4)}, 49}, 
        {{(HashNode )((void *)0), (char *)"errexit", 1 << 6}, 50}, 
        {{(HashNode )((void *)0), (char *)"errreturn", 1 << 6}, 51}, 
        {{(HashNode )((void *)0), (char *)"exec", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      52}, 
        {{(HashNode )((void *)0), (char *)"extendedglob", 1 << 6}, 53}, 
        {{(HashNode )((void *)0), (char *)"extendedhistory", 1 << 1}, 54}, 
        {{(HashNode )((void *)0), (char *)"evallineno", (1 << 6) | (1 << 4)}, 55}, 
        {{(HashNode )((void *)0), (char *)"flowcontrol", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      56}, 
        {{(HashNode )((void *)0), (char *)"forcefloat", 0}, 57}, 
        {{(HashNode )((void *)0), (char *)"functionargzero", (1 << 6) | (((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) & ~ ((1 << 2) | (1 << 3)))},
      58}, 
        {{(HashNode )((void *)0), (char *)"glob", (1 << 6) | ((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4))},
      59}, 
        {{(HashNode )((void *)0), (char *)"globalexport", (1 << 6) | (1 << 4)}, 60}, 
        {{(HashNode )((void *)0), (char *)"globalrcs", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      61}, 
        {{(HashNode )((void *)0), (char *)"globassign", (1 << 6) | (1 << 1)}, 62}, 
        {{(HashNode )((void *)0), (char *)"globcomplete", 0}, 63}, 
        {{(HashNode )((void *)0), (char *)"globdots", 1 << 6}, 64}, 
        {{(HashNode )((void *)0), (char *)"globstarshort", 1 << 6}, 65}, 
        {{(HashNode )((void *)0), (char *)"globsubst", (1 << 6) | (((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) & ~ (1 << 4))},
      66}, 
        {{(HashNode )((void *)0), (char *)"hashcmds", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      67}, 
        {{(HashNode )((void *)0), (char *)"hashdirs", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      68}, 
        {{(HashNode )((void *)0), (char *)"hashexecutablesonly", 0}, 69}, 
        {{(HashNode )((void *)0), (char *)"hashlistall", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      70}, 
        {{(HashNode )((void *)0), (char *)"histallowclobber", 0}, 71}, 
        {{(HashNode )((void *)0), (char *)"histbeep", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      72}, 
        {{(HashNode )((void *)0), (char *)"histexpiredupsfirst", 0}, 73}, 
        {{(HashNode )((void *)0), (char *)"histfcntllock", 0}, 74}, 
        {{(HashNode )((void *)0), (char *)"histfindnodups", 0}, 75}, 
        {{(HashNode )((void *)0), (char *)"histignorealldups", 0}, 76}, 
        {{(HashNode )((void *)0), (char *)"histignoredups", 0}, 77}, 
        {{(HashNode )((void *)0), (char *)"histignorespace", 0}, 78}, 
        {{(HashNode )((void *)0), (char *)"histlexwords", 0}, 79}, 
        {{(HashNode )((void *)0), (char *)"histnofunctions", 0}, 80}, 
        {{(HashNode )((void *)0), (char *)"histnostore", 0}, 81}, 
        {{(HashNode )((void *)0), (char *)"histsubstpattern", 1 << 6}, 85}, 
        {{(HashNode )((void *)0), (char *)"histreduceblanks", 0}, 82}, 
        {{(HashNode )((void *)0), (char *)"histsavebycopy", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      83}, 
        {{(HashNode )((void *)0), (char *)"histsavenodups", 0}, 84}, 
        {{(HashNode )((void *)0), (char *)"histverify", 0}, 86}, 
        {{(HashNode )((void *)0), (char *)"hup", (1 << 6) | (1 << 4)}, 87}, 
        {{(HashNode )((void *)0), (char *)"ignorebraces", (1 << 6) | (1 << 3)}, 88}, 
        {{(HashNode )((void *)0), (char *)"ignoreclosebraces", 1 << 6}, 89}, 
        {{(HashNode )((void *)0), (char *)"ignoreeof", 0}, 90}, 
        {{(HashNode )((void *)0), (char *)"incappendhistory", 0}, 91}, 
        {{(HashNode )((void *)0), (char *)"incappendhistorytime", 0}, 92}, 
        {{(HashNode )((void *)0), (char *)"interactive", (1 << 6) << 1}, 93}, 
        {{(HashNode )((void *)0), (char *)"interactivecomments", (1 << 2) | (1 << 3)},
      94}, 
        {{(HashNode )((void *)0), (char *)"ksharrays", (1 << 6) | ((1 << 2) | (1 << 3))},
      95}, 
        {{(HashNode )((void *)0), (char *)"kshautoload", (1 << 6) | ((1 << 2) | (1 << 3))},
      96}, 
        {{(HashNode )((void *)0), (char *)"kshglob", (1 << 6) | (1 << 2)}, 97}, 
        {{(HashNode )((void *)0), (char *)"kshoptionprint", (1 << 6) | (1 << 2)}, 98}, 
        {{(HashNode )((void *)0),
       (char *)"kshtypeset", 0}, 99}, 
        {{(HashNode )((void *)0), (char *)"kshzerosubscript", 0}, 100}, 
        {{(HashNode )((void *)0), (char *)"listambiguous", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      101}, 
        {{(HashNode )((void *)0), (char *)"listbeep", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      102}, 
        {{(HashNode )((void *)0), (char *)"listpacked", 0}, 103}, 
        {{(HashNode )((void *)0), (char *)"listrowsfirst", 0}, 104}, 
        {{(HashNode )((void *)0), (char *)"listtypes", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      105}, 
        {{(HashNode )((void *)0), (char *)"localoptions", (1 << 6) | (1 << 2)}, 107}, 
        {{(HashNode )((void *)0),
       (char *)"localloops", 1 << 6}, 106}, 
        {{(HashNode )((void *)0), (char *)"localpatterns", 1 << 6}, 108}, 
        {{(HashNode )((void *)0), (char *)"localtraps", (1 << 6) | (1 << 2)}, 109}, 
        {{(HashNode )((void *)0), (char *)"login", (1 << 6) << 1}, 110}, 
        {{(HashNode )((void *)0), (char *)"longlistjobs", 0}, 111}, 
        {{(HashNode )((void *)0), (char *)"magicequalsubst", 1 << 6}, 112}, 
        {{(HashNode )((void *)0), (char *)"mailwarning", 0}, 113}, 
        {{(HashNode )((void *)0), (char *)"markdirs", 0}, 114}, 
        {{(HashNode )((void *)0), (char *)"menucomplete", 0}, 115}, 
        {{(HashNode )((void *)0), (char *)"monitor", (1 << 6) << 1}, 116}, 
        {{(HashNode )((void *)0), (char *)"multibyte", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      117}, 
        {{(HashNode )((void *)0), (char *)"multifuncdef", (1 << 6) | (1 << 4)}, 118}, 
        {{(HashNode )((void *)0),
       (char *)"multios", (1 << 6) | (1 << 4)}, 119}, 
        {{(HashNode )((void *)0), (char *)"nomatch", (1 << 6) | (((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) & ~ ((1 << 2) | (1 << 3)))},
      120}, 
        {{(HashNode )((void *)0), (char *)"notify", 1 << 4}, 121}, 
        {{(HashNode )((void *)0), (char *)"nullglob", 1 << 6}, 122}, 
        {{(HashNode )((void *)0), (char *)"numericglobsort", 1 << 6}, 123}, 
        {{(HashNode )((void *)0), (char *)"octalzeroes", (1 << 6) | (1 << 3)}, 124}, 
        {{(HashNode )((void *)0), (char *)"overstrike", 0}, 125}, 
        {{(HashNode )((void *)0), (char *)"pathdirs", 1 << 6}, 126}, 
        {{(HashNode )((void *)0), (char *)"pathscript", (1 << 6) | ((1 << 2) | (1 << 3))},
      127}, 
        {{(HashNode )((void *)0), (char *)"pipefail", 1 << 6}, 128}, 
        {{(HashNode )((void *)0), (char *)"posixaliases", (1 << 6) | ((1 << 2) | (1 << 3))},
      129}, 
        {{(HashNode )((void *)0), (char *)"posixargzero", 1 << 6}, 130}, 
        {{(HashNode )((void *)0), (char *)"posixbuiltins", (1 << 6) | ((1 << 2) | (1 << 3))},
      131}, 
        {{(HashNode )((void *)0), (char *)"posixcd", (1 << 6) | ((1 << 2) | (1 << 3))},
      132}, 
        {{(HashNode )((void *)0), (char *)"posixidentifiers", (1 << 6) | ((1 << 2) | (1 << 3))},
      133}, 
        {{(HashNode )((void *)0), (char *)"posixjobs", (1 << 6) | ((1 << 2) | (1 << 3))},
      134}, 
        {{(HashNode )((void *)0), (char *)"posixstrings", (1 << 6) | ((1 << 2) | (1 << 3))},
      135}, 
        {{(HashNode )((void *)0), (char *)"posixtraps", (1 << 6) | ((1 << 2) | (1 << 3))},
      136}, 
        {{(HashNode )((void *)0), (char *)"printeightbit", 0}, 137}, 
        {{(HashNode )((void *)0), (char *)"printexitvalue", 0}, 138}, 
        {{(HashNode )((void *)0), (char *)"privileged", (1 << 6) << 1}, 139}, 
        {{(HashNode )((void *)0), (char *)"promptbang", 1 << 2}, 140}, 
        {{(HashNode )((void *)0), (char *)"promptcr", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      141}, 
        {{(HashNode )((void *)0), (char *)"promptpercent", ((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) & ~ ((1 << 2) | (1 << 3))},
      142}, 
        {{(HashNode )((void *)0), (char *)"promptsp", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      143}, 
        {{(HashNode )((void *)0), (char *)"promptsubst", (1 << 2) | (1 << 3)}, 144}, 
        {{(HashNode )((void *)0), (char *)"pushdignoredups", 1 << 6}, 145}, 
        {{(HashNode )((void *)0), (char *)"pushdminus", 1 << 6}, 146}, 
        {{(HashNode )((void *)0), (char *)"pushdsilent", 0}, 147}, 
        {{(HashNode )((void *)0), (char *)"pushdtohome", 1 << 6}, 148}, 
        {{(HashNode )((void *)0), (char *)"rcexpandparam", 1 << 6}, 149}, 
        {{(HashNode )((void *)0), (char *)"rcquotes", 1 << 6}, 150}, 
        {{(HashNode )((void *)0), (char *)"rcs", (((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)},
      151}, 
        {{(HashNode )((void *)0), (char *)"recexact", 0}, 152}, 
        {{(HashNode )((void *)0), (char *)"rematchpcre", 0}, 153}, 
        {{(HashNode )((void *)0), (char *)"restricted", (1 << 6) << 1}, 154}, 
        {{(HashNode )((void *)0), (char *)"rmstarsilent", (1 << 2) | (1 << 3)}, 155}, 
        {{(HashNode )((void *)0),
       (char *)"rmstarwait", 0}, 156}, 
        {{(HashNode )((void *)0), (char *)"sharehistory", 1 << 2}, 157}, 
        {{(HashNode )((void *)0), (char *)"shfileexpansion", (1 << 6) | ((1 << 2) | (1 << 3))},
      158}, 
        {{(HashNode )((void *)0), (char *)"shglob", (1 << 6) | ((1 << 2) | (1 << 3))},
      159}, 
        {{(HashNode )((void *)0), (char *)"shinstdin", (1 << 6) << 1}, 160}, 
        {{(HashNode )((void *)0), (char *)"shnullcmd", (1 << 6) | ((1 << 2) | (1 << 3))},
      161}, 
        {{(HashNode )((void *)0), (char *)"shoptionletters", (1 << 6) | ((1 << 2) | (1 << 3))},
      162}, 
        {{(HashNode )((void *)0), (char *)"shortloops", (1 << 6) | (((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) & ~ ((1 << 2) | (1 << 3)))},
      163}, 
        {{(HashNode )((void *)0), (char *)"shwordsplit", (1 << 6) | ((1 << 2) | (1 << 3))},
      164}, 
        {{(HashNode )((void *)0), (char *)"singlecommand", (1 << 6) << 1}, 165}, 
        {{(HashNode )((void *)0), (char *)"singlelinezle", 1 << 2}, 166}, 
        {{(HashNode )((void *)0), (char *)"sourcetrace", 0}, 167}, 
        {{(HashNode )((void *)0), (char *)"sunkeyboardhack", 0}, 168}, 
        {{(HashNode )((void *)0), (char *)"transientrprompt", 0}, 169}, 
        {{(HashNode )((void *)0), (char *)"trapsasync", 0}, 170}, 
        {{(HashNode )((void *)0), (char *)"typesetsilent", (1 << 6) | ((1 << 2) | (1 << 3))},
      171}, 
        {{(HashNode )((void *)0), (char *)"unset", (1 << 6) | (((1 << 2) | (1 << 3)) | (1 << 4))},
      172}, 
        {{(HashNode )((void *)0), (char *)"verbose", 0}, 173}, 
        {{(HashNode )((void *)0), (char *)"vi", 0}, 174}, 
        {{(HashNode )((void *)0), (char *)"warncreateglobal", 1 << 6}, 175}, 
        {{(HashNode )((void *)0), (char *)"warnnestedvar", 1 << 6}, 176}, 
        {{(HashNode )((void *)0), (char *)"xtrace", 0}, 177}, 
        {{(HashNode )((void *)0), (char *)"zle", (1 << 6) << 1}, 178}, 
        {{(HashNode )((void *)0), (char *)"braceexpand", (1 << 6) << 2}, -88}, 
        {{(HashNode )((void *)0), (char *)"dotglob", (1 << 6) << 2}, 64}, 
        {{(HashNode )((void *)0), (char *)"hashall", (1 << 6) << 2}, 67}, 
        {{(HashNode )((void *)0), (char *)"histappend", (1 << 6) << 2}, 6}, 
        {{(HashNode )((void *)0), (char *)"histexpand", (1 << 6) << 2}, 18}, 
        {{(HashNode )((void *)0), (char *)"log", (1 << 6) << 2}, -80}, 
        {{(HashNode )((void *)0), (char *)"mailwarn", (1 << 6) << 2}, 113}, 
        {{(HashNode )((void *)0), (char *)"onecmd", (1 << 6) << 2}, 165}, 
        {{(HashNode )((void *)0), (char *)"physical", (1 << 6) << 2}, 31}, 
        {{(HashNode )((void *)0), (char *)"promptvars", (1 << 6) << 2}, 144}, 
        {{(HashNode )((void *)0), (char *)"stdin", (1 << 6) << 2}, 160}, 
        {{(HashNode )((void *)0), (char *)"trackall", (1 << 6) << 2}, 67}, 
        {{(HashNode )((void *)0), (char *)"dvorak", 0}, 179}, 
        {{(HashNode )((void *)0), (char *)((void *)0), 0}, 0}};
#line 287 "/tmp/zsh-5.4.2/Src/options.c"
static short zshletters[74]  = 
#line 287
  {      (short)38,      (short)138,      (short)-17,      (short)-120, 
        (short)64,      (short)121,      (short)23,      (short)90, 
        (short)114,      (short)9,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)-22,      (short)-33, 
        (short)148,      (short)147,      (short)-59,      (short)122, 
        (short)155,      (short)88,      (short)7,      (short)-18, 
        (short)168,      (short)166,      (short)14,      (short)39, 
        (short)149,      (short)126,      (short)111,      (short)152, 
        (short)29,      (short)113,      (short)-141,      (short)16, 
        (short)105,      (short)115,      (short)178,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)3,      (short)0,      (short)0, 
        (short)-61,      (short)50,      (short)-151,      (short)78, 
        (short)77,      (short)93,      (short)0,      (short)94, 
        (short)110,      (short)116,      (short)-52,      (short)0, 
        (short)139,      (short)0,      (short)154,      (short)160, 
        (short)165,      (short)-172,      (short)173,      (short)31, 
        (short)177,      (short)164};
#line 364 "/tmp/zsh-5.4.2/Src/options.c"
static short kshletters[74]  = 
#line 364
  {      (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)-33, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)170,      (short)0,      (short)0,      (short)0, 
        (short)114,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)3,      (short)121,      (short)0, 
        (short)0,      (short)50,      (short)-59,      (short)0, 
        (short)0,      (short)93,      (short)0,      (short)0, 
        (short)110,      (short)116,      (short)-52,      (short)0, 
        (short)139,      (short)0,      (short)154,      (short)160, 
        (short)165,      (short)-172,      (short)173,      (short)0, 
        (short)177,      (short)0};
#line 444 "/tmp/zsh-5.4.2/Src/options.c"
static void printoptionnode(HashNode hn , int set ) 
{ 
  Optname on ;
  int optno ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 447
  on = (Optname )hn;
#line 448
  optno = on->optno;
#line 450
  if (optno < 0) {
#line 451
    optno = - optno;
  }
#line 452
  if (opts[98]) {
#line 453
    if (! (! (on->node.flags & emulation))) {
#line 454
      if (opts[optno]) {
#line 454
        tmp = "off";
      } else {
#line 454
        tmp = "on";
      }
      {
#line 454
      printf((char const   */* __restrict  */)"no%-19s %s\n", on->node.nam, tmp);
      }
    } else {
#line 456
      if (opts[optno]) {
#line 456
        tmp___0 = "on";
      } else {
#line 456
        tmp___0 = "off";
      }
      {
#line 456
      printf((char const   */* __restrict  */)"%-21s %s\n", on->node.nam, tmp___0);
      }
    }
  } else
#line 457
  if (set == ((int )opts[optno] ^ ! (! (on->node.flags & emulation)))) {
#line 458
    if (set ^ (int )opts[optno]) {
      {
#line 459
      fputs((char const   */* __restrict  */)"no", (FILE */* __restrict  */)stdout);
      }
    }
    {
#line 460
    puts((char const   *)on->node.nam);
    }
  }
#line 462
  return;
}
}
#line 465 "/tmp/zsh-5.4.2/Src/options.c"
void createoptiontable(void) 
{ 
  Optname on ;

  {
  {
#line 470
  optiontab = newhashtable(101, "optiontab", (void (*)(HashTable  ))((void *)0));
#line 472
  optiontab->hash = & hasher;
#line 473
  optiontab->emptytable = (void (*)(HashTable  ))((void *)0);
#line 474
  optiontab->filltable = (void (*)(HashTable  ))((void *)0);
#line 475
  optiontab->cmpnodes = (int (*)(char const   * , char const   * ))(& strcmp);
#line 476
  optiontab->addnode = & addhashnode;
#line 477
  optiontab->getnode = & gethashnode;
#line 478
  optiontab->getnode2 = & gethashnode2;
#line 479
  optiontab->removenode = (HashNode (*)(HashTable  , char const   * ))((void *)0);
#line 480
  optiontab->disablenode = & disablehashnode;
#line 481
  optiontab->enablenode = & enablehashnode;
#line 482
  optiontab->freenode = (void (*)(HashNode  ))((void *)0);
#line 483
  optiontab->printnode = & printoptionnode;
#line 485
  on = optns;
  }
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! on->node.nam) {
#line 485
      goto while_break;
    }
    {
#line 486
    (*(optiontab->addnode))(optiontab, on->node.nam, (void *)on);
#line 485
    on ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 487
  return;
}
}
#line 491 "/tmp/zsh-5.4.2/Src/options.c"
static int setemulate_emulation  ;
#line 501 "/tmp/zsh-5.4.2/Src/options.c"
static void setemulate(HashNode hn , int fully ) 
{ 
  Optname on ;

  {
#line 504
  on = (Optname )hn;
#line 510
  if (! (on->node.flags & ((1 << 6) << 2))) {
#line 510
    if (fully) {
#line 510
      if (! (on->node.flags & ((1 << 6) << 1))) {
#line 513
        *(setemulate_opts + on->optno) = (char )(! (! (on->node.flags & setemulate_emulation)));
      } else {
#line 510
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 510
    if (on->node.flags & (1 << 6)) {
#line 513
      *(setemulate_opts + on->optno) = (char )(! (! (on->node.flags & setemulate_emulation)));
    }
  }
#line 514
  return;
}
}
#line 517 "/tmp/zsh-5.4.2/Src/options.c"
void installemulation(int new_emulation , char *new_opts ) 
{ 


  {
  {
#line 520
  setemulate_emulation = new_emulation;
#line 521
  setemulate_opts = new_opts;
#line 522
  scanhashtable(optiontab, 0, 0, 0, & setemulate, ! (! (new_emulation & (1 << 5))));
  }
#line 524
  return;
}
}
#line 527 "/tmp/zsh-5.4.2/Src/options.c"
void emulate(char const   *zsh_name , int fully , int *new_emulation , char *new_opts ) 
{ 
  char ch ;
  Shfunc shf ;
  HashNode tmp ;

  {
#line 530
  ch = (char )*zsh_name;
#line 532
  if ((int )ch == 114) {
#line 533
    ch = (char )*(zsh_name + 1);
  }
#line 536
  if ((int )ch == 99) {
#line 537
    *new_emulation = 1 << 1;
  } else
#line 538
  if ((int )ch == 107) {
#line 539
    *new_emulation = 1 << 2;
  } else
#line 540
  if ((int )ch == 115) {
#line 541
    *new_emulation = 1 << 3;
  } else
#line 540
  if ((int )ch == 98) {
#line 541
    *new_emulation = 1 << 3;
  } else {
#line 543
    *new_emulation = 1 << 4;
  }
#line 545
  if (fully) {
#line 546
    *new_emulation |= 1 << 5;
  }
  {
#line 547
  installemulation(*new_emulation, new_opts);
  }
#line 549
  if (funcstack) {
#line 549
    if (funcstack->tp == 1) {
      {
#line 556
      tmp = (*(shfunctab->getnode))(shfunctab, (char const   *)funcstack->name);
#line 556
      shf = (Shfunc )tmp;
      }
#line 557
      if (shf) {
#line 557
        if (shf->node.flags & ((1 << 11) | (1 << 16))) {
#line 559
          *(new_opts + 177) = (char)1;
        }
      }
    }
  }
#line 562
  return;
}
}
#line 567 "/tmp/zsh-5.4.2/Src/options.c"
static void setoption(HashNode hn , int value ) 
{ 


  {
  {
#line 570
  dosetopt(((Optname )hn)->optno, value, 0, opts);
  }
#line 571
  return;
}
}
#line 574 "/tmp/zsh-5.4.2/Src/options.c"
int bin_setopt(char *nam , char **args , Options ops  __attribute__((__unused__)) ,
               int isun ) 
{ 
  int action ;
  int optno ;
  int match ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  Patprog pprog ;
  char *s ;
  char *t ;

  {
#line 577
  match = 0;
#line 580
  if (! *args) {
    {
#line 581
    scanhashtable(optiontab, 1, 0, (1 << 6) << 2, optiontab->printnode, ! isun);
    }
#line 582
    return (0);
  }
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (*args) {
#line 586
      if (! ((int )*(*args) == 45)) {
#line 586
        if (! ((int )*(*args) == 43)) {
#line 586
          goto while_break;
        }
      }
    } else {
#line 586
      goto while_break;
    }
#line 587
    action = ((int )*(*args) == 45) ^ isun;
#line 588
    if (! *(*(args + 0) + 1)) {
#line 589
      *args = (char *)"--";
    }
    {
#line 590
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 590
      (*args) ++;
#line 590
      if (! *(*args)) {
#line 590
        goto while_break___0;
      }
#line 591
      if ((int )*(*args) == -125) {
#line 592
        (*args) ++;
#line 592
        *(*args) = (char )((int )*(*args) ^ 32);
      }
#line 594
      if ((int )*(*args) == 45) {
#line 595
        args ++;
#line 596
        goto doneoptions;
      } else
#line 597
      if ((int )*(*args) == 111) {
#line 598
        (*args) ++;
#line 598
        if (! *(*args)) {
#line 599
          args ++;
        }
#line 600
        if (! *args) {
          {
#line 601
          zwarnnam((char const   *)nam, "string expected after -o");
#line 602
          inittyptab();
          }
#line 603
          return (1);
        }
        {
#line 605
        optno = optlookup((char const   *)*args);
        }
#line 605
        if (optno) {
          {
#line 607
          tmp = dosetopt(optno, action, 0, opts);
          }
#line 607
          if (tmp) {
            {
#line 608
            zwarnnam((char const   *)nam, "can\'t change option: %s", *args);
            }
          }
        } else {
          {
#line 606
          zwarnnam((char const   *)nam, "no such option: %s", *args);
          }
        }
#line 609
        goto while_break___0;
      } else
#line 610
      if ((int )*(*args) == 109) {
#line 611
        match = 1;
      } else {
        {
#line 613
        optno = optlookupc(*(*args));
        }
#line 613
        if (optno) {
          {
#line 615
          tmp___0 = dosetopt(optno, action, 0, opts);
          }
#line 615
          if (tmp___0) {
            {
#line 616
            zwarnnam((char const   *)nam, "can\'t change option: -%c", (int )*(*args));
            }
          }
        } else {
          {
#line 614
          zwarnnam((char const   *)nam, "bad option: -%c", (int )*(*args));
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 619
    args ++;
  }
  while_break: /* CIL Label */ ;
  }
  doneoptions: 
#line 623
  if (! match) {
    {
#line 625
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 625
      if (! *args) {
#line 625
        goto while_break___1;
      }
      {
#line 626
      tmp___2 = args;
#line 626
      args ++;
#line 626
      optno = optlookup((char const   *)*tmp___2);
      }
#line 626
      if (optno) {
        {
#line 628
        tmp___1 = dosetopt(optno, ! isun, 0, opts);
        }
#line 628
        if (tmp___1) {
          {
#line 629
          zwarnnam((char const   *)nam, "can\'t change option: %s", *(args + -1));
          }
        }
      } else {
        {
#line 627
        zwarnnam((char const   *)nam, "no such option: %s", *(args + -1));
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 633
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 633
      if (! *args) {
#line 633
        goto while_break___2;
      }
      {
#line 637
      s = dupstring((char const   *)*args);
#line 637
      t = s;
      }
      {
#line 638
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 638
        if (! *t) {
#line 638
          goto while_break___3;
        }
#line 639
        if ((int )*t == 95) {
          {
#line 640
          chuck(t);
          }
        } else {
#line 643
          if ((int )*t >= 65) {
#line 643
            if ((int )*t <= 90) {
#line 644
              *t = (char )(((int )*t - 65) + 97);
            }
          }
#line 645
          t ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 649
      tokenize(s);
#line 650
      pprog = patcompile(s, 0, (char **)((void *)0));
      }
#line 650
      if (! pprog) {
        {
#line 651
        zwarnnam((char const   *)nam, "bad pattern: %s", *args);
        }
#line 652
        goto while_continue___2;
      }
      {
#line 655
      scanmatchtable(optiontab, pprog, 0, 0, (1 << 6) << 2, & setoption, ! isun);
#line 657
      args ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 660
  inittyptab();
  }
#line 661
  return (0);
}
}
#line 667 "/tmp/zsh-5.4.2/Src/options.c"
int optlookup(char const   *name ) 
{ 
  char *s ;
  char *t ;
  Optname n ;
  HashNode tmp ;
  HashNode tmp___0 ;

  {
  {
#line 673
  t = dupstring(name);
#line 673
  s = t;
  }
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! *t) {
#line 676
      goto while_break;
    }
#line 677
    if ((int )*t == 95) {
      {
#line 678
      chuck(t);
      }
    } else {
#line 686
      if ((int )*t >= 65) {
#line 686
        if ((int )*t <= 90) {
#line 687
          *t = (char )(((int )*t - 65) + 97);
        }
      }
#line 688
      t ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 692
  if ((int )*(s + 0) == 110) {
#line 692
    if ((int )*(s + 1) == 111) {
      {
#line 692
      tmp___0 = (*(optiontab->getnode))(optiontab, (char const   *)(s + 2));
#line 692
      n = (Optname )tmp___0;
      }
#line 692
      if (n) {
#line 694
        return (- n->optno);
      } else {
#line 692
        goto _L___0;
      }
    } else {
#line 692
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 695
    tmp = (*(optiontab->getnode))(optiontab, (char const   *)s);
#line 695
    n = (Optname )tmp;
    }
#line 695
    if (n) {
#line 696
      return (n->optno);
    } else {
#line 698
      return (0);
    }
  }
}
}
#line 704 "/tmp/zsh-5.4.2/Src/options.c"
int optlookupc(char c ) 
{ 
  short *tmp ;

  {
#line 707
  if ((int )c < 48) {
#line 708
    return (0);
  } else
#line 707
  if ((int )c > 121) {
#line 708
    return (0);
  }
#line 710
  if (opts[162]) {
#line 710
    tmp = kshletters;
  } else {
#line 710
    tmp = zshletters;
  }
#line 710
  return ((int )*(tmp + ((int )c - 48)));
}
}
#line 714 "/tmp/zsh-5.4.2/Src/options.c"
static void restrictparam(char *nam ) 
{ 
  Param pm ;
  HashNode tmp ;

  {
  {
#line 717
  tmp = (*(paramtab->getnode))(paramtab, (char const   *)nam);
#line 717
  pm = (Param )tmp;
  }
#line 719
  if (pm) {
#line 720
    pm->node.flags |= (1 << 22) | (1 << 24);
#line 721
    return;
  }
  {
#line 723
  createparam(nam, ((1 << 25) | (1 << 22)) | (1 << 24));
  }
#line 724
  return;
}
}
#line 727 "/tmp/zsh-5.4.2/Src/options.c"
static char *rparams[7]  = {      (char *)"SHELL",      (char *)"HISTFILE",      (char *)"LD_LIBRARY_PATH",      (char *)"LD_AOUT_LIBRARY_PATH", 
        (char *)"LD_PRELOAD",      (char *)"LD_AOUT_PRELOAD",      (char *)((void *)0)};
#line 737 "/tmp/zsh-5.4.2/Src/options.c"
int dosetopt(int optno , int value , int force , char *new_opts ) 
{ 
  int tmp ;
  char **s ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  __gid_t tmp___4 ;
  int tmp___5 ;
  __uid_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 740
  if (! optno) {
#line 741
    return (-1);
  }
#line 742
  if (optno < 0) {
#line 743
    optno = - optno;
#line 744
    value = ! value;
  }
#line 746
  if (optno == 154) {
#line 747
    if (opts[154]) {
#line 748
      if (value) {
#line 748
        tmp = 0;
      } else {
#line 748
        tmp = -1;
      }
#line 748
      return (tmp);
    }
#line 749
    if (value) {
#line 752
      s = rparams;
      {
#line 752
      while (1) {
        while_continue: /* CIL Label */ ;
#line 752
        if (! *s) {
#line 752
          goto while_break;
        }
        {
#line 753
        restrictparam(*s);
#line 752
        s ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else
#line 755
  if (! force) {
#line 755
    if (optno == 52) {
#line 755
      if (! value) {
#line 755
        if (opts[93]) {
#line 757
          return (-1);
        } else {
#line 755
          goto _L___10;
        }
      } else {
#line 755
        goto _L___10;
      }
    } else {
#line 755
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 758
  if (! force) {
#line 758
    if (optno == 93) {
#line 758
      goto _L___7;
    } else
#line 758
    if (optno == 160) {
#line 758
      goto _L___7;
    } else
#line 758
    if (optno == 165) {
      _L___7: /* CIL Label */ 
#line 760
      if ((int )*(new_opts + optno) == value) {
#line 761
        return (0);
      }
#line 763
      return (-1);
    } else {
#line 758
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 764
  if (! force) {
#line 764
    if (optno == 178) {
#line 764
      if (value) {
#line 766
        if (! opts[93]) {
#line 767
          return (-1);
        } else
#line 766
        if (SHTTY == -1) {
#line 767
          return (-1);
        } else
#line 766
        if (! shout) {
#line 767
          return (-1);
        }
      } else {
#line 764
        goto _L___5;
      }
    } else {
#line 764
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 768
  if (optno == 139) {
#line 768
    if (! value) {
      {
#line 771
      tmp___0 = getuid();
#line 771
      setuid(tmp___0);
#line 772
      tmp___1 = getgid();
#line 772
      setgid(tmp___1);
#line 773
      tmp___6 = getuid();
#line 773
      tmp___7 = setuid(tmp___6);
      }
#line 773
      if (tmp___7) {
        {
#line 774
        tmp___2 = __errno_location();
#line 774
        zwarn("failed to change user ID: %e", *tmp___2);
        }
#line 775
        return (-1);
      } else {
        {
#line 776
        tmp___4 = getgid();
#line 776
        tmp___5 = setgid(tmp___4);
        }
#line 776
        if (tmp___5) {
          {
#line 777
          tmp___3 = __errno_location();
#line 777
          zwarn("failed to change group ID: %e", *tmp___3);
          }
#line 778
          return (-1);
        }
      }
    } else {
#line 768
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 785
  if (! force) {
#line 785
    if (optno == 116) {
#line 785
      if (value) {
#line 786
        if ((int )*(new_opts + optno) == value) {
#line 787
          return (0);
        }
#line 788
        if (SHTTY != -1) {
          {
#line 789
          origpgrp = getpgrp();
#line 790
          acquire_pgrp();
          }
        } else {
#line 792
          return (-1);
        }
      } else {
#line 785
        goto _L___2;
      }
    } else {
#line 785
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 801
  if (optno == 48) {
#line 801
    goto _L___0;
  } else
#line 801
  if (optno == 174) {
    _L___0: /* CIL Label */ 
#line 801
    if (value) {
#line 802
      if (sticky) {
#line 802
        if (sticky->emulation) {
#line 803
          return (-1);
        }
      }
      {
#line 804
      zleentry(6, optno);
      }
#line 805
      if (optno == 48) {
#line 805
        tmp___8 = 174;
      } else {
#line 805
        tmp___8 = 48;
      }
#line 805
      *(new_opts + tmp___8) = (char)0;
    } else {
#line 801
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 806
  if (optno == 168) {
#line 808
    if (value) {
#line 808
      keyboardhackchar = (unsigned char )'`';
    } else {
#line 808
      keyboardhackchar = (unsigned char )'\000';
    }
  }
#line 810
  *(new_opts + optno) = (char )value;
#line 811
  if (optno == 18) {
    {
#line 812
    inittyptab();
    }
  } else
#line 811
  if (optno == 160) {
    {
#line 812
    inittyptab();
    }
  }
#line 813
  return (0);
}
}
#line 822 "/tmp/zsh-5.4.2/Src/options.c"
static char buf___5[75]  ;
#line 819 "/tmp/zsh-5.4.2/Src/options.c"
char *dashgetfn(Param pm  __attribute__((__unused__)) ) 
{ 
  char *val ;
  int i ;
  int optno ;
  short *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 823
  val = buf___5;
#line 826
  i = 0;
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! (i <= 73)) {
#line 826
      goto while_break;
    }
#line 827
    if (opts[162]) {
#line 827
      tmp = kshletters;
    } else {
#line 827
      tmp = zshletters;
    }
#line 827
    optno = (int )*(tmp + i);
#line 828
    if (optno) {
#line 828
      if (optno > 0) {
#line 828
        tmp___1 = (int )opts[optno];
      } else {
#line 828
        tmp___1 = ! opts[- optno];
      }
#line 828
      if (tmp___1) {
#line 829
        tmp___0 = val;
#line 829
        val ++;
#line 829
        *tmp___0 = (char )(48 + i);
      }
    }
#line 826
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  *val = (char )'\000';
#line 832
  return (buf___5);
}
}
#line 838 "/tmp/zsh-5.4.2/Src/options.c"
void printoptionstates(int hadplus ) 
{ 


  {
  {
#line 841
  scanhashtable(optiontab, 1, 0, (1 << 6) << 2, & printoptionnodestate, hadplus);
  }
#line 842
  return;
}
}
#line 845 "/tmp/zsh-5.4.2/Src/options.c"
static void printoptionnodestate(HashNode hn , int hadplus ) 
{ 
  Optname on ;
  int optno ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 848
  on = (Optname )hn;
#line 849
  optno = on->optno;
#line 851
  if (hadplus) {
#line 852
    if (! (! (on->node.flags & emulation))) {
#line 852
      tmp = "no";
    } else {
#line 852
      tmp = "";
    }
#line 852
    if (! (! (on->node.flags & emulation)) != (int )opts[optno]) {
#line 852
      tmp___0 = '-';
    } else {
#line 852
      tmp___0 = '+';
    }
    {
#line 852
    printf((char const   */* __restrict  */)"set %co %s%s\n", tmp___0, tmp, on->node.nam);
    }
  } else
#line 857
  if (! (! (on->node.flags & emulation))) {
#line 858
    if (opts[optno]) {
#line 858
      tmp___1 = "off";
    } else {
#line 858
      tmp___1 = "on";
    }
    {
#line 858
    printf((char const   */* __restrict  */)"no%-19s %s\n", on->node.nam, tmp___1);
    }
  } else {
#line 860
    if (opts[optno]) {
#line 860
      tmp___2 = "on";
    } else {
#line 860
      tmp___2 = "off";
    }
    {
#line 860
    printf((char const   */* __restrict  */)"%-21s %s\n", on->node.nam, tmp___2);
    }
  }
#line 862
  return;
}
}
#line 867 "/tmp/zsh-5.4.2/Src/options.c"
void printoptionlist(void) 
{ 
  short *lp ;
  char c ;

  {
  {
#line 873
  printf((char const   */* __restrict  */)"\nNamed options:\n");
#line 874
  scanhashtable(optiontab, 1, 0, (1 << 6) << 2, & printoptionlist_printoption, 0);
#line 875
  printf((char const   */* __restrict  */)"\nOption aliases:\n");
#line 876
  scanhashtable(optiontab, 1, (1 << 6) << 2, 0, & printoptionlist_printoption, 0);
#line 877
  printf((char const   */* __restrict  */)"\nOption letters:\n");
  }
#line 878
  if (opts[162]) {
#line 878
    lp = kshletters;
  } else {
#line 878
    lp = zshletters;
  }
#line 878
  c = (char )'0';
  {
#line 878
  while (1) {
    while_continue: /* CIL Label */ ;
#line 878
    if (! ((int )c <= 121)) {
#line 878
      goto while_break;
    }
#line 879
    if (! *lp) {
#line 880
      goto __Cont;
    }
    {
#line 881
    printf((char const   */* __restrict  */)"  -%c  ", (int )c);
#line 882
    printoptionlist_printequiv((int )*lp);
    }
    __Cont: /* CIL Label */ 
#line 878
    lp ++;
#line 878
    c = (char )((int )c + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  return;
}
}
#line 887 "/tmp/zsh-5.4.2/Src/options.c"
static void printoptionlist_printoption(HashNode hn , int ignored  __attribute__((__unused__)) ) 
{ 
  Optname on ;

  {
#line 890
  on = (Optname )hn;
#line 892
  if (on->node.flags & ((1 << 6) << 2)) {
    {
#line 893
    printf((char const   */* __restrict  */)"  --%-19s  ", on->node.nam);
#line 894
    printoptionlist_printequiv(on->optno);
    }
  } else {
    {
#line 896
    printf((char const   */* __restrict  */)"  --%s\n", on->node.nam);
    }
  }
#line 897
  return;
}
}
#line 900 "/tmp/zsh-5.4.2/Src/options.c"
static void printoptionlist_printequiv(int optno ) 
{ 
  int isneg ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 903
  isneg = optno < 0;
#line 905
  if (isneg) {
#line 905
    tmp = -1;
  } else {
#line 905
    tmp = 1;
  }
#line 905
  optno *= tmp;
#line 906
  if (isneg) {
#line 906
    tmp___0 = "no-";
  } else {
#line 906
    tmp___0 = "";
  }
  {
#line 906
  printf((char const   */* __restrict  */)"  equivalent to --%s%s\n", tmp___0, optns[optno - 1].node.nam);
  }
#line 907
  return;
}
}
#line 913 "/tmp/zsh-5.4.2/Src/options.c"
static void print_emulate_option(HashNode hn , int fully ) 
{ 
  Optname on ;

  {
#line 916
  on = (Optname )hn;
#line 918
  if (! (on->node.flags & ((1 << 6) << 2))) {
#line 918
    if (fully) {
#line 918
      if (! (on->node.flags & ((1 << 6) << 1))) {
#line 918
        goto _L;
      } else {
#line 918
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 918
    if (on->node.flags & (1 << 6)) {
      _L: /* CIL Label */ 
#line 922
      if (! *(print_emulate_opts + on->optno)) {
        {
#line 923
        fputs((char const   */* __restrict  */)"no", (FILE */* __restrict  */)stdout);
        }
      }
      {
#line 924
      puts((char const   *)on->node.nam);
      }
    }
  }
#line 926
  return;
}
}
#line 933 "/tmp/zsh-5.4.2/Src/options.c"
void list_emulate_options(char *cmdopts , int fully ) 
{ 


  {
  {
#line 935
  print_emulate_opts = cmdopts;
#line 936
  scanhashtable(optiontab, 1, 0, 0, & print_emulate_option, fully);
  }
#line 937
  return;
}
}
#line 21 "./linklist.epro"
LinkNode linknodebystring(LinkList list , char *dat ) ;
#line 5 "./module.epro"
LinkList linkedmodules  ;
#line 6 "./module.epro"
char **module_path  ;
#line 7 "./module.epro"
HashTable modulestab  ;
#line 8
HashTable newmoduletable(int size , char const   *name ) ;
#line 9
int setup_zshQsmain(Module m  __attribute__((__unused__)) ) ;
#line 10
int features_zshQsmain(Module m  __attribute__((__unused__)) , char ***features  __attribute__((__unused__)) ) ;
#line 11
int enables_zshQsmain(Module m  __attribute__((__unused__)) , int **enables  __attribute__((__unused__)) ) ;
#line 12
int boot_zshQsmain(Module m  __attribute__((__unused__)) ) ;
#line 13
int cleanup_zshQsmain(Module m  __attribute__((__unused__)) ) ;
#line 14
int finish_zshQsmain(Module m  __attribute__((__unused__)) ) ;
#line 15
void register_module(char *n , int (*setup)(Module  ) , int (*features)(Module  ,
                                                                        char *** ) ,
                     int (*enables)(Module  , int ** ) , int (*boot)(Module  ) , int (*cleanup)(Module  ) ,
                     int (*finish)(Module  ) ) ;
#line 16
Linkedmod module_linked(char const   *name ) ;
#line 17
int deletebuiltin(char const   *nam ) ;
#line 18
int addbuiltins(char const   *nam , Builtin binl , int size ) ;
#line 19 "./module.epro"
FuncWrap wrappers  ;
#line 20
int addwrapper(Module m , FuncWrap w ) ;
#line 21
int deletewrapper(Module m , FuncWrap w ) ;
#line 22 "./module.epro"
Conddef condtab  ;
#line 23
Conddef getconddef(int inf , char const   *name , int autol ) ;
#line 24
int deleteconddef(Conddef c ) ;
#line 25 "./module.epro"
Hookdef hooktab  ;
#line 26
Hookdef gethookdef(char *n ) ;
#line 27
int addhookdef(Hookdef h ) ;
#line 28
int addhookdefs(Module m , Hookdef h , int size ) ;
#line 29
int deletehookdef(Hookdef h ) ;
#line 30
int deletehookdefs(Module m  __attribute__((__unused__)) , Hookdef h , int size ) ;
#line 31
int addhookdeffunc(Hookdef h , int (*f)(Hookdef  , void * ) ) ;
#line 32
int addhookfunc(char *n , int (*f)(Hookdef  , void * ) ) ;
#line 33
int deletehookdeffunc(Hookdef h , int (*f)(Hookdef  , void * ) ) ;
#line 34
int deletehookfunc(char *n , int (*f)(Hookdef  , void * ) ) ;
#line 36
int addparamdef(Paramdef d___0 ) ;
#line 37
int deleteparamdef(Paramdef d___0 ) ;
#line 38 "./module.epro"
MathFunc mathfuncs  ;
#line 39
void removemathfunc(MathFunc previous , MathFunc current ) ;
#line 40
MathFunc getmathfunc(char const   *name , int autol ) ;
#line 41
int deletemathfunc(MathFunc f ) ;
#line 50
int module_loaded(char const   *name ) ;
#line 57
int load_module(char const   *name , Feature_enables enablesarr , int silent ) ;
#line 58
int require_module(char const   *module , Feature_enables features , int silent ) ;
#line 59
void add_dep(char const   *name , char *from ) ;
#line 60
int bin_zmodload(char *nam , char **args , Options ops , int func  __attribute__((__unused__)) ) ;
#line 61
int unload_module(Module m ) ;
#line 62
int unload_named_module(char *modname , char *nam , int silent ) ;
#line 63
char **featuresarray(Module m  __attribute__((__unused__)) , Features f ) ;
#line 64
int *getfeatureenables(Module m  __attribute__((__unused__)) , Features f ) ;
#line 65
int setfeatureenables(Module m , Features f , int *e ) ;
#line 66
int handlefeatures(Module m , Features f , int **enables ) ;
#line 68
int autofeatures(char const   *cmdnam , char const   *module , char **features , int prefchar ,
                 int defflags ) ;
#line 2 "./module.pro"
static int addbuiltin(Builtin b ) ;
#line 3
static int add_autobin(char const   *module , char const   *bnam , int flags ) ;
#line 4
static int del_autobin(char const   *module  __attribute__((__unused__)) , char const   *bnam ,
                       int flags ) ;
#line 5
static int setbuiltins(char const   *nam , Builtin binl , int size , int *e ) ;
#line 6
static int addconddef(Conddef c ) ;
#line 7
static int setconddefs(char const   *nam , Conddef c , int size , int *e ) ;
#line 8
static int add_autocond(char const   *module , char const   *cnam , int flags ) ;
#line 9
static int del_autocond(char const   *modnam  __attribute__((__unused__)) , char const   *cnam ,
                        int flags ) ;
#line 10
static int setparamdefs(char const   *nam , Paramdef d___0 , int size , int *e ) ;
#line 11
static int add_autoparam(char const   *module , char const   *pnam , int flags ) ;
#line 12
static int del_autoparam(char const   *modnam  __attribute__((__unused__)) , char const   *pnam ,
                         int flags ) ;
#line 13
static int addmathfunc(MathFunc f ) ;
#line 14
static int setmathfuncs(char const   *nam , MathFunc f , int size , int *e ) ;
#line 15
static int add_automathfunc(char const   *module , char const   *fnam , int flags ) ;
#line 16
static int del_automathfunc(char const   *modnam  __attribute__((__unused__)) , char const   *fnam ,
                            int flags ) ;
#line 23
static void *try_load_module(char const   *name ) ;
#line 24
static void *do_load_module(char const   *name , int silent ) ;
#line 28
static Module find_module(char const   *name , int flags , char const   **namep ) ;
#line 29
static void delete_module(Module m ) ;
#line 39
static int dyn_setup_module(Module m ) ;
#line 40
static int dyn_features_module(Module m , char ***features ) ;
#line 41
static int dyn_enables_module(Module m , int **enables ) ;
#line 42
static int dyn_boot_module(Module m ) ;
#line 43
static int dyn_cleanup_module(Module m ) ;
#line 44
static int dyn_finish_module(Module m ) ;
#line 46
static int setup_module(Module m ) ;
#line 47
static int features_module(Module m , char ***features ) ;
#line 48
static int enables_module(Module m , int **enables ) ;
#line 49
static int boot_module(Module m ) ;
#line 50
static int cleanup_module(Module m ) ;
#line 51
static int finish_module(Module m ) ;
#line 60
static int do_module_features(Module m , Feature_enables enablesarr , int flags ) ;
#line 61
static int do_boot_module(Module m , Feature_enables enablesarr , int silent ) ;
#line 62
static int do_cleanup_module(Module m ) ;
#line 63
static int modname_ok(char const   *p ) ;
#line 64
static void autoloadscan(HashNode hn , int printflags ) ;
#line 65
static int bin_zmodload_alias(char *nam , char **args , Options ops ) ;
#line 66
static int bin_zmodload_exist(char *nam  __attribute__((__unused__)) , char **args ,
                              Options ops ) ;
#line 67
static int bin_zmodload_dep(char *nam  __attribute__((__unused__)) , char **args ,
                            Options ops ) ;
#line 68
static int bin_zmodload_auto(char *nam , char **args , Options ops ) ;
#line 69
static int bin_zmodload_load(char *nam , char **args , Options ops ) ;
#line 70
static int bin_zmodload_features(char const   *nam , char **args , Options ops ) ;
#line 118 "/tmp/zsh-5.4.2/Src/module.c"
static void freemodulenode(HashNode hn ) 
{ 
  Module m ;

  {
#line 121
  m = (Module )hn;
#line 123
  if (m->node.flags & (1 << 6)) {
    {
#line 124
    zsfree(m->u.alias);
    }
  }
  {
#line 125
  zsfree(m->node.nam);
  }
#line 126
  if (m->autoloads) {
    {
#line 127
    freelinklist(m->autoloads, & freestr);
    }
  }
#line 128
  if (m->deps) {
    {
#line 129
    freelinklist(m->deps, & freestr);
    }
  }
  {
#line 130
  zfree((void *)m, (int )sizeof(*m));
  }
#line 131
  return;
}
}
#line 153 "/tmp/zsh-5.4.2/Src/module.c"
static void printmodulenode(HashNode hn , int flags ) 
{ 
  Module m ;
  char const   *modname ;
  LinkNode n ;
  char **features ;
  int *enables ;
  int tmp ;
  int tmp___0 ;
  LinkNode an ;
  char const   *f ;
  int on ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char **tmp___3 ;

  {
#line 156
  m = (Module )hn;
#line 162
  modname = (char const   *)m->node.nam;
#line 164
  if (flags & 8) {
#line 170
    if (! m->deps) {
#line 171
      return;
    }
#line 173
    if (flags & 1) {
      {
#line 174
      printf((char const   */* __restrict  */)"zmodload -d ");
      }
#line 175
      if ((int const   )*(modname + 0) == 45) {
        {
#line 176
        fputs((char const   */* __restrict  */)"-- ", (FILE */* __restrict  */)stdout);
        }
      }
      {
#line 177
      quotedzputs(modname, stdout);
      }
    } else {
      {
#line 179
      mb_niceformat(modname, stdout, (char **)((void *)0), 0);
#line 180
      putchar(':');
      }
    }
#line 182
    n = (m->deps)->list.first;
    {
#line 182
    while (1) {
      while_continue: /* CIL Label */ ;
#line 182
      if (! n) {
#line 182
        goto while_break;
      }
      {
#line 183
      putchar(' ');
      }
#line 184
      if (flags & 1) {
        {
#line 185
        quotedzputs((char const   *)((char *)n->dat), stdout);
        }
      } else {
        {
#line 187
        mb_niceformat((char const   *)((char *)n->dat), stdout, (char **)((void *)0),
                      0);
        }
      }
#line 182
      n = n->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 189
  if (flags & 2) {
#line 194
    if (m->node.flags & (1 << 6)) {
#line 195
      if (! (flags & 4)) {
#line 197
        return;
      } else {
        {
#line 195
        m = find_module((char const   *)m->u.alias, 1, (char const   **)((void *)0));
        }
#line 195
        if (! m) {
#line 197
          return;
        }
      }
    }
#line 199
    if (! m->u.handle) {
#line 200
      return;
    } else
#line 199
    if (m->node.flags & (1 << 1)) {
#line 200
      return;
    }
    {
#line 201
    mb_niceformat(modname, stdout, (char **)((void *)0), 0);
    }
  } else
#line 202
  if (m->node.flags & (1 << 6)) {
#line 206
    if (flags & 1) {
      {
#line 207
      printf((char const   */* __restrict  */)"zmodload -A ");
      }
#line 208
      if ((int const   )*(modname + 0) == 45) {
        {
#line 209
        fputs((char const   */* __restrict  */)"-- ", (FILE */* __restrict  */)stdout);
        }
      }
      {
#line 210
      quotedzputs(modname, stdout);
#line 211
      putchar('=');
#line 212
      quotedzputs((char const   *)m->u.alias, stdout);
      }
    } else {
      {
#line 214
      mb_niceformat(modname, stdout, (char **)((void *)0), 0);
#line 215
      fputs((char const   */* __restrict  */)" -> ", (FILE */* __restrict  */)stdout);
#line 216
      mb_niceformat((char const   *)m->u.alias, stdout, (char **)((void *)0), 0);
      }
    }
  } else
#line 218
  if (m->u.handle) {
#line 218
    goto _L;
  } else
#line 218
  if (flags & 64) {
    _L: /* CIL Label */ 
#line 222
    if (flags & 1) {
#line 227
      features = (char **)((void *)0);
#line 228
      enables = (int *)((void *)0);
#line 229
      if (flags & 64) {
#line 230
        if (! m->autoloads) {
#line 231
          return;
        } else
#line 230
        if (! (m->autoloads)->list.first) {
#line 231
          return;
        }
      } else
#line 232
      if (flags & 16) {
        {
#line 233
        tmp = features_module(m, & features);
        }
#line 233
        if (tmp) {
#line 236
          return;
        } else {
          {
#line 233
          tmp___0 = enables_module(m, & enables);
          }
#line 233
          if (tmp___0) {
#line 236
            return;
          } else
#line 233
          if (! *features) {
#line 236
            return;
          }
        }
      }
      {
#line 238
      printf((char const   */* __restrict  */)"zmodload ");
      }
#line 239
      if (flags & 64) {
        {
#line 240
        fputs((char const   */* __restrict  */)"-Fa ", (FILE */* __restrict  */)stdout);
        }
      } else
#line 241
      if (features) {
        {
#line 242
        fputs((char const   */* __restrict  */)"-F ", (FILE */* __restrict  */)stdout);
        }
      }
#line 243
      if ((int const   )*(modname + 0) == 45) {
        {
#line 244
        fputs((char const   */* __restrict  */)"-- ", (FILE */* __restrict  */)stdout);
        }
      }
      {
#line 245
      quotedzputs(modname, stdout);
      }
#line 246
      if (flags & 64) {
#line 248
        an = (m->autoloads)->list.first;
        {
#line 248
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 248
          if (! an) {
#line 248
            goto while_break___0;
          }
          {
#line 249
          putchar(' ');
#line 250
          quotedzputs((char const   *)((char *)an->dat), stdout);
#line 248
          an = an->next;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 252
      if (features) {
        {
#line 254
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 254
          tmp___3 = features;
#line 254
          features ++;
#line 254
          f = (char const   *)*tmp___3;
#line 254
          if (! f) {
#line 254
            goto while_break___1;
          }
#line 255
          tmp___1 = enables;
#line 255
          enables ++;
#line 255
          on = *tmp___1;
#line 256
          if (flags & 32) {
#line 257
            if (on) {
#line 257
              tmp___2 = "+";
            } else {
#line 257
              tmp___2 = "-";
            }
            {
#line 257
            printf((char const   */* __restrict  */)" %s", tmp___2);
            }
          } else
#line 258
          if (! on) {
#line 259
            goto while_continue___1;
          } else {
            {
#line 261
            putchar(' ');
            }
          }
          {
#line 262
          quotedzputs(f, stdout);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 266
      mb_niceformat(modname, stdout, (char **)((void *)0), 0);
      }
    }
  } else {
#line 268
    return;
  }
  {
#line 269
  putchar('\n');
  }
#line 270
  return;
}
}
#line 273 "/tmp/zsh-5.4.2/Src/module.c"
HashTable newmoduletable(int size , char const   *name ) 
{ 
  HashTable ht ;

  {
  {
#line 277
  ht = newhashtable(size, name, (void (*)(HashTable  ))((void *)0));
#line 279
  ht->hash = & hasher;
#line 280
  ht->emptytable = & emptyhashtable;
#line 281
  ht->filltable = (void (*)(HashTable  ))((void *)0);
#line 282
  ht->cmpnodes = (int (*)(char const   * , char const   * ))(& strcmp);
#line 283
  ht->addnode = & addhashnode;
#line 285
  ht->getnode = & gethashnode2;
#line 286
  ht->getnode2 = & gethashnode2;
#line 287
  ht->removenode = & removehashnode;
#line 288
  ht->disablenode = (void (*)(HashNode  , int  ))((void *)0);
#line 289
  ht->enablenode = (void (*)(HashNode  , int  ))((void *)0);
#line 290
  ht->freenode = & freemodulenode;
#line 291
  ht->printnode = & printmodulenode;
  }
#line 293
  return (ht);
}
}
#line 305 "/tmp/zsh-5.4.2/Src/module.c"
int setup_zshQsmain(Module m  __attribute__((__unused__)) ) 
{ 


  {
#line 308
  return (0);
}
}
#line 312 "/tmp/zsh-5.4.2/Src/module.c"
int features_zshQsmain(Module m  __attribute__((__unused__)) , char ***features  __attribute__((__unused__)) ) 
{ 


  {
#line 319
  return (1);
}
}
#line 323 "/tmp/zsh-5.4.2/Src/module.c"
int enables_zshQsmain(Module m  __attribute__((__unused__)) , int **enables  __attribute__((__unused__)) ) 
{ 


  {
#line 326
  return (1);
}
}
#line 330 "/tmp/zsh-5.4.2/Src/module.c"
int boot_zshQsmain(Module m  __attribute__((__unused__)) ) 
{ 


  {
#line 333
  return (0);
}
}
#line 337 "/tmp/zsh-5.4.2/Src/module.c"
int cleanup_zshQsmain(Module m  __attribute__((__unused__)) ) 
{ 


  {
#line 340
  return (0);
}
}
#line 344 "/tmp/zsh-5.4.2/Src/module.c"
int finish_zshQsmain(Module m  __attribute__((__unused__)) ) 
{ 


  {
#line 347
  return (0);
}
}
#line 358 "/tmp/zsh-5.4.2/Src/module.c"
void register_module(char *n , int (*setup)(Module  ) , int (*features)(Module  ,
                                                                        char *** ) ,
                     int (*enables)(Module  , int ** ) , int (*boot)(Module  ) , int (*cleanup)(Module  ) ,
                     int (*finish)(Module  ) ) 
{ 
  Linkedmod m ;
  void *tmp ;

  {
  {
#line 368
  tmp = zalloc(sizeof(*m));
#line 368
  m = (Linkedmod )tmp;
#line 370
  m->name = ztrdup((char const   *)n);
#line 371
  m->setup = setup;
#line 372
  m->features = features;
#line 373
  m->enables = enables;
#line 374
  m->boot = boot;
#line 375
  m->cleanup = cleanup;
#line 376
  m->finish = finish;
#line 378
  zinsertlinknode(linkedmodules, linkedmodules->list.last, (void *)m);
  }
#line 379
  return;
}
}
#line 384 "/tmp/zsh-5.4.2/Src/module.c"
Linkedmod module_linked(char const   *name ) 
{ 
  LinkNode node ;
  int tmp ;

  {
#line 389
  node = linkedmodules->list.first;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! node) {
#line 389
      goto while_break;
    }
    {
#line 390
    tmp = strcmp((char const   *)((Linkedmod )node->dat)->name, name);
    }
#line 390
    if (! tmp) {
#line 391
      return ((Linkedmod )node->dat);
    }
#line 389
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return ((Linkedmod )((void *)0));
}
}
#line 408 "/tmp/zsh-5.4.2/Src/module.c"
static int addbuiltin(Builtin b ) 
{ 
  Builtin bn ;
  HashNode tmp ;
  HashNode tmp___0 ;

  {
  {
#line 411
  tmp = (*(builtintab->getnode2))(builtintab, (char const   *)b->node.nam);
#line 411
  bn = (Builtin )tmp;
  }
#line 412
  if (bn) {
#line 412
    if (bn->node.flags & (1 << 3)) {
#line 413
      return (1);
    }
  }
#line 414
  if (bn) {
    {
#line 415
    tmp___0 = (*(builtintab->removenode))(builtintab, (char const   *)b->node.nam);
#line 415
    (*(builtintab->freenode))(tmp___0);
    }
  }
  {
#line 416
  (*(builtintab->addnode))(builtintab, b->node.nam, (void *)b);
  }
#line 417
  return (0);
}
}
#line 425 "/tmp/zsh-5.4.2/Src/module.c"
static int add_autobin(char const   *module , char const   *bnam , int flags ) 
{ 
  Builtin bn ;
  int ret ;
  void *tmp ;

  {
  {
#line 431
  tmp = zshcalloc(sizeof(*bn));
#line 431
  bn = (Builtin )tmp;
#line 432
  bn->node.nam = ztrdup(bnam);
#line 433
  bn->optstr = ztrdup(module);
  }
#line 434
  if (flags & 4) {
#line 435
    bn->node.flags |= 1 << 17;
  }
  {
#line 436
  ret = addbuiltin(bn);
  }
#line 436
  if (ret) {
    {
#line 437
    (*(builtintab->freenode))(& bn->node);
    }
#line 438
    if (! (flags & 1)) {
#line 439
      return (1);
    }
  }
#line 441
  return (0);
}
}
#line 448 "/tmp/zsh-5.4.2/Src/module.c"
int deletebuiltin(char const   *nam ) 
{ 
  Builtin bn ;
  HashNode tmp ;

  {
  {
#line 453
  tmp = (*(builtintab->removenode))(builtintab, nam);
#line 453
  bn = (Builtin )tmp;
  }
#line 454
  if (! bn) {
#line 455
    return (-1);
  }
  {
#line 456
  (*(builtintab->freenode))(& bn->node);
  }
#line 457
  return (0);
}
}
#line 463 "/tmp/zsh-5.4.2/Src/module.c"
static int del_autobin(char const   *module  __attribute__((__unused__)) , char const   *bnam ,
                       int flags ) 
{ 
  Builtin bn ;
  HashNode tmp ;

  {
  {
#line 466
  tmp = (*(builtintab->getnode2))(builtintab, bnam);
#line 466
  bn = (Builtin )tmp;
  }
#line 467
  if (! bn) {
#line 468
    if (! (flags & 1)) {
#line 469
      return (2);
    }
  } else
#line 470
  if (bn->node.flags & (1 << 3)) {
#line 471
    if (! (flags & 1)) {
#line 472
      return (3);
    }
  } else {
    {
#line 474
    deletebuiltin(bnam);
    }
  }
#line 476
  return (0);
}
}
#line 500 "/tmp/zsh-5.4.2/Src/module.c"
static int setbuiltins(char const   *nam , Builtin binl , int size , int *e ) 
{ 
  int ret ;
  int n ;
  Builtin b ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 503
  ret = 0;
#line 505
  n = 0;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (! (n < size)) {
#line 505
      goto while_break;
    }
#line 506
    b = binl + n;
#line 507
    if (e) {
#line 507
      tmp___1 = e;
#line 507
      e ++;
#line 507
      if (*tmp___1) {
#line 508
        if (b->node.flags & (1 << 3)) {
#line 509
          goto __Cont;
        }
        {
#line 510
        tmp = addbuiltin(b);
        }
#line 510
        if (tmp) {
          {
#line 511
          zwarnnam(nam, "name clash when adding builtin `%s\'", b->node.nam);
#line 513
          ret = 1;
          }
        } else {
#line 515
          b->node.flags |= 1 << 3;
        }
      } else {
#line 507
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 518
      if (! (b->node.flags & (1 << 3))) {
#line 519
        goto __Cont;
      }
      {
#line 520
      tmp___0 = deletebuiltin((char const   *)b->node.nam);
      }
#line 520
      if (tmp___0) {
        {
#line 521
        zwarnnam(nam, "builtin `%s\' already deleted", b->node.nam);
#line 522
        ret = 1;
        }
      } else {
#line 524
        b->node.flags &= ~ (1 << 3);
      }
    }
    __Cont: /* CIL Label */ 
#line 505
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  return (ret);
}
}
#line 543 "/tmp/zsh-5.4.2/Src/module.c"
int addbuiltins(char const   *nam , Builtin binl , int size ) 
{ 
  int ret ;
  int n ;
  Builtin b ;
  int tmp ;

  {
#line 546
  ret = 0;
#line 548
  n = 0;
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 548
    if (! (n < size)) {
#line 548
      goto while_break;
    }
#line 549
    b = binl + n;
#line 550
    if (b->node.flags & (1 << 3)) {
#line 551
      goto __Cont;
    }
    {
#line 552
    tmp = addbuiltin(b);
    }
#line 552
    if (tmp) {
      {
#line 553
      zwarnnam(nam, "name clash when adding builtin `%s\'", b->node.nam);
#line 554
      ret = 1;
      }
    } else {
#line 556
      b->node.flags |= 1 << 3;
    }
    __Cont: /* CIL Label */ 
#line 548
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 559
  return (ret);
}
}
#line 576 "/tmp/zsh-5.4.2/Src/module.c"
int addwrapper(Module m , FuncWrap w ) 
{ 
  FuncWrap p ;
  FuncWrap q ;

  {
#line 587
  if (m->node.flags & (1 << 6)) {
#line 588
    return (1);
  }
#line 590
  if (w->flags & 1) {
#line 591
    return (1);
  }
#line 592
  p = wrappers;
#line 592
  q = (FuncWrap )((void *)0);
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    if (! p) {
#line 592
      goto while_break;
    }
#line 592
    q = p;
#line 592
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 593
  if (q) {
#line 594
    q->next = w;
  } else {
#line 596
    wrappers = w;
  }
#line 597
  w->next = (FuncWrap )((void *)0);
#line 598
  w->flags |= 1;
#line 599
  w->module = m;
#line 601
  return (0);
}
}
#line 608 "/tmp/zsh-5.4.2/Src/module.c"
int deletewrapper(Module m , FuncWrap w ) 
{ 
  FuncWrap p ;
  FuncWrap q ;

  {
#line 613
  if (m->node.flags & (1 << 6)) {
#line 614
    return (1);
  }
#line 616
  if (w->flags & 1) {
#line 617
    p = wrappers;
#line 617
    q = (FuncWrap )((void *)0);
    {
#line 617
    while (1) {
      while_continue: /* CIL Label */ ;
#line 617
      if (p) {
#line 617
        if (! ((unsigned long )p != (unsigned long )w)) {
#line 617
          goto while_break;
        }
      } else {
#line 617
        goto while_break;
      }
#line 617
      q = p;
#line 617
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 619
    if (p) {
#line 620
      if (q) {
#line 621
        q->next = p->next;
      } else {
#line 623
        wrappers = p->next;
      }
#line 624
      p->flags &= -2;
#line 626
      return (0);
    }
  }
#line 629
  return (1);
}
}
#line 647 "/tmp/zsh-5.4.2/Src/module.c"
Conddef getconddef(int inf , char const   *name , int autol ) 
{ 
  Conddef p ;
  int f ;
  char *lookup ;
  char *s ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 651
  f = 1;
#line 655
  lookup = dupstring(name);
  }
#line 656
  if (! lookup) {
#line 657
    return ((Conddef )((void *)0));
  }
#line 658
  s = lookup;
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! ((int )*s != 0)) {
#line 658
      goto while_break;
    }
#line 659
    if ((int )*s == -101) {
#line 660
      *s = (char )'-';
    }
#line 658
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 663
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 664
    p = condtab;
    {
#line 664
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 664
      if (! p) {
#line 664
        goto while_break___1;
      }
#line 665
      if (! (! inf) == ! (! (p->flags & 1))) {
        {
#line 665
        tmp = strcmp((char const   *)lookup, (char const   *)p->name);
        }
#line 665
        if (! tmp) {
#line 667
          goto while_break___1;
        }
      }
#line 664
      p = p->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 669
    if (autol) {
#line 669
      if (p) {
#line 669
        if (p->module) {
#line 674
          if (f) {
#line 675
            if (p->flags & 4) {
#line 675
              tmp___0 = (char *)((void *)0);
            } else {
#line 675
              tmp___0 = lookup;
            }
#line 675
            if (p->flags & 1) {
#line 675
              tmp___1 = "C:";
            } else {
#line 675
              tmp___1 = "c:";
            }
            {
#line 675
            ensurefeature((char const   *)p->module, tmp___1, (char const   *)tmp___0);
#line 678
            f = 0;
#line 679
            p = (Conddef )((void *)0);
            }
          } else {
            {
#line 681
            deleteconddef(p);
            }
#line 682
            return ((Conddef )((void *)0));
          }
        } else {
#line 685
          goto while_break___0;
        }
      } else {
#line 685
        goto while_break___0;
      }
    } else {
#line 685
      goto while_break___0;
    }
#line 663
    if (! (! p)) {
#line 663
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 688
  return (p);
}
}
#line 702 "/tmp/zsh-5.4.2/Src/module.c"
static int addconddef(Conddef c ) 
{ 
  Conddef p ;
  Conddef tmp ;

  {
  {
#line 705
  tmp = getconddef(c->flags & 1, (char const   *)c->name, 0);
#line 705
  p = tmp;
  }
#line 707
  if (p) {
#line 708
    if (! p->module) {
#line 709
      return (1);
    } else
#line 708
    if (p->flags & 2) {
#line 709
      return (1);
    }
    {
#line 712
    deleteconddef(p);
    }
  }
#line 714
  c->next = condtab;
#line 715
  condtab = c;
#line 716
  return (0);
}
}
#line 723 "/tmp/zsh-5.4.2/Src/module.c"
int deleteconddef(Conddef c ) 
{ 
  Conddef p ;
  Conddef q ;

  {
#line 728
  p = condtab;
#line 728
  q = (Conddef )((void *)0);
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 728
    if (p) {
#line 728
      if (! ((unsigned long )p != (unsigned long )c)) {
#line 728
        goto while_break;
      }
    } else {
#line 728
      goto while_break;
    }
#line 728
    q = p;
#line 728
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 730
  if (p) {
#line 731
    if (q) {
#line 732
      q->next = p->next;
    } else {
#line 734
      condtab = p->next;
    }
#line 736
    if (p->module) {
      {
#line 738
      zsfree(p->name);
#line 739
      zsfree(p->module);
#line 740
      zfree((void *)p, (int )sizeof(*p));
      }
    }
#line 742
    return (0);
  }
#line 744
  return (-1);
}
}
#line 753 "/tmp/zsh-5.4.2/Src/module.c"
static int setconddefs(char const   *nam , Conddef c , int size , int *e ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 756
  ret = 0;
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 758
    tmp___2 = size;
#line 758
    size --;
#line 758
    if (! tmp___2) {
#line 758
      goto while_break;
    }
#line 759
    if (e) {
#line 759
      tmp___1 = e;
#line 759
      e ++;
#line 759
      if (*tmp___1) {
#line 760
        if (c->flags & 2) {
#line 761
          c ++;
#line 762
          goto while_continue;
        }
        {
#line 764
        tmp = addconddef(c);
        }
#line 764
        if (tmp) {
          {
#line 765
          zwarnnam(nam, "name clash when adding condition `%s\'", c->name);
#line 767
          ret = 1;
          }
        } else {
#line 769
          c->flags |= 2;
        }
      } else {
#line 759
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 772
      if (! (c->flags & 2)) {
#line 773
        c ++;
#line 774
        goto while_continue;
      }
      {
#line 776
      tmp___0 = deleteconddef(c);
      }
#line 776
      if (tmp___0) {
        {
#line 777
        zwarnnam(nam, "condition `%s\' already deleted", c->name);
#line 778
        ret = 1;
        }
      } else {
#line 780
        c->flags &= -3;
      }
    }
#line 783
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 785
  return (ret);
}
}
#line 791 "/tmp/zsh-5.4.2/Src/module.c"
static int add_autocond(char const   *module , char const   *cnam , int flags ) 
{ 
  Conddef c ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 796
  tmp = zalloc(sizeof(*c));
#line 796
  c = (Conddef )tmp;
#line 798
  c->name = ztrdup(cnam);
  }
#line 799
  if (flags & 2) {
#line 799
    c->flags = 1;
  } else {
#line 799
    c->flags = 0;
  }
#line 800
  if (flags & 4) {
#line 801
    c->flags |= 4;
  }
  {
#line 802
  c->module = ztrdup(module);
#line 804
  tmp___0 = addconddef(c);
  }
#line 804
  if (tmp___0) {
    {
#line 805
    zsfree(c->name);
#line 806
    zsfree(c->module);
#line 807
    zfree((void *)c, (int )sizeof(*c));
    }
#line 809
    if (! (flags & 1)) {
#line 810
      return (1);
    }
  }
#line 812
  return (0);
}
}
#line 818 "/tmp/zsh-5.4.2/Src/module.c"
static int del_autocond(char const   *modnam  __attribute__((__unused__)) , char const   *cnam ,
                        int flags ) 
{ 
  Conddef cd ;
  int tmp ;
  Conddef tmp___0 ;

  {
#line 821
  if (flags & 2) {
#line 821
    tmp = 1;
  } else {
#line 821
    tmp = 0;
  }
  {
#line 821
  tmp___0 = getconddef(tmp, cnam, 0);
#line 821
  cd = tmp___0;
  }
#line 823
  if (! cd) {
#line 824
    if (! (flags & 1)) {
#line 825
      return (2);
    }
  } else
#line 827
  if (cd->flags & 2) {
#line 828
    if (! (flags & 1)) {
#line 829
      return (3);
    }
  } else {
    {
#line 831
    deleteconddef(cd);
    }
  }
#line 833
  return (0);
}
}
#line 848 "/tmp/zsh-5.4.2/Src/module.c"
Hookdef gethookdef(char *n ) 
{ 
  Hookdef p ;
  int tmp ;

  {
#line 853
  p = hooktab;
  {
#line 853
  while (1) {
    while_continue: /* CIL Label */ ;
#line 853
    if (! p) {
#line 853
      goto while_break;
    }
    {
#line 854
    tmp = strcmp((char const   *)n, (char const   *)p->name);
    }
#line 854
    if (! tmp) {
#line 855
      return (p);
    }
#line 853
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 856
  return ((Hookdef )((void *)0));
}
}
#line 863 "/tmp/zsh-5.4.2/Src/module.c"
int addhookdef(Hookdef h ) 
{ 
  Hookdef tmp ;

  {
  {
#line 866
  tmp = gethookdef(h->name);
  }
#line 866
  if (tmp) {
#line 867
    return (1);
  }
  {
#line 869
  h->next = hooktab;
#line 870
  hooktab = h;
#line 871
  h->funcs = znewlinklist();
  }
#line 873
  return (0);
}
}
#line 882 "/tmp/zsh-5.4.2/Src/module.c"
int addhookdefs(Module m , Hookdef h , int size ) 
{ 
  int ret ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 885
  ret = 0;
  {
#line 887
  while (1) {
    while_continue: /* CIL Label */ ;
#line 887
    tmp___1 = size;
#line 887
    size --;
#line 887
    if (! tmp___1) {
#line 887
      goto while_break;
    }
    {
#line 888
    tmp___0 = addhookdef(h);
    }
#line 888
    if (tmp___0) {
#line 889
      if (m) {
#line 889
        tmp = m->node.nam;
      } else {
#line 889
        tmp = (char *)((void *)0);
      }
      {
#line 889
      zwarnnam((char const   *)tmp, "name clash when adding hook `%s\'", h->name);
#line 891
      ret = 1;
      }
    }
#line 893
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 895
  return (ret);
}
}
#line 901 "/tmp/zsh-5.4.2/Src/module.c"
int deletehookdef(Hookdef h ) 
{ 
  Hookdef p ;
  Hookdef q ;

  {
#line 906
  p = hooktab;
#line 906
  q = (Hookdef )((void *)0);
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (p) {
#line 906
      if (! ((unsigned long )p != (unsigned long )h)) {
#line 906
        goto while_break;
      }
    } else {
#line 906
      goto while_break;
    }
#line 906
    q = p;
#line 906
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 908
  if (! p) {
#line 909
    return (1);
  }
#line 911
  if (q) {
#line 912
    q->next = p->next;
  } else {
#line 914
    hooktab = p->next;
  }
  {
#line 915
  freelinklist(p->funcs, (void (*)(void * ))((void *)0));
  }
#line 916
  return (0);
}
}
#line 922 "/tmp/zsh-5.4.2/Src/module.c"
int deletehookdefs(Module m  __attribute__((__unused__)) , Hookdef h , int size ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 925
  ret = 0;
  {
#line 927
  while (1) {
    while_continue: /* CIL Label */ ;
#line 927
    tmp___0 = size;
#line 927
    size --;
#line 927
    if (! tmp___0) {
#line 927
      goto while_break;
    }
    {
#line 928
    tmp = deletehookdef(h);
    }
#line 928
    if (tmp) {
#line 929
      ret = 1;
    }
#line 930
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 932
  return (ret);
}
}
#line 938 "/tmp/zsh-5.4.2/Src/module.c"
int addhookdeffunc(Hookdef h , int (*f)(Hookdef  , void * ) ) 
{ 


  {
  {
#line 941
  zinsertlinknode(h->funcs, (h->funcs)->list.last, (void *)f);
  }
#line 943
  return (0);
}
}
#line 947 "/tmp/zsh-5.4.2/Src/module.c"
int addhookfunc(char *n , int (*f)(Hookdef  , void * ) ) 
{ 
  Hookdef h ;
  Hookdef tmp ;
  int tmp___0 ;

  {
  {
#line 950
  tmp = gethookdef(n);
#line 950
  h = tmp;
  }
#line 952
  if (h) {
    {
#line 953
    tmp___0 = addhookdeffunc(h, f);
    }
#line 953
    return (tmp___0);
  }
#line 954
  return (1);
}
}
#line 960 "/tmp/zsh-5.4.2/Src/module.c"
int deletehookdeffunc(Hookdef h , int (*f)(Hookdef  , void * ) ) 
{ 
  LinkNode p ;

  {
#line 965
  p = (h->funcs)->list.first;
  {
#line 965
  while (1) {
    while_continue: /* CIL Label */ ;
#line 965
    if (! p) {
#line 965
      goto while_break;
    }
#line 966
    if ((unsigned long )f == (unsigned long )((int (*)(Hookdef  , void * ))p->dat)) {
      {
#line 967
      remnode(h->funcs, p);
      }
#line 968
      return (0);
    }
#line 965
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 970
  return (1);
}
}
#line 976 "/tmp/zsh-5.4.2/Src/module.c"
int deletehookfunc(char *n , int (*f)(Hookdef  , void * ) ) 
{ 
  Hookdef h ;
  Hookdef tmp ;
  int tmp___0 ;

  {
  {
#line 979
  tmp = gethookdef(n);
#line 979
  h = tmp;
  }
#line 981
  if (h) {
    {
#line 982
    tmp___0 = deletehookdeffunc(h, f);
    }
#line 982
    return (tmp___0);
  }
#line 983
  return (1);
}
}
#line 989 "/tmp/zsh-5.4.2/Src/module.c"
int runhookdef(Hookdef h , void *d___0 ) 
{ 
  int tmp ;
  LinkNode p ;
  int r ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 992
  if ((unsigned long )(h->funcs)->list.first == (unsigned long )((void *)0)) {
#line 993
    if (h->def) {
      {
#line 994
      tmp = (*(h->def))(h, d___0);
      }
#line 994
      return (tmp);
    }
#line 995
    return (0);
  } else
#line 996
  if (h->flags & 1) {
#line 1000
    p = (h->funcs)->list.first;
    {
#line 1000
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1000
      if (! p) {
#line 1000
        goto while_break;
      }
      {
#line 1001
      r = (*((int (*)(Hookdef  , void * ))p->dat))(h, d___0);
      }
#line 1001
      if (r) {
#line 1002
        return (r);
      }
#line 1000
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1003
    if (h->def) {
      {
#line 1004
      tmp___0 = (*(h->def))(h, d___0);
      }
#line 1004
      return (tmp___0);
    }
#line 1005
    return (0);
  } else {
    {
#line 1007
    tmp___1 = (*((int (*)(Hookdef  , void * ))((h->funcs)->list.last)->dat))(h, d___0);
    }
#line 1007
    return (tmp___1);
  }
}
}
#line 1025 "/tmp/zsh-5.4.2/Src/module.c"
static int checkaddparam(char const   *nam , int opt_i ) 
{ 
  Param pm ;
  HashNode tmp ;
  char const   *tmp___0 ;

  {
  {
#line 1030
  tmp = gethashnode2(paramtab, nam);
#line 1030
  pm = (Param )tmp;
  }
#line 1030
  if (! pm) {
#line 1031
    return (0);
  }
#line 1033
  if (pm->level) {
#line 1033
    goto _L___0;
  } else
#line 1033
  if (! (pm->node.flags & (1 << 27))) {
    _L___0: /* CIL Label */ 
#line 1042
    if (! opt_i) {
#line 1042
      goto _L;
    } else
#line 1042
    if (! pm->level) {
      _L: /* CIL Label */ 
#line 1043
      if (pm->level) {
#line 1043
        tmp___0 = "local parameter exists";
      } else {
#line 1043
        tmp___0 = "parameter already exists";
      }
      {
#line 1043
      zwarn("Can\'t add module parameter `%s\': %s", nam, tmp___0);
      }
#line 1047
      return (1);
    }
#line 1049
    return (2);
  }
  {
#line 1052
  unsetparam_pm(pm, 0, 1);
  }
#line 1053
  return (0);
}
}
#line 1060 "/tmp/zsh-5.4.2/Src/module.c"
int addparamdef(Paramdef d___0 ) 
{ 
  Param pm ;
  int tmp ;
  HashNode tmp___0 ;

  {
  {
#line 1065
  tmp = checkaddparam((char const   *)d___0->name, 0);
  }
#line 1065
  if (tmp) {
#line 1066
    return (1);
  }
#line 1068
  if (d___0->getnfn) {
    {
#line 1069
    pm = createspecialhash(d___0->name, d___0->getnfn, d___0->scantfn, d___0->flags);
    }
#line 1069
    if (! pm) {
#line 1071
      return (1);
    }
  } else {
    {
#line 1073
    pm = createparam(d___0->name, d___0->flags);
    }
#line 1073
    if (! pm) {
      {
#line 1073
      tmp___0 = (*(paramtab->getnode))(paramtab, (char const   *)d___0->name);
#line 1073
      pm = (Param )tmp___0;
      }
#line 1073
      if (! pm) {
#line 1075
        return (1);
      }
    }
  }
#line 1077
  d___0->pm = pm;
#line 1078
  pm->level = 0;
#line 1079
  if (d___0->var) {
#line 1080
    pm->u.data = d___0->var;
  }
#line 1081
  if (d___0->var) {
#line 1081
    goto _L;
  } else
#line 1081
  if (d___0->gsu) {
    _L: /* CIL Label */ 
    {
#line 1087
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 1087
      goto case_0;
    }
#line 1091
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 1091
      goto case_exp;
    }
#line 1096
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 1096
      goto case_exp___0;
    }
#line 1096
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 1096
      goto case_exp___0;
    }
#line 1100
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 1100
      goto case_1;
    }
#line 1104
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
#line 1104
      goto case_exp___2;
    }
#line 1110
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1088
    if (d___0->gsu) {
#line 1088
      pm->gsu.s = (GsuScalar )d___0->gsu;
    } else {
#line 1088
      pm->gsu.s = & varscalar_gsu;
    }
#line 1089
    goto switch_break;
    case_exp: /* CIL Label */ 
#line 1092
    if (d___0->gsu) {
#line 1092
      pm->gsu.i = (GsuInteger )d___0->gsu;
    } else {
#line 1092
      pm->gsu.i = & varinteger_gsu;
    }
#line 1093
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    case_exp___1: /* CIL Label */ 
#line 1097
    pm->gsu.f = (GsuFloat )d___0->gsu;
#line 1098
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1101
    if (d___0->gsu) {
#line 1101
      pm->gsu.a = (GsuArray )d___0->gsu;
    } else {
#line 1101
      pm->gsu.a = & vararray_gsu;
    }
#line 1102
    goto switch_break;
    case_exp___2: /* CIL Label */ 
#line 1106
    if (d___0->gsu) {
#line 1107
      pm->gsu.h = (GsuHash )d___0->gsu;
    }
#line 1108
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1111
    unsetparam_pm(pm, 0, 1);
    }
#line 1112
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 1116
  return (0);
}
}
#line 1122 "/tmp/zsh-5.4.2/Src/module.c"
int deleteparamdef(Paramdef d___0 ) 
{ 
  Param pm ;
  HashNode tmp ;
  Param prevpm ;
  Param searchpm ;

  {
  {
#line 1125
  tmp = (*(paramtab->getnode))(paramtab, (char const   *)d___0->name);
#line 1125
  pm = (Param )tmp;
  }
#line 1127
  if (! pm) {
#line 1128
    return (1);
  }
#line 1129
  if ((unsigned long )pm != (unsigned long )d___0->pm) {
#line 1135
    prevpm = pm;
#line 1135
    searchpm = pm->old;
    {
#line 1135
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1135
      if (! searchpm) {
#line 1135
        goto while_break;
      }
#line 1138
      if ((unsigned long )searchpm == (unsigned long )d___0->pm) {
#line 1139
        goto while_break;
      }
#line 1135
      prevpm = searchpm;
#line 1135
      searchpm = searchpm->old;
    }
    while_break: /* CIL Label */ ;
    }
#line 1141
    if (! searchpm) {
#line 1142
      return (1);
    }
    {
#line 1144
    (*(paramtab->removenode))(paramtab, (char const   *)pm->node.nam);
#line 1145
    prevpm->old = searchpm->old;
#line 1146
    searchpm->old = pm;
#line 1147
    (*(paramtab->addnode))(paramtab, searchpm->node.nam, (void *)searchpm);
#line 1149
    pm = searchpm;
    }
  }
  {
#line 1151
  pm->node.flags = (pm->node.flags & ~ (1 << 10)) | (1 << 26);
#line 1152
  unsetparam_pm(pm, 0, 1);
#line 1153
  d___0->pm = (Param )((void *)0);
  }
#line 1154
  return (0);
}
}
#line 1163 "/tmp/zsh-5.4.2/Src/module.c"
static int setparamdefs(char const   *nam , Paramdef d___0 , int size , int *e ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 1166
  ret = 0;
  {
#line 1168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1168
    tmp___2 = size;
#line 1168
    size --;
#line 1168
    if (! tmp___2) {
#line 1168
      goto while_break;
    }
#line 1169
    if (e) {
#line 1169
      tmp___1 = e;
#line 1169
      e ++;
#line 1169
      if (*tmp___1) {
#line 1170
        if (d___0->pm) {
#line 1171
          d___0 ++;
#line 1172
          goto while_continue;
        }
        {
#line 1174
        tmp = addparamdef(d___0);
        }
#line 1174
        if (tmp) {
          {
#line 1175
          zwarnnam(nam, "error when adding parameter `%s\'", d___0->name);
#line 1176
          ret = 1;
          }
        }
      } else {
#line 1169
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1179
      if (! d___0->pm) {
#line 1180
        d___0 ++;
#line 1181
        goto while_continue;
      }
      {
#line 1183
      tmp___0 = deleteparamdef(d___0);
      }
#line 1183
      if (tmp___0) {
        {
#line 1184
        zwarnnam(nam, "parameter `%s\' already deleted", d___0->name);
#line 1185
        ret = 1;
        }
      }
    }
#line 1188
    d___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1190
  return (ret);
}
}
#line 1196 "/tmp/zsh-5.4.2/Src/module.c"
static int add_autoparam(char const   *module , char const   *pnam , int flags ) 
{ 
  Param pm ;
  int ret ;
  sigset_t oset ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  sigset_t oset___0 ;

  {
  {
#line 1202
  queueing_enabled ++;
#line 1203
  ret = checkaddparam(pnam, flags & 1);
  }
#line 1203
  if (ret) {
    {
#line 1204
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1204
      queueing_enabled --;
#line 1204
      if (! queueing_enabled) {
        {
#line 1204
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1204
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1204
            if (! (queue_front != queue_rear)) {
#line 1204
              goto while_break___1;
            }
            {
#line 1204
            queue_front = (queue_front + 1) % 128;
#line 1204
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1204
            zhandler(signal_queue[queue_front]);
#line 1204
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1204
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1204
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1212
    if (ret == 2) {
#line 1212
      tmp = 0;
    } else {
#line 1212
      tmp = -1;
    }
#line 1212
    return (tmp);
  }
  {
#line 1215
  tmp___0 = ztrdup(module);
#line 1215
  tmp___1 = dupstring(pnam);
#line 1215
  pm = setsparam(tmp___1, tmp___0);
#line 1217
  pm->node.flags |= 1 << 27;
  }
#line 1218
  if (flags & 4) {
#line 1219
    pm->node.flags |= 1 << 28;
  }
  {
#line 1220
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1220
    queueing_enabled --;
#line 1220
    if (! queueing_enabled) {
      {
#line 1220
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1220
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1220
          if (! (queue_front != queue_rear)) {
#line 1220
            goto while_break___4;
          }
          {
#line 1220
          queue_front = (queue_front + 1) % 128;
#line 1220
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 1220
          zhandler(signal_queue[queue_front]);
#line 1220
          signal_setmask(oset___0);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1220
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 1220
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1222
  return (0);
}
}
#line 1228 "/tmp/zsh-5.4.2/Src/module.c"
static int del_autoparam(char const   *modnam  __attribute__((__unused__)) , char const   *pnam ,
                         int flags ) 
{ 
  Param pm ;
  HashNode tmp ;

  {
  {
#line 1231
  tmp = gethashnode2(paramtab, pnam);
#line 1231
  pm = (Param )tmp;
  }
#line 1233
  if (! pm) {
#line 1234
    if (! (flags & 1)) {
#line 1235
      return (2);
    }
  } else
#line 1236
  if (! (pm->node.flags & (1 << 27))) {
#line 1237
    if (! (flags & 1)) {
#line 1238
      return (3);
    }
  } else {
    {
#line 1240
    unsetparam_pm(pm, 0, 1);
    }
  }
#line 1242
  return (0);
}
}
#line 1260 "/tmp/zsh-5.4.2/Src/module.c"
void removemathfunc(MathFunc previous , MathFunc current ) 
{ 


  {
#line 1263
  if (previous) {
#line 1264
    previous->next = current->next;
  } else {
#line 1266
    mathfuncs = current->next;
  }
  {
#line 1268
  zsfree(current->name);
#line 1269
  zsfree(current->module);
#line 1270
  zfree((void *)current, (int )sizeof(*current));
  }
#line 1271
  return;
}
}
#line 1276 "/tmp/zsh-5.4.2/Src/module.c"
MathFunc getmathfunc(char const   *name , int autol ) 
{ 
  MathFunc p ;
  MathFunc q ;
  char *n ;
  char *tmp ;
  int flags ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 1279
  q = (MathFunc )((void *)0);
#line 1281
  p = mathfuncs;
  {
#line 1281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1281
    if (! p) {
#line 1281
      goto while_break;
    }
    {
#line 1282
    tmp___1 = strcmp(name, (char const   *)p->name);
    }
#line 1282
    if (! tmp___1) {
#line 1283
      if (autol) {
#line 1283
        if (p->module) {
#line 1283
          if (! (p->flags & 4)) {
            {
#line 1284
            tmp = dupstring((char const   *)p->module);
#line 1284
            n = tmp;
#line 1285
            flags = p->flags;
#line 1287
            removemathfunc(q, p);
            }
#line 1289
            if (flags & 8) {
#line 1289
              tmp___0 = (char const   *)((void *)0);
            } else {
#line 1289
              tmp___0 = name;
            }
            {
#line 1289
            ensurefeature((char const   *)n, "f:", tmp___0);
#line 1292
            p = getmathfunc(name, 0);
            }
#line 1293
            if (! p) {
              {
#line 1294
              zerr("autoloading module %s failed to define math function: %s", n,
                   name);
              }
            }
          }
        }
      }
#line 1297
      return (p);
    }
#line 1281
    q = p;
#line 1281
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1300
  return ((MathFunc )((void *)0));
}
}
#line 1306 "/tmp/zsh-5.4.2/Src/module.c"
static int addmathfunc(MathFunc f ) 
{ 
  MathFunc p ;
  MathFunc q ;
  int tmp ;

  {
#line 1309
  q = (MathFunc )((void *)0);
#line 1311
  if (f->flags & 2) {
#line 1312
    return (1);
  }
#line 1314
  p = mathfuncs;
  {
#line 1314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1314
    if (! p) {
#line 1314
      goto while_break;
    }
    {
#line 1315
    tmp = strcmp((char const   *)f->name, (char const   *)p->name);
    }
#line 1315
    if (! tmp) {
#line 1316
      if (p->module) {
#line 1316
        if (! (p->flags & 4)) {
          {
#line 1320
          removemathfunc(q, p);
          }
#line 1321
          goto while_break;
        }
      }
#line 1323
      return (1);
    }
#line 1314
    q = p;
#line 1314
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1326
  f->next = mathfuncs;
#line 1327
  mathfuncs = f;
#line 1329
  return (0);
}
}
#line 1335 "/tmp/zsh-5.4.2/Src/module.c"
int deletemathfunc(MathFunc f ) 
{ 
  MathFunc p ;
  MathFunc q ;

  {
#line 1340
  p = mathfuncs;
#line 1340
  q = (MathFunc )((void *)0);
  {
#line 1340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1340
    if (p) {
#line 1340
      if (! ((unsigned long )p != (unsigned long )f)) {
#line 1340
        goto while_break;
      }
    } else {
#line 1340
      goto while_break;
    }
#line 1340
    q = p;
#line 1340
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1342
  if (p) {
#line 1343
    if (q) {
#line 1344
      q->next = f->next;
    } else {
#line 1346
      mathfuncs = f->next;
    }
#line 1349
    if (f->module) {
      {
#line 1350
      zsfree(f->name);
#line 1351
      zsfree(f->module);
#line 1352
      zfree((void *)f, (int )sizeof(*f));
      }
    } else {
#line 1354
      f->flags &= -3;
    }
#line 1356
    return (0);
  }
#line 1358
  return (-1);
}
}
#line 1367 "/tmp/zsh-5.4.2/Src/module.c"
static int setmathfuncs(char const   *nam , MathFunc f , int size , int *e ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 1370
  ret = 0;
  {
#line 1372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1372
    tmp___2 = size;
#line 1372
    size --;
#line 1372
    if (! tmp___2) {
#line 1372
      goto while_break;
    }
#line 1373
    if (e) {
#line 1373
      tmp___1 = e;
#line 1373
      e ++;
#line 1373
      if (*tmp___1) {
#line 1374
        if (f->flags & 2) {
#line 1375
          f ++;
#line 1376
          goto while_continue;
        }
        {
#line 1378
        tmp = addmathfunc(f);
        }
#line 1378
        if (tmp) {
          {
#line 1379
          zwarnnam(nam, "name clash when adding math function `%s\'", f->name);
#line 1381
          ret = 1;
          }
        } else {
#line 1383
          f->flags |= 2;
        }
      } else {
#line 1373
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1386
      if (! (f->flags & 2)) {
#line 1387
        f ++;
#line 1388
        goto while_continue;
      }
      {
#line 1390
      tmp___0 = deletemathfunc(f);
      }
#line 1390
      if (tmp___0) {
        {
#line 1391
        zwarnnam(nam, "math function `%s\' already deleted", f->name);
#line 1392
        ret = 1;
        }
      } else {
#line 1394
        f->flags &= -3;
      }
    }
#line 1397
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1399
  return (ret);
}
}
#line 1405 "/tmp/zsh-5.4.2/Src/module.c"
static int add_automathfunc(char const   *module , char const   *fnam , int flags ) 
{ 
  MathFunc f ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1410
  tmp = zalloc(sizeof(*f));
#line 1410
  f = (MathFunc )tmp;
#line 1412
  f->name = ztrdup(fnam);
#line 1413
  f->module = ztrdup(module);
#line 1414
  f->flags = 0;
#line 1416
  tmp___0 = addmathfunc(f);
  }
#line 1416
  if (tmp___0) {
    {
#line 1417
    zsfree(f->name);
#line 1418
    zsfree(f->module);
#line 1419
    zfree((void *)f, (int )sizeof(*f));
    }
#line 1421
    if (! (flags & 1)) {
#line 1422
      return (1);
    }
  }
#line 1425
  return (0);
}
}
#line 1431 "/tmp/zsh-5.4.2/Src/module.c"
static int del_automathfunc(char const   *modnam  __attribute__((__unused__)) , char const   *fnam ,
                            int flags ) 
{ 
  MathFunc f ;
  MathFunc tmp ;

  {
  {
#line 1434
  tmp = getmathfunc(fnam, 0);
#line 1434
  f = tmp;
  }
#line 1436
  if (! f) {
#line 1437
    if (! (flags & 1)) {
#line 1438
      return (2);
    }
  } else
#line 1439
  if (f->flags & 2) {
#line 1440
    if (! (flags & 1)) {
#line 1441
      return (3);
    }
  } else {
    {
#line 1443
    deletemathfunc(f);
    }
  }
#line 1445
  return (0);
}
}
#line 56 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2))) dlsym)(void * __restrict  __handle ,
                                                                                    char const   * __restrict  __name ) ;
#line 82
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
#line 1578 "/tmp/zsh-5.4.2/Src/module.c"
static void *try_load_module(char const   *name ) 
{ 
  char buf___7[4097] ;
  char **pp ;
  void *ret ;
  int l ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 1583
  ret = (void *)0;
#line 1586
  tmp = strlen(name);
#line 1586
  tmp___0 = strlen("so");
#line 1586
  l = (int )(((1UL + tmp) + 1UL) + tmp___0);
#line 1587
  pp = module_path;
  }
  {
#line 1587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1587
    if (! ret) {
#line 1587
      if (! *pp) {
#line 1587
        goto while_break;
      }
    } else {
#line 1587
      goto while_break;
    }
#line 1588
    if (*(*pp)) {
      {
#line 1588
      tmp___1 = strlen((char const   *)*pp);
#line 1588
      tmp___2 = tmp___1;
      }
    } else {
#line 1588
      tmp___2 = (size_t )1;
    }
#line 1588
    if ((size_t )l + tmp___2 > 4096UL) {
#line 1589
      goto __Cont;
    }
#line 1590
    if (*(*pp)) {
#line 1590
      tmp___3 = (char const   *)*pp;
    } else {
#line 1590
      tmp___3 = ".";
    }
    {
#line 1590
    sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%s/%s.%s",
            tmp___3, name, "so");
#line 1591
    unmetafy(buf___7, (int *)((void *)0));
    }
#line 1592
    if (buf___7[0]) {
      {
#line 1593
      ret = dlopen((char const   *)(buf___7), 257);
      }
    }
    __Cont: /* CIL Label */ 
#line 1587
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1596
  return (ret);
}
}
#line 1605 "/tmp/zsh-5.4.2/Src/module.c"
static void *do_load_module(char const   *name , int silent ) 
{ 
  void *ret ;
  char *errstr ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1610
  ret = try_load_module(name);
  }
#line 1611
  if (! ret) {
#line 1611
    if (! silent) {
      {
#line 1613
      tmp = dlerror();
#line 1613
      errstr = tmp;
      }
#line 1614
      if (errstr) {
        {
#line 1614
        tmp___0 = metafy(errstr, -1, 6);
#line 1614
        tmp___1 = (char const   *)tmp___0;
        }
      } else {
#line 1614
        tmp___1 = "empty module path";
      }
      {
#line 1614
      zwarn("failed to load module `%s\': %s", name, tmp___1);
      }
    }
  }
#line 1620
  return (ret);
}
}
#line 1654 "/tmp/zsh-5.4.2/Src/module.c"
static Module find_module(char const   *name , int flags , char const   **namep ) 
{ 
  Module m ;
  HashNode tmp ;
  Module tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1659
  tmp = (*(modulestab->getnode2))(modulestab, name);
#line 1659
  m = (Module )tmp;
  }
#line 1660
  if (m) {
#line 1661
    if (flags & 1) {
#line 1661
      if (m->node.flags & (1 << 6)) {
#line 1662
        if (namep) {
#line 1663
          *namep = (char const   *)m->u.alias;
        }
        {
#line 1664
        tmp___0 = find_module((char const   *)m->u.alias, flags, namep);
        }
#line 1664
        return (tmp___0);
      }
    }
#line 1666
    if (namep) {
#line 1667
      *namep = (char const   *)m->node.nam;
    }
#line 1668
    return (m);
  }
#line 1670
  if (! (flags & 2)) {
#line 1671
    return ((Module )((void *)0));
  }
  {
#line 1672
  tmp___1 = zshcalloc(sizeof(*m));
#line 1672
  m = (Module )tmp___1;
#line 1673
  tmp___2 = ztrdup(name);
#line 1673
  (*(modulestab->addnode))(modulestab, tmp___2, (void *)m);
  }
#line 1674
  return (m);
}
}
#line 1682 "/tmp/zsh-5.4.2/Src/module.c"
static void delete_module(Module m ) 
{ 


  {
  {
#line 1685
  (*(modulestab->removenode))(modulestab, (char const   *)m->node.nam);
#line 1687
  (*(modulestab->freenode))(& m->node);
  }
#line 1688
  return;
}
}
#line 1698 "/tmp/zsh-5.4.2/Src/module.c"
int module_loaded(char const   *name ) 
{ 
  Module m ;
  int tmp ;

  {
  {
#line 1703
  m = find_module(name, 1, (char const   **)((void *)0));
  }
#line 1703
  if (m) {
#line 1703
    if (m->u.handle) {
#line 1703
      if (! (m->node.flags & (1 << 1))) {
#line 1703
        tmp = 1;
      } else {
#line 1703
        tmp = 0;
      }
    } else {
#line 1703
      tmp = 0;
    }
  } else {
#line 1703
    tmp = 0;
  }
#line 1703
  return (tmp);
}
}
#line 1765 "/tmp/zsh-5.4.2/Src/module.c"
static Module_generic_func module_func(Module m , char *name ) 
{ 
  void *tmp ;

  {
  {
#line 1769
  tmp = dlsym((void */* __restrict  */)m->u.handle, (char const   */* __restrict  */)name);
  }
#line 1769
  return ((int (*)(void))tmp);
}
}
#line 1795 "/tmp/zsh-5.4.2/Src/module.c"
static int dyn_setup_module(Module m ) 
{ 
  int (*fn___0)(Module  ) ;
  Module_generic_func tmp ;
  int tmp___0 ;

  {
  {
#line 1798
  tmp = module_func(m, (char *)"setup_");
#line 1798
  fn___0 = (int (*)(Module  ))tmp;
  }
#line 1800
  if (fn___0) {
    {
#line 1801
    tmp___0 = (*fn___0)(m);
    }
#line 1801
    return (tmp___0);
  }
  {
#line 1802
  zwarnnam((char const   *)m->node.nam, "no setup function");
  }
#line 1803
  return (1);
}
}
#line 1807 "/tmp/zsh-5.4.2/Src/module.c"
static int dyn_features_module(Module m , char ***features ) 
{ 
  int (*fn___0)(Module  , char *** ) ;
  Module_generic_func tmp ;
  int tmp___0 ;

  {
  {
#line 1810
  tmp = module_func(m, (char *)"features_");
#line 1810
  fn___0 = (int (*)(Module  , char *** ))tmp;
  }
#line 1813
  if (fn___0) {
    {
#line 1814
    tmp___0 = (*fn___0)(m, features);
    }
#line 1814
    return (tmp___0);
  }
#line 1816
  return (1);
}
}
#line 1820 "/tmp/zsh-5.4.2/Src/module.c"
static int dyn_enables_module(Module m , int **enables ) 
{ 
  int (*fn___0)(Module  , int ** ) ;
  Module_generic_func tmp ;
  int tmp___0 ;

  {
  {
#line 1823
  tmp = module_func(m, (char *)"enables_");
#line 1823
  fn___0 = (int (*)(Module  , int ** ))tmp;
  }
#line 1825
  if (fn___0) {
    {
#line 1826
    tmp___0 = (*fn___0)(m, enables);
    }
#line 1826
    return (tmp___0);
  }
#line 1828
  return (1);
}
}
#line 1832 "/tmp/zsh-5.4.2/Src/module.c"
static int dyn_boot_module(Module m ) 
{ 
  int (*fn___0)(Module  ) ;
  Module_generic_func tmp ;
  int tmp___0 ;

  {
  {
#line 1835
  tmp = module_func(m, (char *)"boot_");
#line 1835
  fn___0 = (int (*)(Module  ))tmp;
  }
#line 1837
  if (fn___0) {
    {
#line 1838
    tmp___0 = (*fn___0)(m);
    }
#line 1838
    return (tmp___0);
  }
  {
#line 1839
  zwarnnam((char const   *)m->node.nam, "no boot function");
  }
#line 1840
  return (1);
}
}
#line 1844 "/tmp/zsh-5.4.2/Src/module.c"
static int dyn_cleanup_module(Module m ) 
{ 
  int (*fn___0)(Module  ) ;
  Module_generic_func tmp ;
  int tmp___0 ;

  {
  {
#line 1847
  tmp = module_func(m, (char *)"cleanup_");
#line 1847
  fn___0 = (int (*)(Module  ))tmp;
  }
#line 1849
  if (fn___0) {
    {
#line 1850
    tmp___0 = (*fn___0)(m);
    }
#line 1850
    return (tmp___0);
  }
  {
#line 1851
  zwarnnam((char const   *)m->node.nam, "no cleanup function");
  }
#line 1852
  return (1);
}
}
#line 1859 "/tmp/zsh-5.4.2/Src/module.c"
static int dyn_finish_module(Module m ) 
{ 
  int (*fn___0)(Module  ) ;
  Module_generic_func tmp ;
  int r ;

  {
  {
#line 1862
  tmp = module_func(m, (char *)"finish_");
#line 1862
  fn___0 = (int (*)(Module  ))tmp;
  }
#line 1865
  if (fn___0) {
    {
#line 1866
    r = (*fn___0)(m);
    }
  } else {
    {
#line 1868
    zwarnnam((char const   *)m->node.nam, "no finish function");
#line 1869
    r = 1;
    }
  }
  {
#line 1871
  dlclose(m->u.handle);
  }
#line 1872
  return (r);
}
}
#line 1879 "/tmp/zsh-5.4.2/Src/module.c"
static int setup_module(Module m ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1882
  if (m->node.flags & (1 << 3)) {
    {
#line 1882
    tmp = (*((m->u.linked)->setup))(m);
#line 1882
    tmp___1 = tmp;
    }
  } else {
    {
#line 1882
    tmp___0 = dyn_setup_module(m);
#line 1882
    tmp___1 = tmp___0;
    }
  }
#line 1882
  return (tmp___1);
}
}
#line 1887 "/tmp/zsh-5.4.2/Src/module.c"
static int features_module(Module m , char ***features ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1890
  if (m->node.flags & (1 << 3)) {
    {
#line 1890
    tmp = (*((m->u.linked)->features))(m, features);
#line 1890
    tmp___1 = tmp;
    }
  } else {
    {
#line 1890
    tmp___0 = dyn_features_module(m, features);
#line 1890
    tmp___1 = tmp___0;
    }
  }
#line 1890
  return (tmp___1);
}
}
#line 1896 "/tmp/zsh-5.4.2/Src/module.c"
static int enables_module(Module m , int **enables ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1899
  if (m->node.flags & (1 << 3)) {
    {
#line 1899
    tmp = (*((m->u.linked)->enables))(m, enables);
#line 1899
    tmp___1 = tmp;
    }
  } else {
    {
#line 1899
    tmp___0 = dyn_enables_module(m, enables);
#line 1899
    tmp___1 = tmp___0;
    }
  }
#line 1899
  return (tmp___1);
}
}
#line 1905 "/tmp/zsh-5.4.2/Src/module.c"
static int boot_module(Module m ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1908
  if (m->node.flags & (1 << 3)) {
    {
#line 1908
    tmp = (*((m->u.linked)->boot))(m);
#line 1908
    tmp___1 = tmp;
    }
  } else {
    {
#line 1908
    tmp___0 = dyn_boot_module(m);
#line 1908
    tmp___1 = tmp___0;
    }
  }
#line 1908
  return (tmp___1);
}
}
#line 1913 "/tmp/zsh-5.4.2/Src/module.c"
static int cleanup_module(Module m ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1916
  if (m->node.flags & (1 << 3)) {
    {
#line 1916
    tmp = (*((m->u.linked)->cleanup))(m);
#line 1916
    tmp___1 = tmp;
    }
  } else {
    {
#line 1916
    tmp___0 = dyn_cleanup_module(m);
#line 1916
    tmp___1 = tmp___0;
    }
  }
#line 1916
  return (tmp___1);
}
}
#line 1921 "/tmp/zsh-5.4.2/Src/module.c"
static int finish_module(Module m ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1924
  if (m->node.flags & (1 << 3)) {
    {
#line 1924
    tmp = (*((m->u.linked)->finish))(m);
#line 1924
    tmp___1 = tmp;
    }
  } else {
    {
#line 1924
    tmp___0 = dyn_finish_module(m);
#line 1924
    tmp___1 = tmp___0;
    }
  }
#line 1924
  return (tmp___1);
}
}
#line 1993 "/tmp/zsh-5.4.2/Src/module.c"
static int do_module_features(Module m , Feature_enables enablesarr , int flags ) 
{ 
  char **features ;
  int ret ;
  int *enables ;
  int tmp ;
  LinkNode an ;
  LinkNode nextn ;
  char *al ;
  char **ptr___0 ;
  int tmp___0 ;
  char *arg[2] ;
  Feature_enables fep ;
  char *str ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  Feature_enables fep___0 ;
  char **fp ;
  char *esp ;
  int on ;
  int found ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int n_features ;
  int tmp___10 ;
  int *ep___0 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 1997
  ret = 0;
#line 1999
  tmp___13 = features_module(m, & features);
  }
#line 1999
  if (tmp___13 == 0) {
    {
#line 2007
    enables = (int *)((void *)0);
#line 2008
    tmp = enables_module(m, & enables);
    }
#line 2008
    if (tmp) {
#line 2010
      if (! (flags & 1)) {
        {
#line 2011
        zwarn("error getting enabled features for module `%s\'", m->node.nam);
        }
      }
#line 2013
      return (1);
    }
#line 2016
    if (flags & 16) {
#line 2016
      if (m->autoloads) {
#line 2024
        an = (m->autoloads)->list.first;
        {
#line 2024
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2024
          if (! an) {
#line 2024
            goto while_break;
          }
#line 2025
          al = (char *)an->dat;
#line 2027
          nextn = an->next;
#line 2028
          ptr___0 = features;
          {
#line 2028
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2028
            if (! *ptr___0) {
#line 2028
              goto while_break___0;
            }
            {
#line 2029
            tmp___0 = strcmp((char const   *)al, (char const   *)*ptr___0);
            }
#line 2029
            if (! tmp___0) {
#line 2030
              goto while_break___0;
            }
#line 2028
            ptr___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 2031
          if (! *ptr___0) {
#line 2033
            if (! (flags & 1)) {
              {
#line 2034
              zwarn("module `%s\' has no such feature: `%s\': autoload cancelled",
                    m->node.nam, al);
              }
            }
            {
#line 2041
            al = dupstring((char const   *)al);
#line 2041
            arg[0] = al;
#line 2042
            arg[1] = (char *)((void *)0);
#line 2043
            autofeatures((char const   *)((void *)0), (char const   *)m->node.nam,
                         arg, 0, 9);
            }
#line 2049
            if (enablesarr) {
#line 2051
              fep = enablesarr;
              {
#line 2051
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 2051
                if (! fep->str) {
#line 2051
                  goto while_break___1;
                }
#line 2052
                str = fep->str;
#line 2053
                if ((int )*str == 43) {
#line 2054
                  str ++;
                } else
#line 2053
                if ((int )*str == 45) {
#line 2054
                  str ++;
                }
#line 2055
                if (fep->pat) {
                  {
#line 2055
                  tmp___1 = pattry(fep->pat, al);
#line 2055
                  tmp___4 = tmp___1;
                  }
                } else {
                  {
#line 2055
                  tmp___2 = strcmp((char const   *)al, (char const   *)str);
                  }
#line 2055
                  if (tmp___2) {
#line 2055
                    tmp___3 = 0;
                  } else {
#line 2055
                    tmp___3 = 1;
                  }
#line 2055
                  tmp___4 = tmp___3;
                }
#line 2055
                if (tmp___4) {
#line 2058
                  ret = 1;
                  {
#line 2059
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 2059
                    if (! fep->str) {
#line 2059
                      goto while_break___2;
                    }
#line 2060
                    fep->str = (fep + 1)->str;
#line 2061
                    fep->pat = (fep + 1)->pat;
#line 2062
                    fep ++;
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 2064
                  if (! fep->pat) {
#line 2065
                    goto while_break___1;
                  }
                }
#line 2051
                fep ++;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
          }
#line 2024
          an = nextn;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
#line 2073
    if (enablesarr) {
#line 2075
      fep___0 = enablesarr;
      {
#line 2075
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2075
        if (! fep___0->str) {
#line 2075
          goto while_break___3;
        }
#line 2076
        esp = fep___0->str;
#line 2077
        on = 1;
#line 2077
        found = 0;
#line 2078
        if ((int )*esp == 43) {
#line 2079
          esp ++;
        } else
#line 2080
        if ((int )*esp == 45) {
#line 2081
          on = 0;
#line 2082
          esp ++;
        }
#line 2084
        fp = features;
        {
#line 2084
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2084
          if (! *fp) {
#line 2084
            goto while_break___4;
          }
#line 2085
          if (fep___0->pat) {
            {
#line 2085
            tmp___5 = pattry(fep___0->pat, *fp);
#line 2085
            tmp___8 = tmp___5;
            }
          } else {
            {
#line 2085
            tmp___6 = strcmp((char const   *)*fp, (char const   *)esp);
            }
#line 2085
            if (tmp___6) {
#line 2085
              tmp___7 = 0;
            } else {
#line 2085
              tmp___7 = 1;
            }
#line 2085
            tmp___8 = tmp___7;
          }
#line 2085
          if (tmp___8) {
#line 2086
            *(enables + (fp - features)) = on;
#line 2087
            found ++;
#line 2088
            if (! fep___0->pat) {
#line 2089
              goto while_break___4;
            }
          }
#line 2084
          fp ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 2091
        if (! found) {
#line 2092
          if (! (flags & 1)) {
#line 2093
            if (fep___0->pat) {
#line 2093
              tmp___9 = "module `%s\' has no feature matching: `%s\'";
            } else {
#line 2093
              tmp___9 = "module `%s\' has no such feature: `%s\'";
            }
            {
#line 2093
            zwarn(tmp___9, m->node.nam, esp);
            }
          }
#line 2097
          return (1);
        }
#line 2075
        fep___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 2105
      tmp___10 = arrlen(features);
#line 2105
      n_features = tmp___10;
#line 2107
      ep___0 = enables;
      }
      {
#line 2107
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2107
        tmp___11 = n_features;
#line 2107
        n_features --;
#line 2107
        if (! tmp___11) {
#line 2107
          goto while_break___5;
        }
#line 2108
        *ep___0 = 1;
#line 2107
        ep___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 2111
    tmp___12 = enables_module(m, & enables);
    }
#line 2111
    if (tmp___12) {
#line 2112
      return (2);
    }
  } else
#line 2113
  if (enablesarr) {
#line 2114
    if (! (flags & 1)) {
      {
#line 2115
      zwarn("module `%s\' does not support features", m->node.nam);
      }
    }
#line 2116
    return (1);
  }
#line 2120
  return (ret);
}
}
#line 2134 "/tmp/zsh-5.4.2/Src/module.c"
static int do_boot_module(Module m , Feature_enables enablesarr , int silent ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2137
  if (silent) {
#line 2137
    tmp = 17;
  } else {
#line 2137
    tmp = 16;
  }
  {
#line 2137
  tmp___0 = do_module_features(m, enablesarr, tmp);
#line 2137
  ret = tmp___0;
  }
#line 2141
  if (ret == 1) {
#line 2142
    return (1);
  }
  {
#line 2144
  tmp___1 = boot_module(m);
  }
#line 2144
  if (tmp___1) {
#line 2145
    return (1);
  }
#line 2146
  return (ret);
}
}
#line 2154 "/tmp/zsh-5.4.2/Src/module.c"
static int do_cleanup_module(Module m ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2157
  if (m->node.flags & (1 << 3)) {
#line 2157
    if (m->u.linked) {
      {
#line 2157
      tmp = (*((m->u.linked)->cleanup))(m);
      }
#line 2157
      if (tmp) {
#line 2157
        tmp___0 = 1;
      } else {
#line 2157
        tmp___0 = 0;
      }
    } else {
#line 2157
      tmp___0 = 0;
    }
#line 2157
    tmp___3 = tmp___0;
  } else {
#line 2157
    if (m->u.handle) {
      {
#line 2157
      tmp___1 = cleanup_module(m);
      }
#line 2157
      if (tmp___1) {
#line 2157
        tmp___2 = 1;
      } else {
#line 2157
        tmp___2 = 0;
      }
    } else {
#line 2157
      tmp___2 = 0;
    }
#line 2157
    tmp___3 = tmp___2;
  }
#line 2157
  return (tmp___3);
}
}
#line 2168 "/tmp/zsh-5.4.2/Src/module.c"
static int modname_ok(char const   *p ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2171
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2172
    tmp = itype_end(p, 1 << 7, 0);
#line 2172
    p = (char const   *)tmp;
    }
#line 2173
    if (! *p) {
#line 2174
      return (1);
    }
#line 2171
    tmp___0 = p;
#line 2171
    p ++;
#line 2171
    if (! ((int const   )*tmp___0 == 47)) {
#line 2171
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2176
  return (0);
}
}
#line 2196 "/tmp/zsh-5.4.2/Src/module.c"
int load_module(char const   *name , Feature_enables enablesarr , int silent ) 
{ 
  Module m ;
  void *handle ;
  Linkedmod linked ;
  int set ;
  int bootret ;
  int tmp ;
  sigset_t oset ;
  void *tmp___0 ;
  char *tmp___1 ;
  sigset_t oset___0 ;
  sigset_t oset___1 ;
  sigset_t oset___2 ;
  sigset_t oset___3 ;
  Linkedmod tmp___2 ;
  sigset_t oset___4 ;
  LinkNode n ;
  sigset_t oset___5 ;
  int tmp___3 ;
  sigset_t oset___6 ;
  sigset_t oset___7 ;
  int tmp___4 ;
  sigset_t oset___8 ;
  sigset_t oset___9 ;

  {
  {
#line 2200
  handle = (void *)0;
#line 2204
  tmp = modname_ok(name);
  }
#line 2204
  if (! tmp) {
#line 2205
    if (! silent) {
      {
#line 2206
      zerr("invalid module name `%s\'", name);
      }
    }
#line 2207
    return (1);
  }
  {
#line 2214
  queueing_enabled ++;
#line 2215
  m = find_module(name, 1, & name);
  }
#line 2215
  if (! m) {
    {
#line 2216
    linked = module_linked(name);
    }
#line 2216
    if (! linked) {
      {
#line 2216
      handle = do_load_module(name, silent);
      }
#line 2216
      if (! handle) {
        {
#line 2218
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2218
          queueing_enabled --;
#line 2218
          if (! queueing_enabled) {
            {
#line 2218
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 2218
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 2218
                if (! (queue_front != queue_rear)) {
#line 2218
                  goto while_break___1;
                }
                {
#line 2218
                queue_front = (queue_front + 1) % 128;
#line 2218
                oset = signal_setmask(signal_mask_queue[queue_front]);
#line 2218
                zhandler(signal_queue[queue_front]);
#line 2218
                signal_setmask(oset);
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 2218
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 2218
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 2219
        return (1);
      }
    }
    {
#line 2221
    tmp___0 = zshcalloc(sizeof(*m));
#line 2221
    m = (Module )tmp___0;
    }
#line 2222
    if (handle) {
#line 2223
      m->u.handle = handle;
#line 2224
      m->node.flags |= 1 << 2;
    } else {
#line 2226
      m->u.linked = linked;
#line 2227
      m->node.flags |= (1 << 2) | (1 << 3);
    }
    {
#line 2229
    tmp___1 = ztrdup(name);
#line 2229
    (*(modulestab->addnode))(modulestab, tmp___1, (void *)m);
#line 2231
    set = setup_module(m);
    }
#line 2231
    if (set) {
#line 2231
      goto _L;
    } else {
      {
#line 2231
      bootret = do_boot_module(m, enablesarr, silent);
      }
#line 2231
      if (bootret == 1) {
        _L: /* CIL Label */ 
#line 2233
        if (! set) {
          {
#line 2234
          do_cleanup_module(m);
          }
        }
        {
#line 2235
        finish_module(m);
#line 2236
        delete_module(m);
        }
        {
#line 2237
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2237
          queueing_enabled --;
#line 2237
          if (! queueing_enabled) {
            {
#line 2237
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 2237
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 2237
                if (! (queue_front != queue_rear)) {
#line 2237
                  goto while_break___4;
                }
                {
#line 2237
                queue_front = (queue_front + 1) % 128;
#line 2237
                oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 2237
                zhandler(signal_queue[queue_front]);
#line 2237
                signal_setmask(oset___0);
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 2237
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 2237
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2238
        return (1);
      }
    }
#line 2240
    m->node.flags |= (1 << 4) | (1 << 5);
#line 2241
    m->node.flags &= ~ (1 << 2);
    {
#line 2242
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2242
      queueing_enabled --;
#line 2242
      if (! queueing_enabled) {
        {
#line 2242
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 2242
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 2242
            if (! (queue_front != queue_rear)) {
#line 2242
              goto while_break___7;
            }
            {
#line 2242
            queue_front = (queue_front + 1) % 128;
#line 2242
            oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 2242
            zhandler(signal_queue[queue_front]);
#line 2242
            signal_setmask(oset___1);
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 2242
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 2242
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2243
    return (bootret);
  }
#line 2245
  if (m->node.flags & (1 << 2)) {
    {
#line 2246
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2246
      queueing_enabled --;
#line 2246
      if (! queueing_enabled) {
        {
#line 2246
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 2246
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 2246
            if (! (queue_front != queue_rear)) {
#line 2246
              goto while_break___10;
            }
            {
#line 2246
            queue_front = (queue_front + 1) % 128;
#line 2246
            oset___2 = signal_setmask(signal_mask_queue[queue_front]);
#line 2246
            zhandler(signal_queue[queue_front]);
#line 2246
            signal_setmask(oset___2);
            }
          }
          while_break___10: /* CIL Label */ ;
          }
#line 2246
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
#line 2246
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 2247
    return (0);
  }
#line 2249
  if (m->node.flags & (1 << 1)) {
#line 2250
    m->node.flags &= ~ (1 << 1);
  } else {
#line 2251
    if (m->node.flags & (1 << 3)) {
#line 2251
      tmp___2 = m->u.linked;
    } else {
#line 2251
      tmp___2 = (Linkedmod )m->u.handle;
    }
#line 2251
    if (tmp___2) {
      {
#line 2252
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 2252
        queueing_enabled --;
#line 2252
        if (! queueing_enabled) {
          {
#line 2252
          while (1) {
            while_continue___12: /* CIL Label */ ;
            {
#line 2252
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 2252
              if (! (queue_front != queue_rear)) {
#line 2252
                goto while_break___13;
              }
              {
#line 2252
              queue_front = (queue_front + 1) % 128;
#line 2252
              oset___3 = signal_setmask(signal_mask_queue[queue_front]);
#line 2252
              zhandler(signal_queue[queue_front]);
#line 2252
              signal_setmask(oset___3);
              }
            }
            while_break___13: /* CIL Label */ ;
            }
#line 2252
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
        }
#line 2252
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 2253
      return (0);
    }
  }
#line 2255
  if (m->node.flags & 1) {
    {
#line 2256
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 2256
      queueing_enabled --;
#line 2256
      if (! queueing_enabled) {
        {
#line 2256
        while (1) {
          while_continue___15: /* CIL Label */ ;
          {
#line 2256
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 2256
            if (! (queue_front != queue_rear)) {
#line 2256
              goto while_break___16;
            }
            {
#line 2256
            queue_front = (queue_front + 1) % 128;
#line 2256
            oset___4 = signal_setmask(signal_mask_queue[queue_front]);
#line 2256
            zhandler(signal_queue[queue_front]);
#line 2256
            signal_setmask(oset___4);
            }
          }
          while_break___16: /* CIL Label */ ;
          }
#line 2256
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
#line 2256
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 2257
    zerr("circular dependencies for module ;%s", name);
    }
#line 2258
    return (1);
  }
#line 2260
  m->node.flags |= 1;
#line 2265
  if (m->deps) {
#line 2267
    n = (m->deps)->list.first;
    {
#line 2267
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 2267
      if (! n) {
#line 2267
        goto while_break___17;
      }
      {
#line 2268
      tmp___3 = load_module((char const   *)((char *)n->dat), (Feature_enables )((void *)0),
                            silent);
      }
#line 2268
      if (tmp___3 == 1) {
#line 2269
        m->node.flags &= -2;
        {
#line 2270
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 2270
          queueing_enabled --;
#line 2270
          if (! queueing_enabled) {
            {
#line 2270
            while (1) {
              while_continue___19: /* CIL Label */ ;
              {
#line 2270
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 2270
                if (! (queue_front != queue_rear)) {
#line 2270
                  goto while_break___20;
                }
                {
#line 2270
                queue_front = (queue_front + 1) % 128;
#line 2270
                oset___5 = signal_setmask(signal_mask_queue[queue_front]);
#line 2270
                zhandler(signal_queue[queue_front]);
#line 2270
                signal_setmask(oset___5);
                }
              }
              while_break___20: /* CIL Label */ ;
              }
#line 2270
              goto while_break___19;
            }
            while_break___19: /* CIL Label */ ;
            }
          }
#line 2270
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
#line 2271
        return (1);
      }
#line 2267
      n = n->next;
    }
    while_break___17: /* CIL Label */ ;
    }
  }
#line 2274
  m->node.flags &= -2;
#line 2275
  if (! m->u.handle) {
    {
#line 2276
    handle = (void *)0;
#line 2277
    linked = module_linked(name);
    }
#line 2277
    if (! linked) {
      {
#line 2277
      handle = do_load_module(name, silent);
      }
#line 2277
      if (! handle) {
        {
#line 2279
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 2279
          queueing_enabled --;
#line 2279
          if (! queueing_enabled) {
            {
#line 2279
            while (1) {
              while_continue___22: /* CIL Label */ ;
              {
#line 2279
              while (1) {
                while_continue___23: /* CIL Label */ ;
#line 2279
                if (! (queue_front != queue_rear)) {
#line 2279
                  goto while_break___23;
                }
                {
#line 2279
                queue_front = (queue_front + 1) % 128;
#line 2279
                oset___6 = signal_setmask(signal_mask_queue[queue_front]);
#line 2279
                zhandler(signal_queue[queue_front]);
#line 2279
                signal_setmask(oset___6);
                }
              }
              while_break___23: /* CIL Label */ ;
              }
#line 2279
              goto while_break___22;
            }
            while_break___22: /* CIL Label */ ;
            }
          }
#line 2279
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 2280
        return (1);
      }
    }
#line 2282
    if (handle) {
#line 2283
      m->u.handle = handle;
#line 2284
      m->node.flags |= 1 << 2;
    } else {
#line 2286
      m->u.linked = linked;
#line 2287
      m->node.flags |= (1 << 2) | (1 << 3);
    }
    {
#line 2289
    tmp___4 = setup_module(m);
    }
#line 2289
    if (tmp___4) {
      {
#line 2290
      finish_module(m);
      }
#line 2291
      if (handle) {
#line 2292
        m->u.handle = (void *)0;
      } else {
#line 2294
        m->u.linked = (Linkedmod )((void *)0);
      }
#line 2295
      m->node.flags &= ~ (1 << 2);
      {
#line 2296
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 2296
        queueing_enabled --;
#line 2296
        if (! queueing_enabled) {
          {
#line 2296
          while (1) {
            while_continue___25: /* CIL Label */ ;
            {
#line 2296
            while (1) {
              while_continue___26: /* CIL Label */ ;
#line 2296
              if (! (queue_front != queue_rear)) {
#line 2296
                goto while_break___26;
              }
              {
#line 2296
              queue_front = (queue_front + 1) % 128;
#line 2296
              oset___7 = signal_setmask(signal_mask_queue[queue_front]);
#line 2296
              zhandler(signal_queue[queue_front]);
#line 2296
              signal_setmask(oset___7);
              }
            }
            while_break___26: /* CIL Label */ ;
            }
#line 2296
            goto while_break___25;
          }
          while_break___25: /* CIL Label */ ;
          }
        }
#line 2296
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 2297
      return (1);
    }
#line 2299
    m->node.flags |= 1 << 4;
  }
  {
#line 2301
  m->node.flags |= 1 << 2;
#line 2302
  bootret = do_boot_module(m, enablesarr, silent);
  }
#line 2302
  if (bootret == 1) {
    {
#line 2303
    do_cleanup_module(m);
#line 2304
    finish_module(m);
    }
#line 2305
    if (m->node.flags & (1 << 3)) {
#line 2306
      m->u.linked = (Linkedmod )((void *)0);
    } else {
#line 2308
      m->u.handle = (void *)0;
    }
#line 2309
    m->node.flags &= ~ (1 << 2);
    {
#line 2310
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 2310
      queueing_enabled --;
#line 2310
      if (! queueing_enabled) {
        {
#line 2310
        while (1) {
          while_continue___28: /* CIL Label */ ;
          {
#line 2310
          while (1) {
            while_continue___29: /* CIL Label */ ;
#line 2310
            if (! (queue_front != queue_rear)) {
#line 2310
              goto while_break___29;
            }
            {
#line 2310
            queue_front = (queue_front + 1) % 128;
#line 2310
            oset___8 = signal_setmask(signal_mask_queue[queue_front]);
#line 2310
            zhandler(signal_queue[queue_front]);
#line 2310
            signal_setmask(oset___8);
            }
          }
          while_break___29: /* CIL Label */ ;
          }
#line 2310
          goto while_break___28;
        }
        while_break___28: /* CIL Label */ ;
        }
      }
#line 2310
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
#line 2311
    return (1);
  }
#line 2313
  m->node.flags |= 1 << 5;
#line 2314
  m->node.flags &= ~ (1 << 2);
  {
#line 2315
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 2315
    queueing_enabled --;
#line 2315
    if (! queueing_enabled) {
      {
#line 2315
      while (1) {
        while_continue___31: /* CIL Label */ ;
        {
#line 2315
        while (1) {
          while_continue___32: /* CIL Label */ ;
#line 2315
          if (! (queue_front != queue_rear)) {
#line 2315
            goto while_break___32;
          }
          {
#line 2315
          queue_front = (queue_front + 1) % 128;
#line 2315
          oset___9 = signal_setmask(signal_mask_queue[queue_front]);
#line 2315
          zhandler(signal_queue[queue_front]);
#line 2315
          signal_setmask(oset___9);
          }
        }
        while_break___32: /* CIL Label */ ;
        }
#line 2315
        goto while_break___31;
      }
      while_break___31: /* CIL Label */ ;
      }
    }
#line 2315
    goto while_break___30;
  }
  while_break___30: /* CIL Label */ ;
  }
#line 2316
  return (bootret);
}
}
#line 2339 "/tmp/zsh-5.4.2/Src/module.c"
int require_module(char const   *module , Feature_enables features , int silent ) 
{ 
  Module m ;
  int ret ;
  sigset_t oset ;

  {
  {
#line 2342
  m = (Module )((void *)0);
#line 2343
  ret = 0;
#line 2346
  queueing_enabled ++;
#line 2347
  m = find_module(module, 1, & module);
  }
#line 2348
  if (! m) {
    {
#line 2350
    ret = load_module(module, features, silent);
    }
  } else
#line 2348
  if (! m->u.handle) {
    {
#line 2350
    ret = load_module(module, features, silent);
    }
  } else
#line 2348
  if (m->node.flags & (1 << 1)) {
    {
#line 2350
    ret = load_module(module, features, silent);
    }
  } else {
    {
#line 2352
    ret = do_module_features(m, features, 0);
    }
  }
  {
#line 2353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2353
    queueing_enabled --;
#line 2353
    if (! queueing_enabled) {
      {
#line 2353
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2353
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2353
          if (! (queue_front != queue_rear)) {
#line 2353
            goto while_break___1;
          }
          {
#line 2353
          queue_front = (queue_front + 1) % 128;
#line 2353
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 2353
          zhandler(signal_queue[queue_front]);
#line 2353
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2353
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2353
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2355
  return (ret);
}
}
#line 2364 "/tmp/zsh-5.4.2/Src/module.c"
void add_dep(char const   *name , char *from ) 
{ 
  LinkNode node ;
  Module m ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 2382
  m = find_module(name, 3, & name);
  }
#line 2383
  if (! m->deps) {
    {
#line 2384
    m->deps = znewlinklist();
    }
  }
#line 2385
  node = (m->deps)->list.first;
  {
#line 2385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2385
    if (node) {
      {
#line 2385
      tmp = strcmp((char const   *)((char *)node->dat), (char const   *)from);
      }
#line 2385
      if (! tmp) {
#line 2385
        goto while_break;
      }
    } else {
#line 2385
      goto while_break;
    }
#line 2385
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2388
  if (! node) {
    {
#line 2389
    tmp___0 = ztrdup((char const   *)from);
#line 2389
    zinsertlinknode(m->deps, (m->deps)->list.last, (void *)tmp___0);
    }
  }
#line 2390
  return;
}
}
#line 2398 "/tmp/zsh-5.4.2/Src/module.c"
static void autoloadscan(HashNode hn , int printflags ) 
{ 
  Builtin bn ;
  int tmp ;
  int tmp___0 ;

  {
#line 2401
  bn = (Builtin )hn;
#line 2403
  if (bn->node.flags & (1 << 3)) {
#line 2404
    return;
  }
#line 2405
  if (printflags & (1 << 2)) {
    {
#line 2406
    fputs((char const   */* __restrict  */)"zmodload -ab ", (FILE */* __restrict  */)stdout);
    }
#line 2407
    if ((int )*(bn->optstr + 0) == 45) {
      {
#line 2408
      fputs((char const   */* __restrict  */)"-- ", (FILE */* __restrict  */)stdout);
      }
    }
    {
#line 2409
    quotedzputs((char const   *)bn->optstr, stdout);
#line 2410
    tmp = strcmp((char const   *)bn->node.nam, (char const   *)bn->optstr);
    }
#line 2410
    if (tmp) {
      {
#line 2411
      putchar(' ');
#line 2412
      quotedzputs((char const   *)bn->node.nam, stdout);
      }
    }
  } else {
    {
#line 2415
    mb_niceformat((char const   *)bn->node.nam, stdout, (char **)((void *)0), 0);
#line 2416
    tmp___0 = strcmp((char const   *)bn->node.nam, (char const   *)bn->optstr);
    }
#line 2416
    if (tmp___0) {
      {
#line 2417
      fputs((char const   */* __restrict  */)" (", (FILE */* __restrict  */)stdout);
#line 2418
      mb_niceformat((char const   *)bn->optstr, stdout, (char **)((void *)0), 0);
#line 2419
      putchar(')');
      }
    }
  }
  {
#line 2422
  putchar('\n');
  }
#line 2423
  return;
}
}
#line 2435 "/tmp/zsh-5.4.2/Src/module.c"
int bin_zmodload(char *nam , char **args , Options ops , int func  __attribute__((__unused__)) ) 
{ 
  int ops_bcpf ;
  int tmp ;
  int ops_au ;
  int tmp___0 ;
  int ret ;
  int autoopts ;
  char *fonly ;
  char *fp ;
  int tmp___1 ;
  sigset_t oset ;

  {
#line 2438
  if ((int )ops->ind[98] != 0) {
#line 2438
    tmp = 1;
  } else
#line 2438
  if ((int )ops->ind[99] != 0) {
#line 2438
    tmp = 1;
  } else
#line 2438
  if ((int )ops->ind[112] != 0) {
#line 2438
    tmp = 1;
  } else
#line 2438
  if ((int )ops->ind[102] != 0) {
#line 2438
    tmp = 1;
  } else {
#line 2438
    tmp = 0;
  }
#line 2438
  ops_bcpf = tmp;
#line 2440
  if ((int )ops->ind[97] != 0) {
#line 2440
    tmp___0 = 1;
  } else
#line 2440
  if ((int )ops->ind[117] != 0) {
#line 2440
    tmp___0 = 1;
  } else {
#line 2440
    tmp___0 = 0;
  }
#line 2440
  ops_au = tmp___0;
#line 2441
  ret = 1;
#line 2443
  fonly = (char *)"lP";
#line 2445
  if (ops_bcpf) {
#line 2445
    if (! ops_au) {
      {
#line 2446
      zwarnnam((char const   *)nam, "-b, -c, -f, and -p must be combined with -a or -u");
      }
#line 2447
      return (1);
    }
  }
#line 2449
  if ((int )ops->ind[70] != 0) {
#line 2449
    if (ops_bcpf) {
      {
#line 2450
      zwarnnam((char const   *)nam, "-b, -c, -f, -p and -u cannot be combined with -F");
      }
#line 2451
      return (1);
    } else
#line 2449
    if ((int )ops->ind[117] != 0) {
      {
#line 2450
      zwarnnam((char const   *)nam, "-b, -c, -f, -p and -u cannot be combined with -F");
      }
#line 2451
      return (1);
    }
  }
#line 2453
  if ((int )ops->ind[65] != 0) {
#line 2453
    goto _L;
  } else
#line 2453
  if ((int )ops->ind[82] != 0) {
    _L: /* CIL Label */ 
#line 2454
    if (ops_bcpf) {
      {
#line 2456
      zwarnnam((char const   *)nam, "illegal flags combined with -A or -R");
      }
#line 2457
      return (1);
    } else
#line 2454
    if (ops_au) {
      {
#line 2456
      zwarnnam((char const   *)nam, "illegal flags combined with -A or -R");
      }
#line 2457
      return (1);
    } else
#line 2454
    if ((int )ops->ind[100] != 0) {
      {
#line 2456
      zwarnnam((char const   *)nam, "illegal flags combined with -A or -R");
      }
#line 2457
      return (1);
    } else
#line 2454
    if ((int )ops->ind[82] != 0) {
#line 2454
      if ((int )ops->ind[101] != 0) {
        {
#line 2456
        zwarnnam((char const   *)nam, "illegal flags combined with -A or -R");
        }
#line 2457
        return (1);
      }
    }
#line 2459
    if (! ((int )ops->ind[101] != 0)) {
      {
#line 2460
      tmp___1 = bin_zmodload_alias(nam, args, ops);
      }
#line 2460
      return (tmp___1);
    }
  }
#line 2462
  if ((int )ops->ind[100] != 0) {
#line 2462
    if ((int )ops->ind[97] != 0) {
      {
#line 2463
      zwarnnam((char const   *)nam, "-d cannot be combined with -a");
      }
#line 2464
      return (1);
    }
  }
#line 2466
  if ((int )ops->ind[117] != 0) {
#line 2466
    if (! *args) {
      {
#line 2467
      zwarnnam((char const   *)nam, "what do you want to unload?");
      }
#line 2468
      return (1);
    }
  }
#line 2470
  if ((int )ops->ind[101] != 0) {
#line 2470
    if ((int )ops->ind[73] != 0) {
      {
#line 2474
      zwarnnam((char const   *)nam, "-e cannot be combined with other options");
      }
#line 2476
      return (1);
    } else
#line 2470
    if ((int )ops->ind[76] != 0) {
      {
#line 2474
      zwarnnam((char const   *)nam, "-e cannot be combined with other options");
      }
#line 2476
      return (1);
    } else
#line 2470
    if ((int )ops->ind[97] != 0) {
#line 2470
      if (! ((int )ops->ind[70] != 0)) {
        {
#line 2474
        zwarnnam((char const   *)nam, "-e cannot be combined with other options");
        }
#line 2476
        return (1);
      } else {
#line 2470
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2470
    if ((int )ops->ind[100] != 0) {
      {
#line 2474
      zwarnnam((char const   *)nam, "-e cannot be combined with other options");
      }
#line 2476
      return (1);
    } else
#line 2470
    if ((int )ops->ind[105] != 0) {
      {
#line 2474
      zwarnnam((char const   *)nam, "-e cannot be combined with other options");
      }
#line 2476
      return (1);
    } else
#line 2470
    if ((int )ops->ind[117] != 0) {
      {
#line 2474
      zwarnnam((char const   *)nam, "-e cannot be combined with other options");
      }
#line 2476
      return (1);
    }
  }
#line 2478
  fp = fonly;
  {
#line 2478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2478
    if (! *fp) {
#line 2478
      goto while_break;
    }
#line 2479
    if ((int )ops->ind[(unsigned char )*fp] != 0) {
#line 2479
      if (! ((int )ops->ind[70] != 0)) {
        {
#line 2480
        zwarnnam((char const   *)nam, "-%c is only allowed with -F", (int )*fp);
        }
#line 2481
        return (1);
      }
    }
#line 2478
    fp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2484
  queueing_enabled ++;
#line 2485
  if ((int )ops->ind[70] != 0) {
    {
#line 2486
    ret = bin_zmodload_features((char const   *)nam, args, ops);
    }
  } else
#line 2487
  if ((int )ops->ind[101] != 0) {
    {
#line 2488
    ret = bin_zmodload_exist(nam, args, ops);
    }
  } else
#line 2489
  if ((int )ops->ind[100] != 0) {
    {
#line 2490
    ret = bin_zmodload_dep(nam, args, ops);
    }
  } else {
#line 2491
    autoopts = ((((int )ops->ind[98] != 0) + ((int )ops->ind[99] != 0)) + ((int )ops->ind[112] != 0)) + ((int )ops->ind[102] != 0);
#line 2491
    if (autoopts) {
#line 2491
      goto _L___1;
    } else
#line 2491
    if ((int )ops->ind[97] != 0) {
      _L___1: /* CIL Label */ 
#line 2495
      if (autoopts > 1) {
        {
#line 2496
        zwarnnam((char const   *)nam, "use only one of -b, -c, or -p");
#line 2497
        ret = 1;
        }
      } else {
        {
#line 2499
        ret = bin_zmodload_auto(nam, args, ops);
        }
      }
    } else {
      {
#line 2501
      ret = bin_zmodload_load(nam, args, ops);
      }
    }
  }
  {
#line 2502
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2502
    queueing_enabled --;
#line 2502
    if (! queueing_enabled) {
      {
#line 2502
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 2502
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2502
          if (! (queue_front != queue_rear)) {
#line 2502
            goto while_break___2;
          }
          {
#line 2502
          queue_front = (queue_front + 1) % 128;
#line 2502
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 2502
          zhandler(signal_queue[queue_front]);
#line 2502
          signal_setmask(oset);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2502
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2502
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2504
  return (ret);
}
}
#line 2510 "/tmp/zsh-5.4.2/Src/module.c"
static int bin_zmodload_alias(char *nam , char **args , Options ops ) 
{ 
  Module m ;
  int tmp ;
  char *eqpos ;
  char *tmp___0 ;
  char *aliasname ;
  char *tmp___1 ;
  int tmp___2 ;
  char const   *mname ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 2528
  if (! *args) {
#line 2529
    if ((int )ops->ind[82] != 0) {
      {
#line 2530
      zwarnnam((char const   *)nam, "no module alias to remove");
      }
#line 2531
      return (1);
    }
#line 2533
    if ((int )ops->ind[76] != 0) {
#line 2533
      tmp = 1;
    } else {
#line 2533
      tmp = 0;
    }
    {
#line 2533
    scanhashtable(modulestab, 1, 1 << 6, 0, modulestab->printnode, tmp);
    }
#line 2536
    return (0);
  }
  {
#line 2539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2539
    if (! *args) {
#line 2539
      goto while_break;
    }
    {
#line 2540
    tmp___0 = strchr((char const   *)*args, '=');
#line 2540
    eqpos = tmp___0;
    }
#line 2541
    if (eqpos) {
#line 2541
      tmp___1 = eqpos + 1;
    } else {
#line 2541
      tmp___1 = (char *)((void *)0);
    }
#line 2541
    aliasname = tmp___1;
#line 2542
    if (eqpos) {
#line 2543
      *eqpos = (char )'\000';
    }
    {
#line 2544
    tmp___2 = modname_ok((char const   *)*args);
    }
#line 2544
    if (! tmp___2) {
      {
#line 2545
      zwarnnam((char const   *)nam, "invalid module name `%s\'", *args);
      }
#line 2546
      return (1);
    }
#line 2548
    if ((int )ops->ind[82] != 0) {
#line 2549
      if (aliasname) {
        {
#line 2550
        zwarnnam((char const   *)nam, "bad syntax for removing module alias: %s",
                 *args);
        }
#line 2552
        return (1);
      }
      {
#line 2554
      m = find_module((char const   *)*args, 0, (char const   **)((void *)0));
      }
#line 2555
      if (m) {
#line 2556
        if (! (m->node.flags & (1 << 6))) {
          {
#line 2557
          zwarnnam((char const   *)nam, "module is not an alias: %s", *args);
          }
#line 2558
          return (1);
        }
        {
#line 2560
        delete_module(m);
        }
      } else {
        {
#line 2562
        zwarnnam((char const   *)nam, "no such module alias: %s", *args);
        }
#line 2563
        return (1);
      }
    } else
#line 2566
    if (aliasname) {
      {
#line 2567
      mname = (char const   *)aliasname;
#line 2568
      tmp___3 = modname_ok((char const   *)aliasname);
      }
#line 2568
      if (! tmp___3) {
        {
#line 2569
        zwarnnam((char const   *)nam, "invalid module name `%s\'", aliasname);
        }
#line 2570
        return (1);
      }
      {
#line 2572
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2573
        tmp___4 = strcmp(mname, (char const   *)*args);
        }
#line 2573
        if (! tmp___4) {
          {
#line 2574
          zwarnnam((char const   *)nam, "module alias would refer to itself: %s",
                   *args);
          }
#line 2576
          return (1);
        }
        {
#line 2572
        m = find_module(mname, 0, (char const   **)((void *)0));
        }
#line 2572
        if (m) {
#line 2572
          if (m->node.flags & (1 << 6)) {
#line 2572
            mname = (char const   *)m->u.alias;
#line 2572
            if (! mname) {
#line 2572
              goto while_break___0;
            }
          } else {
#line 2572
            goto while_break___0;
          }
        } else {
#line 2572
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2581
      m = find_module((char const   *)*args, 0, (char const   **)((void *)0));
      }
#line 2582
      if (m) {
#line 2583
        if (! (m->node.flags & (1 << 6))) {
          {
#line 2584
          zwarnnam((char const   *)nam, "module is not an alias: %s", *args);
          }
#line 2585
          return (1);
        }
        {
#line 2587
        zsfree(m->u.alias);
        }
      } else {
        {
#line 2589
        tmp___5 = zshcalloc(sizeof(*m));
#line 2589
        m = (Module )tmp___5;
#line 2590
        m->node.flags = 1 << 6;
#line 2591
        tmp___6 = ztrdup((char const   *)*args);
#line 2591
        (*(modulestab->addnode))(modulestab, tmp___6, (void *)m);
        }
      }
      {
#line 2593
      m->u.alias = ztrdup((char const   *)aliasname);
      }
    } else {
      {
#line 2595
      m = find_module((char const   *)*args, 0, (char const   **)((void *)0));
      }
#line 2595
      if (m) {
#line 2596
        if (m->node.flags & (1 << 6)) {
#line 2597
          if ((int )ops->ind[76] != 0) {
#line 2597
            tmp___7 = 1;
          } else {
#line 2597
            tmp___7 = 0;
          }
          {
#line 2597
          (*(modulestab->printnode))(& m->node, tmp___7);
          }
        } else {
          {
#line 2601
          zwarnnam((char const   *)nam, "module is not an alias: %s", *args);
          }
#line 2602
          return (1);
        }
      } else {
        {
#line 2605
        zwarnnam((char const   *)nam, "no such module alias: %s", *args);
        }
#line 2606
        return (1);
      }
    }
#line 2539
    args ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2612
  return (0);
}
}
#line 2618 "/tmp/zsh-5.4.2/Src/module.c"
static int bin_zmodload_exist(char *nam  __attribute__((__unused__)) , char **args ,
                              Options ops ) 
{ 
  Module m ;
  int tmp ;
  int ret ;

  {
#line 2623
  if (! *args) {
#line 2624
    if ((int )ops->ind[65] != 0) {
#line 2624
      tmp = 6;
    } else {
#line 2624
      tmp = 2;
    }
    {
#line 2624
    scanhashtable(modulestab, 1, 0, 0, modulestab->printnode, tmp);
    }
#line 2627
    return (0);
  } else {
#line 2629
    ret = 0;
    {
#line 2631
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2631
      if (! ret) {
#line 2631
        if (! *args) {
#line 2631
          goto while_break;
        }
      } else {
#line 2631
        goto while_break;
      }
      {
#line 2632
      m = find_module((char const   *)*args, 1, (char const   **)((void *)0));
      }
#line 2632
      if (m) {
#line 2632
        if (! m->u.handle) {
#line 2635
          ret = 1;
        } else
#line 2632
        if (m->node.flags & (1 << 1)) {
#line 2635
          ret = 1;
        }
      } else {
#line 2635
        ret = 1;
      }
#line 2631
      args ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2637
    return (ret);
  }
}
}
#line 2644 "/tmp/zsh-5.4.2/Src/module.c"
static int bin_zmodload_dep(char *nam  __attribute__((__unused__)) , char **args ,
                            Options ops ) 
{ 
  Module m ;
  char const   *tnam ;
  char **tmp ;
  LinkNode dnode ;
  int tmp___0 ;
  int depflags ;
  int tmp___1 ;
  HashNode tmp___2 ;
  int ret ;
  char *tnam___0 ;
  char **tmp___3 ;

  {
#line 2648
  if ((int )ops->ind[117] != 0) {
    {
#line 2650
    tmp = args;
#line 2650
    args ++;
#line 2650
    tnam = (char const   *)*tmp;
#line 2651
    m = find_module(tnam, 1, & tnam);
    }
#line 2652
    if (! m) {
#line 2653
      return (0);
    }
#line 2654
    if (*args) {
#line 2654
      if (m->deps) {
        {
#line 2655
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2657
          dnode = (m->deps)->list.first;
          {
#line 2657
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2657
            if (! dnode) {
#line 2657
              goto while_break___0;
            }
            {
#line 2658
            tmp___0 = strcmp((char const   *)*args, (char const   *)dnode->dat);
            }
#line 2658
            if (! tmp___0) {
              {
#line 2659
              zsfree((char *)dnode->dat);
#line 2660
              remnode(m->deps, dnode);
              }
#line 2661
              goto while_break___0;
            }
#line 2657
            dnode = dnode->next;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 2655
          args ++;
#line 2655
          if (! *args) {
#line 2655
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 2664
        if ((unsigned long )(m->deps)->list.first == (unsigned long )((void *)0)) {
          {
#line 2665
          freelinklist(m->deps, & freestr);
#line 2666
          m->deps = (LinkList )((void *)0);
          }
        }
      } else {
#line 2654
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2669
    if (m->deps) {
      {
#line 2670
      freelinklist(m->deps, & freestr);
#line 2671
      m->deps = (LinkList )((void *)0);
      }
    }
#line 2674
    if (! m->deps) {
#line 2674
      if (! m->u.handle) {
        {
#line 2675
        delete_module(m);
        }
      }
    }
#line 2676
    return (0);
  } else
#line 2677
  if (! *(args + 0)) {
#line 2677
    goto _L___0;
  } else
#line 2677
  if (! *(args + 1)) {
    _L___0: /* CIL Label */ 
#line 2679
    if ((int )ops->ind[76] != 0) {
#line 2679
      tmp___1 = 9;
    } else {
#line 2679
      tmp___1 = 8;
    }
#line 2679
    depflags = tmp___1;
#line 2681
    if (*(args + 0)) {
      {
#line 2682
      tmp___2 = (*(modulestab->getnode2))(modulestab, (char const   *)*(args + 0));
#line 2682
      m = (Module )tmp___2;
      }
#line 2682
      if (m) {
        {
#line 2683
        (*(modulestab->printnode))(& m->node, depflags);
        }
      }
    } else {
      {
#line 2685
      scanhashtable(modulestab, 1, 0, 0, modulestab->printnode, depflags);
      }
    }
#line 2688
    return (0);
  } else {
#line 2691
    ret = 0;
#line 2692
    tmp___3 = args;
#line 2692
    args ++;
#line 2692
    tnam___0 = *tmp___3;
    {
#line 2694
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2694
      if (! *args) {
#line 2694
        goto while_break___1;
      }
      {
#line 2695
      add_dep((char const   *)tnam___0, *args);
#line 2694
      args ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2696
    return (ret);
  }
}
}
#line 2705 "/tmp/zsh-5.4.2/Src/module.c"
static void printautoparams(HashNode hn , int lon ) 
{ 
  Param pm ;

  {
#line 2708
  pm = (Param )hn;
#line 2710
  if (pm->node.flags & (1 << 27)) {
#line 2711
    if (lon) {
      {
#line 2712
      printf((char const   */* __restrict  */)"zmodload -ap %s %s\n", pm->u.str, pm->node.nam);
      }
    } else {
      {
#line 2714
      printf((char const   */* __restrict  */)"%s (%s)\n", pm->node.nam, pm->u.str);
      }
    }
  }
#line 2716
  return;
}
}
#line 2721 "/tmp/zsh-5.4.2/Src/module.c"
static int bin_zmodload_auto(char *nam , char **args , Options ops ) 
{ 
  int fchar ;
  int flags ;
  char *modnam ;
  Conddef p ;
  MathFunc p___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 2727
  if ((int )ops->ind[99] != 0) {
#line 2728
    if (! *args) {
#line 2732
      p = condtab;
      {
#line 2732
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2732
        if (! p) {
#line 2732
          goto while_break;
        }
#line 2733
        if (p->module) {
#line 2734
          if ((int )ops->ind[76] != 0) {
            {
#line 2735
            fputs((char const   */* __restrict  */)"zmodload -ac", (FILE */* __restrict  */)stdout);
            }
#line 2736
            if (p->flags & 1) {
              {
#line 2737
              putchar('I');
              }
            }
            {
#line 2738
            printf((char const   */* __restrict  */)" %s %s\n", p->module, p->name);
            }
          } else {
#line 2740
            if (p->flags & 1) {
              {
#line 2741
              fputs((char const   */* __restrict  */)"infix ", (FILE */* __restrict  */)stdout);
              }
            } else {
              {
#line 2743
              fputs((char const   */* __restrict  */)"post ", (FILE */* __restrict  */)stdout);
              }
            }
            {
#line 2744
            printf((char const   */* __restrict  */)"%s (%s)\n", p->name, p->module);
            }
          }
        }
#line 2732
        p = p->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 2748
      return (0);
    }
#line 2750
    if ((int )ops->ind[73] != 0) {
#line 2750
      fchar = 'C';
    } else {
#line 2750
      fchar = 'c';
    }
  } else
#line 2751
  if ((int )ops->ind[112] != 0) {
#line 2752
    if (! *args) {
      {
#line 2754
      scanhashtable(paramtab, 1, 0, 0, & printautoparams, (int )ops->ind[76] != 0);
      }
#line 2756
      return (0);
    }
#line 2758
    fchar = 'p';
  } else
#line 2759
  if ((int )ops->ind[102] != 0) {
#line 2760
    if (! *args) {
#line 2764
      p___0 = mathfuncs;
      {
#line 2764
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2764
        if (! p___0) {
#line 2764
          goto while_break___0;
        }
#line 2765
        if (! (p___0->flags & 4)) {
#line 2765
          if (p___0->module) {
#line 2766
            if ((int )ops->ind[76] != 0) {
              {
#line 2767
              fputs((char const   */* __restrict  */)"zmodload -af", (FILE */* __restrict  */)stdout);
#line 2768
              printf((char const   */* __restrict  */)" %s %s\n", p___0->module, p___0->name);
              }
            } else {
              {
#line 2770
              printf((char const   */* __restrict  */)"%s (%s)\n", p___0->name, p___0->module);
              }
            }
          }
        }
#line 2764
        p___0 = p___0->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2773
      return (0);
    }
#line 2775
    fchar = 'f';
  } else {
#line 2778
    if (! *args) {
#line 2780
      if ((int )ops->ind[76] != 0) {
#line 2780
        tmp = 1 << 2;
      } else {
#line 2780
        tmp = 0;
      }
      {
#line 2780
      scanhashtable(builtintab, 1, 0, 0, & autoloadscan, tmp);
      }
#line 2782
      return (0);
    }
#line 2784
    fchar = 'b';
  }
#line 2787
  flags = 4;
#line 2788
  if ((int )ops->ind[105] != 0) {
#line 2789
    flags |= 1;
  }
#line 2790
  if ((int )ops->ind[117] != 0) {
#line 2792
    flags |= 8;
#line 2793
    modnam = (char *)((void *)0);
  } else {
#line 2796
    modnam = *args;
#line 2798
    if (*(args + 1)) {
#line 2799
      args ++;
    }
  }
  {
#line 2801
  tmp___0 = autofeatures((char const   *)nam, (char const   *)modnam, args, fchar,
                         flags);
  }
#line 2801
  return (tmp___0);
}
}
#line 2807 "/tmp/zsh-5.4.2/Src/module.c"
int unload_module(Module m ) 
{ 
  int del ;
  int tmp ;
  LinkNode n ;
  Module dm ;
  Module tmp___0 ;
  Module am ;
  int du ;
  int i ;
  LinkNode sn ;
  int tmp___1 ;
  int tmp___2 ;
  char **tmp___3 ;

  {
#line 2815
  if (m->node.flags & (1 << 6)) {
    {
#line 2816
    m = find_module((char const   *)m->u.alias, 1, (char const   **)((void *)0));
    }
#line 2817
    if (! m) {
#line 2818
      return (1);
    }
  }
#line 2827
  if (m->node.flags & (1 << 4)) {
#line 2827
    if (! (m->node.flags & (1 << 1))) {
      {
#line 2827
      tmp = do_cleanup_module(m);
      }
#line 2827
      if (tmp) {
#line 2830
        return (1);
      }
    }
  }
#line 2831
  m->node.flags &= ~ ((1 << 5) | (1 << 4));
#line 2833
  del = m->node.flags & (1 << 1);
#line 2835
  if (m->wrapper) {
#line 2836
    m->node.flags |= 1 << 1;
#line 2837
    return (0);
  }
#line 2839
  m->node.flags &= ~ (1 << 1);
#line 2845
  if (m->node.flags & (1 << 3)) {
#line 2846
    if (m->u.linked) {
      {
#line 2847
      (*((m->u.linked)->finish))(m);
#line 2848
      m->u.linked = (Linkedmod )((void *)0);
      }
    }
  } else
#line 2851
  if (m->u.handle) {
    {
#line 2852
    finish_module(m);
#line 2853
    m->u.handle = (void *)0;
    }
  }
#line 2857
  if (del) {
#line 2857
    if (m->deps) {
#line 2862
      n = (m->deps)->list.first;
      {
#line 2862
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2862
        if (! n) {
#line 2862
          goto while_break;
        }
        {
#line 2863
        tmp___0 = find_module((char const   *)((char *)n->dat), 1, (char const   **)((void *)0));
#line 2863
        dm = tmp___0;
        }
#line 2866
        if (dm) {
#line 2866
          if (dm->node.flags & (1 << 1)) {
#line 2870
            du = 1;
#line 2872
            i = 0;
            {
#line 2872
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 2872
              if (du) {
#line 2872
                if (! (i < modulestab->hsize)) {
#line 2872
                  goto while_break___0;
                }
              } else {
#line 2872
                goto while_break___0;
              }
#line 2873
              am = (Module )*(modulestab->nodes + i);
              {
#line 2873
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 2873
                if (du) {
#line 2873
                  if (! am) {
#line 2873
                    goto while_break___1;
                  }
                } else {
#line 2873
                  goto while_break___1;
                }
#line 2880
                if ((unsigned long )am == (unsigned long )m) {
#line 2881
                  goto __Cont;
                } else
#line 2880
                if (! am->deps) {
#line 2881
                  goto __Cont;
                }
#line 2883
                if (am->node.flags & (1 << 3)) {
#line 2883
                  tmp___1 = ! am->u.linked;
                } else {
#line 2883
                  tmp___1 = ! am->u.handle;
                }
#line 2883
                if (tmp___1) {
#line 2885
                  goto __Cont;
                }
#line 2886
                sn = (am->deps)->list.first;
                {
#line 2886
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 2886
                  if (du) {
#line 2886
                    if (! sn) {
#line 2886
                      goto while_break___2;
                    }
                  } else {
#line 2886
                    goto while_break___2;
                  }
                  {
#line 2888
                  tmp___2 = strcmp((char const   *)((char *)sn->dat), (char const   *)dm->node.nam);
                  }
#line 2888
                  if (! tmp___2) {
#line 2890
                    du = 0;
                  }
#line 2886
                  sn = sn->next;
                }
                while_break___2: /* CIL Label */ ;
                }
                __Cont: /* CIL Label */ 
#line 2873
                am = (Module )am->node.next;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 2872
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 2894
            if (du) {
              {
#line 2895
              unload_module(dm);
              }
            }
          }
        }
#line 2862
        n = n->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2899
  if (m->autoloads) {
#line 2899
    if ((m->autoloads)->list.first) {
      {
#line 2904
      tmp___3 = hlinklist2array(m->autoloads, 0);
#line 2904
      autofeatures("zsh", (char const   *)m->node.nam, tmp___3, 0, 1);
      }
    } else {
#line 2899
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2906
  if (! m->deps) {
    {
#line 2907
    delete_module(m);
    }
  }
#line 2909
  return (0);
}
}
#line 2919 "/tmp/zsh-5.4.2/Src/module.c"
int unload_named_module(char *modname , char *nam , int silent ) 
{ 
  char const   *mname ;
  Module m ;
  int ret ;
  int i ;
  int del ;
  Module dm ;
  LinkNode dn ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2924
  ret = 0;
#line 2926
  m = find_module((char const   *)modname, 1, & mname);
  }
#line 2927
  if (m) {
#line 2928
    del = 0;
#line 2931
    i = 0;
    {
#line 2931
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2931
      if (! (i < modulestab->hsize)) {
#line 2931
        goto while_break;
      }
#line 2932
      dm = (Module )*(modulestab->nodes + i);
      {
#line 2932
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2932
        if (! dm) {
#line 2932
          goto while_break___0;
        }
#line 2935
        if (! dm->deps) {
#line 2936
          goto __Cont;
        } else
#line 2935
        if (! dm->u.handle) {
#line 2936
          goto __Cont;
        }
#line 2937
        dn = (dm->deps)->list.first;
        {
#line 2937
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2937
          if (! dn) {
#line 2937
            goto while_break___1;
          }
          {
#line 2938
          tmp = strcmp((char const   *)((char *)dn->dat), mname);
          }
#line 2938
          if (! tmp) {
#line 2939
            if (dm->node.flags & (1 << 1)) {
#line 2940
              del = 1;
            } else {
              {
#line 2942
              zwarnnam((char const   *)nam, "module %s is in use by another module and cannot be unloaded",
                       mname);
              }
#line 2943
              return (1);
            }
          }
#line 2937
          dn = dn->next;
        }
        while_break___1: /* CIL Label */ ;
        }
        __Cont: /* CIL Label */ 
#line 2932
        dm = (Module )dm->node.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2931
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2949
    if (del) {
#line 2950
      (m->wrapper) ++;
    }
    {
#line 2951
    tmp___0 = unload_module(m);
    }
#line 2951
    if (tmp___0) {
#line 2952
      ret = 1;
    }
#line 2953
    if (del) {
#line 2954
      (m->wrapper) --;
    }
  } else
#line 2955
  if (! silent) {
    {
#line 2956
    zwarnnam((char const   *)nam, "no such module %s", modname);
#line 2957
    ret = 1;
    }
  }
#line 2960
  return (ret);
}
}
#line 2966 "/tmp/zsh-5.4.2/Src/module.c"
static int bin_zmodload_load(char *nam , char **args , Options ops ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmpret ;
  int tmp___1 ;

  {
#line 2969
  ret = 0;
#line 2970
  if ((int )ops->ind[117] != 0) {
    {
#line 2972
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2972
      if (! *args) {
#line 2972
        goto while_break;
      }
      {
#line 2973
      tmp = unload_named_module(*args, nam, (int )ops->ind[105] != 0);
      }
#line 2973
      if (tmp) {
#line 2974
        ret = 1;
      }
#line 2972
      args ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2976
    return (ret);
  } else
#line 2977
  if (! *args) {
#line 2979
    if ((int )ops->ind[76] != 0) {
#line 2979
      tmp___0 = 1;
    } else {
#line 2979
      tmp___0 = 0;
    }
    {
#line 2979
    scanhashtable(modulestab, 1, 0, (1 << 1) | (1 << 6), modulestab->printnode, tmp___0);
    }
#line 2982
    return (0);
  } else {
    {
#line 2985
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2985
      if (! *args) {
#line 2985
        goto while_break___0;
      }
      {
#line 2986
      tmp___1 = require_module((char const   *)*args, (Feature_enables )((void *)0),
                               (int )ops->ind[115] != 0);
#line 2986
      tmpret = tmp___1;
      }
#line 2987
      if (tmpret) {
#line 2987
        if (ret != 1) {
#line 2988
          ret = tmpret;
        }
      }
#line 2985
      args ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2991
    return (ret);
  }
}
}
#line 2998 "/tmp/zsh-5.4.2/Src/module.c"
static int bin_zmodload_features(char const   *nam , char **args , Options ops ) 
{ 
  int iarg ;
  char *modname ;
  Patprog *patprogs ;
  Feature_enables features ;
  Feature_enables fep ;
  int printflags ;
  char **argp ;
  Patprog *patprogp ;
  int tmp ;
  void *tmp___0 ;
  char *arg ;
  Module m ;
  char **features___0 ;
  char **fp ;
  char **arrset ;
  char **arrp ;
  int *enables ;
  int *ep___0 ;
  char *param ;
  char *tmp___1 ;
  LinkNode ln ;
  char *fstr___0 ;
  int sense ;
  LinkNode tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  char *al ;
  char **tmp___6 ;
  int tmp___7 ;
  Param tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *arg___0 ;
  int on ;
  int found ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  int arrlen___0 ;
  char **argp___0 ;
  char *arg___1 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  void *tmp___20 ;
  char *onoff ;
  int term___0 ;
  char **argp___1 ;
  char *arg___2 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  Param tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  void *tmp___29 ;
  char **tmp___30 ;
  Patprog *tmp___31 ;
  int tmp___32 ;

  {
#line 3002
  modname = *args;
#line 3006
  if (modname) {
#line 3007
    args ++;
  } else
#line 3008
  if ((int )ops->ind[76] != 0) {
#line 3009
    printflags = 17;
#line 3010
    if ((int )ops->ind[80] != 0) {
      {
#line 3011
      zwarnnam(nam, "-P is only allowed with a module name");
      }
#line 3012
      return (1);
    }
#line 3014
    if ((int )ops->ind[108] != 0) {
#line 3015
      printflags |= 32;
    }
#line 3016
    if ((int )ops->ind[97] != 0) {
#line 3017
      printflags |= 64;
    }
    {
#line 3018
    scanhashtable(modulestab, 1, 0, 1 << 6, modulestab->printnode, printflags);
    }
#line 3020
    return (0);
  }
#line 3023
  if (! modname) {
    {
#line 3024
    zwarnnam(nam, "-F requires a module name");
    }
#line 3025
    return (1);
  }
#line 3028
  if ((int )ops->ind[109] != 0) {
    {
#line 3033
    tmp = arrlen(args);
#line 3033
    tmp___0 = zhalloc((unsigned long )tmp * sizeof(Patprog ));
#line 3033
    patprogs = (Patprog *)tmp___0;
#line 3033
    patprogp = patprogs;
#line 3035
    argp = args;
    }
    {
#line 3035
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3035
      if (! *argp) {
#line 3035
        goto while_break;
      }
#line 3036
      arg = *argp;
#line 3037
      if ((int )*arg == 43) {
#line 3038
        arg ++;
      } else
#line 3037
      if ((int )*arg == 45) {
#line 3038
        arg ++;
      }
      {
#line 3039
      tokenize(arg);
#line 3040
      *patprogp = patcompile(arg, 0, (char **)0);
#line 3035
      argp ++;
#line 3035
      patprogp ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 3043
    patprogs = (Patprog *)((void *)0);
  }
#line 3045
  if ((int )ops->ind[108] != 0) {
#line 3045
    goto _L___1;
  } else
#line 3045
  if ((int )ops->ind[76] != 0) {
#line 3045
    goto _L___1;
  } else
#line 3045
  if ((int )ops->ind[101] != 0) {
    _L___1: /* CIL Label */ 
#line 3054
    arrset = (char **)((void *)0);
#line 3054
    arrp = (char **)((void *)0);
#line 3055
    enables = (int *)((void *)0);
#line 3056
    if ((int )ops->ind[80] > 3) {
#line 3056
      tmp___1 = *(ops->args + (((int )ops->ind[80] >> 2) - 1));
    } else {
#line 3056
      tmp___1 = (char *)((void *)0);
    }
    {
#line 3056
    param = tmp___1;
#line 3058
    m = find_module((char const   *)modname, 1, (char const   **)((void *)0));
    }
#line 3059
    if ((int )ops->ind[97] != 0) {
#line 3064
      if (! m) {
#line 3065
        return (1);
      } else
#line 3064
      if (! m->autoloads) {
#line 3065
        return (1);
      }
#line 3066
      if ((int )ops->ind[101] != 0) {
#line 3067
        fp = args;
        {
#line 3067
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3067
          if (! *fp) {
#line 3067
            goto while_break___0;
          }
#line 3068
          fstr___0 = *fp;
#line 3069
          sense = 1;
#line 3070
          if ((int )*fstr___0 == 43) {
#line 3071
            fstr___0 ++;
          } else
#line 3072
          if ((int )*fstr___0 == 45) {
#line 3073
            fstr___0 ++;
#line 3074
            sense = 0;
          }
          {
#line 3076
          tmp___2 = linknodebystring(m->autoloads, fstr___0);
          }
#line 3076
          if (((unsigned long )tmp___2 != (unsigned long )((void *)0)) != sense) {
#line 3078
            return (1);
          }
#line 3067
          fp ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 3080
        return (0);
      }
#line 3082
      if (param) {
        {
#line 3083
        tmp___3 = countlinknodes(m->autoloads);
#line 3083
        tmp___4 = zalloc(sizeof(char *) * (unsigned long )(tmp___3 + 1));
#line 3083
        arrset = (char **)tmp___4;
#line 3083
        arrp = arrset;
        }
      } else
#line 3085
      if ((int )ops->ind[76] != 0) {
#line 3086
        if (m->autoloads) {
#line 3086
          if ((m->autoloads)->list.first) {
#line 3086
            tmp___5 = ' ';
          } else {
#line 3086
            tmp___5 = '\n';
          }
        } else {
#line 3086
          tmp___5 = '\n';
        }
        {
#line 3086
        printf((char const   */* __restrict  */)"zmodload -aF %s%c", m->node.nam,
               tmp___5);
#line 3088
        arrp = (char **)((void *)0);
        }
      }
#line 3090
      ln = (m->autoloads)->list.first;
      {
#line 3090
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3090
        if (! ln) {
#line 3090
          goto while_break___1;
        }
#line 3091
        al = (char *)ln->dat;
#line 3092
        if (param) {
          {
#line 3093
          tmp___6 = arrp;
#line 3093
          arrp ++;
#line 3093
          *tmp___6 = ztrdup((char const   *)al);
          }
        } else {
#line 3095
          if ((int )ops->ind[76] != 0) {
#line 3095
            if (ln->next) {
#line 3095
              tmp___7 = ' ';
            } else {
#line 3095
              tmp___7 = '\n';
            }
          } else {
#line 3095
            tmp___7 = '\n';
          }
          {
#line 3095
          printf((char const   */* __restrict  */)"%s%c", al, tmp___7);
          }
        }
#line 3090
        ln = ln->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3098
      if (param) {
        {
#line 3099
        *arrp = (char *)((void *)0);
#line 3100
        tmp___8 = setaparam(param, arrset);
        }
#line 3100
        if (! tmp___8) {
#line 3101
          return (1);
        }
      }
#line 3103
      return (0);
    }
#line 3105
    if (! m) {
#line 3105
      goto _L;
    } else
#line 3105
    if (! m->u.handle) {
#line 3105
      goto _L;
    } else
#line 3105
    if (m->node.flags & (1 << 1)) {
      _L: /* CIL Label */ 
#line 3106
      if (! ((int )ops->ind[101] != 0)) {
        {
#line 3107
        zwarnnam(nam, "module `%s\' is not yet loaded", modname);
        }
      }
#line 3108
      return (1);
    }
    {
#line 3110
    tmp___9 = features_module(m, & features___0);
    }
#line 3110
    if (tmp___9) {
#line 3111
      if (! ((int )ops->ind[101] != 0)) {
        {
#line 3112
        zwarnnam(nam, "module `%s\' does not support features", m->node.nam);
        }
      }
#line 3114
      return (1);
    }
    {
#line 3116
    tmp___10 = enables_module(m, & enables);
    }
#line 3116
    if (tmp___10) {
      {
#line 3118
      zwarnnam(nam, "error getting enabled features for module `%s\'", m->node.nam);
      }
#line 3120
      return (1);
    }
#line 3122
    arrp = args;
#line 3122
    iarg = 0;
    {
#line 3122
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3122
      if (! *arrp) {
#line 3122
        goto while_break___2;
      }
#line 3123
      arg___0 = *arrp;
#line 3124
      found = 0;
#line 3125
      if ((int )*arg___0 == 45) {
#line 3126
        on = 0;
#line 3127
        arg___0 ++;
      } else
#line 3128
      if ((int )*arg___0 == 43) {
#line 3129
        on = 1;
#line 3130
        arg___0 ++;
      } else {
#line 3132
        on = -1;
      }
#line 3133
      fp = features___0;
#line 3133
      ep___0 = enables;
      {
#line 3133
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3133
        if (! *fp) {
#line 3133
          goto while_break___3;
        }
#line 3134
        if (patprogs) {
          {
#line 3134
          tmp___11 = pattry(*(patprogs + iarg), *fp);
#line 3134
          tmp___14 = tmp___11;
          }
        } else {
          {
#line 3134
          tmp___12 = strcmp((char const   *)arg___0, (char const   *)*fp);
          }
#line 3134
          if (tmp___12) {
#line 3134
            tmp___13 = 0;
          } else {
#line 3134
            tmp___13 = 1;
          }
#line 3134
          tmp___14 = tmp___13;
        }
#line 3134
        if (tmp___14) {
#line 3137
          if ((int )ops->ind[101] != 0) {
#line 3137
            if (on != -1) {
#line 3137
              if (on != (*ep___0 & 1)) {
#line 3139
                return (1);
              }
            }
          }
#line 3140
          found ++;
#line 3141
          if (! patprogs) {
#line 3142
            goto while_break___3;
          }
        }
#line 3133
        fp ++;
#line 3133
        ep___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3145
      if (! found) {
#line 3146
        if (! ((int )ops->ind[101] != 0)) {
#line 3147
          if (patprogs) {
#line 3147
            tmp___15 = "module `%s\' has no feature matching: `%s\'";
          } else {
#line 3147
            tmp___15 = "module `%s\' has no such feature: `%s\'";
          }
          {
#line 3147
          zwarnnam(nam, tmp___15, modname, *arrp);
          }
        }
#line 3151
        return (1);
      }
#line 3122
      arrp ++;
#line 3122
      iarg ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3154
    if ((int )ops->ind[101] != 0) {
#line 3155
      return (0);
    }
#line 3156
    if (param) {
#line 3157
      arrlen___0 = 0;
#line 3158
      fp = features___0;
#line 3158
      ep___0 = enables;
      {
#line 3158
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3158
        if (! *fp) {
#line 3158
          goto while_break___4;
        }
#line 3159
        if ((int )ops->ind[76] != 0) {
#line 3159
          if (! ((int )ops->ind[108] != 0)) {
#line 3159
            if (! *ep___0) {
#line 3161
              goto __Cont;
            }
          }
        }
#line 3162
        if (*args) {
#line 3164
          argp___0 = args;
#line 3164
          iarg = 0;
          {
#line 3164
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 3164
            if (! *argp___0) {
#line 3164
              goto while_break___5;
            }
#line 3165
            arg___1 = *argp___0;
#line 3167
            if ((int )*arg___1 == 43) {
#line 3168
              arg___1 ++;
            } else
#line 3167
            if ((int )*arg___1 == 45) {
#line 3168
              arg___1 ++;
            }
#line 3169
            if (patprogs) {
              {
#line 3169
              tmp___16 = pattry(*(patprogs + iarg), *fp);
#line 3169
              tmp___19 = tmp___16;
              }
            } else {
              {
#line 3169
              tmp___17 = strcmp((char const   *)*fp, (char const   *)arg___1);
              }
#line 3169
              if (tmp___17) {
#line 3169
                tmp___18 = 0;
              } else {
#line 3169
                tmp___18 = 1;
              }
#line 3169
              tmp___19 = tmp___18;
            }
#line 3169
            if (tmp___19) {
#line 3171
              goto while_break___5;
            }
#line 3164
            argp___0 ++;
#line 3164
            iarg ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 3173
          if (! *argp___0) {
#line 3174
            goto __Cont;
          }
        }
#line 3176
        arrlen___0 ++;
        __Cont: /* CIL Label */ 
#line 3158
        fp ++;
#line 3158
        ep___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 3178
      tmp___20 = zalloc(sizeof(char *) * (unsigned long )(arrlen___0 + 1));
#line 3178
      arrset = (char **)tmp___20;
#line 3178
      arrp = arrset;
      }
    } else
#line 3179
    if ((int )ops->ind[76] != 0) {
      {
#line 3180
      printf((char const   */* __restrict  */)"zmodload -F %s ", m->node.nam);
      }
    }
#line 3181
    fp = features___0;
#line 3181
    ep___0 = enables;
    {
#line 3181
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 3181
      if (! *fp) {
#line 3181
        goto while_break___6;
      }
#line 3184
      if (*args) {
#line 3186
        argp___1 = args;
#line 3186
        iarg = 0;
        {
#line 3186
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 3186
          if (! *argp___1) {
#line 3186
            goto while_break___7;
          }
#line 3187
          arg___2 = *argp___1;
#line 3188
          if ((int )*arg___2 == 43) {
#line 3189
            arg___2 ++;
          } else
#line 3188
          if ((int )*arg___2 == 45) {
#line 3189
            arg___2 ++;
          }
#line 3190
          if (patprogs) {
            {
#line 3190
            tmp___21 = pattry(*(patprogs + iarg), *fp);
#line 3190
            tmp___24 = tmp___21;
            }
          } else {
            {
#line 3190
            tmp___22 = strcmp((char const   *)*fp, (char const   *)*argp___1);
            }
#line 3190
            if (tmp___22) {
#line 3190
              tmp___23 = 0;
            } else {
#line 3190
              tmp___23 = 1;
            }
#line 3190
            tmp___24 = tmp___23;
          }
#line 3190
          if (tmp___24) {
#line 3192
            goto while_break___7;
          }
#line 3186
          argp___1 ++;
#line 3186
          iarg ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 3194
        if (! *argp___1) {
#line 3195
          goto __Cont___0;
        }
      }
#line 3197
      if ((int )ops->ind[76] != 0) {
#line 3197
        if (! ((int )ops->ind[108] != 0)) {
#line 3198
          if (! *ep___0) {
#line 3199
            goto __Cont___0;
          }
#line 3200
          onoff = (char *)"";
        } else {
#line 3197
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 3201
      if (*ep___0) {
#line 3202
        onoff = (char *)"+";
      } else {
#line 3204
        onoff = (char *)"-";
      }
#line 3206
      if (param) {
        {
#line 3207
        tmp___25 = arrp;
#line 3207
        arrp ++;
#line 3207
        *tmp___25 = bicat((char const   *)onoff, (char const   *)*fp);
        }
      } else {
#line 3209
        if ((int )ops->ind[76] != 0) {
#line 3209
          if (*(fp + 1)) {
#line 3210
            term___0 = ' ';
          } else {
#line 3212
            term___0 = '\n';
          }
        } else {
#line 3212
          term___0 = '\n';
        }
        {
#line 3214
        printf((char const   */* __restrict  */)"%s%s%c", onoff, *fp, term___0);
        }
      }
      __Cont___0: /* CIL Label */ 
#line 3181
      fp ++;
#line 3181
      ep___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 3217
    if (param) {
      {
#line 3218
      *arrp = (char *)((void *)0);
#line 3219
      tmp___26 = setaparam(param, arrset);
      }
#line 3219
      if (! tmp___26) {
#line 3220
        return (1);
      }
    }
#line 3222
    return (0);
  } else
#line 3223
  if ((int )ops->ind[80] != 0) {
    {
#line 3224
    zwarnnam(nam, "-P can only be used with -l or -L");
    }
#line 3225
    return (1);
  } else
#line 3226
  if ((int )ops->ind[97] != 0) {
#line 3227
    if ((int )ops->ind[109] != 0) {
      {
#line 3228
      zwarnnam(nam, "-m cannot be used with -a");
      }
#line 3229
      return (1);
    }
    {
#line 3242
    tmp___27 = autofeatures(nam, (char const   *)modname, args, 0, 1);
    }
#line 3242
    return (tmp___27);
  }
  {
#line 3245
  tmp___28 = arrlen(args);
#line 3245
  tmp___29 = zhalloc((unsigned long )(tmp___28 + 1) * sizeof(*fep));
#line 3245
  features = (Feature_enables )tmp___29;
#line 3245
  fep = features;
  }
  {
#line 3248
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 3248
    if (! *args) {
#line 3248
      goto while_break___8;
    }
#line 3249
    tmp___30 = args;
#line 3249
    args ++;
#line 3249
    fep->str = *tmp___30;
#line 3250
    if (patprogs) {
#line 3250
      tmp___31 = patprogs;
#line 3250
      patprogs ++;
#line 3250
      fep->pat = *tmp___31;
    } else {
#line 3250
      fep->pat = (Patprog )((void *)0);
    }
#line 3251
    fep ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 3253
  fep->str = (char *)((void *)0);
#line 3254
  fep->pat = (Patprog )((void *)0);
#line 3256
  tmp___32 = require_module((char const   *)modname, features, (int )ops->ind[115] != 0);
  }
#line 3256
  return (tmp___32);
}
}
#line 3274 "/tmp/zsh-5.4.2/Src/module.c"
char **featuresarray(Module m  __attribute__((__unused__)) , Features f ) 
{ 
  int bn_size ;
  int cd_size ;
  int mf_size ;
  int pd_size ;
  int features_size ;
  Builtin bnp ;
  Conddef cdp ;
  MathFunc mfp ;
  Paramdef pdp ;
  char **features ;
  void *tmp ;
  char **featurep ;
  char **tmp___0 ;
  Builtin tmp___1 ;
  int tmp___2 ;
  char **tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  MathFunc tmp___7 ;
  int tmp___8 ;
  char **tmp___9 ;
  Paramdef tmp___10 ;
  int tmp___11 ;

  {
  {
#line 3277
  bn_size = f->bn_size;
#line 3277
  cd_size = f->cd_size;
#line 3278
  mf_size = f->mf_size;
#line 3278
  pd_size = f->pd_size;
#line 3279
  features_size = (((bn_size + cd_size) + pd_size) + mf_size) + f->n_abstract;
#line 3280
  bnp = f->bn_list;
#line 3281
  cdp = f->cd_list;
#line 3282
  mfp = f->mf_list;
#line 3283
  pdp = f->pd_list;
#line 3284
  tmp = zhalloc((unsigned long )(features_size + 1) * sizeof(char *));
#line 3284
  features = (char **)tmp;
#line 3285
  featurep = features;
  }
  {
#line 3287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3287
    tmp___2 = bn_size;
#line 3287
    bn_size --;
#line 3287
    if (! tmp___2) {
#line 3287
      goto while_break;
    }
    {
#line 3288
    tmp___0 = featurep;
#line 3288
    featurep ++;
#line 3288
    tmp___1 = bnp;
#line 3288
    bnp ++;
#line 3288
    *tmp___0 = dyncat("b:", (char const   *)tmp___1->node.nam);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3289
    tmp___5 = cd_size;
#line 3289
    cd_size --;
#line 3289
    if (! tmp___5) {
#line 3289
      goto while_break___0;
    }
#line 3290
    tmp___3 = featurep;
#line 3290
    featurep ++;
#line 3290
    if (cdp->flags & 1) {
#line 3290
      tmp___4 = "C:";
    } else {
#line 3290
      tmp___4 = "c:";
    }
    {
#line 3290
    *tmp___3 = dyncat(tmp___4, (char const   *)cdp->name);
#line 3292
    cdp ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3294
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3294
    tmp___8 = mf_size;
#line 3294
    mf_size --;
#line 3294
    if (! tmp___8) {
#line 3294
      goto while_break___1;
    }
    {
#line 3295
    tmp___6 = featurep;
#line 3295
    featurep ++;
#line 3295
    tmp___7 = mfp;
#line 3295
    mfp ++;
#line 3295
    *tmp___6 = dyncat("f:", (char const   *)tmp___7->name);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3296
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3296
    tmp___11 = pd_size;
#line 3296
    pd_size --;
#line 3296
    if (! tmp___11) {
#line 3296
      goto while_break___2;
    }
    {
#line 3297
    tmp___9 = featurep;
#line 3297
    featurep ++;
#line 3297
    tmp___10 = pdp;
#line 3297
    pdp ++;
#line 3297
    *tmp___9 = dyncat("p:", (char const   *)tmp___10->name);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3299
  *(features + features_size) = (char *)((void *)0);
#line 3300
  return (features);
}
}
#line 3309 "/tmp/zsh-5.4.2/Src/module.c"
int *getfeatureenables(Module m  __attribute__((__unused__)) , Features f ) 
{ 
  int bn_size ;
  int cd_size ;
  int mf_size ;
  int pd_size ;
  int features_size ;
  Builtin bnp ;
  Conddef cdp ;
  MathFunc mfp ;
  Paramdef pdp ;
  int *enables ;
  void *tmp ;
  int *enablep ;
  int *tmp___0 ;
  Builtin tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  Conddef tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  MathFunc tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  Paramdef tmp___14 ;
  int tmp___15 ;

  {
  {
#line 3312
  bn_size = f->bn_size;
#line 3312
  cd_size = f->cd_size;
#line 3313
  mf_size = f->mf_size;
#line 3313
  pd_size = f->pd_size;
#line 3314
  features_size = (((bn_size + cd_size) + mf_size) + pd_size) + f->n_abstract;
#line 3315
  bnp = f->bn_list;
#line 3316
  cdp = f->cd_list;
#line 3317
  mfp = f->mf_list;
#line 3318
  pdp = f->pd_list;
#line 3319
  tmp = zhalloc(sizeof(int ) * (unsigned long )features_size);
#line 3319
  enables = (int *)tmp;
#line 3320
  enablep = enables;
  }
  {
#line 3322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3322
    tmp___3 = bn_size;
#line 3322
    bn_size --;
#line 3322
    if (! tmp___3) {
#line 3322
      goto while_break;
    }
#line 3323
    tmp___0 = enablep;
#line 3323
    enablep ++;
#line 3323
    tmp___2 = bnp;
#line 3323
    bnp ++;
#line 3323
    if (tmp___2->node.flags & (1 << 3)) {
#line 3323
      *tmp___0 = 1;
    } else {
#line 3323
      *tmp___0 = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3324
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3324
    tmp___7 = cd_size;
#line 3324
    cd_size --;
#line 3324
    if (! tmp___7) {
#line 3324
      goto while_break___0;
    }
#line 3325
    tmp___4 = enablep;
#line 3325
    enablep ++;
#line 3325
    tmp___6 = cdp;
#line 3325
    cdp ++;
#line 3325
    if (tmp___6->flags & 2) {
#line 3325
      *tmp___4 = 1;
    } else {
#line 3325
      *tmp___4 = 0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3326
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3326
    tmp___11 = mf_size;
#line 3326
    mf_size --;
#line 3326
    if (! tmp___11) {
#line 3326
      goto while_break___1;
    }
#line 3327
    tmp___8 = enablep;
#line 3327
    enablep ++;
#line 3327
    tmp___10 = mfp;
#line 3327
    mfp ++;
#line 3327
    if (tmp___10->flags & 2) {
#line 3327
      *tmp___8 = 1;
    } else {
#line 3327
      *tmp___8 = 0;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3328
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3328
    tmp___15 = pd_size;
#line 3328
    pd_size --;
#line 3328
    if (! tmp___15) {
#line 3328
      goto while_break___2;
    }
#line 3329
    tmp___12 = enablep;
#line 3329
    enablep ++;
#line 3329
    tmp___14 = pdp;
#line 3329
    pdp ++;
#line 3329
    if (tmp___14->pm) {
#line 3329
      *tmp___12 = 1;
    } else {
#line 3329
      *tmp___12 = 0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3331
  return (enables);
}
}
#line 3345 "/tmp/zsh-5.4.2/Src/module.c"
int setfeatureenables(Module m , Features f , int *e ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3348
  ret = 0;
#line 3350
  if (f->bn_size) {
    {
#line 3351
    tmp = setbuiltins((char const   *)m->node.nam, f->bn_list, f->bn_size, e);
    }
#line 3351
    if (tmp) {
#line 3352
      ret = 1;
    }
#line 3353
    if (e) {
#line 3354
      e += f->bn_size;
    }
  }
#line 3356
  if (f->cd_size) {
    {
#line 3357
    tmp___0 = setconddefs((char const   *)m->node.nam, f->cd_list, f->cd_size, e);
    }
#line 3357
    if (tmp___0) {
#line 3358
      ret = 1;
    }
#line 3359
    if (e) {
#line 3360
      e += f->cd_size;
    }
  }
#line 3362
  if (f->mf_size) {
    {
#line 3363
    tmp___1 = setmathfuncs((char const   *)m->node.nam, f->mf_list, f->mf_size, e);
    }
#line 3363
    if (tmp___1) {
#line 3364
      ret = 1;
    }
#line 3365
    if (e) {
#line 3366
      e += f->mf_size;
    }
  }
#line 3368
  if (f->pd_size) {
    {
#line 3369
    tmp___2 = setparamdefs((char const   *)m->node.nam, f->pd_list, f->pd_size, e);
    }
#line 3369
    if (tmp___2) {
#line 3370
      ret = 1;
    }
#line 3371
    if (e) {
#line 3372
      e += f->pd_size;
    }
  }
#line 3374
  return (ret);
}
}
#line 3383 "/tmp/zsh-5.4.2/Src/module.c"
int handlefeatures(Module m , Features f , int **enables ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 3386
  if (! enables) {
#line 3386
    goto _L;
  } else
#line 3386
  if (*enables) {
    _L: /* CIL Label */ 
#line 3387
    if (enables) {
#line 3387
      tmp = *enables;
    } else {
#line 3387
      tmp = (int *)((void *)0);
    }
    {
#line 3387
    tmp___0 = setfeatureenables(m, f, tmp);
    }
#line 3387
    return (tmp___0);
  }
  {
#line 3388
  *enables = getfeatureenables(m, f);
  }
#line 3389
  return (0);
}
}
#line 3410 "/tmp/zsh-5.4.2/Src/module.c"
int ensurefeature(char const   *modname , char const   *prefix , char const   *feature ) 
{ 
  char *f ;
  struct feature_enables features[2] ;
  int tmp ;
  int tmp___0 ;

  {
#line 3416
  if (! feature) {
    {
#line 3417
    tmp = require_module(modname, (Feature_enables )((void *)0), 0);
    }
#line 3417
    return (tmp);
  }
  {
#line 3418
  f = dyncat(prefix, feature);
#line 3420
  features[0].str = f;
#line 3421
  features[0].pat = (Patprog )((void *)0);
#line 3422
  features[1].str = (char *)((void *)0);
#line 3423
  features[1].pat = (Patprog )((void *)0);
#line 3424
  tmp___0 = require_module(modname, features, 0);
  }
#line 3424
  return (tmp___0);
}
}
#line 3432 "/tmp/zsh-5.4.2/Src/module.c"
int autofeatures(char const   *cmdnam , char const   *module , char **features , int prefchar ,
                 int defflags ) 
{ 
  int ret ;
  int subret ;
  Module defm ;
  Module m ;
  char **modfeatures ;
  int *modenables ;
  Module tmp ;
  Linkedmod tmp___0 ;
  char *fnam ;
  char *typnam ;
  char *feature ;
  int add___0 ;
  int fchar ;
  int flags ;
  int (*fn___0)(char const   *module , char const   *feature , int flags ) ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int i ;
  LinkNode tmp___4 ;
  char **ptr___0 ;
  int tmp___5 ;
  char *tmp___6 ;
  LinkNode ln ;
  LinkNode prev ;
  int cmp ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  LinkNode ln___0 ;
  void *tmp___10 ;

  {
#line 3436
  ret = 0;
#line 3438
  modfeatures = (char **)((void *)0);
#line 3439
  modenables = (int *)((void *)0);
#line 3440
  if (module) {
    {
#line 3441
    tmp = find_module(module, 3, (char const   **)((void *)0));
#line 3441
    defm = tmp;
    }
#line 3443
    if (defm->node.flags & (1 << 3)) {
#line 3443
      tmp___0 = defm->u.linked;
    } else {
#line 3443
      tmp___0 = (Linkedmod )defm->u.handle;
    }
#line 3443
    if (tmp___0) {
      {
#line 3445
      features_module(defm, & modfeatures);
#line 3446
      enables_module(defm, & modenables);
      }
    }
  } else {
#line 3449
    defm = (Module )((void *)0);
  }
  {
#line 3451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3451
    if (! *features) {
#line 3451
      goto while_break;
    }
#line 3453
    flags = defflags;
#line 3456
    if (prefchar) {
      {
#line 3461
      add___0 = 1;
#line 3462
      fchar = prefchar;
#line 3463
      fnam = *features;
#line 3464
      tmp___1 = strlen((char const   *)fnam);
#line 3464
      tmp___2 = zhalloc(tmp___1 + 3UL);
#line 3464
      feature = (char *)tmp___2;
#line 3465
      sprintf((char */* __restrict  */)feature, (char const   */* __restrict  */)"%c:%s",
              fchar, fnam);
      }
    } else {
#line 3467
      feature = *features;
#line 3468
      if ((int )*feature == 45) {
#line 3469
        add___0 = 0;
#line 3470
        feature ++;
      } else {
#line 3472
        add___0 = 1;
#line 3473
        if ((int )*feature == 43) {
#line 3474
          feature ++;
        }
      }
#line 3477
      if (! *feature) {
        {
#line 3478
        zwarnnam(cmdnam, "bad format for autoloadable feature: `%s\'", feature);
#line 3480
        ret = 1;
        }
#line 3481
        goto __Cont;
      } else
#line 3477
      if ((int )*(feature + 1) != 58) {
        {
#line 3478
        zwarnnam(cmdnam, "bad format for autoloadable feature: `%s\'", feature);
#line 3480
        ret = 1;
        }
#line 3481
        goto __Cont;
      }
#line 3483
      fnam = feature + 2;
#line 3484
      fchar = (int )*(feature + 0);
    }
#line 3486
    if (flags & 8) {
#line 3487
      add___0 = 0;
    }
    {
#line 3490
    if (fchar == 98) {
#line 3490
      goto case_98;
    }
#line 3495
    if (fchar == 67) {
#line 3495
      goto case_67;
    }
#line 3498
    if (fchar == 99) {
#line 3498
      goto case_99;
    }
#line 3503
    if (fchar == 102) {
#line 3503
      goto case_102;
    }
#line 3508
    if (fchar == 112) {
#line 3508
      goto case_112;
    }
#line 3513
    goto switch_default;
    case_98: /* CIL Label */ 
#line 3491
    if (add___0) {
#line 3491
      fn___0 = & add_autobin;
    } else {
#line 3491
      fn___0 = & del_autobin;
    }
#line 3492
    typnam = (char *)"builtin";
#line 3493
    goto switch_break;
    case_67: /* CIL Label */ 
#line 3496
    flags |= 2;
    case_99: /* CIL Label */ 
#line 3499
    if (add___0) {
#line 3499
      fn___0 = & add_autocond;
    } else {
#line 3499
      fn___0 = & del_autocond;
    }
#line 3500
    typnam = (char *)"condition";
#line 3501
    goto switch_break;
    case_102: /* CIL Label */ 
#line 3504
    if (add___0) {
#line 3504
      fn___0 = & add_automathfunc;
    } else {
#line 3504
      fn___0 = & del_automathfunc;
    }
#line 3505
    typnam = (char *)"math function";
#line 3506
    goto switch_break;
    case_112: /* CIL Label */ 
#line 3509
    if (add___0) {
#line 3509
      fn___0 = & add_autoparam;
    } else {
#line 3509
      fn___0 = & del_autoparam;
    }
#line 3510
    typnam = (char *)"parameter";
#line 3511
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3514
    zwarnnam(cmdnam, "bad autoloadable feature type: `%c\'", fchar);
#line 3516
    ret = 1;
    }
#line 3517
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
    {
#line 3520
    tmp___3 = strchr((char const   *)fnam, '/');
    }
#line 3520
    if (tmp___3) {
      {
#line 3521
      zwarnnam(cmdnam, "%s: `/\' is illegal in a %s", fnam, typnam);
#line 3522
      ret = 1;
      }
#line 3523
      goto __Cont;
    }
#line 3526
    if (! module) {
#line 3532
      i = 0;
#line 3532
      m = (Module )((void *)0);
      {
#line 3532
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3532
        if (! m) {
#line 3532
          if (! (i < modulestab->hsize)) {
#line 3532
            goto while_break___0;
          }
        } else {
#line 3532
          goto while_break___0;
        }
#line 3533
        m = (Module )*(modulestab->nodes + i);
        {
#line 3533
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3533
          if (! m) {
#line 3533
            goto while_break___1;
          }
#line 3535
          if (m->autoloads) {
            {
#line 3535
            tmp___4 = linknodebystring(m->autoloads, feature);
            }
#line 3535
            if (tmp___4) {
#line 3537
              goto while_break___1;
            }
          }
#line 3533
          m = (Module )m->node.next;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3532
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3540
      if (! m) {
#line 3541
        if (! (flags & 1)) {
          {
#line 3542
          ret = 1;
#line 3543
          zwarnnam(cmdnam, "%s: no such %s", fnam, typnam);
          }
        }
#line 3545
        goto __Cont;
      }
    } else {
#line 3548
      m = defm;
    }
#line 3550
    subret = 0;
#line 3551
    if (add___0) {
#line 3553
      if (modfeatures) {
#line 3558
        ptr___0 = modfeatures;
        {
#line 3558
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3558
          if (! *ptr___0) {
#line 3558
            goto while_break___2;
          }
          {
#line 3559
          tmp___5 = strcmp((char const   *)*ptr___0, (char const   *)feature);
          }
#line 3559
          if (! tmp___5) {
#line 3560
            goto while_break___2;
          }
#line 3558
          ptr___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3561
        if (! *ptr___0) {
          {
#line 3562
          zwarnnam(cmdnam, "module `%s\' has no such feature: `%s\'", m->node.nam,
                   feature);
#line 3564
          ret = 1;
          }
#line 3565
          goto __Cont;
        }
#line 3571
        if (*(modenables + (ptr___0 - modfeatures))) {
#line 3572
          goto __Cont;
        }
      }
#line 3578
      if (! m->autoloads) {
        {
#line 3579
        m->autoloads = znewlinklist();
#line 3580
        tmp___6 = ztrdup((char const   *)feature);
#line 3580
        zinsertlinknode(m->autoloads, (m->autoloads)->list.last, (void *)tmp___6);
        }
      } else {
#line 3583
        prev = (LinkNode )m->autoloads;
        {
#line 3584
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3584
          ln = prev->next;
#line 3584
          if (! ln) {
#line 3584
            goto while_break___3;
          }
          {
#line 3585
          tmp___7 = strcmp((char const   *)feature, (char const   *)((char *)ln->dat));
#line 3585
          cmp = tmp___7;
          }
#line 3586
          if (cmp == 0) {
#line 3588
            goto while_break___3;
          }
#line 3590
          if (cmp < 0) {
            {
#line 3591
            tmp___8 = ztrdup((char const   *)feature);
#line 3591
            zinsertlinknode(m->autoloads, prev, (void *)tmp___8);
            }
#line 3593
            goto while_break___3;
          }
#line 3595
          prev = ln;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 3597
        if (! ln) {
          {
#line 3598
          tmp___9 = ztrdup((char const   *)feature);
#line 3598
          zinsertlinknode(m->autoloads, (m->autoloads)->list.last, (void *)tmp___9);
          }
        }
      }
    } else
#line 3600
    if (m->autoloads) {
      {
#line 3602
      ln___0 = linknodebystring(m->autoloads, feature);
      }
#line 3602
      if (ln___0) {
        {
#line 3603
        tmp___10 = remnode(m->autoloads, ln___0);
#line 3603
        zsfree((char *)tmp___10);
        }
      } else
#line 3609
      if (flags & 1) {
#line 3609
        subret = -2;
      } else {
#line 3609
        subret = 2;
      }
    }
#line 3613
    if (subret == 0) {
      {
#line 3614
      subret = (*fn___0)(module, (char const   *)fnam, flags);
      }
    }
#line 3616
    if (subret != 0) {
#line 3618
      if (subret != -2) {
#line 3619
        ret = 1;
      }
      {
#line 3621
      if (subret == 1) {
#line 3621
        goto case_1;
      }
#line 3625
      if (subret == 2) {
#line 3625
        goto case_2;
      }
#line 3629
      if (subret == 3) {
#line 3629
        goto case_3;
      }
#line 3633
      goto switch_default___0;
      case_1: /* CIL Label */ 
      {
#line 3622
      zwarnnam(cmdnam, "failed to add %s `%s\'", typnam, fnam);
      }
#line 3623
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 3626
      zwarnnam(cmdnam, "%s: no such %s", fnam, typnam);
      }
#line 3627
      goto switch_break___0;
      case_3: /* CIL Label */ 
      {
#line 3630
      zwarnnam(cmdnam, "%s: %s is already defined", fnam, typnam);
      }
#line 3631
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 3635
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 3451
    features ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3640
  return (ret);
}
}
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 614
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 8 "./mem.epro"
Heap new_heaps(void) ;
#line 9
void old_heaps(Heap old ) ;
#line 10
Heap switch_heaps(Heap new ) ;
#line 12
void freeheap(void) ;
#line 129 "/tmp/zsh-5.4.2/Src/mem.c"
static Heap heaps  ;
#line 134 "/tmp/zsh-5.4.2/Src/mem.c"
static Heap fheap  ;
#line 193 "/tmp/zsh-5.4.2/Src/mem.c"
Heap new_heaps(void) 
{ 
  Heap h ;
  sigset_t oset ;

  {
#line 198
  queueing_enabled ++;
#line 199
  h = heaps;
#line 201
  heaps = (Heap )((void *)0);
#line 201
  fheap = heaps;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    queueing_enabled --;
#line 202
    if (! queueing_enabled) {
      {
#line 202
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 202
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 202
          if (! (queue_front != queue_rear)) {
#line 202
            goto while_break___1;
          }
          {
#line 202
          queue_front = (queue_front + 1) % 128;
#line 202
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 202
          zhandler(signal_queue[queue_front]);
#line 202
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 202
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 202
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return (h);
}
}
#line 219 "/tmp/zsh-5.4.2/Src/mem.c"
void old_heaps(Heap old ) 
{ 
  Heap h ;
  Heap n ;
  sigset_t oset ;

  {
#line 224
  queueing_enabled ++;
#line 225
  h = heaps;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! h) {
#line 225
      goto while_break;
    }
    {
#line 226
    n = h->next;
#line 235
    munmap((void *)h, h->size);
#line 225
    h = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  heaps = old;
#line 259
  fheap = (Heap )((void *)0);
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 260
    queueing_enabled --;
#line 260
    if (! queueing_enabled) {
      {
#line 260
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 260
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 260
          if (! (queue_front != queue_rear)) {
#line 260
            goto while_break___2;
          }
          {
#line 260
          queue_front = (queue_front + 1) % 128;
#line 260
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 260
          zhandler(signal_queue[queue_front]);
#line 260
          signal_setmask(oset);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 260
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 260
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 261
  return;
}
}
#line 266 "/tmp/zsh-5.4.2/Src/mem.c"
Heap switch_heaps(Heap new ) 
{ 
  Heap h ;
  sigset_t oset ;

  {
#line 271
  queueing_enabled ++;
#line 272
  h = heaps;
#line 280
  heaps = new;
#line 281
  fheap = (Heap )((void *)0);
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    queueing_enabled --;
#line 282
    if (! queueing_enabled) {
      {
#line 282
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 282
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 282
          if (! (queue_front != queue_rear)) {
#line 282
            goto while_break___1;
          }
          {
#line 282
          queue_front = (queue_front + 1) % 128;
#line 282
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 282
          zhandler(signal_queue[queue_front]);
#line 282
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 282
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 282
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return (h);
}
}
#line 290 "/tmp/zsh-5.4.2/Src/mem.c"
void pushheap(void) 
{ 
  Heap h ;
  Heapstack hs ;
  void *tmp ;
  sigset_t oset ;

  {
#line 296
  queueing_enabled ++;
#line 302
  h = heaps;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! h) {
#line 302
      goto while_break;
    }
    {
#line 304
    tmp = zalloc(sizeof(*hs));
#line 304
    hs = (Heapstack )tmp;
#line 305
    hs->next = h->sp;
#line 306
    h->sp = hs;
#line 307
    hs->used = h->used;
#line 302
    h = h->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    queueing_enabled --;
#line 318
    if (! queueing_enabled) {
      {
#line 318
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 318
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 318
          if (! (queue_front != queue_rear)) {
#line 318
            goto while_break___2;
          }
          {
#line 318
          queue_front = (queue_front + 1) % 128;
#line 318
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 318
          zhandler(signal_queue[queue_front]);
#line 318
          signal_setmask(oset);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 318
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 318
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 319
  return;
}
}
#line 324 "/tmp/zsh-5.4.2/Src/mem.c"
void freeheap(void) 
{ 
  Heap h ;
  Heap hn ;
  Heap hl ;
  sigset_t oset ;

  {
#line 327
  hl = (Heap )((void *)0);
#line 329
  queueing_enabled ++;
#line 355
  if (fheap) {
#line 355
    if (! fheap->sp) {
#line 356
      fheap = (Heap )((void *)0);
    }
  }
#line 363
  if (fheap) {
#line 363
    h = fheap;
  } else {
#line 363
    h = heaps;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! h) {
#line 363
      goto while_break;
    }
#line 364
    hn = h->next;
#line 365
    if (h->sp) {
#line 373
      h->used = (h->sp)->used;
#line 374
      if (! fheap) {
#line 375
        if (h->used < h->size - sizeof(struct heap )) {
#line 376
          fheap = h;
        }
      } else
#line 377
      if ((h->size - sizeof(struct heap )) - h->used > (fheap->size - sizeof(struct heap )) - fheap->used) {
#line 379
        fheap = h;
      }
#line 380
      hl = h;
    } else {
#line 401
      if ((unsigned long )fheap == (unsigned long )h) {
#line 402
        fheap = (Heap )((void *)0);
      }
#line 403
      if (h->next) {
#line 405
        if ((unsigned long )h == (unsigned long )heaps) {
#line 406
          heaps = h->next;
#line 406
          hl = heaps;
        } else
#line 407
        if (hl) {
#line 407
          if ((unsigned long )hl->next == (unsigned long )h) {
#line 408
            hl->next = h->next;
          } else {
#line 411
            hl = h;
#line 412
            goto __Cont;
          }
        } else {
#line 411
          hl = h;
#line 412
          goto __Cont;
        }
#line 414
        h->next = (struct heap *)((void *)0);
      } else {
#line 417
        h->used = (size_t )0;
#line 418
        hl = h;
#line 418
        fheap = hl;
#line 419
        goto while_break;
      }
      {
#line 422
      munmap((void *)h, h->size);
      }
    }
    __Cont: /* CIL Label */ 
#line 363
    h = hn;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  if (hl) {
#line 432
    hl->next = (struct heap *)((void *)0);
  } else {
#line 434
    fheap = (Heap )((void *)0);
#line 434
    heaps = fheap;
  }
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    queueing_enabled --;
#line 436
    if (! queueing_enabled) {
      {
#line 436
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 436
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 436
          if (! (queue_front != queue_rear)) {
#line 436
            goto while_break___2;
          }
          {
#line 436
          queue_front = (queue_front + 1) % 128;
#line 436
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 436
          zhandler(signal_queue[queue_front]);
#line 436
          signal_setmask(oset);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 436
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 436
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 437
  return;
}
}
#line 442 "/tmp/zsh-5.4.2/Src/mem.c"
void popheap(void) 
{ 
  Heap h ;
  Heap hn ;
  Heap hl ;
  Heapstack hs ;
  sigset_t oset ;

  {
#line 445
  hl = (Heap )((void *)0);
#line 448
  queueing_enabled ++;
#line 454
  fheap = (Heap )((void *)0);
#line 455
  h = heaps;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    if (! h) {
#line 455
      goto while_break;
    }
#line 456
    hn = h->next;
#line 457
    hs = h->sp;
#line 457
    if (hs) {
#line 458
      h->sp = hs->next;
#line 466
      h->used = hs->used;
#line 478
      if (! fheap) {
#line 479
        if (h->used < h->size - sizeof(struct heap )) {
#line 480
          fheap = h;
        }
      } else
#line 481
      if ((h->size - sizeof(struct heap )) - h->used > (fheap->size - sizeof(struct heap )) - fheap->used) {
#line 483
        fheap = h;
      }
      {
#line 484
      zfree((void *)hs, (int )sizeof(*hs));
#line 486
      hl = h;
      }
    } else {
#line 488
      if (h->next) {
#line 490
        if ((unsigned long )h == (unsigned long )heaps) {
#line 491
          heaps = h->next;
#line 491
          hl = heaps;
        } else
#line 492
        if (hl) {
#line 492
          if ((unsigned long )hl->next == (unsigned long )h) {
#line 493
            hl->next = h->next;
          } else {
#line 496
            hl = h;
#line 497
            goto __Cont;
          }
        } else {
#line 496
          hl = h;
#line 497
          goto __Cont;
        }
#line 499
        h->next = (struct heap *)((void *)0);
      } else
#line 500
      if ((unsigned long )hl == (unsigned long )h) {
#line 501
        hl = (Heap )((void *)0);
      }
      {
#line 503
      munmap((void *)h, h->size);
      }
    }
    __Cont: /* CIL Label */ 
#line 455
    h = hn;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  if (hl) {
#line 513
    hl->next = (struct heap *)((void *)0);
  } else {
#line 515
    heaps = (Heap )((void *)0);
  }
  {
#line 517
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 517
    queueing_enabled --;
#line 517
    if (! queueing_enabled) {
      {
#line 517
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 517
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 517
          if (! (queue_front != queue_rear)) {
#line 517
            goto while_break___2;
          }
          {
#line 517
          queue_front = (queue_front + 1) % 128;
#line 517
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 517
          zhandler(signal_queue[queue_front]);
#line 517
          signal_setmask(oset);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 517
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 517
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 518
  return;
}
}
#line 529
static Heap mmap_heap_alloc(size_t *n ) ;
#line 529 "/tmp/zsh-5.4.2/Src/mem.c"
static size_t pgsz___0  =    (size_t )0;
#line 525 "/tmp/zsh-5.4.2/Src/mem.c"
static Heap mmap_heap_alloc(size_t *n ) 
{ 
  Heap h ;
  long tmp ;
  void *tmp___0 ;

  {
#line 531
  if (! pgsz___0) {
    {
#line 534
    tmp = sysconf(30);
#line 534
    pgsz___0 = (size_t )tmp;
#line 543
    pgsz___0 --;
    }
  }
  {
#line 545
  *n = (*n + pgsz___0) & ~ pgsz___0;
#line 546
  tmp___0 = mmap((void *)0, *n, 3, 34, -1, (__off_t )0);
#line 546
  h = (Heap )tmp___0;
  }
#line 548
  if ((unsigned long )h == (unsigned long )((Heap )-1)) {
    {
#line 549
    zerr("fatal error: out of heap memory");
#line 550
    exit(1);
    }
  }
#line 553
  return (h);
}
}
#line 560 "/tmp/zsh-5.4.2/Src/mem.c"
void *zheapptr(void *p ) 
{ 
  Heap h ;
  sigset_t oset ;
  void *tmp ;

  {
#line 564
  queueing_enabled ++;
#line 565
  h = heaps;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    if (! h) {
#line 565
      goto while_break;
    }
#line 566
    if ((unsigned long )((char *)p) >= (unsigned long )((char *)h + sizeof(struct heap ))) {
#line 566
      if ((unsigned long )((char *)p + sizeof(union mem_align )) < (unsigned long )(((char *)h + sizeof(struct heap )) + (h->size - sizeof(struct heap )))) {
#line 568
        goto while_break;
      }
    }
#line 565
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 569
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 569
    queueing_enabled --;
#line 569
    if (! queueing_enabled) {
      {
#line 569
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 569
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 569
          if (! (queue_front != queue_rear)) {
#line 569
            goto while_break___2;
          }
          {
#line 569
          queue_front = (queue_front + 1) % 128;
#line 569
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 569
          zhandler(signal_queue[queue_front]);
#line 569
          signal_setmask(oset);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 569
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 569
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 570
  if (h) {
#line 570
    tmp = p;
  } else {
#line 570
    tmp = (void *)0;
  }
#line 570
  return (tmp);
}
}
#line 576 "/tmp/zsh-5.4.2/Src/mem.c"
void *zhalloc(size_t size ) 
{ 
  Heap h ;
  Heap hp ;
  size_t n ;
  void *ret ;
  sigset_t oset ;
  sigset_t oset___0 ;

  {
#line 579
  hp = (Heap )((void *)0);
#line 588
  size = ((size + sizeof(union mem_align )) - 1UL) & ~ (sizeof(union mem_align ) - 1UL);
#line 590
  queueing_enabled ++;
#line 605
  if (fheap) {
#line 605
    h = fheap;
  } else {
#line 605
    h = heaps;
  }
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! h) {
#line 605
      goto while_break;
    }
#line 606
    hp = h;
#line 607
    n = size + h->used;
#line 607
    if (h->size - sizeof(struct heap ) >= n) {
#line 610
      h->used = n;
#line 611
      ret = (void *)((((char *)h + sizeof(struct heap )) + n) - size);
      {
#line 612
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 612
        queueing_enabled --;
#line 612
        if (! queueing_enabled) {
          {
#line 612
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 612
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 612
              if (! (queue_front != queue_rear)) {
#line 612
                goto while_break___2;
              }
              {
#line 612
              queue_front = (queue_front + 1) % 128;
#line 612
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 612
              zhandler(signal_queue[queue_front]);
#line 612
              signal_setmask(oset);
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 612
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 612
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 623
      return (ret);
    }
#line 605
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 634
  if ((16384UL - sizeof(union mem_align )) - sizeof(struct heap ) > size) {
#line 634
    n = 16384UL - sizeof(union mem_align );
  } else {
#line 634
    n = size + sizeof(*h);
  }
  {
#line 637
  h = mmap_heap_alloc(& n);
#line 648
  h->size = n;
#line 649
  h->used = size;
#line 650
  h->next = (struct heap *)((void *)0);
#line 651
  h->sp = (struct heapstack *)((void *)0);
  }
#line 667
  if (hp) {
#line 668
    hp->next = h;
  } else {
#line 670
    heaps = h;
  }
#line 671
  fheap = h;
  {
#line 673
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 673
    queueing_enabled --;
#line 673
    if (! queueing_enabled) {
      {
#line 673
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 673
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 673
          if (! (queue_front != queue_rear)) {
#line 673
            goto while_break___5;
          }
          {
#line 673
          queue_front = (queue_front + 1) % 128;
#line 673
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 673
          zhandler(signal_queue[queue_front]);
#line 673
          signal_setmask(oset___0);
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 673
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 673
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 681
  return ((void *)((char *)h + sizeof(struct heap )));
}
}
#line 686 "/tmp/zsh-5.4.2/Src/mem.c"
void *hrealloc(char *p , size_t old , size_t new ) 
{ 
  Heap h ;
  Heap ph ;
  void *tmp ;
  char *ptr___0 ;
  void *tmp___0 ;
  sigset_t oset ;
  sigset_t oset___0 ;
  char *tmp___1 ;
  sigset_t oset___1 ;
  Heap hnew ;
  size_t n ;
  sigset_t oset___2 ;
  sigset_t oset___3 ;
  char *t ;
  void *tmp___2 ;
  size_t tmp___3 ;
  sigset_t oset___4 ;

  {
#line 695
  old = ((old + sizeof(union mem_align )) - 1UL) & ~ (sizeof(union mem_align ) - 1UL);
#line 696
  new = ((new + sizeof(union mem_align )) - 1UL) & ~ (sizeof(union mem_align ) - 1UL);
#line 698
  if (old == new) {
#line 699
    return ((void *)p);
  }
#line 700
  if (! old) {
#line 700
    if (! p) {
      {
#line 704
      tmp = zhalloc(new);
      }
#line 704
      return (tmp);
    }
  }
#line 709
  queueing_enabled ++;
#line 710
  h = heaps;
#line 710
  ph = (Heap )((void *)0);
  {
#line 710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 710
    if (! h) {
#line 710
      goto while_break;
    }
#line 711
    if ((unsigned long )p >= (unsigned long )((char *)h + sizeof(struct heap ))) {
#line 711
      if ((unsigned long )p < (unsigned long )(((char *)h + sizeof(struct heap )) + (h->size - sizeof(struct heap )))) {
#line 712
        goto while_break;
      }
    }
#line 710
    ph = h;
#line 710
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 726
  if ((unsigned long )(p + old) < (unsigned long )(((char *)h + sizeof(struct heap )) + h->used)) {
#line 727
    if (new > old) {
      {
#line 731
      tmp___0 = zhalloc(new);
#line 731
      ptr___0 = (char *)tmp___0;
#line 733
      memcpy((void */* __restrict  */)ptr___0, (void const   */* __restrict  */)p,
             old);
      }
      {
#line 744
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 744
        queueing_enabled --;
#line 744
        if (! queueing_enabled) {
          {
#line 744
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 744
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 744
              if (! (queue_front != queue_rear)) {
#line 744
                goto while_break___2;
              }
              {
#line 744
              queue_front = (queue_front + 1) % 128;
#line 744
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 744
              zhandler(signal_queue[queue_front]);
#line 744
              signal_setmask(oset);
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 744
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 744
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 745
      return ((void *)ptr___0);
    } else {
      {
#line 755
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 755
        queueing_enabled --;
#line 755
        if (! queueing_enabled) {
          {
#line 755
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 755
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 755
              if (! (queue_front != queue_rear)) {
#line 755
                goto while_break___5;
              }
              {
#line 755
              queue_front = (queue_front + 1) % 128;
#line 755
              oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 755
              zhandler(signal_queue[queue_front]);
#line 755
              signal_setmask(oset___0);
              }
            }
            while_break___5: /* CIL Label */ ;
            }
#line 755
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 755
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 756
      if (new) {
#line 756
        tmp___1 = p;
      } else {
#line 756
        tmp___1 = (char *)((void *)0);
      }
#line 756
      return ((void *)tmp___1);
    }
  }
#line 770
  if ((unsigned long )p == (unsigned long )((char *)h + sizeof(struct heap ))) {
#line 778
    if (! new) {
#line 779
      if (ph) {
#line 780
        ph->next = h->next;
      } else {
#line 782
        heaps = h->next;
      }
      {
#line 783
      fheap = (Heap )((void *)0);
#line 785
      munmap((void *)h, h->size);
      }
      {
#line 792
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 792
        queueing_enabled --;
#line 792
        if (! queueing_enabled) {
          {
#line 792
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 792
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 792
              if (! (queue_front != queue_rear)) {
#line 792
                goto while_break___8;
              }
              {
#line 792
              queue_front = (queue_front + 1) % 128;
#line 792
              oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 792
              zhandler(signal_queue[queue_front]);
#line 792
              signal_setmask(oset___1);
              }
            }
            while_break___8: /* CIL Label */ ;
            }
#line 792
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
#line 792
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 793
      return ((void *)0);
    }
#line 795
    if (new > h->size - sizeof(struct heap )) {
      {
#line 807
      n = (new + sizeof(*h)) + (16384UL - sizeof(union mem_align ));
#line 808
      n -= n % (16384UL - sizeof(union mem_align ));
#line 809
      fheap = (Heap )((void *)0);
#line 818
      hnew = mmap_heap_alloc(& n);
#line 820
      memcpy((void */* __restrict  */)hnew, (void const   */* __restrict  */)h, h->size);
#line 821
      munmap((void *)h, h->size);
#line 834
      h = hnew;
#line 836
      h->size = n;
      }
#line 837
      if (ph) {
#line 838
        ph->next = h;
      } else {
#line 840
        heaps = h;
      }
    }
#line 849
    h->used = new;
    {
#line 853
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 853
      queueing_enabled --;
#line 853
      if (! queueing_enabled) {
        {
#line 853
        while (1) {
          while_continue___10: /* CIL Label */ ;
          {
#line 853
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 853
            if (! (queue_front != queue_rear)) {
#line 853
              goto while_break___11;
            }
            {
#line 853
            queue_front = (queue_front + 1) % 128;
#line 853
            oset___2 = signal_setmask(signal_mask_queue[queue_front]);
#line 853
            zhandler(signal_queue[queue_front]);
#line 853
            signal_setmask(oset___2);
            }
          }
          while_break___11: /* CIL Label */ ;
          }
#line 853
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 853
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 854
    return ((void *)((char *)h + sizeof(struct heap )));
  }
#line 859
  if (h->used + (new - old) <= h->size - sizeof(struct heap )) {
#line 860
    h->used += new - old;
    {
#line 861
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 861
      queueing_enabled --;
#line 861
      if (! queueing_enabled) {
        {
#line 861
        while (1) {
          while_continue___13: /* CIL Label */ ;
          {
#line 861
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 861
            if (! (queue_front != queue_rear)) {
#line 861
              goto while_break___14;
            }
            {
#line 861
            queue_front = (queue_front + 1) % 128;
#line 861
            oset___3 = signal_setmask(signal_mask_queue[queue_front]);
#line 861
            zhandler(signal_queue[queue_front]);
#line 861
            signal_setmask(oset___3);
            }
          }
          while_break___14: /* CIL Label */ ;
          }
#line 861
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
#line 861
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 867
    return ((void *)p);
  } else {
    {
#line 869
    tmp___2 = zhalloc(new);
#line 869
    t = (char *)tmp___2;
    }
#line 870
    if (old > new) {
#line 870
      tmp___3 = new;
    } else {
#line 870
      tmp___3 = old;
    }
    {
#line 870
    memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)p, tmp___3);
#line 871
    h->used -= old;
    }
    {
#line 879
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 879
      queueing_enabled --;
#line 879
      if (! queueing_enabled) {
        {
#line 879
        while (1) {
          while_continue___16: /* CIL Label */ ;
          {
#line 879
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 879
            if (! (queue_front != queue_rear)) {
#line 879
              goto while_break___17;
            }
            {
#line 879
            queue_front = (queue_front + 1) % 128;
#line 879
            oset___4 = signal_setmask(signal_mask_queue[queue_front]);
#line 879
            zhandler(signal_queue[queue_front]);
#line 879
            signal_setmask(oset___4);
            }
          }
          while_break___17: /* CIL Label */ ;
          }
#line 879
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
#line 879
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 880
    return ((void *)t);
  }
}
}
#line 945 "/tmp/zsh-5.4.2/Src/mem.c"
void *hcalloc(size_t size ) 
{ 
  void *ptr___0 ;

  {
  {
#line 950
  ptr___0 = zhalloc(size);
#line 951
  memset(ptr___0, 0, size);
  }
#line 952
  return (ptr___0);
}
}
#line 958 "/tmp/zsh-5.4.2/Src/mem.c"
void *zalloc(size_t size ) 
{ 
  void *ptr___0 ;
  void *tmp ;
  sigset_t oset ;

  {
#line 963
  if (! size) {
#line 964
    size = (size_t )1;
  }
  {
#line 965
  queueing_enabled ++;
#line 966
  tmp = malloc(size);
#line 966
  ptr___0 = tmp;
  }
#line 966
  if (! ptr___0) {
    {
#line 967
    zerr("fatal error: out of memory");
#line 968
    exit(1);
    }
  }
  {
#line 970
  while (1) {
    while_continue: /* CIL Label */ ;
#line 970
    queueing_enabled --;
#line 970
    if (! queueing_enabled) {
      {
#line 970
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 970
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 970
          if (! (queue_front != queue_rear)) {
#line 970
            goto while_break___1;
          }
          {
#line 970
          queue_front = (queue_front + 1) % 128;
#line 970
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 970
          zhandler(signal_queue[queue_front]);
#line 970
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 970
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 970
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 972
  return (ptr___0);
}
}
#line 976 "/tmp/zsh-5.4.2/Src/mem.c"
void *zshcalloc(size_t size ) 
{ 
  void *ptr___0 ;
  void *tmp ;

  {
  {
#line 979
  tmp = zalloc(size);
#line 979
  ptr___0 = tmp;
  }
#line 980
  if (! size) {
#line 981
    size = (size_t )1;
  }
  {
#line 982
  memset(ptr___0, 0, size);
  }
#line 983
  return (ptr___0);
}
}
#line 993 "/tmp/zsh-5.4.2/Src/mem.c"
void *zrealloc(void *ptr___0 , size_t size ) 
{ 
  void *tmp ;
  sigset_t oset ;
  void *tmp___0 ;
  sigset_t oset___0 ;

  {
#line 996
  queueing_enabled ++;
#line 997
  if (ptr___0) {
#line 998
    if (size) {
      {
#line 1000
      tmp = realloc(ptr___0, size);
#line 1000
      ptr___0 = tmp;
      }
#line 1000
      if (! ptr___0) {
        {
#line 1001
        zerr("fatal error: out of memory");
#line 1002
        exit(1);
        }
      }
      {
#line 1004
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1004
        queueing_enabled --;
#line 1004
        if (! queueing_enabled) {
          {
#line 1004
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 1004
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1004
              if (! (queue_front != queue_rear)) {
#line 1004
                goto while_break___1;
              }
              {
#line 1004
              queue_front = (queue_front + 1) % 128;
#line 1004
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1004
              zhandler(signal_queue[queue_front]);
#line 1004
              signal_setmask(oset);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 1004
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 1004
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1005
      return (ptr___0);
    } else {
      {
#line 1010
      free(ptr___0);
      }
    }
#line 1012
    ptr___0 = (void *)0;
  } else {
    {
#line 1015
    tmp___0 = malloc(size);
#line 1015
    ptr___0 = tmp___0;
    }
#line 1015
    if (! ptr___0) {
      {
#line 1016
      zerr("fatal error: out of memory");
#line 1017
      exit(1);
      }
    }
  }
  {
#line 1020
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1020
    queueing_enabled --;
#line 1020
    if (! queueing_enabled) {
      {
#line 1020
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1020
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1020
          if (! (queue_front != queue_rear)) {
#line 1020
            goto while_break___4;
          }
          {
#line 1020
          queue_front = (queue_front + 1) % 128;
#line 1020
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 1020
          zhandler(signal_queue[queue_front]);
#line 1020
          signal_setmask(oset___0);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1020
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 1020
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1022
  return (ptr___0);
}
}
#line 1879 "/tmp/zsh-5.4.2/Src/mem.c"
void zfree(void *p , int sz___0  __attribute__((__unused__)) ) 
{ 


  {
#line 1882
  if (p) {
    {
#line 1883
    free(p);
    }
  }
#line 1884
  return;
}
}
#line 1887 "/tmp/zsh-5.4.2/Src/mem.c"
void zsfree(char *p ) 
{ 


  {
#line 1890
  if (p) {
    {
#line 1891
    free((void *)p);
    }
  }
#line 1892
  return;
}
}
#line 5 "./math.epro"
int noeval  ;
#line 6 "./math.epro"
mnumber zero_mnumber  ;
#line 7 "./math.epro"
mnumber lastmathval  ;
#line 8 "./math.epro"
int lastbase  ;
#line 9 "./math.epro"
int outputradix  ;
#line 10 "./math.epro"
int outputunderscore  ;
#line 11
void op(int what ) ;
#line 2 "./math.pro"
static int zzlex(void) ;
#line 3
static void push(mnumber val , char *lval , int getme ) ;
#line 4
static mnumber pop(int noget ) ;
#line 5
static mnumber getcvar(char *s ) ;
#line 6
static mnumber setmathvar(struct mathvalue *mvp , mnumber v ) ;
#line 7
static mnumber callmathfunc(char *o ) ;
#line 8
static int notzero(mnumber a ) ;
#line 9
static void bop(int tk ) ;
#line 10
static void checkunary(int mtokc , char *mptr ) ;
#line 11
static void mathparse(int pc ) ;
#line 140 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 60 "/tmp/zsh-5.4.2/Src/math.c"
static char *ptr  ;
#line 62 "/tmp/zsh-5.4.2/Src/math.c"
static mnumber yyval  ;
#line 63 "/tmp/zsh-5.4.2/Src/math.c"
static char *yylval  ;
#line 67 "/tmp/zsh-5.4.2/Src/math.c"
static int mlevel  =    0;
#line 71 "/tmp/zsh-5.4.2/Src/math.c"
static int unary  =    1;
#line 195 "/tmp/zsh-5.4.2/Src/math.c"
static int c_prec[53]  = 
#line 195
  {      1,      137,      2,      2, 
        2,      2,      2,      2, 
        9,      10,      11,      4, 
        4,      4,      5,      5, 
        6,      6,      7,      7, 
        7,      7,      8,      8, 
        12,      14,      13,      15, 
        16,      17,      17,      17, 
        17,      17,      17,      17, 
        17,      17,      17,      17, 
        17,      17,      17,      18, 
        200,      2,      2,      0, 
        0,      3,      0,      17, 
        0};
#line 251 "/tmp/zsh-5.4.2/Src/math.c"
static int z_prec[53]  = 
#line 251
  {      1,      137,      2,      2, 
        2,      2,      2,      2, 
        4,      5,      6,      8, 
        8,      8,      9,      9, 
        3,      3,      10,      10, 
        10,      10,      11,      11, 
        12,      13,      13,      14, 
        15,      16,      16,      16, 
        16,      16,      16,      16, 
        16,      16,      16,      16, 
        16,      16,      16,      17, 
        200,      2,      2,      0, 
        0,      7,      0,      16, 
        0};
#line 278 "/tmp/zsh-5.4.2/Src/math.c"
static int *prec  ;
#line 287 "/tmp/zsh-5.4.2/Src/math.c"
static int type[53]  = 
#line 287
  {      0,      384,      1,      1, 
        385,      385,      1,      1, 
        16,      16,      16,      4, 
        4,      4,      4,      4, 
        16,      16,      8,      8, 
        8,      8,      8,      8, 
        18,      18,      16,      129, 
        129,      33,      33,      33, 
        33,      33,      33,      65, 
        65,      65,      65,      65, 
        66,      66,      17,      5, 
        129,      1,      1,      256, 
        256,      5,      256,      33, 
        256};
#line 305 "/tmp/zsh-5.4.2/Src/math.c"
static int mtok  ;
#line 306 "/tmp/zsh-5.4.2/Src/math.c"
static int sp  =    -1;
#line 322 "/tmp/zsh-5.4.2/Src/math.c"
static struct mathvalue *stack  ;
#line 336 "/tmp/zsh-5.4.2/Src/math.c"
static mnumber getmathparam(struct mathvalue *mptr ) 
{ 
  mnumber result ;
  char *s ;
  void *tmp ;
  Value tmp___0 ;

  {
#line 340
  if (! mptr->pval) {
    {
#line 341
    s = mptr->lval;
#line 342
    tmp = zhalloc(sizeof(struct value ));
#line 342
    mptr->pval = (Value )tmp;
#line 343
    tmp___0 = getvalue(mptr->pval, & s, 1);
    }
#line 343
    if (! tmp___0) {
#line 345
      mptr->pval = (Value )((void *)0);
#line 346
      if (opts[57]) {
#line 347
        result.type = 2;
#line 348
        result.u.d = 0.0;
#line 349
        return (result);
      }
#line 351
      return (zero_mnumber);
    }
  }
  {
#line 354
  result = getnumvalue(mptr->pval);
  }
#line 355
  if (opts[57]) {
#line 355
    if (result.type == 1) {
#line 356
      result.type = 2;
#line 357
      result.u.d = (double )result.u.l;
    }
  }
#line 359
  return (result);
}
}
#line 362 "/tmp/zsh-5.4.2/Src/math.c"
static mnumber mathevall(char *s , enum prec_type prec_tp , char **ep___0 ) 
{ 
  int xlastbase ;
  int xnoeval ;
  int xunary ;
  int *xprec ;
  char *xptr ;
  mnumber xyyval ;
  char *xyylval ;
  int xsp ;
  struct mathvalue *xstack ;
  struct mathvalue nstack[100] ;
  mnumber ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 370
  xstack = (struct mathvalue *)0;
#line 373
  if (mlevel >= 256) {
    {
#line 374
    xyyval.type = 1;
#line 375
    xyyval.u.l = (zlong )0;
#line 376
    *ep___0 = s;
#line 378
    zerr("math recursion limit exceeded: %s", *ep___0);
    }
#line 380
    return (xyyval);
  }
#line 382
  tmp = mlevel;
#line 382
  mlevel ++;
#line 382
  if (tmp) {
#line 383
    xlastbase = lastbase;
#line 384
    xnoeval = noeval;
#line 385
    xunary = unary;
#line 386
    xptr = ptr;
#line 387
    xyyval = yyval;
#line 388
    xyylval = yylval;
#line 390
    xsp = sp;
#line 391
    xstack = stack;
#line 392
    xprec = prec;
  } else {
#line 394
    xsp = 0;
#line 394
    xunary = xsp;
#line 394
    xnoeval = xunary;
#line 394
    xlastbase = xnoeval;
#line 395
    xyyval.type = 1;
#line 396
    xyyval.u.l = (zlong )0;
#line 397
    xyylval = (char *)((void *)0);
#line 398
    xptr = (char *)((void *)0);
#line 399
    xprec = (int *)((void *)0);
  }
#line 401
  if (opts[41]) {
#line 401
    prec = c_prec;
  } else {
#line 401
    prec = z_prec;
  }
#line 402
  stack = nstack;
#line 403
  lastbase = -1;
#line 404
  ptr = s;
#line 405
  sp = -1;
#line 406
  unary = 1;
#line 407
  (stack + 0)->val.type = 1;
#line 408
  (stack + 0)->val.u.l = (zlong )0;
#line 409
  if ((unsigned int )prec_tp == 0U) {
#line 409
    tmp___0 = *(prec + 43) + 1;
  } else {
#line 409
    tmp___0 = *(prec + 43) - 1;
  }
  {
#line 409
  mathparse(tmp___0);
  }
#line 415
  if (mtok == 1) {
#line 415
    if (! errflag) {
      {
#line 416
      zerr("bad math expression: unexpected \')\'");
      }
    }
  }
#line 417
  *ep___0 = ptr;
#line 421
  if (errflag) {
#line 433
    ret.type = 1;
#line 434
    ret.u.l = (zlong )0;
  } else
#line 436
  if ((stack + 0)->val.type == 4) {
    {
#line 437
    ret = getmathparam(stack);
    }
  } else {
#line 439
    ret = (stack + 0)->val;
  }
#line 442
  mlevel --;
#line 442
  if (mlevel) {
#line 443
    lastbase = xlastbase;
#line 444
    noeval = xnoeval;
#line 445
    unary = xunary;
#line 446
    ptr = xptr;
#line 447
    yyval = xyyval;
#line 448
    yylval = xyylval;
#line 450
    sp = xsp;
#line 451
    stack = xstack;
#line 452
    prec = xprec;
  }
#line 454
  lastmathval = ret;
#line 454
  return (lastmathval);
}
}
#line 457 "/tmp/zsh-5.4.2/Src/math.c"
static int lexconstant(void) 
{ 
  char *prev_locale ;
  char *nptr ;
  int lowchar ;
  int __res ;
  __int32_t const   **tmp___0 ;
  char *ptr2 ;
  char *ptr2___0 ;
  char *tmp___1 ;
  int len ;

  {
#line 465
  nptr = ptr;
#line 466
  if ((int )*nptr == 45) {
#line 467
    nptr ++;
  } else
#line 466
  if ((int )*nptr == -101) {
#line 467
    nptr ++;
  }
#line 469
  if ((int )*nptr == 48) {
#line 471
    nptr ++;
#line 472
    if (sizeof(*nptr) > 1UL) {
      {
#line 472
      __res = tolower((int )*nptr);
      }
    } else {
      {
#line 472
      tmp___0 = __ctype_tolower_loc();
#line 472
      __res = (int )*(*tmp___0 + (int )*nptr);
      }
    }
#line 472
    lowchar = __res;
#line 473
    if (lowchar == 120) {
#line 473
      goto _L;
    } else
#line 473
    if (lowchar == 98) {
      _L: /* CIL Label */ 
      {
#line 475
      yyval.u.l = zstrtol_underscore((char const   *)ptr, & ptr, 0, 1);
      }
#line 477
      if (lowchar == 98) {
#line 477
        lastbase = 2;
      } else {
#line 477
        lastbase = 16;
      }
#line 478
      if (opts[57]) {
#line 480
        yyval.type = 2;
#line 481
        yyval.u.d = (double )yyval.u.l;
      }
#line 483
      return (47);
    } else
#line 485
    if (opts[124]) {
#line 494
      ptr2 = nptr;
      {
#line 494
      while (1) {
        while_continue: /* CIL Label */ ;
#line 494
        if (! ((int )typtab[(unsigned char )*ptr2] & 1)) {
#line 494
          if (! ((int )*ptr2 == 95)) {
#line 494
            goto while_break;
          }
        }
#line 494
        ptr2 ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 497
      if ((unsigned long )ptr2 > (unsigned long )nptr) {
#line 497
        if ((int )*ptr2 != 46) {
#line 497
          if ((int )*ptr2 != 101) {
#line 497
            if ((int )*ptr2 != 69) {
#line 497
              if ((int )*ptr2 != 35) {
                {
#line 500
                yyval.u.l = zstrtol_underscore((char const   *)ptr, & ptr, 0, 1);
#line 501
                lastbase = 8;
                }
#line 502
                if (opts[57]) {
#line 504
                  yyval.type = 2;
#line 505
                  yyval.u.d = (double )yyval.u.l;
                }
#line 507
                return (47);
              }
            }
          }
        }
      }
#line 509
      nptr = ptr2;
    }
  }
  {
#line 512
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 512
    if (! ((int )typtab[(unsigned char )*nptr] & 1)) {
#line 512
      if (! ((int )*nptr == 95)) {
#line 512
        goto while_break___0;
      }
    }
#line 513
    nptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 515
  if ((int )*nptr == 46) {
#line 515
    goto _L___1;
  } else
#line 515
  if ((int )*nptr == 101) {
#line 515
    goto _L___1;
  } else
#line 515
  if ((int )*nptr == 69) {
    _L___1: /* CIL Label */ 
    {
#line 518
    yyval.type = 2;
#line 520
    tmp___1 = setlocale(1, (char const   *)((void *)0));
#line 520
    prev_locale = dupstring((char const   *)tmp___1);
#line 521
    setlocale(1, "POSIX");
    }
#line 523
    if ((int )*nptr == 46) {
#line 524
      nptr ++;
      {
#line 525
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 525
        if (! ((int )typtab[(unsigned char )*nptr] & 1)) {
#line 525
          if (! ((int )*nptr == 95)) {
#line 525
            goto while_break___1;
          }
        }
#line 526
        nptr ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 528
    if ((int )*nptr == 101) {
#line 528
      goto _L___0;
    } else
#line 528
    if ((int )*nptr == 69) {
      _L___0: /* CIL Label */ 
#line 529
      nptr ++;
#line 530
      if ((int )*nptr == 43) {
#line 531
        nptr ++;
      } else
#line 530
      if ((int )*nptr == 45) {
#line 531
        nptr ++;
      } else
#line 530
      if ((int )*nptr == -101) {
#line 531
        nptr ++;
      }
      {
#line 532
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 532
        if (! ((int )typtab[(unsigned char )*nptr] & 1)) {
#line 532
          if (! ((int )*nptr == 95)) {
#line 532
            goto while_break___2;
          }
        }
#line 533
        nptr ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 535
    ptr2___0 = ptr;
    {
#line 535
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 535
      if (! ((unsigned long )ptr2___0 < (unsigned long )nptr)) {
#line 535
        goto while_break___3;
      }
#line 536
      if ((int )*ptr2___0 == 95) {
        {
#line 537
        len = (int )(nptr - ptr);
#line 538
        ptr = ztrdup((char const   *)ptr);
#line 539
        ptr2___0 = ptr;
        }
        {
#line 539
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 539
          if (! len) {
#line 539
            goto while_break___4;
          }
#line 540
          if ((int )*ptr2___0 == 95) {
            {
#line 541
            chuck(ptr2___0);
            }
          } else {
#line 543
            ptr2___0 ++;
          }
#line 539
          len --;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 545
        goto while_break___3;
      }
#line 535
      ptr2___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 548
    yyval.u.d = strtod((char const   */* __restrict  */)ptr, (char **/* __restrict  */)(& nptr));
    }
#line 550
    if (prev_locale) {
      {
#line 550
      setlocale(1, (char const   *)prev_locale);
      }
    }
#line 552
    if ((unsigned long )ptr == (unsigned long )nptr) {
      {
#line 553
      zerr("bad floating point constant");
      }
#line 554
      return (44);
    } else
#line 552
    if ((int )*nptr == 46) {
      {
#line 553
      zerr("bad floating point constant");
      }
#line 554
      return (44);
    }
#line 556
    ptr = nptr;
  } else {
    {
#line 559
    yyval.u.l = zstrtol_underscore((char const   *)ptr, & ptr, 10, 1);
    }
#line 561
    if ((int )*ptr == 35) {
      {
#line 562
      ptr ++;
#line 563
      lastbase = (int )yyval.u.l;
#line 564
      yyval.u.l = zstrtol_underscore((char const   *)ptr, & ptr, lastbase, 1);
      }
    }
#line 566
    if (opts[57]) {
#line 568
      yyval.type = 2;
#line 569
      yyval.u.d = (double )yyval.u.l;
    }
  }
#line 572
  return (47);
}
}
#line 582 "/tmp/zsh-5.4.2/Src/math.c"
static int zzlex(void) 
{ 
  int cct ;
  char *ie ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int n ;
  int checkradix ;
  zlong tmp___4 ;
  zlong tmp___5 ;
  zlong tmp___6 ;
  int tmp___7 ;
  int v ;
  int func ;
  char *p ;
  char op___0 ;
  char cp ;
  int tmp___8 ;
  int l ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 585
  cct = 0;
#line 587
  yyval.type = 1;
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 590
    tmp = ptr;
#line 590
    ptr ++;
    {
#line 591
    if ((int )*tmp == 43) {
#line 591
      goto case_43;
    }
#line 602
    if ((int )*tmp == -101) {
#line 602
      goto case_neg_101;
    }
#line 602
    if ((int )*tmp == 45) {
#line 602
      goto case_neg_101;
    }
#line 619
    if ((int )*tmp == 40) {
#line 619
      goto case_40;
    }
#line 621
    if ((int )*tmp == 41) {
#line 621
      goto case_41;
    }
#line 623
    if ((int )*tmp == 33) {
#line 623
      goto case_33;
    }
#line 629
    if ((int )*tmp == 126) {
#line 629
      goto case_126;
    }
#line 631
    if ((int )*tmp == 38) {
#line 631
      goto case_38;
    }
#line 643
    if ((int )*tmp == 124) {
#line 643
      goto case_124;
    }
#line 655
    if ((int )*tmp == 94) {
#line 655
      goto case_94;
    }
#line 667
    if ((int )*tmp == 42) {
#line 667
      goto case_42;
    }
#line 680
    if ((int )*tmp == 47) {
#line 680
      goto case_47;
    }
#line 686
    if ((int )*tmp == 37) {
#line 686
      goto case_37;
    }
#line 692
    if ((int )*tmp == 60) {
#line 692
      goto case_60;
    }
#line 704
    if ((int )*tmp == 62) {
#line 704
      goto case_62;
    }
#line 716
    if ((int )*tmp == 61) {
#line 716
      goto case_61;
    }
#line 722
    if ((int )*tmp == 36) {
#line 722
      goto case_36;
    }
#line 725
    if ((int )*tmp == 63) {
#line 725
      goto case_63;
    }
#line 731
    if ((int )*tmp == 58) {
#line 731
      goto case_58;
    }
#line 733
    if ((int )*tmp == 44) {
#line 733
      goto case_44;
    }
#line 735
    if ((int )*tmp == 0) {
#line 735
      goto case_0;
    }
#line 738
    if ((int )*tmp == 91) {
#line 738
      goto case_91;
    }
#line 790
    if ((int )*tmp == 10) {
#line 790
      goto case_10;
    }
#line 790
    if ((int )*tmp == 9) {
#line 790
      goto case_10;
    }
#line 790
    if ((int )*tmp == 32) {
#line 790
      goto case_10;
    }
#line 793
    goto switch_default;
    case_43: /* CIL Label */ 
#line 592
    if ((int )*ptr == 43) {
#line 593
      ptr ++;
#line 594
      if (unary) {
#line 594
        tmp___0 = 45;
      } else {
#line 594
        tmp___0 = 4;
      }
#line 594
      return (tmp___0);
    }
#line 596
    if ((int )*ptr == 61) {
#line 597
      ptr ++;
#line 598
      return (30);
    }
#line 600
    if (unary) {
#line 600
      tmp___1 = 6;
    } else {
#line 600
      tmp___1 = 14;
    }
#line 600
    return (tmp___1);
    case_neg_101: /* CIL Label */ 
    case_45: /* CIL Label */ 
#line 603
    if ((int )*ptr == 45) {
#line 603
      goto _L;
    } else
#line 603
    if ((int )*ptr == -101) {
      _L: /* CIL Label */ 
#line 604
      ptr ++;
#line 605
      if (unary) {
#line 605
        tmp___2 = 46;
      } else {
#line 605
        tmp___2 = 5;
      }
#line 605
      return (tmp___2);
    }
#line 607
    if ((int )*ptr == 61) {
#line 608
      ptr ++;
#line 609
      return (31);
    }
#line 611
    if (unary) {
#line 612
      if ((int )typtab[(unsigned char )*ptr] & 1) {
        {
#line 613
        ptr --;
#line 614
        tmp___3 = lexconstant();
        }
#line 614
        return (tmp___3);
      } else
#line 612
      if ((int )*ptr == 46) {
        {
#line 613
        ptr --;
#line 614
        tmp___3 = lexconstant();
        }
#line 614
        return (tmp___3);
      } else {
#line 616
        return (7);
      }
    } else {
#line 618
      return (15);
    }
    case_40: /* CIL Label */ 
#line 620
    return (0);
    case_41: /* CIL Label */ 
#line 622
    return (1);
    case_33: /* CIL Label */ 
#line 624
    if ((int )*ptr == 61) {
#line 625
      ptr ++;
#line 626
      return (23);
    }
#line 628
    return (2);
    case_126: /* CIL Label */ 
#line 630
    return (3);
    case_38: /* CIL Label */ 
#line 632
    if ((int )*ptr == 38) {
#line 633
      ptr ++;
#line 633
      if ((int )*ptr == 61) {
#line 634
        ptr ++;
#line 635
        return (40);
      }
#line 637
      return (24);
    } else
#line 638
    if ((int )*ptr == 61) {
#line 639
      ptr ++;
#line 640
      return (35);
    }
#line 642
    return (8);
    case_124: /* CIL Label */ 
#line 644
    if ((int )*ptr == 124) {
#line 645
      ptr ++;
#line 645
      if ((int )*ptr == 61) {
#line 646
        ptr ++;
#line 647
        return (41);
      }
#line 649
      return (25);
    } else
#line 650
    if ((int )*ptr == 61) {
#line 651
      ptr ++;
#line 652
      return (37);
    }
#line 654
    return (10);
    case_94: /* CIL Label */ 
#line 656
    if ((int )*ptr == 94) {
#line 657
      ptr ++;
#line 657
      if ((int )*ptr == 61) {
#line 658
        ptr ++;
#line 659
        return (42);
      }
#line 661
      return (26);
    } else
#line 662
    if ((int )*ptr == 61) {
#line 663
      ptr ++;
#line 664
      return (36);
    }
#line 666
    return (9);
    case_42: /* CIL Label */ 
#line 668
    if ((int )*ptr == 42) {
#line 669
      ptr ++;
#line 669
      if ((int )*ptr == 61) {
#line 670
        ptr ++;
#line 671
        return (51);
      }
#line 673
      return (49);
    }
#line 675
    if ((int )*ptr == 61) {
#line 676
      ptr ++;
#line 677
      return (32);
    }
#line 679
    return (11);
    case_47: /* CIL Label */ 
#line 681
    if ((int )*ptr == 61) {
#line 682
      ptr ++;
#line 683
      return (33);
    }
#line 685
    return (12);
    case_37: /* CIL Label */ 
#line 687
    if ((int )*ptr == 61) {
#line 688
      ptr ++;
#line 689
      return (34);
    }
#line 691
    return (13);
    case_60: /* CIL Label */ 
#line 693
    if ((int )*ptr == 60) {
#line 694
      ptr ++;
#line 694
      if ((int )*ptr == 61) {
#line 695
        ptr ++;
#line 696
        return (38);
      }
#line 698
      return (16);
    } else
#line 699
    if ((int )*ptr == 61) {
#line 700
      ptr ++;
#line 701
      return (19);
    }
#line 703
    return (18);
    case_62: /* CIL Label */ 
#line 705
    if ((int )*ptr == 62) {
#line 706
      ptr ++;
#line 706
      if ((int )*ptr == 61) {
#line 707
        ptr ++;
#line 708
        return (39);
      }
#line 710
      return (17);
    } else
#line 711
    if ((int )*ptr == 61) {
#line 712
      ptr ++;
#line 713
      return (21);
    }
#line 715
    return (20);
    case_61: /* CIL Label */ 
#line 717
    if ((int )*ptr == 61) {
#line 718
      ptr ++;
#line 719
      return (22);
    }
#line 721
    return (29);
    case_36: /* CIL Label */ 
#line 723
    yyval.u.l = mypid;
#line 724
    return (47);
    case_63: /* CIL Label */ 
#line 726
    if (unary) {
#line 727
      yyval.u.l = lastval;
#line 728
      return (47);
    }
#line 730
    return (27);
    case_58: /* CIL Label */ 
#line 732
    return (28);
    case_44: /* CIL Label */ 
#line 734
    return (43);
    case_0: /* CIL Label */ 
#line 736
    ptr --;
#line 737
    return (44);
    case_91: /* CIL Label */ 
#line 740
    checkradix = 0;
#line 742
    if ((int )typtab[(unsigned char )*ptr] & 1) {
      {
#line 743
      tmp___4 = zstrtol((char const   *)ptr, & ptr, 10);
#line 743
      n = (int )tmp___4;
      }
#line 744
      if ((int )*ptr != 93) {
        {
#line 745
        zerr("bad base syntax");
        }
#line 746
        return (44);
      } else {
#line 744
        ptr ++;
#line 744
        if (! ((int )typtab[(unsigned char )*ptr] & 1)) {
          {
#line 745
          zerr("bad base syntax");
          }
#line 746
          return (44);
        }
      }
      {
#line 748
      lastbase = n;
#line 748
      yyval.u.l = zstrtol((char const   *)ptr, & ptr, lastbase);
      }
#line 749
      return (47);
    }
#line 751
    if ((int )*ptr == 35) {
#line 752
      n = 1;
#line 753
      ptr ++;
#line 753
      if ((int )*ptr == 35) {
#line 754
        n = -1;
#line 755
        ptr ++;
      }
#line 757
      if (! ((int )typtab[(unsigned char )*ptr] & 1)) {
#line 757
        if ((int )*ptr != 95) {
#line 758
          goto bofs;
        }
      }
#line 759
      if ((int )typtab[(unsigned char )*ptr] & 1) {
        {
#line 760
        tmp___5 = zstrtol((char const   *)ptr, & ptr, 10);
#line 760
        outputradix = (int )((zlong )n * tmp___5);
#line 761
        checkradix = 1;
        }
      }
#line 763
      if ((int )*ptr == 95) {
#line 764
        ptr ++;
#line 765
        if ((int )typtab[(unsigned char )*ptr] & 1) {
          {
#line 766
          tmp___6 = zstrtol((char const   *)ptr, & ptr, 10);
#line 766
          outputunderscore = (int )tmp___6;
          }
        } else {
#line 768
          outputunderscore = 3;
        }
      }
    } else {
      bofs: 
      {
#line 772
      zerr("bad output format specification");
      }
#line 773
      return (44);
    }
#line 775
    if ((int )*ptr != 93) {
#line 776
      goto bofs;
    }
#line 777
    if (checkradix) {
#line 778
      if (outputradix < 0) {
#line 778
        n = - outputradix;
      } else {
#line 778
        n = outputradix;
      }
#line 779
      if (n < 2) {
        {
#line 780
        zerr("invalid base (must be 2 to 36 inclusive): %d", outputradix);
        }
#line 782
        return (44);
      } else
#line 779
      if (n > 36) {
        {
#line 780
        zerr("invalid base (must be 2 to 36 inclusive): %d", outputradix);
        }
#line 782
        return (44);
      }
    }
#line 785
    ptr ++;
#line 786
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 791
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 794
    ptr --;
#line 794
    if ((int )typtab[(unsigned char )*ptr] & 1) {
      {
#line 795
      tmp___7 = lexconstant();
      }
#line 795
      return (tmp___7);
    } else
#line 794
    if ((int )*ptr == 46) {
      {
#line 795
      tmp___7 = lexconstant();
      }
#line 795
      return (tmp___7);
    }
#line 796
    if ((int )*ptr == 35) {
#line 797
      ptr ++;
#line 797
      if ((int )*ptr == 92) {
#line 797
        goto _L___0;
      } else
#line 797
      if ((int )*ptr == 35) {
        _L___0: /* CIL Label */ 
#line 800
        ptr ++;
#line 801
        if (! *ptr) {
          {
#line 802
          zerr("bad math expression: character missing after ##");
          }
#line 803
          return (44);
        }
        {
#line 805
        ptr = getkeystring(ptr, (int *)((void *)0), 71, & v);
#line 806
        yyval.u.l = (zlong )v;
        }
#line 807
        return (47);
      }
#line 809
      cct = 1;
    }
    {
#line 811
    ie = itype_end((char const   *)ptr, 1 << 7, 0);
    }
#line 811
    if ((unsigned long )ie != (unsigned long )ptr) {
#line 812
      func = 0;
#line 815
      p = ptr;
#line 816
      ptr = ie;
#line 817
      if ((int )*ptr == 91) {
#line 817
        goto _L___1;
      } else
#line 817
      if (! cct) {
#line 817
        if ((int )*ptr == 40) {
          _L___1: /* CIL Label */ 
#line 818
          op___0 = *ptr;
#line 818
          if ((int )*ptr == 91) {
#line 818
            tmp___8 = ']';
          } else {
#line 818
            tmp___8 = ')';
          }
#line 818
          cp = (char )tmp___8;
#line 820
          func = (int )op___0 == 40;
#line 821
          ptr ++;
#line 821
          l = 1;
          {
#line 821
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 821
            if (*ptr) {
#line 821
              if (! l) {
#line 821
                goto while_break___0;
              }
            } else {
#line 821
              goto while_break___0;
            }
#line 822
            if ((int )*ptr == (int )op___0) {
#line 823
              l ++;
            }
#line 824
            if ((int )*ptr == (int )cp) {
#line 825
              l --;
            }
#line 826
            if ((int )*ptr == 92) {
#line 826
              if (*(ptr + 1)) {
#line 827
                ptr ++;
              }
            }
#line 821
            ptr ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
      {
#line 830
      yylval = dupstrpfx((char const   *)p, (int )(ptr - p));
      }
#line 831
      if (func) {
#line 831
        tmp___10 = 52;
      } else {
#line 831
        if (cct) {
#line 831
          tmp___9 = 50;
        } else {
#line 831
          tmp___9 = 48;
        }
#line 831
        tmp___10 = tmp___9;
      }
#line 831
      return (tmp___10);
    } else
#line 833
    if (cct) {
      {
#line 834
      yyval.u.l = poundgetfn((Param )((void *)0));
      }
#line 835
      return (47);
    }
#line 837
    return (44);
    switch_break: /* CIL Label */ ;
    }
#line 589
    cct = 0;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 842 "/tmp/zsh-5.4.2/Src/math.c"
static void push(mnumber val , char *lval , int getme ) 
{ 


  {
#line 845
  if (sp == 99) {
    {
#line 846
    zerr("stack overflow");
    }
  } else {
#line 848
    sp ++;
  }
#line 849
  (stack + sp)->val = val;
#line 850
  (stack + sp)->lval = lval;
#line 851
  (stack + sp)->pval = (Value )((void *)0);
#line 852
  if (getme) {
#line 853
    (stack + sp)->val.type = 4;
  }
#line 854
  return;
}
}
#line 857 "/tmp/zsh-5.4.2/Src/math.c"
static mnumber pop(int noget ) 
{ 
  struct mathvalue *mv ;
  mnumber tmp ;

  {
#line 860
  mv = stack + sp;
#line 862
  if (mv->val.type == 4) {
#line 862
    if (! noget) {
      {
#line 863
      mv->val = getmathparam(mv);
      }
    }
  }
#line 864
  sp --;
#line 865
  if (errflag) {
#line 865
    tmp = zero_mnumber;
  } else {
#line 865
    tmp = mv->val;
  }
#line 865
  return (tmp);
}
}
#line 869 "/tmp/zsh-5.4.2/Src/math.c"
static mnumber getcvar(char *s ) 
{ 
  char *t ;
  mnumber mn ;
  wint_t wc ;
  sigset_t oset ;
  int tmp ;
  sigset_t oset___0 ;

  {
  {
#line 874
  mn.type = 1;
#line 876
  queueing_enabled ++;
#line 877
  t = getsparam(s);
  }
#line 877
  if (t) {
#line 881
    if (opts[117]) {
      {
#line 883
      mb_metacharlenconv((char const   *)t, & wc);
      }
#line 884
      if (wc != 4294967295U) {
#line 885
        mn.u.l = (zlong )wc;
        {
#line 886
        while (1) {
          while_continue: /* CIL Label */ ;
#line 886
          queueing_enabled --;
#line 886
          if (! queueing_enabled) {
            {
#line 886
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 886
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 886
                if (! (queue_front != queue_rear)) {
#line 886
                  goto while_break___1;
                }
                {
#line 886
                queue_front = (queue_front + 1) % 128;
#line 886
                oset = signal_setmask(signal_mask_queue[queue_front]);
#line 886
                zhandler(signal_queue[queue_front]);
#line 886
                signal_setmask(oset);
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 886
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 886
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 887
        return (mn);
      }
    }
#line 891
    if ((int )*t == -125) {
#line 891
      tmp = (int )*(t + 1) ^ 32;
    } else {
#line 891
      tmp = (int )*t;
    }
#line 891
    mn.u.l = (zlong )((unsigned char )tmp);
  } else {
#line 878
    mn.u.l = (zlong )0;
  }
  {
#line 893
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 893
    queueing_enabled --;
#line 893
    if (! queueing_enabled) {
      {
#line 893
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 893
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 893
          if (! (queue_front != queue_rear)) {
#line 893
            goto while_break___4;
          }
          {
#line 893
          queue_front = (queue_front + 1) % 128;
#line 893
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 893
          zhandler(signal_queue[queue_front]);
#line 893
          signal_setmask(oset___0);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 893
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 893
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 894
  return (mn);
}
}
#line 898 "/tmp/zsh-5.4.2/Src/math.c"
static mnumber setmathvar(struct mathvalue *mvp , mnumber v ) 
{ 
  Param pm ;
  char *s ;
  char *ptr___0 ;
  Param pm___0 ;
  HashNode tmp ;

  {
#line 903
  if (mvp->pval) {
    {
#line 908
    s = mvp->lval;
#line 911
    ptr___0 = strchr((char const   *)s, '[');
    }
#line 911
    if (ptr___0) {
      {
#line 912
      s = dupstrpfx((char const   *)s, (int )(ptr___0 - s));
      }
    }
    {
#line 913
    tmp = (*(paramtab->getnode))(paramtab, (char const   *)s);
#line 913
    pm___0 = (Param )tmp;
    }
#line 914
    if ((unsigned long )pm___0 == (unsigned long )(mvp->pval)->pm) {
#line 915
      if (noeval) {
#line 916
        return (v);
      }
      {
#line 917
      setnumvalue(mvp->pval, v);
      }
#line 918
      return (v);
    }
#line 921
    mvp->pval = (Value )((void *)0);
  }
#line 923
  if (! mvp->lval) {
    {
#line 924
    zerr("bad math expression: lvalue required");
#line 925
    v.type = 1;
#line 926
    v.u.l = (zlong )0;
    }
#line 927
    return (v);
  }
#line 929
  if (noeval) {
#line 930
    return (v);
  }
  {
#line 931
  untokenize(mvp->lval);
#line 932
  pm = setnparam(mvp->lval, v);
  }
#line 933
  if (pm) {
    {
#line 942
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 942
      goto case_exp;
    }
#line 950
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 950
      goto case_exp___0;
    }
#line 950
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 950
      goto case_exp___0;
    }
#line 941
    goto switch_break;
    case_exp: /* CIL Label */ 
#line 943
    if (v.type != 1) {
#line 944
      v.u.l = (zlong )v.u.d;
#line 945
      v.type = 1;
    }
#line 947
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    case_exp___1: /* CIL Label */ 
#line 951
    if (v.type != 2) {
#line 952
      v.u.d = (double )v.u.l;
#line 953
      v.type = 2;
    }
#line 955
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 958
  return (v);
}
}
#line 968 "/tmp/zsh-5.4.2/Src/math.c"
static mnumber dummy  ;
#line 963 "/tmp/zsh-5.4.2/Src/math.c"
static mnumber callmathfunc(char *o ) 
{ 
  MathFunc f ;
  char *a ;
  char *n ;
  char *tmp ;
  size_t tmp___0 ;
  mnumber tmp___1 ;
  int argc ;
  mnumber *argv ;
  mnumber *q ;
  mnumber marg___0 ;
  LinkList l ;
  LinkList tmp___2 ;
  LinkNode node ;
  char *tmp___3 ;
  char *str ;
  char buf___7[(int )(sizeof(zlong ) * 8UL + 4UL)] ;
  void *tmp___4 ;
  char *shfnam ;
  char *tmp___5 ;
  Shfunc shfunc ;
  Shfunc tmp___6 ;
  void *tmp___7 ;
  mnumber *tmp___8 ;
  mnumber tmp___9 ;

  {
  {
#line 970
  a = dupstring((char const   *)o);
#line 970
  n = a;
  }
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 972
    if (! ((int )*a != 40)) {
#line 972
      goto while_break;
    }
#line 973
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 974
  tmp = a;
#line 974
  a ++;
#line 974
  *tmp = (char )'\000';
#line 975
  tmp___0 = strlen((char const   *)a);
#line 975
  *(a + (tmp___0 - 1UL)) = (char )'\000';
#line 977
  f = getmathfunc((char const   *)n, 1);
  }
#line 977
  if (f) {
#line 978
    if ((f->flags & 5) == 1) {
      {
#line 979
      tmp___1 = (*(f->sfunc))(n, a, f->funcid);
      }
#line 979
      return (tmp___1);
    } else {
      {
#line 981
      argc = 0;
#line 982
      argv = (mnumber *)((void *)0);
#line 983
      tmp___2 = newlinklist();
#line 983
      l = tmp___2;
      }
#line 986
      if (f->flags & 4) {
        {
#line 988
        insertlinknode(l, l->list.last, (void *)n);
        }
      }
#line 991
      if (f->flags & 1) {
#line 992
        if (! *a) {
          {
#line 993
          tmp___3 = dupstring("");
#line 993
          insertlinknode(l, l->list.last, (void *)tmp___3);
#line 994
          argc ++;
          }
        }
      } else {
        {
#line 997
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 997
          if (! ((int )typtab[(unsigned char )*a] & (1 << 2))) {
#line 997
            goto while_break___0;
          }
#line 998
          a ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 1000
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1000
        if (! *a) {
#line 1000
          goto while_break___1;
        }
#line 1001
        if (*a) {
#line 1002
          argc ++;
#line 1003
          if (f->flags & 4) {
#line 1006
            if (f->flags & 1) {
              {
#line 1007
              str = dupstring((char const   *)a);
#line 1008
              a = (char *)"";
              }
            } else {
              {
#line 1010
              marg___0 = mathevall(a, (enum prec_type )1, & a);
              }
#line 1011
              if (marg___0.type & 2) {
                {
#line 1013
                str = convfloat(marg___0.u.d, 0, 0, (FILE *)((void *)0));
                }
              } else {
                {
#line 1016
                convbase(buf___7, marg___0.u.l, 10);
#line 1017
                str = dupstring((char const   *)(buf___7));
                }
              }
            }
            {
#line 1020
            insertlinknode(l, l->list.last, (void *)str);
            }
          } else {
            {
#line 1022
            tmp___4 = zhalloc(sizeof(mnumber ));
#line 1022
            q = (mnumber *)tmp___4;
#line 1023
            *q = mathevall(a, (enum prec_type )1, & a);
#line 1024
            insertlinknode(l, l->list.last, (void *)q);
            }
          }
#line 1026
          if (errflag) {
#line 1027
            goto while_break___1;
          } else
#line 1026
          if (mtok != 43) {
#line 1027
            goto while_break___1;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1030
      if (*a) {
#line 1030
        if (! errflag) {
          {
#line 1031
          zerr("bad math expression: illegal character: %c", (int )*a);
          }
        }
      }
#line 1032
      if (! errflag) {
#line 1033
        if (argc >= f->minargs) {
#line 1033
          if (f->maxargs < 0) {
#line 1033
            goto _L;
          } else
#line 1033
          if (argc <= f->maxargs) {
            _L: /* CIL Label */ 
#line 1035
            if (f->flags & 4) {
#line 1036
              if (f->module) {
#line 1036
                tmp___5 = f->module;
              } else {
#line 1036
                tmp___5 = n;
              }
              {
#line 1036
              shfnam = tmp___5;
#line 1037
              tmp___6 = getshfunc(shfnam);
#line 1037
              shfunc = tmp___6;
              }
#line 1038
              if (! shfunc) {
                {
#line 1039
                zerr("no such function: %s", shfnam);
                }
              } else {
                {
#line 1041
                doshfunc(shfunc, l, 1);
                }
#line 1042
                return (lastmathval);
              }
            } else {
#line 1045
              if (argc) {
                {
#line 1046
                tmp___7 = zhalloc((unsigned long )argc * sizeof(mnumber ));
#line 1046
                argv = (mnumber *)tmp___7;
#line 1046
                q = argv;
#line 1048
                node = l->list.first;
                }
                {
#line 1048
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 1048
                  if (! node) {
#line 1048
                    goto while_break___2;
                  }
#line 1049
                  tmp___8 = q;
#line 1049
                  q ++;
#line 1049
                  *tmp___8 = *((mnumber *)node->dat);
#line 1048
                  node = node->next;
                }
                while_break___2: /* CIL Label */ ;
                }
              }
              {
#line 1051
              tmp___9 = (*(f->nfunc))(n, argc, argv, f->funcid);
              }
#line 1051
              return (tmp___9);
            }
          } else {
            {
#line 1054
            zerr("wrong number of arguments: %s", o);
            }
          }
        } else {
          {
#line 1054
          zerr("wrong number of arguments: %s", o);
          }
        }
      }
    }
  } else {
    {
#line 1058
    zerr("unknown function: %s", n);
    }
  }
#line 1061
  dummy.type = 1;
#line 1062
  dummy.u.l = (zlong )0;
#line 1064
  return (dummy);
}
}
#line 1068 "/tmp/zsh-5.4.2/Src/math.c"
static int notzero(mnumber a ) 
{ 
  int tmp ;

  {
#line 1071
  if (a.type & 1) {
#line 1071
    tmp = a.u.l == 0L;
  } else {
#line 1071
    tmp = a.u.d == 0.0;
  }
#line 1071
  if (tmp) {
    {
#line 1072
    zerr("division by zero");
    }
#line 1073
    return (0);
  }
#line 1075
  return (1);
}
}
#line 1081 "/tmp/zsh-5.4.2/Src/math.c"
void op(int what ) 
{ 
  mnumber a ;
  mnumber b ;
  mnumber c ;
  mnumber *spval ;
  int tp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  zlong tmp___10 ;
  int tmp___11 ;
  double tst ;
  struct mathvalue *mvp ;
  mnumber tmp___13 ;
  double tmp___14 ;

  {
#line 1085
  tp = type[what];
#line 1087
  if (errflag) {
#line 1088
    return;
  }
#line 1089
  if (sp < 0) {
    {
#line 1090
    zerr("bad math expression: stack empty");
    }
#line 1091
    return;
  }
#line 1094
  if (tp & 124) {
    {
#line 1097
    b = pop(0);
#line 1098
    a = pop(what == 29);
    }
#line 1099
    if (errflag) {
#line 1100
      return;
    }
#line 1102
    if (tp & 80) {
#line 1104
      if (a.type & 2) {
#line 1105
        a.type = 1;
#line 1106
        a.u.l = (zlong )a.u.d;
      }
#line 1108
      if (b.type & 2) {
#line 1109
        b.type = 1;
#line 1110
        b.u.l = (zlong )b.u.d;
      }
    } else
#line 1112
    if (a.type != b.type) {
#line 1112
      if (what != 43) {
#line 1112
        if (a.type != 4) {
#line 1112
          goto _L;
        } else
#line 1112
        if (what != 29) {
          _L: /* CIL Label */ 
#line 1123
          if (a.type & 1) {
#line 1124
            a.type = 2;
#line 1125
            a.u.d = (double )a.u.l;
          }
#line 1127
          if (b.type & 1) {
#line 1128
            b.type = 2;
#line 1129
            b.u.d = (double )b.u.l;
          }
        }
      }
    }
#line 1133
    if (noeval) {
#line 1134
      c.type = 1;
#line 1135
      c.u.l = (zlong )0;
    } else {
#line 1141
      if (tp & 8) {
#line 1141
        c.type = 1;
      } else {
#line 1141
        c.type = a.type;
      }
      {
#line 1145
      if (what == 35) {
#line 1145
        goto case_35;
      }
#line 1145
      if (what == 8) {
#line 1145
        goto case_35;
      }
#line 1149
      if (what == 36) {
#line 1149
        goto case_36;
      }
#line 1149
      if (what == 9) {
#line 1149
        goto case_36;
      }
#line 1153
      if (what == 37) {
#line 1153
        goto case_37;
      }
#line 1153
      if (what == 10) {
#line 1153
        goto case_37;
      }
#line 1157
      if (what == 32) {
#line 1157
        goto case_32;
      }
#line 1157
      if (what == 11) {
#line 1157
        goto case_32;
      }
#line 1164
      if (what == 33) {
#line 1164
        goto case_33;
      }
#line 1164
      if (what == 12) {
#line 1164
        goto case_33;
      }
#line 1185
      if (what == 34) {
#line 1185
        goto case_34;
      }
#line 1185
      if (what == 13) {
#line 1185
        goto case_34;
      }
#line 1201
      if (what == 30) {
#line 1201
        goto case_30;
      }
#line 1201
      if (what == 14) {
#line 1201
        goto case_30;
      }
#line 1208
      if (what == 31) {
#line 1208
        goto case_31;
      }
#line 1208
      if (what == 15) {
#line 1208
        goto case_31;
      }
#line 1215
      if (what == 38) {
#line 1215
        goto case_38;
      }
#line 1215
      if (what == 16) {
#line 1215
        goto case_38;
      }
#line 1219
      if (what == 39) {
#line 1219
        goto case_39;
      }
#line 1219
      if (what == 17) {
#line 1219
        goto case_39;
      }
#line 1222
      if (what == 18) {
#line 1222
        goto case_18;
      }
#line 1226
      if (what == 19) {
#line 1226
        goto case_19;
      }
#line 1230
      if (what == 20) {
#line 1230
        goto case_20;
      }
#line 1234
      if (what == 21) {
#line 1234
        goto case_21;
      }
#line 1238
      if (what == 22) {
#line 1238
        goto case_22;
      }
#line 1242
      if (what == 23) {
#line 1242
        goto case_23;
      }
#line 1247
      if (what == 40) {
#line 1247
        goto case_40;
      }
#line 1247
      if (what == 24) {
#line 1247
        goto case_40;
      }
#line 1251
      if (what == 41) {
#line 1251
        goto case_41;
      }
#line 1251
      if (what == 25) {
#line 1251
        goto case_41;
      }
#line 1255
      if (what == 42) {
#line 1255
        goto case_42;
      }
#line 1255
      if (what == 26) {
#line 1255
        goto case_42;
      }
#line 1258
      if (what == 43) {
#line 1258
        goto case_43;
      }
#line 1262
      if (what == 51) {
#line 1262
        goto case_51;
      }
#line 1262
      if (what == 49) {
#line 1262
        goto case_51;
      }
#line 1285
      if (what == 29) {
#line 1285
        goto case_29;
      }
#line 1143
      goto switch_break;
      case_35: /* CIL Label */ 
      case_8: /* CIL Label */ 
#line 1146
      c.u.l = a.u.l & b.u.l;
#line 1147
      goto switch_break;
      case_36: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 1150
      c.u.l = a.u.l ^ b.u.l;
#line 1151
      goto switch_break;
      case_37: /* CIL Label */ 
      case_10: /* CIL Label */ 
#line 1154
      c.u.l = a.u.l | b.u.l;
#line 1155
      goto switch_break;
      case_32: /* CIL Label */ 
      case_11: /* CIL Label */ 
#line 1158
      if (c.type == 2) {
#line 1159
        c.u.d = a.u.d * b.u.d;
      } else {
#line 1161
        c.u.l = a.u.l * b.u.l;
      }
#line 1162
      goto switch_break;
      case_33: /* CIL Label */ 
      case_12: /* CIL Label */ 
      {
#line 1165
      tmp = notzero(b);
      }
#line 1165
      if (! tmp) {
#line 1166
        return;
      }
#line 1167
      if (c.type == 2) {
#line 1168
        c.u.d = a.u.d / b.u.d;
      } else
#line 1178
      if (b.u.l == -1L) {
#line 1179
        c.u.l = - a.u.l;
      } else {
#line 1181
        c.u.l = a.u.l / b.u.l;
      }
#line 1183
      goto switch_break;
      case_34: /* CIL Label */ 
      case_13: /* CIL Label */ 
      {
#line 1186
      tmp___0 = notzero(b);
      }
#line 1186
      if (! tmp___0) {
#line 1187
        return;
      }
#line 1193
      if (c.type == 2) {
        {
#line 1194
        c.u.d = fmod(a.u.d, b.u.d);
        }
      } else
#line 1195
      if (b.u.l == -1L) {
#line 1196
        c.u.l = (zlong )0;
      } else {
#line 1198
        c.u.l = a.u.l % b.u.l;
      }
#line 1199
      goto switch_break;
      case_30: /* CIL Label */ 
      case_14: /* CIL Label */ 
#line 1202
      if (c.type == 2) {
#line 1203
        c.u.d = a.u.d + b.u.d;
      } else {
#line 1205
        c.u.l = a.u.l + b.u.l;
      }
#line 1206
      goto switch_break;
      case_31: /* CIL Label */ 
      case_15: /* CIL Label */ 
#line 1209
      if (c.type == 2) {
#line 1210
        c.u.d = a.u.d - b.u.d;
      } else {
#line 1212
        c.u.l = a.u.l - b.u.l;
      }
#line 1213
      goto switch_break;
      case_38: /* CIL Label */ 
      case_16: /* CIL Label */ 
#line 1216
      c.u.l = a.u.l << b.u.l;
#line 1217
      goto switch_break;
      case_39: /* CIL Label */ 
      case_17: /* CIL Label */ 
#line 1220
      c.u.l = a.u.l >> b.u.l;
#line 1221
      goto switch_break;
      case_18: /* CIL Label */ 
#line 1223
      if (a.type == 2) {
#line 1223
        tmp___1 = a.u.d < b.u.d;
      } else {
#line 1223
        tmp___1 = a.u.l < b.u.l;
      }
#line 1223
      c.u.l = (zlong )tmp___1;
#line 1225
      goto switch_break;
      case_19: /* CIL Label */ 
#line 1227
      if (a.type == 2) {
#line 1227
        tmp___2 = a.u.d <= b.u.d;
      } else {
#line 1227
        tmp___2 = a.u.l <= b.u.l;
      }
#line 1227
      c.u.l = (zlong )tmp___2;
#line 1229
      goto switch_break;
      case_20: /* CIL Label */ 
#line 1231
      if (a.type == 2) {
#line 1231
        tmp___3 = a.u.d > b.u.d;
      } else {
#line 1231
        tmp___3 = a.u.l > b.u.l;
      }
#line 1231
      c.u.l = (zlong )tmp___3;
#line 1233
      goto switch_break;
      case_21: /* CIL Label */ 
#line 1235
      if (a.type == 2) {
#line 1235
        tmp___4 = a.u.d >= b.u.d;
      } else {
#line 1235
        tmp___4 = a.u.l >= b.u.l;
      }
#line 1235
      c.u.l = (zlong )tmp___4;
#line 1237
      goto switch_break;
      case_22: /* CIL Label */ 
#line 1239
      if (a.type == 2) {
#line 1239
        tmp___5 = a.u.d == b.u.d;
      } else {
#line 1239
        tmp___5 = a.u.l == b.u.l;
      }
#line 1239
      c.u.l = (zlong )tmp___5;
#line 1241
      goto switch_break;
      case_23: /* CIL Label */ 
#line 1243
      if (a.type == 2) {
#line 1243
        tmp___6 = a.u.d != b.u.d;
      } else {
#line 1243
        tmp___6 = a.u.l != b.u.l;
      }
#line 1243
      c.u.l = (zlong )tmp___6;
#line 1245
      goto switch_break;
      case_40: /* CIL Label */ 
      case_24: /* CIL Label */ 
#line 1248
      if (a.u.l) {
#line 1248
        if (b.u.l) {
#line 1248
          tmp___7 = 1;
        } else {
#line 1248
          tmp___7 = 0;
        }
      } else {
#line 1248
        tmp___7 = 0;
      }
#line 1248
      c.u.l = (zlong )tmp___7;
#line 1249
      goto switch_break;
      case_41: /* CIL Label */ 
      case_25: /* CIL Label */ 
#line 1252
      if (a.u.l) {
#line 1252
        tmp___8 = 1;
      } else
#line 1252
      if (b.u.l) {
#line 1252
        tmp___8 = 1;
      } else {
#line 1252
        tmp___8 = 0;
      }
#line 1252
      c.u.l = (zlong )tmp___8;
#line 1253
      goto switch_break;
      case_42: /* CIL Label */ 
      case_26: /* CIL Label */ 
#line 1256
      if (a.u.l) {
#line 1256
        if (! b.u.l) {
#line 1256
          tmp___9 = 1;
        } else {
#line 1256
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1256
      if (! a.u.l) {
#line 1256
        if (b.u.l) {
#line 1256
          tmp___9 = 1;
        } else {
#line 1256
          tmp___9 = 0;
        }
      } else {
#line 1256
        tmp___9 = 0;
      }
#line 1256
      c.u.l = (zlong )tmp___9;
#line 1257
      goto switch_break;
      case_43: /* CIL Label */ 
#line 1259
      c = b;
#line 1260
      goto switch_break;
      case_51: /* CIL Label */ 
      case_49: /* CIL Label */ 
#line 1263
      if (c.type == 1) {
#line 1263
        if (b.u.l < 0L) {
#line 1265
          c.type = 2;
#line 1265
          b.type = c.type;
#line 1265
          a.type = b.type;
#line 1266
          a.u.d = (double )a.u.l;
#line 1267
          b.u.d = (double )b.u.l;
        }
      }
#line 1269
      if (c.type == 1) {
#line 1270
        c.u.l = (zlong )1;
        {
#line 1270
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1270
          tmp___10 = b.u.l;
#line 1270
          (b.u.l) --;
#line 1270
          if (! tmp___10) {
#line 1270
            goto while_break;
          }
#line 1270
          c.u.l *= a.u.l;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 1272
        if (b.u.d <= (double )0) {
          {
#line 1272
          tmp___11 = notzero(a);
          }
#line 1272
          if (! tmp___11) {
#line 1273
            return;
          }
        }
#line 1274
        if (a.u.d < (double )0) {
#line 1276
          tst = (double )((zlong )b.u.d);
#line 1277
          if (tst != b.u.d) {
            {
#line 1278
            zerr("bad math expression: imaginary power");
            }
#line 1279
            return;
          }
        }
        {
#line 1282
        c.u.d = pow(a.u.d, b.u.d);
        }
      }
#line 1284
      goto switch_break;
      case_29: /* CIL Label */ 
#line 1286
      c = b;
#line 1287
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 1290
    if (tp & 96) {
      {
#line 1291
      mvp = (stack + sp) + 1;
#line 1292
      c = setmathvar(mvp, c);
#line 1293
      push(c, mvp->lval, 0);
      }
    } else {
      {
#line 1295
      push(c, (char *)((void *)0), 0);
      }
    }
#line 1296
    return;
  }
#line 1299
  spval = & (stack + sp)->val;
#line 1300
  if ((stack + sp)->val.type == 4) {
    {
#line 1301
    *spval = getmathparam(stack + sp);
    }
  }
  {
#line 1303
  if (what == 2) {
#line 1303
    goto case_2;
  }
#line 1312
  if (what == 3) {
#line 1312
    goto case_3;
  }
#line 1321
  if (what == 4) {
#line 1321
    goto case_4;
  }
#line 1329
  if (what == 5) {
#line 1329
    goto case_5;
  }
#line 1337
  if (what == 6) {
#line 1337
    goto case_6;
  }
#line 1341
  if (what == 7) {
#line 1341
    goto case_7;
  }
#line 1349
  if (what == 27) {
#line 1349
    goto case_27;
  }
#line 1359
  if (what == 28) {
#line 1359
    goto case_28;
  }
#line 1362
  if (what == 45) {
#line 1362
    goto case_45;
  }
#line 1369
  if (what == 46) {
#line 1369
    goto case_46;
  }
#line 1376
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1304
  if (spval->type & 2) {
#line 1305
    spval->u.l = (zlong )(! spval->u.d);
#line 1306
    spval->type = 1;
  } else {
#line 1308
    spval->u.l = (zlong )(! spval->u.l);
  }
#line 1309
  (stack + sp)->lval = (char *)((void *)0);
#line 1310
  (stack + sp)->pval = (Value )((void *)0);
#line 1311
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 1313
  if (spval->type & 2) {
#line 1314
    spval->u.l = ~ ((zlong )spval->u.d);
#line 1315
    spval->type = 1;
  } else {
#line 1317
    spval->u.l = ~ spval->u.l;
  }
#line 1318
  (stack + sp)->lval = (char *)((void *)0);
#line 1319
  (stack + sp)->pval = (Value )((void *)0);
#line 1320
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 1322
  a = *spval;
#line 1323
  if (spval->type & 2) {
#line 1324
    a.u.d += (double )1;
  } else {
#line 1326
    (a.u.l) ++;
  }
  {
#line 1327
  setmathvar(stack + sp, a);
  }
#line 1328
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 1330
  a = *spval;
#line 1331
  if (spval->type & 2) {
#line 1332
    a.u.d -= (double )1;
  } else {
#line 1334
    (a.u.l) --;
  }
  {
#line 1335
  setmathvar(stack + sp, a);
  }
#line 1336
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 1338
  (stack + sp)->lval = (char *)((void *)0);
#line 1339
  (stack + sp)->pval = (Value )((void *)0);
#line 1340
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 1342
  if (spval->type & 2) {
#line 1343
    spval->u.d = - spval->u.d;
  } else {
#line 1345
    spval->u.l = - spval->u.l;
  }
#line 1346
  (stack + sp)->lval = (char *)((void *)0);
#line 1347
  (stack + sp)->pval = (Value )((void *)0);
#line 1348
  goto switch_break___0;
  case_27: /* CIL Label */ 
  {
#line 1351
  c = pop(0);
#line 1352
  b = pop(0);
#line 1353
  a = pop(0);
  }
#line 1354
  if (errflag) {
#line 1355
    return;
  }
#line 1357
  if (a.type & 2) {
#line 1357
    tmp___14 = a.u.d;
  } else {
#line 1357
    tmp___14 = (double )a.u.l;
  }
#line 1357
  if (tmp___14) {
#line 1357
    tmp___13 = b;
  } else {
#line 1357
    tmp___13 = c;
  }
  {
#line 1357
  push(tmp___13, (char *)((void *)0), 0);
  }
#line 1358
  goto switch_break___0;
  case_28: /* CIL Label */ 
  {
#line 1360
  zerr("bad math expression: \':\' without \'?\'");
  }
#line 1361
  goto switch_break___0;
  case_45: /* CIL Label */ 
#line 1363
  if (spval->type & 2) {
#line 1364
    spval->u.d += (double )1;
  } else {
#line 1366
    (spval->u.l) ++;
  }
  {
#line 1367
  setmathvar(stack + sp, *spval);
  }
#line 1368
  goto switch_break___0;
  case_46: /* CIL Label */ 
#line 1370
  if (spval->type & 2) {
#line 1371
    spval->u.d -= (double )1;
  } else {
#line 1373
    (spval->u.l) --;
  }
  {
#line 1374
  setmathvar(stack + sp, *spval);
  }
#line 1375
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 1377
  zerr("bad math expression: out of integers");
  }
#line 1378
  return;
  switch_break___0: /* CIL Label */ ;
  }
#line 1380
  return;
}
}
#line 1384 "/tmp/zsh-5.4.2/Src/math.c"
static void bop(int tk ) 
{ 
  mnumber *spval ;
  int tst ;

  {
#line 1387
  spval = & (stack + sp)->val;
#line 1390
  if ((stack + sp)->val.type == 4) {
    {
#line 1391
    *spval = getmathparam(stack + sp);
    }
  }
#line 1392
  if (spval->type & 2) {
#line 1392
    tst = (int )((zlong )spval->u.d);
  } else {
#line 1392
    tst = (int )spval->u.l;
  }
  {
#line 1396
  if (tk == 40) {
#line 1396
    goto case_40;
  }
#line 1396
  if (tk == 24) {
#line 1396
    goto case_40;
  }
#line 1401
  if (tk == 41) {
#line 1401
    goto case_41;
  }
#line 1401
  if (tk == 25) {
#line 1401
    goto case_41;
  }
#line 1394
  goto switch_break;
  case_40: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 1397
  if (! tst) {
#line 1398
    noeval ++;
  }
#line 1399
  goto switch_break;
  case_41: /* CIL Label */ 
  case_25: /* CIL Label */ 
#line 1402
  if (tst) {
#line 1403
    noeval ++;
  }
#line 1404
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1406
  return;
}
}
#line 1410 "/tmp/zsh-5.4.2/Src/math.c"
mnumber matheval(char *s ) 
{ 
  char *junk ;
  mnumber x ;
  int xmtok ;

  {
#line 1415
  xmtok = mtok;
#line 1417
  if (! mlevel) {
#line 1418
    outputunderscore = 0;
#line 1418
    outputradix = outputunderscore;
  }
#line 1420
  if ((int )*s == -95) {
#line 1421
    s ++;
  }
#line 1422
  if (! *s) {
#line 1423
    x.type = 1;
#line 1424
    x.u.l = (zlong )0;
#line 1425
    return (x);
  }
  {
#line 1427
  x = mathevall(s, (enum prec_type )0, & junk);
#line 1428
  mtok = xmtok;
  }
#line 1429
  if (*junk) {
    {
#line 1430
    zerr("bad math expression: illegal character: %c", (int )*junk);
    }
  }
#line 1431
  return (x);
}
}
#line 1435 "/tmp/zsh-5.4.2/Src/math.c"
zlong mathevali(char *s ) 
{ 
  mnumber x ;
  mnumber tmp ;
  zlong tmp___0 ;

  {
  {
#line 1438
  tmp = matheval(s);
#line 1438
  x = tmp;
  }
#line 1439
  if (x.type & 2) {
#line 1439
    tmp___0 = (zlong )x.u.d;
  } else {
#line 1439
    tmp___0 = x.u.l;
  }
#line 1439
  return (tmp___0);
}
}
#line 1444 "/tmp/zsh-5.4.2/Src/math.c"
zlong mathevalarg(char *s , char **ss ) 
{ 
  mnumber x ;
  int xmtok ;
  zlong tmp ;

  {
#line 1448
  xmtok = mtok;
#line 1459
  if ((int )*s == -95) {
#line 1460
    s ++;
  }
#line 1461
  if (! *s) {
    {
#line 1462
    zerr("bad math expression: empty string");
    }
#line 1463
    return ((zlong )0);
  }
  {
#line 1465
  x = mathevall(s, (enum prec_type )1, ss);
  }
#line 1466
  if (mtok == 43) {
#line 1467
    (*ss) --;
  }
#line 1468
  mtok = xmtok;
#line 1469
  if (x.type & 2) {
#line 1469
    tmp = (zlong )x.u.d;
  } else {
#line 1469
    tmp = x.u.l;
  }
#line 1469
  return (tmp);
}
}
#line 1478 "/tmp/zsh-5.4.2/Src/math.c"
static void checkunary(int mtokc , char *mptr ) 
{ 
  int errmsg ;
  int tp ;
  int len ;
  int over ;
  char *errtype ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 1481
  errmsg = 0;
#line 1482
  tp = type[mtokc];
#line 1483
  if (tp & 252) {
#line 1484
    if (unary) {
#line 1485
      errmsg = 1;
    }
  } else
#line 1487
  if (! unary) {
#line 1488
    errmsg = 2;
  }
#line 1490
  if (errmsg) {
#line 1491
    over = 0;
#line 1492
    if (errmsg == 2) {
#line 1492
      tmp = "operator";
    } else {
#line 1492
      tmp = "operand";
    }
#line 1492
    errtype = (char *)tmp;
    {
#line 1493
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1493
      if (! ((int )typtab[(unsigned char )*mptr] & (1 << 3))) {
#line 1493
        goto while_break;
      }
#line 1494
      mptr ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1495
    len = ztrlen((char const   *)mptr);
    }
#line 1496
    if (len > 10) {
#line 1497
      len = 10;
#line 1498
      over = 1;
    }
#line 1500
    if (! *mptr) {
      {
#line 1501
      zerr("bad math expression: %s expected at end of string", errtype);
      }
    } else {
#line 1504
      if (over) {
#line 1504
        tmp___0 = "...";
      } else {
#line 1504
        tmp___0 = "";
      }
      {
#line 1504
      zerr("bad math expression: %s expected at `%l%s\'", errtype, mptr, len, tmp___0);
      }
    }
  }
#line 1507
  unary = ! (tp & 256);
#line 1508
  return;
}
}
#line 1513 "/tmp/zsh-5.4.2/Src/math.c"
static void mathparse(int pc ) 
{ 
  zlong q ;
  int otok ;
  int onoeval ;
  char *optr ;
  mnumber tmp ;
  mnumber tmp___0 ;
  mnumber tmp___1 ;
  mnumber tmp___2 ;
  int tmp___3 ;

  {
#line 1518
  optr = ptr;
#line 1520
  if (errflag) {
#line 1521
    return;
  }
  {
#line 1522
  mtok = zzlex();
  }
#line 1524
  if (pc == *(prec + 43) + 1) {
#line 1524
    if (mtok == 44) {
#line 1525
      return;
    }
  }
  {
#line 1526
  checkunary(mtok, optr);
  }
  {
#line 1527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1527
    if (! (*(prec + mtok) <= pc)) {
#line 1527
      goto while_break;
    }
#line 1528
    if (errflag) {
#line 1529
      return;
    }
    {
#line 1531
    if (mtok == 47) {
#line 1531
      goto case_47;
    }
#line 1534
    if (mtok == 48) {
#line 1534
      goto case_48;
    }
#line 1537
    if (mtok == 50) {
#line 1537
      goto case_50;
    }
#line 1540
    if (mtok == 52) {
#line 1540
      goto case_52;
    }
#line 1543
    if (mtok == 0) {
#line 1543
      goto case_0;
    }
#line 1551
    if (mtok == 27) {
#line 1551
      goto case_27;
    }
#line 1575
    goto switch_default;
    case_47: /* CIL Label */ 
    {
#line 1532
    push(yyval, (char *)((void *)0), 0);
    }
#line 1533
    goto switch_break;
    case_48: /* CIL Label */ 
    {
#line 1535
    push(zero_mnumber, yylval, ! noeval);
    }
#line 1536
    goto switch_break;
    case_50: /* CIL Label */ 
#line 1538
    if (noeval) {
#line 1538
      tmp___0 = zero_mnumber;
    } else {
      {
#line 1538
      tmp = getcvar(yylval);
#line 1538
      tmp___0 = tmp;
      }
    }
    {
#line 1538
    push(tmp___0, yylval, 0);
    }
#line 1539
    goto switch_break;
    case_52: /* CIL Label */ 
#line 1541
    if (noeval) {
#line 1541
      tmp___2 = zero_mnumber;
    } else {
      {
#line 1541
      tmp___1 = callmathfunc(yylval);
#line 1541
      tmp___2 = tmp___1;
      }
    }
    {
#line 1541
    push(tmp___2, yylval, 0);
    }
#line 1542
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1544
    mathparse(*(prec + 43) + 1);
    }
#line 1545
    if (mtok != 1) {
#line 1546
      if (! errflag) {
        {
#line 1547
        zerr("bad math expression: \')\' expected");
        }
      }
#line 1548
      return;
    }
#line 1550
    goto switch_break;
    case_27: /* CIL Label */ 
#line 1552
    if ((stack + sp)->val.type == 4) {
      {
#line 1553
      (stack + sp)->val = getmathparam(stack + sp);
      }
    }
#line 1554
    if ((stack + sp)->val.type == 2) {
#line 1554
      if ((stack + sp)->val.u.d == (double )0) {
#line 1554
        tmp___3 = 0;
      } else {
#line 1554
        tmp___3 = 1;
      }
#line 1554
      q = (zlong )tmp___3;
    } else {
#line 1554
      q = (stack + sp)->val.u.l;
    }
#line 1558
    if (! q) {
#line 1559
      noeval ++;
    }
    {
#line 1560
    mathparse(*(prec + 28) - 1);
    }
#line 1561
    if (! q) {
#line 1562
      noeval --;
    }
#line 1563
    if (mtok != 28) {
#line 1564
      if (! errflag) {
        {
#line 1565
        zerr("bad math expression: \':\' expected");
        }
      }
#line 1566
      return;
    }
#line 1568
    if (q) {
#line 1569
      noeval ++;
    }
    {
#line 1570
    mathparse(*(prec + 27));
    }
#line 1571
    if (q) {
#line 1572
      noeval --;
    }
    {
#line 1573
    op(27);
    }
#line 1574
    goto while_continue;
    switch_default: /* CIL Label */ 
#line 1576
    otok = mtok;
#line 1577
    onoeval = noeval;
#line 1578
    if ((type[otok] & 3) == 2) {
      {
#line 1579
      bop(otok);
      }
    }
    {
#line 1580
    mathparse(*(prec + otok) - ((type[otok] & 3) != 1));
#line 1581
    noeval = onoeval;
#line 1582
    op(otok);
    }
#line 1583
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1585
    optr = ptr;
#line 1586
    mtok = zzlex();
#line 1587
    checkunary(mtok, optr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1589
  return;
}
}
#line 534 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 265 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 564
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 33 "./builtin.epro"
LinkList bufstack ;
#line 6 "./exec.epro"
int this_noerrexit ;
#line 45
void execlist(Estate state , int dont_change_job , int exiting ) ;
#line 47
void quote_tokenized_output(char *str , FILE *file ) ;
#line 49
void execsubst(LinkList strs ) ;
#line 12 "./lex.epro"
int isfirstln ;
#line 11 "./linklist.epro"
void *getlinknode(LinkList list ) ;
#line 5 "./loop.epro"
int loops  ;
#line 6 "./loop.epro"
int contflag  ;
#line 7 "./loop.epro"
int breaks  ;
#line 8
int execfor(Estate state , int do_exec ) ;
#line 9
int execselect(Estate state , int do_exec  __attribute__((__unused__)) ) ;
#line 10
size_t selectlist(LinkList l , size_t start ) ;
#line 11
int execwhile(Estate state , int do_exec  __attribute__((__unused__)) ) ;
#line 12
int execrepeat(Estate state , int do_exec  __attribute__((__unused__)) ) ;
#line 13
int execif(Estate state , int do_exec ) ;
#line 14
int execcase(Estate state , int do_exec ) ;
#line 18
int exectry(Estate state , int do_exec ) ;
#line 49 "/tmp/zsh-5.4.2/Src/loop.c"
int execfor(Estate state , int do_exec ) 
{ 
  Wordcode end ;
  Wordcode loop___0 ;
  wordcode code ;
  int iscond ;
  int ctok ;
  int atok ;
  int last ;
  char *name ;
  char *str ;
  char *cond ;
  char *advance ;
  zlong val ;
  LinkList vars ;
  LinkList args ;
  int old_simple_pline ;
  char *tmp ;
  char *str2 ;
  char *tmp___0 ;
  Wordcode tmp___1 ;
  int htok ;
  Wordcode tmp___2 ;
  char **x ;
  char *tmp___3 ;
  LinkNode node ;
  int count ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 53
  code = *(state->pc + -1);
#line 54
  iscond = ((code >> 5) & 3U) == 2U;
#line 54
  ctok = 0;
#line 54
  atok = 0;
#line 55
  last = 0;
#line 56
  cond = (char *)((void *)0);
#line 56
  advance = (char *)((void *)0);
#line 57
  val = (zlong )0;
#line 58
  vars = (LinkList )((void *)0);
#line 58
  args = (LinkList )((void *)0);
#line 59
  old_simple_pline = simple_pline;
#line 62
  simple_pline = 1;
#line 64
  end = state->pc + ((code >> 5) >> 2);
#line 66
  if (iscond) {
    {
#line 67
    tmp = ecgetstr(state, 0, (int *)((void *)0));
#line 67
    str = dupstring((char const   *)tmp);
#line 68
    singsub(& str);
    }
#line 69
    if (opts[177]) {
      {
#line 70
      tmp___0 = dupstring((char const   *)str);
#line 70
      str2 = tmp___0;
#line 71
      untokenize(str2);
#line 72
      printprompt4();
#line 73
      fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)"%s\n",
              str2);
#line 74
      fflush(xtrerr);
      }
    }
#line 76
    if (! errflag) {
      {
#line 77
      matheval(str);
      }
    }
#line 79
    if (errflag) {
#line 80
      state->pc = end;
#line 81
      simple_pline = old_simple_pline;
#line 82
      return (1);
    }
    {
#line 84
    cond = ecgetstr(state, 0, & ctok);
#line 85
    advance = ecgetstr(state, 0, & atok);
    }
  } else {
    {
#line 87
    tmp___1 = state->pc;
#line 87
    (state->pc) ++;
#line 87
    vars = ecgetlist(state, (int )*tmp___1, 0, (int *)((void *)0));
    }
#line 89
    if (((code >> 5) & 3U) == 1U) {
      {
#line 90
      htok = 0;
#line 92
      tmp___2 = state->pc;
#line 92
      (state->pc) ++;
#line 92
      args = ecgetlist(state, (int )*tmp___2, 2, & htok);
      }
#line 92
      if (! args) {
#line 93
        state->pc = end;
#line 94
        simple_pline = old_simple_pline;
#line 95
        return (0);
      }
#line 97
      if (htok) {
        {
#line 98
        execsubst(args);
        }
#line 99
        if (errflag) {
#line 100
          state->pc = end;
#line 101
          simple_pline = old_simple_pline;
#line 102
          return (1);
        }
      }
    } else {
      {
#line 108
      args = newlinklist();
#line 109
      x = pparams;
      }
      {
#line 109
      while (1) {
        while_continue: /* CIL Label */ ;
#line 109
        if (! *x) {
#line 109
          goto while_break;
        }
        {
#line 110
        tmp___3 = dupstring((char const   *)*x);
#line 110
        insertlinknode(args, args->list.last, (void *)tmp___3);
#line 109
        x ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 114
  if (! args) {
#line 115
    lastval = (zlong )0;
  } else
#line 114
  if ((unsigned long )args->list.first == (unsigned long )((void *)0)) {
#line 115
    lastval = (zlong )0;
  }
  {
#line 117
  loops ++;
#line 118
  pushheap();
#line 119
  cmdpush(0);
#line 120
  loop___0 = state->pc;
  }
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (! last)) {
#line 121
      goto while_break___0;
    }
#line 122
    if (iscond) {
#line 123
      if (ctok) {
        {
#line 124
        str = dupstring((char const   *)cond);
#line 125
        singsub(& str);
        }
      } else {
#line 127
        str = cond;
      }
#line 128
      if (! errflag) {
        {
#line 129
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 129
          if (! ((int )typtab[(unsigned char )*str] & (1 << 2))) {
#line 129
            goto while_break___1;
          }
#line 130
          str ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 131
        if (*str) {
#line 132
          if (opts[177]) {
            {
#line 133
            printprompt4();
#line 134
            fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)"%s\n",
                    str);
#line 135
            fflush(xtrerr);
            }
          }
          {
#line 137
          val = mathevali(str);
          }
        } else {
#line 139
          val = (zlong )1;
        }
      }
#line 141
      if (errflag) {
#line 142
        if (breaks) {
#line 143
          breaks --;
        }
#line 144
        lastval = (zlong )1;
#line 145
        goto while_break___0;
      }
#line 147
      if (! val) {
#line 148
        goto while_break___0;
      }
    } else {
#line 151
      count = 0;
#line 152
      node = vars->list.first;
      {
#line 152
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 152
        if (! node) {
#line 152
          goto while_break___2;
        }
#line 154
        name = (char *)node->dat;
#line 155
        if (! args) {
#line 155
          goto _L;
        } else {
          {
#line 155
          tmp___4 = ugetnode(args);
#line 155
          str = (char *)tmp___4;
          }
#line 155
          if (! str) {
            _L: /* CIL Label */ 
#line 157
            if (count) {
#line 158
              str = (char *)"";
#line 159
              last = 1;
            } else {
#line 161
              goto while_break___2;
            }
          }
        }
#line 163
        if (opts[177]) {
          {
#line 164
          printprompt4();
#line 165
          fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)"%s=%s\n",
                  name, str);
#line 166
          fflush(xtrerr);
          }
        }
        {
#line 168
        tmp___5 = ztrdup((char const   *)str);
#line 168
        setsparam(name, tmp___5);
#line 169
        count ++;
#line 152
        node = node->next;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 171
      if (! count) {
#line 172
        goto while_break___0;
      }
    }
#line 174
    state->pc = loop___0;
#line 175
    if (do_exec) {
#line 175
      if (args) {
#line 175
        if ((unsigned long )args->list.first == (unsigned long )((void *)0)) {
#line 175
          tmp___6 = 1;
        } else {
#line 175
          tmp___6 = 0;
        }
      } else {
#line 175
        tmp___6 = 0;
      }
    } else {
#line 175
      tmp___6 = 0;
    }
    {
#line 175
    execlist(state, 1, tmp___6);
    }
#line 176
    if (breaks) {
#line 177
      breaks --;
#line 178
      if (breaks) {
#line 179
        goto while_break___0;
      } else
#line 178
      if (! contflag) {
#line 179
        goto while_break___0;
      }
#line 180
      contflag = 0;
    }
#line 182
    if (retflag) {
#line 183
      goto while_break___0;
    }
#line 184
    if (iscond) {
#line 184
      if (! errflag) {
#line 185
        if (atok) {
          {
#line 186
          str = dupstring((char const   *)advance);
#line 187
          singsub(& str);
          }
        } else {
#line 189
          str = advance;
        }
#line 190
        if (opts[177]) {
          {
#line 191
          printprompt4();
#line 192
          fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)"%s\n",
                  str);
#line 193
          fflush(xtrerr);
          }
        }
#line 195
        if (! errflag) {
          {
#line 196
          matheval(str);
          }
        }
      }
    }
#line 198
    if (errflag) {
#line 199
      if (breaks) {
#line 200
        breaks --;
      }
#line 201
      lastval = (zlong )1;
#line 202
      goto while_break___0;
    }
    {
#line 204
    freeheap();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 206
  popheap();
#line 207
  cmdpop();
#line 208
  loops --;
#line 209
  simple_pline = old_simple_pline;
#line 210
  state->pc = end;
#line 211
  this_noerrexit = 1;
  }
#line 212
  return ((int )lastval);
}
}
#line 216 "/tmp/zsh-5.4.2/Src/loop.c"
int execselect(Estate state , int do_exec  __attribute__((__unused__)) ) 
{ 
  Wordcode end ;
  Wordcode loop___0 ;
  wordcode code ;
  char *str ;
  char *s ;
  char *name ;
  LinkNode n ;
  int i ;
  int usezle ;
  FILE *inp ;
  size_t more ;
  LinkList args ;
  int old_simple_pline ;
  char **x ;
  char *tmp ;
  int htok ;
  Wordcode tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int oef ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 220
  code = *(state->pc + -1);
#line 227
  old_simple_pline = simple_pline;
#line 230
  simple_pline = 1;
#line 232
  end = state->pc + ((code >> 5) >> 2);
#line 233
  name = ecgetstr(state, 0, (int *)((void *)0));
  }
#line 235
  if (((code >> 5) & 1U) == 0U) {
    {
#line 238
    args = newlinklist();
#line 239
    x = pparams;
    }
    {
#line 239
    while (1) {
      while_continue: /* CIL Label */ ;
#line 239
      if (! *x) {
#line 239
        goto while_break;
      }
      {
#line 240
      tmp = dupstring((char const   *)*x);
#line 240
      insertlinknode(args, args->list.last, (void *)tmp);
#line 239
      x ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 242
    htok = 0;
#line 244
    tmp___0 = state->pc;
#line 244
    (state->pc) ++;
#line 244
    args = ecgetlist(state, (int )*tmp___0, 2, & htok);
    }
#line 244
    if (! args) {
#line 245
      state->pc = end;
#line 246
      simple_pline = old_simple_pline;
#line 247
      return (0);
    }
#line 249
    if (htok) {
      {
#line 250
      execsubst(args);
      }
#line 251
      if (errflag) {
#line 252
        state->pc = end;
#line 253
        simple_pline = old_simple_pline;
#line 254
        return (1);
      }
    }
  }
#line 258
  if (! args) {
#line 259
    state->pc = end;
#line 260
    simple_pline = old_simple_pline;
#line 261
    return (0);
  } else
#line 258
  if ((unsigned long )args->list.first == (unsigned long )((void *)0)) {
#line 259
    state->pc = end;
#line 260
    simple_pline = old_simple_pline;
#line 261
    return (0);
  }
  {
#line 263
  loops ++;
#line 265
  pushheap();
#line 266
  cmdpush(3);
  }
#line 267
  if (opts[93]) {
#line 267
    if (SHTTY != -1) {
#line 267
      if (opts[178]) {
#line 267
        tmp___1 = 1;
      } else {
#line 267
        tmp___1 = 0;
      }
    } else {
#line 267
      tmp___1 = 0;
    }
  } else {
#line 267
    tmp___1 = 0;
  }
#line 267
  usezle = tmp___1;
#line 268
  if (usezle) {
#line 268
    tmp___2 = SHTTY;
  } else {
#line 268
    tmp___2 = 0;
  }
  {
#line 268
  tmp___3 = dup(tmp___2);
#line 268
  inp = fdopen(tmp___3, "r");
#line 269
  more = selectlist(args, (size_t )0);
#line 270
  loop___0 = state->pc;
  }
  {
#line 271
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 272
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 273
      if ((unsigned long )bufstack->list.first == (unsigned long )((void *)0)) {
#line 274
        if (usezle) {
          {
#line 275
          oef = errflag;
#line 277
          isfirstln = 1;
#line 278
          str = zleentry(1, & prompt3, (void *)0, 0, 2);
          }
#line 280
          if (errflag) {
#line 281
            str = (char *)((void *)0);
          }
#line 283
          errflag = oef | (errflag & 2);
        } else {
          {
#line 285
          str = promptexpand(prompt3, 0, (char *)((void *)0), (char *)((void *)0),
                             (unsigned int *)((void *)0));
#line 286
          zputs((char const   *)str, stderr);
#line 287
          free((void *)str);
#line 288
          fflush(stderr);
#line 289
          tmp___4 = zhalloc((size_t )256);
#line 289
          str = fgets((char */* __restrict  */)tmp___4, 256, (FILE */* __restrict  */)inp);
          }
        }
      } else {
        {
#line 292
        tmp___5 = getlinknode(bufstack);
#line 292
        str = (char *)tmp___5;
        }
      }
#line 293
      if (! str) {
#line 293
        if (! errflag) {
          {
#line 294
          tmp___6 = ztrdup("");
#line 294
          setsparam((char *)"REPLY", tmp___6);
          }
        }
      }
#line 295
      if (! str) {
#line 295
        goto _L;
      } else
#line 295
      if (errflag) {
        _L: /* CIL Label */ 
#line 296
        if (breaks) {
#line 297
          breaks --;
        }
        {
#line 298
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 299
        fflush(stderr);
        }
#line 300
        goto done;
      }
      {
#line 302
      s = strchr((char const   *)str, '\n');
      }
#line 302
      if (s) {
#line 303
        *s = (char )'\000';
      }
#line 304
      if (*str) {
#line 305
        goto while_break___1;
      }
      {
#line 306
      more = selectlist(args, more);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 308
    tmp___7 = ztrdup((char const   *)str);
#line 308
    setsparam((char *)"REPLY", tmp___7);
#line 309
    i = atoi((char const   *)str);
    }
#line 310
    if (! i) {
#line 311
      str = (char *)"";
    } else {
#line 313
      i --;
#line 313
      n = args->list.first;
      {
#line 313
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 313
        if (n) {
#line 313
          if (! i) {
#line 313
            goto while_break___2;
          }
        } else {
#line 313
          goto while_break___2;
        }
#line 313
        n = n->next;
#line 313
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 314
      if (n) {
#line 315
        str = (char *)n->dat;
      } else {
#line 317
        str = (char *)"";
      }
    }
    {
#line 319
    tmp___8 = ztrdup((char const   *)str);
#line 319
    setsparam(name, tmp___8);
#line 320
    state->pc = loop___0;
#line 321
    execlist(state, 1, 0);
#line 322
    freeheap();
    }
#line 323
    if (breaks) {
#line 324
      breaks --;
#line 325
      if (breaks) {
#line 326
        goto while_break___0;
      } else
#line 325
      if (! contflag) {
#line 326
        goto while_break___0;
      }
#line 327
      contflag = 0;
    }
#line 329
    if (retflag) {
#line 330
      goto while_break___0;
    } else
#line 329
    if (errflag) {
#line 330
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  done: 
  {
#line 333
  cmdpop();
#line 334
  popheap();
#line 335
  fclose(inp);
#line 336
  loops --;
#line 337
  simple_pline = old_simple_pline;
#line 338
  state->pc = end;
#line 339
  this_noerrexit = 1;
  }
#line 340
  return ((int )lastval);
}
}
#line 346 "/tmp/zsh-5.4.2/Src/loop.c"
size_t selectlist(LinkList l , size_t start ) 
{ 
  size_t longest ;
  size_t fct ;
  size_t fw ;
  size_t colsz ;
  size_t t0 ;
  size_t t1 ;
  size_t ct ;
  char **arr ;
  char **ap ;
  size_t tmp ;
  size_t t2 ;
  size_t tmp___0 ;
  int t3 ;
  size_t tmp___1 ;

  {
  {
#line 349
  longest = (size_t )1;
#line 349
  fw = (size_t )0;
#line 352
  zleentry(3);
#line 353
  arr = hlinklist2array(l, 0);
#line 354
  ap = arr;
  }
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! *ap) {
#line 354
      goto while_break;
    }
    {
#line 355
    tmp = strlen((char const   *)*ap);
    }
#line 355
    if (tmp > longest) {
      {
#line 356
      longest = strlen((char const   *)*ap);
      }
    }
#line 354
    ap ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  ct = (size_t )(ap - arr);
#line 357
  t0 = ct;
#line 358
  longest ++;
  {
#line 359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 359
    if (! t0) {
#line 359
      goto while_break___0;
    }
#line 360
    t0 /= 10UL;
#line 360
    longest ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 362
  fct = (size_t )(zterm_columns - 1L) / (longest + 3UL);
#line 363
  if (fct == 0UL) {
#line 364
    fct = (size_t )1;
  } else {
#line 366
    fw = (size_t )(zterm_columns - 1L) / fct;
  }
#line 367
  colsz = ((ct + fct) - 1UL) / fct;
#line 368
  t1 = start;
  {
#line 368
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 368
    if (t1 != colsz) {
#line 368
      if (! (t1 - start < (size_t )(zterm_lines - 2L))) {
#line 368
        goto while_break___1;
      }
    } else {
#line 368
      goto while_break___1;
    }
#line 369
    ap = arr + t1;
    {
#line 370
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 371
      tmp___0 = strlen((char const   *)*ap);
#line 371
      t2 = tmp___0 + 2UL;
#line 374
      t3 = (int )((ap - arr) + 1L);
#line 374
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d) %s",
              t3, *ap);
      }
      {
#line 375
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 375
        if (! t3) {
#line 375
          goto while_break___3;
        }
#line 376
        t2 ++;
#line 376
        t3 /= 10;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 377
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 377
        if (! (t2 < fw)) {
#line 377
          goto while_break___4;
        }
        {
#line 378
        fputc(' ', stderr);
#line 377
        t2 ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 379
      t0 = colsz;
      {
#line 379
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 379
        if (t0) {
#line 379
          if (! *ap) {
#line 379
            goto while_break___5;
          }
        } else {
#line 379
          goto while_break___5;
        }
#line 379
        t0 --;
#line 379
        ap ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 370
      if (! *ap) {
#line 370
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 382
    fputc('\n', stderr);
#line 368
    t1 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 394
  fflush(stderr);
  }
#line 396
  if (t1 < colsz) {
#line 396
    tmp___1 = t1;
  } else {
#line 396
    tmp___1 = (size_t )0;
  }
#line 396
  return (tmp___1);
}
}
#line 400 "/tmp/zsh-5.4.2/Src/loop.c"
int execwhile(Estate state , int do_exec  __attribute__((__unused__)) ) 
{ 
  Wordcode end ;
  Wordcode loop___0 ;
  wordcode code ;
  int olderrexit ;
  int oldval ;
  int isuntil ;
  int old_simple_pline ;
  int tmp ;

  {
  {
#line 404
  code = *(state->pc + -1);
#line 405
  isuntil = ((code >> 5) & 1U) == 1U;
#line 406
  old_simple_pline = simple_pline;
#line 408
  end = state->pc + ((code >> 5) >> 1);
#line 409
  olderrexit = noerrexit;
#line 410
  oldval = 0;
#line 411
  pushheap();
  }
#line 412
  if (isuntil) {
#line 412
    tmp = 4;
  } else {
#line 412
    tmp = 1;
  }
  {
#line 412
  cmdpush(tmp);
#line 413
  loops ++;
#line 414
  loop___0 = state->pc;
  }
#line 416
  if (*(loop___0 + 0) == 0U) {
#line 416
    if (*(loop___0 + 1) == 0U) {
#line 421
      simple_pline = 1;
      {
#line 423
      while (1) {
        while_continue: /* CIL Label */ ;
#line 423
        if (! (! breaks)) {
#line 423
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 425
      breaks --;
#line 427
      simple_pline = old_simple_pline;
    } else {
#line 416
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 429
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 430
      state->pc = loop___0;
#line 431
      noerrexit = 1;
#line 435
      simple_pline = 1;
#line 437
      execlist(state, 1, 0);
#line 439
      simple_pline = old_simple_pline;
#line 440
      noerrexit = olderrexit;
      }
#line 441
      if (! ((lastval == 0L) ^ isuntil)) {
#line 442
        if (breaks) {
#line 443
          breaks --;
        }
#line 444
        if (! retflag) {
#line 445
          lastval = (zlong )oldval;
        }
#line 446
        goto while_break___0;
      }
#line 448
      if (retflag) {
#line 449
        goto while_break___0;
      }
      {
#line 453
      simple_pline = 1;
#line 455
      execlist(state, 1, 0);
#line 457
      simple_pline = old_simple_pline;
      }
#line 458
      if (breaks) {
#line 459
        breaks --;
#line 460
        if (breaks) {
#line 461
          goto while_break___0;
        } else
#line 460
        if (! contflag) {
#line 461
          goto while_break___0;
        }
#line 462
        contflag = 0;
      }
#line 464
      if (errflag) {
#line 465
        lastval = (zlong )1;
#line 466
        goto while_break___0;
      }
#line 468
      if (retflag) {
#line 469
        goto while_break___0;
      }
      {
#line 470
      freeheap();
#line 471
      oldval = (int )lastval;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 473
  cmdpop();
#line 474
  popheap();
#line 475
  loops --;
#line 476
  state->pc = end;
#line 477
  this_noerrexit = 1;
  }
#line 478
  return ((int )lastval);
}
}
#line 482 "/tmp/zsh-5.4.2/Src/loop.c"
int execrepeat(Estate state , int do_exec  __attribute__((__unused__)) ) 
{ 
  Wordcode end ;
  Wordcode loop___0 ;
  wordcode code ;
  int count ;
  int htok ;
  char *tmp ;
  int old_simple_pline ;
  zlong tmp___0 ;
  int tmp___1 ;

  {
  {
#line 486
  code = *(state->pc + -1);
#line 487
  htok = 0;
#line 489
  old_simple_pline = simple_pline;
#line 492
  simple_pline = 1;
#line 494
  end = state->pc + (code >> 5);
#line 496
  lastval = (zlong )0;
#line 497
  tmp = ecgetstr(state, 2, & htok);
  }
#line 498
  if (htok) {
    {
#line 499
    singsub(& tmp);
    }
  }
  {
#line 500
  tmp___0 = mathevali(tmp);
#line 500
  count = (int )tmp___0;
  }
#line 501
  if (errflag) {
#line 502
    return (1);
  }
  {
#line 503
  pushheap();
#line 504
  cmdpush(2);
#line 505
  loops ++;
#line 506
  loop___0 = state->pc;
  }
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    tmp___1 = count;
#line 507
    count --;
#line 507
    if (! (tmp___1 > 0)) {
#line 507
      goto while_break;
    }
    {
#line 508
    state->pc = loop___0;
#line 509
    execlist(state, 1, 0);
#line 510
    freeheap();
    }
#line 511
    if (breaks) {
#line 512
      breaks --;
#line 513
      if (breaks) {
#line 514
        goto while_break;
      } else
#line 513
      if (! contflag) {
#line 514
        goto while_break;
      }
#line 515
      contflag = 0;
    }
#line 517
    if (errflag) {
#line 518
      lastval = (zlong )1;
#line 519
      goto while_break;
    }
#line 521
    if (retflag) {
#line 522
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 524
  cmdpop();
#line 525
  popheap();
#line 526
  loops --;
#line 527
  simple_pline = old_simple_pline;
#line 528
  state->pc = end;
#line 529
  this_noerrexit = 1;
  }
#line 530
  return ((int )lastval);
}
}
#line 534 "/tmp/zsh-5.4.2/Src/loop.c"
int execif(Estate state , int do_exec ) 
{ 
  Wordcode end ;
  Wordcode next___0 ;
  wordcode code ;
  int olderrexit ;
  int s ;
  int run ;
  Wordcode tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 538
  code = *(state->pc + -1);
#line 539
  s = 0;
#line 539
  run = 0;
#line 541
  olderrexit = noerrexit;
#line 542
  end = state->pc + ((code >> 5) >> 2);
#line 544
  if (! noerrexit) {
#line 545
    noerrexit = 3;
  }
  {
#line 546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 546
    if (! ((unsigned long )state->pc < (unsigned long )end)) {
#line 546
      goto while_break;
    }
#line 547
    tmp = state->pc;
#line 547
    (state->pc) ++;
#line 547
    code = *tmp;
#line 548
    if ((code & (wordcode )((1 << 5) - 1)) != 17U) {
#line 548
      goto _L;
    } else {
#line 548
      run = ((code >> 5) & 3U) == 3U;
#line 548
      if (run) {
        _L: /* CIL Label */ 
#line 550
        if (run) {
#line 551
          run = 2;
        }
#line 552
        goto while_break;
      }
    }
#line 554
    next___0 = state->pc + ((code >> 5) >> 2);
#line 555
    if (s) {
#line 555
      tmp___0 = 8;
    } else {
#line 555
      tmp___0 = 5;
    }
    {
#line 555
    cmdpush(tmp___0);
#line 556
    execlist(state, 1, 0);
#line 557
    cmdpop();
    }
#line 558
    if (! lastval) {
#line 559
      run = 1;
#line 560
      goto while_break;
    }
#line 562
    if (retflag) {
#line 563
      goto while_break;
    }
#line 564
    s = 1;
#line 565
    state->pc = next___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  if (run) {
#line 570
    if (olderrexit) {
#line 571
      noerrexit = olderrexit;
    } else
#line 572
    if (lastval) {
#line 573
      noerrexit = 7;
    } else {
#line 575
      noerrexit = 0;
    }
#line 576
    if (run == 2) {
#line 576
      tmp___2 = 7;
    } else {
#line 576
      if (s) {
#line 576
        tmp___1 = 26;
      } else {
#line 576
        tmp___1 = 6;
      }
#line 576
      tmp___2 = tmp___1;
    }
    {
#line 576
    cmdpush(tmp___2);
#line 577
    execlist(state, 1, do_exec);
#line 578
    cmdpop();
    }
  } else {
#line 580
    noerrexit = olderrexit;
#line 581
    if (! retflag) {
#line 582
      lastval = (zlong )0;
    }
  }
#line 584
  state->pc = end;
#line 585
  this_noerrexit = 1;
#line 587
  return ((int )lastval);
}
}
#line 591 "/tmp/zsh-5.4.2/Src/loop.c"
int execcase(Estate state , int do_exec ) 
{ 
  Wordcode end ;
  Wordcode next___0 ;
  wordcode code ;
  char *word ;
  char *pat ;
  int npat ;
  int save ;
  int nalts ;
  int ialt ;
  int patok ;
  int anypatok ;
  Patprog *spprog ;
  Patprog pprog ;
  Wordcode tmp ;
  Wordcode tmp___0 ;
  int htok ;
  char *tmp___1 ;
  int tmp___2 ;
  char *opat ;
  int htok___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  sigset_t oset ;
  int tmp___7 ;
  Wordcode tmp___8 ;
  Wordcode tmp___9 ;
  int tmp___10 ;

  {
  {
#line 595
  code = *(state->pc + -1);
#line 600
  end = state->pc + ((code >> 5) >> 3);
#line 602
  word = ecgetstr(state, 1, (int *)((void *)0));
#line 603
  singsub(& word);
#line 604
  untokenize(word);
#line 605
  anypatok = 0;
#line 607
  cmdpush(16);
  }
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    if (! ((unsigned long )state->pc < (unsigned long )end)) {
#line 608
      goto while_break;
    }
#line 609
    tmp = state->pc;
#line 609
    (state->pc) ++;
#line 609
    code = *tmp;
#line 610
    if ((code & (wordcode )((1 << 5) - 1)) != 16U) {
#line 611
      goto while_break;
    }
#line 613
    save = 0;
#line 614
    next___0 = state->pc + ((code >> 5) >> 3);
#line 615
    tmp___0 = state->pc;
#line 615
    (state->pc) ++;
#line 615
    nalts = (int )*tmp___0;
#line 616
    patok = 0;
#line 616
    ialt = patok;
#line 618
    if (opts[177]) {
      {
#line 619
      printprompt4();
#line 620
      fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)"case %s (",
              word);
      }
    }
    {
#line 623
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 623
      if (! patok) {
#line 623
        if (! nalts) {
#line 623
          goto while_break___0;
        }
      } else {
#line 623
        goto while_break___0;
      }
#line 624
      npat = (int )*(state->pc + 1);
#line 625
      spprog = (state->prog)->pats + npat;
#line 626
      pprog = (Patprog )((void *)0);
#line 627
      pat = (char *)((void *)0);
#line 629
      queueing_enabled ++;
#line 631
      if (opts[177]) {
        {
#line 632
        htok = 0;
#line 633
        tmp___1 = ecrawstr(state->prog, state->pc, & htok);
#line 633
        pat = dupstring((char const   *)tmp___1);
        }
#line 634
        if (htok) {
          {
#line 635
          singsub(& pat);
          }
        }
#line 637
        tmp___2 = ialt;
#line 637
        ialt ++;
#line 637
        if (tmp___2) {
          {
#line 638
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" | ");
          }
        }
        {
#line 639
        quote_tokenized_output(pat, xtrerr);
        }
      }
#line 642
      if ((unsigned long )*spprog != (unsigned long )((Patprog )1)) {
#line 642
        if ((unsigned long )*spprog != (unsigned long )((Patprog )2)) {
#line 643
          pprog = *spprog;
        }
      }
#line 645
      if (! pprog) {
#line 646
        if (! pat) {
          {
#line 648
          htok___0 = 0;
#line 650
          opat = ecrawstr(state->prog, state->pc, & htok___0);
#line 650
          pat = dupstring((char const   *)opat);
          }
#line 652
          if (htok___0) {
            {
#line 653
            singsub(& pat);
            }
          }
#line 654
          if (! ((state->prog)->flags & 2)) {
            {
#line 654
            tmp___3 = strcmp((char const   *)pat, (char const   *)opat);
            }
#line 654
            if (tmp___3) {
#line 654
              tmp___4 = 0;
            } else
#line 654
            if ((unsigned long )*spprog != (unsigned long )((Patprog )2)) {
#line 654
              tmp___4 = 1;
            } else {
#line 654
              tmp___4 = 0;
            }
          } else {
#line 654
            tmp___4 = 0;
          }
#line 654
          save = tmp___4;
        }
#line 657
        if (save) {
#line 657
          tmp___5 = 256;
        } else {
#line 657
          tmp___5 = 64;
        }
        {
#line 657
        pprog = patcompile(pat, tmp___5, (char **)((void *)0));
        }
#line 657
        if (pprog) {
#line 660
          if (save) {
#line 661
            *spprog = pprog;
          }
        } else {
          {
#line 659
          zerr("bad pattern: %s", pat);
          }
        }
      }
#line 663
      if (pprog) {
        {
#line 663
        tmp___6 = pattry(pprog, word);
        }
#line 663
        if (tmp___6) {
#line 664
          anypatok = 1;
#line 664
          patok = anypatok;
        }
      }
#line 665
      state->pc += 2;
#line 666
      nalts --;
      {
#line 668
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 668
        queueing_enabled --;
#line 668
        if (! queueing_enabled) {
          {
#line 668
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 668
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 668
              if (! (queue_front != queue_rear)) {
#line 668
                goto while_break___3;
              }
              {
#line 668
              queue_front = (queue_front + 1) % 128;
#line 668
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 668
              zhandler(signal_queue[queue_front]);
#line 668
              signal_setmask(oset);
              }
            }
            while_break___3: /* CIL Label */ ;
            }
#line 668
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 668
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 670
    state->pc += 2 * nalts;
#line 671
    if (opts[177]) {
      {
#line 672
      fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)")\n");
#line 673
      fflush(xtrerr);
      }
    }
#line 675
    if (patok) {
#line 676
      if (((code >> 5) & 7U) == 1U) {
#line 676
        if (do_exec) {
#line 676
          tmp___7 = 1;
        } else {
#line 676
          tmp___7 = 0;
        }
      } else {
#line 676
        tmp___7 = 0;
      }
      {
#line 676
      execlist(state, 1, tmp___7);
      }
      {
#line 678
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 678
        if (! retflag) {
#line 678
          if ((code & (wordcode )((1 << 5) - 1)) == 16U) {
#line 678
            if (((code >> 5) & 7U) == 2U) {
#line 678
              if (! ((unsigned long )state->pc < (unsigned long )end)) {
#line 678
                goto while_break___4;
              }
            } else {
#line 678
              goto while_break___4;
            }
          } else {
#line 678
            goto while_break___4;
          }
        } else {
#line 678
          goto while_break___4;
        }
#line 680
        state->pc = next___0;
#line 681
        tmp___8 = state->pc;
#line 681
        (state->pc) ++;
#line 681
        code = *tmp___8;
#line 682
        next___0 = state->pc + ((code >> 5) >> 3);
#line 683
        tmp___9 = state->pc;
#line 683
        (state->pc) ++;
#line 683
        nalts = (int )*tmp___9;
#line 684
        state->pc += 2 * nalts;
#line 685
        if (((code >> 5) & 7U) == 1U) {
#line 685
          if (do_exec) {
#line 685
            tmp___10 = 1;
          } else {
#line 685
            tmp___10 = 0;
          }
        } else {
#line 685
          tmp___10 = 0;
        }
        {
#line 685
        execlist(state, 1, tmp___10);
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 688
      if (((code >> 5) & 7U) != 3U) {
#line 689
        goto while_break;
      }
    }
#line 691
    state->pc = next___0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 693
  cmdpop();
#line 695
  state->pc = end;
  }
#line 697
  if (! anypatok) {
#line 698
    lastval = (zlong )0;
  }
#line 699
  this_noerrexit = 1;
#line 701
  return ((int )lastval);
}
}
#line 710 "/tmp/zsh-5.4.2/Src/loop.c"
zlong try_errflag  =    (zlong )-1;
#line 718 "/tmp/zsh-5.4.2/Src/loop.c"
zlong try_interrupt  =    (zlong )-1;
#line 722 "/tmp/zsh-5.4.2/Src/loop.c"
zlong try_tryflag  =    (zlong )0;
#line 726 "/tmp/zsh-5.4.2/Src/loop.c"
int exectry(Estate state , int do_exec ) 
{ 
  Wordcode end ;
  Wordcode always ;
  int endval ;
  int save_retflag ;
  int save_breaks ;
  int save_contflag ;
  zlong save_try_errflag ;
  zlong save_try_tryflag ;
  zlong save_try_interrupt ;
  int tmp ;

  {
  {
#line 734
  end = state->pc + (*(state->pc + -1) >> 5);
#line 735
  always = (state->pc + 1) + (*(state->pc) >> 5);
#line 736
  (state->pc) ++;
#line 737
  pushheap();
#line 738
  cmdpush(19);
#line 741
  save_try_tryflag = try_tryflag;
#line 742
  try_tryflag = (zlong )1;
#line 744
  execlist(state, 1, do_exec);
#line 746
  try_tryflag = save_try_tryflag;
  }
#line 750
  if (lastval) {
#line 750
    endval = (int )lastval;
  } else {
#line 750
    endval = errflag;
  }
  {
#line 752
  freeheap();
#line 754
  cmdpop();
#line 755
  cmdpush(31);
#line 758
  save_try_errflag = try_errflag;
#line 759
  save_try_interrupt = try_interrupt;
#line 760
  try_errflag = (zlong )(errflag & 1);
  }
#line 761
  if (errflag & 2) {
#line 761
    tmp = 1;
  } else {
#line 761
    tmp = 0;
  }
  {
#line 761
  try_interrupt = (zlong )tmp;
#line 763
  errflag = 0;
#line 764
  save_retflag = retflag;
#line 765
  retflag = 0;
#line 766
  save_breaks = breaks;
#line 767
  breaks = 0;
#line 768
  save_contflag = contflag;
#line 769
  contflag = 0;
#line 771
  state->pc = always;
#line 772
  execlist(state, 1, do_exec);
  }
#line 774
  if (try_errflag) {
#line 775
    errflag |= 1;
  } else {
#line 777
    errflag &= -2;
  }
#line 778
  if (try_interrupt) {
#line 779
    errflag |= 2;
  } else {
#line 781
    errflag &= -3;
  }
#line 782
  try_errflag = save_try_errflag;
#line 783
  try_interrupt = save_try_interrupt;
#line 784
  if (! retflag) {
#line 785
    retflag = save_retflag;
  }
#line 786
  if (! breaks) {
#line 787
    breaks = save_breaks;
  }
#line 788
  if (! contflag) {
#line 789
    contflag = save_contflag;
  }
  {
#line 791
  cmdpop();
#line 792
  popheap();
#line 793
  state->pc = end;
  }
#line 795
  return (endval);
}
}
#line 9 "./linklist.epro"
LinkNode uinsertlinknode(LinkList list , LinkNode node , LinkNode new ) ;
#line 17
void rolllist(LinkList l , LinkNode nd ) ;
#line 19
LinkList joinlists(LinkList first , LinkList second ) ;
#line 23
char **zlinklist2array(LinkList list ) ;
#line 102 "/tmp/zsh-5.4.2/Src/linklist.c"
LinkList newlinklist(void) 
{ 
  LinkList list ;
  void *tmp ;

  {
  {
#line 107
  tmp = zhalloc(sizeof(*list));
#line 107
  list = (LinkList )tmp;
#line 108
  list->list.first = (LinkNode )((void *)0);
#line 109
  list->list.last = & list->node;
#line 110
  list->list.flags = 0;
  }
#line 111
  return (list);
}
}
#line 115 "/tmp/zsh-5.4.2/Src/linklist.c"
LinkList znewlinklist(void) 
{ 
  LinkList list ;
  void *tmp ;

  {
  {
#line 120
  tmp = zalloc(sizeof(*list));
#line 120
  list = (LinkList )tmp;
  }
#line 121
  if (! list) {
#line 122
    return ((LinkList )((void *)0));
  }
#line 123
  list->list.first = (LinkNode )((void *)0);
#line 124
  list->list.last = & list->node;
#line 125
  list->list.flags = 0;
#line 126
  return (list);
}
}
#line 132 "/tmp/zsh-5.4.2/Src/linklist.c"
LinkNode insertlinknode(LinkList list , LinkNode node , void *dat ) 
{ 
  LinkNode tmp ;
  LinkNode new ;
  void *tmp___0 ;

  {
  {
#line 137
  tmp = node->next;
#line 138
  tmp___0 = zhalloc(sizeof(*tmp));
#line 138
  new = (LinkNode )tmp___0;
#line 138
  node->next = new;
#line 139
  new->prev = node;
#line 140
  new->dat = dat;
#line 141
  new->next = tmp;
  }
#line 142
  if (tmp) {
#line 143
    tmp->prev = new;
  } else {
#line 145
    list->list.last = new;
  }
#line 146
  return (new);
}
}
#line 150 "/tmp/zsh-5.4.2/Src/linklist.c"
LinkNode zinsertlinknode(LinkList list , LinkNode node , void *dat ) 
{ 
  LinkNode tmp ;
  LinkNode new ;
  void *tmp___0 ;

  {
  {
#line 155
  tmp = node->next;
#line 156
  tmp___0 = zalloc(sizeof(*tmp));
#line 156
  new = (LinkNode )tmp___0;
#line 156
  node->next = new;
  }
#line 157
  if (! new) {
#line 158
    return ((LinkNode )((void *)0));
  }
#line 159
  new->prev = node;
#line 160
  new->dat = dat;
#line 161
  new->next = tmp;
#line 162
  if (tmp) {
#line 163
    tmp->prev = new;
  } else {
#line 165
    list->list.last = new;
  }
#line 166
  return (new);
}
}
#line 172 "/tmp/zsh-5.4.2/Src/linklist.c"
LinkNode uinsertlinknode(LinkList list , LinkNode node , LinkNode new ) 
{ 
  LinkNode tmp ;

  {
#line 175
  tmp = node->next;
#line 176
  node->next = new;
#line 177
  new->prev = node;
#line 178
  new->next = tmp;
#line 179
  if (tmp) {
#line 180
    tmp->prev = new;
  } else {
#line 182
    list->list.last = new;
  }
#line 183
  return (new);
}
}
#line 189 "/tmp/zsh-5.4.2/Src/linklist.c"
void insertlinklist(LinkList l , LinkNode where , LinkList x ) 
{ 
  LinkNode nx ;

  {
#line 194
  nx = where->next;
#line 195
  if (! l->list.first) {
#line 196
    return;
  }
#line 197
  where->next = l->list.first;
#line 198
  (l->list.last)->next = nx;
#line 199
  (l->list.first)->prev = where;
#line 200
  if (nx) {
#line 201
    nx->prev = l->list.last;
  } else {
#line 203
    x->list.last = l->list.last;
  }
#line 204
  return;
}
}
#line 209 "/tmp/zsh-5.4.2/Src/linklist.c"
void *getlinknode(LinkList list ) 
{ 
  void *dat ;
  LinkNode node ;

  {
#line 215
  node = list->list.first;
#line 215
  if (! node) {
#line 216
    return ((void *)0);
  }
#line 217
  dat = node->dat;
#line 218
  list->list.first = node->next;
#line 219
  if (node->next) {
#line 220
    (node->next)->prev = & list->node;
  } else {
#line 222
    list->list.last = & list->node;
  }
  {
#line 223
  zfree((void *)node, (int )sizeof(*node));
  }
#line 224
  return (dat);
}
}
#line 230 "/tmp/zsh-5.4.2/Src/linklist.c"
void *ugetnode(LinkList list ) 
{ 
  void *dat ;
  LinkNode node ;

  {
#line 236
  node = list->list.first;
#line 236
  if (! node) {
#line 237
    return ((void *)0);
  }
#line 238
  dat = node->dat;
#line 239
  list->list.first = node->next;
#line 240
  if (node->next) {
#line 241
    (node->next)->prev = & list->node;
  } else {
#line 243
    list->list.last = & list->node;
  }
#line 244
  return (dat);
}
}
#line 250 "/tmp/zsh-5.4.2/Src/linklist.c"
void *remnode(LinkList list , LinkNode nd ) 
{ 
  void *dat ;

  {
#line 255
  (nd->prev)->next = nd->next;
#line 256
  if (nd->next) {
#line 257
    (nd->next)->prev = nd->prev;
  } else {
#line 259
    list->list.last = nd->prev;
  }
  {
#line 260
  dat = nd->dat;
#line 261
  zfree((void *)nd, (int )sizeof(*nd));
  }
#line 263
  return (dat);
}
}
#line 269 "/tmp/zsh-5.4.2/Src/linklist.c"
void *uremnode(LinkList list , LinkNode nd ) 
{ 
  void *dat ;

  {
#line 274
  (nd->prev)->next = nd->next;
#line 275
  if (nd->next) {
#line 276
    (nd->next)->prev = nd->prev;
  } else {
#line 278
    list->list.last = nd->prev;
  }
#line 279
  dat = nd->dat;
#line 280
  return (dat);
}
}
#line 286 "/tmp/zsh-5.4.2/Src/linklist.c"
void freelinklist(LinkList list , void (*freefunc)(void * ) ) 
{ 
  LinkNode node ;
  LinkNode next___0 ;

  {
#line 291
  node = list->list.first;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! node) {
#line 291
      goto while_break;
    }
#line 292
    next___0 = node->next;
#line 293
    if (freefunc) {
      {
#line 294
      (*freefunc)(node->dat);
      }
    }
    {
#line 295
    zfree((void *)node, (int )sizeof(*node));
#line 291
    node = next___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 297
  zfree((void *)list, (int )sizeof(*list));
  }
#line 298
  return;
}
}
#line 303 "/tmp/zsh-5.4.2/Src/linklist.c"
int countlinknodes(LinkList list ) 
{ 
  LinkNode nd ;
  int ct ;

  {
#line 307
  ct = 0;
#line 309
  nd = list->list.first;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! nd) {
#line 309
      goto while_break;
    }
#line 309
    nd = nd->next;
#line 309
    ct ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return (ct);
}
}
#line 316 "/tmp/zsh-5.4.2/Src/linklist.c"
void rolllist(LinkList l , LinkNode nd ) 
{ 


  {
#line 319
  (l->list.last)->next = l->list.first;
#line 320
  (l->list.first)->prev = l->list.last;
#line 321
  l->list.first = nd;
#line 322
  l->list.last = nd->prev;
#line 323
  nd->prev = & l->node;
#line 324
  (l->list.last)->next = (LinkNode )0;
#line 325
  return;
}
}
#line 330 "/tmp/zsh-5.4.2/Src/linklist.c"
LinkList newsizedlist(int size ) 
{ 
  LinkList list ;
  LinkNode node ;
  void *tmp ;

  {
  {
#line 336
  tmp = zhalloc(sizeof(*list) + (unsigned long )size * sizeof(*node));
#line 336
  list = (LinkList )tmp;
#line 338
  list->list.first = & (list + 1)->node;
#line 339
  node = list->list.first;
  }
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! size) {
#line 339
      goto while_break;
    }
#line 340
    node->prev = node - 1;
#line 341
    node->next = node + 1;
#line 339
    size --;
#line 339
    node ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  list->list.last = node - 1;
#line 344
  (list->list.first)->prev = & list->node;
#line 345
  (node + -1)->next = (LinkNode )((void *)0);
#line 347
  return (list);
}
}
#line 359 "/tmp/zsh-5.4.2/Src/linklist.c"
LinkList joinlists(LinkList first , LinkList second ) 
{ 
  LinkNode moveme ;
  LinkNode anchor ;
  LinkNode tmp ;

  {
#line 362
  moveme = second->list.first;
#line 363
  if (moveme) {
#line 364
    if (first->list.first) {
#line 365
      anchor = first->list.last;
#line 366
      anchor->next = moveme;
#line 367
      moveme->prev = anchor;
    } else {
#line 369
      first->list.first = moveme;
#line 370
      moveme->prev = & first->node;
    }
#line 372
    first->list.last = second->list.last;
#line 374
    tmp = (LinkNode )((void *)0);
#line 374
    second->list.last = tmp;
#line 374
    second->list.first = tmp;
  }
#line 376
  return (first);
}
}
#line 385 "/tmp/zsh-5.4.2/Src/linklist.c"
LinkNode linknodebydatum(LinkList list , void *dat ) 
{ 
  LinkNode node ;

  {
#line 390
  node = list->list.first;
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! node) {
#line 390
      goto while_break;
    }
#line 391
    if ((unsigned long )node->dat == (unsigned long )dat) {
#line 392
      return (node);
    }
#line 390
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  return ((LinkNode )((void *)0));
}
}
#line 402 "/tmp/zsh-5.4.2/Src/linklist.c"
LinkNode linknodebystring(LinkList list , char *dat ) 
{ 
  LinkNode node ;
  int tmp ;

  {
#line 407
  node = list->list.first;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! node) {
#line 407
      goto while_break;
    }
    {
#line 408
    tmp = strcmp((char const   *)((char *)node->dat), (char const   *)dat);
    }
#line 408
    if (! tmp) {
#line 409
      return (node);
    }
#line 407
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  return ((LinkNode )((void *)0));
}
}
#line 422 "/tmp/zsh-5.4.2/Src/linklist.c"
char **hlinklist2array(LinkList list , int copy ) 
{ 
  int l ;
  int tmp ;
  char **ret ;
  void *tmp___0 ;
  char **p ;
  LinkNode n ;

  {
  {
#line 425
  tmp = countlinknodes(list);
#line 425
  l = tmp;
#line 426
  tmp___0 = zhalloc((unsigned long )(l + 1) * sizeof(char *));
#line 426
  ret = (char **)tmp___0;
#line 429
  n = list->list.first;
#line 429
  p = ret;
  }
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! n) {
#line 429
      goto while_break;
    }
#line 430
    *p = (char *)n->dat;
#line 431
    if (copy) {
      {
#line 432
      *p = dupstring((char const   *)*p);
      }
    }
#line 429
    n = n->next;
#line 429
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  *p = (char *)((void *)0);
#line 436
  return (ret);
}
}
#line 446 "/tmp/zsh-5.4.2/Src/linklist.c"
char **zlinklist2array(LinkList list ) 
{ 
  int l ;
  int tmp ;
  char **ret ;
  void *tmp___0 ;
  char **p ;
  LinkNode n ;

  {
  {
#line 449
  tmp = countlinknodes(list);
#line 449
  l = tmp;
#line 450
  tmp___0 = zalloc((unsigned long )(l + 1) * sizeof(char *));
#line 450
  ret = (char **)tmp___0;
#line 453
  n = list->list.first;
#line 453
  p = ret;
  }
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! n) {
#line 453
      goto while_break;
    }
    {
#line 454
    *p = ztrdup((char const   *)((char *)n->dat));
#line 453
    n = n->next;
#line 453
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  *p = (char *)((void *)0);
#line 458
  return (ret);
}
}
#line 5 "./context.epro"
void zcontext_save_partial(int parts ) ;
#line 7
void zcontext_restore_partial(int parts ) ;
#line 51 "./exec.epro"
char *gethere(char **strp , int typ ) ;
#line 34 "./hashtable.epro"
extern HashTable sufaliastab ;
#line 5 "./hist.epro"
int (*hgetc)(void) ;
#line 6
void (*hungetc)(int  ) ;
#line 7
void (*hwaddc)(int  ) ;
#line 8
void (*hwbegin)(int  ) ;
#line 9
void (*hwend)(void) ;
#line 10
void (*addtoline)(int  ) ;
#line 11
int stophist ;
#line 12
int expanding ;
#line 34
int qbang ;
#line 38
void hist_in_word(int yesno ) ;
#line 41
void strinbeg(int dohist ) ;
#line 42
void strinend(void) ;
#line 7 "./input.epro"
int strin ;
#line 8
int inbufct ;
#line 9
int inbufflags ;
#line 11
int ingetc(void) ;
#line 15
void inpush(char *str , int flags , Alias inalias ) ;
#line 16
void inpop(void) ;
#line 6 "./lex.epro"
char *zshlextext  ;
#line 7 "./lex.epro"
char *tokstr  ;
#line 8 "./lex.epro"
enum lextok tok  ;
#line 9 "./lex.epro"
int tokfd  ;
#line 10 "./lex.epro"
zlong toklineno  ;
#line 11 "./lex.epro"
int lexstop  ;
#line 12 "./lex.epro"
int isfirstln  ;
#line 13 "./lex.epro"
int isfirstch  ;
#line 14 "./lex.epro"
int inalmore  ;
#line 15 "./lex.epro"
int nocorrect  ;
#line 16 "./lex.epro"
int zlemetacs  ;
#line 17 "./lex.epro"
int zlemetall  ;
#line 18 "./lex.epro"
int inwhat  ;
#line 19 "./lex.epro"
int addedx  ;
#line 20 "./lex.epro"
int wb  ;
#line 21 "./lex.epro"
int we  ;
#line 22 "./lex.epro"
int wordbeg  ;
#line 23 "./lex.epro"
int parbegin  ;
#line 24 "./lex.epro"
int parend  ;
#line 25 "./lex.epro"
int noaliases  ;
#line 26 "./lex.epro"
int lexflags  ;
#line 27 "./lex.epro"
int nocomments  ;
#line 28
char *tokstrings[63] ;
#line 29
void lex_context_save(struct lex_stack *ls , int toplevel ) ;
#line 30
void lex_context_restore(struct lex_stack  const  *ls , int toplevel ) ;
#line 32
void ctxtlex(void) ;
#line 33
void initlextabs(void) ;
#line 34
void lexinit(void) ;
#line 35
void add(int c ) ;
#line 40
int exalias(void) ;
#line 41
void zshlex_raw_add(int c ) ;
#line 42
void zshlex_raw_back(void) ;
#line 43
int zshlex_raw_mark(int offset ) ;
#line 44
void zshlex_raw_back_to_mark(int mark ) ;
#line 2 "./lex.pro"
static int lex_add_raw  ;
#line 3
static int isnumglob(void) ;
#line 4
static enum lextok gettok(void) ;
#line 5
static enum lextok gettokstr(int c , int sub ) ;
#line 6
static int dquote_parse(char endchar , int sub ) ;
#line 7
static void gotword(void) ;
#line 8
static int skipcomm(void) ;
#line 38 "/tmp/zsh-5.4.2/Src/lex.c"
char ztokens[30]  = 
#line 38 "/tmp/zsh-5.4.2/Src/lex.c"
  {      (char )'#',      (char )'$',      (char )'^',      (char )'*', 
        (char )'(',      (char )'(',      (char )')',      (char )')', 
        (char )'$',      (char )'=',      (char )'|',      (char )'{', 
        (char )'}',      (char )'[',      (char )']',      (char )'`', 
        (char )'<',      (char )'>',      (char )'>',      (char )'?', 
        (char )'~',      (char )'`',      (char )',',      (char )'-', 
        (char )'!',      (char )'\'',      (char )'\"',      (char )'\\', 
        (char )'\\',      (char )'\000'};
#line 165 "/tmp/zsh-5.4.2/Src/lex.c"
static char *tokstr_raw  ;
#line 166 "/tmp/zsh-5.4.2/Src/lex.c"
static struct lexbufstate lexbuf_raw  ;
#line 171 "/tmp/zsh-5.4.2/Src/lex.c"
char *tokstrings[63]  = 
#line 171
  {      (char *)((void *)0),      (char *)";",      (char *)"\\n",      (char *)";", 
        (char *)";;",      (char *)"&",      (char *)"(",      (char *)")", 
        (char *)"||",      (char *)"&&",      (char *)">",      (char *)">|", 
        (char *)">>",      (char *)">>|",      (char *)"<",      (char *)"<>", 
        (char *)"<<",      (char *)"<<-",      (char *)"<&",      (char *)">&", 
        (char *)"&>",      (char *)"&>|",      (char *)">>&",      (char *)">>&|", 
        (char *)"<<<",      (char *)"|",      (char *)"|&",      (char *)"()", 
        (char *)"((",      (char *)"))",      (char *)"&|",      (char *)";&", 
        (char *)";|"};
#line 209 "/tmp/zsh-5.4.2/Src/lex.c"
static int dbparens  ;
#line 210 "/tmp/zsh-5.4.2/Src/lex.c"
static struct lexbufstate lexbuf  =    {(char *)((void *)0), 256, 0};
#line 215 "/tmp/zsh-5.4.2/Src/lex.c"
void lex_context_save(struct lex_stack *ls , int toplevel ) 
{ 


  {
#line 220
  ls->dbparens = dbparens;
#line 221
  ls->isfirstln = isfirstln;
#line 222
  ls->isfirstch = isfirstch;
#line 223
  ls->lexflags = lexflags;
#line 225
  ls->tok = tok;
#line 226
  ls->tokstr = tokstr;
#line 227
  ls->zshlextext = zshlextext;
#line 228
  ls->lexbuf = lexbuf;
#line 229
  ls->lex_add_raw = lex_add_raw;
#line 230
  ls->tokstr_raw = tokstr_raw;
#line 231
  ls->lexbuf_raw = lexbuf_raw;
#line 232
  ls->lexstop = lexstop;
#line 233
  ls->toklineno = toklineno;
#line 235
  lexbuf.ptr = (char *)((void *)0);
#line 235
  zshlextext = lexbuf.ptr;
#line 235
  tokstr = zshlextext;
#line 236
  lexbuf.siz = 256;
#line 237
  lexbuf_raw.ptr = (char *)((void *)0);
#line 237
  tokstr_raw = lexbuf_raw.ptr;
#line 238
  lex_add_raw = 0;
#line 238
  lexbuf_raw.len = lex_add_raw;
#line 238
  lexbuf_raw.siz = lexbuf_raw.len;
#line 239
  return;
}
}
#line 244 "/tmp/zsh-5.4.2/Src/lex.c"
void lex_context_restore(struct lex_stack  const  *ls , int toplevel ) 
{ 


  {
#line 249
  dbparens = (int )ls->dbparens;
#line 250
  isfirstln = (int )ls->isfirstln;
#line 251
  isfirstch = (int )ls->isfirstch;
#line 252
  lexflags = (int )ls->lexflags;
#line 253
  tok = (enum lextok )ls->tok;
#line 254
  tokstr = (char *)ls->tokstr;
#line 255
  zshlextext = (char *)ls->zshlextext;
#line 256
  lexbuf = (struct lexbufstate )ls->lexbuf;
#line 257
  lex_add_raw = (int )ls->lex_add_raw;
#line 258
  tokstr_raw = (char *)ls->tokstr_raw;
#line 259
  lexbuf_raw = (struct lexbufstate )ls->lexbuf_raw;
#line 260
  lexstop = (int )ls->lexstop;
#line 261
  toklineno = (zlong )ls->toklineno;
#line 262
  return;
}
}
#line 265 "/tmp/zsh-5.4.2/Src/lex.c"
void zshlex(void) 
{ 
  int tmp ;
  struct heredocs *next___0 ;
  char *doc ;
  char *munged_term ;
  int tmp___0 ;

  {
#line 268
  if ((unsigned int )tok == 38U) {
#line 269
    return;
  }
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (inrepeat_) {
#line 272
      inrepeat_ ++;
    }
#line 273
    if (inrepeat_ == 3) {
#line 273
      if (opts[163]) {
#line 274
        incmdpos = 1;
      }
    }
    {
#line 275
    tok = gettok();
    }
#line 270
    if ((unsigned int )tok != 37U) {
      {
#line 270
      tmp = exalias();
      }
#line 270
      if (! tmp) {
#line 270
        goto while_break;
      }
    } else {
#line 270
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  nocorrect &= 1;
#line 278
  if ((unsigned int )tok == 2U) {
#line 278
    goto _L;
  } else
#line 278
  if ((unsigned int )tok == 37U) {
    _L: /* CIL Label */ 
    {
#line 279
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 279
      if (! hdocs) {
#line 279
        goto while_break___0;
      }
      {
#line 280
      next___0 = hdocs->next;
#line 283
      (*hwbegin)(0);
      }
#line 284
      if (hdocs->type == 10) {
#line 284
        tmp___0 = 27;
      } else {
#line 284
        tmp___0 = 28;
      }
      {
#line 284
      cmdpush(tmp___0);
#line 285
      munged_term = dupstring((char const   *)hdocs->str);
#line 286
      stophist += 4;
#line 287
      doc = gethere(& munged_term, hdocs->type);
#line 288
      stophist -= 4;
#line 289
      cmdpop();
#line 290
      (*hwend)();
      }
#line 291
      if (! doc) {
        {
#line 292
        zerr("here document too large");
        }
        {
#line 293
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 293
          if (! hdocs) {
#line 293
            goto while_break___1;
          }
          {
#line 294
          next___0 = hdocs->next;
#line 295
          zfree((void *)hdocs, (int )sizeof(struct heredocs ));
#line 296
          hdocs = next___0;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 298
        tok = (enum lextok )38;
#line 299
        goto while_break___0;
      }
      {
#line 301
      setheredoc(hdocs->pc, 12, doc, hdocs->str, munged_term);
#line 303
      zfree((void *)hdocs, (int )sizeof(struct heredocs ));
#line 304
      hdocs = next___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 307
  if ((unsigned int )tok != 2U) {
#line 308
    isnewlin = 0;
  } else
#line 310
  if (inbufct) {
#line 310
    isnewlin = -1;
  } else {
#line 310
    isnewlin = 1;
  }
#line 311
  if ((unsigned int )tok == 3U) {
#line 312
    tok = (enum lextok )1;
  } else
#line 311
  if ((unsigned int )tok == 2U) {
#line 311
    if (! (lexflags & 16)) {
#line 312
      tok = (enum lextok )1;
    }
  }
#line 313
  return;
}
}
#line 319 "/tmp/zsh-5.4.2/Src/lex.c"
static int oldpos  ;
#line 316 "/tmp/zsh-5.4.2/Src/lex.c"
void ctxtlex(void) 
{ 


  {
  {
#line 321
  zshlex();
  }
  {
#line 342
  if ((unsigned int )tok == 33U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 48U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 47U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 59U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 45U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 27U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 26U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 25U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 9U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 8U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 41U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 6U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 30U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 5U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 32U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 31U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 4U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 3U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 2U) {
#line 342
    goto case_33;
  }
#line 342
  if ((unsigned int )tok == 1U) {
#line 342
    goto case_33;
  }
#line 351
  if ((unsigned int )tok == 40U) {
#line 351
    goto case_40;
  }
#line 351
  if ((unsigned int )tok == 43U) {
#line 351
    goto case_40;
  }
#line 351
  if ((unsigned int )tok == 7U) {
#line 351
    goto case_40;
  }
#line 351
  if ((unsigned int )tok == 36U) {
#line 351
    goto case_40;
  }
#line 351
  if ((unsigned int )tok == 63U) {
#line 351
    goto case_40;
  }
#line 351
  if ((unsigned int )tok == 34U) {
#line 351
    goto case_40;
  }
#line 355
  goto switch_default;
  case_33: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 343
  incmdpos = 1;
#line 344
  goto switch_break;
  case_40: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_34: /* CIL Label */ 
#line 352
  incmdpos = 0;
#line 353
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 357
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 359
  if ((unsigned int )tok != 28U) {
#line 360
    if ((unsigned int )tok == 52U) {
#line 360
      infor = 2;
    } else {
#line 360
      infor = 0;
    }
  }
#line 361
  if ((unsigned int )tok >= 10U) {
#line 361
    if ((unsigned int )tok <= 24U) {
#line 362
      inredir = 1;
#line 363
      oldpos = incmdpos;
#line 364
      incmdpos = 0;
    } else {
#line 361
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 361
  if ((unsigned int )tok == 52U) {
#line 362
    inredir = 1;
#line 363
    oldpos = incmdpos;
#line 364
    incmdpos = 0;
  } else
#line 361
  if ((unsigned int )tok == 53U) {
#line 362
    inredir = 1;
#line 363
    oldpos = incmdpos;
#line 364
    incmdpos = 0;
  } else
#line 361
  if ((unsigned int )tok == 58U) {
#line 362
    inredir = 1;
#line 363
    oldpos = incmdpos;
#line 364
    incmdpos = 0;
  } else
#line 365
  if (inredir) {
#line 366
    incmdpos = oldpos;
#line 367
    inredir = 0;
  }
#line 369
  return;
}
}
#line 406 "/tmp/zsh-5.4.2/Src/lex.c"
static unsigned char lexact1[256]  ;
#line 406 "/tmp/zsh-5.4.2/Src/lex.c"
static unsigned char lexact2[256]  ;
#line 406 "/tmp/zsh-5.4.2/Src/lex.c"
static unsigned char lextok2[256]  ;
#line 413 "/tmp/zsh-5.4.2/Src/lex.c"
static char *lx1  =    (char *)"\\q\n;!&|(){}[]<>";
#line 414 "/tmp/zsh-5.4.2/Src/lex.c"
static char *lx2  =    (char *)";)|$[]~({}><=\\\'\"`,-!";
#line 409 "/tmp/zsh-5.4.2/Src/lex.c"
void initlextabs(void) 
{ 
  int t0 ;

  {
#line 416
  t0 = 0;
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (! (t0 != 256)) {
#line 416
      goto while_break;
    }
#line 417
    lexact1[t0] = (unsigned char)15;
#line 418
    lexact2[t0] = (unsigned char)20;
#line 419
    lextok2[t0] = (unsigned char )t0;
#line 416
    t0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 421
  t0 = 0;
  {
#line 421
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 421
    if (! *(lx1 + t0)) {
#line 421
      goto while_break___0;
    }
#line 422
    lexact1[(int )*(lx1 + t0)] = (unsigned char )t0;
#line 421
    t0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 423
  t0 = 0;
  {
#line 423
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 423
    if (! *(lx2 + t0)) {
#line 423
      goto while_break___1;
    }
#line 424
    lexact2[(int )*(lx2 + t0)] = (unsigned char )t0;
#line 423
    t0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 425
  lexact2['&'] = (unsigned char)0;
#line 426
  lexact2[(unsigned char)131] = (unsigned char)21;
#line 427
  lextok2['*'] = (unsigned char)135;
#line 428
  lextok2['?'] = (unsigned char)151;
#line 429
  lextok2['{'] = (unsigned char)143;
#line 430
  lextok2['['] = (unsigned char)145;
#line 431
  lextok2['$'] = (unsigned char)133;
#line 432
  lextok2['~'] = (unsigned char)152;
#line 433
  lextok2['#'] = (unsigned char)132;
#line 434
  lextok2['^'] = (unsigned char)134;
#line 435
  return;
}
}
#line 440 "/tmp/zsh-5.4.2/Src/lex.c"
void lexinit(void) 
{ 


  {
#line 443
  lexstop = 0;
#line 443
  dbparens = lexstop;
#line 443
  nocorrect = dbparens;
#line 444
  tok = (enum lextok )37;
#line 445
  return;
}
}
#line 450 "/tmp/zsh-5.4.2/Src/lex.c"
void add(int c ) 
{ 
  char *tmp ;
  int newbsiz ;
  void *tmp___0 ;

  {
#line 453
  tmp = lexbuf.ptr;
#line 453
  (lexbuf.ptr) ++;
#line 453
  *tmp = (char )c;
#line 454
  (lexbuf.len) ++;
#line 454
  if (lexbuf.siz == lexbuf.len) {
#line 455
    newbsiz = lexbuf.siz * 2;
#line 457
    if (newbsiz > inbufct) {
#line 457
      if (inbufct > lexbuf.siz) {
#line 458
        newbsiz = inbufct;
      }
    }
    {
#line 460
    tmp___0 = hrealloc(tokstr, (size_t )lexbuf.siz, (size_t )newbsiz);
#line 460
    tokstr = (char *)tmp___0;
#line 461
    lexbuf.ptr = tokstr + lexbuf.len;
#line 463
    memset((void *)lexbuf.ptr, 0, (size_t )(newbsiz - lexbuf.siz));
#line 464
    lexbuf.siz = newbsiz;
    }
  }
#line 466
  return;
}
}
#line 494 "/tmp/zsh-5.4.2/Src/lex.c"
static int cmd_or_math(int cs_type ) 
{ 
  int oldlen ;
  int c ;
  int oinflags ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 497
  oldlen = lexbuf.len;
#line 499
  oinflags = inbufflags;
#line 501
  cmdpush(cs_type);
#line 502
  inbufflags |= 1 << 7;
#line 503
  c = dquote_parse((char )')', 0);
  }
#line 504
  if (! (oinflags & (1 << 7))) {
#line 505
    inbufflags &= ~ (1 << 7);
  }
  {
#line 506
  cmdpop();
#line 507
  *(lexbuf.ptr) = (char )'\000';
  }
#line 508
  if (! c) {
    {
#line 510
    c = (*hgetc)();
    }
#line 511
    if (c == 41) {
#line 512
      return (1);
    }
    {
#line 513
    (*hungetc)(c);
#line 514
    lexstop = 0;
#line 515
    c = ')';
    }
  } else
#line 516
  if (lexstop) {
#line 518
    return (2);
  }
  {
#line 521
  (*hungetc)(c);
#line 522
  lexstop = 0;
  }
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (lexbuf.len > oldlen) {
#line 523
      if (! (! (errflag & 1))) {
#line 523
        goto while_break;
      }
    } else {
#line 523
      goto while_break;
    }
#line 524
    (lexbuf.len) --;
#line 525
    (lexbuf.ptr) --;
#line 525
    if ((int )typtab[(unsigned char )*(lexbuf.ptr)] & (1 << 4)) {
#line 525
      tmp = (int )ztokens[(int )*(lexbuf.ptr) - -124];
    } else {
#line 525
      tmp = (int )*(lexbuf.ptr);
    }
    {
#line 525
    (*hungetc)(tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  if (errflag) {
#line 529
    return (2);
  }
  {
#line 530
  (*hungetc)('(');
  }
#line 531
  if (errflag) {
#line 531
    tmp___0 = 2;
  } else {
#line 531
    tmp___0 = 0;
  }
#line 531
  return (tmp___0);
}
}
#line 539 "/tmp/zsh-5.4.2/Src/lex.c"
static int cmd_or_math_sub(void) 
{ 
  int c ;
  int tmp ;
  int ret ;
  int lexpos ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 542
  tmp = (*hgetc)();
#line 542
  c = tmp;
  }
#line 544
  if (c == 40) {
    {
#line 545
    lexpos = (int )(lexbuf.ptr - tokstr);
#line 546
    add(-120);
#line 547
    add('(');
#line 548
    ret = cmd_or_math(25);
    }
#line 548
    if (ret == 1) {
      {
#line 549
      *(tokstr + lexpos) = (char)-119;
#line 550
      add(')');
      }
#line 551
      return (1);
    }
#line 553
    if (ret == 2) {
#line 554
      return (2);
    }
#line 555
    lexbuf.ptr -= 2;
#line 556
    lexbuf.len -= 2;
  } else {
    {
#line 558
    (*hungetc)(c);
#line 559
    lexstop = 0;
    }
  }
  {
#line 561
  tmp___2 = skipcomm();
  }
#line 561
  if (tmp___2) {
#line 561
    tmp___1 = 2;
  } else {
#line 561
    tmp___1 = 0;
  }
#line 561
  return (tmp___1);
}
}
#line 569 "/tmp/zsh-5.4.2/Src/lex.c"
static int isnumglob(void) 
{ 
  int c ;
  int ec ;
  int ret ;
  int tbs ;
  int n ;
  char *tbuf___0 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 572
  ec = '-';
#line 572
  ret = 0;
#line 573
  tbs = 256;
#line 573
  n = 0;
#line 574
  tmp = zalloc((size_t )tbs);
#line 574
  tbuf___0 = (char *)tmp;
  }
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 577
    c = (*hgetc)();
    }
#line 578
    if (lexstop) {
#line 579
      lexstop = 0;
#line 580
      goto while_break;
    }
#line 582
    tmp___0 = n;
#line 582
    n ++;
#line 582
    *(tbuf___0 + tmp___0) = (char )c;
#line 583
    if (! ((int )typtab[(unsigned char )c] & 1)) {
#line 584
      if (c != ec) {
#line 585
        goto while_break;
      }
#line 586
      if (ec == 62) {
#line 587
        ret = 1;
#line 588
        goto while_break;
      }
#line 590
      ec = '>';
    }
#line 592
    if (n == tbs) {
      {
#line 593
      tbs *= 2;
#line 593
      tmp___1 = realloc((void *)tbuf___0, (size_t )tbs);
#line 593
      tbuf___0 = (char *)tmp___1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 595
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 595
    tmp___2 = n;
#line 595
    n --;
#line 595
    if (! tmp___2) {
#line 595
      goto while_break___0;
    }
    {
#line 596
    (*hungetc)((int )*(tbuf___0 + n));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 597
  zfree((void *)tbuf___0, tbs);
  }
#line 598
  return (ret);
}
}
#line 602 "/tmp/zsh-5.4.2/Src/lex.c"
static enum lextok gettok(void) 
{ 
  int c ;
  int d___0 ;
  int peekfd ;
  enum lextok peek ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int e ;
  int tmp___8 ;
  int tmp___9 ;
  enum lextok tmp___10 ;

  {
#line 606
  peekfd = -1;
  beginning: 
#line 610
  tokstr = (char *)((void *)0);
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 611
    c = (*hgetc)();
    }
#line 611
    if ((int )typtab[(unsigned char )c] & (1 << 2)) {
#line 611
      if (! (! lexstop)) {
#line 611
        goto while_break;
      }
    } else {
#line 611
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 612
  toklineno = lineno;
#line 613
  if (lexstop) {
#line 614
    if (errflag) {
#line 614
      tmp = 38;
    } else {
#line 614
      tmp = 37;
    }
#line 614
    return ((enum lextok )tmp);
  }
#line 615
  isfirstln = 0;
#line 616
  if (lexflags & 2) {
#line 616
    if (! (inbufflags & (1 << 1))) {
#line 617
      if (qbang) {
#line 617
        if (c == (int )bangchar) {
#line 617
          tmp___0 = 1;
        } else {
#line 617
          tmp___0 = 0;
        }
      } else {
#line 617
        tmp___0 = 0;
      }
#line 617
      wordbeg = inbufct - tmp___0;
    }
  }
#line 618
  if (qbang) {
#line 618
    if (c == (int )bangchar) {
#line 618
      tmp___1 = 1;
    } else {
#line 618
      tmp___1 = 0;
    }
  } else {
#line 618
    tmp___1 = 0;
  }
  {
#line 618
  (*hwbegin)(-1 - tmp___1);
  }
#line 620
  if (dbparens) {
    {
#line 621
    lexbuf.len = 0;
#line 622
    lexbuf.siz = 32;
#line 622
    tmp___2 = hcalloc((size_t )lexbuf.siz);
#line 622
    tokstr = (char *)tmp___2;
#line 622
    lexbuf.ptr = tokstr;
#line 623
    (*hungetc)(c);
#line 624
    cmdpush(9);
    }
#line 625
    if (infor) {
#line 625
      tmp___3 = ';';
    } else {
#line 625
      tmp___3 = ')';
    }
    {
#line 625
    c = dquote_parse((char )tmp___3, 0);
#line 626
    cmdpop();
#line 627
    *(lexbuf.ptr) = (char )'\000';
    }
#line 628
    if (! c) {
#line 628
      if (infor) {
#line 629
        infor --;
#line 630
        return ((enum lextok )28);
      }
    }
#line 632
    if (c) {
      {
#line 633
      (*hungetc)(c);
      }
#line 634
      return ((enum lextok )38);
    } else {
      {
#line 632
      c = (*hgetc)();
      }
#line 632
      if (c != 41) {
        {
#line 633
        (*hungetc)(c);
        }
#line 634
        return ((enum lextok )38);
      }
    }
#line 636
    dbparens = 0;
#line 637
    return ((enum lextok )29);
  } else
#line 638
  if ((int )typtab[(unsigned char )c] & 1) {
    {
#line 639
    d___0 = (*hgetc)();
    }
#line 640
    if (d___0 == 38) {
      {
#line 641
      d___0 = (*hgetc)();
      }
#line 642
      if (d___0 == 62) {
        {
#line 643
        peekfd = c - 48;
#line 644
        (*hungetc)('>');
#line 645
        c = '&';
        }
      } else {
        {
#line 647
        (*hungetc)(d___0);
#line 648
        lexstop = 0;
#line 649
        (*hungetc)('&');
        }
      }
    } else
#line 651
    if (d___0 == 62) {
#line 652
      peekfd = c - 48;
#line 653
      c = d___0;
    } else
#line 651
    if (d___0 == 60) {
#line 652
      peekfd = c - 48;
#line 653
      c = d___0;
    } else {
      {
#line 655
      (*hungetc)(d___0);
#line 656
      lexstop = 0;
      }
    }
  }
#line 667
  if (c == (int )hashchar) {
#line 667
    if (! nocomments) {
#line 667
      if (opts[94]) {
#line 667
        goto _L___0;
      } else
#line 667
      if (! lexflags) {
#line 667
        goto _L___1;
      } else
#line 667
      if (lexflags & 12) {
        _L___1: /* CIL Label */ 
#line 667
        if (! expanding) {
#line 667
          if (! opts[93]) {
#line 667
            goto _L___0;
          } else
#line 667
          if (! opts[160]) {
#line 667
            goto _L___0;
          } else
#line 667
          if (strin) {
            _L___0: /* CIL Label */ 
#line 674
            if (lexflags & 4) {
              {
#line 675
              lexbuf.len = 0;
#line 676
              lexbuf.siz = 32;
#line 676
              tmp___4 = hcalloc((size_t )lexbuf.siz);
#line 676
              tokstr = (char *)tmp___4;
#line 676
              lexbuf.ptr = tokstr;
#line 678
              add(c);
              }
            }
            {
#line 680
            (*hwend)();
            }
            {
#line 681
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 681
              c = ingetc();
              }
#line 681
              if (c != 10) {
#line 681
                if (! (! lexstop)) {
#line 681
                  goto while_break___0;
                }
              } else {
#line 681
                goto while_break___0;
              }
              {
#line 682
              (*hwaddc)(c);
#line 683
              (*addtoline)(c);
              }
#line 684
              if (lexflags & 4) {
                {
#line 685
                add(c);
                }
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 688
            if (errflag) {
#line 689
              peek = (enum lextok )38;
            } else
#line 691
            if (lexflags & 4) {
#line 692
              *(lexbuf.ptr) = (char )'\000';
#line 693
              if (! lexstop) {
                {
#line 694
                (*hungetc)(c);
                }
              }
#line 695
              peek = (enum lextok )34;
            } else {
              {
#line 697
              (*hwend)();
#line 698
              (*hwbegin)(0);
#line 699
              (*hwaddc)('\n');
#line 700
              (*addtoline)('\n');
              }
#line 706
              if (lexflags & 8) {
#line 706
                if (lexstop) {
#line 707
                  peek = (enum lextok )37;
                } else {
#line 709
                  peek = (enum lextok )2;
                }
              } else {
#line 709
                peek = (enum lextok )2;
              }
            }
#line 712
            return (peek);
          }
        }
      }
    }
  }
  {
#line 715
  if ((int )lexact1[(unsigned char )c] == 0) {
#line 715
    goto case_0;
  }
#line 722
  if ((int )lexact1[(unsigned char )c] == 2) {
#line 722
    goto case_2;
  }
#line 724
  if ((int )lexact1[(unsigned char )c] == 3) {
#line 724
    goto case_3;
  }
#line 735
  if ((int )lexact1[(unsigned char )c] == 5) {
#line 735
    goto case_5;
  }
#line 761
  if ((int )lexact1[(unsigned char )c] == 6) {
#line 761
    goto case_6;
  }
#line 770
  if ((int )lexact1[(unsigned char )c] == 7) {
#line 770
    goto case_7;
  }
#line 813
  if ((int )lexact1[(unsigned char )c] == 8) {
#line 813
    goto case_8;
  }
#line 815
  if ((int )lexact1[(unsigned char )c] == 13) {
#line 815
    goto case_13;
  }
#line 855
  if ((int )lexact1[(unsigned char )c] == 14) {
#line 855
    goto case_14;
  }
#line 714
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 716
  d___0 = (*hgetc)();
  }
#line 717
  if (d___0 == 10) {
#line 718
    goto beginning;
  }
  {
#line 719
  (*hungetc)(d___0);
#line 720
  lexstop = 0;
  }
#line 721
  goto switch_break;
  case_2: /* CIL Label */ 
#line 723
  return ((enum lextok )2);
  case_3: /* CIL Label */ 
  {
#line 725
  d___0 = (*hgetc)();
  }
#line 726
  if (d___0 == 59) {
#line 727
    return ((enum lextok )4);
  } else
#line 728
  if (d___0 == 38) {
#line 729
    return ((enum lextok )31);
  } else
#line 730
  if (d___0 == 124) {
#line 731
    return ((enum lextok )32);
  }
  {
#line 732
  (*hungetc)(d___0);
#line 733
  lexstop = 0;
  }
#line 734
  return ((enum lextok )3);
  case_5: /* CIL Label */ 
  {
#line 736
  d___0 = (*hgetc)();
  }
#line 737
  if (d___0 == 38) {
#line 738
    return ((enum lextok )9);
  } else
#line 739
  if (d___0 == 33) {
#line 740
    return ((enum lextok )30);
  } else
#line 739
  if (d___0 == 124) {
#line 740
    return ((enum lextok )30);
  } else
#line 741
  if (d___0 == 62) {
    {
#line 742
    tokfd = peekfd;
#line 743
    d___0 = (*hgetc)();
    }
#line 744
    if (d___0 == 33) {
#line 745
      return ((enum lextok )21);
    } else
#line 744
    if (d___0 == 124) {
#line 745
      return ((enum lextok )21);
    } else
#line 746
    if (d___0 == 62) {
      {
#line 747
      d___0 = (*hgetc)();
      }
#line 748
      if (d___0 == 33) {
#line 749
        return ((enum lextok )23);
      } else
#line 748
      if (d___0 == 124) {
#line 749
        return ((enum lextok )23);
      }
      {
#line 750
      (*hungetc)(d___0);
#line 751
      lexstop = 0;
      }
#line 752
      return ((enum lextok )22);
    }
    {
#line 754
    (*hungetc)(d___0);
#line 755
    lexstop = 0;
    }
#line 756
    return ((enum lextok )20);
  }
  {
#line 758
  (*hungetc)(d___0);
#line 759
  lexstop = 0;
  }
#line 760
  return ((enum lextok )5);
  case_6: /* CIL Label */ 
  {
#line 762
  d___0 = (*hgetc)();
  }
#line 763
  if (d___0 == 124) {
#line 763
    if (! incasepat) {
#line 764
      return ((enum lextok )8);
    } else {
#line 763
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 765
  if (d___0 == 38) {
#line 766
    return ((enum lextok )26);
  }
  {
#line 767
  (*hungetc)(d___0);
#line 768
  lexstop = 0;
  }
#line 769
  return ((enum lextok )25);
  case_7: /* CIL Label */ 
  {
#line 771
  d___0 = (*hgetc)();
  }
#line 772
  if (d___0 == 40) {
#line 773
    if (infor) {
#line 774
      dbparens = 1;
#line 775
      return ((enum lextok )28);
    }
#line 777
    if (incmdpos) {
#line 777
      goto _L___3;
    } else
#line 777
    if (opts[159]) {
#line 777
      if (! opts[97]) {
        _L___3: /* CIL Label */ 
        {
#line 778
        lexbuf.len = 0;
#line 779
        lexbuf.siz = 32;
#line 779
        tmp___5 = hcalloc((size_t )lexbuf.siz);
#line 779
        tokstr = (char *)tmp___5;
#line 779
        lexbuf.ptr = tokstr;
#line 781
        tmp___6 = cmd_or_math(9);
        }
        {
#line 782
        if (tmp___6 == 1) {
#line 782
          goto case_1;
        }
#line 785
        if (tmp___6 == 0) {
#line 785
          goto case_0___0;
        }
#line 793
        if (tmp___6 == 2) {
#line 793
          goto case_2___0;
        }
#line 802
        goto switch_default;
        case_1: /* CIL Label */ 
#line 783
        return ((enum lextok )28);
        case_0___0: /* CIL Label */ 
#line 790
        tokstr = (char *)((void *)0);
#line 791
        return ((enum lextok )6);
        case_2___0: /* CIL Label */ 
#line 798
        if (lexflags & 1) {
#line 799
          if (tokstr) {
#line 799
            tmp___7 = (char const   *)tokstr;
          } else {
#line 799
            tmp___7 = "";
          }
          {
#line 799
          tokstr = dyncat("((", tmp___7);
          }
        }
        switch_default: /* CIL Label */ 
#line 803
        return ((enum lextok )38);
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
  } else
#line 806
  if (d___0 == 41) {
#line 807
    return ((enum lextok )27);
  }
  {
#line 808
  (*hungetc)(d___0);
#line 809
  lexstop = 0;
  }
#line 810
  if (! opts[159]) {
#line 810
    if (! (incond == 1)) {
#line 810
      if (! incmdpos) {
#line 811
        goto switch_break;
      }
    }
  }
#line 812
  return ((enum lextok )6);
  case_8: /* CIL Label */ 
#line 814
  return ((enum lextok )7);
  case_13: /* CIL Label */ 
  {
#line 816
  d___0 = (*hgetc)();
  }
#line 817
  if (d___0 == 40) {
    {
#line 818
    (*hungetc)(d___0);
#line 819
    lexstop = 0;
    }
    unpeekfd: 
#line 821
    if (peekfd != -1) {
      {
#line 822
      (*hungetc)(c);
#line 823
      c = 48 + peekfd;
      }
    }
#line 825
    goto switch_break;
  }
#line 827
  if (d___0 == 62) {
#line 828
    peek = (enum lextok )15;
  } else
#line 829
  if (d___0 == 60) {
    {
#line 830
    tmp___8 = (*hgetc)();
#line 830
    e = tmp___8;
    }
#line 832
    if (e == 40) {
      {
#line 833
      (*hungetc)(e);
#line 834
      (*hungetc)(d___0);
#line 835
      peek = (enum lextok )14;
      }
    } else
#line 836
    if (e == 60) {
#line 837
      peek = (enum lextok )24;
    } else
#line 838
    if (e == 45) {
#line 839
      peek = (enum lextok )17;
    } else {
      {
#line 841
      (*hungetc)(e);
#line 842
      lexstop = 0;
#line 843
      peek = (enum lextok )16;
      }
    }
  } else
#line 845
  if (d___0 == 38) {
#line 846
    peek = (enum lextok )18;
  } else {
    {
#line 848
    (*hungetc)(d___0);
#line 849
    tmp___9 = isnumglob();
    }
#line 849
    if (tmp___9) {
#line 850
      goto unpeekfd;
    }
#line 851
    peek = (enum lextok )14;
  }
#line 853
  tokfd = peekfd;
#line 854
  return (peek);
  case_14: /* CIL Label */ 
  {
#line 856
  d___0 = (*hgetc)();
  }
#line 857
  if (d___0 == 40) {
    {
#line 858
    (*hungetc)(d___0);
    }
#line 859
    goto unpeekfd;
  } else
#line 860
  if (d___0 == 38) {
    {
#line 861
    d___0 = (*hgetc)();
    }
#line 862
    if (d___0 == 33) {
#line 863
      peek = (enum lextok )21;
    } else
#line 862
    if (d___0 == 124) {
#line 863
      peek = (enum lextok )21;
    } else {
      {
#line 865
      (*hungetc)(d___0);
#line 866
      lexstop = 0;
#line 867
      peek = (enum lextok )19;
      }
    }
  } else
#line 869
  if (d___0 == 33) {
#line 870
    peek = (enum lextok )11;
  } else
#line 869
  if (d___0 == 124) {
#line 870
    peek = (enum lextok )11;
  } else
#line 871
  if (d___0 == 62) {
    {
#line 872
    d___0 = (*hgetc)();
    }
#line 873
    if (d___0 == 38) {
      {
#line 874
      d___0 = (*hgetc)();
      }
#line 875
      if (d___0 == 33) {
#line 876
        peek = (enum lextok )23;
      } else
#line 875
      if (d___0 == 124) {
#line 876
        peek = (enum lextok )23;
      } else {
        {
#line 878
        (*hungetc)(d___0);
#line 879
        lexstop = 0;
#line 880
        peek = (enum lextok )22;
        }
      }
    } else
#line 882
    if (d___0 == 33) {
#line 883
      peek = (enum lextok )13;
    } else
#line 882
    if (d___0 == 124) {
#line 883
      peek = (enum lextok )13;
    } else
#line 884
    if (d___0 == 40) {
      {
#line 885
      (*hungetc)(d___0);
#line 886
      (*hungetc)('>');
#line 887
      peek = (enum lextok )10;
      }
    } else {
      {
#line 889
      (*hungetc)(d___0);
#line 890
      lexstop = 0;
#line 891
      peek = (enum lextok )12;
      }
#line 892
      if (opts[71]) {
        {
#line 893
        (*hwaddc)('|');
        }
      }
    }
  } else {
    {
#line 896
    (*hungetc)(d___0);
#line 897
    lexstop = 0;
#line 898
    peek = (enum lextok )10;
    }
#line 899
    if (! incond) {
#line 899
      if (opts[71]) {
        {
#line 900
        (*hwaddc)('|');
        }
      }
    }
  }
#line 902
  tokfd = peekfd;
#line 903
  return (peek);
  switch_break: /* CIL Label */ ;
  }
  {
#line 908
  tmp___10 = gettokstr(c, 0);
  }
#line 908
  return (tmp___10);
}
}
#line 925 "/tmp/zsh-5.4.2/Src/lex.c"
static enum lextok gettokstr(int c , int sub ) 
{ 
  int bct ;
  int pct ;
  int brct ;
  int seen_brct ;
  int fdpar ;
  int intpos ;
  int in_brace_param ;
  int inquote ;
  int unmatched ;
  enum lextok peek ;
  void *tmp ;
  int act ;
  int e ;
  int inbl ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *t ;
  int sav ;
  int strquote ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 928
  bct = 0;
#line 928
  pct = 0;
#line 928
  brct = 0;
#line 928
  seen_brct = 0;
#line 928
  fdpar = 0;
#line 929
  intpos = 1;
#line 929
  in_brace_param = 0;
#line 930
  unmatched = 0;
#line 936
  peek = (enum lextok )34;
#line 937
  if (! sub) {
    {
#line 938
    lexbuf.len = 0;
#line 939
    lexbuf.siz = 32;
#line 939
    tmp = hcalloc((size_t )lexbuf.siz);
#line 939
    tokstr = (char *)tmp;
#line 939
    lexbuf.ptr = tokstr;
    }
  }
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    inbl = (int )typtab[(unsigned char )c] & (1 << 3);
#line 946
    if (fdpar) {
#line 946
      if (! inbl) {
#line 946
        if (c != 41) {
#line 947
          fdpar = 0;
        }
      }
    }
#line 949
    if (inbl) {
#line 949
      if (! in_brace_param) {
#line 949
        if (! pct) {
#line 950
          act = 0;
        } else {
#line 952
          act = (int )lexact2[(unsigned char )c];
#line 953
          c = (int )lextok2[(unsigned char )c];
        }
      } else {
#line 952
        act = (int )lexact2[(unsigned char )c];
#line 953
        c = (int )lextok2[(unsigned char )c];
      }
    } else {
#line 952
      act = (int )lexact2[(unsigned char )c];
#line 953
      c = (int )lextok2[(unsigned char )c];
    }
    {
#line 956
    if (act == 0) {
#line 956
      goto case_0;
    }
#line 960
    if (act == 21) {
#line 960
      goto case_21;
    }
#line 971
    if (act == 1) {
#line 971
      goto case_1;
    }
#line 989
    if (act == 2) {
#line 989
      goto case_2;
    }
#line 999
    if (act == 3) {
#line 999
      goto case_3;
    }
#line 1043
    if (act == 4) {
#line 1043
      goto case_4;
    }
#line 1050
    if (act == 5) {
#line 1050
      goto case_5;
    }
#line 1057
    if (act == 7) {
#line 1057
      goto case_7;
    }
#line 1116
    if (act == 8) {
#line 1116
      goto case_8;
    }
#line 1131
    if (act == 9) {
#line 1131
      goto case_9;
    }
#line 1143
    if (act == 17) {
#line 1143
      goto case_17;
    }
#line 1147
    if (act == 10) {
#line 1147
      goto case_10;
    }
#line 1163
    if (act == 11) {
#line 1163
      goto case_11;
    }
#line 1188
    if (act == 12) {
#line 1188
      goto case_12;
    }
#line 1237
    if (act == 13) {
#line 1237
      goto case_13;
    }
#line 1260
    if (act == 14) {
#line 1260
      goto case_14;
    }
#line 1309
    if (act == 15) {
#line 1309
      goto case_15;
    }
#line 1321
    if (act == 16) {
#line 1321
      goto case_16;
    }
#line 1359
    if (act == 18) {
#line 1359
      goto case_18;
    }
#line 1370
    if (act == 19) {
#line 1370
      goto case_19;
    }
#line 955
    goto switch_break;
    case_0: /* CIL Label */ 
#line 957
    if (! in_brace_param) {
#line 957
      if (! sub) {
#line 958
        goto brk;
      }
    }
#line 959
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 961
    c = (*hgetc)();
#line 969
    add(-125);
    }
#line 970
    goto switch_break;
    case_1: /* CIL Label */ 
#line 972
    if (fdpar) {
      {
#line 974
      add(c);
#line 975
      *(lexbuf.ptr) = (char )'\000';
      }
#line 976
      return ((enum lextok )27);
    }
#line 978
    if (sub) {
#line 978
      goto _L;
    } else
#line 978
    if (in_brace_param) {
      _L: /* CIL Label */ 
#line 978
      if (opts[159]) {
#line 979
        goto switch_break;
      }
    }
#line 980
    if (! in_brace_param) {
#line 980
      tmp___0 = pct;
#line 980
      pct --;
#line 980
      if (! tmp___0) {
#line 981
        if (sub) {
#line 982
          pct = 0;
#line 983
          goto switch_break;
        } else {
#line 985
          goto brk;
        }
      }
    }
#line 987
    c = -118;
#line 988
    goto switch_break;
    case_2: /* CIL Label */ 
#line 990
    if (! pct) {
#line 990
      if (! in_brace_param) {
#line 991
        if (sub) {
#line 992
          goto switch_break;
        } else {
#line 994
          goto brk;
        }
      }
    }
#line 996
    if (! opts[159]) {
#line 997
      c = -114;
    } else
#line 996
    if (! sub) {
#line 996
      if (! in_brace_param) {
#line 997
        c = -114;
      }
    }
#line 998
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1000
    e = (*hgetc)();
    }
#line 1001
    if (e == 91) {
      {
#line 1002
      cmdpush(25);
#line 1003
      add(-123);
#line 1004
      add(-111);
#line 1005
      c = dquote_parse((char )']', sub);
#line 1006
      cmdpop();
      }
#line 1007
      if (c) {
#line 1008
        peek = (enum lextok )38;
#line 1009
        goto brk;
      }
#line 1011
      c = -110;
    } else
#line 1012
    if (e == 40) {
      {
#line 1013
      add(-123);
#line 1014
      tmp___1 = cmd_or_math_sub();
      }
      {
#line 1015
      if (tmp___1 == 0) {
#line 1015
        goto case_0___0;
      }
#line 1019
      if (tmp___1 == 1) {
#line 1019
        goto case_1___0;
      }
#line 1023
      goto switch_default;
      case_0___0: /* CIL Label */ 
#line 1016
      c = -118;
#line 1017
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1020
      c = -117;
#line 1021
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 1024
      peek = (enum lextok )38;
#line 1025
      goto brk;
      switch_break___0: /* CIL Label */ ;
      }
    } else
#line 1028
    if (e == 123) {
      {
#line 1029
      add(c);
#line 1030
      c = -113;
#line 1031
      bct ++;
#line 1032
      cmdpush(30);
      }
#line 1033
      if (! in_brace_param) {
#line 1034
        in_brace_param = bct;
#line 1034
        if (in_brace_param) {
#line 1035
          seen_brct = 0;
        }
      }
    } else {
      {
#line 1038
      (*hungetc)(e);
#line 1039
      lexstop = 0;
      }
    }
#line 1042
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1044
    if (! in_brace_param) {
#line 1045
      brct ++;
#line 1046
      seen_brct = 1;
    }
#line 1048
    c = -111;
#line 1049
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1051
    if (! in_brace_param) {
#line 1052
      brct --;
    }
#line 1053
    if (brct < 0) {
#line 1054
      brct = 0;
    }
#line 1055
    c = -110;
#line 1056
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1058
    if (opts[159]) {
#line 1059
      if (sub) {
#line 1060
        goto switch_break;
      } else
#line 1059
      if (in_brace_param) {
#line 1060
        goto switch_break;
      }
#line 1061
      if (incasepat > 0) {
#line 1061
        if (! lexbuf.len) {
#line 1062
          return ((enum lextok )6);
        }
      }
#line 1063
      if (! opts[97]) {
#line 1063
        if (lexbuf.len) {
#line 1064
          goto brk;
        }
      }
    }
#line 1066
    if (! in_brace_param) {
#line 1067
      if (! sub) {
        {
#line 1068
        e = (*hgetc)();
#line 1069
        (*hungetc)(e);
#line 1070
        lexstop = 0;
        }
#line 1091
        if (e == 41) {
#line 1099
          nocorrect |= 2;
#line 1100
          goto brk;
        } else
#line 1091
        if (opts[159]) {
#line 1091
          if ((int )typtab[(unsigned char )e] & (1 << 3)) {
#line 1091
            if (! bct) {
#line 1091
              if (! brct) {
#line 1091
                if (! intpos) {
#line 1091
                  if (incmdpos) {
#line 1099
                    nocorrect |= 2;
#line 1100
                    goto brk;
                  }
                }
              }
            }
          }
        }
      }
#line 1111
      tmp___2 = pct;
#line 1111
      pct ++;
#line 1111
      if (! tmp___2) {
#line 1111
        if (opts[159]) {
#line 1111
          if (intpos) {
#line 1111
            if (! bct) {
#line 1111
              if (! brct) {
#line 1112
                fdpar = 1;
              }
            }
          }
        }
      }
    }
#line 1114
    c = -120;
#line 1115
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1117
    if (opts[88]) {
#line 1118
      c = '{';
    } else
#line 1117
    if (sub) {
#line 1118
      c = '{';
    } else {
#line 1120
      if (! lexbuf.len) {
#line 1120
        if (incmdpos) {
          {
#line 1121
          add('{');
#line 1122
          *(lexbuf.ptr) = (char )'\000';
          }
#line 1123
          return ((enum lextok )34);
        }
      }
#line 1125
      if (in_brace_param) {
        {
#line 1126
        cmdpush(29);
        }
      }
#line 1128
      bct ++;
    }
#line 1130
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1132
    if (opts[88]) {
#line 1132
      goto _L___0;
    } else
#line 1132
    if (sub) {
      _L___0: /* CIL Label */ 
#line 1132
      if (! in_brace_param) {
#line 1133
        goto switch_break;
      }
    }
#line 1134
    if (! bct) {
#line 1135
      goto switch_break;
    }
#line 1136
    if (in_brace_param) {
      {
#line 1137
      cmdpop();
      }
    }
#line 1139
    tmp___3 = bct;
#line 1139
    bct --;
#line 1139
    if (tmp___3 == in_brace_param) {
#line 1140
      in_brace_param = 0;
    }
#line 1141
    c = -112;
#line 1142
    goto switch_break;
    case_17: /* CIL Label */ 
#line 1144
    if (! opts[88]) {
#line 1144
      if (! sub) {
#line 1144
        if (bct > in_brace_param) {
#line 1145
          c = -102;
        }
      }
    }
#line 1146
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1148
    if (in_brace_param) {
#line 1149
      goto switch_break;
    } else
#line 1148
    if (sub) {
#line 1149
      goto switch_break;
    }
    {
#line 1150
    e = (*hgetc)();
    }
#line 1151
    if (e != 40) {
      {
#line 1152
      (*hungetc)(e);
#line 1153
      lexstop = 0;
      }
#line 1154
      goto brk;
    }
    {
#line 1156
    add(-106);
#line 1157
    tmp___4 = skipcomm();
    }
#line 1157
    if (tmp___4) {
#line 1158
      peek = (enum lextok )38;
#line 1159
      goto brk;
    }
#line 1161
    c = -118;
#line 1162
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1164
    if (opts[159]) {
#line 1164
      if (sub) {
#line 1165
        goto switch_break;
      }
    }
    {
#line 1166
    e = (*hgetc)();
    }
#line 1167
    if (! in_brace_param) {
#line 1167
      if (! sub) {
#line 1167
        if (e == 40) {
          {
#line 1168
          add(-108);
#line 1169
          tmp___5 = skipcomm();
          }
#line 1169
          if (tmp___5) {
#line 1170
            peek = (enum lextok )38;
#line 1171
            goto brk;
          }
#line 1173
          c = -118;
#line 1174
          goto switch_break;
        }
      }
    }
    {
#line 1176
    (*hungetc)(e);
#line 1177
    tmp___6 = isnumglob();
    }
#line 1177
    if (tmp___6) {
      {
#line 1178
      add(-108);
      }
      {
#line 1179
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1179
        c = (*hgetc)();
        }
#line 1179
        if (! (c != 62)) {
#line 1179
          goto while_break___0;
        }
        {
#line 1180
        add(c);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1181
      c = -107;
#line 1182
      goto switch_break;
    }
#line 1184
    lexstop = 0;
#line 1185
    if (in_brace_param) {
#line 1186
      goto switch_break;
    } else
#line 1185
    if (sub) {
#line 1186
      goto switch_break;
    }
#line 1187
    goto brk;
    case_12: /* CIL Label */ 
#line 1189
    if (! sub) {
#line 1190
      if (intpos) {
        {
#line 1191
        e = (*hgetc)();
        }
#line 1192
        if (e != 40) {
          {
#line 1193
          (*hungetc)(e);
#line 1194
          lexstop = 0;
#line 1195
          c = -115;
          }
        } else {
          {
#line 1197
          add(-115);
#line 1198
          tmp___7 = skipcomm();
          }
#line 1198
          if (tmp___7) {
#line 1199
            peek = (enum lextok )38;
#line 1200
            goto brk;
          }
#line 1202
          c = -118;
        }
      } else
#line 1204
      if ((unsigned int )peek != 35U) {
#line 1204
        if (incmdpos) {
#line 1204
          goto _L___1;
        } else
#line 1204
        if (intypeset) {
          _L___1: /* CIL Label */ 
#line 1204
          if (! bct) {
#line 1204
            if (! brct) {
#line 1206
              t = tokstr;
#line 1207
              if ((int )typtab[(unsigned char )*t] & 1) {
                {
#line 1208
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 1208
                  t ++;
#line 1208
                  if ((unsigned long )t < (unsigned long )lexbuf.ptr) {
#line 1208
                    if (! ((int )typtab[(unsigned char )*t] & 1)) {
#line 1208
                      goto while_break___1;
                    }
                  } else {
#line 1208
                    goto while_break___1;
                  }
                }
                while_break___1: /* CIL Label */ ;
                }
              } else {
                {
#line 1210
                sav = (int )*(lexbuf.ptr);
#line 1211
                *(lexbuf.ptr) = (char )'\000';
#line 1212
                t = itype_end((char const   *)t, 1 << 7, 0);
                }
#line 1213
                if ((unsigned long )t < (unsigned long )lexbuf.ptr) {
                  {
#line 1214
                  skipparens((char)-111, (char)-110, & t);
                  }
                } else {
#line 1216
                  *(lexbuf.ptr) = (char )sav;
                }
              }
#line 1219
              if ((int )*t == 43) {
#line 1220
                t ++;
              }
#line 1221
              if ((unsigned long )t == (unsigned long )lexbuf.ptr) {
                {
#line 1222
                e = (*hgetc)();
                }
#line 1223
                if (e == 40) {
#line 1224
                  *(lexbuf.ptr) = (char )'\000';
#line 1225
                  return ((enum lextok )36);
                }
                {
#line 1227
                (*hungetc)(e);
#line 1228
                lexstop = 0;
#line 1229
                peek = (enum lextok )35;
#line 1230
                intpos = 2;
                }
              } else {
#line 1232
                c = -115;
              }
            } else {
#line 1234
              c = -115;
            }
          } else {
#line 1234
            c = -115;
          }
        } else {
#line 1234
          c = -115;
        }
      } else {
#line 1234
        c = -115;
      }
    }
#line 1236
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 1238
    c = (*hgetc)();
    }
#line 1239
    if (c == 10) {
      {
#line 1240
      c = (*hgetc)();
      }
#line 1241
      if (! lexstop) {
#line 1242
        goto __Cont;
      }
    } else {
      {
#line 1244
      add(-97);
      }
#line 1245
      if (c == 131) {
        {
#line 1246
        c = (*hgetc)();
#line 1254
        add(-125);
        }
      }
    }
#line 1257
    if (lexstop) {
#line 1258
      goto brk;
    }
#line 1259
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1261
    if (lexbuf.len) {
#line 1261
      if ((int )*(lexbuf.ptr + -1) == -123) {
#line 1261
        tmp___8 = 1;
      } else {
#line 1261
        tmp___8 = 0;
      }
    } else {
#line 1261
      tmp___8 = 0;
    }
    {
#line 1261
    strquote = tmp___8;
#line 1263
    add(-99);
#line 1264
    cmdpush(21);
    }
    {
#line 1265
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1266
      stophist += 4;
      {
#line 1267
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1267
        c = (*hgetc)();
        }
#line 1267
        if (c != 39) {
#line 1267
          if (! (! lexstop)) {
#line 1267
            goto while_break___3;
          }
        } else {
#line 1267
          goto while_break___3;
        }
#line 1268
        if (strquote) {
#line 1268
          if (c == 92) {
            {
#line 1269
            c = (*hgetc)();
            }
#line 1270
            if (lexstop) {
#line 1271
              goto while_break___3;
            }
#line 1279
            if (c == 92) {
              {
#line 1280
              add(-97);
              }
            } else
#line 1279
            if (c == 39) {
              {
#line 1280
              add(-97);
              }
            } else {
              {
#line 1282
              add('\\');
              }
            }
          } else {
#line 1268
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 1283
        if (! sub) {
#line 1283
          if (opts[44]) {
#line 1283
            if (c == 10) {
#line 1284
              if ((int )*(lexbuf.ptr + -1) == 92) {
#line 1285
                (lexbuf.ptr) --;
#line 1285
                (lexbuf.len) --;
              } else {
#line 1287
                goto while_break___3;
              }
            }
          }
        }
        {
#line 1289
        add(c);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1291
      stophist -= 4;
#line 1292
      if (c != 39) {
        {
#line 1293
        unmatched = '\'';
#line 1294
        peek = (enum lextok )38;
#line 1295
        cmdpop();
        }
#line 1296
        goto brk;
      }
      {
#line 1298
      e = (*hgetc)();
      }
#line 1299
      if (e != 39) {
#line 1300
        goto while_break___2;
      } else
#line 1299
      if (! opts[150]) {
#line 1300
        goto while_break___2;
      } else
#line 1299
      if (strquote) {
#line 1300
        goto while_break___2;
      }
      {
#line 1301
      add(c);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1303
    cmdpop();
#line 1304
    (*hungetc)(e);
#line 1305
    lexstop = 0;
#line 1306
    c = -99;
    }
#line 1307
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 1310
    add(-98);
#line 1311
    cmdpush(22);
#line 1312
    c = dquote_parse((char )'\"', sub);
#line 1313
    cmdpop();
    }
#line 1314
    if (c) {
#line 1315
      unmatched = '\"';
#line 1316
      peek = (enum lextok )38;
#line 1317
      goto brk;
    }
#line 1319
    c = -98;
#line 1320
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 1322
    add(-109);
#line 1323
    cmdpush(23);
    }
#line 1324
    if (lexflags & 2) {
#line 1324
      if (! (inbufflags & (1 << 1))) {
#line 1324
        if (zlemetacs >= (zlemetall + 1) - inbufct) {
#line 1324
          parbegin = inbufct;
        }
      }
    }
#line 1325
    inquote = 0;
    {
#line 1326
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1326
      c = (*hgetc)();
      }
#line 1326
      if (c != 96) {
#line 1326
        if (! (! lexstop)) {
#line 1326
          goto while_break___4;
        }
      } else {
#line 1326
        goto while_break___4;
      }
#line 1327
      if (c == 92) {
        {
#line 1328
        c = (*hgetc)();
        }
#line 1329
        if (c != 10) {
#line 1330
          if (c == 96) {
#line 1330
            tmp___9 = -97;
          } else
#line 1330
          if (c == 92) {
#line 1330
            tmp___9 = -97;
          } else
#line 1330
          if (c == 36) {
#line 1330
            tmp___9 = -97;
          } else {
#line 1330
            tmp___9 = '\\';
          }
          {
#line 1330
          add(tmp___9);
#line 1331
          add(c);
          }
        } else
#line 1333
        if (! sub) {
#line 1333
          if (opts[44]) {
            {
#line 1334
            add(c);
            }
          }
        }
      } else {
#line 1336
        if (! sub) {
#line 1336
          if (opts[44]) {
#line 1336
            if (c == 10) {
#line 1337
              goto while_break___4;
            }
          }
        }
        {
#line 1339
        add(c);
        }
#line 1340
        if (c == 39) {
#line 1341
          inquote = ! inquote;
#line 1341
          if (inquote) {
#line 1342
            stophist += 4;
          } else {
#line 1344
            stophist -= 4;
          }
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1348
    if (inquote) {
#line 1349
      stophist -= 4;
    }
    {
#line 1350
    cmdpop();
    }
#line 1351
    if (c != 96) {
#line 1352
      unmatched = '`';
#line 1353
      peek = (enum lextok )38;
#line 1354
      goto brk;
    }
#line 1356
    c = -109;
#line 1357
    if (lexflags & 2) {
#line 1357
      if (! (inbufflags & (1 << 1))) {
#line 1357
        if (parbegin != -1) {
#line 1357
          if (parend == -1) {
#line 1357
            if (zlemetacs >= (zlemetall + 1) - inbufct) {
#line 1357
              parbegin = -1;
            } else {
#line 1357
              parend = inbufct;
            }
          }
        }
      }
    }
#line 1358
    goto switch_break;
    case_18: /* CIL Label */ 
#line 1368
    c = -101;
#line 1369
    goto switch_break;
    case_19: /* CIL Label */ 
#line 1374
    if (seen_brct) {
#line 1375
      c = -100;
    } else {
#line 1377
      c = '!';
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 1379
    add(c);
#line 1380
    c = (*hgetc)();
    }
#line 1381
    if (intpos) {
#line 1382
      intpos --;
    }
#line 1383
    if (lexstop) {
#line 1384
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  brk: 
#line 1387
  if (errflag) {
#line 1388
    if (in_brace_param) {
      {
#line 1389
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1389
        tmp___10 = bct;
#line 1389
        bct --;
#line 1389
        if (! (tmp___10 >= in_brace_param)) {
#line 1389
          goto while_break___5;
        }
        {
#line 1390
        cmdpop();
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1392
    return ((enum lextok )38);
  }
  {
#line 1394
  (*hungetc)(c);
  }
#line 1395
  if (unmatched) {
    {
#line 1396
    zerr("unmatched %c", unmatched);
    }
  }
#line 1397
  if (in_brace_param) {
    {
#line 1398
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1398
      tmp___11 = bct;
#line 1398
      bct --;
#line 1398
      if (! (tmp___11 >= in_brace_param)) {
#line 1398
        goto while_break___6;
      }
      {
#line 1399
      cmdpop();
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 1400
    zerr("closing brace expected");
    }
  } else
#line 1401
  if (! opts[88]) {
#line 1401
    if (! sub) {
#line 1401
      if (lexbuf.len > 1) {
#line 1401
        if ((unsigned int )peek == 34U) {
#line 1401
          if ((int )*(lexbuf.ptr + -1) == 125) {
#line 1401
            if ((int )*(lexbuf.ptr + -2) != -97) {
              {
#line 1405
              (lexbuf.ptr) --;
#line 1406
              (lexbuf.len) --;
#line 1407
              lexstop = 0;
#line 1408
              (*hungetc)('}');
              }
            }
          }
        }
      }
    }
  }
#line 1410
  *(lexbuf.ptr) = (char )'\000';
#line 1412
  return (peek);
}
}
#line 1424 "/tmp/zsh-5.4.2/Src/lex.c"
static int dquote_parse(char endchar , int sub ) 
{ 
  int pct ;
  int brct ;
  int bct ;
  int intick ;
  int err ;
  int c ;
  int math ;
  int tmp ;
  int zlemath ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1427
  pct = 0;
#line 1427
  brct = 0;
#line 1427
  bct = 0;
#line 1427
  intick = 0;
#line 1427
  err = 0;
#line 1429
  if ((int )endchar == 41) {
#line 1429
    tmp = 1;
  } else
#line 1429
  if ((int )endchar == 93) {
#line 1429
    tmp = 1;
  } else
#line 1429
  if (infor) {
#line 1429
    tmp = 1;
  } else {
#line 1429
    tmp = 0;
  }
#line 1429
  math = tmp;
#line 1430
  if (math) {
#line 1430
    if (zlemetacs > (zlemetall + addedx) - inbufct) {
#line 1430
      tmp___0 = 1;
    } else {
#line 1430
      tmp___0 = 0;
    }
  } else {
#line 1430
    tmp___0 = 0;
  }
#line 1430
  zlemath = tmp___0;
  {
#line 1432
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1432
    c = (*hgetc)();
    }
#line 1432
    if (c != (int )endchar) {
#line 1432
      goto _L___3;
    } else
#line 1432
    if (bct) {
#line 1432
      goto _L___3;
    } else
#line 1432
    if (math) {
#line 1432
      if (pct > 0) {
#line 1432
        goto _L___3;
      } else
#line 1432
      if (brct > 0) {
#line 1432
        goto _L___3;
      } else {
#line 1432
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1432
    if (intick) {
      _L___3: /* CIL Label */ 
#line 1432
      if (! (! lexstop)) {
#line 1432
        goto while_break;
      }
    } else {
#line 1432
      goto while_break;
    }
    cont: 
    {
#line 1437
    if (c == 92) {
#line 1437
      goto case_92;
    }
#line 1455
    if (c == 10) {
#line 1455
      goto case_10;
    }
#line 1458
    if (c == 36) {
#line 1458
      goto case_36;
    }
#line 1497
    if (c == 125) {
#line 1497
      goto case_125;
    }
#line 1504
    if (c == 96) {
#line 1504
      goto case_96;
    }
#line 1516
    if (c == 39) {
#line 1516
      goto case_39;
    }
#line 1524
    if (c == 40) {
#line 1524
      goto case_40;
    }
#line 1528
    if (c == 41) {
#line 1528
      goto case_41;
    }
#line 1532
    if (c == 91) {
#line 1532
      goto case_91;
    }
#line 1536
    if (c == 93) {
#line 1536
      goto case_93;
    }
#line 1540
    if (c == 34) {
#line 1540
      goto case_34;
    }
#line 1436
    goto switch_break;
    case_92: /* CIL Label */ 
    {
#line 1438
    c = (*hgetc)();
    }
#line 1439
    if (c != 10) {
#line 1440
      if (c == 36) {
        {
#line 1446
        add(-97);
        }
      } else
#line 1440
      if (c == 92) {
        {
#line 1446
        add(-97);
        }
      } else
#line 1440
      if (c == 125) {
#line 1440
        if (! intick) {
#line 1440
          if (bct) {
            {
#line 1446
            add(-97);
            }
          } else {
#line 1440
            goto _L___0;
          }
        } else {
#line 1440
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1440
      if (c == (int )endchar) {
        {
#line 1446
        add(-97);
        }
      } else
#line 1440
      if (c == 96) {
        {
#line 1446
        add(-97);
        }
      } else
#line 1440
      if ((int )endchar == 93) {
#line 1440
        if (c == 91) {
          {
#line 1446
          add(-97);
          }
        } else
#line 1440
        if (c == 93) {
          {
#line 1446
          add(-97);
          }
        } else
#line 1440
        if (c == 40) {
          {
#line 1446
          add(-97);
          }
        } else
#line 1440
        if (c == 41) {
          {
#line 1446
          add(-97);
          }
        } else
#line 1440
        if (c == 123) {
          {
#line 1446
          add(-97);
          }
        } else
#line 1440
        if (c == 125) {
          {
#line 1446
          add(-97);
          }
        } else
#line 1440
        if (c == 34) {
#line 1440
          if (sub) {
            {
#line 1446
            add(-97);
            }
          } else {
            {
#line 1449
            add('\\');
            }
#line 1450
            goto cont;
          }
        } else {
          {
#line 1449
          add('\\');
          }
#line 1450
          goto cont;
        }
      } else {
        {
#line 1449
        add('\\');
        }
#line 1450
        goto cont;
      }
    } else
#line 1452
    if (sub) {
#line 1453
      goto while_continue;
    } else
#line 1452
    if (! opts[44]) {
#line 1453
      goto while_continue;
    } else
#line 1452
    if ((int )endchar != 34) {
#line 1453
      goto while_continue;
    }
#line 1454
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1456
    if (! sub) {
#line 1456
      if (opts[44]) {
#line 1456
        if ((int )endchar == 34) {
#line 1456
          tmp___1 = 1;
        } else {
#line 1456
          tmp___1 = 0;
        }
      } else {
#line 1456
        tmp___1 = 0;
      }
    } else {
#line 1456
      tmp___1 = 0;
    }
#line 1456
    err = tmp___1;
#line 1457
    goto switch_break;
    case_36: /* CIL Label */ 
#line 1459
    if (intick) {
#line 1460
      goto switch_break;
    }
    {
#line 1461
    c = (*hgetc)();
    }
#line 1462
    if (c == 40) {
      {
#line 1463
      add(-116);
#line 1464
      tmp___2 = cmd_or_math_sub();
      }
      {
#line 1465
      if (tmp___2 == 0) {
#line 1465
        goto case_0;
      }
#line 1469
      if (tmp___2 == 1) {
#line 1469
        goto case_1;
      }
#line 1473
      goto switch_default;
      case_0: /* CIL Label */ 
#line 1466
      c = -118;
#line 1467
      goto switch_break___0;
      case_1: /* CIL Label */ 
#line 1470
      c = -117;
#line 1471
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 1474
      err = 1;
#line 1475
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else
#line 1477
    if (c == 91) {
      {
#line 1478
      add(-123);
#line 1479
      add(-111);
#line 1480
      cmdpush(25);
#line 1481
      err = dquote_parse((char )']', sub);
#line 1482
      cmdpop();
#line 1483
      c = -110;
      }
    } else
#line 1484
    if (c == 123) {
      {
#line 1485
      add(-116);
#line 1486
      c = -113;
#line 1487
      cmdpush(30);
#line 1488
      bct ++;
      }
    } else
#line 1489
    if (c == 36) {
      {
#line 1490
      add(-116);
      }
    } else {
      {
#line 1492
      (*hungetc)(c);
#line 1493
      lexstop = 0;
#line 1494
      c = -116;
      }
    }
#line 1496
    goto switch_break;
    case_125: /* CIL Label */ 
#line 1498
    if (intick) {
#line 1499
      goto switch_break;
    } else
#line 1498
    if (! bct) {
#line 1499
      goto switch_break;
    }
    {
#line 1500
    c = -112;
#line 1501
    bct --;
#line 1502
    cmdpop();
    }
#line 1503
    goto switch_break;
    case_96: /* CIL Label */ 
#line 1505
    c = -103;
#line 1506
    if (intick == 2) {
#line 1507
      stophist -= 4;
    }
#line 1508
    intick = ! intick;
#line 1508
    if (intick) {
#line 1509
      if (lexflags & 2) {
#line 1509
        if (! (inbufflags & (1 << 1))) {
#line 1509
          if (zlemetacs >= (zlemetall + 1) - inbufct) {
#line 1509
            parbegin = inbufct;
          }
        }
      }
      {
#line 1510
      cmdpush(23);
      }
    } else {
#line 1512
      if (lexflags & 2) {
#line 1512
        if (! (inbufflags & (1 << 1))) {
#line 1512
          if (parbegin != -1) {
#line 1512
            if (parend == -1) {
#line 1512
              if (zlemetacs >= (zlemetall + 1) - inbufct) {
#line 1512
                parbegin = -1;
              } else {
#line 1512
                parend = inbufct;
              }
            }
          }
        }
      }
      {
#line 1513
      cmdpop();
      }
    }
#line 1515
    goto switch_break;
    case_39: /* CIL Label */ 
#line 1517
    if (! intick) {
#line 1518
      goto switch_break;
    }
#line 1519
    if (intick == 1) {
#line 1520
      intick = 2;
#line 1520
      stophist += 4;
    } else {
#line 1522
      intick = 1;
#line 1522
      stophist -= 4;
    }
#line 1523
    goto switch_break;
    case_40: /* CIL Label */ 
#line 1525
    if (! math) {
#line 1526
      pct ++;
    } else
#line 1525
    if (! bct) {
#line 1526
      pct ++;
    }
#line 1527
    goto switch_break;
    case_41: /* CIL Label */ 
#line 1529
    if (! math) {
#line 1529
      goto _L___1;
    } else
#line 1529
    if (! bct) {
      _L___1: /* CIL Label */ 
#line 1530
      tmp___3 = pct;
#line 1530
      pct --;
#line 1530
      if (tmp___3) {
#line 1530
        tmp___4 = 0;
      } else
#line 1530
      if (math) {
#line 1530
        tmp___4 = 1;
      } else {
#line 1530
        tmp___4 = 0;
      }
#line 1530
      err = tmp___4;
    }
#line 1531
    goto switch_break;
    case_91: /* CIL Label */ 
#line 1533
    if (! math) {
#line 1534
      brct ++;
    } else
#line 1533
    if (! bct) {
#line 1534
      brct ++;
    }
#line 1535
    goto switch_break;
    case_93: /* CIL Label */ 
#line 1537
    if (! math) {
#line 1537
      goto _L___2;
    } else
#line 1537
    if (! bct) {
      _L___2: /* CIL Label */ 
#line 1538
      tmp___5 = brct;
#line 1538
      brct --;
#line 1538
      if (tmp___5) {
#line 1538
        tmp___6 = 0;
      } else
#line 1538
      if (math) {
#line 1538
        tmp___6 = 1;
      } else {
#line 1538
        tmp___6 = 0;
      }
#line 1538
      err = tmp___6;
    }
#line 1539
    goto switch_break;
    case_34: /* CIL Label */ 
#line 1541
    if (intick) {
#line 1542
      goto switch_break;
    } else
#line 1541
    if ((int )endchar != 34) {
#line 1541
      if (! bct) {
#line 1542
        goto switch_break;
      }
    }
#line 1543
    if (bct) {
      {
#line 1544
      add(-98);
#line 1545
      cmdpush(22);
#line 1546
      err = dquote_parse((char )'\"', sub);
#line 1547
      cmdpop();
#line 1548
      c = -98;
      }
    } else {
#line 1550
      err = 1;
    }
#line 1551
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1553
    if (err) {
#line 1554
      goto while_break;
    } else
#line 1553
    if (lexstop) {
#line 1554
      goto while_break;
    }
    {
#line 1555
    add(c);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1557
  if (intick == 2) {
#line 1558
    stophist -= 4;
  }
#line 1559
  if (intick) {
    {
#line 1560
    cmdpop();
    }
  }
  {
#line 1562
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1562
    tmp___7 = bct;
#line 1562
    bct --;
#line 1562
    if (! tmp___7) {
#line 1562
      goto while_break___0;
    }
    {
#line 1563
    cmdpop();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1564
  if (lexstop) {
#line 1565
    if (intick) {
#line 1565
      tmp___8 = 1;
    } else
#line 1565
    if (endchar) {
#line 1565
      tmp___8 = 1;
    } else
#line 1565
    if (err) {
#line 1565
      tmp___8 = 1;
    } else {
#line 1565
      tmp___8 = 0;
    }
#line 1565
    err = tmp___8;
  } else
#line 1566
  if (err == 1) {
#line 1577
    err = c;
  }
#line 1579
  if (zlemath) {
#line 1579
    if (zlemetacs <= (zlemetall + 1) - inbufct) {
#line 1580
      inwhat = 2;
    }
  }
#line 1581
  return (err);
}
}
#line 1598 "/tmp/zsh-5.4.2/Src/lex.c"
int parsestr(char **s ) 
{ 
  int err ;

  {
  {
#line 1603
  err = parsestrnoerr(s);
  }
#line 1603
  if (err) {
    {
#line 1604
    untokenize(*s);
    }
#line 1605
    if (! (errflag & 2)) {
#line 1606
      if (err > 32) {
#line 1606
        if (err < 127) {
          {
#line 1607
          zerr("parse error near `%c\'", err);
          }
        } else {
          {
#line 1609
          zerr("parse error");
          }
        }
      } else {
        {
#line 1609
        zerr("parse error");
        }
      }
    }
  }
#line 1612
  return (err);
}
}
#line 1616 "/tmp/zsh-5.4.2/Src/lex.c"
int parsestrnoerr(char **s ) 
{ 
  int l ;
  size_t tmp ;
  int err ;
  char *tmp___0 ;

  {
  {
#line 1619
  tmp = strlen((char const   *)*s);
#line 1619
  l = (int )tmp;
#line 1621
  zcontext_save();
#line 1622
  untokenize(*s);
#line 1623
  tmp___0 = dupstring((char const   *)*s);
#line 1623
  inpush(tmp___0, 0, (Alias )((void *)0));
#line 1624
  strinbeg(0);
#line 1625
  lexbuf.len = 0;
#line 1626
  tokstr = *s;
#line 1626
  lexbuf.ptr = tokstr;
#line 1627
  lexbuf.siz = l + 1;
#line 1628
  err = dquote_parse((char )'\000', 1);
  }
#line 1629
  if (tokstr) {
#line 1630
    *s = tokstr;
  }
  {
#line 1631
  *(lexbuf.ptr) = (char )'\000';
#line 1632
  strinend();
#line 1633
  inpop();
#line 1635
  zcontext_restore();
  }
#line 1636
  return (err);
}
}
#line 1646 "/tmp/zsh-5.4.2/Src/lex.c"
char *parse_subscript(char *s , int sub , int endchar ) 
{ 
  int l ;
  size_t tmp ;
  int err ;
  int toklen ;
  char *t ;
  char *strend___0 ;

  {
  {
#line 1649
  tmp = strlen((char const   *)s);
#line 1649
  l = (int )tmp;
  }
#line 1652
  if (! *s) {
#line 1653
    return ((char *)0);
  } else
#line 1652
  if ((int )*s == endchar) {
#line 1653
    return ((char *)0);
  }
  {
#line 1654
  zcontext_save();
#line 1655
  t = dupstring((char const   *)s);
#line 1655
  untokenize(t);
#line 1656
  inpush(t, 0, (Alias )((void *)0));
#line 1657
  strinbeg(0);
#line 1670
  lexbuf.len = 0;
#line 1671
  tokstr = dupstring((char const   *)s);
#line 1671
  lexbuf.ptr = tokstr;
#line 1672
  lexbuf.siz = l + 1;
#line 1673
  err = dquote_parse((char )endchar, sub);
#line 1674
  toklen = (int )(lexbuf.ptr - tokstr);
#line 1676
  memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)tokstr, (size_t )toklen);
  }
#line 1677
  if (err) {
    {
#line 1678
    strend___0 = s + toklen;
#line 1679
    err = (int )*strend___0;
#line 1680
    *strend___0 = (char )'\000';
#line 1681
    untokenize(s);
#line 1682
    *strend___0 = (char )err;
#line 1683
    s = (char *)((void *)0);
    }
  } else {
#line 1685
    s += toklen;
  }
  {
#line 1687
  strinend();
#line 1688
  inpop();
#line 1690
  zcontext_restore();
  }
#line 1691
  return (s);
}
}
#line 1699 "/tmp/zsh-5.4.2/Src/lex.c"
int parse_subst_string(char *s ) 
{ 
  int c ;
  int l ;
  size_t tmp ;
  int err ;
  char *ptr___0 ;
  enum lextok ctok ;
  int tmp___0 ;
  char *tmp___1 ;
  char *t ;
  int len ;
  int tlen ;
  int diff ;
  size_t tmp___2 ;
  char *dptr ;
  char *sptr ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 1702
  tmp = strlen((char const   *)s);
#line 1702
  l = (int )tmp;
  }
#line 1706
  if (! *s) {
#line 1707
    return (0);
  } else {
    {
#line 1706
    tmp___0 = strcmp((char const   *)s, (char const   *)(nulstring));
    }
#line 1706
    if (! tmp___0) {
#line 1707
      return (0);
    }
  }
  {
#line 1708
  zcontext_save();
#line 1709
  untokenize(s);
#line 1710
  tmp___1 = dupstring((char const   *)s);
#line 1710
  inpush(tmp___1, 0, (Alias )((void *)0));
#line 1711
  strinbeg(0);
#line 1712
  lexbuf.len = 0;
#line 1713
  tokstr = s;
#line 1713
  lexbuf.ptr = tokstr;
#line 1714
  lexbuf.siz = l + 1;
#line 1715
  c = (*hgetc)();
#line 1716
  ctok = gettokstr(c, 1);
#line 1717
  err = errflag;
#line 1718
  strinend();
#line 1719
  inpop();
#line 1721
  zcontext_restore();
#line 1723
  errflag = err | (errflag & 2);
  }
#line 1724
  if ((unsigned int )ctok == 38U) {
    {
#line 1725
    untokenize(s);
    }
#line 1726
    return (1);
  }
#line 1743
  ptr___0 = s;
  {
#line 1743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1743
    if (! *ptr___0) {
#line 1743
      goto while_break;
    }
#line 1745
    if ((int )*ptr___0 == -123) {
#line 1745
      if ((int )*(ptr___0 + 1) == -99) {
        {
#line 1749
        t = getkeystring(ptr___0 + 2, & len, 19, (int *)((void *)0));
#line 1750
        len += 2;
#line 1751
        tmp___2 = strlen((char const   *)t);
#line 1751
        tlen = (int )tmp___2;
#line 1752
        diff = len - tlen;
        }
#line 1764
        if (diff < 0) {
#line 1766
          return (1);
        }
        {
#line 1768
        memcpy((void */* __restrict  */)ptr___0, (void const   */* __restrict  */)t,
               (size_t )tlen);
#line 1769
        ptr___0 += tlen;
        }
#line 1770
        if (diff > 0) {
#line 1771
          dptr = ptr___0;
#line 1772
          sptr = ptr___0 + diff;
          {
#line 1773
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1773
            tmp___3 = dptr;
#line 1773
            dptr ++;
#line 1773
            tmp___5 = sptr;
#line 1773
            sptr ++;
#line 1773
            tmp___4 = *tmp___5;
#line 1773
            *tmp___3 = tmp___4;
#line 1773
            if (! tmp___4) {
#line 1773
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      } else {
#line 1777
        ptr___0 ++;
      }
    } else {
#line 1777
      ptr___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1779
  return (0);
}
}
#line 1785 "/tmp/zsh-5.4.2/Src/lex.c"
static void gotword(void) 
{ 
  int nwe ;
  int tmp ;
  int nwb ;

  {
#line 1788
  if (addedx == 2) {
#line 1788
    tmp = 1;
  } else {
#line 1788
    tmp = 0;
  }
#line 1788
  nwe = ((zlemetall + 1) - inbufct) + tmp;
#line 1789
  if (zlemetacs <= nwe) {
#line 1790
    nwb = (zlemetall - wordbeg) + addedx;
#line 1791
    if (zlemetacs >= nwb) {
#line 1792
      wb = nwb;
#line 1793
      we = nwe;
    } else {
#line 1795
      wb = zlemetacs + addedx;
#line 1796
      if (we < wb) {
#line 1797
        we = wb;
      }
    }
#line 1799
    lexflags = 0;
  }
#line 1801
  return;
}
}
#line 1805 "/tmp/zsh-5.4.2/Src/lex.c"
static int checkalias(void) 
{ 
  Alias an ;
  char *suf ;
  HashNode tmp ;
  int c ;
  int tmp___0 ;
  char *tmp___1 ;
  HashNode tmp___2 ;
  HashNode tmp___3 ;

  {
#line 1810
  if (! zshlextext) {
#line 1811
    return (0);
  }
#line 1813
  if (! noaliases) {
#line 1813
    if (opts[1]) {
#line 1813
      if (! opts[129]) {
#line 1813
        goto _L___1;
      } else
#line 1813
      if ((unsigned int )tok == 34U) {
        {
#line 1813
        tmp___3 = (*(reswdtab->getnode))(reswdtab, (char const   *)zshlextext);
        }
#line 1813
        if (! tmp___3) {
          _L___1: /* CIL Label */ 
          {
#line 1818
          tmp = (*(aliastab->getnode))(aliastab, (char const   *)zshlextext);
#line 1818
          an = (Alias )tmp;
          }
#line 1819
          if (an) {
#line 1819
            if (! an->inuse) {
#line 1819
              if (an->node.flags & (1 << 1)) {
#line 1819
                goto _L;
              } else
#line 1819
              if (incmdpos) {
#line 1819
                if ((unsigned int )tok == 34U) {
#line 1819
                  goto _L;
                } else {
#line 1819
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 1819
              if (inalmore) {
                _L: /* CIL Label */ 
#line 1822
                if (! lexstop) {
                  {
#line 1827
                  tmp___0 = (*hgetc)();
#line 1827
                  c = tmp___0;
#line 1828
                  (*hungetc)(c);
                  }
#line 1829
                  if (! ((int )typtab[(unsigned char )c] & (1 << 2))) {
                    {
#line 1830
                    inpush((char *)" ", 1 << 1, (Alias )0);
                    }
                  }
                }
                {
#line 1832
                inpush(an->text, 1 << 1, an);
                }
#line 1833
                if ((int )*(an->text + 0) == 32) {
#line 1833
                  if (! (an->node.flags & (1 << 1))) {
#line 1834
                    aliasspaceflag = 1;
                  }
                }
#line 1835
                lexstop = 0;
#line 1836
                return (1);
              }
            }
          }
          {
#line 1838
          suf = strrchr((char const   *)zshlextext, '.');
          }
#line 1838
          if (suf) {
#line 1838
            if (*(suf + 1)) {
#line 1838
              if ((unsigned long )suf > (unsigned long )zshlextext) {
#line 1838
                if ((int )*(suf + -1) != -125) {
                  {
#line 1838
                  tmp___2 = (*(sufaliastab->getnode))(sufaliastab, (char const   *)(suf + 1));
#line 1838
                  an = (Alias )tmp___2;
                  }
#line 1838
                  if (an) {
#line 1838
                    if (! an->inuse) {
#line 1838
                      if (incmdpos) {
                        {
#line 1842
                        tmp___1 = dupstring((char const   *)zshlextext);
#line 1842
                        inpush(tmp___1, 1 << 1, an);
#line 1843
                        inpush((char *)" ", 1 << 1, (Alias )((void *)0));
#line 1844
                        inpush(an->text, 1 << 1, (Alias )((void *)0));
#line 1845
                        lexstop = 0;
                        }
#line 1846
                        return (1);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1850
  return (0);
}
}
#line 1856 "/tmp/zsh-5.4.2/Src/lex.c"
int exalias(void) 
{ 
  Reswd rw ;
  int tmp ;
  char *copy ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *p ;
  char *t ;
  char *tmp___2 ;
  char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int zp ;
  int tmp___7 ;
  int tmp___8 ;
  HashNode tmp___9 ;

  {
  {
#line 1861
  (*hwend)();
  }
#line 1862
  if (opts[93]) {
#line 1862
    if (opts[160]) {
#line 1862
      if (! strin) {
#line 1862
        if (incasepat <= 0) {
#line 1862
          if ((unsigned int )tok == 34U) {
#line 1862
            if (! nocorrect) {
#line 1862
              if (! (inbufflags & (1 << 1))) {
#line 1862
                if (opts[39]) {
                  {
#line 1865
                  spckword(& tokstr, 1, incmdpos, 1);
                  }
                } else
#line 1862
                if (opts[38]) {
#line 1862
                  if (incmdpos) {
                    {
#line 1865
                    spckword(& tokstr, 1, incmdpos, 1);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1867
  if (! tokstr) {
#line 1868
    zshlextext = tokstrings[tok];
#line 1870
    if ((unsigned int )tok == 2U) {
#line 1871
      return (0);
    }
    {
#line 1872
    tmp = checkalias();
    }
#line 1872
    return (tmp);
  } else {
    {
#line 1874
    tmp___0 = strlen((char const   *)tokstr);
#line 1874
    tmp___1 = zhalloc(sizeof(char ) * (tmp___0 + 1UL));
#line 1874
    copy = (char *)tmp___1;
#line 1876
    tmp___6 = has_token((char const   *)tokstr);
    }
#line 1876
    if (tmp___6) {
#line 1879
      p = copy;
#line 1879
      zshlextext = p;
#line 1880
      t = tokstr;
      {
#line 1880
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1880
        tmp___2 = p;
#line 1880
        p ++;
#line 1880
        if ((int )typtab[(unsigned char )*t] & (1 << 4)) {
#line 1880
          tmp___4 = t;
#line 1880
          t ++;
#line 1880
          tmp___3 = ztokens[(int )*tmp___4 - -124];
        } else {
#line 1880
          tmp___5 = t;
#line 1880
          t ++;
#line 1880
          tmp___3 = *tmp___5;
        }
#line 1880
        *tmp___2 = tmp___3;
#line 1880
        if (! tmp___3) {
#line 1880
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1883
      zshlextext = tokstr;
    }
#line 1885
    if (lexflags & 2) {
#line 1885
      if (! (inbufflags & (1 << 1))) {
        {
#line 1886
        zp = lexflags;
#line 1888
        gotword();
        }
#line 1889
        if (zp & 2) {
#line 1889
          if (! lexflags) {
#line 1890
            if ((unsigned long )zshlextext == (unsigned long )copy) {
#line 1891
              zshlextext = tokstr;
            }
#line 1892
            return (0);
          }
        }
      }
    }
#line 1896
    if ((unsigned int )tok == 34U) {
#line 1898
      if ((unsigned long )zshlextext != (unsigned long )copy) {
#line 1898
        goto _L;
      } else
#line 1898
      if (! opts[129]) {
        _L: /* CIL Label */ 
        {
#line 1898
        tmp___7 = checkalias();
        }
#line 1898
        if (tmp___7) {
#line 1899
          if ((unsigned long )zshlextext == (unsigned long )copy) {
#line 1900
            zshlextext = tokstr;
          }
#line 1901
          return (1);
        }
      }
#line 1905
      if (incmdpos) {
#line 1905
        goto _L___2;
      } else
#line 1905
      if (! opts[88]) {
#line 1905
        if (! opts[89]) {
#line 1905
          if ((int )*(zshlextext + 0) == 125) {
#line 1905
            if (! *(zshlextext + 1)) {
              _L___2: /* CIL Label */ 
              {
#line 1905
              tmp___9 = (*(reswdtab->getnode))(reswdtab, (char const   *)zshlextext);
#line 1905
              rw = (Reswd )tmp___9;
              }
#line 1905
              if (rw) {
#line 1909
                tok = (enum lextok )rw->token;
#line 1910
                inrepeat_ = (unsigned int )tok == 57U;
#line 1911
                if ((unsigned int )tok == 40U) {
#line 1912
                  incond = 1;
                }
              } else {
#line 1905
                goto _L___5;
              }
            } else {
#line 1905
              goto _L___5;
            }
          } else {
#line 1905
            goto _L___5;
          }
        } else {
#line 1905
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 1913
      if (incond) {
        {
#line 1913
        tmp___8 = strcmp((char const   *)zshlextext, "]]");
        }
#line 1913
        if (tmp___8) {
#line 1913
          goto _L___0;
        } else {
#line 1914
          tok = (enum lextok )33;
#line 1915
          incond = 0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1916
      if (incond == 1) {
#line 1916
        if ((int )*(zshlextext + 0) == 33) {
#line 1916
          if (! *(zshlextext + 1)) {
#line 1917
            tok = (enum lextok )39;
          }
        }
      }
    }
#line 1919
    inalmore = 0;
#line 1920
    if ((unsigned long )zshlextext == (unsigned long )copy) {
#line 1921
      zshlextext = tokstr;
    }
  }
#line 1923
  return (0);
}
}
#line 1927 "/tmp/zsh-5.4.2/Src/lex.c"
void zshlex_raw_add(int c ) 
{ 
  char *tmp ;
  int newbsiz ;
  void *tmp___0 ;

  {
#line 1930
  if (! lex_add_raw) {
#line 1931
    return;
  }
#line 1933
  tmp = lexbuf_raw.ptr;
#line 1933
  (lexbuf_raw.ptr) ++;
#line 1933
  *tmp = (char )c;
#line 1934
  (lexbuf_raw.len) ++;
#line 1934
  if (lexbuf_raw.siz == lexbuf_raw.len) {
    {
#line 1935
    newbsiz = lexbuf_raw.siz * 2;
#line 1937
    tmp___0 = hrealloc(tokstr_raw, (size_t )lexbuf_raw.siz, (size_t )newbsiz);
#line 1937
    tokstr_raw = (char *)tmp___0;
#line 1938
    lexbuf_raw.ptr = tokstr_raw + lexbuf_raw.len;
#line 1939
    memset((void *)lexbuf_raw.ptr, 0, (size_t )(newbsiz - lexbuf_raw.siz));
#line 1940
    lexbuf_raw.siz = newbsiz;
    }
  }
#line 1942
  return;
}
}
#line 1945 "/tmp/zsh-5.4.2/Src/lex.c"
void zshlex_raw_back(void) 
{ 


  {
#line 1948
  if (! lex_add_raw) {
#line 1949
    return;
  }
#line 1950
  (lexbuf_raw.ptr) --;
#line 1951
  (lexbuf_raw.len) --;
#line 1952
  return;
}
}
#line 1955 "/tmp/zsh-5.4.2/Src/lex.c"
int zshlex_raw_mark(int offset ) 
{ 


  {
#line 1958
  if (! lex_add_raw) {
#line 1959
    return (0);
  }
#line 1960
  return (lexbuf_raw.len + offset);
}
}
#line 1964 "/tmp/zsh-5.4.2/Src/lex.c"
void zshlex_raw_back_to_mark(int mark ) 
{ 


  {
#line 1967
  if (! lex_add_raw) {
#line 1968
    return;
  }
#line 1969
  lexbuf_raw.ptr = tokstr_raw + mark;
#line 1970
  lexbuf_raw.len = mark;
#line 1971
  return;
}
}
#line 1984 "/tmp/zsh-5.4.2/Src/lex.c"
static int skipcomm(void) 
{ 
  char *new_tokstr ;
  int new_lexstop ;
  int new_lex_add_raw ;
  int save_infor ;
  struct lexbufstate new_lexbuf ;
  Eprog tmp ;

  {
  {
#line 2061
  save_infor = infor;
#line 2064
  infor = 0;
#line 2065
  cmdpush(24);
  }
#line 2066
  if (lexflags & 2) {
#line 2066
    if (! (inbufflags & (1 << 1))) {
#line 2066
      if (zlemetacs >= (zlemetall + 1) - inbufct) {
#line 2066
        parbegin = inbufct;
      }
    }
  }
  {
#line 2067
  add(-120);
#line 2069
  new_lex_add_raw = lex_add_raw + 1;
  }
#line 2070
  if (! lex_add_raw) {
#line 2086
    new_tokstr = tokstr;
#line 2087
    new_lexbuf = lexbuf;
#line 2099
    if (inbufflags & (1 << 1)) {
#line 2100
      inbufflags |= 1 << 8;
    }
    {
#line 2101
    zcontext_save_partial(6);
#line 2102
    hist_in_word(1);
    }
  } else {
    {
#line 2113
    new_tokstr = tokstr_raw;
#line 2114
    new_lexbuf = lexbuf_raw;
#line 2116
    zcontext_save_partial(6);
    }
  }
  {
#line 2118
  tokstr_raw = new_tokstr;
#line 2119
  lexbuf_raw = new_lexbuf;
#line 2120
  lex_add_raw = new_lex_add_raw;
#line 2132
  lexflags &= -3;
#line 2133
  dbparens = 0;
#line 2135
  tmp = parse_event(7);
  }
#line 2135
  if (tmp) {
#line 2135
    if ((unsigned int )tok != 7U) {
      _L: /* CIL Label */ 
#line 2136
      if (strin) {
        {
#line 2141
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2141
          if (! (! lexstop)) {
#line 2141
            goto while_break;
          }
          {
#line 2142
          ingetc();
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 2144
        lexstop = 1;
      }
    }
  } else {
#line 2135
    goto _L;
  }
  {
#line 2152
  new_tokstr = tokstr_raw;
#line 2153
  new_lexbuf = lexbuf_raw;
#line 2159
  new_lexstop = lexstop;
#line 2161
  zcontext_restore_partial(6);
  }
#line 2163
  if (lex_add_raw) {
#line 2167
    tokstr_raw = new_tokstr;
#line 2168
    lexbuf_raw = new_lexbuf;
  } else {
#line 2170
    if (! new_lexstop) {
#line 2172
      (new_lexbuf.len) --;
#line 2173
      (new_lexbuf.ptr) --;
#line 2173
      *(new_lexbuf.ptr) = (char )'\000';
    }
    {
#line 2180
    tokstr = new_tokstr;
#line 2181
    lexbuf = new_lexbuf;
#line 2182
    lexstop = new_lexstop;
#line 2183
    hist_in_word(0);
    }
  }
#line 2186
  if (! lexstop) {
#line 2187
    if (lexflags & 2) {
#line 2187
      if (! (inbufflags & (1 << 1))) {
#line 2187
        if (parbegin != -1) {
#line 2187
          if (parend == -1) {
#line 2187
            if (zlemetacs >= (zlemetall + 1) - inbufct) {
#line 2187
              parbegin = -1;
            } else {
#line 2187
              parend = inbufct;
            }
          }
        }
      }
    }
  }
  {
#line 2188
  cmdpop();
#line 2189
  infor = save_infor;
  }
#line 2191
  return (lexstop);
}
}
#line 649 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 87 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 12 "./exec.epro"
int subsh ;
#line 14
long lastval2 ;
#line 21 "./init.epro"
sigset_t sigchld_mask ;
#line 5 "./jobs.epro"
pid_t origpgrp  ;
#line 6 "./jobs.epro"
pid_t mypgrp  ;
#line 7 "./jobs.epro"
int thisjob  ;
#line 8 "./jobs.epro"
int curjob  ;
#line 9 "./jobs.epro"
int prevjob  ;
#line 10 "./jobs.epro"
struct job *jobtab  ;
#line 11 "./jobs.epro"
int jobtabsize  ;
#line 12 "./jobs.epro"
int maxjob  ;
#line 16 "./jobs.epro"
int ttyfrozen  ;
#line 17 "./jobs.epro"
int prev_errflag  ;
#line 18 "./jobs.epro"
int prev_breaks  ;
#line 19 "./jobs.epro"
int errbrk_saved  ;
#line 20 "./jobs.epro"
int numpipestats  ;
#line 21 "./jobs.epro"
int pipestats[256]  ;
#line 22
void makerunning(Job jn ) ;
#line 24
int hasprocs(int job ) ;
#line 28
void storepipestats(Job jn , int inforeground , int fixlastval ) ;
#line 30
long get_clktck(void) ;
#line 31
int printjob(Job jn , int lng , int synch ) ;
#line 32
void addfilelist(char const   *name , int fd ) ;
#line 33
void pipecleanfilelist(LinkList filelist , int proc_subst_only ) ;
#line 34
void deletefilelist(LinkList file_list , int disowning ) ;
#line 35
void freejob(Job jn , int deleting ) ;
#line 36
void deletejob(Job jn , int disowning ) ;
#line 37
void addproc(pid_t pid , char *text , int aux , struct timeval *bgtime ) ;
#line 38
int havefiles(void) ;
#line 39
int waitforpid(pid_t pid , int wait_cmd ) ;
#line 40
void waitjobs(void) ;
#line 41
void clearjobtab(int monitor ) ;
#line 42
int initjob(void) ;
#line 43
void setjobpwd(void) ;
#line 44
void spawnjob(void) ;
#line 45
void shelltime(void) ;
#line 47
int getjob(char const   *s , char const   *prog ) ;
#line 48
void init_jobs(char **argv , char **envp ) ;
#line 49
int expandjobtab(void) ;
#line 50
void maybeshrinkjobtab(void) ;
#line 52
int bin_fg(char *name , char **argv , Options ops , int func ) ;
#line 53
int bin_kill(char *nam , char **argv , Options ops  __attribute__((__unused__)) ,
             int func  __attribute__((__unused__)) ) ;
#line 54
int getsignum(char const   *s ) ;
#line 55
char const   *getsigname(int sig ) ;
#line 57
void removetrapnode(int sig ) ;
#line 58
int bin_suspend(char *name , char **argv  __attribute__((__unused__)) , Options ops ,
                int func  __attribute__((__unused__)) ) ;
#line 59
int findjobnam(char const   *s ) ;
#line 61
void release_pgrp(void) ;
#line 3 "./jobs.pro"
static struct rusage child_usage  ;
#line 7
static struct timeval *dtime(struct timeval *dt , struct timeval *t1 , struct timeval *t2 ) ;
#line 8
static int super_job(int sub ) ;
#line 9
static int handle_sub(int job , int fg ) ;
#line 10
static void setprevjob(void) ;
#line 11
static void printhhmmss(double secs ) ;
#line 12
static void dumptime(Job jn ) ;
#line 13
static int should_report_time(Job j ) ;
#line 14
static int zwaitjob(int job , int wait_cmd ) ;
#line 15
static int isanum(char *s ) ;
#line 16
static void setcurjob(void) ;
#line 75 "/tmp/zsh-5.4.2/Src/jobs.c"
static struct job *oldjobtab  ;
#line 78 "/tmp/zsh-5.4.2/Src/jobs.c"
static int oldmaxjob  ;
#line 110 "/tmp/zsh-5.4.2/Src/jobs.c"
static struct timeval *dtime(struct timeval *dt , struct timeval *t1 , struct timeval *t2 ) 
{ 


  {
#line 113
  dt->tv_sec = t2->tv_sec - t1->tv_sec;
#line 114
  dt->tv_usec = t2->tv_usec - t1->tv_usec;
#line 115
  if (dt->tv_usec < 0L) {
#line 116
    dt->tv_usec = (__suseconds_t )((double )dt->tv_usec + 1000000.0);
#line 117
    dt->tv_sec = (__time_t )((double )dt->tv_sec - 1.0);
  }
#line 119
  return (dt);
}
}
#line 125 "/tmp/zsh-5.4.2/Src/jobs.c"
void makerunning(Job jn ) 
{ 
  Process pn ;

  {
#line 130
  jn->stat &= -3;
#line 131
  pn = jn->procs;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! pn) {
#line 131
      goto while_break;
    }
#line 137
    if ((pn->status & 255) == 127) {
#line 138
      pn->status = -1;
    }
#line 131
    pn = pn->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  if (jn->stat & 128) {
    {
#line 142
    makerunning(jobtab + jn->other);
    }
  }
#line 143
  return;
}
}
#line 149 "/tmp/zsh-5.4.2/Src/jobs.c"
int findproc(pid_t pid , Job *jptr , Process *pptr , int aux ) 
{ 
  Process pn ;
  int i ;
  int tmp ;

  {
#line 155
  *jptr = (Job )((void *)0);
#line 156
  *pptr = (Process )((void *)0);
#line 157
  i = 1;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i <= maxjob)) {
#line 157
      goto while_break;
    }
#line 165
    if ((jobtab + i)->stat & 8) {
#line 166
      goto __Cont;
    }
#line 168
    if (aux) {
#line 168
      pn = (jobtab + i)->auxprocs;
    } else {
#line 168
      pn = (jobtab + i)->procs;
    }
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 168
      if (! pn) {
#line 168
        goto while_break___0;
      }
#line 186
      if (pn->pid == pid) {
#line 187
        *pptr = pn;
#line 188
        *jptr = jobtab + i;
#line 189
        if (pn->status == -1) {
#line 190
          return (1);
        }
      }
#line 168
      pn = pn->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 157
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  if (*pptr) {
#line 195
    if (*jptr) {
#line 195
      tmp = 1;
    } else {
#line 195
      tmp = 0;
    }
  } else {
#line 195
    tmp = 0;
  }
#line 195
  return (tmp);
}
}
#line 201 "/tmp/zsh-5.4.2/Src/jobs.c"
int hasprocs(int job ) 
{ 
  Job jn ;
  int tmp ;

  {
#line 206
  if (job < 0) {
#line 208
    return (0);
  }
#line 210
  jn = jobtab + job;
#line 212
  if (jn->procs) {
#line 212
    tmp = 1;
  } else
#line 212
  if (jn->auxprocs) {
#line 212
    tmp = 1;
  } else {
#line 212
    tmp = 0;
  }
#line 212
  return (tmp);
}
}
#line 218 "/tmp/zsh-5.4.2/Src/jobs.c"
static int super_job(int sub ) 
{ 
  int i ;

  {
#line 223
  i = 1;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (i <= maxjob)) {
#line 223
      goto while_break;
    }
#line 224
    if ((jobtab + i)->stat & 128) {
#line 224
      if ((jobtab + i)->other == sub) {
#line 224
        if ((jobtab + i)->gleader) {
#line 227
          return (i);
        }
      }
    }
#line 223
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return (0);
}
}
#line 232 "/tmp/zsh-5.4.2/Src/jobs.c"
static int handle_sub(int job , int fg ) 
{ 
  Job jn ;
  Job sj ;
  struct process *p ;
  int cp ;
  Process p___0 ;
  int tmp ;
  int tmp___0 ;
  struct process *p___1 ;

  {
#line 236
  jn = jobtab + job;
#line 236
  sj = jobtab + jn->other;
#line 238
  if (sj->stat & 8) {
#line 238
    goto _L___1;
  } else
#line 238
  if (! sj->procs) {
#line 238
    if (! sj->auxprocs) {
      _L___1: /* CIL Label */ 
#line 241
      p = sj->procs;
      {
#line 241
      while (1) {
        while_continue: /* CIL Label */ ;
#line 241
        if (! p) {
#line 241
          goto while_break;
        }
#line 242
        if ((int )((signed char )((p->status & 127) + 1)) >> 1 > 0) {
#line 243
          if (jn->gleader != mypgrp) {
#line 243
            if ((jn->procs)->next) {
              {
#line 244
              killpg(jn->gleader, p->status & 127);
              }
            } else {
              {
#line 246
              kill((jn->procs)->pid, p->status & 127);
              }
            }
          } else {
            {
#line 246
            kill((jn->procs)->pid, p->status & 127);
            }
          }
          {
#line 247
          kill(sj->other, 18);
#line 248
          kill(sj->other, p->status & 127);
          }
#line 249
          goto while_break;
        }
#line 241
        p = p->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 252
      if (! p) {
#line 255
        jn->stat &= -129;
#line 256
        jn->stat |= 512;
#line 258
        if (((jn->procs)->status & 127) == 0) {
#line 258
          goto _L;
        } else
#line 258
        if ((int )((signed char )(((jn->procs)->status & 127) + 1)) >> 1 > 0) {
          _L: /* CIL Label */ 
          {
#line 258
          tmp = killpg(jn->gleader, 0);
          }
#line 258
          if (tmp == -1) {
#line 258
            tmp___0 = 1;
          } else {
#line 258
            tmp___0 = 0;
          }
        } else {
#line 258
          tmp___0 = 0;
        }
#line 258
        cp = tmp___0;
#line 258
        if (cp) {
#line 262
          p___0 = jn->procs;
          {
#line 262
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 262
            if (! p___0->next) {
#line 262
              goto while_break___0;
            }
#line 262
            p___0 = p___0->next;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 263
          jn->gleader = p___0->pid;
        }
#line 276
        if (fg) {
#line 276
          goto _L___0;
        } else
#line 276
        if (thisjob == job) {
          _L___0: /* CIL Label */ 
#line 276
          if (! (jn->procs)->next) {
            {
#line 278
            attachtty(jn->gleader);
            }
          } else
#line 276
          if (cp) {
            {
#line 278
            attachtty(jn->gleader);
            }
          } else
#line 276
          if ((jn->procs)->pid != jn->gleader) {
            {
#line 278
            attachtty(jn->gleader);
            }
          }
        }
        {
#line 279
        kill(sj->other, 18);
        }
#line 280
        if (jn->stat & 65536) {
          {
#line 282
          deletejob(jn, 1);
          }
        }
      }
#line 285
      curjob = (int )(jn - jobtab);
    } else {
#line 238
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 286
  if (sj->stat & 2) {
#line 289
    jn->stat |= 2;
#line 290
    p___1 = jn->procs;
    {
#line 290
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 290
      if (! p___1) {
#line 290
        goto while_break___1;
      }
#line 291
      if (p___1->status == -1) {
#line 293
        p___1->status = (sj->procs)->status;
      } else
#line 291
      if (! ((p___1->status & 127) == 0)) {
#line 291
        if (! ((int )((signed char )((p___1->status & 127) + 1)) >> 1 > 0)) {
#line 293
          p___1->status = (sj->procs)->status;
        }
      }
#line 290
      p___1 = p___1->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 294
    curjob = (int )(jn - jobtab);
#line 295
    printjob(jn, ! (! opts[111]), 1);
    }
#line 296
    return (1);
  }
#line 298
  return (0);
}
}
#line 305 "/tmp/zsh-5.4.2/Src/jobs.c"
void get_usage(void) 
{ 


  {
  {
#line 309
  getrusage((__rusage_who_t )-1, & child_usage);
  }
#line 313
  return;
}
}
#line 355 "/tmp/zsh-5.4.2/Src/jobs.c"
void check_cursh_sig(int sig ) 
{ 
  int i ;
  int j ;
  Process pn ;
  struct process *tmp ;

  {
#line 360
  if (! errflag) {
#line 361
    return;
  }
#line 362
  i = 1;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! (i <= maxjob)) {
#line 362
      goto while_break;
    }
#line 363
    if (((jobtab + i)->stat & 1032) == 1024) {
#line 365
      j = 0;
      {
#line 365
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 365
        if (! (j < 2)) {
#line 365
          goto while_break___0;
        }
#line 366
        if (j) {
#line 366
          tmp = (jobtab + i)->auxprocs;
        } else {
#line 366
          tmp = (jobtab + i)->procs;
        }
#line 366
        pn = tmp;
        {
#line 367
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 367
          if (! pn) {
#line 367
            goto while_break___1;
          }
#line 368
          if (pn->status == -1) {
            {
#line 369
            kill(pn->pid, sig);
            }
          }
#line 367
          pn = pn->next;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 365
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 362
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  return;
}
}
#line 378 "/tmp/zsh-5.4.2/Src/jobs.c"
void storepipestats(Job jn , int inforeground , int fixlastval ) 
{ 
  int i ;
  int pipefail ;
  int jpipestats[256] ;
  Process p ;
  int tmp ;
  int tmp___0 ;

  {
#line 381
  pipefail = 0;
#line 384
  p = jn->procs;
#line 384
  i = 0;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (p) {
#line 384
      if (! (i < 256)) {
#line 384
        goto while_break;
      }
    } else {
#line 384
      goto while_break;
    }
#line 385
    if ((int )((signed char )((p->status & 127) + 1)) >> 1 > 0) {
#line 385
      jpipestats[i] = 128 | (p->status & 127);
    } else {
#line 385
      if ((p->status & 255) == 127) {
#line 385
        tmp = 128 | ((p->status & 65280) >> 8);
      } else {
#line 385
        tmp = (p->status & 65280) >> 8;
      }
#line 385
      jpipestats[i] = tmp;
    }
#line 390
    if (jpipestats[i]) {
#line 391
      pipefail = jpipestats[i];
    }
#line 384
    p = p->next;
#line 384
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  if (inforeground) {
    {
#line 394
    memcpy((void */* __restrict  */)(pipestats), (void const   */* __restrict  */)(jpipestats),
           sizeof(int ) * (unsigned long )i);
    }
#line 395
    if (jn->stat & 1024) {
#line 395
      if (i < 256) {
#line 396
        tmp___0 = i;
#line 396
        i ++;
#line 396
        pipestats[tmp___0] = (int )lastval;
      }
    }
#line 397
    numpipestats = i;
  }
#line 400
  if (fixlastval) {
#line 401
    if (jn->stat & 1024) {
#line 402
      if (! lastval) {
#line 402
        if (opts[128]) {
#line 403
          lastval = (zlong )pipefail;
        }
      }
    } else
#line 404
    if (opts[128]) {
#line 405
      lastval = (zlong )pipefail;
    }
  }
#line 407
  return;
}
}
#line 412 "/tmp/zsh-5.4.2/Src/jobs.c"
void update_job(Job jn ) 
{ 
  Process pn ;
  int job ;
  int val ;
  int status ;
  int somestopped ;
  int inforeground ;
  int tmp ;
  void *tmp___0 ;
  int i ;
  pid_t pgrp ;
  pid_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int su ;
  int tmp___5 ;
  int sig ;

  {
#line 417
  val = 0;
#line 417
  status = 0;
#line 418
  somestopped = 0;
#line 418
  inforeground = 0;
#line 420
  pn = jn->auxprocs;
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (! pn) {
#line 420
      goto while_break;
    }
#line 422
    if (pn->status == 65535) {
#line 423
      pn->status = -1;
    }
#line 425
    if (pn->status == -1) {
#line 426
      return;
    }
#line 420
    pn = pn->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  pn = jn->procs;
  {
#line 429
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 429
    if (! pn) {
#line 429
      goto while_break___0;
    }
#line 431
    if (pn->status == 65535) {
#line 432
      jn->stat &= -3;
#line 433
      pn->status = -1;
    }
#line 436
    if (pn->status == -1) {
#line 437
      return;
    }
#line 438
    if ((pn->status & 255) == 127) {
#line 439
      somestopped = 1;
    }
#line 440
    if (! pn->next) {
#line 441
      if ((int )((signed char )((pn->status & 127) + 1)) >> 1 > 0) {
#line 441
        val = 128 | (pn->status & 127);
      } else {
#line 441
        if ((pn->status & 255) == 127) {
#line 441
          tmp = 128 | ((pn->status & 65280) >> 8);
        } else {
#line 441
          tmp = (pn->status & 65280) >> 8;
        }
#line 441
        val = tmp;
      }
    }
#line 446
    if (pn->pid == jn->gleader) {
#line 447
      status = pn->status;
    }
#line 429
    pn = pn->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 450
  job = (int )(jn - jobtab);
#line 452
  if (somestopped) {
#line 453
    if (jn->stty_in_env) {
#line 453
      if (! jn->ty) {
        {
#line 454
        tmp___0 = zalloc(sizeof(struct ttyinfo ));
#line 454
        jn->ty = (struct ttyinfo *)tmp___0;
#line 455
        gettyinfo(jn->ty);
        }
      }
    }
#line 457
    if (jn->stat & 2) {
#line 458
      if (jn->stat & 256) {
        {
#line 465
        i = super_job(job);
        }
#line 465
        if (i) {
          {
#line 466
          killpg((jobtab + i)->gleader, 20);
          }
        }
      }
#line 468
      return;
    }
  }
#line 472
  lastval2 = (long )val;
#line 477
  if (jn->stat & 1024) {
#line 478
    inforeground = 1;
  } else
#line 479
  if (job == thisjob) {
#line 480
    lastval = (zlong )val;
#line 481
    inforeground = 2;
  }
#line 485
  if (shout) {
#line 485
    if ((unsigned long )shout != (unsigned long )stderr) {
#line 485
      if (! ttyfrozen) {
#line 485
        if (! jn->stty_in_env) {
#line 485
          if (! zleactive) {
#line 485
            if (job == thisjob) {
#line 485
              if (! somestopped) {
#line 485
                if (! (jn->stat & 2048)) {
                  {
#line 488
                  gettyinfo(& shttyinfo);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 490
  if (opts[116]) {
    {
#line 491
    tmp___1 = gettygrp();
#line 491
    pgrp = tmp___1;
    }
#line 494
    if (mypgrp != pgrp) {
#line 494
      if (inforeground) {
#line 494
        if (jn->gleader == pgrp) {
#line 494
          goto _L___0;
        } else
#line 494
        if (pgrp > 1) {
          {
#line 494
          tmp___3 = kill(- pgrp, 0);
          }
#line 494
          if (tmp___3 == -1) {
            _L___0: /* CIL Label */ 
#line 496
            if (list_pipe) {
#line 497
              if (somestopped) {
                {
#line 498
                attachtty(mypgrp);
#line 500
                adjustwinsize(0);
                }
              } else
#line 497
              if (pgrp > 1) {
                {
#line 497
                tmp___2 = kill(- pgrp, 0);
                }
#line 497
                if (tmp___2 == -1) {
                  {
#line 498
                  attachtty(mypgrp);
#line 500
                  adjustwinsize(0);
                  }
                } else {
#line 509
                  jn->stat |= 4096;
                }
              } else {
#line 509
                jn->stat |= 4096;
              }
#line 513
              if (val & 128) {
#line 513
                if (inforeground == 1) {
#line 513
                  if ((val & -129) == 2) {
#line 513
                    goto _L;
                  } else
#line 513
                  if ((val & -129) == 3) {
                    _L: /* CIL Label */ 
#line 515
                    if (! errbrk_saved) {
#line 516
                      errbrk_saved = 1;
#line 517
                      prev_breaks = breaks;
#line 518
                      prev_errflag = errflag;
                    }
                    {
#line 520
                    breaks = loops;
#line 521
                    errflag |= 2;
#line 522
                    inerrflush();
                    }
                  }
                }
              }
            } else {
              {
#line 525
              attachtty(mypgrp);
#line 527
              adjustwinsize(0);
              }
            }
          }
        }
      }
    }
  } else
#line 530
  if (list_pipe) {
#line 530
    if (val & 128) {
#line 530
      if (inforeground == 1) {
#line 530
        if ((val & -129) == 2) {
#line 530
          goto _L___1;
        } else
#line 530
        if ((val & -129) == 3) {
          _L___1: /* CIL Label */ 
#line 532
          if (! errbrk_saved) {
#line 533
            errbrk_saved = 1;
#line 534
            prev_breaks = breaks;
#line 535
            prev_errflag = errflag;
          }
          {
#line 537
          breaks = loops;
#line 538
          errflag |= 2;
#line 539
          inerrflush();
          }
        }
      }
    }
  }
#line 541
  if (somestopped) {
#line 541
    if (jn->stat & 128) {
#line 542
      return;
    }
  }
#line 543
  if (somestopped) {
#line 543
    tmp___4 = 3;
  } else {
#line 543
    tmp___4 = 9;
  }
#line 543
  jn->stat |= tmp___4;
#line 545
  if (jn->stat & 10) {
    {
#line 551
    storepipestats(jn, inforeground, 0);
    }
  }
#line 553
  if (! inforeground) {
#line 553
    if ((jn->stat & 264) == 264) {
      {
#line 557
      su = super_job((int )(jn - jobtab));
      }
#line 557
      if (su) {
        {
#line 558
        handle_sub(su, 0);
        }
      }
    }
  }
#line 560
  if ((jn->stat & 10) == 2) {
#line 561
    prevjob = curjob;
#line 562
    curjob = job;
  }
#line 564
  if (opts[121]) {
#line 564
    goto _L___2;
  } else
#line 564
  if (job == thisjob) {
    _L___2: /* CIL Label */ 
#line 564
    if (jn->stat & 16) {
      {
#line 565
      tmp___5 = printjob(jn, ! (! opts[111]), 0);
      }
#line 565
      if (tmp___5) {
#line 565
        if (zleactive) {
          {
#line 567
          zleentry(5);
          }
        }
      }
    }
  }
#line 569
  if (sigtrapped[17]) {
#line 569
    if (job != thisjob) {
      {
#line 570
      dotrap(17);
      }
    }
  }
#line 576
  if (inforeground == 2) {
#line 576
    if (opts[116]) {
#line 576
      if ((int )((signed char )((status & 127) + 1)) >> 1 > 0) {
#line 577
        sig = status & 127;
#line 579
        if (sig == 2) {
#line 579
          goto _L___3;
        } else
#line 579
        if (sig == 3) {
          _L___3: /* CIL Label */ 
#line 580
          if (sigtrapped[sig]) {
            {
#line 581
            dotrap(sig);
            }
#line 589
            if (errflag) {
#line 590
              breaks = loops;
            }
          } else {
#line 592
            breaks = loops;
#line 593
            errflag |= 2;
          }
          {
#line 595
          check_cursh_sig(sig);
          }
        }
      }
    }
  }
#line 598
  return;
}
}
#line 603 "/tmp/zsh-5.4.2/Src/jobs.c"
static void setprevjob(void) 
{ 
  int i ;

  {
#line 608
  i = maxjob;
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    if (! i) {
#line 608
      goto while_break;
    }
#line 609
    if ((jobtab + i)->stat & 64) {
#line 609
      if ((jobtab + i)->stat & 2) {
#line 609
        if (! ((jobtab + i)->stat & 256)) {
#line 609
          if (i != curjob) {
#line 609
            if (i != thisjob) {
#line 611
              prevjob = i;
#line 612
              return;
            }
          }
        }
      }
    }
#line 608
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 615
  i = maxjob;
  {
#line 615
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 615
    if (! i) {
#line 615
      goto while_break___0;
    }
#line 616
    if ((jobtab + i)->stat & 64) {
#line 616
      if (! ((jobtab + i)->stat & 256)) {
#line 616
        if (i != curjob) {
#line 616
          if (i != thisjob) {
#line 618
            prevjob = i;
#line 619
            return;
          }
        }
      }
    }
#line 615
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 622
  prevjob = -1;
#line 623
  return;
}
}
#line 629 "/tmp/zsh-5.4.2/Src/jobs.c"
static long clktck  ;
#line 626 "/tmp/zsh-5.4.2/Src/jobs.c"
long get_clktck(void) 
{ 


  {
#line 632
  if (! clktck) {
    {
#line 635
    clktck = sysconf(2);
    }
  }
#line 653
  return (clktck);
}
}
#line 657 "/tmp/zsh-5.4.2/Src/jobs.c"
static void printhhmmss(double secs ) 
{ 
  int mins ;
  int hours ;

  {
#line 660
  mins = (int )secs / 60;
#line 661
  hours = mins / 60;
#line 663
  secs -= (double )(60 * mins);
#line 664
  mins -= 60 * hours;
#line 665
  if (hours) {
    {
#line 666
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d:%02d:%05.2f",
            hours, mins, secs);
    }
  } else
#line 667
  if (mins) {
    {
#line 668
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d:%05.2f",
            mins, secs);
    }
  } else {
    {
#line 670
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%.3f",
            secs);
    }
  }
#line 671
  return;
}
}
#line 673 "/tmp/zsh-5.4.2/Src/jobs.c"
static void printtime(struct timeval *real , child_times_t *ti , char *desc ) 
{ 
  char *s ;
  double elapsed_time ;
  double user_time ;
  double system_time ;
  double total_time ;
  int percent ;
  int desclen ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  sigset_t oset ;

  {
#line 683
  if (! desc) {
#line 685
    desc = (char *)"";
#line 686
    desclen = 0;
  } else {
    {
#line 690
    desc = dupstring((char const   *)desc);
#line 691
    unmetafy(desc, & desclen);
    }
  }
  {
#line 695
  elapsed_time = (double )real->tv_sec + (double )real->tv_usec / 1000000.0;
#line 698
  user_time = (double )ti->ru_utime.tv_sec + (double )ti->ru_utime.tv_usec / 1000000.0;
#line 699
  system_time = (double )ti->ru_stime.tv_sec + (double )ti->ru_stime.tv_usec / 1000000.0;
#line 700
  total_time = user_time + system_time;
#line 701
  percent = (int )((100.0 * total_time) / ((double )real->tv_sec + (double )real->tv_usec / 1000000.0));
#line 713
  queueing_enabled ++;
#line 714
  s = getsparam((char *)"TIMEFMT");
  }
#line 714
  if (s) {
    {
#line 717
    s = unmetafy(s, (int *)((void *)0));
    }
  } else {
#line 715
    s = (char *)"%J  %U user %S system %P cpu %*E total";
  }
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if (! *s) {
#line 719
      goto while_break;
    }
#line 720
    if ((int )*s == 37) {
#line 721
      s ++;
      {
#line 722
      if ((int )*s == 69) {
#line 722
        goto case_69;
      }
#line 725
      if ((int )*s == 85) {
#line 725
        goto case_85;
      }
#line 728
      if ((int )*s == 83) {
#line 728
        goto case_83;
      }
#line 731
      if ((int )*s == 42) {
#line 731
        goto case_42;
      }
#line 748
      if ((int )*s == 80) {
#line 748
        goto case_80;
      }
#line 752
      if ((int )*s == 87) {
#line 752
        goto case_87;
      }
#line 757
      if ((int )*s == 88) {
#line 757
        goto case_88;
      }
#line 765
      if ((int )*s == 68) {
#line 765
        goto case_68;
      }
#line 779
      if ((int )*s == 75) {
#line 779
        goto case_75;
      }
#line 800
      if ((int )*s == 77) {
#line 800
        goto case_77;
      }
#line 805
      if ((int )*s == 70) {
#line 805
        goto case_70;
      }
#line 810
      if ((int )*s == 82) {
#line 810
        goto case_82;
      }
#line 815
      if ((int )*s == 73) {
#line 815
        goto case_73;
      }
#line 820
      if ((int )*s == 79) {
#line 820
        goto case_79;
      }
#line 825
      if ((int )*s == 114) {
#line 825
        goto case_114;
      }
#line 830
      if ((int )*s == 115) {
#line 830
        goto case_115;
      }
#line 835
      if ((int )*s == 107) {
#line 835
        goto case_107;
      }
#line 840
      if ((int )*s == 119) {
#line 840
        goto case_119;
      }
#line 845
      if ((int )*s == 99) {
#line 845
        goto case_99;
      }
#line 849
      if ((int )*s == 74) {
#line 849
        goto case_74;
      }
#line 852
      if ((int )*s == 37) {
#line 852
        goto case_37;
      }
#line 855
      if ((int )*s == 0) {
#line 855
        goto case_0;
      }
#line 858
      goto switch_default___0;
      case_69: /* CIL Label */ 
      {
#line 723
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%4.2fs",
              elapsed_time);
      }
#line 724
      goto switch_break;
      case_85: /* CIL Label */ 
      {
#line 726
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%4.2fs",
              user_time);
      }
#line 727
      goto switch_break;
      case_83: /* CIL Label */ 
      {
#line 729
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%4.2fs",
              system_time);
      }
#line 730
      goto switch_break;
      case_42: /* CIL Label */ 
#line 732
      s ++;
      {
#line 733
      if ((int )*s == 69) {
#line 733
        goto case_69___0;
      }
#line 736
      if ((int )*s == 85) {
#line 736
        goto case_85___0;
      }
#line 739
      if ((int )*s == 83) {
#line 739
        goto case_83___0;
      }
#line 742
      goto switch_default;
      case_69___0: /* CIL Label */ 
      {
#line 734
      printhhmmss(elapsed_time);
      }
#line 735
      goto switch_break___0;
      case_85___0: /* CIL Label */ 
      {
#line 737
      printhhmmss(user_time);
      }
#line 738
      goto switch_break___0;
      case_83___0: /* CIL Label */ 
      {
#line 740
      printhhmmss(system_time);
      }
#line 741
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 743
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%%*");
#line 744
      s --;
      }
#line 745
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 747
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 749
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d%%",
              percent);
      }
#line 750
      goto switch_break;
      case_87: /* CIL Label */ 
      {
#line 753
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              ti->__annonCompField10.ru_nswap);
      }
#line 754
      goto switch_break;
      case_88: /* CIL Label */ 
#line 758
      if (total_time) {
#line 758
        tmp = (long )((double )ti->__annonCompField5.ru_ixrss / total_time);
      } else {
#line 758
        tmp = 0L;
      }
      {
#line 758
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              tmp);
      }
#line 762
      goto switch_break;
      case_68: /* CIL Label */ 
#line 766
      if (total_time) {
#line 766
        tmp___0 = (long )((double )(ti->__annonCompField6.ru_idrss + ti->__annonCompField7.ru_isrss) / total_time);
      } else {
#line 766
        tmp___0 = 0L;
      }
      {
#line 766
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              tmp___0);
      }
#line 774
      goto switch_break;
      case_75: /* CIL Label */ 
#line 781
      if (total_time) {
#line 781
        tmp___1 = (long )((double )((ti->__annonCompField5.ru_ixrss + ti->__annonCompField6.ru_idrss) + ti->__annonCompField7.ru_isrss) / total_time);
      } else {
#line 781
        tmp___1 = 0L;
      }
      {
#line 781
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              tmp___1);
      }
#line 797
      goto switch_break;
      case_77: /* CIL Label */ 
      {
#line 801
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              ti->__annonCompField4.ru_maxrss / 1024L);
      }
#line 802
      goto switch_break;
      case_70: /* CIL Label */ 
      {
#line 806
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              ti->__annonCompField9.ru_majflt);
      }
#line 807
      goto switch_break;
      case_82: /* CIL Label */ 
      {
#line 811
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              ti->__annonCompField8.ru_minflt);
      }
#line 812
      goto switch_break;
      case_73: /* CIL Label */ 
      {
#line 816
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              ti->__annonCompField11.ru_inblock);
      }
#line 817
      goto switch_break;
      case_79: /* CIL Label */ 
      {
#line 821
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              ti->__annonCompField12.ru_oublock);
      }
#line 822
      goto switch_break;
      case_114: /* CIL Label */ 
      {
#line 826
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              ti->__annonCompField14.ru_msgrcv);
      }
#line 827
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 831
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              ti->__annonCompField13.ru_msgsnd);
      }
#line 832
      goto switch_break;
      case_107: /* CIL Label */ 
      {
#line 836
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              ti->__annonCompField15.ru_nsignals);
      }
#line 837
      goto switch_break;
      case_119: /* CIL Label */ 
      {
#line 841
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              ti->__annonCompField16.ru_nvcsw);
      }
#line 842
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 846
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
              ti->__annonCompField17.ru_nivcsw);
      }
#line 847
      goto switch_break;
      case_74: /* CIL Label */ 
      {
#line 850
      fwrite((void const   */* __restrict  */)desc, sizeof(char ), (size_t )desclen,
             (FILE */* __restrict  */)stderr);
      }
#line 851
      goto switch_break;
      case_37: /* CIL Label */ 
      {
#line 853
      _IO_putc('%', stderr);
      }
#line 854
      goto switch_break;
      case_0: /* CIL Label */ 
#line 856
      s --;
#line 857
      goto switch_break;
      switch_default___0: /* CIL Label */ 
      {
#line 859
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%%%c",
              (int )*s);
      }
#line 860
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 862
      _IO_putc((int )*s, stderr);
      }
    }
#line 719
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 863
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 863
    queueing_enabled --;
#line 863
    if (! queueing_enabled) {
      {
#line 863
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 863
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 863
          if (! (queue_front != queue_rear)) {
#line 863
            goto while_break___2;
          }
          {
#line 863
          queue_front = (queue_front + 1) % 128;
#line 863
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 863
          zhandler(signal_queue[queue_front]);
#line 863
          signal_setmask(oset);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 863
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 863
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 864
  _IO_putc('\n', stderr);
#line 865
  fflush(stderr);
  }
#line 866
  return;
}
}
#line 869 "/tmp/zsh-5.4.2/Src/jobs.c"
static void dumptime(Job jn ) 
{ 
  Process pn ;
  struct timeval dtimeval ;
  struct timeval *tmp ;

  {
#line 875
  if (! jn->procs) {
#line 876
    return;
  }
#line 877
  pn = jn->procs;
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    if (! pn) {
#line 877
      goto while_break;
    }
    {
#line 878
    tmp = dtime(& dtimeval, & pn->bgtime, & pn->endtime);
#line 878
    printtime(tmp, & pn->ti, pn->text);
#line 877
    pn = pn->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 880
  return;
}
}
#line 888 "/tmp/zsh-5.4.2/Src/jobs.c"
static int should_report_time(Job j ) 
{ 
  struct value vbuf ;
  Value v ;
  char *s ;
  zlong reporttime ;
  char *sm ;
  zlong reportmemory ;
  sigset_t oset ;

  {
#line 893
  s = (char *)"REPORTTIME";
#line 894
  reporttime = (zlong )-1;
#line 896
  sm = (char *)"REPORTMEMORY";
#line 897
  reportmemory = (zlong )-1;
#line 901
  if (j->stat & 4) {
#line 902
    return (1);
  }
  {
#line 904
  queueing_enabled ++;
#line 905
  v = getvalue(& vbuf, & s, 0);
  }
#line 905
  if (v) {
    {
#line 906
    reporttime = getintvalue(v);
    }
  }
  {
#line 908
  v = getvalue(& vbuf, & sm, 0);
  }
#line 908
  if (v) {
    {
#line 909
    reportmemory = getintvalue(v);
    }
  }
  {
#line 911
  while (1) {
    while_continue: /* CIL Label */ ;
#line 911
    queueing_enabled --;
#line 911
    if (! queueing_enabled) {
      {
#line 911
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 911
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 911
          if (! (queue_front != queue_rear)) {
#line 911
            goto while_break___1;
          }
          {
#line 911
          queue_front = (queue_front + 1) % 128;
#line 911
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 911
          zhandler(signal_queue[queue_front]);
#line 911
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 911
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 911
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 912
  if (reporttime < 0L) {
#line 912
    if (reportmemory < 0L) {
#line 917
      return (0);
    }
  }
#line 919
  if (! j->procs) {
#line 920
    return (0);
  }
#line 921
  if (zleactive) {
#line 922
    return (0);
  }
#line 924
  if (reporttime >= 0L) {
#line 927
    reporttime -= (j->procs)->ti.ru_utime.tv_sec + (j->procs)->ti.ru_stime.tv_sec;
#line 929
    if ((j->procs)->ti.ru_utime.tv_usec + (j->procs)->ti.ru_stime.tv_usec >= 1000000L) {
#line 931
      reporttime --;
    }
#line 932
    if (reporttime <= 0L) {
#line 933
      return (1);
    }
  }
#line 944
  if (reportmemory >= 0L) {
#line 944
    if ((j->procs)->ti.__annonCompField4.ru_maxrss / 1024L > reportmemory) {
#line 946
      return (1);
    }
  }
#line 949
  return (0);
}
}
#line 969 "/tmp/zsh-5.4.2/Src/jobs.c"
int printjob(Job jn , int lng , int synch ) 
{ 
  Process pn ;
  int job ;
  int len ;
  int sig ;
  int sflag ;
  int llen ;
  int conted ;
  int lineleng ;
  int skip ;
  int doputnl ;
  int doneprint ;
  int skip_print ;
  FILE *fout ;
  struct _IO_FILE *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int len2 ;
  int fline ;
  int plainfmt ;
  int tmp___7 ;
  int thisfmt ;
  int tmp___8 ;
  Process qn ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  pid_t x ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  size_t tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char *txt ;
  char *tmp___21 ;
  int txtlen ;
  char const   *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 973
  len = 9;
#line 973
  sflag = 0;
#line 974
  conted = 0;
#line 974
  lineleng = (int )zterm_columns;
#line 974
  skip = 0;
#line 974
  doputnl = 0;
#line 975
  doneprint = 0;
#line 975
  skip_print = 0;
#line 976
  if (synch == 2) {
#line 976
    tmp = stdout;
  } else
#line 976
  if (! shout) {
#line 976
    tmp = stdout;
  } else {
#line 976
    tmp = shout;
  }
#line 976
  fout = tmp;
#line 978
  if (synch > 1) {
#line 978
    if ((unsigned long )oldjobtab != (unsigned long )((void *)0)) {
#line 979
      job = (int )(jn - oldjobtab);
    } else {
#line 981
      job = (int )(jn - jobtab);
    }
  } else {
#line 981
    job = (int )(jn - jobtab);
  }
#line 986
  if (jn->stat & 32) {
#line 987
    skip_print = 1;
  }
#line 990
  if (lng < 0) {
#line 991
    conted = 1;
#line 992
    lng = ! (! opts[111]);
  }
#line 998
  pn = jn->procs;
  {
#line 998
  while (1) {
    while_continue: /* CIL Label */ ;
#line 998
    if (! pn) {
#line 998
      goto while_break;
    }
#line 999
    if (jn->stat & 128) {
#line 999
      if ((jn->procs)->status == -1) {
#line 999
        if (! pn->next) {
#line 1001
          pn->status = -1;
        }
      }
    }
#line 1002
    if (pn->status != -1) {
#line 1003
      if ((int )((signed char )((pn->status & 127) + 1)) >> 1 > 0) {
#line 1004
        sig = pn->status & 127;
#line 1005
        if (sig <= 31) {
#line 1005
          tmp___0 = (char const   *)sig_msg[sig];
        } else {
#line 1005
          tmp___0 = "unknown signal";
        }
        {
#line 1005
        tmp___1 = strlen(tmp___0);
#line 1005
        llen = (int )tmp___1;
        }
#line 1006
        if (pn->status & 128) {
#line 1007
          llen += 14;
        }
#line 1008
        if (llen > len) {
#line 1009
          len = llen;
        }
#line 1010
        if (sig != 2) {
#line 1010
          if (sig != 13) {
#line 1011
            sflag = 1;
          }
        }
#line 1012
        if (job == thisjob) {
#line 1012
          if (sig == 2) {
#line 1013
            doputnl = 1;
          }
        }
#line 1014
        if (opts[138]) {
#line 1014
          if (opts[160]) {
#line 1015
            sflag = 1;
#line 1016
            skip_print = 0;
          }
        }
      } else
#line 1018
      if ((pn->status & 255) == 127) {
#line 1019
        sig = (pn->status & 65280) >> 8;
#line 1020
        if (sig <= 31) {
#line 1020
          tmp___4 = (char const   *)sig_msg[sig];
        } else {
#line 1020
          tmp___4 = "unknown signal";
        }
        {
#line 1020
        tmp___5 = strlen(tmp___4);
        }
#line 1020
        if ((int )tmp___5 > len) {
#line 1021
          if (sig <= 31) {
#line 1021
            tmp___2 = (char const   *)sig_msg[sig];
          } else {
#line 1021
            tmp___2 = "unknown signal";
          }
          {
#line 1021
          tmp___3 = strlen(tmp___2);
#line 1021
          len = (int )tmp___3;
          }
        }
#line 1022
        if (job == thisjob) {
#line 1022
          if (sig == 20) {
#line 1023
            doputnl = 1;
          }
        }
      } else
#line 1024
      if (opts[138]) {
#line 1024
        if (opts[160]) {
#line 1024
          if ((pn->status & 65280) >> 8) {
#line 1026
            sflag = 1;
#line 1027
            skip_print = 0;
          }
        }
      }
    }
#line 998
    pn = pn->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1032
  if (skip_print) {
#line 1033
    if (jn->stat & 8) {
#line 1035
      if (synch <= 1) {
        {
#line 1036
        storepipestats(jn, job == thisjob, job == thisjob);
        }
      }
      {
#line 1037
      tmp___6 = should_report_time(jn);
      }
#line 1037
      if (tmp___6) {
        {
#line 1038
        dumptime(jn);
        }
      }
      {
#line 1039
      deletejob(jn, 0);
      }
#line 1040
      if (job == curjob) {
#line 1041
        curjob = prevjob;
#line 1042
        prevjob = job;
      }
#line 1044
      if (job == prevjob) {
        {
#line 1045
        setprevjob();
        }
      }
    }
#line 1047
    return (0);
  }
#line 1056
  if (synch == 2) {
#line 1056
    goto _L___2;
  } else
#line 1056
  if (opts[93]) {
#line 1056
    goto _L___4;
  } else
#line 1056
  if (synch) {
    _L___4: /* CIL Label */ 
#line 1056
    if (opts[116]) {
#line 1056
      if (jn->stat & 2) {
#line 1056
        goto _L___2;
      } else
#line 1056
      if (sflag) {
#line 1056
        goto _L___2;
      } else
#line 1056
      if (job != thisjob) {
        _L___2: /* CIL Label */ 
#line 1059
        fline = 1;
#line 1061
        if (synch == 3) {
#line 1061
          if (opts[134]) {
#line 1061
            tmp___7 = 1;
          } else {
#line 1061
            tmp___7 = 0;
          }
        } else {
#line 1061
          tmp___7 = 0;
        }
#line 1061
        plainfmt = tmp___7;
#line 1063
        if (job == thisjob) {
#line 1063
          if (synch != 2) {
#line 1063
            tmp___8 = 1;
          } else {
#line 1063
            tmp___8 = 0;
          }
        } else {
#line 1063
          tmp___8 = 0;
        }
#line 1063
        thisfmt = tmp___8;
#line 1066
        if (! synch) {
          {
#line 1067
          zleentry(3);
          }
        }
#line 1068
        if (doputnl) {
#line 1068
          if (! synch) {
            {
#line 1069
            doneprint = 1;
#line 1070
            _IO_putc('\n', fout);
            }
          }
        }
#line 1072
        pn = jn->procs;
        {
#line 1072
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1072
          if (! pn) {
#line 1072
            goto while_break___0;
          }
#line 1073
          if (thisfmt) {
#line 1073
            tmp___9 = 5;
          } else {
#line 1073
            tmp___9 = 10;
          }
#line 1073
          len2 = tmp___9 + len;
#line 1074
          if (lng & 3) {
#line 1075
            qn = pn->next;
          } else {
#line 1077
            qn = pn->next;
            {
#line 1077
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1077
              if (! qn) {
#line 1077
                goto while_break___1;
              }
#line 1078
              if (qn->status != pn->status) {
#line 1079
                goto while_break___1;
              }
              {
#line 1080
              tmp___10 = strlen((char const   *)(qn->text));
              }
#line 1080
              if (qn->next) {
#line 1080
                tmp___11 = 3;
              } else {
#line 1080
                tmp___11 = 0;
              }
#line 1080
              if (((int )tmp___10 + len2) + tmp___11 > lineleng) {
#line 1082
                goto while_break___1;
              }
              {
#line 1083
              tmp___12 = strlen((char const   *)(qn->text));
#line 1083
              len2 = (int )((size_t )len2 + (tmp___12 + 2UL));
#line 1077
              qn = qn->next;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 1085
          doneprint = 1;
#line 1086
          if (! plainfmt) {
#line 1087
            if (! thisfmt) {
#line 1087
              goto _L;
            } else
#line 1087
            if (lng) {
              _L: /* CIL Label */ 
#line 1088
              if (fline) {
#line 1089
                if (job == curjob) {
#line 1089
                  tmp___14 = '+';
                } else {
#line 1089
                  if (job == prevjob) {
#line 1089
                    tmp___13 = '-';
                  } else {
#line 1089
                    tmp___13 = ' ';
                  }
#line 1089
                  tmp___14 = tmp___13;
                }
                {
#line 1089
                fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"[%ld]  %c ",
                        (long )job, tmp___14);
                }
              } else {
#line 1094
                if (job > 9) {
#line 1094
                  tmp___15 = "        ";
                } else {
#line 1094
                  tmp___15 = "       ";
                }
                {
#line 1094
                fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)tmp___15);
                }
              }
            } else {
              {
#line 1096
              fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"zsh: ");
              }
            }
#line 1097
            if (lng & 1) {
              {
#line 1098
              fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%ld ",
                      (long )pn->pid);
              }
            } else
#line 1099
            if (lng & 2) {
              {
#line 1100
              x = jn->gleader;
#line 1102
              fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%ld ",
                      (long )x);
              }
              {
#line 1103
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 1104
                skip ++;
#line 1103
                x /= 10;
#line 1103
                if (! x) {
#line 1103
                  goto while_break___2;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
#line 1106
              skip ++;
#line 1107
              lng &= -4;
            } else {
              {
#line 1109
              fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%*s",
                      skip, "");
              }
            }
#line 1110
            if (pn->status == -1) {
#line 1111
              if (! conted) {
                {
#line 1112
                fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"running%*s",
                        (len - 7) + 2, "");
                }
              } else {
                {
#line 1114
                fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"continued%*s",
                        (len - 9) + 2, "");
                }
              }
            } else
#line 1116
            if ((pn->status & 127) == 0) {
#line 1117
              if ((pn->status & 65280) >> 8) {
                {
#line 1118
                fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"exit %-4d%*s",
                        (pn->status & 65280) >> 8, (len - 9) + 2, "");
                }
              } else {
                {
#line 1121
                fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"done%*s",
                        (len - 4) + 2, "");
                }
              }
            } else
#line 1122
            if ((pn->status & 255) == 127) {
#line 1123
              if ((pn->status & 65280) >> 8 <= 31) {
#line 1123
                tmp___16 = (char const   *)sig_msg[(pn->status & 65280) >> 8];
              } else {
#line 1123
                tmp___16 = "unknown signal";
              }
              {
#line 1123
              fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%-*s",
                      len + 2, tmp___16);
              }
            } else
#line 1125
            if (pn->status & 128) {
#line 1126
              if ((pn->status & 127) <= 31) {
#line 1126
                tmp___17 = (char const   *)sig_msg[pn->status & 127];
              } else {
#line 1126
                tmp___17 = "unknown signal";
              }
              {
#line 1126
              tmp___18 = strlen(tmp___17);
              }
#line 1126
              if ((pn->status & 127) <= 31) {
#line 1126
                tmp___19 = (char const   *)sig_msg[pn->status & 127];
              } else {
#line 1126
                tmp___19 = "unknown signal";
              }
              {
#line 1126
              fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s (core dumped)%*s",
                      tmp___19, (int )((size_t )((len - 14) + 2) - tmp___18), "");
              }
            } else {
#line 1131
              if ((pn->status & 127) <= 31) {
#line 1131
                tmp___20 = (char const   *)sig_msg[pn->status & 127];
              } else {
#line 1131
                tmp___20 = "unknown signal";
              }
              {
#line 1131
              fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%-*s",
                      len + 2, tmp___20);
              }
            }
          }
          {
#line 1134
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1134
            if (! ((unsigned long )pn != (unsigned long )qn)) {
#line 1134
              goto while_break___3;
            }
            {
#line 1135
            tmp___21 = dupstring((char const   *)(pn->text));
#line 1135
            txt = tmp___21;
#line 1137
            unmetafy(txt, & txtlen);
#line 1138
            fwrite((void const   */* __restrict  */)txt, sizeof(char ), (size_t )txtlen,
                   (FILE */* __restrict  */)fout);
            }
#line 1139
            if (pn->next) {
              {
#line 1140
              fputs((char const   */* __restrict  */)" | ", (FILE */* __restrict  */)fout);
              }
            }
#line 1134
            pn = pn->next;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 1142
          _IO_putc('\n', fout);
#line 1143
          fline = 0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1145
        fflush(fout);
        }
      } else {
#line 1056
        goto _L___3;
      }
    } else {
#line 1056
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 1146
  if (doputnl) {
#line 1146
    if (opts[93]) {
#line 1146
      if (! synch) {
        {
#line 1147
        doneprint = 1;
#line 1148
        _IO_putc('\n', fout);
#line 1149
        fflush(fout);
        }
      }
    }
  }
#line 1156
  if (lng & 4) {
#line 1156
    goto _L___5;
  } else
#line 1156
  if (opts[93]) {
#line 1156
    if (job == thisjob) {
#line 1156
      if (jn->pwd) {
        {
#line 1156
        tmp___24 = strcmp((char const   *)jn->pwd, (char const   *)pwd);
        }
#line 1156
        if (tmp___24) {
          _L___5: /* CIL Label */ 
#line 1158
          doneprint = 1;
#line 1159
          if (lng & 4) {
#line 1159
            tmp___22 = "";
          } else {
#line 1159
            tmp___22 = "now";
          }
          {
#line 1159
          fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"(pwd %s: ",
                  tmp___22);
          }
#line 1160
          if (lng & 4) {
#line 1160
            if (jn->pwd) {
#line 1160
              tmp___23 = jn->pwd;
            } else {
#line 1160
              tmp___23 = pwd;
            }
          } else {
#line 1160
            tmp___23 = pwd;
          }
          {
#line 1160
          fprintdir(tmp___23, fout);
#line 1161
          fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)")\n");
#line 1162
          fflush(fout);
          }
        }
      }
    }
  }
#line 1167
  if (jn->stat & 8) {
#line 1169
    if (synch <= 1) {
      {
#line 1170
      storepipestats(jn, job == thisjob, job == thisjob);
      }
    }
    {
#line 1171
    tmp___25 = should_report_time(jn);
    }
#line 1171
    if (tmp___25) {
      {
#line 1172
      dumptime(jn);
      }
    }
    {
#line 1173
    deletejob(jn, 0);
    }
#line 1174
    if (job == curjob) {
#line 1175
      curjob = prevjob;
#line 1176
      prevjob = job;
    }
#line 1178
    if (job == prevjob) {
      {
#line 1179
      setprevjob();
      }
    }
  } else {
#line 1181
    jn->stat &= -2;
  }
#line 1183
  return (doneprint);
}
}
#line 1189 "/tmp/zsh-5.4.2/Src/jobs.c"
void addfilelist(char const   *name , int fd ) 
{ 
  Jobfile jf ;
  void *tmp ;
  LinkList ll ;
  LinkList tmp___0 ;

  {
  {
#line 1192
  tmp = zalloc(sizeof(struct jobfile ));
#line 1192
  jf = (Jobfile )tmp;
#line 1193
  ll = (jobtab + thisjob)->filelist;
  }
#line 1195
  if (! ll) {
    {
#line 1196
    tmp___0 = znewlinklist();
#line 1196
    (jobtab + thisjob)->filelist = tmp___0;
#line 1196
    ll = tmp___0;
    }
  }
#line 1197
  if (name) {
    {
#line 1199
    jf->u.name = ztrdup(name);
#line 1200
    jf->is_fd = 0;
    }
  } else {
#line 1204
    jf->u.fd = fd;
#line 1205
    jf->is_fd = 1;
  }
  {
#line 1207
  zinsertlinknode(ll, ll->list.last, (void *)jf);
  }
#line 1208
  return;
}
}
#line 1213 "/tmp/zsh-5.4.2/Src/jobs.c"
void pipecleanfilelist(LinkList filelist , int proc_subst_only ) 
{ 
  LinkNode node ;
  Jobfile jf ;
  LinkNode next___0 ;

  {
#line 1218
  if (! filelist) {
#line 1219
    return;
  }
#line 1220
  node = filelist->list.first;
  {
#line 1221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1221
    if (! node) {
#line 1221
      goto while_break;
    }
#line 1222
    jf = (Jobfile )node->dat;
#line 1223
    if (jf->is_fd) {
#line 1223
      if (! proc_subst_only) {
        {
#line 1229
        next___0 = node->next;
#line 1230
        zclose(jf->u.fd);
#line 1231
        remnode(filelist, node);
#line 1232
        zfree((void *)jf, (int )sizeof(*jf));
#line 1233
        node = next___0;
        }
      } else
#line 1223
      if ((int )*(fdtable + jf->u.fd) == 7) {
        {
#line 1229
        next___0 = node->next;
#line 1230
        zclose(jf->u.fd);
#line 1231
        remnode(filelist, node);
#line 1232
        zfree((void *)jf, (int )sizeof(*jf));
#line 1233
        node = next___0;
        }
      } else {
#line 1235
        node = node->next;
      }
    } else {
#line 1235
      node = node->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1237
  return;
}
}
#line 1242 "/tmp/zsh-5.4.2/Src/jobs.c"
void deletefilelist(LinkList file_list , int disowning ) 
{ 
  Jobfile jf ;
  void *tmp ;

  {
#line 1246
  if (file_list) {
    {
#line 1247
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1247
      tmp = getlinknode(file_list);
#line 1247
      jf = (Jobfile )tmp;
      }
#line 1247
      if (! jf) {
#line 1247
        goto while_break;
      }
#line 1248
      if (jf->is_fd) {
#line 1249
        if (! disowning) {
          {
#line 1250
          zclose(jf->u.fd);
          }
        }
      } else {
#line 1252
        if (! disowning) {
          {
#line 1253
          unlink((char const   *)jf->u.name);
          }
        }
        {
#line 1254
        zsfree(jf->u.name);
        }
      }
      {
#line 1256
      zfree((void *)jf, (int )sizeof(*jf));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1258
    zfree((void *)file_list, (int )sizeof(struct linklist ));
    }
  }
#line 1260
  return;
}
}
#line 1263 "/tmp/zsh-5.4.2/Src/jobs.c"
void freejob(Job jn , int deleting ) 
{ 
  struct process *pn ;
  struct process *nx ;
  int job ;
  pid_t tmp ;
  int tmp___0 ;

  {
#line 1268
  pn = jn->procs;
#line 1269
  jn->procs = (struct process *)((void *)0);
  {
#line 1270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1270
    if (! pn) {
#line 1270
      goto while_break;
    }
    {
#line 1271
    nx = pn->next;
#line 1272
    zfree((void *)pn, (int )sizeof(struct process ));
#line 1270
    pn = nx;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1275
  pn = jn->auxprocs;
#line 1276
  jn->auxprocs = (struct process *)((void *)0);
  {
#line 1277
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1277
    if (! pn) {
#line 1277
      goto while_break___0;
    }
    {
#line 1278
    nx = pn->next;
#line 1279
    zfree((void *)pn, (int )sizeof(struct process ));
#line 1277
    pn = nx;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1282
  if (jn->ty) {
    {
#line 1283
    zfree((void *)jn->ty, (int )sizeof(struct ttyinfo ));
    }
  }
#line 1284
  if (jn->pwd) {
    {
#line 1285
    zsfree(jn->pwd);
    }
  }
#line 1286
  jn->pwd = (char *)((void *)0);
#line 1287
  if (jn->stat & 512) {
#line 1289
    job = (int )(jn - jobtab);
#line 1290
    if (deleting) {
      {
#line 1291
      deletejob(jobtab + jn->other, 0);
      }
    } else {
      {
#line 1293
      freejob(jobtab + jn->other, 0);
      }
    }
#line 1294
    jn = jobtab + job;
  }
#line 1296
  tmp = 0;
#line 1296
  jn->other = tmp;
#line 1296
  jn->gleader = tmp;
#line 1297
  tmp___0 = 0;
#line 1297
  jn->stty_in_env = tmp___0;
#line 1297
  jn->stat = tmp___0;
#line 1298
  jn->filelist = (LinkList )((void *)0);
#line 1299
  jn->ty = (struct ttyinfo *)((void *)0);
#line 1302
  if ((long )maxjob == jn - jobtab) {
    {
#line 1303
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1303
      if (maxjob) {
#line 1303
        if (! (! ((jobtab + maxjob)->stat & 64))) {
#line 1303
          goto while_break___1;
        }
      } else {
#line 1303
        goto while_break___1;
      }
#line 1304
      maxjob --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1306
  return;
}
}
#line 1318 "/tmp/zsh-5.4.2/Src/jobs.c"
void deletejob(Job jn , int disowning ) 
{ 
  Job jno ;

  {
  {
#line 1321
  deletefilelist(jn->filelist, disowning);
  }
#line 1322
  if (jn->stat & 4096) {
    {
#line 1323
    attachtty(mypgrp);
#line 1324
    adjustwinsize(0);
    }
  }
#line 1326
  if (jn->stat & 128) {
#line 1327
    jno = jobtab + jn->other;
#line 1328
    if (jno->stat & 256) {
#line 1329
      jno->stat |= 32768;
    }
  }
  {
#line 1332
  freejob(jn, 1);
  }
#line 1333
  return;
}
}
#line 1344 "/tmp/zsh-5.4.2/Src/jobs.c"
void addproc(pid_t pid , char *text , int aux , struct timeval *bgtime ) 
{ 
  Process pn ;
  Process *pnlist ;
  void *tmp ;
  Process n ;

  {
  {
#line 1350
  tmp = zshcalloc(sizeof(*pn));
#line 1350
  pn = (Process )tmp;
#line 1351
  pn->pid = pid;
  }
#line 1352
  if (text) {
    {
#line 1353
    strcpy((char */* __restrict  */)(pn->text), (char const   */* __restrict  */)text);
    }
  } else {
#line 1355
    pn->text[0] = (char )'\000';
  }
#line 1356
  pn->status = -1;
#line 1357
  pn->next = (struct process *)((void *)0);
#line 1359
  if (! aux) {
#line 1361
    pn->bgtime = *bgtime;
#line 1364
    if (! (jobtab + thisjob)->gleader) {
#line 1365
      (jobtab + thisjob)->gleader = pid;
    }
#line 1367
    pnlist = & (jobtab + thisjob)->procs;
  } else {
#line 1370
    pnlist = & (jobtab + thisjob)->auxprocs;
  }
#line 1372
  if (*pnlist) {
#line 1375
    n = *pnlist;
    {
#line 1375
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1375
      if (! n->next) {
#line 1375
        goto while_break;
      }
#line 1375
      n = n->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1376
    n->next = pn;
  } else {
#line 1379
    *pnlist = pn;
  }
#line 1387
  (jobtab + thisjob)->stat &= -9;
#line 1388
  return;
}
}
#line 1395 "/tmp/zsh-5.4.2/Src/jobs.c"
int havefiles(void) 
{ 
  int i ;

  {
#line 1400
  i = 1;
  {
#line 1400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1400
    if (! (i <= maxjob)) {
#line 1400
      goto while_break;
    }
#line 1401
    if ((jobtab + i)->stat) {
#line 1401
      if ((jobtab + i)->filelist) {
#line 1402
        return (1);
      }
    }
#line 1400
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1403
  return (0);
}
}
#line 1415 "/tmp/zsh-5.4.2/Src/jobs.c"
int waitforpid(pid_t pid , int wait_cmd ) 
{ 
  int first ;
  int q ;
  sigset_t oset ;
  int tmp ;
  int *tmp___0 ;

  {
#line 1418
  first = 1;
#line 1418
  q = queueing_enabled;
  {
#line 1421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1421
    queueing_enabled = 0;
    {
#line 1421
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1421
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1421
        if (! (queue_front != queue_rear)) {
#line 1421
          goto while_break___1;
        }
        {
#line 1421
        queue_front = (queue_front + 1) % 128;
#line 1421
        oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1421
        zhandler(signal_queue[queue_front]);
#line 1421
        signal_setmask(oset);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1421
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1421
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1422
  signal_block(sigchld_mask);
#line 1423
  queue_traps(wait_cmd);
  }
  {
#line 1431
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1431
    if (! errflag) {
      {
#line 1431
      tmp = kill(pid, 0);
      }
#line 1431
      if (! (tmp >= 0)) {
        {
#line 1431
        tmp___0 = __errno_location();
        }
#line 1431
        if (! (*tmp___0 != 3)) {
#line 1431
          goto while_break___2;
        }
      }
    } else {
#line 1431
      goto while_break___2;
    }
#line 1432
    if (first) {
#line 1433
      first = 0;
    } else
#line 1434
    if (! wait_cmd) {
      {
#line 1435
      kill(pid, 18);
      }
    }
    {
#line 1437
    last_signal = -1;
#line 1438
    signal_suspend(17, wait_cmd);
    }
#line 1439
    if (last_signal != 17) {
#line 1439
      if (wait_cmd) {
#line 1439
        if (last_signal >= 0) {
#line 1439
          if (sigtrapped[last_signal] & 1) {
#line 1442
            queueing_enabled = q;
#line 1443
            return (128 + last_signal);
          }
        }
      }
    }
    {
#line 1445
    signal_block(sigchld_mask);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1447
  unqueue_traps();
#line 1448
  signal_unblock(sigchld_mask);
#line 1449
  queueing_enabled = q;
  }
#line 1451
  return (0);
}
}
#line 1461 "/tmp/zsh-5.4.2/Src/jobs.c"
static int zwaitjob(int job , int wait_cmd ) 
{ 
  int q ;
  Job jn ;
  sigset_t oset ;
  int tmp ;

  {
  {
#line 1464
  q = queueing_enabled;
#line 1465
  jn = jobtab + job;
#line 1467
  signal_block(sigchld_mask);
#line 1468
  queue_traps(wait_cmd);
  }
  {
#line 1469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1469
    queueing_enabled = 0;
    {
#line 1469
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1469
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1469
        if (! (queue_front != queue_rear)) {
#line 1469
          goto while_break___1;
        }
        {
#line 1469
        queue_front = (queue_front + 1) % 128;
#line 1469
        oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1469
        zhandler(signal_queue[queue_front]);
#line 1469
        signal_setmask(oset);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1469
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1469
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1470
  if (jn->procs) {
#line 1470
    goto _L;
  } else
#line 1470
  if (jn->auxprocs) {
    _L: /* CIL Label */ 
#line 1471
    jn->stat |= 16;
#line 1472
    if (jn->stat & 1) {
      {
#line 1473
      printjob(jn, ! (! opts[111]), 1);
      }
    }
#line 1474
    if (jn->filelist) {
      {
#line 1485
      pipecleanfilelist(jn->filelist, 0);
      }
    }
    {
#line 1487
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1487
      if (! (errflag & 1)) {
#line 1487
        if (jn->stat) {
#line 1487
          if (! (jn->stat & 8)) {
#line 1487
            if (opts[93]) {
#line 1487
              if (jn->stat & 2) {
#line 1487
                goto while_break___2;
              }
            }
          } else {
#line 1487
            goto while_break___2;
          }
        } else {
#line 1487
          goto while_break___2;
        }
      } else {
#line 1487
        goto while_break___2;
      }
      {
#line 1490
      signal_suspend(17, wait_cmd);
      }
#line 1491
      if (last_signal != 17) {
#line 1491
        if (wait_cmd) {
#line 1491
          if (last_signal >= 0) {
#line 1491
            if (sigtrapped[last_signal] & 1) {
#line 1495
              queueing_enabled = q;
#line 1496
              return (128 + last_signal);
            }
          }
        }
      }
#line 1518
      if (subsh) {
        {
#line 1519
        killjb(jn, 18);
#line 1520
        jn->stat &= -3;
        }
      }
#line 1522
      if (jn->stat & 128) {
        {
#line 1523
        tmp = handle_sub((int )(jn - jobtab), 1);
        }
#line 1523
        if (tmp) {
#line 1524
          goto while_break___2;
        }
      }
      {
#line 1525
      signal_block(sigchld_mask);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 1528
    deletejob(jn, 0);
#line 1529
    pipestats[0] = (int )lastval;
#line 1530
    numpipestats = 1;
    }
  }
  {
#line 1532
  queueing_enabled = q;
#line 1533
  unqueue_traps();
#line 1534
  signal_unblock(sigchld_mask);
  }
#line 1536
  return (0);
}
}
#line 1542 "/tmp/zsh-5.4.2/Src/jobs.c"
void waitjobs(void) 
{ 
  Job jn ;

  {
#line 1545
  jn = jobtab + thisjob;
#line 1548
  if (jn->procs) {
    {
#line 1549
    zwaitjob(thisjob, 0);
    }
  } else
#line 1548
  if (jn->auxprocs) {
    {
#line 1549
    zwaitjob(thisjob, 0);
    }
  } else {
    {
#line 1551
    deletejob(jn, 0);
#line 1552
    pipestats[0] = (int )lastval;
#line 1553
    numpipestats = 1;
    }
  }
#line 1555
  thisjob = -1;
#line 1556
  return;
}
}
#line 1561 "/tmp/zsh-5.4.2/Src/jobs.c"
void clearjobtab(int monitor ) 
{ 
  int i ;
  int sz___0 ;
  void *tmp ;

  {
#line 1566
  if (opts[134]) {
#line 1567
    oldmaxjob = 0;
  }
#line 1568
  i = 1;
  {
#line 1568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1568
    if (! (i <= maxjob)) {
#line 1568
      goto while_break;
    }
#line 1575
    if (monitor) {
#line 1575
      if (! opts[134]) {
#line 1575
        if ((jobtab + i)->stat) {
#line 1576
          oldmaxjob = i + 1;
        } else {
#line 1575
          goto _L___0;
        }
      } else {
#line 1575
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1577
    if ((jobtab + i)->stat & 64) {
      {
#line 1578
      freejob(jobtab + i, 0);
      }
    }
#line 1568
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1581
  if (monitor) {
#line 1581
    if (oldmaxjob) {
#line 1582
      sz___0 = (int )((unsigned long )oldmaxjob * sizeof(struct job ));
#line 1583
      if (oldjobtab) {
        {
#line 1584
        free((void *)oldjobtab);
        }
      }
      {
#line 1585
      tmp = zalloc((size_t )sz___0);
#line 1585
      oldjobtab = (struct job *)tmp;
#line 1586
      memcpy((void */* __restrict  */)oldjobtab, (void const   */* __restrict  */)jobtab,
             (size_t )sz___0);
      }
#line 1589
      if (thisjob != -1) {
#line 1589
        if (thisjob < oldmaxjob) {
          {
#line 1590
          memset((void *)(oldjobtab + thisjob), 0, sizeof(struct job ));
          }
        }
      }
    }
  }
  {
#line 1593
  memset((void *)jobtab, 0, (unsigned long )jobtabsize * sizeof(struct job ));
#line 1594
  maxjob = 0;
#line 1603
  thisjob = initjob();
  }
#line 1604
  return;
}
}
#line 1606 "/tmp/zsh-5.4.2/Src/jobs.c"
static int initnewjob(int i ) 
{ 


  {
#line 1608
  (jobtab + i)->stat = 64;
#line 1609
  if ((jobtab + i)->pwd) {
    {
#line 1610
    zsfree((jobtab + i)->pwd);
#line 1611
    (jobtab + i)->pwd = (char *)((void *)0);
    }
  }
#line 1613
  (jobtab + i)->gleader = 0;
#line 1615
  if (i > maxjob) {
#line 1616
    maxjob = i;
  }
#line 1618
  return (i);
}
}
#line 1624 "/tmp/zsh-5.4.2/Src/jobs.c"
int initjob(void) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1629
  i = 1;
  {
#line 1629
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1629
    if (! (i <= maxjob)) {
#line 1629
      goto while_break;
    }
#line 1630
    if (! (jobtab + i)->stat) {
      {
#line 1631
      tmp = initnewjob(i);
      }
#line 1631
      return (tmp);
    }
#line 1629
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1632
  if (maxjob + 1 < jobtabsize) {
    {
#line 1633
    tmp___0 = initnewjob(maxjob + 1);
    }
#line 1633
    return (tmp___0);
  }
  {
#line 1635
  tmp___2 = expandjobtab();
  }
#line 1635
  if (tmp___2) {
    {
#line 1636
    tmp___1 = initnewjob(i);
    }
#line 1636
    return (tmp___1);
  }
  {
#line 1638
  zerr("job table full or recursion limit exceeded");
  }
#line 1639
  return (-1);
}
}
#line 1643 "/tmp/zsh-5.4.2/Src/jobs.c"
void setjobpwd(void) 
{ 
  int i ;

  {
#line 1648
  i = 1;
  {
#line 1648
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1648
    if (! (i <= maxjob)) {
#line 1648
      goto while_break;
    }
#line 1649
    if ((jobtab + i)->stat) {
#line 1649
      if (! (jobtab + i)->pwd) {
        {
#line 1650
        (jobtab + i)->pwd = ztrdup((char const   *)pwd);
        }
      }
    }
#line 1648
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1651
  return;
}
}
#line 1656 "/tmp/zsh-5.4.2/Src/jobs.c"
void spawnjob(void) 
{ 
  Process pn ;
  FILE *fout ;
  FILE *tmp ;
  int tmp___0 ;

  {
#line 1663
  if (! subsh) {
#line 1664
    if (curjob == -1) {
      {
#line 1665
      curjob = thisjob;
#line 1666
      setprevjob();
      }
    } else
#line 1664
    if (! ((jobtab + curjob)->stat & 2)) {
      {
#line 1665
      curjob = thisjob;
#line 1666
      setprevjob();
      }
    } else
#line 1667
    if (prevjob == -1) {
#line 1668
      prevjob = thisjob;
    } else
#line 1667
    if (! ((jobtab + prevjob)->stat & 2)) {
#line 1668
      prevjob = thisjob;
    }
#line 1669
    if (opts[116]) {
#line 1669
      if ((jobtab + thisjob)->procs) {
#line 1670
        if (shout) {
#line 1670
          tmp = shout;
        } else {
#line 1670
          tmp = stdout;
        }
        {
#line 1670
        fout = tmp;
#line 1671
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"[%d]",
                thisjob);
#line 1672
        pn = (jobtab + thisjob)->procs;
        }
        {
#line 1672
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1672
          if (! pn) {
#line 1672
            goto while_break;
          }
          {
#line 1673
          fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" %ld",
                  (long )pn->pid);
#line 1672
          pn = pn->next;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1674
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 1675
        fflush(fout);
        }
      }
    }
  }
  {
#line 1678
  tmp___0 = hasprocs(thisjob);
  }
#line 1678
  if (tmp___0) {
    {
#line 1681
    (jobtab + thisjob)->stat |= 16;
#line 1682
    pipecleanfilelist((jobtab + thisjob)->filelist, 0);
    }
  } else {
    {
#line 1679
    deletejob(jobtab + thisjob, 0);
    }
  }
#line 1684
  thisjob = -1;
#line 1685
  return;
}
}
#line 1688 "/tmp/zsh-5.4.2/Src/jobs.c"
void shelltime(void) 
{ 
  struct timezone dummy_tz ;
  struct timeval dtimeval ;
  struct timeval now ;
  child_times_t ti ;
  struct timeval *tmp ;

  {
  {
#line 1698
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )(& dummy_tz));
#line 1701
  getrusage((__rusage_who_t )0, & ti);
#line 1708
  tmp = dtime(& dtimeval, & shtimer, & now);
#line 1708
  printtime(tmp, & ti, (char *)"shell");
#line 1711
  getrusage((__rusage_who_t )-1, & ti);
#line 1716
  printtime(& dtimeval, & ti, (char *)"children");
  }
#line 1718
  return;
}
}
#line 1723 "/tmp/zsh-5.4.2/Src/jobs.c"
void scanjobs(void) 
{ 
  int i ;

  {
#line 1728
  i = 1;
  {
#line 1728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1728
    if (! (i <= maxjob)) {
#line 1728
      goto while_break;
    }
#line 1729
    if ((jobtab + i)->stat & 1) {
      {
#line 1730
      printjob(jobtab + i, ! (! opts[111]), 1);
      }
    }
#line 1728
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1731
  return;
}
}
#line 1741 "/tmp/zsh-5.4.2/Src/jobs.c"
static int isanum(char *s ) 
{ 


  {
  {
#line 1744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1744
    if (! ((int )*s == 45)) {
#line 1744
      if (! ((int )typtab[(unsigned char )*s] & 1)) {
#line 1744
        goto while_break;
      }
    }
#line 1745
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1746
  return ((int )*s == 0);
}
}
#line 1752 "/tmp/zsh-5.4.2/Src/jobs.c"
static void setcurjob(void) 
{ 


  {
#line 1755
  if (curjob == thisjob) {
#line 1755
    goto _L;
  } else
#line 1755
  if (curjob != -1) {
#line 1755
    if (! ((jobtab + curjob)->stat & 64)) {
      _L: /* CIL Label */ 
      {
#line 1757
      curjob = prevjob;
#line 1758
      setprevjob();
      }
#line 1759
      if (curjob == thisjob) {
        {
#line 1762
        curjob = prevjob;
#line 1763
        setprevjob();
        }
      } else
#line 1759
      if (curjob != -1) {
#line 1759
        if ((jobtab + curjob)->stat & 64) {
#line 1759
          if (! (curjob != thisjob)) {
            {
#line 1762
            curjob = prevjob;
#line 1763
            setprevjob();
            }
          }
        } else {
          {
#line 1762
          curjob = prevjob;
#line 1763
          setprevjob();
          }
        }
      }
    }
  }
#line 1766
  return;
}
}
#line 1772 "/tmp/zsh-5.4.2/Src/jobs.c"
int getjob(char const   *s , char const   *prog ) 
{ 
  int jobnum ;
  int returnval ;
  int mymaxjob ;
  Job myjobtab ;
  struct process *pn ;
  char *tmp ;

  {
#line 1778
  if (oldjobtab) {
#line 1779
    myjobtab = oldjobtab;
#line 1780
    mymaxjob = oldmaxjob;
  } else {
#line 1782
    myjobtab = jobtab;
#line 1783
    mymaxjob = maxjob;
  }
#line 1787
  if ((int const   )*s != 37) {
#line 1788
    goto jump;
  }
#line 1789
  s ++;
#line 1791
  if ((int const   )*s == 37) {
#line 1791
    goto _L;
  } else
#line 1791
  if ((int const   )*s == 43) {
#line 1791
    goto _L;
  } else
#line 1791
  if (! *s) {
    _L: /* CIL Label */ 
#line 1792
    if (curjob == -1) {
#line 1793
      if (prog) {
        {
#line 1794
        zwarnnam(prog, "no current job");
        }
      }
#line 1795
      returnval = -1;
#line 1796
      goto done;
    }
#line 1798
    returnval = curjob;
#line 1799
    goto done;
  }
#line 1802
  if ((int const   )*s == 45) {
#line 1803
    if (prevjob == -1) {
#line 1804
      if (prog) {
        {
#line 1805
        zwarnnam(prog, "no previous job");
        }
      }
#line 1806
      returnval = -1;
#line 1807
      goto done;
    }
#line 1809
    returnval = prevjob;
#line 1810
    goto done;
  }
#line 1813
  if ((int )typtab[(unsigned char )*s] & 1) {
    {
#line 1814
    jobnum = atoi(s);
    }
#line 1815
    if (jobnum) {
#line 1815
      if (jobnum <= mymaxjob) {
#line 1815
        if ((myjobtab + jobnum)->stat) {
#line 1815
          if (! ((myjobtab + jobnum)->stat & 256)) {
#line 1815
            if ((unsigned long )myjobtab == (unsigned long )oldjobtab) {
#line 1824
              returnval = jobnum;
#line 1825
              goto done;
            } else
#line 1815
            if (jobnum != thisjob) {
#line 1824
              returnval = jobnum;
#line 1825
              goto done;
            }
          }
        }
      }
    }
#line 1827
    if (prog) {
      {
#line 1828
      zwarnnam(prog, "%%%s: no such job", s);
      }
    }
#line 1829
    returnval = -1;
#line 1830
    goto done;
  }
#line 1833
  if ((int const   )*s == 63) {
#line 1836
    jobnum = mymaxjob;
    {
#line 1836
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1836
      if (! (jobnum >= 0)) {
#line 1836
        goto while_break;
      }
#line 1837
      if ((myjobtab + jobnum)->stat) {
#line 1837
        if (! ((myjobtab + jobnum)->stat & 256)) {
#line 1837
          if (jobnum != thisjob) {
#line 1840
            pn = (myjobtab + jobnum)->procs;
            {
#line 1840
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1840
              if (! pn) {
#line 1840
                goto while_break___0;
              }
              {
#line 1841
              tmp = strstr((char const   *)(pn->text), s + 1);
              }
#line 1841
              if (tmp) {
#line 1842
                returnval = jobnum;
#line 1843
                goto done;
              }
#line 1840
              pn = pn->next;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
      }
#line 1836
      jobnum --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1845
    if (prog) {
      {
#line 1846
      zwarnnam(prog, "job not found: %s", s);
      }
    }
#line 1847
    returnval = -1;
#line 1848
    goto done;
  }
  jump: 
  {
#line 1853
  jobnum = findjobnam(s);
  }
#line 1853
  if (jobnum != -1) {
#line 1854
    returnval = jobnum;
#line 1855
    goto done;
  }
  {
#line 1859
  zwarnnam(prog, "job not found: %s", s);
#line 1860
  returnval = -1;
  }
  done: 
#line 1862
  return (returnval);
}
}
#line 1870 "/tmp/zsh-5.4.2/Src/jobs.c"
static char *hackzero  ;
#line 1871 "/tmp/zsh-5.4.2/Src/jobs.c"
static int hackspace  ;
#line 1878 "/tmp/zsh-5.4.2/Src/jobs.c"
void init_jobs(char **argv , char **envp ) 
{ 
  char *p ;
  char *q ;
  size_t init_bytes ;
  void *tmp ;

  {
  {
#line 1884
  init_bytes = 50UL * sizeof(struct job );
#line 1889
  tmp = zalloc(init_bytes);
#line 1889
  jobtab = (struct job *)tmp;
  }
#line 1890
  if (! jobtab) {
    {
#line 1891
    zerr("failed to allocate job table, aborting.");
#line 1892
    exit(1);
    }
  }
  {
#line 1894
  jobtabsize = 50;
#line 1895
  memset((void *)jobtab, 0, init_bytes);
#line 1904
  hackzero = *argv;
#line 1905
  p = strchr((char const   *)hackzero, 0);
  }
  {
#line 1906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1906
    argv ++;
#line 1906
    if (! *argv) {
#line 1906
      goto while_break;
    }
#line 1907
    q = *argv;
#line 1908
    if ((unsigned long )q != (unsigned long )(p + 1)) {
#line 1909
      goto done;
    }
    {
#line 1910
    p = strchr((char const   *)q, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 1921
  hackspace = (int )(p - hackzero);
#line 1923
  return;
}
}
#line 1939 "/tmp/zsh-5.4.2/Src/jobs.c"
int expandjobtab(void) 
{ 
  int newsize ;
  struct job *newjobtab ;
  void *tmp ;

  {
#line 1942
  newsize = jobtabsize + 50;
#line 1945
  if (newsize > 1000) {
#line 1946
    return (0);
  }
  {
#line 1948
  tmp = zrealloc((void *)jobtab, (unsigned long )newsize * sizeof(struct job ));
#line 1948
  newjobtab = (struct job *)tmp;
  }
#line 1949
  if (! newjobtab) {
#line 1950
    return (0);
  }
  {
#line 1956
  memset((void *)(newjobtab + jobtabsize), 0, 50UL * sizeof(struct job ));
#line 1958
  jobtab = newjobtab;
#line 1959
  jobtabsize = newsize;
  }
#line 1961
  return (1);
}
}
#line 1973 "/tmp/zsh-5.4.2/Src/jobs.c"
void maybeshrinkjobtab(void) 
{ 
  int jobbound ;
  struct job *newjobtab ;
  void *tmp ;
  sigset_t oset ;

  {
#line 1978
  queueing_enabled ++;
#line 1979
  jobbound = (maxjob + 50) - maxjob % 50;
#line 1980
  if (jobbound < jobtabsize) {
#line 1980
    if (jobbound > maxjob + 20) {
      {
#line 1984
      tmp = zrealloc((void *)jobtab, (unsigned long )jobbound * sizeof(struct job ));
#line 1984
      newjobtab = (struct job *)tmp;
      }
#line 1987
      if (newjobtab) {
#line 1988
        jobtab = newjobtab;
#line 1989
        jobtabsize = jobbound;
      }
    }
  }
  {
#line 1992
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1992
    queueing_enabled --;
#line 1992
    if (! queueing_enabled) {
      {
#line 1992
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1992
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1992
          if (! (queue_front != queue_rear)) {
#line 1992
            goto while_break___1;
          }
          {
#line 1992
          queue_front = (queue_front + 1) % 128;
#line 1992
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1992
          zhandler(signal_queue[queue_front]);
#line 1992
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1992
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1992
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1993
  return;
}
}
#line 2017 "/tmp/zsh-5.4.2/Src/jobs.c"
static LinkList bgstatus_list  ;
#line 2019 "/tmp/zsh-5.4.2/Src/jobs.c"
static long bgstatus_count  ;
#line 2024 "/tmp/zsh-5.4.2/Src/jobs.c"
static void rembgstatus(LinkNode node ) 
{ 
  void *tmp ;

  {
  {
#line 2026
  tmp = remnode(bgstatus_list, node);
#line 2026
  zfree(tmp, (int )sizeof(struct bgstatus ));
#line 2027
  bgstatus_count --;
  }
#line 2028
  return;
}
}
#line 2042 "/tmp/zsh-5.4.2/Src/jobs.c"
static long child_max  ;
#line 2039 "/tmp/zsh-5.4.2/Src/jobs.c"
void addbgstatus(pid_t pid , int status ) 
{ 
  Bgstatus bgstatus_entry ;
  void *tmp ;
  LinkNode tmp___0 ;

  {
#line 2045
  if (! child_max) {
    {
#line 2047
    child_max = sysconf(1);
    }
#line 2048
    if (! child_max) {
#line 2052
      child_max = 1024L;
    }
  }
#line 2056
  if (! bgstatus_list) {
    {
#line 2057
    bgstatus_list = znewlinklist();
    }
#line 2064
    if (! bgstatus_list) {
#line 2065
      return;
    }
  }
#line 2067
  if (bgstatus_count == child_max) {
    {
#line 2069
    rembgstatus(bgstatus_list->list.first);
    }
  }
  {
#line 2071
  tmp = zalloc(sizeof(*bgstatus_entry));
#line 2071
  bgstatus_entry = (Bgstatus )tmp;
  }
#line 2072
  if (! bgstatus_entry) {
#line 2074
    return;
  }
  {
#line 2076
  bgstatus_entry->pid = pid;
#line 2077
  bgstatus_entry->status = status;
#line 2078
  tmp___0 = zinsertlinknode(bgstatus_list, bgstatus_list->list.last, (void *)bgstatus_entry);
  }
#line 2078
  if (! tmp___0) {
    {
#line 2079
    zfree((void *)bgstatus_entry, (int )sizeof(*bgstatus_entry));
    }
#line 2080
    return;
  }
#line 2082
  bgstatus_count ++;
#line 2083
  return;
}
}
#line 2094 "/tmp/zsh-5.4.2/Src/jobs.c"
static int getbgstatus(pid_t pid ) 
{ 
  LinkNode node ;
  Bgstatus bgstatus_entry ;
  int status ;

  {
#line 2099
  if (! bgstatus_list) {
#line 2100
    return (-1);
  }
#line 2101
  node = bgstatus_list->list.first;
  {
#line 2101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2101
    if (! node) {
#line 2101
      goto while_break;
    }
#line 2102
    bgstatus_entry = (Bgstatus )node->dat;
#line 2103
    if (bgstatus_entry->pid == pid) {
      {
#line 2104
      status = bgstatus_entry->status;
#line 2105
      rembgstatus(node);
      }
#line 2106
      return (status);
    }
#line 2101
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2109
  return (-1);
}
}
#line 2117 "/tmp/zsh-5.4.2/Src/jobs.c"
int bin_fg(char *name , char **argv , Options ops , int func ) 
{ 
  int job ;
  int lng ;
  int firstjob ;
  int retval ;
  int ofunc ;
  int len ;
  sigset_t oset ;
  int tmp ;
  sigset_t oset___0 ;
  struct job *jobptr ;
  int curmaxjob ;
  int ignorejob ;
  sigset_t oset___1 ;
  sigset_t oset___2 ;
  char **tmp___0 ;
  int tmp___1 ;
  int stopped ;
  int ocj ;
  int jstat ;
  pid_t pid ;
  int tmp___2 ;
  Job j ;
  Process p ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  sigset_t oset___3 ;
  int tmp___6 ;
  sigset_t oset___4 ;
  Process pn ;
  Process next___0 ;
  sigset_t oset___5 ;
  int tmp___7 ;
  FILE *fout ;
  struct _IO_FILE *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct job *tmp___11 ;
  char buf___7[20] ;
  char *pids ;
  Process pn___0 ;
  sigset_t oset___6 ;

  {
#line 2120
  firstjob = -1;
#line 2120
  retval = 0;
#line 2120
  ofunc = func;
#line 2122
  if ((int )ops->ind[90] != 0) {
#line 2125
    if (opts[154]) {
      {
#line 2126
      zwarnnam((char const   *)name, "-Z is restricted");
      }
#line 2127
      return (1);
    }
#line 2129
    if (! *(argv + 0)) {
      {
#line 2130
      zwarnnam((char const   *)name, "-Z requires one argument");
      }
#line 2131
      return (1);
    } else
#line 2129
    if (*(argv + 1)) {
      {
#line 2130
      zwarnnam((char const   *)name, "-Z requires one argument");
      }
#line 2131
      return (1);
    }
    {
#line 2133
    queueing_enabled ++;
#line 2134
    unmetafy(*argv, & len);
    }
#line 2138
    if (len > hackspace) {
#line 2139
      len = hackspace;
    }
    {
#line 2140
    memcpy((void */* __restrict  */)hackzero, (void const   */* __restrict  */)*argv,
           (size_t )len);
#line 2141
    memset((void *)(hackzero + len), 0, (size_t )(hackspace - len));
    }
    {
#line 2143
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2143
      queueing_enabled --;
#line 2143
      if (! queueing_enabled) {
        {
#line 2143
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 2143
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2143
            if (! (queue_front != queue_rear)) {
#line 2143
              goto while_break___1;
            }
            {
#line 2143
            queue_front = (queue_front + 1) % 128;
#line 2143
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 2143
            zhandler(signal_queue[queue_front]);
#line 2143
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2143
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 2143
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 2144
    return (0);
  }
#line 2147
  if (func == 3) {
#line 2148
    if ((int )ops->ind[108] != 0) {
#line 2148
      lng = 1;
    } else {
#line 2148
      if ((int )ops->ind[112] != 0) {
#line 2148
        tmp = 2;
      } else {
#line 2148
        tmp = 0;
      }
#line 2148
      lng = tmp;
    }
#line 2149
    if ((int )ops->ind[100] != 0) {
#line 2150
      lng |= 4;
    }
  } else {
#line 2152
    lng = ! (! opts[111]);
  }
#line 2155
  if (func == 2) {
#line 2155
    goto _L;
  } else
#line 2155
  if (func == 1) {
    _L: /* CIL Label */ 
#line 2155
    if (! opts[116]) {
      {
#line 2157
      zwarnnam((char const   *)name, "no job control in this shell.");
      }
#line 2158
      return (1);
    }
  }
  {
#line 2161
  queueing_enabled ++;
#line 2168
  wait_for_processes();
  }
#line 2171
  if (! opts[121]) {
    {
#line 2172
    scanjobs();
    }
  }
#line 2174
  if (func != 3) {
    {
#line 2175
    setcurjob();
    }
  } else
#line 2174
  if (opts[116]) {
    {
#line 2175
    setcurjob();
    }
  } else
#line 2174
  if (! oldmaxjob) {
    {
#line 2175
    setcurjob();
    }
  }
#line 2177
  if (func == 3) {
#line 2180
    stopmsg = 2;
  }
#line 2181
  if (! *argv) {
#line 2185
    if (func == 2) {
#line 2185
      goto _L___4;
    } else
#line 2185
    if (func == 1) {
#line 2185
      goto _L___4;
    } else
#line 2185
    if (func == 5) {
      _L___4: /* CIL Label */ 
#line 2188
      if (curjob == -1) {
#line 2188
        goto _L___0;
      } else
#line 2188
      if ((jobtab + curjob)->stat & 32) {
        _L___0: /* CIL Label */ 
        {
#line 2189
        zwarnnam((char const   *)name, "no current job");
        }
        {
#line 2190
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2190
          queueing_enabled --;
#line 2190
          if (! queueing_enabled) {
            {
#line 2190
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 2190
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 2190
                if (! (queue_front != queue_rear)) {
#line 2190
                  goto while_break___4;
                }
                {
#line 2190
                queue_front = (queue_front + 1) % 128;
#line 2190
                oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 2190
                zhandler(signal_queue[queue_front]);
#line 2190
                signal_setmask(oset___0);
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 2190
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 2190
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2191
        return (1);
      }
#line 2193
      firstjob = curjob;
    } else
#line 2194
    if (func == 3) {
#line 2198
      if (! opts[116]) {
#line 2198
        if (oldmaxjob) {
#line 2199
          jobptr = oldjobtab;
#line 2200
          if (oldmaxjob) {
#line 2200
            curmaxjob = oldmaxjob - 1;
          } else {
#line 2200
            curmaxjob = 0;
          }
#line 2201
          ignorejob = 0;
        } else {
#line 2203
          jobptr = jobtab;
#line 2204
          curmaxjob = maxjob;
#line 2205
          ignorejob = thisjob;
        }
      } else {
#line 2203
        jobptr = jobtab;
#line 2204
        curmaxjob = maxjob;
#line 2205
        ignorejob = thisjob;
      }
#line 2207
      job = 0;
      {
#line 2207
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2207
        if (! (job <= curmaxjob)) {
#line 2207
          goto while_break___5;
        }
#line 2208
        if (job != ignorejob) {
#line 2208
          if (jobptr->stat) {
#line 2209
            if (! ((int )ops->ind[114] != 0)) {
#line 2209
              if (! ((int )ops->ind[115] != 0)) {
                {
#line 2214
                printjob(jobptr, lng, 2);
                }
              } else {
#line 2209
                goto _L___3;
              }
            } else
            _L___3: /* CIL Label */ 
#line 2209
            if ((int )ops->ind[114] != 0) {
#line 2209
              if ((int )ops->ind[115] != 0) {
                {
#line 2214
                printjob(jobptr, lng, 2);
                }
              } else {
#line 2209
                goto _L___2;
              }
            } else
            _L___2: /* CIL Label */ 
#line 2209
            if ((int )ops->ind[114] != 0) {
#line 2209
              if (! (jobptr->stat & 2)) {
                {
#line 2214
                printjob(jobptr, lng, 2);
                }
              } else {
#line 2209
                goto _L___1;
              }
            } else
            _L___1: /* CIL Label */ 
#line 2209
            if ((int )ops->ind[115] != 0) {
#line 2209
              if (jobptr->stat & 2) {
                {
#line 2214
                printjob(jobptr, lng, 2);
                }
              }
            }
          }
        }
#line 2207
        job ++;
#line 2207
        jobptr ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 2216
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2216
        queueing_enabled --;
#line 2216
        if (! queueing_enabled) {
          {
#line 2216
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 2216
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 2216
              if (! (queue_front != queue_rear)) {
#line 2216
                goto while_break___8;
              }
              {
#line 2216
              queue_front = (queue_front + 1) % 128;
#line 2216
              oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 2216
              zhandler(signal_queue[queue_front]);
#line 2216
              signal_setmask(oset___1);
              }
            }
            while_break___8: /* CIL Label */ ;
            }
#line 2216
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
#line 2216
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2217
      return (0);
    } else {
#line 2219
      job = 0;
      {
#line 2219
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 2219
        if (! (job <= maxjob)) {
#line 2219
          goto while_break___9;
        }
#line 2220
        if (job != thisjob) {
#line 2220
          if ((jobtab + job)->stat) {
            {
#line 2221
            retval = zwaitjob(job, 1);
            }
          }
        }
#line 2219
        job ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 2222
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 2222
        queueing_enabled --;
#line 2222
        if (! queueing_enabled) {
          {
#line 2222
          while (1) {
            while_continue___11: /* CIL Label */ ;
            {
#line 2222
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 2222
              if (! (queue_front != queue_rear)) {
#line 2222
                goto while_break___12;
              }
              {
#line 2222
              queue_front = (queue_front + 1) % 128;
#line 2222
              oset___2 = signal_setmask(signal_mask_queue[queue_front]);
#line 2222
              zhandler(signal_queue[queue_front]);
#line 2222
              signal_setmask(oset___2);
              }
            }
            while_break___12: /* CIL Label */ ;
            }
#line 2222
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
        }
#line 2222
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 2223
      return (retval);
    }
  }
  {
#line 2230
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 2230
    if (! (firstjob != -1)) {
#line 2230
      if (! *argv) {
#line 2230
        goto while_break___13;
      }
    }
#line 2231
    ocj = thisjob;
#line 2233
    func = ofunc;
#line 2235
    if (func == 4) {
      {
#line 2235
      tmp___5 = isanum(*argv);
      }
#line 2235
      if (tmp___5) {
        {
#line 2237
        tmp___2 = atoi((char const   *)*argv);
#line 2237
        pid = (pid_t )((long )tmp___2);
#line 2241
        tmp___4 = findproc(pid, & j, & p, 0);
        }
#line 2241
        if (tmp___4) {
#line 2242
          if (j->stat & 2) {
            {
#line 2243
            tmp___3 = killjb(j, 18);
#line 2243
            retval = tmp___3 != 0;
            }
#line 2244
            if (retval == 0) {
              {
#line 2245
              makerunning(j);
              }
            }
          }
#line 2247
          if (retval == 0) {
            {
#line 2252
            retval = waitforpid(pid, 1);
            }
          }
#line 2254
          if (retval == 0) {
#line 2255
            retval = (int )lastval2;
          }
        } else {
          {
#line 2256
          retval = getbgstatus(pid);
          }
#line 2256
          if (retval < 0) {
            {
#line 2257
            zwarnnam((char const   *)name, "pid %d is not a child of this shell",
                     pid);
#line 2259
            retval = 1;
            }
          }
        }
#line 2261
        thisjob = ocj;
#line 2262
        goto __Cont;
      }
    }
#line 2264
    if (func != 3) {
#line 2264
      if ((unsigned long )oldjobtab != (unsigned long )((void *)0)) {
        {
#line 2265
        zwarnnam((char const   *)name, "can\'t manipulate jobs in subshell");
        }
        {
#line 2266
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 2266
          queueing_enabled --;
#line 2266
          if (! queueing_enabled) {
            {
#line 2266
            while (1) {
              while_continue___15: /* CIL Label */ ;
              {
#line 2266
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 2266
                if (! (queue_front != queue_rear)) {
#line 2266
                  goto while_break___16;
                }
                {
#line 2266
                queue_front = (queue_front + 1) % 128;
#line 2266
                oset___3 = signal_setmask(signal_mask_queue[queue_front]);
#line 2266
                zhandler(signal_queue[queue_front]);
#line 2266
                signal_setmask(oset___3);
                }
              }
              while_break___16: /* CIL Label */ ;
              }
#line 2266
              goto while_break___15;
            }
            while_break___15: /* CIL Label */ ;
            }
          }
#line 2266
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 2267
        return (1);
      }
    }
#line 2270
    if (*argv) {
      {
#line 2270
      tmp___6 = getjob((char const   *)*argv, (char const   *)name);
#line 2270
      job = tmp___6;
      }
    } else {
#line 2270
      job = firstjob;
    }
#line 2271
    firstjob = -1;
#line 2272
    if (job == -1) {
#line 2273
      retval = 1;
#line 2274
      goto while_break___13;
    }
#line 2276
    if (oldjobtab) {
#line 2276
      jstat = (oldjobtab + job)->stat;
    } else {
#line 2276
      jstat = (jobtab + job)->stat;
    }
#line 2277
    if (! (jstat & 64)) {
#line 2277
      goto _L___5;
    } else
#line 2277
    if (jstat & 32) {
      _L___5: /* CIL Label */ 
      {
#line 2279
      zwarnnam((char const   *)name, "%s: no such job", *argv);
      }
      {
#line 2280
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 2280
        queueing_enabled --;
#line 2280
        if (! queueing_enabled) {
          {
#line 2280
          while (1) {
            while_continue___18: /* CIL Label */ ;
            {
#line 2280
            while (1) {
              while_continue___19: /* CIL Label */ ;
#line 2280
              if (! (queue_front != queue_rear)) {
#line 2280
                goto while_break___19;
              }
              {
#line 2280
              queue_front = (queue_front + 1) % 128;
#line 2280
              oset___4 = signal_setmask(signal_mask_queue[queue_front]);
#line 2280
              zhandler(signal_queue[queue_front]);
#line 2280
              signal_setmask(oset___4);
              }
            }
            while_break___19: /* CIL Label */ ;
            }
#line 2280
            goto while_break___18;
          }
          while_break___18: /* CIL Label */ ;
          }
        }
#line 2280
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 2281
      return (1);
    }
#line 2286
    if (opts[8]) {
#line 2286
      if (func == 5) {
#line 2286
        if (jstat & 2) {
#line 2288
          func = 1;
        }
      }
    }
    {
#line 2294
    if (func == 4) {
#line 2294
      goto case_4;
    }
#line 2294
    if (func == 1) {
#line 2294
      goto case_4;
    }
#line 2294
    if (func == 2) {
#line 2294
      goto case_4;
    }
#line 2378
    if (func == 3) {
#line 2378
      goto case_3;
    }
#line 2381
    if (func == 5) {
#line 2381
      goto case_5;
    }
#line 2291
    goto switch_break;
    case_4: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 2295
    if (func == 1) {
#line 2296
      (jobtab + job)->stat |= 2048;
#line 2297
      (jobtab + job)->stat &= -1025;
    }
#line 2299
    stopped = (jobtab + job)->stat & 2;
#line 2299
    if (stopped) {
      {
#line 2300
      makerunning(jobtab + job);
      }
#line 2301
      if (func == 1) {
#line 2303
        pn = (jobtab + job)->procs;
        {
#line 2304
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 2305
          next___0 = pn->next;
#line 2306
          if (! next___0) {
#line 2307
            lastpid = (zlong )pn->pid;
#line 2308
            goto while_break___20;
          }
#line 2310
          pn = next___0;
        }
        while_break___20: /* CIL Label */ ;
        }
      }
    } else
#line 2313
    if (func == 1) {
      {
#line 2315
      zwarnnam((char const   *)name, "job already in background");
#line 2316
      thisjob = ocj;
      }
      {
#line 2317
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 2317
        queueing_enabled --;
#line 2317
        if (! queueing_enabled) {
          {
#line 2317
          while (1) {
            while_continue___22: /* CIL Label */ ;
            {
#line 2317
            while (1) {
              while_continue___23: /* CIL Label */ ;
#line 2317
              if (! (queue_front != queue_rear)) {
#line 2317
                goto while_break___23;
              }
              {
#line 2317
              queue_front = (queue_front + 1) % 128;
#line 2317
              oset___5 = signal_setmask(signal_mask_queue[queue_front]);
#line 2317
              zhandler(signal_queue[queue_front]);
#line 2317
              signal_setmask(oset___5);
              }
            }
            while_break___23: /* CIL Label */ ;
            }
#line 2317
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
        }
#line 2317
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 2318
      return (1);
    }
#line 2322
    if (curjob == job) {
#line 2323
      curjob = prevjob;
#line 2324
      if (func == 1) {
#line 2324
        prevjob = -1;
      } else {
#line 2324
        prevjob = job;
      }
    }
#line 2326
    if (prevjob == job) {
      {
#line 2327
      setprevjob();
      }
    } else
#line 2326
    if (prevjob == -1) {
      {
#line 2327
      setprevjob();
      }
    }
#line 2328
    if (curjob == -1) {
      {
#line 2329
      curjob = prevjob;
#line 2330
      setprevjob();
      }
    }
#line 2332
    if (func != 4) {
#line 2334
      if (stopped) {
#line 2334
        tmp___7 = -1;
      } else {
#line 2334
        tmp___7 = lng;
      }
      {
#line 2334
      printjob(jobtab + job, tmp___7, 3);
      }
    }
#line 2335
    if (func != 1) {
#line 2336
      if ((jobtab + job)->pwd) {
        {
#line 2336
        tmp___9 = strcmp((char const   *)(jobtab + job)->pwd, (char const   *)pwd);
        }
#line 2336
        if (tmp___9) {
#line 2337
          if (func == 3) {
#line 2337
            tmp___8 = stdout;
          } else
#line 2337
          if (! shout) {
#line 2337
            tmp___8 = stdout;
          } else {
#line 2337
            tmp___8 = shout;
          }
          {
#line 2337
          fout = tmp___8;
#line 2338
          fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"(pwd : ");
#line 2339
          fprintdir((jobtab + job)->pwd, fout);
#line 2340
          fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)")\n");
#line 2341
          fflush(fout);
          }
        }
      }
#line 2343
      if (func != 4) {
#line 2344
        thisjob = job;
#line 2345
        if ((jobtab + job)->stat & 128) {
#line 2345
          if (! ((jobtab + job)->procs)->next) {
#line 2345
            goto _L___6;
          } else
#line 2345
          if ((jobtab + job)->stat & 8192) {
#line 2345
            goto _L___6;
          } else {
            {
#line 2345
            tmp___10 = killpg((jobtab + job)->gleader, 0);
            }
#line 2345
            if (tmp___10 == -1) {
              _L___6: /* CIL Label */ 
#line 2345
              if ((jobtab + (jobtab + job)->other)->gleader) {
                {
#line 2350
                attachtty((jobtab + (jobtab + job)->other)->gleader);
                }
              } else {
                {
#line 2352
                attachtty((jobtab + job)->gleader);
                }
              }
            } else {
              {
#line 2352
              attachtty((jobtab + job)->gleader);
              }
            }
          }
        } else {
          {
#line 2352
          attachtty((jobtab + job)->gleader);
          }
        }
      }
    }
#line 2355
    if (stopped) {
#line 2356
      if (func != 1) {
#line 2356
        if ((jobtab + job)->ty) {
          {
#line 2357
          settyinfo((jobtab + job)->ty);
          }
        }
      }
      {
#line 2358
      killjb(jobtab + job, 18);
      }
    }
#line 2360
    if (func == 4) {
      {
#line 2362
      retval = zwaitjob(job, 1);
      }
#line 2363
      if (! retval) {
#line 2364
        retval = (int )lastval2;
      }
    } else
#line 2366
    if (func != 1) {
      {
#line 2373
      waitjobs();
#line 2374
      retval = (int )lastval2;
      }
    } else
#line 2375
    if (ofunc == 5) {
      {
#line 2376
      deletejob(jobtab + job, 1);
      }
    }
#line 2377
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2379
    if (oldjobtab) {
#line 2379
      tmp___11 = oldjobtab;
    } else {
#line 2379
      tmp___11 = jobtab;
    }
    {
#line 2379
    printjob(tmp___11 + job, lng, 2);
    }
#line 2380
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2382
    if ((jobtab + job)->stat & 128) {
#line 2383
      (jobtab + job)->stat |= 65536;
#line 2384
      goto __Cont;
    }
#line 2386
    if ((jobtab + job)->stat & 2) {
#line 2387
      pids = (char *)"";
#line 2389
      if ((jobtab + job)->stat & 128) {
#line 2392
        pn___0 = (jobtab + (jobtab + job)->other)->procs;
        {
#line 2392
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 2392
          if (! pn___0) {
#line 2392
            goto while_break___24;
          }
          {
#line 2393
          sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)" -%d",
                  pn___0->pid);
#line 2394
          pids = dyncat((char const   *)pids, (char const   *)(buf___7));
#line 2392
          pn___0 = pn___0->next;
          }
        }
        while_break___24: /* CIL Label */ ;
        }
#line 2396
        pn___0 = (jobtab + job)->procs;
        {
#line 2396
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 2396
          if (! pn___0->next) {
#line 2396
            goto while_break___25;
          }
          {
#line 2397
          sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)" %d",
                  pn___0->pid);
#line 2398
          pids = dyncat((char const   *)pids, (char const   *)(buf___7));
#line 2396
          pn___0 = pn___0->next;
          }
        }
        while_break___25: /* CIL Label */ ;
        }
#line 2400
        if (! (jobtab + (jobtab + job)->other)->procs) {
#line 2400
          if (pn___0) {
            {
#line 2401
            sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)" %d",
                    pn___0->pid);
#line 2402
            pids = dyncat((char const   *)pids, (char const   *)(buf___7));
            }
          }
        }
      } else {
        {
#line 2405
        sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)" -%d",
                (jobtab + job)->gleader);
#line 2406
        pids = buf___7;
        }
      }
      {
#line 2408
      zwarnnam((char const   *)name, "warning: job is suspended, use `kill -CONT%s\' to resume",
               pids);
      }
    }
    {
#line 2416
    deletejob(jobtab + job, 1);
    }
#line 2417
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2419
    thisjob = ocj;
    __Cont: /* CIL Label */ 
#line 2230
    if (*argv) {
#line 2230
      tmp___0 = argv;
#line 2230
      argv ++;
#line 2230
      if (tmp___0) {
#line 2230
        tmp___1 = 1;
      } else {
#line 2230
        tmp___1 = 0;
      }
    } else {
#line 2230
      tmp___1 = 0;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 2421
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 2421
    queueing_enabled --;
#line 2421
    if (! queueing_enabled) {
      {
#line 2421
      while (1) {
        while_continue___27: /* CIL Label */ ;
        {
#line 2421
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 2421
          if (! (queue_front != queue_rear)) {
#line 2421
            goto while_break___28;
          }
          {
#line 2421
          queue_front = (queue_front + 1) % 128;
#line 2421
          oset___6 = signal_setmask(signal_mask_queue[queue_front]);
#line 2421
          zhandler(signal_queue[queue_front]);
#line 2421
          signal_setmask(oset___6);
          }
        }
        while_break___28: /* CIL Label */ ;
        }
#line 2421
        goto while_break___27;
      }
      while_break___27: /* CIL Label */ ;
      }
    }
#line 2421
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
#line 2422
  return (retval);
}
}
#line 2425 "/tmp/zsh-5.4.2/Src/jobs.c"
static struct __anonstruct_alt_sigs_713894858  const  alt_sigs[4]  = {      {"CLD", 17}, 
        {"IO", 29}, 
        {"ERR", 32}, 
        {(char const   *)((void *)0), 0}};
#line 2454 "/tmp/zsh-5.4.2/Src/jobs.c"
int bin_kill(char *nam , char **argv , Options ops  __attribute__((__unused__)) ,
             int func  __attribute__((__unused__)) ) 
{ 
  int sig ;
  int returnval ;
  char *endp ;
  zlong tmp ;
  char *signame ;
  zlong tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int i ;
  int tmp___3 ;
  char *endp___0 ;
  zlong tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int i___0 ;
  int tmp___7 ;
  int p ;
  int *tmp___8 ;
  int tmp___9 ;
  int pid ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  sigset_t oset ;
  int tmp___14 ;

  {
#line 2457
  sig = 15;
#line 2458
  returnval = 0;
#line 2461
  if (*argv) {
#line 2461
    if ((int )*(*argv) == 45) {
#line 2462
      if ((int )typtab[(unsigned char )*(*argv + 1)] & 1) {
        {
#line 2465
        tmp = zstrtol((char const   *)(*argv + 1), & endp, 10);
#line 2465
        sig = (int )tmp;
        }
#line 2466
        if (*endp) {
          {
#line 2467
          zwarnnam((char const   *)nam, "invalid signal number: %s", *argv);
          }
#line 2468
          return (1);
        }
      } else
#line 2470
      if ((int )*(*argv + 1) != 45) {
#line 2470
        goto _L___0;
      } else
#line 2470
      if (*(*argv + 2)) {
        _L___0: /* CIL Label */ 
#line 2474
        if ((int )*(*argv + 1) == 108) {
#line 2474
          if ((int )*(*argv + 2) == 0) {
#line 2475
            if (*(argv + 1)) {
              {
#line 2476
              while (1) {
                while_continue: /* CIL Label */ ;
#line 2476
                argv ++;
#line 2476
                if (! *argv) {
#line 2476
                  goto while_break;
                }
                {
#line 2477
                tmp___0 = zstrtol((char const   *)*argv, & signame, 10);
#line 2477
                sig = (int )tmp___0;
                }
#line 2478
                if ((unsigned long )signame == (unsigned long )*argv) {
                  {
#line 2479
                  tmp___1 = strncmp((char const   *)signame, "SIG", (size_t )3);
                  }
#line 2479
                  if (! tmp___1) {
#line 2480
                    signame += 3;
                  }
#line 2481
                  sig = 1;
                  {
#line 2481
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
#line 2481
                    if (! (sig <= 31)) {
#line 2481
                      goto while_break___0;
                    }
                    {
#line 2482
                    tmp___2 = strcasecmp((char const   *)sigs[sig], (char const   *)signame);
                    }
#line 2482
                    if (! tmp___2) {
#line 2483
                      goto while_break___0;
                    }
#line 2481
                    sig ++;
                  }
                  while_break___0: /* CIL Label */ ;
                  }
#line 2484
                  if (sig > 31) {
#line 2487
                    i = 0;
                    {
#line 2487
                    while (1) {
                      while_continue___1: /* CIL Label */ ;
#line 2487
                      if (! alt_sigs[i].name) {
#line 2487
                        goto while_break___1;
                      }
                      {
#line 2488
                      tmp___3 = strcasecmp((char const   *)alt_sigs[i].name, (char const   *)signame);
                      }
#line 2488
                      if (! tmp___3) {
#line 2490
                        sig = (int )alt_sigs[i].num;
#line 2491
                        goto while_break___1;
                      }
#line 2487
                      i ++;
                    }
                    while_break___1: /* CIL Label */ ;
                    }
                  }
#line 2494
                  if (sig > 31) {
                    {
#line 2495
                    zwarnnam((char const   *)nam, "unknown signal: SIG%s", signame);
#line 2497
                    returnval ++;
                    }
                  } else {
                    {
#line 2499
                    printf((char const   */* __restrict  */)"%d\n", sig);
                    }
                  }
                } else
#line 2501
                if (*signame) {
                  {
#line 2502
                  zwarnnam((char const   *)nam, "unknown signal: SIG%s", signame);
#line 2504
                  returnval ++;
                  }
                } else {
#line 2506
                  if ((int )((signed char )((sig & 127) + 1)) >> 1 > 0) {
#line 2507
                    sig &= 127;
                  } else
#line 2508
                  if ((sig & 255) == 127) {
#line 2509
                    sig = (sig & 65280) >> 8;
                  }
#line 2510
                  if (1 <= sig) {
#line 2510
                    if (sig <= 31) {
                      {
#line 2511
                      printf((char const   */* __restrict  */)"%s\n", sigs[sig]);
                      }
                    } else {
                      {
#line 2513
                      printf((char const   */* __restrict  */)"%d\n", sig);
                      }
                    }
                  } else {
                    {
#line 2513
                    printf((char const   */* __restrict  */)"%d\n", sig);
                    }
                  }
                }
              }
              while_break: /* CIL Label */ ;
              }
#line 2517
              return (returnval);
            }
            {
#line 2519
            printf((char const   */* __restrict  */)"%s", sigs[1]);
#line 2520
            sig = 2;
            }
            {
#line 2520
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 2520
              if (! (sig <= 31)) {
#line 2520
                goto while_break___2;
              }
              {
#line 2521
              printf((char const   */* __restrict  */)" %s", sigs[sig]);
#line 2520
              sig ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 2522
            putchar('\n');
            }
#line 2523
            return (0);
          }
        }
#line 2526
        if ((int )*(*argv + 1) == 110) {
#line 2526
          if ((int )*(*argv + 2) == 0) {
#line 2529
            argv ++;
#line 2529
            if (! *argv) {
              {
#line 2530
              zwarnnam((char const   *)nam, "-n: argument expected");
              }
#line 2531
              return (1);
            }
            {
#line 2533
            tmp___4 = zstrtol((char const   *)*argv, & endp___0, 10);
#line 2533
            sig = (int )tmp___4;
            }
#line 2534
            if (*endp___0) {
              {
#line 2535
              zwarnnam((char const   *)nam, "invalid signal number: %s", *argv);
              }
#line 2536
              return (1);
            }
          } else {
#line 2526
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 2539
          if ((int )*(*argv + 1) == 115) {
#line 2539
            if ((int )*(*argv + 2) == 0) {
#line 2541
              argv ++;
#line 2541
              if (*argv) {
#line 2545
                signame = *argv;
              } else {
                {
#line 2542
                zwarnnam((char const   *)nam, "-s: argument expected");
                }
#line 2543
                return (1);
              }
            } else {
#line 2540
              signame = *argv + 1;
            }
          } else {
#line 2540
            signame = *argv + 1;
          }
#line 2546
          if (! *signame) {
            {
#line 2547
            zwarnnam((char const   *)nam, "-: signal name expected");
            }
#line 2548
            return (1);
          }
          {
#line 2550
          signame = casemodify(signame, 1);
#line 2551
          tmp___5 = strncmp((char const   *)signame, "SIG", (size_t )3);
          }
#line 2551
          if (! tmp___5) {
#line 2552
            signame += 3;
          }
#line 2555
          sig = 1;
          {
#line 2555
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2555
            if (! (sig <= 31)) {
#line 2555
              goto while_break___3;
            }
            {
#line 2556
            tmp___6 = strcmp((char const   *)*(sigs + sig), (char const   *)signame);
            }
#line 2556
            if (! tmp___6) {
#line 2557
              goto while_break___3;
            }
#line 2555
            sig ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 2558
          if ((int )*signame == 48) {
#line 2558
            if (! *(signame + 1)) {
#line 2559
              sig = 0;
            }
          }
#line 2560
          if (sig > 31) {
#line 2563
            i___0 = 0;
            {
#line 2563
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 2563
              if (! alt_sigs[i___0].name) {
#line 2563
                goto while_break___4;
              }
              {
#line 2564
              tmp___7 = strcmp((char const   *)alt_sigs[i___0].name, (char const   *)signame);
              }
#line 2564
              if (! tmp___7) {
#line 2566
                sig = (int )alt_sigs[i___0].num;
#line 2567
                goto while_break___4;
              }
#line 2563
              i___0 ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
#line 2570
          if (sig > 31) {
            {
#line 2571
            zwarnnam((char const   *)nam, "unknown signal: SIG%s", signame);
#line 2572
            zwarnnam((char const   *)nam, "type kill -l for a list of signals");
            }
#line 2573
            return (1);
          }
        }
      }
#line 2577
      argv ++;
    }
  }
#line 2581
  if (*argv) {
#line 2581
    if ((int )*(*argv + 0) == 45) {
#line 2581
      if (! *(*argv + 1)) {
#line 2582
        argv ++;
      } else
#line 2581
      if ((int )*(*argv + 1) == 45) {
#line 2582
        argv ++;
      }
    }
  }
#line 2584
  if (! *argv) {
    {
#line 2585
    zwarnnam((char const   *)nam, "not enough arguments");
    }
#line 2586
    return (1);
  }
  {
#line 2589
  queueing_enabled ++;
#line 2590
  setcurjob();
  }
  {
#line 2594
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2594
    if (! *argv) {
#line 2594
      goto while_break___5;
    }
#line 2595
    if ((int )*(*argv) == 37) {
      {
#line 2599
      p = getjob((char const   *)*argv, (char const   *)nam);
      }
#line 2599
      if (p == -1) {
#line 2600
        returnval ++;
#line 2601
        goto __Cont;
      }
      {
#line 2603
      tmp___9 = killjb(jobtab + p, sig);
      }
#line 2603
      if (tmp___9 == -1) {
        {
#line 2604
        tmp___8 = __errno_location();
#line 2604
        zwarnnam("kill", "kill %s failed: %e", *argv, *tmp___8);
#line 2605
        returnval ++;
        }
#line 2606
        goto __Cont;
      }
#line 2611
      if ((jobtab + p)->stat & 2) {
#line 2617
        if (sig != 9) {
#line 2617
          if (sig != 18) {
#line 2617
            if (sig != 20) {
#line 2617
              if (sig != 22) {
#line 2617
                if (sig != 21) {
#line 2617
                  if (sig != 19) {
                    {
#line 2619
                    killjb(jobtab + p, 18);
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      {
#line 2621
      tmp___13 = isanum(*argv);
      }
#line 2621
      if (tmp___13) {
        {
#line 2625
        tmp___10 = atoi((char const   *)*argv);
#line 2625
        pid = tmp___10;
#line 2626
        tmp___12 = kill(pid, sig);
        }
#line 2626
        if (tmp___12 == -1) {
          {
#line 2627
          tmp___11 = __errno_location();
#line 2627
          zwarnnam("kill", "kill %s failed: %e", *argv, *tmp___11);
#line 2628
          returnval ++;
          }
        }
      } else {
        {
#line 2622
        zwarnnam("kill", "illegal pid: %s", *argv);
#line 2623
        returnval ++;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 2594
    argv ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 2643
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2643
    queueing_enabled --;
#line 2643
    if (! queueing_enabled) {
      {
#line 2643
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 2643
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2643
          if (! (queue_front != queue_rear)) {
#line 2643
            goto while_break___8;
          }
          {
#line 2643
          queue_front = (queue_front + 1) % 128;
#line 2643
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 2643
          zhandler(signal_queue[queue_front]);
#line 2643
          signal_setmask(oset);
          }
        }
        while_break___8: /* CIL Label */ ;
        }
#line 2643
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 2643
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2645
  if (returnval < 126) {
#line 2645
    tmp___14 = returnval;
  } else {
#line 2645
    tmp___14 = 1;
  }
#line 2645
  return (tmp___14);
}
}
#line 2650 "/tmp/zsh-5.4.2/Src/jobs.c"
int getsignum(char const   *s ) 
{ 
  int x ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2656
  x = atoi(s);
  }
#line 2657
  if ((int )typtab[(unsigned char )*s] & 1) {
#line 2657
    if (x >= 0) {
#line 2657
      if (x < 34) {
#line 2658
        return (x);
      }
    }
  }
  {
#line 2661
  tmp = strncmp(s, "SIG", (size_t )3);
  }
#line 2661
  if (! tmp) {
#line 2662
    s += 3;
  }
#line 2664
  i = 0;
  {
#line 2664
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2664
    if (! (i < 34)) {
#line 2664
      goto while_break;
    }
    {
#line 2665
    tmp___0 = strcmp(s, (char const   *)sigs[i]);
    }
#line 2665
    if (! tmp___0) {
#line 2666
      return (i);
    }
#line 2664
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2668
  i = 0;
  {
#line 2668
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2668
    if (! alt_sigs[i].name) {
#line 2668
      goto while_break___0;
    }
    {
#line 2670
    tmp___1 = strcmp(s, (char const   *)alt_sigs[i].name);
    }
#line 2670
    if (! tmp___1) {
#line 2671
      return ((int )alt_sigs[i].num);
    }
#line 2668
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2675
  return (-1);
}
}
#line 2681 "/tmp/zsh-5.4.2/Src/jobs.c"
char const   *getsigname(int sig ) 
{ 
  int i ;

  {
#line 2684
  if (sigtrapped[sig] & (1 << 3)) {
#line 2687
    i = 0;
    {
#line 2687
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2687
      if (! alt_sigs[i].name) {
#line 2687
        goto while_break;
      }
#line 2688
      if (sig == (int )alt_sigs[i].num) {
#line 2689
        return ((char const   *)alt_sigs[i].name);
      }
#line 2687
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 2692
    return ((char const   *)sigs[sig]);
  }
#line 2698
  return ("");
}
}
#line 2704 "/tmp/zsh-5.4.2/Src/jobs.c"
HashNode gettrapnode(int sig , int ignoredisable ) 
{ 
  char fname[20] ;
  HashNode hn ;
  HashNode (*getptr)(HashTable ht , char const   *name ) ;
  int i ;

  {
#line 2711
  if (ignoredisable) {
#line 2712
    getptr = shfunctab->getnode2;
  } else {
#line 2714
    getptr = shfunctab->getnode;
  }
  {
#line 2716
  sprintf((char */* __restrict  */)(fname), (char const   */* __restrict  */)"TRAP%s",
          sigs[sig]);
#line 2717
  hn = (*getptr)(shfunctab, (char const   *)(fname));
  }
#line 2717
  if (hn) {
#line 2718
    return (hn);
  }
#line 2720
  i = 0;
  {
#line 2720
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2720
    if (! alt_sigs[i].name) {
#line 2720
      goto while_break;
    }
#line 2721
    if (alt_sigs[i].num == (int const   )sig) {
      {
#line 2722
      sprintf((char */* __restrict  */)(fname), (char const   */* __restrict  */)"TRAP%s",
              alt_sigs[i].name);
#line 2723
      hn = (*getptr)(shfunctab, (char const   *)(fname));
      }
#line 2723
      if (hn) {
#line 2724
        return (hn);
      }
    }
#line 2720
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2728
  return ((HashNode )((void *)0));
}
}
#line 2734 "/tmp/zsh-5.4.2/Src/jobs.c"
void removetrapnode(int sig ) 
{ 
  HashNode hn ;
  HashNode tmp ;

  {
  {
#line 2737
  tmp = gettrapnode(sig, 1);
#line 2737
  hn = tmp;
  }
#line 2738
  if (hn) {
    {
#line 2739
    (*(shfunctab->removenode))(shfunctab, (char const   *)hn->nam);
#line 2740
    (*(shfunctab->freenode))(hn);
    }
  }
#line 2742
  return;
}
}
#line 2747 "/tmp/zsh-5.4.2/Src/jobs.c"
int bin_suspend(char *name , char **argv  __attribute__((__unused__)) , Options ops ,
                int func  __attribute__((__unused__)) ) 
{ 


  {
#line 2751
  if (opts[110]) {
#line 2751
    if (! ((int )ops->ind[102] != 0)) {
      {
#line 2752
      zwarnnam((char const   *)name, "can\'t suspend login shell");
      }
#line 2753
      return (1);
    }
  }
#line 2755
  if (opts[116]) {
    {
#line 2757
    signal(21, (void (*)(int  ))0);
#line 2758
    signal(20, (void (*)(int  ))0);
#line 2759
    signal(22, (void (*)(int  ))0);
#line 2762
    release_pgrp();
    }
  }
  {
#line 2766
  killpg(origpgrp, 20);
  }
#line 2768
  if (opts[116]) {
    {
#line 2769
    acquire_pgrp();
#line 2771
    signal(22, (void (*)(int  ))1);
#line 2772
    signal(20, (void (*)(int  ))1);
#line 2773
    signal(21, (void (*)(int  ))1);
    }
  }
#line 2775
  return (0);
}
}
#line 2781 "/tmp/zsh-5.4.2/Src/jobs.c"
int findjobnam(char const   *s ) 
{ 
  int jobnum ;
  int tmp ;

  {
#line 2786
  jobnum = maxjob;
  {
#line 2786
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2786
    if (! (jobnum >= 0)) {
#line 2786
      goto while_break;
    }
#line 2787
    if (! ((jobtab + jobnum)->stat & 288)) {
#line 2787
      if ((jobtab + jobnum)->stat) {
#line 2787
        if ((jobtab + jobnum)->procs) {
#line 2787
          if (jobnum != thisjob) {
#line 2787
            if (((jobtab + jobnum)->procs)->text[0]) {
              {
#line 2787
              tmp = strpfx(s, (char const   *)(((jobtab + jobnum)->procs)->text));
              }
#line 2787
              if (tmp) {
#line 2790
                return (jobnum);
              }
            }
          }
        }
      }
    }
#line 2786
    jobnum --;
  }
  while_break: /* CIL Label */ ;
  }
#line 2791
  return (-1);
}
}
#line 2799 "/tmp/zsh-5.4.2/Src/jobs.c"
void acquire_pgrp(void) 
{ 
  long ttpgrp ;
  sigset_t blockset ;
  sigset_t oldset ;
  long lastpgrp ;
  pid_t tmp ;
  ssize_t tmp___0 ;
  pid_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2805
  mypgrp = getpgrp();
  }
#line 2805
  if (mypgrp >= 0) {
    {
#line 2806
    lastpgrp = (long )mypgrp;
#line 2807
    sigemptyset(& blockset);
#line 2808
    sigaddset(& blockset, 21);
#line 2809
    sigaddset(& blockset, 22);
#line 2810
    sigaddset(& blockset, 20);
#line 2811
    oldset = signal_block(blockset);
    }
    {
#line 2812
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2812
      tmp___1 = gettygrp();
#line 2812
      ttpgrp = (long )tmp___1;
      }
#line 2812
      if (ttpgrp != -1L) {
#line 2812
        if (! (ttpgrp != (long )mypgrp)) {
#line 2812
          goto while_break;
        }
      } else {
#line 2812
        goto while_break;
      }
      {
#line 2813
      mypgrp = getpgrp();
      }
#line 2814
      if ((zlong )mypgrp == mypid) {
#line 2815
        if (! opts[93]) {
#line 2816
          goto while_break;
        }
        {
#line 2817
        signal_setmask(oldset);
#line 2818
        attachtty(mypgrp);
#line 2819
        signal_block(blockset);
        }
      }
      {
#line 2821
      tmp = gettygrp();
      }
#line 2821
      if (mypgrp == tmp) {
#line 2822
        goto while_break;
      }
      {
#line 2823
      signal_setmask(oldset);
#line 2824
      tmp___0 = read(0, (void *)0, (size_t )0);
#line 2825
      signal_block(blockset);
#line 2826
      mypgrp = getpgrp();
      }
#line 2827
      if ((long )mypgrp == lastpgrp) {
#line 2827
        if (! opts[93]) {
#line 2828
          goto while_break;
        }
      }
#line 2829
      lastpgrp = (long )mypgrp;
    }
    while_break: /* CIL Label */ ;
    }
#line 2831
    if ((zlong )mypgrp != mypid) {
      {
#line 2832
      tmp___2 = setpgid(0, 0);
      }
#line 2832
      if (tmp___2 == 0) {
        {
#line 2833
        mypgrp = (pid_t )mypid;
#line 2834
        attachtty(mypgrp);
        }
      } else {
#line 2836
        opts[116] = (char)0;
      }
    }
    {
#line 2838
    signal_setmask(oldset);
    }
  } else {
#line 2840
    opts[116] = (char)0;
  }
#line 2841
  return;
}
}
#line 2846 "/tmp/zsh-5.4.2/Src/jobs.c"
void release_pgrp(void) 
{ 


  {
#line 2849
  if (origpgrp != mypgrp) {
#line 2851
    if (origpgrp) {
      {
#line 2852
      attachtty(origpgrp);
#line 2853
      setpgid(0, origpgrp);
      }
    }
#line 2855
    mypgrp = origpgrp;
  }
#line 2857
  return;
}
}
#line 477 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 55 "./hist.epro"
void histbackword(void) ;
#line 5 "./input.epro"
int SHIN  ;
#line 6 "./input.epro"
FILE *bshin  ;
#line 7 "./input.epro"
int strin  ;
#line 8 "./input.epro"
int inbufct  ;
#line 9 "./input.epro"
int inbufflags  ;
#line 10
char *shingetline(void) ;
#line 12
void inungetc(int c ) ;
#line 13
int stuff(char *fn___0 ) ;
#line 17
void inpopalias(void) ;
#line 18
char *ingetptr(void) ;
#line 2 "./input.pro"
static int inputline(void) ;
#line 3
static void inputsetline(char *str , int flags ) ;
#line 4
static void inpoptop(void) ;
#line 103 "/tmp/zsh-5.4.2/Src/input.c"
static char *inbuf  ;
#line 104 "/tmp/zsh-5.4.2/Src/input.c"
static char *inbufptr  ;
#line 105 "/tmp/zsh-5.4.2/Src/input.c"
static char *inbufpush  ;
#line 106 "/tmp/zsh-5.4.2/Src/input.c"
static int inbufleft  ;
#line 119 "/tmp/zsh-5.4.2/Src/input.c"
static struct instacks *instack  ;
#line 119 "/tmp/zsh-5.4.2/Src/input.c"
static struct instacks *instacktop  ;
#line 130 "/tmp/zsh-5.4.2/Src/input.c"
static int instacksz  =    4;
#line 136 "/tmp/zsh-5.4.2/Src/input.c"
char *shingetline(void) 
{ 
  char *line ;
  int ll ;
  int c ;
  char buf___7[8192] ;
  char *p ;
  int q ;
  sigset_t tmp ;
  sigset_t oset ;
  int *tmp___0 ;
  int *tmp___1 ;
  sigset_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  sigset_t tmp___9 ;
  void *tmp___10 ;
  sigset_t tmp___11 ;
  sigset_t oset___0 ;

  {
  {
#line 139
  line = (char *)((void *)0);
#line 140
  ll = 0;
#line 144
  q = queueing_enabled;
#line 146
  p = buf___7;
#line 147
  tmp = signal_mask(28);
#line 147
  signal_unblock(tmp);
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    queueing_enabled = 0;
    {
#line 148
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 148
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 148
        if (! (queue_front != queue_rear)) {
#line 148
          goto while_break___1;
        }
        {
#line 148
        queue_front = (queue_front + 1) % 128;
#line 148
        oset = signal_setmask(signal_mask_queue[queue_front]);
#line 148
        zhandler(signal_queue[queue_front]);
#line 148
        signal_setmask(oset);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 148
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 148
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 149
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 151
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 152
      tmp___0 = __errno_location();
#line 152
      *tmp___0 = 0;
#line 153
      c = fgetc(bshin);
      }
#line 151
      if (c < 0) {
        {
#line 151
        tmp___1 = __errno_location();
        }
#line 151
        if (! (*tmp___1 == 4)) {
#line 151
          goto while_break___3;
        }
      } else {
#line 151
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 155
    if (c < 0) {
#line 155
      goto _L;
    } else
#line 155
    if (c == 10) {
      _L: /* CIL Label */ 
      {
#line 156
      tmp___2 = signal_mask(28);
#line 156
      signal_block(tmp___2);
#line 157
      queueing_enabled = q;
      }
#line 158
      if (c == 10) {
#line 159
        tmp___3 = p;
#line 159
        p ++;
#line 159
        *tmp___3 = (char )'\n';
      }
#line 160
      if ((unsigned long )p > (unsigned long )(buf___7)) {
        {
#line 161
        tmp___4 = p;
#line 161
        p ++;
#line 161
        *tmp___4 = (char )'\000';
#line 162
        tmp___5 = zrealloc((void *)line, (size_t )((long )ll + (p - buf___7)));
#line 162
        line = (char *)tmp___5;
#line 163
        memcpy((void */* __restrict  */)(line + ll), (void const   */* __restrict  */)(buf___7),
               (size_t )(p - buf___7));
        }
      }
#line 165
      return (line);
    }
#line 167
    if ((int )typtab[(unsigned char )c] & (1 << 12)) {
#line 168
      tmp___6 = p;
#line 168
      p ++;
#line 168
      *tmp___6 = (char)-125;
#line 169
      tmp___7 = p;
#line 169
      p ++;
#line 169
      *tmp___7 = (char )(c ^ 32);
    } else {
#line 171
      tmp___8 = p;
#line 171
      p ++;
#line 171
      *tmp___8 = (char )c;
    }
#line 172
    if ((unsigned long )p >= (unsigned long )((buf___7 + 8192) - 1)) {
      {
#line 173
      tmp___9 = signal_mask(28);
#line 173
      signal_block(tmp___9);
#line 174
      queueing_enabled ++;
#line 175
      tmp___10 = zrealloc((void *)line, (size_t )(((long )ll + (p - buf___7)) + 1L));
#line 175
      line = (char *)tmp___10;
#line 176
      memcpy((void */* __restrict  */)(line + ll), (void const   */* __restrict  */)(buf___7),
             (size_t )(p - buf___7));
#line 177
      ll = (int )((long )ll + (p - buf___7));
#line 178
      *(line + ll) = (char )'\000';
#line 179
      p = buf___7;
#line 180
      tmp___11 = signal_mask(28);
#line 180
      signal_unblock(tmp___11);
      }
      {
#line 181
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 181
        queueing_enabled = 0;
        {
#line 181
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 181
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 181
            if (! (queue_front != queue_rear)) {
#line 181
              goto while_break___6;
            }
            {
#line 181
            queue_front = (queue_front + 1) % 128;
#line 181
            oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 181
            zhandler(signal_queue[queue_front]);
#line 181
            signal_setmask(oset___0);
            }
          }
          while_break___6: /* CIL Label */ ;
          }
#line 181
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 181
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 191 "/tmp/zsh-5.4.2/Src/input.c"
int ingetc(void) 
{ 
  int lastc ;
  char *tmp ;
  int tmp___0 ;

  {
#line 194
  lastc = ' ';
#line 196
  if (lexstop) {
#line 197
    return (' ');
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (inbufleft) {
#line 200
      inbufleft --;
#line 201
      inbufct --;
#line 202
      tmp = inbufptr;
#line 202
      inbufptr ++;
#line 202
      lastc = (int )((unsigned char )*tmp);
#line 202
      if ((int )typtab[(unsigned char )lastc] & (1 << 4)) {
#line 203
        goto __Cont;
      }
#line 204
      if (inbufflags & (1 << 6)) {
#line 204
        goto _L;
      } else
#line 204
      if (! strin) {
        _L: /* CIL Label */ 
#line 204
        if (lastc == 10) {
#line 205
          lineno ++;
        }
      }
#line 206
      goto while_break;
    }
#line 216
    if (! inbufct) {
#line 216
      if (strin) {
#line 217
        lexstop = 1;
#line 218
        goto while_break;
      } else
#line 216
      if (errflag) {
#line 217
        lexstop = 1;
#line 218
        goto while_break;
      }
    }
#line 223
    if (inbufflags & (1 << 3)) {
      {
#line 224
      inpoptop();
      }
#line 225
      goto __Cont;
    }
    {
#line 228
    tmp___0 = inputline();
    }
#line 228
    if (tmp___0) {
#line 229
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  if (! lexstop) {
    {
#line 232
    zshlex_raw_add(lastc);
    }
  }
#line 233
  return (lastc);
}
}
#line 239 "/tmp/zsh-5.4.2/Src/input.c"
static int inputline(void) 
{ 
  char *ingetcline ;
  char **ingetcpmptl ;
  char **ingetcpmptr ;
  int context ;
  char *pptbuf ;
  int pptlen ;
  char *tmp ;
  char *tmp___0 ;
  int flags ;
  char *stripptr ;
  size_t tmp___1 ;
  int ct ;
  char *ptr___0 ;
  size_t tmp___2 ;
  char *oinbuf ;
  int newlen ;
  size_t tmp___3 ;
  int oldlen ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 242
  ingetcpmptl = (char **)((void *)0);
#line 242
  ingetcpmptr = (char **)((void *)0);
#line 243
  context = 0;
#line 246
  if (opts[93]) {
#line 246
    if (opts[160]) {
#line 247
      if (! isfirstln) {
#line 248
        ingetcpmptl = & prompt2;
#line 249
        if (rprompt2) {
#line 250
          ingetcpmptr = & rprompt2;
        }
#line 251
        context = 1;
      } else {
#line 254
        ingetcpmptl = & prompt;
#line 255
        if (rprompt) {
#line 256
          ingetcpmptr = & rprompt;
        }
      }
    }
  }
#line 259
  if (opts[93]) {
#line 259
    if (opts[160]) {
#line 259
      if (SHTTY != -1) {
#line 259
        if (opts[178]) {
#line 292
          flags = 3;
#line 293
          if (opts[90]) {
#line 294
            flags |= 4;
          }
          {
#line 295
          ingetcline = zleentry(1, ingetcpmptl, ingetcpmptr, flags, context);
#line 297
          histdone |= 8;
          }
        } else {
#line 259
          goto _L___1;
        }
      } else {
#line 259
        goto _L___1;
      }
    } else {
#line 259
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 266
    if (opts[93]) {
#line 266
      if (opts[160]) {
#line 275
        if (ingetcpmptl) {
#line 275
          tmp = *ingetcpmptl;
        } else {
#line 275
          tmp = (char *)((void *)0);
        }
        {
#line 275
        tmp___0 = promptexpand(tmp, 0, (char *)((void *)0), (char *)((void *)0), (unsigned int *)((void *)0));
#line 275
        pptbuf = unmetafy(tmp___0, & pptlen);
#line 277
        write_loop(2, (char const   *)pptbuf, (size_t )pptlen);
#line 278
        free((void *)pptbuf);
        }
      }
    }
    {
#line 280
    ingetcline = shingetline();
    }
  }
#line 299
  if (! ingetcline) {
#line 300
    lexstop = 1;
#line 300
    return (lexstop);
  }
#line 302
  if (errflag) {
    {
#line 303
    free((void *)ingetcline);
#line 304
    errflag |= 1;
#line 305
    lexstop = 1;
    }
#line 305
    return (lexstop);
  }
#line 307
  if (opts[173]) {
    {
#line 309
    zputs((char const   *)ingetcline, stderr);
#line 310
    fflush(stderr);
    }
  }
#line 312
  if (keyboardhackchar) {
#line 312
    if (*ingetcline) {
      {
#line 312
      tmp___2 = strlen((char const   *)ingetcline);
      }
#line 312
      if ((int )*(ingetcline + (tmp___2 - 1UL)) == 10) {
#line 312
        if (opts[93]) {
#line 312
          if (opts[160]) {
#line 312
            if (SHTTY != -1) {
#line 312
              if (*(ingetcline + 1)) {
                {
#line 317
                tmp___1 = strlen((char const   *)ingetcline);
#line 317
                stripptr = (ingetcline + tmp___1) - 2;
                }
#line 318
                if ((int )*stripptr == (int )keyboardhackchar) {
#line 321
                  ct = 1;
#line 324
                  if ((int )keyboardhackchar == 39) {
#line 324
                    goto _L___2;
                  } else
#line 324
                  if ((int )keyboardhackchar == 34) {
#line 324
                    goto _L___2;
                  } else
#line 324
                  if ((int )keyboardhackchar == 96) {
                    _L___2: /* CIL Label */ 
#line 330
                    ct = 0;
#line 330
                    ptr___0 = ingetcline;
                    {
#line 330
                    while (1) {
                      while_continue: /* CIL Label */ ;
#line 330
                      if (! *ptr___0) {
#line 330
                        goto while_break;
                      }
#line 331
                      if ((int )*ptr___0 == (int )keyboardhackchar) {
#line 332
                        ct ++;
                      }
#line 330
                      ptr___0 ++;
                    }
                    while_break: /* CIL Label */ ;
                    }
                  }
#line 334
                  if (ct & 1) {
#line 335
                    *(stripptr + 0) = (char )'\n';
#line 336
                    *(stripptr + 1) = (char )'\000';
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 340
  isfirstch = 1;
#line 341
  if (inbufflags & (1 << 7)) {
#line 341
    if (inbuf) {
      {
#line 354
      oinbuf = inbuf;
#line 355
      tmp___3 = strlen((char const   *)ingetcline);
#line 355
      newlen = (int )tmp___3;
#line 356
      oldlen = (int )(inbufptr - inbuf) + inbufleft;
      }
#line 357
      if (inbufflags & 1) {
        {
#line 358
        tmp___4 = realloc((void *)inbuf, (size_t )((oldlen + newlen) + 1));
#line 358
        inbuf = (char *)tmp___4;
        }
      } else {
        {
#line 360
        tmp___5 = zalloc((size_t )((oldlen + newlen) + 1));
#line 360
        inbuf = (char *)tmp___5;
#line 361
        memcpy((void */* __restrict  */)inbuf, (void const   */* __restrict  */)oinbuf,
               (size_t )oldlen);
        }
      }
      {
#line 363
      inbufptr += inbuf - oinbuf;
#line 364
      strcpy((char */* __restrict  */)(inbuf + oldlen), (char const   */* __restrict  */)ingetcline);
#line 365
      free((void *)ingetcline);
#line 366
      inbufleft += newlen;
#line 367
      inbufct += newlen;
#line 368
      inbufflags |= 1;
      }
    } else {
      {
#line 371
      inputsetline(ingetcline, 1);
      }
    }
  } else {
    {
#line 371
    inputsetline(ingetcline, 1);
    }
  }
#line 374
  return (0);
}
}
#line 383 "/tmp/zsh-5.4.2/Src/input.c"
static void inputsetline(char *str , int flags ) 
{ 
  size_t tmp ;
  sigset_t oset ;

  {
#line 386
  queueing_enabled ++;
#line 388
  if (inbufflags & 1) {
#line 388
    if (inbuf) {
      {
#line 389
      free((void *)inbuf);
      }
    }
  }
  {
#line 391
  inbufptr = str;
#line 391
  inbuf = inbufptr;
#line 392
  tmp = strlen((char const   *)inbuf);
#line 392
  inbufleft = (int )tmp;
  }
#line 400
  if (flags & (1 << 3)) {
#line 401
    inbufct += inbufleft;
  } else {
#line 403
    inbufct = inbufleft;
  }
#line 404
  inbufflags = flags;
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    queueing_enabled --;
#line 406
    if (! queueing_enabled) {
      {
#line 406
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 406
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 406
          if (! (queue_front != queue_rear)) {
#line 406
            goto while_break___1;
          }
          {
#line 406
          queue_front = (queue_front + 1) % 128;
#line 406
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 406
          zhandler(signal_queue[queue_front]);
#line 406
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 406
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 406
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 419 "/tmp/zsh-5.4.2/Src/input.c"
void inungetc(int c ) 
{ 
  char *cback ;
  void *tmp ;

  {
#line 422
  if (! lexstop) {
#line 423
    if ((unsigned long )inbufptr != (unsigned long )inbuf) {
#line 432
      inbufptr --;
#line 433
      inbufct ++;
#line 434
      inbufleft ++;
#line 435
      if (inbufflags & (1 << 6)) {
#line 435
        goto _L;
      } else
#line 435
      if (! strin) {
        _L: /* CIL Label */ 
#line 435
        if (c == 10) {
#line 436
          lineno --;
        }
      }
    } else
#line 438
    if (! (inbufflags & (1 << 3))) {
      {
#line 443
      zerr("Garbled input at %c (binary file as commands?)", c);
      }
#line 444
      return;
    } else {
      {
#line 453
      tmp = zshcalloc((size_t )2);
#line 453
      cback = (char *)tmp;
#line 454
      *(cback + 0) = (char )c;
#line 455
      inpush(cback, 1 | (1 << 3), (Alias )((void *)0));
      }
    }
#line 461
    if ((unsigned long )inbufptr == (unsigned long )inbufpush) {
#line 461
      if (inbufflags & ((1 << 4) | (1 << 5))) {
        {
#line 467
        while (1) {
          while_continue: /* CIL Label */ ;
#line 468
          if (instacktop->alias) {
#line 469
            (instacktop->alias)->inuse = 1;
          }
#line 470
          instacktop ++;
#line 467
          if (instacktop->flags & ((1 << 4) | (1 << 5))) {
#line 467
            if (! (! instacktop->bufleft)) {
#line 467
              goto while_break;
            }
          } else {
#line 467
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 473
        if (inbufflags & (1 << 5)) {
#line 474
          inbufflags = ((1 << 3) | (1 << 1)) | (1 << 2);
        } else {
#line 476
          inbufflags = (1 << 3) | (1 << 1);
        }
#line 477
        inbufleft = 0;
#line 478
        inbufptr = (char *)"";
#line 478
        inbuf = inbufptr;
      }
    }
    {
#line 480
    zshlex_raw_back();
    }
  }
#line 482
  return;
}
}
#line 487 "/tmp/zsh-5.4.2/Src/input.c"
int stuff(char *fn___0 ) 
{ 
  FILE *in ;
  char *buf___7 ;
  off_t len ;
  char *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 494
  tmp = unmeta((char const   *)fn___0);
#line 494
  in = fopen((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)"r");
  }
#line 494
  if (! in) {
    {
#line 495
    zerr("can\'t open %s", fn___0);
    }
#line 496
    return (1);
  }
  {
#line 498
  fseeko(in, (__off_t )0, 2);
#line 499
  len = ftello(in);
#line 500
  fseeko(in, (__off_t )0, 0);
#line 501
  tmp___0 = zalloc((size_t )(len + 1L));
#line 501
  buf___7 = (char *)tmp___0;
#line 502
  tmp___1 = fread((void */* __restrict  */)buf___7, (size_t )len, (size_t )1, (FILE */* __restrict  */)in);
  }
#line 502
  if (! tmp___1) {
    {
#line 503
    zerr("read error on %s", fn___0);
#line 504
    fclose(in);
#line 505
    zfree((void *)buf___7, (int )(len + 1L));
    }
#line 506
    return (1);
  }
  {
#line 508
  fclose(in);
#line 509
  *(buf___7 + len) = (char )'\000';
#line 510
  fwrite((void const   */* __restrict  */)buf___7, (size_t )len, (size_t )1, (FILE */* __restrict  */)stderr);
#line 511
  fflush(stderr);
#line 512
  tmp___2 = metafy(buf___7, (int )len, 0);
#line 512
  inputsetline(tmp___2, 1);
  }
#line 513
  return (0);
}
}
#line 519 "/tmp/zsh-5.4.2/Src/input.c"
void inerrflush(void) 
{ 


  {
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 522
    if (! lexstop) {
#line 522
      if (! inbufct) {
#line 522
        goto while_break;
      }
    } else {
#line 522
      goto while_break;
    }
    {
#line 523
    ingetc();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 524
  return;
}
}
#line 529 "/tmp/zsh-5.4.2/Src/input.c"
void inpush(char *str , int flags , Alias inalias ) 
{ 
  void *tmp ;
  Alias tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 532
  if (! instack) {
    {
#line 534
    tmp = zalloc((unsigned long )instacksz * sizeof(struct instacks ));
#line 534
    instack = (struct instacks *)tmp;
#line 535
    instacktop = instack;
    }
  }
#line 538
  instacktop->buf = inbuf;
#line 539
  instacktop->bufptr = inbufptr;
#line 540
  instacktop->bufleft = inbufleft;
#line 541
  instacktop->bufct = inbufct;
#line 542
  inbufflags &= ~ ((1 << 4) | (1 << 5));
#line 543
  if (flags & ((1 << 1) | (1 << 2))) {
#line 550
    flags |= (1 << 3) | (1 << 1);
#line 551
    if (flags & (1 << 2)) {
#line 552
      instacktop->flags = inbufflags | (1 << 5);
    } else {
#line 554
      instacktop->flags = inbufflags | (1 << 4);
    }
#line 555
    tmp___0 = inalias;
#line 555
    instacktop->alias = tmp___0;
#line 555
    if (tmp___0) {
#line 556
      inalias->inuse = 1;
    }
  } else {
#line 561
    tmp___1 = inbufflags;
#line 561
    instacktop->flags = tmp___1;
#line 561
    if (tmp___1 & (1 << 1)) {
#line 561
      if (flags & (1 << 3)) {
#line 563
        flags |= 1 << 1;
      }
    }
  }
#line 566
  instacktop ++;
#line 567
  if ((unsigned long )instacktop == (unsigned long )(instack + instacksz)) {
    {
#line 569
    tmp___2 = realloc((void *)instack, (unsigned long )(instacksz + 4) * sizeof(struct instacks ));
#line 569
    instack = (struct instacks *)tmp___2;
#line 572
    instacktop = instack + instacksz;
#line 573
    instacksz += 4;
    }
  }
  {
#line 579
  instacktop->flags = 0;
#line 581
  inbuf = (char *)((void *)0);
#line 581
  inbufpush = inbuf;
#line 583
  inputsetline(str, flags);
  }
#line 584
  return;
}
}
#line 589 "/tmp/zsh-5.4.2/Src/input.c"
static void inpoptop(void) 
{ 
  char *t ;
  size_t tmp ;

  {
#line 592
  if (! lexstop) {
#line 593
    inbufflags &= ~ ((1 << 4) | (1 << 5));
    {
#line 594
    while (1) {
      while_continue: /* CIL Label */ ;
#line 594
      if (! ((unsigned long )inbufptr > (unsigned long )inbuf)) {
#line 594
        goto while_break;
      }
#line 595
      inbufptr --;
#line 596
      inbufct ++;
#line 597
      inbufleft ++;
#line 605
      if ((inbufflags & (((1 << 1) | (1 << 2)) | (1 << 8))) == 1 << 1) {
        {
#line 606
        zshlex_raw_back();
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 610
  if (inbuf) {
#line 610
    if (inbufflags & 1) {
      {
#line 611
      free((void *)inbuf);
      }
    }
  }
#line 613
  instacktop --;
#line 615
  inbuf = instacktop->buf;
#line 616
  inbufpush = instacktop->bufptr;
#line 616
  inbufptr = inbufpush;
#line 617
  inbufleft = instacktop->bufleft;
#line 618
  inbufct = instacktop->bufct;
#line 619
  inbufflags = instacktop->flags;
#line 621
  if (! (inbufflags & ((1 << 4) | (1 << 5)))) {
#line 622
    return;
  }
#line 624
  if (instacktop->alias) {
#line 625
    t = (instacktop->alias)->text;
#line 627
    (instacktop->alias)->inuse = 0;
#line 628
    if (*t) {
      {
#line 628
      tmp = strlen((char const   *)t);
      }
#line 628
      if ((int )*(t + (tmp - 1UL)) == 32) {
        {
#line 629
        inalmore = 1;
#line 630
        histbackword();
        }
      }
    }
  }
#line 633
  return;
}
}
#line 638 "/tmp/zsh-5.4.2/Src/input.c"
void inpop(void) 
{ 
  int remcont ;

  {
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 644
    remcont = inbufflags & (1 << 3);
#line 646
    inpoptop();
    }
#line 643
    if (! remcont) {
#line 643
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 648
  return;
}
}
#line 657 "/tmp/zsh-5.4.2/Src/input.c"
void inpopalias(void) 
{ 


  {
  {
#line 660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 660
    if (! (inbufflags & (1 << 1))) {
#line 660
      goto while_break;
    }
    {
#line 661
    inpoptop();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  return;
}
}
#line 670 "/tmp/zsh-5.4.2/Src/input.c"
char *ingetptr(void) 
{ 


  {
#line 673
  return (inbufptr);
}
}
#line 685 "/tmp/zsh-5.4.2/Src/input.c"
char *input_hasalias(void) 
{ 
  int flags ;
  struct instacks *instackptr ;

  {
#line 687
  flags = inbufflags;
#line 688
  instackptr = instacktop;
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 692
    if (! (flags & (1 << 3))) {
#line 693
      goto while_break;
    }
#line 694
    instackptr --;
#line 695
    if (instackptr->alias) {
#line 696
      return ((instackptr->alias)->node.nam);
    }
#line 697
    flags = instackptr->flags;
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  return ((char *)((void *)0));
}
}
#line 420 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 773
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 294 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict  __stream , char * __restrict  __buf ,
                                                 int __modes , size_t __n ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 787 "/usr/include/term.h"
extern char *tgetstr(char const   * , char ** ) ;
#line 789
extern int tgetent(char * , char const   * ) ;
#line 790
extern int tgetflag(char const   * ) ;
#line 6 "./builtin.epro"
void createbuiltintable(void) ;
#line 7
void init_builtins(void) ;
#line 38
int exit_pending ;
#line 22 "./compat.epro"
long zopenmax(void) ;
#line 8 "./exec.epro"
int nohistsave ;
#line 30
struct rlimit current_limits[16] ;
#line 31
struct rlimit limits[16] ;
#line 43
void execstring(char *s , int dont_change_job , int exiting , char *context ) ;
#line 23 "./hashtable.epro"
void createcmdnamtable(void) ;
#line 26
void createshfunctable(void) ;
#line 32
void createreswdtable(void) ;
#line 36
void createaliastables(void) ;
#line 6 "./hashnameddir.epro"
void createnameddirtable(void) ;
#line 16 "./hist.epro"
struct histent curline ;
#line 19
Histent hist_ring ;
#line 43
void hbegin(int dohist ) ;
#line 52
int hend(Eprog prog ) ;
#line 69
void inithist(void) ;
#line 71
void readhistfile(char *fn___0 , int err , int readflags ) ;
#line 5 "./init.epro"
int noexitct ;
#line 6 "./init.epro"
char *zunderscore  ;
#line 7 "./init.epro"
int underscorelen  ;
#line 8 "./init.epro"
int underscoreused  ;
#line 9 "./init.epro"
int sourcelevel  ;
#line 10 "./init.epro"
int SHTTY  ;
#line 11 "./init.epro"
FILE *shout  ;
#line 12 "./init.epro"
char *tcstr[34]  ;
#line 13 "./init.epro"
int tclen[34]  ;
#line 14 "./init.epro"
int tclines  ;
#line 15 "./init.epro"
int tccolumns  ;
#line 16 "./init.epro"
int hasam  ;
#line 17 "./init.epro"
int hasbw  ;
#line 18 "./init.epro"
int hasxn  ;
#line 19 "./init.epro"
int hasye  ;
#line 20 "./init.epro"
int tccolours  ;
#line 21 "./init.epro"
sigset_t sigchld_mask  ;
#line 23
enum loop_return loop(int toplevel , int justonce ) ;
#line 24
int parseopts(char *nam , char ***argvp , char *new_opts , char **cmdp , LinkList optlist ) ;
#line 25
void init_io(char *cmd ) ;
#line 26
void init_shout(void) ;
#line 27
char *tccap_get_name(int cap ) ;
#line 29
void setupvals(char *cmd , char *runscript , char *zsh_name ) ;
#line 30
void init_signals(void) ;
#line 31
void run_init_scripts(void) ;
#line 32
void init_misc(char *cmd , char *zsh_name ) ;
#line 33
enum source_return source(char *s ) ;
#line 34
void sourcehome(char *s ) ;
#line 35
void init_bltinmods(void) ;
#line 36
void noop_function(void) ;
#line 37
void noop_function_int(int nothing  __attribute__((__unused__)) ) ;
#line 38 "./init.epro"
char *(*zle_entry_ptr)(int cmd , va_list___0 ap )  ;
#line 39 "./init.epro"
int zle_load_state  ;
#line 41
int (*compctlreadptr)(char * , char ** , Options  , char * ) ;
#line 42
int fallback_compctlread(char *name , char **args  __attribute__((__unused__)) , Options ops  __attribute__((__unused__)) ,
                         char *reply  __attribute__((__unused__)) ) ;
#line 43 "./init.epro"
int use_exit_printed  ;
#line 44
int zsh_main(int argc  __attribute__((__unused__)) , char **argv ) ;
#line 2 "./init.pro"
static void parseargs(char **argv , char **runscript , char **cmdptr ) ;
#line 3
static void parseopts_insert(LinkList optlist , char *base , int optno ) ;
#line 4
static void printhelp(void) ;
#line 40 "/tmp/zsh-5.4.2/Src/init.c"
int noexitct  =    0;
#line 93 "/tmp/zsh-5.4.2/Src/init.c"
struct hookdef zshhooks[3]  = {      {(Hookdef )((void *)0), (char *)"exit", (int (*)(Hookdef  , void * ))((void *)0),
      1, (LinkList )((void *)0)}, 
        {(Hookdef )((void *)0), (char *)"before_trap", (int (*)(Hookdef  , void * ))((void *)0),
      1, (LinkList )((void *)0)}, 
        {(Hookdef )((void *)0), (char *)"after_trap", (int (*)(Hookdef  , void * ))((void *)0),
      1, (LinkList )((void *)0)}};
#line 102 "/tmp/zsh-5.4.2/Src/init.c"
enum loop_return loop(int toplevel , int justonce ) 
{ 
  Eprog prog ;
  int err ;
  int non_empty ;
  int hstop ;
  enum lextok toksav ;
  LinkList args ;
  char *cmdstr ;
  char *tmp ;
  char *tmp___0 ;
  Shfunc tmp___1 ;
  HashNode tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  sigset_t oset ;
  sigset_t oset___0 ;

  {
  {
#line 106
  non_empty = 0;
#line 108
  queueing_enabled ++;
#line 109
  pushheap();
  }
#line 110
  if (! toplevel) {
    {
#line 111
    zcontext_save();
    }
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 113
    freeheap();
    }
#line 114
    if (stophist == 3) {
      {
#line 115
      hend((Eprog )((void *)0));
      }
    }
    {
#line 116
    hbegin(1);
    }
#line 117
    if (opts[160]) {
      {
#line 118
      setblock_stdin();
      }
#line 119
      if (opts[93]) {
#line 119
        if (toplevel) {
          {
#line 120
          hstop = stophist;
#line 121
          stophist = 3;
#line 129
          errflag = 0;
#line 130
          preprompt();
          }
#line 131
          if (stophist != 3) {
            {
#line 132
            hbegin(1);
            }
          } else {
#line 134
            stophist = hstop;
          }
#line 140
          errflag = 0;
        }
      }
    }
    {
#line 143
    use_exit_printed = 0;
#line 144
    intr();
#line 145
    lexinit();
#line 146
    prog = parse_event(37);
    }
#line 146
    if (! prog) {
      {
#line 148
      hend((Eprog )((void *)0));
      }
#line 149
      if ((unsigned int )tok == 37U) {
#line 149
        if (! errflag) {
#line 152
          goto while_break;
        } else {
#line 149
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 149
      if ((unsigned int )tok == 38U) {
#line 149
        if (! opts[160]) {
#line 152
          goto while_break;
        } else
#line 149
        if (! toplevel) {
#line 152
          goto while_break;
        } else {
#line 149
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 149
      if (justonce) {
#line 152
        goto while_break;
      }
#line 153
      if (exit_pending) {
        {
#line 159
        stopmsg = 1;
#line 160
        zexit(exit_pending >> 1, 0);
        }
      }
#line 162
      if ((unsigned int )tok == 38U) {
#line 162
        if (! lastval) {
#line 163
          lastval = (zlong )1;
        }
      }
#line 164
      goto __Cont;
    }
    {
#line 166
    tmp___4 = hend(prog);
    }
#line 166
    if (tmp___4) {
#line 167
      toksav = tok;
#line 169
      non_empty = 1;
#line 170
      if (toplevel) {
        {
#line 170
        tmp___1 = getshfunc((char *)"preexec");
        }
#line 170
        if (tmp___1) {
#line 170
          goto _L___1;
        } else {
          {
#line 170
          tmp___2 = (*(paramtab->getnode))(paramtab, "preexec_functions");
          }
#line 170
          if (tmp___2) {
            _L___1: /* CIL Label */ 
            {
#line 181
            args = newlinklist();
#line 182
            insertlinknode(args, args->list.last, (void *)"preexec");
            }
#line 185
            if (hist_ring) {
#line 185
              if (curline.histnum == curhist) {
                {
#line 186
                insertlinknode(args, args->list.last, (void *)hist_ring->node.nam);
                }
              } else {
                {
#line 188
                insertlinknode(args, args->list.last, (void *)"");
                }
              }
            } else {
              {
#line 188
              insertlinknode(args, args->list.last, (void *)"");
              }
            }
            {
#line 189
            tmp = getjobtext(prog, (Wordcode )((void *)0));
#line 189
            tmp___0 = dupstring((char const   *)tmp);
#line 189
            insertlinknode(args, args->list.last, (void *)tmp___0);
#line 190
            cmdstr = getpermtext(prog, (Wordcode )((void *)0), 0);
#line 190
            insertlinknode(args, args->list.last, (void *)cmdstr);
#line 192
            callhookfunc((char *)"preexec", args, 1, (int *)((void *)0));
#line 195
            zsfree(cmdstr);
#line 204
            errflag &= -2;
            }
          }
        }
      }
#line 206
      if (stopmsg) {
#line 207
        stopmsg --;
      }
#line 208
      if (toplevel) {
#line 208
        tmp___3 = "toplevel";
      } else {
#line 208
        tmp___3 = "file";
      }
      {
#line 208
      execode(prog, 0, 0, (char *)tmp___3);
#line 209
      tok = toksav;
      }
#line 210
      if (toplevel) {
#line 211
        noexitct = 0;
      }
    }
    {
#line 213
    tmp___5 = ferror(stderr);
    }
#line 213
    if (tmp___5) {
      {
#line 214
      zerr("write error");
#line 215
      clearerr(stderr);
      }
    }
#line 217
    if (subsh) {
      {
#line 218
      exit((int )lastval);
      }
    }
#line 219
    if (! opts[93]) {
#line 219
      goto _L___3;
    } else
#line 219
    if (sourcelevel) {
      _L___3: /* CIL Label */ 
#line 219
      if (errflag) {
#line 220
        goto while_break;
      } else {
#line 219
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 219
    if (retflag) {
#line 220
      goto while_break;
    }
#line 221
    if (opts[165]) {
#line 221
      if (toplevel) {
        {
#line 222
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 222
          queueing_enabled = 0;
          {
#line 222
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 222
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 222
              if (! (queue_front != queue_rear)) {
#line 222
                goto while_break___2;
              }
              {
#line 222
              queue_front = (queue_front + 1) % 128;
#line 222
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 222
              zhandler(signal_queue[queue_front]);
#line 222
              signal_setmask(oset);
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 222
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 222
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 223
        if (sigtrapped[0]) {
          {
#line 224
          dotrap(0);
          }
        }
        {
#line 225
        exit((int )lastval);
        }
      }
    }
#line 227
    if (justonce) {
#line 228
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  err = errflag;
#line 231
  if (! toplevel) {
    {
#line 232
    zcontext_restore();
    }
  }
  {
#line 233
  popheap();
  }
  {
#line 234
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 234
    queueing_enabled --;
#line 234
    if (! queueing_enabled) {
      {
#line 234
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 234
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 234
          if (! (queue_front != queue_rear)) {
#line 234
            goto while_break___5;
          }
          {
#line 234
          queue_front = (queue_front + 1) % 128;
#line 234
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 234
          zhandler(signal_queue[queue_front]);
#line 234
          signal_setmask(oset___0);
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 234
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 234
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 236
  if (err) {
#line 237
    return ((enum loop_return )2);
  }
#line 238
  if (! non_empty) {
#line 239
    return ((enum loop_return )1);
  }
#line 240
  return ((enum loop_return )0);
}
}
#line 243 "/tmp/zsh-5.4.2/Src/init.c"
static int restricted  ;
#line 246 "/tmp/zsh-5.4.2/Src/init.c"
static void parseargs(char **argv , char **runscript , char **cmdptr ) 
{ 
  char **x ;
  LinkList paramlist ;
  char **tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char **tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char **tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;

  {
  {
#line 252
  tmp = argv;
#line 252
  argv ++;
#line 252
  posixzero = *tmp;
#line 252
  argzero = posixzero;
#line 253
  SHIN = 0;
#line 262
  tmp___1 = isatty(0);
  }
#line 262
  if (tmp___1) {
#line 262
    opts[93] = (char)2;
  } else {
#line 262
    opts[93] = (char)0;
  }
  {
#line 267
  opts[116] = (char)2;
#line 268
  opts[68] = (char)2;
#line 269
  opts[178] = (char)1;
#line 270
  opts[160] = (char)0;
#line 271
  opts[165] = (char)0;
#line 273
  tmp___2 = parseopts((char *)((void *)0), & argv, opts, cmdptr, (LinkList )((void *)0));
  }
#line 273
  if (tmp___2) {
    {
#line 274
    exit(1);
    }
  }
#line 284
  if (opts[160]) {
#line 285
    if (opts[178]) {
      {
#line 285
      tmp___3 = isatty(0);
      }
#line 285
      if (tmp___3) {
#line 285
        tmp___4 = 1;
      } else {
#line 285
        tmp___4 = 0;
      }
    } else {
#line 285
      tmp___4 = 0;
    }
#line 285
    opts[178] = (char )tmp___4;
  }
  {
#line 287
  paramlist = znewlinklist();
  }
#line 288
  if (*argv) {
#line 289
    if (! opts[160]) {
#line 290
      posixzero = *argv;
#line 291
      if (*cmdptr) {
#line 292
        argzero = *argv;
      } else {
#line 294
        *runscript = *argv;
      }
#line 295
      opts[93] = (char )((int )opts[93] & 1);
#line 296
      argv ++;
    }
    {
#line 298
    while (1) {
      while_continue: /* CIL Label */ ;
#line 298
      if (! *argv) {
#line 298
        goto while_break;
      }
      {
#line 299
      tmp___5 = argv;
#line 299
      argv ++;
#line 299
      tmp___6 = ztrdup((char const   *)*tmp___5);
#line 299
      zinsertlinknode(paramlist, paramlist->list.last, (void *)tmp___6);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 300
  if (! *cmdptr) {
#line 301
    opts[160] = (char)1;
  }
#line 302
  if (opts[165]) {
#line 303
    opts[93] = (char )((int )opts[93] & 1);
  }
#line 304
  opts[93] = (char )(! (! opts[93]));
#line 305
  if ((int )opts[116] == 2) {
#line 306
    opts[116] = opts[93];
  }
#line 307
  if ((int )opts[68] == 2) {
#line 308
    opts[68] = opts[93];
  }
  {
#line 309
  tmp___7 = countlinknodes(paramlist);
#line 309
  tmp___8 = zshcalloc((unsigned long )(tmp___7 + 1) * sizeof(char *));
#line 309
  x = (char **)tmp___8;
#line 309
  pparams = x;
  }
  {
#line 311
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 311
    tmp___9 = x;
#line 311
    x ++;
#line 311
    tmp___11 = getlinknode(paramlist);
#line 311
    tmp___10 = (char *)tmp___11;
#line 311
    *tmp___9 = tmp___10;
    }
#line 311
    if (! tmp___10) {
#line 311
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 312
  free((void *)paramlist);
#line 313
  argzero = ztrdup((char const   *)argzero);
#line 314
  posixzero = ztrdup((char const   *)posixzero);
  }
#line 315
  return;
}
}
#line 320 "/tmp/zsh-5.4.2/Src/init.c"
static void parseopts_insert(LinkList optlist , char *base , int optno ) 
{ 
  LinkNode node ;
  void *ptr___0 ;
  int tmp ;

  {
#line 324
  if (optno < 0) {
#line 324
    tmp = - optno;
  } else {
#line 324
    tmp = optno;
  }
#line 324
  ptr___0 = (void *)(base + tmp);
#line 326
  node = optlist->list.first;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! node) {
#line 326
      goto while_break;
    }
#line 327
    if ((unsigned long )ptr___0 < (unsigned long )node->dat) {
      {
#line 328
      insertlinknode(optlist, node->prev, ptr___0);
      }
#line 329
      return;
    }
#line 326
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  insertlinknode(optlist, optlist->list.last, ptr___0);
  }
#line 334
  return;
}
}
#line 346 "/tmp/zsh-5.4.2/Src/init.c"
int parseopts(char *nam , char ***argvp , char *new_opts , char **cmdp , LinkList optlist ) 
{ 
  int optionbreak ;
  int action ;
  int optno ;
  char **argv ;
  char *args ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char **tmp___5 ;

  {
#line 350
  optionbreak = 0;
#line 352
  argv = *argvp;
#line 354
  *cmdp = (char *)0;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! optionbreak) {
#line 372
      if (*argv) {
#line 372
        if (! ((int )*(*argv) == 45)) {
#line 372
          if (! ((int )*(*argv) == 43)) {
#line 372
            goto while_break;
          }
        }
      } else {
#line 372
        goto while_break;
      }
    } else {
#line 372
      goto while_break;
    }
#line 373
    args = *argv;
#line 374
    action = (int )*(*argv) == 45;
#line 375
    if (! *(*(argv + 0) + 1)) {
#line 376
      *argv = (char *)"--";
    }
    {
#line 377
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 377
      (*argv) ++;
#line 377
      if (! *(*argv)) {
#line 377
        goto while_break___0;
      }
#line 378
      if ((int )*(*argv) == 45) {
#line 379
        if (! *(*(argv + 0) + 1)) {
#line 381
          argv ++;
#line 382
          goto doneoptions;
        }
#line 384
        if (nam) {
#line 385
          goto badoptionstring;
        } else
#line 384
        if ((unsigned long )*argv != (unsigned long )(args + 1)) {
#line 385
          goto badoptionstring;
        } else
#line 384
        if ((int )*(*argv) != 45) {
#line 385
          goto badoptionstring;
        }
        {
#line 387
        (*argv) ++;
#line 388
        tmp = strcmp((char const   *)*argv, "version");
        }
#line 388
        if (! tmp) {
          {
#line 389
          printf((char const   */* __restrict  */)"zsh %s (%s-%s-%s)\n", "5.4.2",
                 "x86_64", "unknown", "linux-gnu");
          }
          {
#line 391
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 391
            if (nam) {
#line 391
              if (*argv) {
#line 391
                argv ++;
              }
#line 391
              goto doneargv;
            } else {
              {
#line 391
              exit(0);
              }
            }
#line 391
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
        {
#line 393
        tmp___0 = strcmp((char const   *)*argv, "help");
        }
#line 393
        if (! tmp___0) {
          {
#line 394
          printhelp();
          }
          {
#line 395
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 395
            if (nam) {
#line 395
              if (*argv) {
#line 395
                argv ++;
              }
#line 395
              goto doneargv;
            } else {
              {
#line 395
              exit(0);
              }
            }
#line 395
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 398
        args = *argv;
        {
#line 398
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 398
          if (! *args) {
#line 398
            goto while_break___3;
          }
#line 399
          if ((int )*args == 45) {
#line 400
            *args = (char )'_';
          }
#line 398
          args ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 401
        goto longoptions;
      }
#line 404
      if (! opts[162]) {
#line 404
        if ((int )*(*argv) == 98) {
#line 406
          optionbreak = 1;
        } else {
#line 404
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 407
      if ((int )*(*argv) == 99) {
        {
#line 409
        *cmdp = *argv;
#line 410
        *(new_opts + 93) = (char )((int )*(new_opts + 93) & 1);
#line 411
        scriptfilename = ztrdup("zsh");
#line 411
        scriptname = scriptfilename;
        }
      } else
#line 412
      if ((int )*(*argv) == 111) {
#line 413
        (*argv) ++;
#line 413
        if (! *(*argv)) {
#line 414
          argv ++;
        }
#line 415
        if (! *argv) {
          {
#line 416
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 416
            if (nam) {
              {
#line 416
              zwarnnam((char const   *)nam, "string expected after -o", (void *)0);
              }
            } else {
              {
#line 416
              zerr("string expected after -o", (void *)0);
              }
            }
#line 416
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 417
          return (1);
        }
        longoptions: 
        {
#line 420
        optno = optlookup((char const   *)*argv);
        }
#line 420
        if (optno) {
#line 423
          if (optno == 154) {
#line 423
            if (! nam) {
#line 424
              restricted = action;
            } else {
#line 423
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 425
          if (optno == 48) {
#line 425
            goto _L___1;
          } else
#line 425
          if (optno == 174) {
            _L___1: /* CIL Label */ 
#line 425
            if (nam) {
              {
#line 426
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 426
                if (nam) {
                  {
#line 426
                  zwarnnam((char const   *)nam, "can\'t change option: %s", *argv);
                  }
                } else {
                  {
#line 426
                  zerr("can\'t change option: %s", *argv);
                  }
                }
#line 426
                goto while_break___5;
              }
              while_break___5: /* CIL Label */ ;
              }
            } else {
#line 425
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 428
            tmp___1 = dosetopt(optno, action, ! nam, new_opts);
            }
#line 428
            if (tmp___1) {
#line 428
              if (nam) {
                {
#line 429
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 429
                  if (nam) {
                    {
#line 429
                    zwarnnam((char const   *)nam, "can\'t change option: %s", *argv);
                    }
                  } else {
                    {
#line 429
                    zerr("can\'t change option: %s", *argv);
                    }
                  }
#line 429
                  goto while_break___6;
                }
                while_break___6: /* CIL Label */ ;
                }
              } else {
#line 428
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 430
            if (optlist) {
              {
#line 431
              parseopts_insert(optlist, new_opts, optno);
              }
            }
          }
        } else {
          {
#line 421
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 421
            if (nam) {
              {
#line 421
              zwarnnam((char const   *)nam, "no such option: %s", *argv);
              }
            } else {
              {
#line 421
              zerr("no such option: %s", *argv);
              }
            }
#line 421
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 422
          return (1);
        }
#line 434
        goto while_break___0;
      } else {
        {
#line 435
        tmp___4 = __ctype_b_loc();
        }
#line 435
        if ((int const   )*(*tmp___4 + (int )((unsigned char )*(*argv))) & 8192) {
          {
#line 437
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 437
            (*argv) ++;
#line 437
            if (! *(*argv)) {
#line 437
              goto while_break___8;
            }
            {
#line 438
            tmp___2 = __ctype_b_loc();
            }
#line 438
            if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*(*argv))) & 8192)) {
              badoptionstring: 
              {
#line 440
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 440
                if (nam) {
                  {
#line 440
                  zwarnnam((char const   *)nam, "bad option string: \'%s\'", args);
                  }
                } else {
                  {
#line 440
                  zerr("bad option string: \'%s\'", args);
                  }
                }
#line 440
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 441
              return (1);
            }
          }
          while_break___8: /* CIL Label */ ;
          }
#line 443
          goto while_break___0;
        } else {
          {
#line 445
          optno = optlookupc(*(*argv));
          }
#line 445
          if (optno) {
#line 448
            if (optno == 154) {
#line 448
              if (! nam) {
#line 449
                restricted = action;
              } else {
#line 448
                goto _L___6;
              }
            } else
            _L___6: /* CIL Label */ 
#line 450
            if (optno == 48) {
#line 450
              goto _L___5;
            } else
#line 450
            if (optno == 174) {
              _L___5: /* CIL Label */ 
#line 450
              if (nam) {
                {
#line 451
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 451
                  if (nam) {
                    {
#line 451
                    zwarnnam((char const   *)nam, "can\'t change option: %s", *argv);
                    }
                  } else {
                    {
#line 451
                    zerr("can\'t change option: %s", *argv);
                    }
                  }
#line 451
                  goto while_break___10;
                }
                while_break___10: /* CIL Label */ ;
                }
              } else {
#line 450
                goto _L___4;
              }
            } else {
              _L___4: /* CIL Label */ 
              {
#line 453
              tmp___3 = dosetopt(optno, action, ! nam, new_opts);
              }
#line 453
              if (tmp___3) {
#line 453
                if (nam) {
                  {
#line 454
                  while (1) {
                    while_continue___11: /* CIL Label */ ;
#line 454
                    if (nam) {
                      {
#line 454
                      zwarnnam((char const   *)nam, "can\'t change option: -%c", (int )*(*argv));
                      }
                    } else {
                      {
#line 454
                      zerr("can\'t change option: -%c", (int )*(*argv));
                      }
                    }
#line 454
                    goto while_break___11;
                  }
                  while_break___11: /* CIL Label */ ;
                  }
                } else {
#line 453
                  goto _L___3;
                }
              } else
              _L___3: /* CIL Label */ 
#line 455
              if (optlist) {
                {
#line 456
                parseopts_insert(optlist, new_opts, optno);
                }
              }
            }
          } else {
            {
#line 446
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 446
              if (nam) {
                {
#line 446
                zwarnnam((char const   *)nam, "bad option: -%c", (int )*(*argv));
                }
              } else {
                {
#line 446
                zerr("bad option: -%c", (int )*(*argv));
                }
              }
#line 446
              goto while_break___12;
            }
            while_break___12: /* CIL Label */ ;
            }
#line 447
            return (1);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 461
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
  doneoptions: 
#line 464
  if (*cmdp) {
#line 465
    if (! *argv) {
      {
#line 466
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 466
        if (nam) {
          {
#line 466
          zwarnnam((char const   *)nam, "string expected after -%s", *cmdp);
          }
        } else {
          {
#line 466
          zerr("string expected after -%s", *cmdp);
          }
        }
#line 466
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 467
      return (1);
    }
#line 469
    tmp___5 = argv;
#line 469
    argv ++;
#line 469
    *cmdp = *tmp___5;
  }
  doneargv: 
#line 472
  *argvp = argv;
#line 473
  return (0);
}
}
#line 477 "/tmp/zsh-5.4.2/Src/init.c"
static void printhelp(void) 
{ 


  {
  {
#line 480
  printf((char const   */* __restrict  */)"Usage: %s [<options>] [<argument> ...]\n",
         argzero);
#line 481
  printf((char const   */* __restrict  */)"\nSpecial options:\n");
#line 482
  printf((char const   */* __restrict  */)"  --help     show this message, then exit\n");
#line 483
  printf((char const   */* __restrict  */)"  --version  show zsh version number, then exit\n");
  }
#line 484
  if (! opts[162]) {
    {
#line 485
    printf((char const   */* __restrict  */)"  -b         end option processing, like --\n");
    }
  }
  {
#line 486
  printf((char const   */* __restrict  */)"  -c         take first argument as a command to execute\n");
#line 487
  printf((char const   */* __restrict  */)"  -o OPTION  set an option by name (see below)\n");
#line 488
  printf((char const   */* __restrict  */)"\nNormal options are named.  An option may be turned on by\n");
#line 489
  printf((char const   */* __restrict  */)"`-o OPTION\', `--OPTION\', `+o no_OPTION\' or `+-no-OPTION\'.  An\n");
#line 490
  printf((char const   */* __restrict  */)"option may be turned off by `-o no_OPTION\', `--no-OPTION\',\n");
#line 491
  printf((char const   */* __restrict  */)"`+o OPTION\' or `+-OPTION\'.  Options are listed below only in\n");
#line 492
  printf((char const   */* __restrict  */)"`--OPTION\' or `--no-OPTION\' form.\n");
#line 493
  printoptionlist();
  }
#line 494
  return;
}
}
#line 500 "/tmp/zsh-5.4.2/Src/init.c"
static char outbuf[8192]  ;
#line 500 "/tmp/zsh-5.4.2/Src/init.c"
static char errbuf[8192]  ;
#line 497 "/tmp/zsh-5.4.2/Src/init.c"
void init_io(char *cmd ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  long fdflags ;
  int tmp___11 ;
  __pid_t tmp___12 ;

  {
  {
#line 508
  setvbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)(outbuf), 0, (size_t )8192);
#line 509
  setvbuf((FILE */* __restrict  */)stderr, (char */* __restrict  */)(errbuf), 0, (size_t )8192);
  }
#line 526
  if (shout) {
#line 532
    if ((unsigned long )shout != (unsigned long )stderr) {
      {
#line 533
      fclose(shout);
      }
    }
#line 534
    shout = (FILE *)0;
  }
#line 536
  if (SHTTY != -1) {
    {
#line 537
    zclose(SHTTY);
#line 538
    SHTTY = -1;
    }
  }
  {
#line 542
  xtrerr = stderr;
#line 545
  tmp___4 = isatty(0);
  }
#line 545
  if (tmp___4) {
    {
#line 546
    zsfree(ttystrname);
#line 547
    tmp___1 = ttyname(0);
#line 547
    ttystrname = ztrdup((char const   *)tmp___1);
    }
#line 547
    if (ttystrname) {
      {
#line 548
      tmp = open((char const   *)ttystrname, 258);
#line 548
      SHTTY = movefd(tmp);
      }
#line 555
      if (SHTTY == -1) {
        {
#line 555
        tmp___0 = __errno_location();
        }
#line 555
        if (*tmp___0 == 16) {
          {
#line 556
          ioctl(0, 21517UL, 0);
          }
        }
      }
    }
#line 579
    if (SHTTY == -1) {
      {
#line 579
      tmp___3 = fcntl(0, 3, 0);
      }
#line 579
      if ((tmp___3 & 2) == 2) {
        {
#line 580
        tmp___2 = dup(0);
#line 580
        SHTTY = movefd(tmp___2);
        }
      }
    }
  }
#line 583
  if (SHTTY == -1) {
    {
#line 583
    tmp___6 = isatty(1);
    }
#line 583
    if (tmp___6) {
      {
#line 583
      tmp___7 = fcntl(1, 3, 0);
      }
#line 583
      if ((tmp___7 & 2) == 2) {
        {
#line 583
        tmp___8 = dup(1);
#line 583
        SHTTY = movefd(tmp___8);
        }
#line 583
        if (SHTTY != -1) {
          {
#line 585
          zsfree(ttystrname);
#line 586
          tmp___5 = ttyname(1);
#line 586
          ttystrname = ztrdup((char const   *)tmp___5);
          }
        }
      }
    }
  }
#line 588
  if (SHTTY == -1) {
    {
#line 588
    tmp___10 = open("/dev/tty", 258);
#line 588
    SHTTY = movefd(tmp___10);
    }
#line 588
    if (SHTTY != -1) {
      {
#line 590
      zsfree(ttystrname);
#line 591
      tmp___9 = ttyname(SHTTY);
#line 591
      ttystrname = ztrdup((char const   *)tmp___9);
      }
    }
  }
#line 593
  if (SHTTY == -1) {
    {
#line 594
    zsfree(ttystrname);
#line 595
    ttystrname = ztrdup("");
    }
  } else {
    {
#line 598
    tmp___11 = fcntl(SHTTY, 1, 0);
#line 598
    fdflags = (long )tmp___11;
    }
#line 599
    if (fdflags != -1L) {
      {
#line 600
      fdflags |= 1L;
#line 601
      fcntl(SHTTY, 2, fdflags);
      }
    }
#line 604
    if (! ttystrname) {
      {
#line 605
      ttystrname = ztrdup("/dev/tty");
      }
    }
  }
#line 610
  if (opts[93]) {
    {
#line 611
    init_shout();
    }
#line 612
    if (! SHTTY) {
#line 613
      opts[178] = (char)0;
    } else
#line 612
    if (! shout) {
#line 613
      opts[178] = (char)0;
    }
  } else {
#line 615
    opts[178] = (char)0;
  }
  {
#line 621
  tmp___12 = getpid();
#line 621
  mypid = (zlong )tmp___12;
  }
#line 622
  if (opts[116]) {
#line 622
    if (SHTTY != -1) {
      {
#line 623
      origpgrp = getpgrp();
#line 624
      acquire_pgrp();
      }
    } else {
#line 626
      opts[116] = (char)0;
    }
  } else {
#line 626
    opts[116] = (char)0;
  }
#line 630
  return;
}
}
#line 636 "/tmp/zsh-5.4.2/Src/init.c"
static char shoutbuf[8192]  ;
#line 633 "/tmp/zsh-5.4.2/Src/init.c"
void init_shout(void) 
{ 


  {
#line 641
  if (SHTTY == -1) {
#line 644
    shout = stderr;
#line 645
    return;
  }
  {
#line 654
  shout = fdopen(SHTTY, "w");
  }
#line 656
  if (shout) {
    {
#line 657
    setvbuf((FILE */* __restrict  */)shout, (char */* __restrict  */)(shoutbuf), 0,
            (size_t )8192);
    }
  }
  {
#line 660
  gettyinfo(& shttyinfo);
  }
#line 665
  return;
}
}
#line 669 "/tmp/zsh-5.4.2/Src/init.c"
static char *tccapnams[34]  = 
#line 669
  {      (char *)"cl",      (char *)"le",      (char *)"LE",      (char *)"nd", 
        (char *)"RI",      (char *)"up",      (char *)"UP",      (char *)"do", 
        (char *)"DO",      (char *)"dc",      (char *)"DC",      (char *)"ic", 
        (char *)"IC",      (char *)"cd",      (char *)"ce",      (char *)"al", 
        (char *)"dl",      (char *)"ta",      (char *)"md",      (char *)"so", 
        (char *)"us",      (char *)"me",      (char *)"se",      (char *)"ue", 
        (char *)"ch",      (char *)"ku",      (char *)"kd",      (char *)"kl", 
        (char *)"kr",      (char *)"sc",      (char *)"rc",      (char *)"bc", 
        (char *)"AF",      (char *)"AB"};
#line 677 "/tmp/zsh-5.4.2/Src/init.c"
char *tccap_get_name(int cap ) 
{ 


  {
#line 680
  if (cap >= 34) {
#line 684
    return ((char *)"");
  }
#line 686
  return (tccapnams[cap]);
}
}
#line 692 "/tmp/zsh-5.4.2/Src/init.c"
int init_term(void) 
{ 
  int tmp ;
  char tbuf___0[1024] ;
  char *pp ;
  int t0 ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 699
  if (! *term) {
#line 700
    termflags |= 2;
#line 701
    return (0);
  }
  {
#line 705
  tmp = strcmp((char const   *)term, "emacs");
  }
#line 705
  if (! tmp) {
#line 706
    opts[178] = (char)0;
  }
  {
#line 710
  tmp___2 = tgetent((char *)((void *)0), (char const   *)term);
  }
#line 710
  if (tmp___2 != 1) {
#line 715
    if (opts[93]) {
      {
#line 716
      zerr("can\'t find terminal definition for %s", term);
      }
    }
#line 717
    errflag &= -2;
#line 718
    termflags |= 1;
#line 719
    return (0);
  } else {
#line 724
    termflags &= -2;
#line 725
    termflags &= -3;
#line 726
    t0 = 0;
    {
#line 726
    while (1) {
      while_continue: /* CIL Label */ ;
#line 726
      if (! (t0 != 34)) {
#line 726
        goto while_break;
      }
      {
#line 727
      pp = tbuf___0;
#line 728
      zsfree(tcstr[t0]);
#line 730
      pp = tgetstr((char const   *)tccapnams[t0], & pp);
      }
#line 730
      if (pp) {
        {
#line 733
        tmp___0 = strlen((char const   *)pp);
#line 733
        tclen[t0] = (int )tmp___0;
#line 734
        tmp___1 = zalloc((size_t )(tclen[t0] + 1));
#line 734
        tcstr[t0] = (char *)tmp___1;
#line 735
        memcpy((void */* __restrict  */)tcstr[t0], (void const   */* __restrict  */)pp,
               (size_t )(tclen[t0] + 1));
        }
      } else {
#line 731
        tcstr[t0] = (char *)((void *)0);
#line 731
        tclen[t0] = 0;
      }
#line 726
      t0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 740
    hasam = tgetflag("am");
#line 741
    hasbw = tgetflag("bw");
#line 742
    hasxn = tgetflag("xn");
#line 743
    hasye = tgetflag("YE");
#line 745
    tclines = tgetnum("li");
#line 746
    tccolumns = tgetnum("co");
#line 747
    tccolours = tgetnum("Co");
    }
#line 752
    if (tclen[5]) {
#line 753
      termflags &= -5;
    } else {
      {
#line 755
      zsfree(tcstr[5]);
#line 756
      tcstr[5] = (char *)((void *)0);
#line 757
      termflags |= 4;
      }
    }
#line 761
    if (! tclen[31]) {
      {
#line 762
      zsfree(tcstr[31]);
#line 763
      tcstr[31] = ztrdup("\b");
#line 764
      tclen[31] = 1;
      }
    }
#line 768
    if (! tclen[1]) {
      {
#line 769
      zsfree(tcstr[1]);
#line 770
      tcstr[1] = ztrdup((char const   *)tcstr[31]);
#line 771
      tclen[1] = tclen[31];
      }
    }
#line 774
    if (tclen[29]) {
#line 774
      if (! tclen[30]) {
        {
#line 775
        tclen[29] = 0;
#line 776
        zsfree(tcstr[29]);
#line 777
        tcstr[29] = (char *)((void *)0);
        }
      }
    }
#line 781
    if (tclen[7]) {
#line 781
      if ((int )*(tcstr[7] + 0) == 10) {
        {
#line 782
        tclen[7] = 0;
#line 783
        zsfree(tcstr[7]);
#line 784
        tcstr[7] = (char *)((void *)0);
        }
      }
    }
#line 788
    if (! tclen[0]) {
      {
#line 789
      zsfree(tcstr[0]);
#line 790
      tcstr[0] = ztrdup("\f");
#line 791
      tclen[0] = 1;
      }
    }
#line 793
    rprompt_indent = (zlong )1;
  }
#line 798
  return (1);
}
}
#line 804 "/tmp/zsh-5.4.2/Src/init.c"
void setupvals(char *cmd , char *runscript , char *zsh_name ) 
{ 
  struct passwd *pswd ;
  struct timezone dummy_tz ;
  char *ptr___0 ;
  int i ;
  int j ;
  char **fpathptr ;
  int fpathlen ;
  int close_fds[10] ;
  int tmppipe[2] ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char **tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  void *tmp___13 ;
  __pid_t tmp___14 ;
  __pid_t tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;

  {
  {
#line 833
  fpathlen = 1;
#line 844
  memset((void *)(close_fds), 0, 10UL * sizeof(int ));
#line 845
  tmp = pipe((int *)(tmppipe));
  }
#line 845
  if (tmp == 0) {
#line 852
    i = -1;
    {
#line 853
    while (1) {
      while_continue: /* CIL Label */ ;
#line 853
      if (! (i < 9)) {
#line 853
        goto while_break;
      }
#line 855
      if (i < tmppipe[0]) {
#line 856
        j = tmppipe[0];
      } else
#line 857
      if (i < tmppipe[1]) {
#line 858
        j = tmppipe[1];
      } else {
        {
#line 860
        j = dup(0);
        }
#line 861
        if (j == -1) {
#line 862
          goto while_break;
        }
      }
#line 864
      if (j < 10) {
#line 865
        close_fds[j] = 1;
      } else {
        {
#line 867
        close(j);
        }
      }
#line 868
      if (i < j) {
#line 869
        i = j;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 871
    if (i < tmppipe[0]) {
      {
#line 872
      close(tmppipe[0]);
      }
    }
#line 873
    if (i < tmppipe[1]) {
      {
#line 874
      close(tmppipe[1]);
      }
    }
  }
  {
#line 877
  addhookdefs((Module )((void *)0), zshhooks, (int )(sizeof(zshhooks) / sizeof(zshhooks[0])));
#line 879
  init_eprog();
#line 881
  zero_mnumber.type = 1;
#line 882
  zero_mnumber.u.l = (zlong )0;
#line 884
  noeval = 0;
#line 885
  curhist = (zlong )0;
#line 886
  histsiz = (zlong )30;
#line 887
  inithist();
#line 889
  tmp___0 = zalloc((size_t )256);
#line 889
  cmdstack = (unsigned char *)tmp___0;
#line 890
  cmdsp = 0;
#line 892
  bangchar = (unsigned char )'!';
#line 893
  hashchar = (unsigned char )'#';
#line 894
  hatchar = (unsigned char )'^';
#line 895
  termflags = 2;
#line 896
  coprocout = -1;
#line 896
  coprocin = coprocout;
#line 896
  prevjob = coprocin;
#line 896
  curjob = prevjob;
#line 897
  gettimeofday((struct timeval */* __restrict  */)(& shtimer), (__timezone_ptr_t )(& dummy_tz));
#line 898
  srand((unsigned int )(shtimer.tv_sec + shtimer.tv_usec));
#line 901
  tmp___1 = zalloc(sizeof(*path) * 5UL);
#line 901
  path = (char **)tmp___1;
#line 902
  *(path + 0) = ztrdup("/bin");
#line 903
  *(path + 1) = ztrdup("/usr/bin");
#line 904
  *(path + 2) = ztrdup("/usr/ucb");
#line 905
  *(path + 3) = ztrdup("/usr/local/bin");
#line 906
  *(path + 4) = (char *)((void *)0);
#line 908
  cdpath = mkarray((char *)((void *)0));
#line 909
  manpath = mkarray((char *)((void *)0));
#line 910
  fignore = mkarray((char *)((void *)0));
#line 917
  fpathlen ++;
#line 924
  tmp___2 = zalloc((unsigned long )(fpathlen + 1) * sizeof(char *));
#line 924
  fpathptr = (char **)tmp___2;
#line 924
  fpath = fpathptr;
#line 930
  tmp___3 = fpathptr;
#line 930
  fpathptr ++;
#line 930
  *tmp___3 = ztrdup("/usr/local/share/zsh/site-functions");
#line 931
  fpathlen --;
#line 947
  tmp___4 = fpathptr;
#line 947
  fpathptr ++;
#line 947
  *tmp___4 = ztrdup("/usr/local/share/zsh/5.4.2/functions");
#line 950
  *fpathptr = (char *)((void *)0);
#line 955
  mailpath = mkarray((char *)((void *)0));
#line 956
  watch = mkarray((char *)((void *)0));
#line 957
  psvar = mkarray((char *)((void *)0));
#line 958
  tmp___5 = ztrdup("/usr/local/lib/zsh/5.4.2");
#line 958
  module_path = mkarray(tmp___5);
#line 959
  modulestab = newmoduletable(17, "modules");
#line 960
  linkedmodules = znewlinklist();
  }
#line 963
  if (! opts[93]) {
    {
#line 964
    prompt = ztrdup("");
#line 965
    prompt2 = ztrdup("");
    }
  } else
#line 966
  if (emulation & ((1 << 2) | (1 << 3))) {
    {
#line 967
    tmp___8 = privasserted();
    }
#line 967
    if (tmp___8) {
#line 967
      tmp___7 = "# ";
    } else {
#line 967
      tmp___7 = "$ ";
    }
    {
#line 967
    prompt = ztrdup(tmp___7);
#line 968
    prompt2 = ztrdup("> ");
    }
  } else {
    {
#line 970
    prompt = ztrdup("%m%# ");
#line 971
    prompt2 = ztrdup("%_> ");
    }
  }
  {
#line 973
  prompt3 = ztrdup("?# ");
  }
#line 974
  if (emulation & ((1 << 2) | (1 << 3))) {
    {
#line 974
    tmp___9 = ztrdup("+ ");
#line 974
    prompt4 = tmp___9;
    }
  } else {
    {
#line 974
    tmp___10 = ztrdup("+%N:%i> ");
#line 974
    prompt4 = tmp___10;
    }
  }
  {
#line 976
  sprompt = ztrdup("zsh: correct \'%R\' to \'%r\' [nyae]? ");
  }
#line 978
  if (emulation & ((1 << 2) | (1 << 3))) {
    {
#line 978
    tmp___11 = ztrdup(" \t\n");
#line 978
    ifs = tmp___11;
    }
  } else {
    {
#line 978
    tmp___12 = ztrdup(" \t\n\203 ");
#line 978
    ifs = tmp___12;
    }
  }
  {
#line 980
  wordchars = ztrdup("*?_-.[]~=/&;!#$%^(){}<>");
#line 981
  postedit = ztrdup("");
#line 982
  underscorelen = 32;
#line 982
  tmp___13 = zalloc((size_t )underscorelen);
#line 982
  zunderscore = (char *)tmp___13;
#line 983
  underscoreused = 1;
#line 984
  *zunderscore = (char )'\000';
#line 986
  zoptarg = ztrdup("");
#line 987
  zoptind = (zlong )1;
#line 989
  tmp___14 = getppid();
#line 989
  ppid = (zlong )tmp___14;
#line 990
  tmp___15 = getpid();
#line 990
  mypid = (zlong )tmp___15;
#line 991
  term = ztrdup("");
#line 993
  nullcmd = ztrdup("cat");
#line 994
  readnullcmd = ztrdup("more");
#line 998
  cached_uid = getuid();
#line 1002
  pswd = getpwuid(cached_uid);
  }
#line 1002
  if (pswd) {
#line 1003
    if (emulation & (1 << 4)) {
      {
#line 1004
      home = metafy(pswd->pw_dir, -1, 3);
      }
    }
    {
#line 1005
    cached_username = ztrdup((char const   *)pswd->pw_name);
    }
  } else {
#line 1010
    if (emulation & (1 << 4)) {
      {
#line 1011
      home = ztrdup("/");
      }
    }
    {
#line 1012
    cached_username = ztrdup("");
    }
  }
#line 1020
  if (emulation & (1 << 4)) {
#line 1021
    ptr___0 = home;
  } else {
    {
#line 1023
    ptr___0 = zgetenv((char *)"HOME");
    }
  }
#line 1024
  if (ptr___0) {
    {
#line 1024
    tmp___19 = ispwd(ptr___0);
    }
#line 1024
    if (tmp___19) {
      {
#line 1025
      pwd = ztrdup((char const   *)ptr___0);
      }
    } else {
#line 1024
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1026
    ptr___0 = zgetenv((char *)"PWD");
    }
#line 1026
    if (ptr___0) {
      {
#line 1026
      tmp___17 = strlen((char const   *)ptr___0);
      }
#line 1026
      if (tmp___17 < 4096UL) {
        {
#line 1026
        ptr___0 = metafy(ptr___0, -1, 2);
#line 1026
        tmp___18 = ispwd(ptr___0);
        }
#line 1026
        if (tmp___18) {
          {
#line 1028
          pwd = ztrdup((char const   *)ptr___0);
          }
        } else {
          {
#line 1030
          pwd = (char *)((void *)0);
#line 1031
          tmp___16 = zgetcwd();
#line 1031
          pwd = metafy(tmp___16, -1, 3);
          }
        }
      } else {
        {
#line 1030
        pwd = (char *)((void *)0);
#line 1031
        tmp___16 = zgetcwd();
#line 1031
        pwd = metafy(tmp___16, -1, 3);
        }
      }
    } else {
      {
#line 1030
      pwd = (char *)((void *)0);
#line 1031
      tmp___16 = zgetcwd();
#line 1031
      pwd = metafy(tmp___16, -1, 3);
      }
    }
  }
  {
#line 1034
  oldpwd = ztrdup((char const   *)pwd);
#line 1036
  inittyptab();
#line 1037
  initlextabs();
#line 1039
  createreswdtable();
#line 1040
  createaliastables();
#line 1041
  createcmdnamtable();
#line 1042
  createshfunctable();
#line 1043
  createbuiltintable();
#line 1044
  createnameddirtable();
#line 1045
  createparamtable();
#line 1047
  condtab = (Conddef )((void *)0);
#line 1048
  wrappers = (FuncWrap )((void *)0);
#line 1051
  adjustwinsize(0);
#line 1061
  i = 0;
  }
  {
#line 1061
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1061
    if (! (i != 16)) {
#line 1061
      goto while_break___0;
    }
    {
#line 1062
    getrlimit((__rlimit_resource_t )i, current_limits + i);
#line 1063
    limits[i] = current_limits[i];
#line 1061
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1067
  loops = 0;
#line 1067
  breaks = loops;
#line 1068
  lastmailcheck = time((time_t *)((void *)0));
#line 1069
  sourcelevel = 0;
#line 1069
  locallevel = sourcelevel;
#line 1070
  sfcontext = 0;
#line 1071
  trap_return = 0;
#line 1072
  trap_state = 0;
#line 1073
  noerrexit = 11;
#line 1074
  nohistsave = 1;
#line 1075
  dirstack = znewlinklist();
#line 1076
  bufstack = znewlinklist();
#line 1077
  hsubr = (char *)((void *)0);
#line 1077
  hsubl = hsubr;
#line 1078
  lastpid = (zlong )0;
#line 1080
  get_usage();
#line 1083
  i = 0;
  }
  {
#line 1083
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1083
    if (! (i < 10)) {
#line 1083
      goto while_break___1;
    }
#line 1084
    if (close_fds[i]) {
      {
#line 1085
      close(i);
      }
    }
#line 1083
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1088
  set_default_colour_sequences();
  }
#line 1090
  if (cmd) {
    {
#line 1091
    tmp___20 = ztrdup((char const   *)cmd);
#line 1091
    setsparam((char *)"ZSH_EXECUTION_STRING", tmp___20);
    }
  }
#line 1092
  if (runscript) {
    {
#line 1093
    tmp___21 = ztrdup((char const   *)runscript);
#line 1093
    setsparam((char *)"ZSH_SCRIPT", tmp___21);
    }
  }
  {
#line 1094
  tmp___22 = ztrdup((char const   *)zsh_name);
#line 1094
  setsparam((char *)"ZSH_NAME", tmp___22);
  }
#line 1095
  return;
}
}
#line 1102 "/tmp/zsh-5.4.2/Src/init.c"
static void setupshin(char *runscript ) 
{ 
  char *funmeta ;
  char *sfname ;
  struct stat st___0 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  FILE *tmp___3 ;

  {
#line 1105
  if (runscript) {
    {
#line 1106
    sfname = (char *)((void *)0);
#line 1109
    funmeta = unmeta((char const   *)runscript);
#line 1113
    tmp___0 = access((char const   *)funmeta, 0);
    }
#line 1113
    if (tmp___0 == 0) {
      {
#line 1113
      tmp___1 = stat((char const   */* __restrict  */)funmeta, (struct stat */* __restrict  */)(& st___0));
      }
#line 1113
      if (tmp___1 >= 0) {
#line 1113
        if (! ((st___0.st_mode & 61440U) == 16384U)) {
#line 1116
          sfname = runscript;
        } else {
#line 1113
          goto _L___0;
        }
      } else {
#line 1113
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1117
    if (opts[127]) {
      {
#line 1117
      tmp = strchr((char const   *)runscript, '/');
      }
#line 1117
      if (! tmp) {
        {
#line 1122
        funmeta = pathprog(runscript, & sfname);
        }
      }
    }
#line 1124
    if (! sfname) {
      {
#line 1127
      zerr("can\'t open input file: %s", runscript);
#line 1128
      exit(127);
      }
    } else {
      {
#line 1124
      tmp___2 = open((char const   *)funmeta, 256);
#line 1124
      SHIN = movefd(tmp___2);
      }
#line 1124
      if (SHIN == -1) {
        {
#line 1127
        zerr("can\'t open input file: %s", runscript);
#line 1128
        exit(127);
        }
      }
    }
    {
#line 1130
    scriptfilename = sfname;
#line 1131
    sfname = argzero;
#line 1132
    argzero = ztrdup((char const   *)runscript);
#line 1133
    zsfree(sfname);
    }
  }
#line 1139
  lineno = (zlong )1;
#line 1143
  if (SHIN) {
    {
#line 1143
    tmp___3 = fdopen(SHIN, "r");
#line 1143
    bshin = tmp___3;
    }
  } else {
#line 1143
    bshin = stdin;
  }
#line 1144
  if (opts[160]) {
#line 1144
    if (! SHIN) {
#line 1144
      if (! opts[93]) {
        {
#line 1146
        setvbuf((FILE */* __restrict  */)stdin, (char */* __restrict  */)((void *)0),
                2, (size_t )0);
        }
      }
    }
  }
#line 1151
  return;
}
}
#line 1156 "/tmp/zsh-5.4.2/Src/init.c"
void init_signals(void) 
{ 
  int i ;
  sigset_t tmp ;
  __sighandler_t tmp___0 ;
  sigset_t tmp___1 ;

  {
#line 1159
  if (opts[93]) {
    {
#line 1161
    tmp = signal_mask(0);
#line 1161
    signal_setmask(tmp);
#line 1162
    i = 0;
    }
    {
#line 1162
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1162
      if (! (i < 65)) {
#line 1162
        goto while_break;
      }
      {
#line 1163
      signal(i, (void (*)(int  ))0);
#line 1162
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1165
  sigchld_mask = signal_mask(17);
#line 1167
  intr();
#line 1170
  signal(3, (void (*)(int  ))1);
#line 1173
  tmp___0 = signal(1, (void (*)(int  ))1);
  }
#line 1173
  if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))1)) {
#line 1174
    opts[87] = (char)0;
  } else {
    {
#line 1176
    install_handler(1);
    }
  }
  {
#line 1177
  install_handler(17);
#line 1179
  install_handler(28);
#line 1180
  tmp___1 = signal_mask(28);
#line 1180
  signal_block(tmp___1);
  }
#line 1182
  if (opts[93]) {
    {
#line 1183
    install_handler(13);
#line 1184
    install_handler(14);
#line 1185
    signal(15, (void (*)(int  ))1);
    }
  }
#line 1187
  if (opts[116]) {
    {
#line 1188
    signal(22, (void (*)(int  ))1);
#line 1189
    signal(20, (void (*)(int  ))1);
#line 1190
    signal(21, (void (*)(int  ))1);
    }
  }
#line 1192
  return;
}
}
#line 1199 "/tmp/zsh-5.4.2/Src/init.c"
void run_init_scripts(void) 
{ 
  char *s ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1202
  noerrexit = 11;
#line 1204
  if (emulation & ((1 << 2) | (1 << 3))) {
#line 1205
    if (opts[110]) {
      {
#line 1206
      source((char *)"/etc/profile");
      }
    }
#line 1207
    if (! opts[139]) {
#line 1208
      if (opts[110]) {
        {
#line 1209
        sourcehome((char *)".profile");
        }
      }
#line 1211
      if (opts[93]) {
        {
#line 1212
        noerrs = 2;
#line 1213
        tmp = getsparam((char *)"ENV");
#line 1213
        s = tmp;
        }
#line 1214
        if (s) {
          {
#line 1215
          s = dupstring((char const   *)s);
#line 1216
          tmp___0 = parsestr(& s);
          }
#line 1216
          if (! tmp___0) {
            {
#line 1217
            singsub(& s);
#line 1218
            noerrs = 0;
#line 1219
            source(s);
            }
          }
        }
#line 1222
        noerrs = 0;
      }
    } else {
      {
#line 1225
      source((char *)"/etc/suid_profile");
      }
    }
  } else {
    {
#line 1228
    source((char *)"/etc/zshenv");
    }
#line 1231
    if (opts[151]) {
#line 1231
      if (! opts[139]) {
#line 1233
        if (opts[93]) {
          {
#line 1238
          tmp___1 = load_module("zsh/newuser", (Feature_enables )((void *)0), 1);
          }
#line 1238
          if (! tmp___1) {
            {
#line 1240
            unload_named_module((char *)"zsh/newuser", (char *)"zsh", 1);
            }
          }
        }
        {
#line 1244
        sourcehome((char *)".zshenv");
        }
      }
    }
#line 1246
    if (opts[110]) {
#line 1248
      if (opts[151]) {
#line 1248
        if (opts[61]) {
          {
#line 1249
          source((char *)"/etc/zprofile");
          }
        }
      }
#line 1251
      if (opts[151]) {
#line 1251
        if (! opts[139]) {
          {
#line 1252
          sourcehome((char *)".zprofile");
          }
        }
      }
    }
#line 1254
    if (opts[93]) {
#line 1256
      if (opts[151]) {
#line 1256
        if (opts[61]) {
          {
#line 1257
          source((char *)"/etc/zshrc");
          }
        }
      }
#line 1259
      if (opts[151]) {
#line 1259
        if (! opts[139]) {
          {
#line 1260
          sourcehome((char *)".zshrc");
          }
        }
      }
    }
#line 1262
    if (opts[110]) {
#line 1264
      if (opts[151]) {
#line 1264
        if (opts[61]) {
          {
#line 1265
          source((char *)"/etc/zlogin");
          }
        }
      }
#line 1267
      if (opts[151]) {
#line 1267
        if (! opts[139]) {
          {
#line 1268
          sourcehome((char *)".zlogin");
          }
        }
      }
    }
  }
#line 1271
  noerrexit = 0;
#line 1272
  nohistsave = 0;
#line 1273
  return;
}
}
#line 1278 "/tmp/zsh-5.4.2/Src/init.c"
void init_misc(char *cmd , char *zsh_name ) 
{ 
  int tmp ;

  {
#line 1284
  if ((int )*zsh_name == 114) {
    {
#line 1286
    dosetopt(154, 1, 0, opts);
    }
  } else
#line 1284
  if (restricted) {
    {
#line 1286
    dosetopt(154, 1, 0, opts);
    }
  }
#line 1287
  if (cmd) {
#line 1288
    if (SHIN >= 10) {
      {
#line 1289
      fclose(bshin);
      }
    }
    {
#line 1290
    tmp = open("/dev/null", 256);
#line 1290
    SHIN = movefd(tmp);
#line 1291
    bshin = fdopen(SHIN, "r");
#line 1292
    execstring(cmd, 0, 1, (char *)"cmdarg");
#line 1293
    stopmsg = 1;
#line 1294
    zexit((int )lastval, 0);
    }
  }
#line 1297
  if (opts[93]) {
#line 1297
    if (opts[151]) {
      {
#line 1298
      readhistfile((char *)((void *)0), 0, 32768);
      }
    }
  }
#line 1299
  return;
}
}
#line 1307 "/tmp/zsh-5.4.2/Src/init.c"
enum source_return source(char *s ) 
{ 
  Eprog prog ;
  int tempfd ;
  int fd ;
  int cj ;
  zlong oldlineno ;
  int oldshst ;
  int osubsh ;
  int oloops ;
  FILE *obshin ;
  char *old_scriptname ;
  char *us ;
  char *old_scriptfilename ;
  unsigned char *ocs ;
  int ocsp ;
  int otrap_return ;
  int otrap_state ;
  struct funcstack fstack ;
  enum source_return ret ;
  int tmp ;
  void *tmp___0 ;
  FILE *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  enum loop_return tmp___4 ;

  {
#line 1311
  tempfd = -1;
#line 1315
  old_scriptname = scriptname;
#line 1316
  old_scriptfilename = scriptfilename;
#line 1319
  otrap_return = trap_return;
#line 1319
  otrap_state = trap_state;
#line 1321
  ret = (enum source_return )0;
#line 1323
  if (! s) {
#line 1326
    return ((enum source_return )1);
  } else {
    {
#line 1323
    us = unmeta((char const   *)s);
#line 1323
    prog = try_source_file(us);
    }
#line 1323
    if (! prog) {
      {
#line 1323
      tmp = open((char const   *)us, 256);
#line 1323
      tempfd = movefd(tmp);
      }
#line 1323
      if (tempfd == -1) {
#line 1326
        return ((enum source_return )1);
      }
    }
  }
  {
#line 1330
  fd = SHIN;
#line 1331
  obshin = bshin;
#line 1332
  osubsh = subsh;
#line 1333
  cj = thisjob;
#line 1334
  oldlineno = lineno;
#line 1335
  oloops = loops;
#line 1336
  oldshst = (int )opts[160];
#line 1337
  ocs = cmdstack;
#line 1338
  ocsp = cmdsp;
#line 1339
  tmp___0 = zalloc((size_t )256);
#line 1339
  cmdstack = (unsigned char *)tmp___0;
#line 1340
  cmdsp = 0;
  }
#line 1342
  if (! prog) {
    {
#line 1343
    SHIN = tempfd;
#line 1344
    bshin = fdopen(SHIN, "r");
    }
  }
  {
#line 1346
  subsh = 0;
#line 1347
  lineno = (zlong )1;
#line 1348
  loops = 0;
#line 1349
  dosetopt(160, 0, 1, opts);
#line 1350
  scriptname = s;
#line 1351
  scriptfilename = s;
  }
#line 1353
  if (opts[167]) {
    {
#line 1354
    printprompt4();
    }
#line 1355
    if (xtrerr) {
#line 1355
      tmp___1 = xtrerr;
    } else {
#line 1355
      tmp___1 = stderr;
    }
    {
#line 1355
    fprintf((FILE */* __restrict  */)tmp___1, (char const   */* __restrict  */)"<sourcetrace>\n");
    }
  }
#line 1363
  trap_state = 0;
#line 1365
  sourcelevel ++;
#line 1367
  fstack.name = scriptfilename;
#line 1368
  if (funcstack) {
#line 1368
    fstack.caller = funcstack->name;
  } else {
#line 1368
    if (old_scriptfilename) {
#line 1368
      tmp___2 = (char const   *)old_scriptfilename;
    } else {
#line 1368
      tmp___2 = "zsh";
    }
    {
#line 1368
    tmp___3 = dupstring(tmp___2);
#line 1368
    fstack.caller = tmp___3;
    }
  }
#line 1370
  fstack.flineno = (zlong )0;
#line 1371
  fstack.lineno = oldlineno;
#line 1372
  fstack.filename = scriptfilename;
#line 1373
  fstack.prev = funcstack;
#line 1374
  fstack.tp = 0;
#line 1375
  funcstack = & fstack;
#line 1377
  if (prog) {
    {
#line 1378
    pushheap();
#line 1379
    errflag &= -2;
#line 1380
    execode(prog, 1, 0, (char *)"filecode");
#line 1381
    popheap();
    }
#line 1382
    if (errflag) {
#line 1383
      ret = (enum source_return )2;
    }
  } else {
    {
#line 1386
    tmp___4 = loop(0, 0);
    }
    {
#line 1388
    if ((unsigned int )tmp___4 == 0U) {
#line 1388
      goto case_0;
    }
#line 1392
    if ((unsigned int )tmp___4 == 1U) {
#line 1392
      goto case_1;
    }
#line 1397
    if ((unsigned int )tmp___4 == 2U) {
#line 1397
      goto case_2;
    }
#line 1386
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1390
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1394
    lastval = (zlong )0;
#line 1395
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1398
    ret = (enum source_return )2;
#line 1399
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1402
  funcstack = funcstack->prev;
#line 1403
  sourcelevel --;
#line 1405
  trap_state = otrap_state;
#line 1406
  trap_return = otrap_return;
#line 1409
  if (prog) {
    {
#line 1410
    freeeprog(prog);
    }
  } else {
    {
#line 1412
    fclose(bshin);
#line 1413
    *(fdtable + SHIN) = (unsigned char)0;
#line 1414
    SHIN = fd;
#line 1415
    bshin = obshin;
    }
  }
  {
#line 1417
  subsh = osubsh;
#line 1418
  thisjob = cj;
#line 1419
  lineno = oldlineno;
#line 1420
  loops = oloops;
#line 1421
  dosetopt(160, oldshst, 1, opts);
#line 1422
  errflag &= -2;
  }
#line 1423
  if (! exit_pending) {
#line 1424
    retflag = 0;
  }
  {
#line 1425
  scriptname = old_scriptname;
#line 1426
  scriptfilename = old_scriptfilename;
#line 1427
  zfree((void *)cmdstack, 256);
#line 1428
  cmdstack = ocs;
#line 1429
  cmdsp = ocsp;
  }
#line 1431
  return (ret);
}
}
#line 1437 "/tmp/zsh-5.4.2/Src/init.c"
void sourcehome(char *s ) 
{ 
  char *h ;
  sigset_t oset ;
  char *buf___7 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  sigset_t oset___0 ;

  {
#line 1442
  queueing_enabled ++;
#line 1443
  if (emulation & ((1 << 3) | (1 << 2))) {
#line 1443
    goto _L;
  } else {
    {
#line 1443
    h = getsparam_u((char *)"ZDOTDIR");
    }
#line 1443
    if (! h) {
      _L: /* CIL Label */ 
#line 1444
      h = home;
#line 1445
      if (! h) {
        {
#line 1446
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1446
          queueing_enabled --;
#line 1446
          if (! queueing_enabled) {
            {
#line 1446
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 1446
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 1446
                if (! (queue_front != queue_rear)) {
#line 1446
                  goto while_break___1;
                }
                {
#line 1446
                queue_front = (queue_front + 1) % 128;
#line 1446
                oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1446
                zhandler(signal_queue[queue_front]);
#line 1446
                signal_setmask(oset);
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 1446
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 1446
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 1447
        return;
      }
    }
  }
  {
#line 1453
  tmp = strlen((char const   *)h);
#line 1453
  tmp___0 = strlen((char const   *)s);
#line 1453
  tmp___1 = zhalloc(sizeof(char ) * ((tmp + tmp___0) + 2UL));
#line 1453
  buf___7 = (char *)tmp___1;
#line 1454
  sprintf((char */* __restrict  */)buf___7, (char const   */* __restrict  */)"%s/%s",
          h, s);
  }
  {
#line 1455
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1455
    queueing_enabled --;
#line 1455
    if (! queueing_enabled) {
      {
#line 1455
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1455
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1455
          if (! (queue_front != queue_rear)) {
#line 1455
            goto while_break___4;
          }
          {
#line 1455
          queue_front = (queue_front + 1) % 128;
#line 1455
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 1455
          zhandler(signal_queue[queue_front]);
#line 1455
          signal_setmask(oset___0);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1455
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 1455
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1456
  source(buf___7);
  }
#line 1458
  return;
}
}
#line 1461 "/tmp/zsh-5.4.2/Src/init.c"
void init_bltinmods(void) 
{ 
  char *zsh_features[4] ;
  char *emu_features[2] ;
  char **tmp ;
  char *features[3] ;
  char *features___0[2] ;
  char *features___1[31] ;
  char *features___2[3] ;
  char *features___3[3] ;
  char *features___4[5] ;
  char *features___5[3] ;
  char *features___6[7] ;
  char *features___7[9] ;
  char *features___8[4] ;
  char *features___9[3] ;

  {
#line 5 "./bltinmods.list"
  zsh_features[0] = (char *)"b:limit";
#line 5
  zsh_features[1] = (char *)"b:ulimit";
#line 5
  zsh_features[2] = (char *)"b:unlimit";
#line 5
  zsh_features[3] = (char *)((void *)0);
#line 11
  emu_features[0] = (char *)"b:ulimit";
#line 11
  emu_features[1] = (char *)((void *)0);
#line 15
  if (emulation & (1 << 4)) {
#line 15
    tmp = zsh_features;
  } else {
#line 15
    tmp = emu_features;
  }
  {
#line 15
  autofeatures("zsh", "zsh/rlimits", tmp, 0, 1);
  }
#line 22
  if (emulation & (1 << 4)) {
    {
#line 23
    features[0] = (char *)"b:sched";
#line 23
    features[1] = (char *)"p:zsh_scheduled_events";
#line 23
    features[2] = (char *)((void *)0);
#line 28
    autofeatures("zsh", "zsh/sched", features, 0, 1);
    }
  }
#line 33
  if (emulation & (1 << 4)) {
    {
#line 34
    features___0[0] = (char *)"b:private";
#line 34
    features___0[1] = (char *)((void *)0);
#line 38
    autofeatures("zsh", "zsh/param/private", features___0, 0, 1);
    }
  }
#line 43
  if (emulation & (1 << 4)) {
    {
#line 44
    features___1[0] = (char *)"p:parameters";
#line 44
    features___1[1] = (char *)"p:commands";
#line 44
    features___1[2] = (char *)"p:functions";
#line 44
    features___1[3] = (char *)"p:dis_functions";
#line 44
    features___1[4] = (char *)"p:funcfiletrace";
#line 44
    features___1[5] = (char *)"p:funcsourcetrace";
#line 44
    features___1[6] = (char *)"p:funcstack";
#line 44
    features___1[7] = (char *)"p:functrace";
#line 44
    features___1[8] = (char *)"p:builtins";
#line 44
    features___1[9] = (char *)"p:dis_builtins";
#line 44
    features___1[10] = (char *)"p:reswords";
#line 44
    features___1[11] = (char *)"p:dis_reswords";
#line 44
    features___1[12] = (char *)"p:patchars";
#line 44
    features___1[13] = (char *)"p:dis_patchars";
#line 44
    features___1[14] = (char *)"p:options";
#line 44
    features___1[15] = (char *)"p:modules";
#line 44
    features___1[16] = (char *)"p:dirstack";
#line 44
    features___1[17] = (char *)"p:history";
#line 44
    features___1[18] = (char *)"p:historywords";
#line 44
    features___1[19] = (char *)"p:jobtexts";
#line 44
    features___1[20] = (char *)"p:jobdirs";
#line 44
    features___1[21] = (char *)"p:jobstates";
#line 44
    features___1[22] = (char *)"p:nameddirs";
#line 44
    features___1[23] = (char *)"p:userdirs";
#line 44
    features___1[24] = (char *)"p:aliases";
#line 44
    features___1[25] = (char *)"p:dis_aliases";
#line 44
    features___1[26] = (char *)"p:galiases";
#line 44
    features___1[27] = (char *)"p:dis_galiases";
#line 44
    features___1[28] = (char *)"p:saliases";
#line 44
    features___1[29] = (char *)"p:dis_saliases";
#line 44
    features___1[30] = (char *)((void *)0);
#line 77
    autofeatures("zsh", "zsh/parameter", features___1, 0, 1);
    }
  }
#line 82
  if (emulation & (1 << 4)) {
    {
#line 83
    features___2[0] = (char *)"b:echotc";
#line 83
    features___2[1] = (char *)"p:termcap";
#line 83
    features___2[2] = (char *)((void *)0);
#line 88
    autofeatures("zsh", "zsh/termcap", features___2, 0, 1);
    }
  }
#line 93
  if (emulation & (1 << 4)) {
    {
#line 94
    features___3[0] = (char *)"b:echoti";
#line 94
    features___3[1] = (char *)"p:terminfo";
#line 94
    features___3[2] = (char *)((void *)0);
#line 99
    autofeatures("zsh", "zsh/terminfo", features___3, 0, 1);
    }
  }
#line 104
  if (emulation & (1 << 4)) {
    {
#line 105
    features___4[0] = (char *)"b:zformat";
#line 105
    features___4[1] = (char *)"b:zstyle";
#line 105
    features___4[2] = (char *)"b:zregexparse";
#line 105
    features___4[3] = (char *)"b:zparseopts";
#line 105
    features___4[4] = (char *)((void *)0);
#line 112
    autofeatures("zsh", "zsh/zutil", features___4, 0, 1);
    }
  }
  {
#line 114
  add_dep("zsh/zutil", (char *)"zsh/complete");
  }
#line 118
  if (emulation & (1 << 4)) {
    {
#line 119
    features___5[0] = (char *)"b:compctl";
#line 119
    features___5[1] = (char *)"b:compcall";
#line 119
    features___5[2] = (char *)((void *)0);
#line 124
    autofeatures("zsh", "zsh/compctl", features___5, 0, 1);
    }
  }
  {
#line 126
  add_dep("zsh/compctl", (char *)"zsh/complete");
#line 127
  add_dep("zsh/compctl", (char *)"zsh/zle");
  }
#line 131
  if (emulation & (1 << 4)) {
    {
#line 132
    features___6[0] = (char *)"b:compadd";
#line 132
    features___6[1] = (char *)"b:compset";
#line 132
    features___6[2] = (char *)"c:prefix";
#line 132
    features___6[3] = (char *)"c:suffix";
#line 132
    features___6[4] = (char *)"c:between";
#line 132
    features___6[5] = (char *)"c:after";
#line 132
    features___6[6] = (char *)((void *)0);
#line 141
    autofeatures("zsh", "zsh/complete", features___6, 0, 1);
    }
  }
  {
#line 143
  add_dep("zsh/complete", (char *)"zsh/zle");
#line 147
  add_dep("zsh/complist", (char *)"zsh/complete");
#line 148
  add_dep("zsh/complist", (char *)"zsh/zle");
  }
#line 152
  if (emulation & (1 << 4)) {
    {
#line 153
    features___7[0] = (char *)"b:compdescribe";
#line 153
    features___7[1] = (char *)"b:comparguments";
#line 153
    features___7[2] = (char *)"b:compvalues";
#line 153
    features___7[3] = (char *)"b:compquote";
#line 153
    features___7[4] = (char *)"b:comptags";
#line 153
    features___7[5] = (char *)"b:comptry";
#line 153
    features___7[6] = (char *)"b:compfiles";
#line 153
    features___7[7] = (char *)"b:compgroups";
#line 153
    features___7[8] = (char *)((void *)0);
#line 164
    autofeatures("zsh", "zsh/computil", features___7, 0, 1);
    }
  }
  {
#line 166
  add_dep("zsh/computil", (char *)"zsh/complete");
#line 167
  add_dep("zsh/computil", (char *)"zsh/zle");
  }
#line 171
  if (emulation & (1 << 4)) {
    {
#line 172
    features___8[0] = (char *)"b:bindkey";
#line 172
    features___8[1] = (char *)"b:vared";
#line 172
    features___8[2] = (char *)"b:zle";
#line 172
    features___8[3] = (char *)((void *)0);
#line 178
    autofeatures("zsh", "zsh/zle", features___8, 0, 1);
    }
  }
#line 183
  if (emulation & (1 << 4)) {
    {
#line 184
    features___9[0] = (char *)"p:widgets";
#line 184
    features___9[1] = (char *)"p:keymaps";
#line 184
    features___9[2] = (char *)((void *)0);
#line 189
    autofeatures("zsh", "zsh/zleparameter", features___9, 0, 1);
    }
  }
  {
#line 191
  add_dep("zsh/zleparameter", (char *)"zsh/zle");
#line 203
  register_module((char *)"zsh/main", & setup_zshQsmain, & features_zshQsmain, & enables_zshQsmain,
                  & boot_zshQsmain, & cleanup_zshQsmain, & finish_zshQsmain);
#line 1467 "/tmp/zsh-5.4.2/Src/init.c"
  load_module("zsh/main", (Feature_enables )((void *)0), 0);
  }
#line 1468
  return;
}
}
#line 1471 "/tmp/zsh-5.4.2/Src/init.c"
void noop_function(void) 
{ 


  {
#line 1475
  return;
}
}
#line 1478 "/tmp/zsh-5.4.2/Src/init.c"
void noop_function_int(int nothing  __attribute__((__unused__)) ) 
{ 


  {
#line 1482
  return;
}
}
#line 1501 "/tmp/zsh-5.4.2/Src/init.c"
char *zleentry(int cmd  , ...) 
{ 
  char *ret ;
  va_list___0 ap ;
  int tmp ;
  char *pptbuf ;
  char **lp ;
  int pptlen ;
  char **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *ll ;
  int *cs ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1505
  ret = (char *)((void *)0);
#line 1509
  __builtin_va_start(ap, cmd);
  }
  {
#line 1515
  if (zle_load_state == 0) {
#line 1515
    goto case_0;
  }
#line 1535
  if (zle_load_state == 1) {
#line 1535
    goto case_1;
  }
#line 1541
  if (zle_load_state == 2) {
#line 1541
    goto case_2;
  }
#line 1514
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1520
  if (cmd != 3) {
#line 1520
    if (cmd != 4) {
#line 1520
      if (cmd != 5) {
        {
#line 1523
        tmp = load_module("zsh/zle", (Feature_enables )((void *)0), 0);
        }
#line 1523
        if (tmp != 1) {
          {
#line 1524
          load_module("zsh/compctl", (Feature_enables )((void *)0), 0);
#line 1525
          ret = (*zle_entry_ptr)(cmd, ap);
#line 1527
          cmd = -1;
          }
        } else {
#line 1529
          zle_load_state = 2;
        }
      }
    }
  }
#line 1533
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1536
  ret = (*zle_entry_ptr)(cmd, ap);
#line 1538
  cmd = -1;
  }
#line 1539
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1543
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1555
  if (cmd == 1) {
#line 1555
    goto case_1___0;
  }
#line 1572
  if (cmd == 0) {
#line 1572
    goto case_0___0;
  }
#line 1547
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 1560
  tmp___0 = __builtin_va_arg(ap, char **);
#line 1560
  lp = tmp___0;
  }
#line 1562
  if (lp) {
#line 1562
    tmp___1 = *lp;
  } else {
#line 1562
    tmp___1 = (char *)((void *)0);
  }
  {
#line 1562
  tmp___2 = promptexpand(tmp___1, 0, (char *)((void *)0), (char *)((void *)0), (unsigned int *)((void *)0));
#line 1562
  pptbuf = unmetafy(tmp___2, & pptlen);
#line 1565
  write_loop(2, (char const   *)pptbuf, (size_t )pptlen);
#line 1566
  free((void *)pptbuf);
#line 1568
  ret = shingetline();
  }
#line 1569
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 1576
  tmp___3 = __builtin_va_arg(ap, int *);
#line 1576
  ll = tmp___3;
#line 1577
  tmp___4 = __builtin_va_arg(ap, int *);
#line 1577
  cs = tmp___4;
#line 1578
  tmp___5 = 0;
#line 1578
  *cs = tmp___5;
#line 1578
  *ll = tmp___5;
#line 1579
  ret = ztrdup("");
  }
#line 1580
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1584
  __builtin_va_end(ap);
  }
#line 1585
  return (ret);
}
}
#line 1591 "/tmp/zsh-5.4.2/Src/init.c"
int (*compctlreadptr)(char * , char ** , Options  , char * )  =    & fallback_compctlread;
#line 1594 "/tmp/zsh-5.4.2/Src/init.c"
int fallback_compctlread(char *name , char **args  __attribute__((__unused__)) , Options ops  __attribute__((__unused__)) ,
                         char *reply  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1597
  zwarnnam((char const   *)name, "no loaded module provides read for completion context");
  }
#line 1598
  return (1);
}
}
#line 1614 "/tmp/zsh-5.4.2/Src/init.c"
int zsh_main(int argc  __attribute__((__unused__)) , char **argv ) 
{ 
  char **t ;
  char *runscript ;
  char *zsh_name ;
  char *cmd ;
  int t0 ;
  char *arg0 ;
  char *sh ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __gid_t tmp___7 ;
  __gid_t tmp___8 ;
  int tmp___9 ;
  int errexit ;
  char const   *tmp___10 ;

  {
  {
#line 1617
  runscript = (char *)((void *)0);
#line 1621
  setlocale(6, "");
#line 1624
  init_jobs(argv, environ);
#line 1631
  typtab['\000'] = (short )((int )typtab[0] | (1 << 12));
#line 1632
  typtab[(unsigned char)131] = (short )((int )typtab[(unsigned char)131] | (1 << 12));
#line 1633
  typtab[(unsigned char)162] = (short )((int )typtab[(unsigned char)162] | (1 << 12));
#line 1634
  t0 = 132;
  }
  {
#line 1634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1634
    if (! (t0 <= 161)) {
#line 1634
      goto while_break;
    }
#line 1635
    typtab[t0] = (short )((int )typtab[t0] | ((1 << 4) | (1 << 12)));
#line 1634
    t0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1637
  t = argv;
  {
#line 1637
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1637
    if (! *t) {
#line 1637
      goto while_break___0;
    }
    {
#line 1637
    *t = metafy(*t, -1, 4);
#line 1637
    t ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1639
  zsh_name = *(argv + 0);
  {
#line 1640
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1641
    arg0 = zsh_name;
#line 1642
    zsh_name = strrchr((char const   *)arg0, '/');
    }
#line 1642
    if (zsh_name) {
#line 1645
      zsh_name ++;
    } else {
#line 1643
      zsh_name = arg0;
    }
#line 1646
    if ((int )*zsh_name == 45) {
#line 1647
      zsh_name ++;
    }
    {
#line 1648
    tmp___0 = strcmp((char const   *)zsh_name, "su");
    }
#line 1648
    if (tmp___0 == 0) {
      {
#line 1649
      tmp = zgetenv((char *)"SHELL");
#line 1649
      sh = tmp;
      }
#line 1650
      if (sh) {
#line 1650
        if (*sh) {
#line 1650
          if ((unsigned long )arg0 != (unsigned long )sh) {
#line 1651
            zsh_name = sh;
          } else {
#line 1653
            goto while_break___1;
          }
        } else {
#line 1653
          goto while_break___1;
        }
      } else {
#line 1653
        goto while_break___1;
      }
    } else {
#line 1655
      goto while_break___1;
    }
#line 1640
    if (! zsh_name) {
#line 1640
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1658
  tmp___1 = zopenmax();
#line 1658
  fdtable_size = (int )tmp___1;
#line 1659
  tmp___2 = zshcalloc((unsigned long )fdtable_size * sizeof(*fdtable));
#line 1659
  fdtable = (unsigned char *)tmp___2;
#line 1660
  tmp___4 = (unsigned char)2;
#line 1660
  *(fdtable + 2) = tmp___4;
#line 1660
  tmp___3 = tmp___4;
#line 1660
  *(fdtable + 1) = tmp___3;
#line 1660
  *(fdtable + 0) = tmp___3;
#line 1662
  createoptiontable();
#line 1663
  emulate((char const   *)zsh_name, 1, & emulation, opts);
#line 1664
  opts[110] = (char )((int )*(*argv) == 45);
#line 1665
  tmp___5 = getuid();
#line 1665
  tmp___6 = geteuid();
  }
#line 1665
  if (tmp___5 != tmp___6) {
#line 1665
    tmp___9 = 1;
  } else {
    {
#line 1665
    tmp___7 = getgid();
#line 1665
    tmp___8 = getegid();
    }
#line 1665
    if (tmp___7 != tmp___8) {
#line 1665
      tmp___9 = 1;
    } else {
#line 1665
      tmp___9 = 0;
    }
  }
  {
#line 1665
  opts[139] = (char )tmp___9;
#line 1667
  parseargs(argv, & runscript, & cmd);
#line 1669
  SHTTY = -1;
#line 1670
  init_io(cmd);
#line 1671
  setupvals(cmd, runscript, zsh_name);
#line 1673
  init_signals();
#line 1674
  init_bltinmods();
#line 1675
  init_builtins();
#line 1676
  run_init_scripts();
#line 1677
  setupshin(runscript);
#line 1678
  init_misc(cmd, zsh_name);
  }
  {
#line 1680
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1686
    errexit = 0;
#line 1687
    maybeshrinkjobtab();
    }
    {
#line 1689
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1691
      retflag = 0;
#line 1692
      loop(1, 0);
      }
#line 1693
      if (errflag) {
#line 1693
        if (! opts[93]) {
#line 1693
          if (! opts[40]) {
#line 1694
            errexit = 1;
#line 1695
            goto while_break___3;
          }
        }
      }
#line 1689
      if ((unsigned int )tok != 37U) {
#line 1689
        if (! ((unsigned int )tok != 38U)) {
#line 1689
          if (! opts[160]) {
#line 1689
            goto while_break___3;
          }
        }
      } else {
#line 1689
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1698
    if ((unsigned int )tok == 38U) {
#line 1698
      goto _L;
    } else
#line 1698
    if (errexit) {
      _L: /* CIL Label */ 
#line 1700
      if (! lastval) {
#line 1701
        lastval = (zlong )1;
      }
      {
#line 1702
      stopmsg = 1;
#line 1703
      zexit((int )lastval, 0);
      }
    }
#line 1705
    if (opts[90]) {
#line 1705
      if (! opts[93]) {
        {
#line 1710
        zexit((int )lastval, 0);
        }
#line 1711
        goto __Cont;
      }
    } else {
      {
#line 1710
      zexit((int )lastval, 0);
      }
#line 1711
      goto __Cont;
    }
#line 1713
    noexitct ++;
#line 1714
    if (noexitct >= 10) {
      {
#line 1715
      stopmsg = 1;
#line 1716
      zexit((int )lastval, 0);
      }
    }
#line 1723
    if (! use_exit_printed) {
#line 1724
      if (! opts[110]) {
#line 1724
        tmp___10 = "use \'exit\' to exit.";
      } else {
#line 1724
        tmp___10 = "use \'logout\' to logout.";
      }
      {
#line 1724
      zerrnam("zsh", tmp___10);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 481 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 805
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) symlink)(char const   *__from ,
                                                                                      char const   *__to ) ;
#line 146 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 293 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 797 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
#line 38 "./hashtable.epro"
void createhisttable(void) ;
#line 41
int histstrcmp(char const   *str1 , char const   *str2 ) ;
#line 42
extern void addhistnode(HashTable ht , char *nam , void *nodeptr ) ;
#line 43
void freehistnode(HashNode nodeptr ) ;
#line 44
void freehistdata(Histent he , int unlink___0 ) ;
#line 5 "./hist.epro"
int (*hgetc)(void)  ;
#line 6 "./hist.epro"
void (*hungetc)(int  )  ;
#line 7 "./hist.epro"
void (*hwaddc)(int  )  ;
#line 8 "./hist.epro"
void (*hwbegin)(int  )  ;
#line 9 "./hist.epro"
void (*hwend)(void)  ;
#line 10 "./hist.epro"
void (*addtoline)(int  )  ;
#line 11 "./hist.epro"
int stophist  ;
#line 12 "./hist.epro"
int expanding  ;
#line 13 "./hist.epro"
int excs  ;
#line 14 "./hist.epro"
int exlast  ;
#line 15 "./hist.epro"
zlong curhist  ;
#line 16 "./hist.epro"
struct histent curline  ;
#line 17 "./hist.epro"
zlong histlinect  ;
#line 18 "./hist.epro"
HashTable histtab  ;
#line 19 "./hist.epro"
Histent hist_ring  ;
#line 20 "./hist.epro"
zlong histsiz  ;
#line 21 "./hist.epro"
zlong savehistsiz  ;
#line 22 "./hist.epro"
int histdone  ;
#line 23 "./hist.epro"
int histactive  ;
#line 24 "./hist.epro"
int hist_ignore_all_dups  ;
#line 25 "./hist.epro"
int hist_skip_flags  ;
#line 26 "./hist.epro"
short *chwords  ;
#line 27 "./hist.epro"
int chwordlen  ;
#line 28 "./hist.epro"
int chwordpos  ;
#line 29 "./hist.epro"
char *hsubl  ;
#line 30 "./hist.epro"
char *hsubr  ;
#line 31 "./hist.epro"
char *hptr  ;
#line 32 "./hist.epro"
char *chline  ;
#line 33 "./hist.epro"
char *zle_chline  ;
#line 34 "./hist.epro"
int qbang  ;
#line 35 "./hist.epro"
int hlinesz  ;
#line 36
void hist_context_save(struct hist_stack *hs , int toplevel ) ;
#line 37
void hist_context_restore(struct hist_stack  const  *hs , int toplevel ) ;
#line 39
void iaddtoline(int c ) ;
#line 44
void histreduceblanks(void) ;
#line 45
void histremovedups(void) ;
#line 46
zlong addhistnum(zlong hl , int n , int xflags ) ;
#line 47
Histent movehistent(Histent he , int n , int xflags ) ;
#line 48
Histent up_histent(Histent he ) ;
#line 49
Histent down_histent(Histent he ) ;
#line 50
Histent gethistent(zlong ev , int nearmatch ) ;
#line 51
Histent prepnexthistent(void) ;
#line 53
void ihwbegin(int offset ) ;
#line 54
void ihwend(void) ;
#line 57
char *hgetline(void) ;
#line 58
zlong hcomsearch(char *str ) ;
#line 67
void checkcurline(Histent he ) ;
#line 68
Histent quietgethist(int ev ) ;
#line 72
void savehistfile(char *fn___0 , int err , int writeflags ) ;
#line 73
int lockhistfile(char *fn___0 , int keep_trying ) ;
#line 74
void unlockhistfile(char *fn___0 ) ;
#line 75
int histfileIsLocked(void) ;
#line 77
void histsplitwords(char *lineptr , short **wordsp , int *nwordsp , int *nwordposp ,
                    int uselex ) ;
#line 78
int pushhiststack(char *hf , zlong hs , zlong shs , int level ) ;
#line 79
int pophiststack(void) ;
#line 2 "./hist.pro"
static void safeinungetc(int c ) ;
#line 3
static int getsubsargs(char *subline  __attribute__((__unused__)) , int *gbalp , int *cflagp ) ;
#line 4
static int getargc(Histent ehist ) ;
#line 5
static int substfailed(void) ;
#line 6
static int histsubchar(int c ) ;
#line 7
static void hwget(char **startptr ) ;
#line 8
static int getargspec(int argc , int marg___0 , int evset ) ;
#line 9
static zlong hconsearch(char *str , int *marg___0 ) ;
#line 10
static char *convamps(char *out , char *in , int inlen ) ;
#line 11
static Histent gethist(int ev ) ;
#line 12
static char *getargs(Histent elist , int arg1 , int arg2 ) ;
#line 13
static int quote(char **tr ) ;
#line 14
static int quotebreak(char **tr ) ;
#line 15
static char *hdynread2(int stop ) ;
#line 202 "/tmp/zsh-5.4.2/Src/hist.c"
static zlong defev  ;
#line 205 "/tmp/zsh-5.4.2/Src/hist.c"
static struct histfile_stats lasthist  ;
#line 212 "/tmp/zsh-5.4.2/Src/hist.c"
static struct histsave *histsave_stack  ;
#line 223 "/tmp/zsh-5.4.2/Src/hist.c"
static int histsave_stack_size  =    0;
#line 224 "/tmp/zsh-5.4.2/Src/hist.c"
static int histsave_stack_pos  =    0;
#line 226 "/tmp/zsh-5.4.2/Src/hist.c"
static zlong histfile_linect  ;
#line 231 "/tmp/zsh-5.4.2/Src/hist.c"
void hist_context_save(struct hist_stack *hs , int toplevel ) 
{ 
  void *tmp ;

  {
#line 234
  if (toplevel) {
#line 236
    zle_chline = chline;
#line 238
    if (hptr) {
#line 239
      *hptr = (char )'\000';
    }
  }
  {
#line 241
  hs->histactive = histactive;
#line 242
  hs->histdone = histdone;
#line 243
  hs->stophist = stophist;
#line 244
  hs->hline = chline;
#line 245
  hs->hptr = hptr;
#line 246
  hs->chwords = chwords;
#line 247
  hs->chwordlen = chwordlen;
#line 248
  hs->chwordpos = chwordpos;
#line 249
  hs->hgetc = hgetc;
#line 250
  hs->hungetc = hungetc;
#line 251
  hs->hwaddc = hwaddc;
#line 252
  hs->hwbegin = hwbegin;
#line 253
  hs->hwend = hwend;
#line 254
  hs->addtoline = addtoline;
#line 255
  hs->hlinesz = hlinesz;
#line 256
  hs->defev = defev;
#line 263
  hs->cstack = cmdstack;
#line 264
  hs->csp = cmdsp;
#line 266
  stophist = 0;
#line 267
  chline = (char *)((void *)0);
#line 268
  hptr = (char *)((void *)0);
#line 269
  histactive = 0;
#line 270
  tmp = zalloc((size_t )256);
#line 270
  cmdstack = (unsigned char *)tmp;
#line 271
  cmdsp = 0;
  }
#line 272
  return;
}
}
#line 277 "/tmp/zsh-5.4.2/Src/hist.c"
void hist_context_restore(struct hist_stack  const  *hs , int toplevel ) 
{ 


  {
#line 280
  if (toplevel) {
#line 283
    zle_chline = (char *)((void *)0);
  }
#line 285
  histactive = (int )hs->histactive;
#line 286
  histdone = (int )hs->histdone;
#line 287
  stophist = (int )hs->stophist;
#line 288
  chline = (char *)hs->hline;
#line 289
  hptr = (char *)hs->hptr;
#line 290
  chwords = (short *)hs->chwords;
#line 291
  chwordlen = (int )hs->chwordlen;
#line 292
  chwordpos = (int )hs->chwordpos;
#line 293
  hgetc = (int (*)(void))hs->hgetc;
#line 294
  hungetc = (void (*)(int  ))hs->hungetc;
#line 295
  hwaddc = (void (*)(int  ))hs->hwaddc;
#line 296
  hwbegin = (void (*)(int  ))hs->hwbegin;
#line 297
  hwend = (void (*)(void))hs->hwend;
#line 298
  addtoline = (void (*)(int  ))hs->addtoline;
#line 299
  hlinesz = (int )hs->hlinesz;
#line 300
  defev = (zlong )hs->defev;
#line 301
  if (cmdstack) {
    {
#line 302
    zfree((void *)cmdstack, 256);
    }
  }
#line 303
  cmdstack = (unsigned char *)hs->cstack;
#line 304
  cmdsp = (int )hs->csp;
#line 305
  return;
}
}
#line 318 "/tmp/zsh-5.4.2/Src/hist.c"
void hist_in_word(int yesno ) 
{ 


  {
#line 321
  if (yesno) {
#line 322
    histactive |= 1 << 2;
  } else {
#line 324
    histactive &= ~ (1 << 2);
  }
#line 325
  return;
}
}
#line 329 "/tmp/zsh-5.4.2/Src/hist.c"
static void ihwaddc(int c ) 
{ 
  char *tmp ;
  int oldsiz ;
  void *tmp___0 ;

  {
#line 333
  if (chline) {
#line 333
    if (! errflag) {
#line 333
      if (! lexstop) {
#line 333
        if ((inbufflags & ((1 << 1) | (1 << 2))) != 1 << 1) {
#line 344
          if (c == (int )bangchar) {
#line 344
            if (stophist < 2) {
#line 344
              if (qbang) {
                {
#line 350
                (*hwaddc)('\\');
                }
              }
            }
          }
#line 351
          tmp = hptr;
#line 351
          hptr ++;
#line 351
          *tmp = (char )c;
#line 354
          if (hptr - chline >= (long )hlinesz) {
            {
#line 355
            oldsiz = hlinesz;
#line 357
            hlinesz = oldsiz + 64;
#line 357
            tmp___0 = realloc((void *)chline, (size_t )hlinesz);
#line 357
            chline = (char *)tmp___0;
#line 358
            hptr = chline + oldsiz;
            }
          }
        }
      }
    }
  }
#line 361
  return;
}
}
#line 369 "/tmp/zsh-5.4.2/Src/hist.c"
void iaddtoline(int c ) 
{ 
  int tmp ;

  {
#line 372
  if (! expanding) {
#line 373
    return;
  } else
#line 372
  if (lexstop) {
#line 373
    return;
  }
#line 374
  if (qbang) {
#line 374
    if (c == (int )bangchar) {
#line 374
      if (stophist < 2) {
        {
#line 375
        exlast --;
#line 376
        zleentry(2, '\\');
        }
      }
    }
  }
#line 378
  if (excs > zlemetacs) {
#line 379
    excs += (1 + inbufct) - exlast;
#line 380
    if (excs < zlemetacs) {
#line 383
      excs = zlemetacs;
    }
  }
#line 385
  exlast = inbufct;
#line 386
  if ((int )typtab[(unsigned char )c] & (1 << 4)) {
#line 386
    tmp = (int )ztokens[c - -124];
  } else {
#line 386
    tmp = c;
  }
  {
#line 386
  zleentry(2, tmp);
  }
#line 387
  return;
}
}
#line 390 "/tmp/zsh-5.4.2/Src/hist.c"
static int ihgetc(void) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 393
  tmp = ingetc();
#line 393
  c = tmp;
  }
#line 395
  if (exit_pending) {
#line 397
    lexstop = 1;
#line 398
    errflag |= 1;
#line 399
    return (' ');
  }
#line 401
  qbang = 0;
#line 402
  if (! stophist) {
#line 402
    if (! (inbufflags & (1 << 1))) {
      {
#line 404
      c = histsubchar(c);
      }
#line 405
      if (c < 0) {
#line 407
        lexstop = 1;
#line 408
        errflag |= 1;
#line 409
        return (' ');
      }
    }
  }
#line 412
  if (inbufflags & (1 << 2)) {
#line 412
    if (! stophist) {
#line 420
      qbang = 0;
#line 421
      if (c == 92) {
        {
#line 421
        c = ingetc();
#line 421
        qbang = c == (int )bangchar;
        }
#line 421
        if (! qbang) {
          {
#line 422
          safeinungetc(c);
#line 422
          c = '\\';
          }
        }
      }
    } else {
#line 412
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 423
  if (stophist) {
#line 423
    goto _L;
  } else
#line 423
  if (inbufflags & (1 << 1)) {
    _L: /* CIL Label */ 
#line 431
    if (c == (int )bangchar) {
#line 431
      if (stophist < 2) {
#line 431
        tmp___0 = 1;
      } else {
#line 431
        tmp___0 = 0;
      }
    } else {
#line 431
      tmp___0 = 0;
    }
#line 431
    qbang = tmp___0;
  }
  {
#line 432
  (*hwaddc)(c);
#line 433
  (*addtoline)(c);
  }
#line 435
  return (c);
}
}
#line 439 "/tmp/zsh-5.4.2/Src/hist.c"
static void safeinungetc(int c ) 
{ 


  {
#line 442
  if (lexstop) {
#line 443
    lexstop = 0;
  } else {
    {
#line 445
    inungetc(c);
    }
  }
#line 446
  return;
}
}
#line 449 "/tmp/zsh-5.4.2/Src/hist.c"
void herrflush(void) 
{ 
  int tmp ;

  {
  {
#line 452
  inpopalias();
  }
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 454
    if (! lexstop) {
#line 454
      if (inbufct) {
#line 454
        if (! (! strin)) {
#line 454
          goto while_break;
        }
      } else {
#line 454
        goto while_break;
      }
    } else {
#line 454
      goto while_break;
    }
    {
#line 455
    tmp = ingetc();
#line 455
    (*hwaddc)(tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  return;
}
}
#line 472 "/tmp/zsh-5.4.2/Src/hist.c"
static int getsubsargs(char *subline  __attribute__((__unused__)) , int *gbalp , int *cflagp ) 
{ 
  int del ;
  int follow ;
  char *ptr1 ;
  char *ptr2 ;
  size_t tmp ;

  {
  {
#line 478
  del = ingetc();
#line 479
  ptr1 = hdynread2(del);
  }
#line 480
  if (! ptr1) {
#line 481
    return (1);
  }
  {
#line 482
  ptr2 = hdynread2(del);
#line 483
  tmp = strlen((char const   *)ptr1);
  }
#line 483
  if (tmp) {
    {
#line 484
    zsfree(hsubl);
#line 485
    hsubl = ptr1;
    }
  } else
#line 486
  if (! hsubl) {
    {
#line 487
    zsfree(ptr1);
#line 488
    zsfree(ptr2);
    }
#line 489
    return (0);
  }
  {
#line 491
  zsfree(hsubr);
#line 492
  hsubr = ptr2;
#line 493
  follow = ingetc();
  }
#line 494
  if (follow == 58) {
    {
#line 495
    follow = ingetc();
    }
#line 496
    if (follow == 71) {
#line 497
      *gbalp = 1;
    } else {
      {
#line 499
      inungetc(follow);
#line 500
      *cflagp = 1;
      }
    }
  } else {
    {
#line 503
    inungetc(follow);
    }
  }
#line 504
  return (0);
}
}
#line 510 "/tmp/zsh-5.4.2/Src/hist.c"
static int getargc(Histent ehist ) 
{ 
  int tmp ;

  {
#line 513
  if (ehist->nwords) {
#line 513
    tmp = ehist->nwords - 1;
  } else {
#line 513
    tmp = 0;
  }
#line 513
  return (tmp);
}
}
#line 517 "/tmp/zsh-5.4.2/Src/hist.c"
static int substfailed(void) 
{ 


  {
  {
#line 520
  herrflush();
#line 521
  zerr("substitution failed");
  }
#line 522
  return (-1);
}
}
#line 533 "/tmp/zsh-5.4.2/Src/hist.c"
static int marg  =    -1;
#line 534 "/tmp/zsh-5.4.2/Src/hist.c"
static zlong mev  =    (zlong )-1;
#line 528 "/tmp/zsh-5.4.2/Src/hist.c"
static int histsubchar(int c ) 
{ 
  int farg ;
  int evset ;
  int larg ;
  int argc ;
  int cflag ;
  int bflag ;
  zlong ev ;
  char *buf___7 ;
  char *ptr___0 ;
  char *sline ;
  int lexraw_mark ;
  Histent ehist ;
  size_t buflen ;
  int gbal ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int g ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  sigset_t oset ;
  zlong t0 ;
  char *tmp___9 ;
  void *tmp___10 ;
  sigset_t oset___0 ;
  zlong tmp___11 ;
  sigset_t oset___1 ;
  sigset_t oset___2 ;
  sigset_t oset___3 ;
  sigset_t oset___4 ;
  sigset_t oset___5 ;
  sigset_t oset___6 ;
  sigset_t oset___7 ;
  int tmp___12 ;
  int gbal___0 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int one ;
  int oef ;
  int tmp___22 ;

  {
  {
#line 531
  evset = -1;
#line 531
  cflag = 0;
#line 531
  bflag = 0;
#line 549
  lexraw_mark = zshlex_raw_mark(-1);
  }
#line 552
  if (isfirstch) {
#line 552
    if (c == (int )hatchar) {
      {
#line 553
      gbal = 0;
#line 556
      isfirstch = 0;
#line 557
      inungetc((int )hatchar);
#line 558
      ehist = gethist((int )defev);
      }
#line 558
      if (ehist) {
        {
#line 558
        tmp = getargc(ehist);
#line 558
        sline = getargs(ehist, 0, tmp);
        }
#line 558
        if (! sline) {
#line 560
          return (-1);
        }
      } else {
#line 560
        return (-1);
      }
      {
#line 562
      tmp___1 = getsubsargs(sline, & gbal, & cflag);
      }
#line 562
      if (tmp___1) {
        {
#line 563
        tmp___0 = substfailed();
        }
#line 563
        return (tmp___0);
      }
#line 564
      if (! hsubl) {
#line 565
        return (-1);
      }
      {
#line 566
      tmp___3 = subst(& sline, hsubl, hsubr, gbal);
      }
#line 566
      if (tmp___3) {
        {
#line 567
        tmp___2 = substfailed();
        }
#line 567
        return (tmp___2);
      }
    } else {
#line 552
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 570
    if (c != 32) {
#line 571
      isfirstch = 0;
    }
#line 572
    if (c == 92) {
      {
#line 573
      tmp___4 = ingetc();
#line 573
      g = tmp___4;
      }
#line 575
      if (g != (int )bangchar) {
        {
#line 576
        safeinungetc(g);
        }
      } else {
#line 578
        qbang = 1;
#line 579
        return ((int )bangchar);
      }
    }
#line 582
    if (c != (int )bangchar) {
#line 583
      return (c);
    }
    {
#line 584
    *hptr = (char )'\000';
#line 585
    c = ingetc();
    }
#line 585
    if (c == 123) {
      {
#line 586
      cflag = 1;
#line 586
      bflag = cflag;
#line 587
      c = ingetc();
      }
    }
#line 589
    if (c == 34) {
      {
#line 590
      stophist = 1;
#line 591
      tmp___5 = ingetc();
      }
#line 591
      return (tmp___5);
    }
#line 593
    if (! cflag) {
#line 593
      if ((int )typtab[(unsigned char )c] & (1 << 3)) {
        {
#line 594
        safeinungetc(c);
        }
#line 595
        return ((int )bangchar);
      } else {
#line 593
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 593
    if (c == 61) {
      {
#line 594
      safeinungetc(c);
      }
#line 595
      return ((int )bangchar);
    } else
#line 593
    if (c == 40) {
      {
#line 594
      safeinungetc(c);
      }
#line 595
      return ((int )bangchar);
    } else
#line 593
    if (lexstop) {
      {
#line 594
      safeinungetc(c);
      }
#line 595
      return ((int )bangchar);
    }
    {
#line 597
    cflag = 0;
#line 598
    buflen = (size_t )265;
#line 598
    tmp___6 = zhalloc(buflen);
#line 598
    buf___7 = (char *)tmp___6;
#line 598
    ptr___0 = buf___7;
#line 602
    queueing_enabled ++;
    }
#line 603
    if (c == 63) {
      {
#line 604
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 605
        c = ingetc();
        }
#line 606
        if (c == 63) {
#line 607
          goto while_break;
        } else
#line 606
        if (c == 10) {
#line 607
          goto while_break;
        } else
#line 606
        if (lexstop) {
#line 607
          goto while_break;
        } else {
#line 609
          tmp___7 = ptr___0;
#line 609
          ptr___0 ++;
#line 609
          *tmp___7 = (char )c;
#line 610
          if ((unsigned long )ptr___0 == (unsigned long )(buf___7 + buflen)) {
            {
#line 611
            tmp___8 = hrealloc(buf___7, buflen, 2UL * buflen);
#line 611
            buf___7 = (char *)tmp___8;
#line 612
            ptr___0 = buf___7 + buflen;
#line 613
            buflen *= 2UL;
            }
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 617
      if (c != 10) {
#line 617
        if (! lexstop) {
          {
#line 618
          c = ingetc();
          }
        }
      }
      {
#line 619
      *ptr___0 = (char )'\000';
#line 620
      hsubl = ztrdup((char const   *)buf___7);
#line 620
      ev = hconsearch(hsubl, & marg);
#line 620
      mev = ev;
#line 621
      evset = 0;
      }
#line 622
      if (ev == -1L) {
        {
#line 623
        herrflush();
        }
        {
#line 624
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 624
          queueing_enabled --;
#line 624
          if (! queueing_enabled) {
            {
#line 624
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 624
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 624
                if (! (queue_front != queue_rear)) {
#line 624
                  goto while_break___2;
                }
                {
#line 624
                queue_front = (queue_front + 1) % 128;
#line 624
                oset = signal_setmask(signal_mask_queue[queue_front]);
#line 624
                zhandler(signal_queue[queue_front]);
#line 624
                signal_setmask(oset);
                }
              }
              while_break___2: /* CIL Label */ ;
              }
#line 624
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 624
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 625
        zerr("no such event: %s", buf___7);
        }
#line 626
        return (-1);
      }
    } else {
      {
#line 631
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 632
        if ((int )typtab[(unsigned char )c] & (1 << 3)) {
#line 635
          goto while_break___3;
        } else
#line 632
        if (c == 59) {
#line 635
          goto while_break___3;
        } else
#line 632
        if (c == 58) {
#line 635
          goto while_break___3;
        } else
#line 632
        if (c == 94) {
#line 635
          goto while_break___3;
        } else
#line 632
        if (c == 36) {
#line 635
          goto while_break___3;
        } else
#line 632
        if (c == 42) {
#line 635
          goto while_break___3;
        } else
#line 632
        if (c == 37) {
#line 635
          goto while_break___3;
        } else
#line 632
        if (c == 125) {
#line 635
          goto while_break___3;
        } else
#line 632
        if (c == 39) {
#line 635
          goto while_break___3;
        } else
#line 632
        if (c == 34) {
#line 635
          goto while_break___3;
        } else
#line 632
        if (c == 96) {
#line 635
          goto while_break___3;
        } else
#line 632
        if (lexstop) {
#line 635
          goto while_break___3;
        }
#line 636
        if ((unsigned long )ptr___0 != (unsigned long )buf___7) {
#line 637
          if (c == 45) {
#line 638
            goto while_break___3;
          }
#line 639
          if ((int )typtab[(unsigned char )*(buf___7 + 0)] & 1) {
#line 639
            goto _L___0;
          } else
#line 639
          if ((int )*(buf___7 + 0) == 45) {
            _L___0: /* CIL Label */ 
#line 639
            if (! ((int )typtab[(unsigned char )c] & 1)) {
#line 640
              goto while_break___3;
            }
          }
        }
#line 642
        tmp___9 = ptr___0;
#line 642
        ptr___0 ++;
#line 642
        *tmp___9 = (char )c;
#line 643
        if ((unsigned long )ptr___0 == (unsigned long )(buf___7 + buflen)) {
          {
#line 644
          tmp___10 = hrealloc(buf___7, buflen, 2UL * buflen);
#line 644
          buf___7 = (char *)tmp___10;
#line 645
          ptr___0 = buf___7 + buflen;
#line 646
          buflen *= 2UL;
          }
        }
#line 648
        if (c == 35) {
          {
#line 649
          c = ingetc();
          }
#line 650
          goto while_break___3;
        } else
#line 648
        if (c == (int )bangchar) {
          {
#line 649
          c = ingetc();
          }
#line 650
          goto while_break___3;
        }
        {
#line 652
        c = ingetc();
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 654
      if ((unsigned long )ptr___0 == (unsigned long )buf___7) {
#line 654
        if (c == 125) {
#line 654
          goto _L___1;
        } else
#line 654
        if (c == 59) {
#line 654
          goto _L___1;
        } else
#line 654
        if (c == 39) {
#line 654
          goto _L___1;
        } else
#line 654
        if (c == 34) {
#line 654
          goto _L___1;
        } else
#line 654
        if (c == 96) {
          _L___1: /* CIL Label */ 
          {
#line 657
          safeinungetc(c);
          }
          {
#line 658
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 658
            queueing_enabled --;
#line 658
            if (! queueing_enabled) {
              {
#line 658
              while (1) {
                while_continue___5: /* CIL Label */ ;
                {
#line 658
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 658
                  if (! (queue_front != queue_rear)) {
#line 658
                    goto while_break___6;
                  }
                  {
#line 658
                  queue_front = (queue_front + 1) % 128;
#line 658
                  oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 658
                  zhandler(signal_queue[queue_front]);
#line 658
                  signal_setmask(oset___0);
                  }
                }
                while_break___6: /* CIL Label */ ;
                }
#line 658
                goto while_break___5;
              }
              while_break___5: /* CIL Label */ ;
              }
            }
#line 658
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 659
          return ((int )bangchar);
        }
      }
#line 661
      *ptr___0 = (char)0;
#line 662
      if (! *buf___7) {
#line 663
        if (c != 37) {
#line 664
          if (opts[42]) {
            {
#line 665
            ev = addhistnum(curhist, -1, 16);
            }
          } else {
#line 667
            ev = defev;
          }
#line 668
          if (c == 58) {
#line 668
            if (evset == -1) {
#line 669
              evset = 0;
            } else {
#line 671
              evset = 1;
            }
          } else {
#line 671
            evset = 1;
          }
        } else {
#line 673
          if (marg != -1) {
#line 674
            ev = mev;
          } else {
#line 676
            ev = defev;
          }
#line 677
          evset = 0;
        }
      } else {
        {
#line 679
        t0 = zstrtol((char const   *)buf___7, (char **)((void *)0), 10);
        }
#line 679
        if (t0) {
#line 680
          if (t0 < 0L) {
            {
#line 680
            tmp___11 = addhistnum(curhist, (int )t0, 16);
#line 680
            ev = tmp___11;
            }
          } else {
#line 680
            ev = t0;
          }
#line 681
          evset = 1;
        } else
#line 682
        if ((unsigned int )*buf___7 == (unsigned int )bangchar) {
          {
#line 683
          ev = addhistnum(curhist, -1, 16);
#line 684
          evset = 1;
          }
        } else
#line 685
        if ((int )*buf___7 == 35) {
#line 686
          ev = curhist;
#line 687
          evset = 1;
        } else {
          {
#line 688
          ev = hcomsearch(buf___7);
          }
#line 688
          if (ev == -1L) {
            {
#line 689
            herrflush();
            }
            {
#line 690
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 690
              queueing_enabled --;
#line 690
              if (! queueing_enabled) {
                {
#line 690
                while (1) {
                  while_continue___8: /* CIL Label */ ;
                  {
#line 690
                  while (1) {
                    while_continue___9: /* CIL Label */ ;
#line 690
                    if (! (queue_front != queue_rear)) {
#line 690
                      goto while_break___9;
                    }
                    {
#line 690
                    queue_front = (queue_front + 1) % 128;
#line 690
                    oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 690
                    zhandler(signal_queue[queue_front]);
#line 690
                    signal_setmask(oset___1);
                    }
                  }
                  while_break___9: /* CIL Label */ ;
                  }
#line 690
                  goto while_break___8;
                }
                while_break___8: /* CIL Label */ ;
                }
              }
#line 690
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
            {
#line 691
            zerr("event not found: %s", buf___7);
            }
#line 692
            return (-1);
          } else {
#line 694
            evset = 1;
          }
        }
      }
    }
    {
#line 699
    defev = ev;
#line 699
    ehist = gethist((int )defev);
    }
#line 699
    if (! ehist) {
      {
#line 700
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 700
        queueing_enabled --;
#line 700
        if (! queueing_enabled) {
          {
#line 700
          while (1) {
            while_continue___11: /* CIL Label */ ;
            {
#line 700
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 700
              if (! (queue_front != queue_rear)) {
#line 700
                goto while_break___12;
              }
              {
#line 700
              queue_front = (queue_front + 1) % 128;
#line 700
              oset___2 = signal_setmask(signal_mask_queue[queue_front]);
#line 700
              zhandler(signal_queue[queue_front]);
#line 700
              signal_setmask(oset___2);
              }
            }
            while_break___12: /* CIL Label */ ;
            }
#line 700
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
        }
#line 700
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 701
      return (-1);
    }
    {
#line 705
    argc = getargc(ehist);
    }
#line 706
    if (c == 58) {
      {
#line 707
      cflag = 1;
#line 708
      c = ingetc();
      }
#line 709
      if (c == 37) {
#line 709
        if (marg != -1) {
#line 710
          if (! evset) {
            {
#line 711
            defev = mev;
#line 711
            ehist = gethist((int )defev);
#line 712
            argc = getargc(ehist);
            }
          } else {
            {
#line 714
            herrflush();
            }
            {
#line 715
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 715
              queueing_enabled --;
#line 715
              if (! queueing_enabled) {
                {
#line 715
                while (1) {
                  while_continue___14: /* CIL Label */ ;
                  {
#line 715
                  while (1) {
                    while_continue___15: /* CIL Label */ ;
#line 715
                    if (! (queue_front != queue_rear)) {
#line 715
                      goto while_break___15;
                    }
                    {
#line 715
                    queue_front = (queue_front + 1) % 128;
#line 715
                    oset___3 = signal_setmask(signal_mask_queue[queue_front]);
#line 715
                    zhandler(signal_queue[queue_front]);
#line 715
                    signal_setmask(oset___3);
                    }
                  }
                  while_break___15: /* CIL Label */ ;
                  }
#line 715
                  goto while_break___14;
                }
                while_break___14: /* CIL Label */ ;
                }
              }
#line 715
              goto while_break___13;
            }
            while_break___13: /* CIL Label */ ;
            }
            {
#line 716
            zerr("ambiguous history reference");
            }
#line 717
            return (-1);
          }
        }
      }
    }
#line 722
    if (c == 42) {
#line 723
      farg = 1;
#line 724
      larg = argc;
#line 725
      cflag = 0;
    } else {
      {
#line 727
      inungetc(c);
#line 728
      farg = getargspec(argc, marg, evset);
#line 728
      larg = farg;
      }
#line 729
      if (larg == -2) {
        {
#line 730
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 730
          queueing_enabled --;
#line 730
          if (! queueing_enabled) {
            {
#line 730
            while (1) {
              while_continue___17: /* CIL Label */ ;
              {
#line 730
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 730
                if (! (queue_front != queue_rear)) {
#line 730
                  goto while_break___18;
                }
                {
#line 730
                queue_front = (queue_front + 1) % 128;
#line 730
                oset___4 = signal_setmask(signal_mask_queue[queue_front]);
#line 730
                zhandler(signal_queue[queue_front]);
#line 730
                signal_setmask(oset___4);
                }
              }
              while_break___18: /* CIL Label */ ;
              }
#line 730
              goto while_break___17;
            }
            while_break___17: /* CIL Label */ ;
            }
          }
#line 730
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 731
        return (-1);
      }
#line 733
      if (farg != -1) {
#line 734
        cflag = 0;
      }
      {
#line 735
      c = ingetc();
      }
#line 736
      if (c == 42) {
#line 737
        cflag = 0;
#line 738
        larg = argc;
      } else
#line 739
      if (c == 45) {
        {
#line 740
        cflag = 0;
#line 741
        larg = getargspec(argc, marg, evset);
        }
#line 742
        if (larg == -2) {
          {
#line 743
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 743
            queueing_enabled --;
#line 743
            if (! queueing_enabled) {
              {
#line 743
              while (1) {
                while_continue___20: /* CIL Label */ ;
                {
#line 743
                while (1) {
                  while_continue___21: /* CIL Label */ ;
#line 743
                  if (! (queue_front != queue_rear)) {
#line 743
                    goto while_break___21;
                  }
                  {
#line 743
                  queue_front = (queue_front + 1) % 128;
#line 743
                  oset___5 = signal_setmask(signal_mask_queue[queue_front]);
#line 743
                  zhandler(signal_queue[queue_front]);
#line 743
                  signal_setmask(oset___5);
                  }
                }
                while_break___21: /* CIL Label */ ;
                }
#line 743
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
            }
#line 743
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 744
          return (-1);
        }
#line 746
        if (larg == -1) {
#line 747
          larg = argc - 1;
        }
      } else {
        {
#line 749
        inungetc(c);
        }
      }
    }
#line 751
    if (farg == -1) {
#line 752
      farg = 0;
    }
#line 753
    if (larg == -1) {
#line 754
      larg = argc;
    }
    {
#line 755
    sline = getargs(ehist, farg, larg);
    }
#line 755
    if (! sline) {
      {
#line 756
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 756
        queueing_enabled --;
#line 756
        if (! queueing_enabled) {
          {
#line 756
          while (1) {
            while_continue___23: /* CIL Label */ ;
            {
#line 756
            while (1) {
              while_continue___24: /* CIL Label */ ;
#line 756
              if (! (queue_front != queue_rear)) {
#line 756
                goto while_break___24;
              }
              {
#line 756
              queue_front = (queue_front + 1) % 128;
#line 756
              oset___6 = signal_setmask(signal_mask_queue[queue_front]);
#line 756
              zhandler(signal_queue[queue_front]);
#line 756
              signal_setmask(oset___6);
              }
            }
            while_break___24: /* CIL Label */ ;
            }
#line 756
            goto while_break___23;
          }
          while_break___23: /* CIL Label */ ;
          }
        }
#line 756
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 757
      return (-1);
    }
    {
#line 759
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 759
      queueing_enabled --;
#line 759
      if (! queueing_enabled) {
        {
#line 759
        while (1) {
          while_continue___26: /* CIL Label */ ;
          {
#line 759
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 759
            if (! (queue_front != queue_rear)) {
#line 759
              goto while_break___27;
            }
            {
#line 759
            queue_front = (queue_front + 1) % 128;
#line 759
            oset___7 = signal_setmask(signal_mask_queue[queue_front]);
#line 759
            zhandler(signal_queue[queue_front]);
#line 759
            signal_setmask(oset___7);
            }
          }
          while_break___27: /* CIL Label */ ;
          }
#line 759
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
      }
#line 759
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
  }
  {
#line 764
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 765
    if (cflag) {
#line 765
      c = ':';
    } else {
      {
#line 765
      tmp___12 = ingetc();
#line 765
      c = tmp___12;
      }
    }
#line 766
    cflag = 0;
#line 767
    if (c == 58) {
      {
#line 768
      gbal___0 = 0;
#line 770
      c = ingetc();
      }
#line 770
      if (c == 103) {
        {
#line 771
        gbal___0 = 1;
#line 772
        c = ingetc();
        }
#line 773
        if (c != 115) {
#line 773
          if (c != 38) {
            {
#line 774
            zerr("\'s\' or \'&\' modifier expected after \'g\'");
            }
#line 775
            return (-1);
          }
        }
      }
      {
#line 779
      if (c == 112) {
#line 779
        goto case_112;
      }
#line 782
      if (c == 97) {
#line 782
        goto case_97;
      }
#line 790
      if (c == 65) {
#line 790
        goto case_65;
      }
#line 797
      if (c == 99) {
#line 797
        goto case_99;
      }
#line 804
      if (c == 104) {
#line 804
        goto case_104;
      }
#line 811
      if (c == 101) {
#line 811
        goto case_101;
      }
#line 818
      if (c == 114) {
#line 818
        goto case_114;
      }
#line 825
      if (c == 116) {
#line 825
        goto case_116;
      }
#line 832
      if (c == 115) {
#line 832
        goto case_115;
      }
#line 835
      if (c == 38) {
#line 835
        goto case_38;
      }
#line 845
      if (c == 113) {
#line 845
        goto case_113;
      }
#line 848
      if (c == 81) {
#line 848
        goto case_81;
      }
#line 860
      if (c == 120) {
#line 860
        goto case_120;
      }
#line 863
      if (c == 108) {
#line 863
        goto case_108;
      }
#line 866
      if (c == 117) {
#line 866
        goto case_117;
      }
#line 869
      goto switch_default;
      case_112: /* CIL Label */ 
#line 780
      histdone = 3;
#line 781
      goto switch_break;
      case_97: /* CIL Label */ 
      {
#line 783
      tmp___13 = chabspath(& sline);
      }
#line 783
      if (! tmp___13) {
        {
#line 784
        herrflush();
#line 785
        zerr("modifier failed: a");
        }
#line 786
        return (-1);
      }
#line 788
      goto switch_break;
      case_65: /* CIL Label */ 
      {
#line 791
      tmp___14 = chrealpath(& sline);
      }
#line 791
      if (! tmp___14) {
        {
#line 792
        herrflush();
#line 793
        zerr("modifier failed: A");
        }
#line 794
        return (-1);
      }
#line 796
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 798
      sline = equalsubstr(sline, 0, 0);
      }
#line 798
      if (! sline) {
        {
#line 799
        herrflush();
#line 800
        zerr("modifier failed: c");
        }
#line 801
        return (-1);
      }
#line 803
      goto switch_break;
      case_104: /* CIL Label */ 
      {
#line 805
      tmp___15 = remtpath(& sline);
      }
#line 805
      if (! tmp___15) {
        {
#line 806
        herrflush();
#line 807
        zerr("modifier failed: h");
        }
#line 808
        return (-1);
      }
#line 810
      goto switch_break;
      case_101: /* CIL Label */ 
      {
#line 812
      tmp___16 = rembutext(& sline);
      }
#line 812
      if (! tmp___16) {
        {
#line 813
        herrflush();
#line 814
        zerr("modifier failed: e");
        }
#line 815
        return (-1);
      }
#line 817
      goto switch_break;
      case_114: /* CIL Label */ 
      {
#line 819
      tmp___17 = remtext(& sline);
      }
#line 819
      if (! tmp___17) {
        {
#line 820
        herrflush();
#line 821
        zerr("modifier failed: r");
        }
#line 822
        return (-1);
      }
#line 824
      goto switch_break;
      case_116: /* CIL Label */ 
      {
#line 826
      tmp___18 = remlpaths(& sline);
      }
#line 826
      if (! tmp___18) {
        {
#line 827
        herrflush();
#line 828
        zerr("modifier failed: t");
        }
#line 829
        return (-1);
      }
#line 831
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 833
      tmp___19 = getsubsargs(sline, & gbal___0, & cflag);
      }
#line 833
      if (tmp___19) {
#line 834
        return (-1);
      }
      case_38: /* CIL Label */ 
#line 836
      if (hsubl) {
#line 836
        if (hsubr) {
          {
#line 837
          tmp___21 = subst(& sline, hsubl, hsubr, gbal___0);
          }
#line 837
          if (tmp___21) {
            {
#line 838
            tmp___20 = substfailed();
            }
#line 838
            return (tmp___20);
          }
        } else {
          {
#line 840
          herrflush();
#line 841
          zerr("no previous substitution");
          }
#line 842
          return (-1);
        }
      } else {
        {
#line 840
        herrflush();
#line 841
        zerr("no previous substitution");
        }
#line 842
        return (-1);
      }
#line 844
      goto switch_break;
      case_113: /* CIL Label */ 
      {
#line 846
      quote(& sline);
      }
#line 847
      goto switch_break;
      case_81: /* CIL Label */ 
      {
#line 850
      one = noerrs;
#line 850
      oef = errflag;
#line 852
      noerrs = 1;
#line 853
      parse_subst_string(sline);
#line 854
      noerrs = one;
#line 855
      errflag = oef | (errflag & 2);
#line 856
      remnulargs(sline);
#line 857
      untokenize(sline);
      }
#line 859
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 861
      quotebreak(& sline);
      }
#line 862
      goto switch_break;
      case_108: /* CIL Label */ 
      {
#line 864
      sline = casemodify(sline, 2);
      }
#line 865
      goto switch_break;
      case_117: /* CIL Label */ 
      {
#line 867
      sline = casemodify(sline, 1);
      }
#line 868
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 870
      herrflush();
#line 871
      zerr("illegal modifier: %c", c);
      }
#line 872
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 875
      if (c != 125) {
        {
#line 876
        inungetc(c);
        }
      } else
#line 875
      if (! bflag) {
        {
#line 876
        inungetc(c);
        }
      }
#line 877
      if (c != 125) {
#line 877
        if (bflag) {
          {
#line 878
          zerr("\'}\' expected");
          }
#line 879
          return (-1);
        }
      }
#line 881
      goto while_break___28;
    }
  }
  while_break___28: /* CIL Label */ ;
  }
  {
#line 885
  zshlex_raw_back_to_mark(lexraw_mark);
#line 892
  lexstop = 0;
#line 898
  inpush(sline, 1 << 2, (Alias )((void *)0));
#line 899
  histdone |= 1;
  }
#line 900
  if (opts[86]) {
#line 901
    histdone |= 6;
  }
  {
#line 904
  tmp___22 = ingetc();
  }
#line 904
  return (tmp___22);
}
}
#line 910 "/tmp/zsh-5.4.2/Src/hist.c"
static void ihungetc(int c ) 
{ 
  int doit ;
  int tmp ;
  int tmp___0 ;

  {
#line 913
  doit = 1;
  {
#line 915
  while (1) {
    while_continue: /* CIL Label */ ;
#line 915
    if (! lexstop) {
#line 915
      if (! (! errflag)) {
#line 915
        goto while_break;
      }
    } else {
#line 915
      goto while_break;
    }
#line 916
    if ((int )*(hptr + -1) != (int )((char )c)) {
#line 916
      if (stophist < 4) {
#line 916
        if ((unsigned long )hptr > (unsigned long )(chline + 1)) {
#line 916
          if ((int )*(hptr + -1) == 10) {
#line 916
            if ((int )*(hptr + -2) == 92) {
#line 916
              if (! (histactive & (1 << 3))) {
#line 916
                if ((inbufflags & ((1 << 1) | (1 << 2))) != 1 << 1) {
                  {
#line 920
                  histactive |= 1 << 3;
#line 921
                  (*hungetc)('\n');
#line 922
                  (*hungetc)('\\');
#line 923
                  histactive &= ~ (1 << 3);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 926
    if (expanding) {
#line 927
      zlemetacs --;
#line 928
      zlemetall --;
#line 929
      exlast ++;
    }
#line 931
    if ((inbufflags & ((1 << 1) | (1 << 2))) != 1 << 1) {
#line 933
      hptr --;
#line 935
      if (c == (int )bangchar) {
#line 935
        if (stophist < 2) {
#line 935
          if ((unsigned long )hptr > (unsigned long )chline) {
#line 935
            if ((int )*(hptr + -1) == 92) {
#line 935
              tmp = 1;
            } else {
#line 935
              tmp = 0;
            }
          } else {
#line 935
            tmp = 0;
          }
        } else {
#line 935
          tmp = 0;
        }
      } else {
#line 935
        tmp = 0;
      }
#line 935
      qbang = tmp;
    } else {
#line 939
      qbang = 0;
    }
#line 941
    if (doit) {
      {
#line 942
      inungetc(c);
      }
    }
#line 943
    if (! qbang) {
#line 944
      return;
    }
#line 945
    if (! stophist) {
#line 945
      if (inbufflags & (1 << 2)) {
#line 945
        tmp___0 = 1;
      } else
#line 945
      if (! (inbufflags & (1 << 1))) {
#line 945
        tmp___0 = 1;
      } else {
#line 945
        tmp___0 = 0;
      }
    } else {
#line 945
      tmp___0 = 0;
    }
#line 945
    doit = tmp___0;
#line 947
    c = '\\';
  }
  while_break: /* CIL Label */ ;
  }
#line 949
  return;
}
}
#line 954 "/tmp/zsh-5.4.2/Src/hist.c"
void strinbeg(int dohist ) 
{ 


  {
  {
#line 957
  strin ++;
#line 958
  hbegin(dohist);
#line 959
  lexinit();
#line 964
  init_parse_status();
  }
#line 965
  return;
}
}
#line 970 "/tmp/zsh-5.4.2/Src/hist.c"
void strinend(void) 
{ 


  {
  {
#line 973
  hend((Eprog )((void *)0));
#line 975
  strin --;
#line 976
  isfirstch = 1;
#line 977
  histdone = 0;
  }
#line 978
  return;
}
}
#line 983 "/tmp/zsh-5.4.2/Src/hist.c"
static void nohw(int c  __attribute__((__unused__)) ) 
{ 


  {
#line 986
  return;
}
}
#line 988 "/tmp/zsh-5.4.2/Src/hist.c"
static void nohwe(void) 
{ 


  {
#line 991
  return;
}
}
#line 995 "/tmp/zsh-5.4.2/Src/hist.c"
static void linkcurline(void) 
{ 
  Histent tmp ;

  {
#line 998
  if (! hist_ring) {
#line 999
    curline.down = & curline;
#line 999
    curline.up = curline.down;
#line 999
    hist_ring = curline.up;
  } else {
#line 1001
    curline.up = hist_ring;
#line 1002
    curline.down = hist_ring->down;
#line 1003
    tmp = & curline;
#line 1003
    (hist_ring->down)->up = tmp;
#line 1003
    hist_ring->down = tmp;
#line 1004
    hist_ring = & curline;
  }
#line 1006
  curhist ++;
#line 1006
  curline.histnum = curhist;
#line 1007
  return;
}
}
#line 1009 "/tmp/zsh-5.4.2/Src/hist.c"
static void unlinkcurline(void) 
{ 


  {
#line 1012
  (curline.up)->down = curline.down;
#line 1013
  (curline.down)->up = curline.up;
#line 1014
  if ((unsigned long )hist_ring == (unsigned long )(& curline)) {
#line 1015
    if (! histlinect) {
#line 1016
      hist_ring = (Histent )((void *)0);
    } else {
#line 1018
      hist_ring = curline.up;
    }
  }
#line 1020
  curhist --;
#line 1021
  return;
}
}
#line 1026 "/tmp/zsh-5.4.2/Src/hist.c"
void hbegin(int dohist ) 
{ 
  char *hf ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1031
  isfirstch = 1;
#line 1031
  isfirstln = isfirstch;
#line 1032
  errflag &= -2;
#line 1033
  histdone = 0;
#line 1034
  if (! dohist) {
#line 1035
    stophist = 2;
  } else
#line 1036
  if (dohist != 2) {
#line 1037
    if (! opts[93]) {
#line 1037
      stophist = 2;
    } else
#line 1037
    if (! opts[160]) {
#line 1037
      stophist = 2;
    } else {
#line 1037
      stophist = 0;
    }
  } else {
#line 1039
    stophist = 0;
  }
#line 1051
  if (stophist == 2) {
#line 1052
    hptr = (char *)((void *)0);
#line 1052
    chline = hptr;
#line 1053
    hlinesz = 0;
#line 1054
    chwords = (short *)((void *)0);
#line 1055
    chwordlen = 0;
#line 1056
    hgetc = & ingetc;
#line 1057
    hungetc = & inungetc;
#line 1058
    hwaddc = & nohw;
#line 1059
    hwbegin = & nohw;
#line 1060
    hwend = & nohwe;
#line 1061
    addtoline = & nohw;
  } else {
    {
#line 1063
    hlinesz = 64;
#line 1063
    tmp = zshcalloc((size_t )hlinesz);
#line 1063
    hptr = (char *)tmp;
#line 1063
    chline = hptr;
#line 1064
    chwordlen = 64;
#line 1064
    tmp___0 = zalloc((unsigned long )chwordlen * sizeof(short ));
#line 1064
    chwords = (short *)tmp___0;
#line 1065
    hgetc = & ihgetc;
#line 1066
    hungetc = & ihungetc;
#line 1067
    hwaddc = & ihwaddc;
#line 1068
    hwbegin = & ihwbegin;
#line 1069
    hwend = & ihwend;
#line 1070
    addtoline = & iaddtoline;
    }
#line 1071
    if (! opts[18]) {
#line 1072
      stophist = 4;
    }
  }
#line 1074
  chwordpos = 0;
#line 1076
  if (hist_ring) {
#line 1076
    if (! hist_ring->ftim) {
#line 1076
      if (! strin) {
        {
#line 1077
        hist_ring->ftim = time((time_t *)((void *)0));
        }
      }
    }
  }
#line 1078
  if (dohist == 2) {
#line 1078
    goto _L;
  } else
#line 1078
  if (opts[93]) {
#line 1078
    if (opts[160]) {
      _L: /* CIL Label */ 
#line 1078
      if (! strin) {
        {
#line 1079
        histactive = 1;
#line 1080
        attachtty(mypgrp);
#line 1081
        linkcurline();
#line 1082
        defev = addhistnum(curhist, -1, 16);
        }
      } else {
#line 1084
        histactive = 1 | (1 << 1);
      }
    } else {
#line 1084
      histactive = 1 | (1 << 1);
    }
  } else {
#line 1084
    histactive = 1 | (1 << 1);
  }
  {
#line 1086
  hf = getsparam((char *)"HISTFILE");
  }
#line 1105
  if (opts[92]) {
#line 1105
    if (! opts[157]) {
#line 1105
      if (! opts[91]) {
#line 1105
        if (! (histactive & (1 << 1))) {
#line 1105
          if (! strin) {
#line 1105
            if (histsave_stack_pos == 0) {
              {
#line 1108
              savehistfile(hf, 0, 32784);
              }
            }
          }
        }
      }
    }
  }
#line 1109
  return;
}
}
#line 1112 "/tmp/zsh-5.4.2/Src/hist.c"
void histreduceblanks(void) 
{ 
  int i ;
  int len ;
  int pos ;
  int needblank ;
  int spacecount ;
  int trunc_ok ;
  char *lastptr ;
  char *ptr___0 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;

  {
#line 1115
  spacecount = 0;
#line 1118
  if (opts[78]) {
    {
#line 1119
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1119
      if (! ((int )*(chline + spacecount) == 32)) {
#line 1119
        goto while_break;
      }
#line 1119
      spacecount ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1121
  i = 0;
#line 1121
  len = spacecount;
  {
#line 1121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1121
    if (! (i < chwordpos)) {
#line 1121
      goto while_break___0;
    }
#line 1122
    if (i > 0) {
#line 1122
      if ((int )*(chwords + i) > (int )*(chwords + (i - 1))) {
#line 1122
        tmp = 1;
      } else {
#line 1122
        tmp = 0;
      }
    } else {
#line 1122
      tmp = 0;
    }
#line 1122
    len += ((int )*(chwords + (i + 1)) - (int )*(chwords + i)) + tmp;
#line 1121
    i += 2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1125
  if ((int )*(chline + len) == 0) {
#line 1126
    return;
  }
#line 1129
  if (chwordpos) {
#line 1130
    lastptr = chline + (int )*(chwords + (chwordpos - 1));
  } else {
#line 1132
    lastptr = chline;
  }
#line 1134
  i = 0;
#line 1134
  pos = spacecount;
  {
#line 1134
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1134
    if (! (i < chwordpos)) {
#line 1134
      goto while_break___1;
    }
#line 1135
    len = (int )*(chwords + (i + 1)) - (int )*(chwords + i);
#line 1136
    if (i < chwordpos - 2) {
#line 1136
      if ((int )*(chwords + (i + 2)) > (int )*(chwords + (i + 1))) {
#line 1136
        tmp___0 = 1;
      } else {
#line 1136
        tmp___0 = 0;
      }
    } else {
#line 1136
      tmp___0 = 0;
    }
#line 1136
    needblank = tmp___0;
#line 1137
    if (pos != (int )*(chwords + i)) {
      {
#line 1138
      memmove((void *)(chline + pos), (void const   *)(chline + (int )*(chwords + i)),
              (size_t )(len + needblank));
#line 1139
      *(chwords + i) = (short )pos;
#line 1140
      *(chwords + (i + 1)) = (short )((int )*(chwords + i) + len);
      }
    }
#line 1142
    pos += len + needblank;
#line 1134
    i += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1149
  trunc_ok = 1;
#line 1150
  ptr___0 = lastptr;
  {
#line 1150
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1150
    if (! *ptr___0) {
#line 1150
      goto while_break___2;
    }
#line 1151
    if (! ((int )typtab[(unsigned char )*ptr___0] & (1 << 3))) {
#line 1152
      trunc_ok = 0;
#line 1153
      goto while_break___2;
    }
#line 1150
    ptr___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1156
  if (trunc_ok) {
#line 1157
    *(chline + pos) = (char )'\000';
  } else {
#line 1159
    ptr___0 = chline + pos;
    {
#line 1160
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1160
      tmp___1 = ptr___0;
#line 1160
      ptr___0 ++;
#line 1160
      tmp___3 = lastptr;
#line 1160
      lastptr ++;
#line 1160
      tmp___2 = *tmp___3;
#line 1160
      *tmp___1 = tmp___2;
#line 1160
      if (! tmp___2) {
#line 1160
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1163
  return;
}
}
#line 1166 "/tmp/zsh-5.4.2/Src/hist.c"
void histremovedups(void) 
{ 
  Histent he ;
  Histent next___0 ;

  {
#line 1170
  he = hist_ring;
  {
#line 1170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1170
    if (! he) {
#line 1170
      goto while_break;
    }
    {
#line 1171
    next___0 = up_histent(he);
    }
#line 1172
    if (he->node.flags & 8) {
      {
#line 1173
      freehistnode(& he->node);
      }
    }
#line 1170
    he = next___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1175
  return;
}
}
#line 1178 "/tmp/zsh-5.4.2/Src/hist.c"
zlong addhistnum(zlong hl , int n , int xflags ) 
{ 
  int dir ;
  int tmp ;
  int tmp___0 ;
  Histent he ;
  Histent tmp___1 ;
  zlong tmp___2 ;
  zlong tmp___3 ;

  {
#line 1181
  if (n < 0) {
#line 1181
    tmp___0 = -1;
  } else {
#line 1181
    if (n > 0) {
#line 1181
      tmp = 1;
    } else {
#line 1181
      tmp = 0;
    }
#line 1181
    tmp___0 = tmp;
  }
  {
#line 1181
  dir = tmp___0;
#line 1182
  tmp___1 = gethistent(hl, dir);
#line 1182
  he = tmp___1;
  }
#line 1184
  if (! he) {
#line 1185
    return ((zlong )0);
  }
#line 1186
  if (he->histnum != hl) {
#line 1187
    n -= dir;
  }
#line 1188
  if (n) {
    {
#line 1189
    he = movehistent(he, n, xflags);
    }
  }
#line 1190
  if (! he) {
#line 1191
    if (dir < 0) {
#line 1191
      if (hist_ring) {
#line 1191
        tmp___2 = (hist_ring->down)->histnum;
      } else {
#line 1191
        tmp___2 = curhist;
      }
#line 1191
      tmp___3 = tmp___2 - 1L;
    } else {
#line 1191
      tmp___3 = curhist + 1L;
    }
#line 1191
    return (tmp___3);
  }
#line 1192
  return (he->histnum);
}
}
#line 1196 "/tmp/zsh-5.4.2/Src/hist.c"
Histent movehistent(Histent he , int n , int xflags ) 
{ 


  {
  {
#line 1199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1199
    if (! (n < 0)) {
#line 1199
      goto while_break;
    }
    {
#line 1200
    he = up_histent(he);
    }
#line 1200
    if (! he) {
#line 1201
      return ((Histent )((void *)0));
    }
#line 1202
    if (! (he->node.flags & xflags)) {
#line 1203
      n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1205
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1205
    if (! (n > 0)) {
#line 1205
      goto while_break___0;
    }
    {
#line 1206
    he = down_histent(he);
    }
#line 1206
    if (! he) {
#line 1207
      return ((Histent )((void *)0));
    }
#line 1208
    if (! (he->node.flags & xflags)) {
#line 1209
      n --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1211
  checkcurline(he);
  }
#line 1212
  return (he);
}
}
#line 1216 "/tmp/zsh-5.4.2/Src/hist.c"
Histent up_histent(Histent he ) 
{ 
  Histent tmp ;

  {
#line 1219
  if (! he) {
#line 1219
    tmp = (Histent )((void *)0);
  } else
#line 1219
  if ((unsigned long )he->up == (unsigned long )hist_ring) {
#line 1219
    tmp = (Histent )((void *)0);
  } else {
#line 1219
    tmp = he->up;
  }
#line 1219
  return (tmp);
}
}
#line 1223 "/tmp/zsh-5.4.2/Src/hist.c"
Histent down_histent(Histent he ) 
{ 
  Histent tmp ;

  {
#line 1226
  if ((unsigned long )he == (unsigned long )hist_ring) {
#line 1226
    tmp = (Histent )((void *)0);
  } else {
#line 1226
    tmp = he->down;
  }
#line 1226
  return (tmp);
}
}
#line 1230 "/tmp/zsh-5.4.2/Src/hist.c"
Histent gethistent(zlong ev , int nearmatch ) 
{ 
  Histent he ;

  {
#line 1235
  if (! hist_ring) {
#line 1236
    return ((Histent )((void *)0));
  }
#line 1238
  if (ev - (hist_ring->down)->histnum < hist_ring->histnum - ev) {
#line 1239
    he = hist_ring->down;
    {
#line 1239
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1239
      if (! (he->histnum < ev)) {
#line 1239
        goto while_break;
      }
#line 1239
      he = he->down;
    }
    while_break: /* CIL Label */ ;
    }
#line 1240
    if (he->histnum != ev) {
#line 1241
      if (nearmatch == 0) {
#line 1243
        return ((Histent )((void *)0));
      } else
#line 1241
      if (nearmatch < 0) {
        {
#line 1241
        he = up_histent(he);
        }
#line 1241
        if ((unsigned long )he == (unsigned long )((void *)0)) {
#line 1243
          return ((Histent )((void *)0));
        }
      }
    }
  } else {
#line 1247
    he = hist_ring;
    {
#line 1247
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1247
      if (! (he->histnum > ev)) {
#line 1247
        goto while_break___0;
      }
#line 1247
      he = he->up;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1248
    if (he->histnum != ev) {
#line 1249
      if (nearmatch == 0) {
#line 1251
        return ((Histent )((void *)0));
      } else
#line 1249
      if (nearmatch > 0) {
        {
#line 1249
        he = down_histent(he);
        }
#line 1249
        if ((unsigned long )he == (unsigned long )((void *)0)) {
#line 1251
          return ((Histent )((void *)0));
        }
      }
    }
  }
  {
#line 1255
  checkcurline(he);
  }
#line 1256
  return (he);
}
}
#line 1262
static void putoldhistentryontop(short keep_going ) ;
#line 1262 "/tmp/zsh-5.4.2/Src/hist.c"
static Histent next  =    (Histent )((void *)0);
#line 1269 "/tmp/zsh-5.4.2/Src/hist.c"
static zlong max_unique_ct  =    (zlong )0;
#line 1259 "/tmp/zsh-5.4.2/Src/hist.c"
static void putoldhistentryontop(short keep_going ) 
{ 
  Histent he ;
  Histent tmp ;
  zlong tmp___0 ;
  Histent tmp___1 ;

  {
#line 1263
  if (keep_going) {
#line 1263
    tmp = next;
  } else
#line 1263
  if (! hist_ring) {
#line 1263
    tmp = next;
  } else {
#line 1263
    tmp = hist_ring->down;
  }
#line 1263
  he = tmp;
#line 1264
  if (he) {
#line 1265
    next = he->down;
  } else {
#line 1267
    return;
  }
#line 1268
  if (opts[73]) {
#line 1268
    if (! (he->node.flags & 8)) {
#line 1270
      if (! keep_going) {
#line 1271
        max_unique_ct = savehistsiz;
      }
      {
#line 1272
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1273
        tmp___0 = max_unique_ct;
#line 1273
        max_unique_ct --;
#line 1273
        if (tmp___0 <= 0L) {
#line 1274
          max_unique_ct = (zlong )0;
#line 1275
          he = hist_ring->down;
#line 1276
          next = hist_ring;
#line 1277
          goto while_break;
        } else
#line 1273
        if ((unsigned long )he == (unsigned long )hist_ring) {
#line 1274
          max_unique_ct = (zlong )0;
#line 1275
          he = hist_ring->down;
#line 1276
          next = hist_ring;
#line 1277
          goto while_break;
        }
#line 1279
        he = next;
#line 1280
        next = he->down;
#line 1272
        if (! (! (he->node.flags & 8))) {
#line 1272
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1283
  if ((unsigned long )he != (unsigned long )hist_ring->down) {
#line 1284
    (he->up)->down = he->down;
#line 1285
    (he->down)->up = he->up;
#line 1286
    he->up = hist_ring;
#line 1287
    he->down = hist_ring->down;
#line 1288
    tmp___1 = he;
#line 1288
    (he->down)->up = tmp___1;
#line 1288
    hist_ring->down = tmp___1;
  }
#line 1290
  hist_ring = he;
#line 1291
  return;
}
}
#line 1294 "/tmp/zsh-5.4.2/Src/hist.c"
Histent prepnexthistent(void) 
{ 
  Histent he ;
  int curline_in_ring ;
  void *tmp ;
  Histent tmp___0 ;
  Histent tmp___1 ;
  Histent tmp___2 ;

  {
#line 1298
  curline_in_ring = (unsigned long )hist_ring == (unsigned long )(& curline);
#line 1300
  if (curline_in_ring) {
    {
#line 1301
    unlinkcurline();
    }
  }
#line 1302
  if (hist_ring) {
#line 1302
    if (hist_ring->node.flags & 32) {
      {
#line 1303
      curhist --;
#line 1304
      freehistnode(& hist_ring->node);
      }
    }
  }
#line 1307
  if (histlinect < histsiz) {
#line 1307
    goto _L;
  } else
#line 1307
  if (! hist_ring) {
    _L: /* CIL Label */ 
    {
#line 1308
    tmp = zshcalloc(sizeof(*he));
#line 1308
    he = (Histent )tmp;
    }
#line 1309
    if (! hist_ring) {
#line 1310
      tmp___1 = he;
#line 1310
      he->down = tmp___1;
#line 1310
      tmp___0 = tmp___1;
#line 1310
      he->up = tmp___0;
#line 1310
      hist_ring = tmp___0;
    } else {
#line 1312
      he->up = hist_ring;
#line 1313
      he->down = hist_ring->down;
#line 1314
      tmp___2 = he;
#line 1314
      (he->down)->up = tmp___2;
#line 1314
      hist_ring->down = tmp___2;
#line 1315
      hist_ring = he;
    }
#line 1317
    histlinect ++;
  } else {
    {
#line 1320
    putoldhistentryontop((short)0);
#line 1321
    freehistdata(hist_ring, 0);
#line 1322
    he = hist_ring;
    }
  }
#line 1324
  curhist ++;
#line 1324
  he->histnum = curhist;
#line 1325
  if (curline_in_ring) {
    {
#line 1326
    linkcurline();
    }
  }
#line 1327
  return (he);
}
}
#line 1332 "/tmp/zsh-5.4.2/Src/hist.c"
static int should_ignore_line(Eprog prog ) 
{ 
  Wordcode pc ;
  wordcode code ;
  char *b ;
  char *tmp ;
  int saw_builtin ;
  int tmp___0 ;
  int tmp___1 ;
  HashNode tmp___2 ;
  HashNode tmp___3 ;
  HashNode tmp___4 ;

  {
#line 1335
  if (opts[78]) {
#line 1336
    if ((int )*chline == 32) {
#line 1337
      return (1);
    } else
#line 1336
    if (aliasspaceflag) {
#line 1337
      return (1);
    }
  }
#line 1340
  if (! prog) {
#line 1341
    return (0);
  }
#line 1343
  if (opts[80]) {
#line 1344
    pc = prog->prog;
#line 1345
    code = *pc;
#line 1346
    if ((code & (wordcode )((1 << 5) - 1)) == 1U) {
#line 1346
      if ((code >> 5) & (unsigned int )(1 << 5)) {
#line 1346
        if ((*(pc + 2) & (wordcode )((1 << 5) - 1)) == 11U) {
#line 1348
          return (1);
        }
      }
    }
  }
#line 1351
  if (opts[81]) {
    {
#line 1352
    tmp = getjobtext(prog, (Wordcode )((void *)0));
#line 1352
    b = tmp;
    }
#line 1354
    if ((int )*b == 98) {
      {
#line 1354
      tmp___0 = strncmp((char const   *)b, "builtin ", (size_t )8);
      }
#line 1354
      if (tmp___0 == 0) {
#line 1355
        b += 8;
#line 1356
        saw_builtin = 1;
      } else {
#line 1358
        saw_builtin = 0;
      }
    } else {
#line 1358
      saw_builtin = 0;
    }
#line 1359
    if ((int )*b == 104) {
      {
#line 1359
      tmp___1 = strncmp((char const   *)b, "history", (size_t )7);
      }
#line 1359
      if (tmp___1 == 0) {
#line 1359
        if (! *(b + 7)) {
#line 1359
          goto _L;
        } else
#line 1359
        if ((int )*(b + 7) == 32) {
          _L: /* CIL Label */ 
#line 1359
          if (saw_builtin) {
#line 1361
            return (1);
          } else {
            {
#line 1359
            tmp___2 = (*(shfunctab->getnode))(shfunctab, "history");
            }
#line 1359
            if (! tmp___2) {
#line 1361
              return (1);
            }
          }
        }
      }
    }
#line 1362
    if ((int )*b == 114) {
#line 1362
      if (! *(b + 1)) {
#line 1362
        goto _L___0;
      } else
#line 1362
      if ((int )*(b + 1) == 32) {
        _L___0: /* CIL Label */ 
#line 1362
        if (saw_builtin) {
#line 1364
          return (1);
        } else {
          {
#line 1362
          tmp___3 = (*(shfunctab->getnode))(shfunctab, "r");
          }
#line 1362
          if (! tmp___3) {
#line 1364
            return (1);
          }
        }
      }
    }
#line 1365
    if ((int )*b == 102) {
#line 1365
      if ((int )*(b + 1) == 99) {
#line 1365
        if ((int )*(b + 2) == 32) {
#line 1365
          if ((int )*(b + 3) == 45) {
#line 1365
            if (saw_builtin) {
#line 1365
              goto _L___1;
            } else {
              {
#line 1365
              tmp___4 = (*(shfunctab->getnode))(shfunctab, "fc");
              }
#line 1365
              if (! tmp___4) {
                _L___1: /* CIL Label */ 
#line 1367
                b += 3;
                {
#line 1368
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 1369
                  b ++;
#line 1369
                  if ((int )*b == 108) {
#line 1370
                    return (1);
                  }
#line 1368
                  if (! ((int )typtab[(unsigned char )*b] & (1 << 6))) {
#line 1368
                    goto while_break;
                  }
                }
                while_break: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
#line 1375
  return (0);
}
}
#line 1381 "/tmp/zsh-5.4.2/Src/hist.c"
int hend(Eprog prog ) 
{ 
  int flag ;
  int hookret ;
  int stack_pos ;
  int save ;
  char *hf ;
  sigset_t oset ;
  LinkList hookargs ;
  LinkList tmp ;
  int save_errflag ;
  int tmp___0 ;
  int tmp___1 ;
  char *ptr___0 ;
  Histent he ;
  zlong tmp___2 ;
  Histent he___0 ;
  int newflags ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  sigset_t oset___0 ;
  int tmp___9 ;

  {
#line 1384
  stack_pos = histsave_stack_pos;
#line 1392
  save = 1;
#line 1397
  queueing_enabled ++;
#line 1398
  if (histdone & 8) {
    {
#line 1399
    settyinfo(& shttyinfo);
    }
  }
#line 1400
  if (! (histactive & (1 << 1))) {
    {
#line 1401
    unlinkcurline();
    }
  }
#line 1402
  if (histactive & (1 << 1)) {
    {
#line 1403
    zfree((void *)chline, hlinesz);
#line 1404
    zfree((void *)chwords, (int )((unsigned long )chwordlen * sizeof(short )));
#line 1405
    hptr = (char *)((void *)0);
#line 1405
    chline = hptr;
#line 1406
    chwords = (short *)((void *)0);
#line 1407
    histactive = 0;
    }
    {
#line 1408
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1408
      queueing_enabled --;
#line 1408
      if (! queueing_enabled) {
        {
#line 1408
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1408
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1408
            if (! (queue_front != queue_rear)) {
#line 1408
              goto while_break___1;
            }
            {
#line 1408
            queue_front = (queue_front + 1) % 128;
#line 1408
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1408
            zhandler(signal_queue[queue_front]);
#line 1408
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1408
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1408
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1409
    return (1);
  }
#line 1411
  if (hist_ignore_all_dups != (int )opts[76]) {
#line 1411
    hist_ignore_all_dups = (int )opts[76];
#line 1411
    if (hist_ignore_all_dups != 0) {
      {
#line 1413
      histremovedups();
      }
    }
  }
#line 1415
  if (hptr) {
#line 1421
    *hptr = (char )'\000';
  }
#line 1423
  if (*chline) {
    {
#line 1424
    tmp = newlinklist();
#line 1424
    hookargs = tmp;
#line 1425
    save_errflag = errflag;
#line 1426
    errflag = 0;
#line 1428
    insertlinknode(hookargs, hookargs->list.last, (void *)"zshaddhistory");
#line 1429
    insertlinknode(hookargs, hookargs->list.last, (void *)chline);
#line 1430
    callhookfunc((char *)"zshaddhistory", hookargs, 1, & hookret);
#line 1432
    errflag &= -2;
#line 1433
    errflag |= save_errflag;
    }
  }
  {
#line 1436
  hf = getsparam((char *)"HISTFILE");
  }
#line 1437
  if (opts[157]) {
    {
#line 1437
    tmp___0 = lockhistfile(hf, 0);
    }
#line 1437
    if (! tmp___0) {
      {
#line 1438
      readhistfile(hf, 0, 32784);
#line 1439
      curline.histnum = curhist + 1L;
      }
    }
  }
#line 1441
  flag = histdone;
#line 1442
  histdone = 0;
#line 1443
  if ((unsigned long )hptr < (unsigned long )(chline + 1)) {
#line 1444
    save = 0;
  } else {
#line 1446
    if ((int )*(hptr + -1) == 10) {
#line 1447
      if (*(chline + 1)) {
#line 1448
        hptr --;
#line 1448
        *hptr = (char )'\000';
      } else {
#line 1450
        save = 0;
      }
    }
#line 1452
    if (chwordpos <= 2) {
#line 1453
      save = 0;
    } else {
      {
#line 1454
      tmp___1 = should_ignore_line(prog);
      }
#line 1454
      if (tmp___1) {
#line 1455
        save = -1;
      } else
#line 1456
      if (hookret == 2) {
#line 1457
        save = -2;
      } else
#line 1458
      if (hookret) {
#line 1459
        save = -1;
      }
    }
  }
#line 1461
  if (flag & 5) {
    {
#line 1464
    ptr___0 = ztrdup((char const   *)chline);
    }
#line 1465
    if ((flag & 5) == 1) {
      {
#line 1466
      zputs((char const   *)ptr___0, shout);
#line 1467
      fputc('\n', shout);
#line 1468
      fflush(shout);
      }
    }
#line 1470
    if (flag & 4) {
      {
#line 1471
      zinsertlinknode(bufstack, & bufstack->node, (void *)ptr___0);
#line 1472
      save = 0;
      }
    } else {
      {
#line 1474
      zsfree(ptr___0);
      }
    }
  }
#line 1476
  if (save) {
#line 1476
    goto _L;
  } else
#line 1476
  if ((int )*chline == 32) {
    _L: /* CIL Label */ 
#line 1478
    he = hist_ring;
    {
#line 1478
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1478
      if (he) {
#line 1478
        if (! (he->node.flags & 16)) {
#line 1478
          goto while_break___2;
        }
      } else {
#line 1478
        goto while_break___2;
      }
      {
#line 1478
      he = up_histent(he);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1480
    if (he) {
#line 1480
      if (he->node.flags & 32) {
#line 1481
        if ((unsigned long )he == (unsigned long )hist_ring) {
#line 1482
          tmp___2 = curhist;
#line 1482
          curhist --;
#line 1482
          curline.histnum = tmp___2;
        }
        {
#line 1483
        freehistnode(& he->node);
        }
      }
    }
  }
#line 1486
  if (save) {
#line 1498
    if (chwordpos > 1) {
#line 1498
      if (! *(chline + *(chwords + (chwordpos - 2)))) {
#line 1499
        chwordpos -= 2;
#line 1501
        if (opts[82]) {
          {
#line 1502
          histreduceblanks();
          }
        }
      }
    }
#line 1504
    if (save == -1) {
#line 1505
      newflags = 32;
    } else
#line 1506
    if (save == -2) {
#line 1507
      newflags = 64;
    } else {
#line 1509
      newflags = 0;
    }
#line 1510
    if (opts[77]) {
#line 1510
      goto _L___0;
    } else
#line 1510
    if (opts[76]) {
      _L___0: /* CIL Label */ 
#line 1510
      if (save > 0) {
#line 1510
        if (hist_ring) {
          {
#line 1510
          tmp___3 = histstrcmp((char const   *)chline, (char const   *)hist_ring->node.nam);
          }
#line 1510
          if (tmp___3 == 0) {
            {
#line 1517
            he___0 = hist_ring;
#line 1518
            newflags |= he___0->node.flags & 2;
#line 1519
            freehistdata(he___0, 0);
#line 1520
            curline.histnum = curhist;
            }
          } else {
            {
#line 1522
            he___0 = prepnexthistent();
            }
          }
        } else {
          {
#line 1522
          he___0 = prepnexthistent();
          }
        }
      } else {
        {
#line 1522
        he___0 = prepnexthistent();
        }
      }
    } else {
      {
#line 1522
      he___0 = prepnexthistent();
      }
    }
    {
#line 1524
    he___0->node.nam = ztrdup((char const   *)chline);
#line 1525
    he___0->stim = time((time_t *)((void *)0));
#line 1526
    he___0->ftim = 0L;
#line 1527
    he___0->node.flags = newflags;
#line 1529
    tmp___5 = chwordpos / 2;
#line 1529
    he___0->nwords = tmp___5;
    }
#line 1529
    if (tmp___5) {
      {
#line 1530
      tmp___4 = zalloc((unsigned long )chwordpos * sizeof(short ));
#line 1530
      he___0->words = (short *)tmp___4;
#line 1531
      memcpy((void */* __restrict  */)he___0->words, (void const   */* __restrict  */)chwords,
             (unsigned long )chwordpos * sizeof(short ));
      }
    }
#line 1533
    if (! (newflags & 32)) {
      {
#line 1534
      addhistnode(histtab, he___0->node.nam, (void *)he___0);
      }
    }
  }
  {
#line 1536
  zfree((void *)chline, hlinesz);
#line 1537
  zfree((void *)chwords, (int )((unsigned long )chwordlen * sizeof(short )));
#line 1538
  hptr = (char *)((void *)0);
#line 1538
  chline = hptr;
#line 1539
  chwords = (short *)((void *)0);
#line 1540
  histactive = 0;
  }
#line 1544
  if (opts[157]) {
    {
#line 1544
    tmp___6 = histfileIsLocked();
#line 1544
    tmp___8 = tmp___6;
    }
  } else {
#line 1544
    if (opts[91]) {
#line 1544
      tmp___7 = 1;
    } else
#line 1544
    if (opts[92]) {
#line 1544
      if (histsave_stack_pos != 0) {
#line 1544
        tmp___7 = 1;
      } else {
#line 1544
        tmp___7 = 0;
      }
    } else {
#line 1544
      tmp___7 = 0;
    }
#line 1544
    tmp___8 = tmp___7;
  }
#line 1544
  if (tmp___8) {
    {
#line 1547
    savehistfile(hf, 0, 32784);
    }
  }
  {
#line 1548
  unlockhistfile(hf);
  }
  {
#line 1553
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1553
    if (! (histsave_stack_pos > stack_pos)) {
#line 1553
      goto while_break___3;
    }
    {
#line 1554
    pophiststack();
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1555
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1555
    queueing_enabled --;
#line 1555
    if (! queueing_enabled) {
      {
#line 1555
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 1555
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1555
          if (! (queue_front != queue_rear)) {
#line 1555
            goto while_break___6;
          }
          {
#line 1555
          queue_front = (queue_front + 1) % 128;
#line 1555
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 1555
          zhandler(signal_queue[queue_front]);
#line 1555
          signal_setmask(oset___0);
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1555
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1555
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1556
  if (flag & 2) {
#line 1556
    tmp___9 = 0;
  } else
#line 1556
  if (errflag) {
#line 1556
    tmp___9 = 0;
  } else {
#line 1556
    tmp___9 = 1;
  }
#line 1556
  return (tmp___9);
}
}
#line 1562 "/tmp/zsh-5.4.2/Src/hist.c"
void ihwbegin(int offset ) 
{ 
  int tmp ;

  {
#line 1565
  if (stophist == 2) {
#line 1567
    return;
  } else
#line 1565
  if (histactive & (1 << 2)) {
#line 1567
    return;
  } else
#line 1565
  if ((inbufflags & ((1 << 1) | (1 << 2))) == 1 << 1) {
#line 1567
    return;
  }
#line 1568
  if (chwordpos % 2) {
#line 1569
    chwordpos --;
  }
#line 1570
  tmp = chwordpos;
#line 1570
  chwordpos ++;
#line 1570
  *(chwords + tmp) = (short )((hptr - chline) + (long )offset);
#line 1571
  return;
}
}
#line 1576 "/tmp/zsh-5.4.2/Src/hist.c"
void ihwend(void) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 1579
  if (stophist == 2) {
#line 1581
    return;
  } else
#line 1579
  if (histactive & (1 << 2)) {
#line 1581
    return;
  } else
#line 1579
  if ((inbufflags & ((1 << 1) | (1 << 2))) == 1 << 1) {
#line 1581
    return;
  }
#line 1582
  if (chwordpos % 2) {
#line 1582
    if (chline) {
#line 1584
      if ((unsigned long )hptr > (unsigned long )(chline + (int )*(chwords + (chwordpos - 1)))) {
#line 1585
        tmp = chwordpos;
#line 1585
        chwordpos ++;
#line 1585
        *(chwords + tmp) = (short )(hptr - chline);
#line 1586
        if (chwordpos >= chwordlen) {
          {
#line 1587
          chwordlen += 32;
#line 1587
          tmp___0 = realloc((void *)chwords, (unsigned long )chwordlen * sizeof(short ));
#line 1587
          chwords = (short *)tmp___0;
          }
        }
      } else {
#line 1593
        chwordpos --;
      }
    }
  }
#line 1596
  return;
}
}
#line 1601 "/tmp/zsh-5.4.2/Src/hist.c"
void histbackword(void) 
{ 


  {
#line 1604
  if (! (chwordpos % 2)) {
#line 1604
    if (chwordpos) {
#line 1605
      hptr = chline + (int )*(chwords + (chwordpos - 1));
    }
  }
#line 1606
  return;
}
}
#line 1611 "/tmp/zsh-5.4.2/Src/hist.c"
static void hwget(char **startptr ) 
{ 
  int pos ;

  {
#line 1614
  pos = chwordpos - 2;
#line 1631
  *startptr = chline + (int )*(chwords + pos);
#line 1632
  pos ++;
#line 1632
  *(chline + *(chwords + pos)) = (char )'\000';
#line 1633
  return;
}
}
#line 1638 "/tmp/zsh-5.4.2/Src/hist.c"
void hwrep(char *rep ) 
{ 
  char *start ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 1642
  hwget(& start);
#line 1644
  tmp = strcmp((char const   *)rep, (char const   *)start);
  }
#line 1644
  if (! tmp) {
#line 1645
    return;
  }
  {
#line 1647
  hptr = start;
#line 1648
  chwordpos -= 2;
#line 1649
  (*hwbegin)(0);
#line 1650
  qbang = 1;
  }
  {
#line 1651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1651
    if (! *rep) {
#line 1651
      goto while_break;
    }
    {
#line 1652
    tmp___0 = rep;
#line 1652
    rep ++;
#line 1652
    (*hwaddc)((int )*tmp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1653
  (*hwend)();
  }
#line 1654
  return;
}
}
#line 1659 "/tmp/zsh-5.4.2/Src/hist.c"
char *hgetline(void) 
{ 
  char *ret ;

  {
#line 1668
  if (! chline) {
#line 1669
    return ((char *)((void *)0));
  } else
#line 1668
  if ((unsigned long )hptr == (unsigned long )chline) {
#line 1669
    return ((char *)((void *)0));
  }
  {
#line 1670
  *hptr = (char )'\000';
#line 1671
  ret = dupstring((char const   *)chline);
#line 1674
  hptr = chline;
#line 1675
  chwordpos = 0;
  }
#line 1677
  return (ret);
}
}
#line 1683 "/tmp/zsh-5.4.2/Src/hist.c"
static int getargspec(int argc , int marg___0 , int evset ) 
{ 
  int c ;
  int ret ;

  {
  {
#line 1686
  ret = -1;
#line 1688
  c = ingetc();
  }
#line 1688
  if (c == 48) {
#line 1689
    return (0);
  }
#line 1690
  if ((int )typtab[(unsigned char )c] & 1) {
#line 1691
    ret = 0;
    {
#line 1692
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1692
      if (! ((int )typtab[(unsigned char )c] & 1)) {
#line 1692
        goto while_break;
      }
      {
#line 1693
      ret = (ret * 10 + c) - 48;
#line 1694
      c = ingetc();
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1696
    inungetc(c);
    }
  } else
#line 1697
  if (c == 94) {
#line 1698
    ret = 1;
  } else
#line 1699
  if (c == 36) {
#line 1700
    ret = argc;
  } else
#line 1701
  if (c == 37) {
#line 1702
    if (evset) {
      {
#line 1703
      herrflush();
#line 1704
      zerr("Ambiguous history reference");
      }
#line 1705
      return (-2);
    }
#line 1707
    if (marg___0 == -1) {
      {
#line 1708
      herrflush();
#line 1709
      zerr("%% with no previous word matched");
      }
#line 1710
      return (-2);
    }
#line 1712
    ret = marg___0;
  } else {
    {
#line 1714
    inungetc(c);
    }
  }
#line 1715
  return (ret);
}
}
#line 1721 "/tmp/zsh-5.4.2/Src/hist.c"
static zlong hconsearch(char *str , int *marg___0 ) 
{ 
  int t1 ;
  char *s ;
  Histent he ;
  int pos ;

  {
  {
#line 1724
  t1 = 0;
#line 1728
  he = up_histent(hist_ring);
  }
  {
#line 1728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1728
    if (! he) {
#line 1728
      goto while_break;
    }
#line 1729
    if (he->node.flags & 16) {
#line 1730
      goto __Cont;
    }
    {
#line 1731
    s = strstr((char const   *)he->node.nam, (char const   *)str);
    }
#line 1731
    if (s) {
#line 1732
      pos = (int )(s - he->node.nam);
      {
#line 1733
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1733
        if (t1 < he->nwords) {
#line 1733
          if (! ((int )*(he->words + 2 * t1) <= pos)) {
#line 1733
            goto while_break___0;
          }
        } else {
#line 1733
          goto while_break___0;
        }
#line 1734
        t1 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1735
      *marg___0 = t1 - 1;
#line 1736
      return (he->histnum);
    }
    __Cont: /* CIL Label */ 
    {
#line 1728
    he = up_histent(he);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1739
  return ((zlong )-1);
}
}
#line 1745 "/tmp/zsh-5.4.2/Src/hist.c"
zlong hcomsearch(char *str ) 
{ 
  Histent he ;
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1749
  tmp = strlen((char const   *)str);
#line 1749
  len = (int )tmp;
#line 1751
  he = up_histent(hist_ring);
  }
  {
#line 1751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1751
    if (! he) {
#line 1751
      goto while_break;
    }
#line 1752
    if (he->node.flags & 16) {
#line 1753
      goto __Cont;
    }
    {
#line 1754
    tmp___0 = strncmp((char const   *)he->node.nam, (char const   *)str, (size_t )len);
    }
#line 1754
    if (tmp___0 == 0) {
#line 1755
      return (he->histnum);
    }
    __Cont: /* CIL Label */ 
    {
#line 1751
    he = up_histent(he);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1757
  return ((zlong )-1);
}
}
#line 1763 "/tmp/zsh-5.4.2/Src/hist.c"
int chabspath(char **junkptr ) 
{ 
  char *current ;
  char *dest ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char tmp___11 ;
  char *tmp___12 ;

  {
#line 1768
  if (! *(*junkptr)) {
#line 1769
    return (1);
  }
#line 1771
  if ((int )*(*junkptr) != 47) {
    {
#line 1772
    tmp = zgetcwd();
#line 1772
    tmp___0 = metafy(tmp, -1, 6);
#line 1772
    *junkptr = zhtricat((char const   *)tmp___0, "/", (char const   *)*junkptr);
    }
  }
#line 1775
  current = *junkptr;
#line 1776
  dest = *junkptr;
  {
#line 1788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1789
    if ((int )*current == 47) {
#line 1794
      tmp___1 = dest;
#line 1794
      dest ++;
#line 1794
      tmp___2 = current;
#line 1794
      current ++;
#line 1794
      *tmp___1 = *tmp___2;
      {
#line 1795
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1795
        if (! ((int )*current == 47)) {
#line 1795
          goto while_break___0;
        }
#line 1796
        current ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 1797
    if (! *current) {
      {
#line 1798
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1798
        if ((unsigned long )dest > (unsigned long )(*junkptr + 1)) {
#line 1798
          if (! ((int )*(dest + -1) == 47)) {
#line 1798
            goto while_break___1;
          }
        } else {
#line 1798
          goto while_break___1;
        }
#line 1799
        dest --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1800
      *dest = (char )'\000';
#line 1801
      goto while_break;
    } else
#line 1802
    if ((int )*(current + 0) == 46) {
#line 1802
      if ((int )*(current + 1) == 46) {
#line 1802
        if (! *(current + 2)) {
#line 1802
          goto _L___4;
        } else
#line 1802
        if ((int )*(current + 2) == 47) {
          _L___4: /* CIL Label */ 
#line 1804
          if ((unsigned long )current == (unsigned long )*junkptr) {
#line 1804
            goto _L___0;
          } else
#line 1804
          if ((unsigned long )dest == (unsigned long )*junkptr) {
            _L___0: /* CIL Label */ 
#line 1805
            tmp___3 = dest;
#line 1805
            dest ++;
#line 1805
            *tmp___3 = (char )'.';
#line 1806
            tmp___4 = dest;
#line 1806
            dest ++;
#line 1806
            *tmp___4 = (char )'.';
#line 1807
            current += 2;
          } else
#line 1808
          if ((unsigned long )dest > (unsigned long )(*junkptr + 2)) {
            {
#line 1808
            tmp___7 = strncmp((char const   *)(dest - 3), "../", (size_t )3);
            }
#line 1808
            if (tmp___7) {
#line 1808
              goto _L;
            } else {
#line 1810
              tmp___5 = dest;
#line 1810
              dest ++;
#line 1810
              *tmp___5 = (char )'.';
#line 1811
              tmp___6 = dest;
#line 1811
              dest ++;
#line 1811
              *tmp___6 = (char )'.';
#line 1812
              current += 2;
            }
          } else
          _L: /* CIL Label */ 
#line 1813
          if ((unsigned long )dest > (unsigned long )(*junkptr + 1)) {
#line 1814
            *dest = (char )'\000';
#line 1815
            dest --;
            {
#line 1815
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 1815
              if ((unsigned long )dest > (unsigned long )(*junkptr + 1)) {
#line 1815
                if (! ((int )*(dest + -1) != 47)) {
#line 1815
                  goto while_break___2;
                }
              } else {
#line 1815
                goto while_break___2;
              }
#line 1815
              dest --;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 1818
            if ((int )*(dest + -1) != 47) {
#line 1819
              dest --;
            }
#line 1820
            current += 2;
#line 1821
            if ((int )*current == 47) {
#line 1822
              current ++;
            }
          } else
#line 1823
          if ((unsigned long )dest == (unsigned long )(*junkptr + 1)) {
#line 1825
            current += 2;
          } else {
#line 1827
            return (0);
          }
        } else {
#line 1802
          goto _L___5;
        }
      } else {
#line 1802
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 1829
    if ((int )*(current + 0) == 46) {
#line 1829
      if ((int )*(current + 1) == 47) {
#line 1829
        goto _L___2;
      } else
#line 1829
      if (! *(current + 1)) {
        _L___2: /* CIL Label */ 
        {
#line 1830
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1830
          current ++;
#line 1830
          if (! ((int )*current == 47)) {
#line 1830
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 1829
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 1832
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1832
        if ((int )*current != 47) {
#line 1832
          if (! ((int )*current != 0)) {
#line 1832
            goto while_break___4;
          }
        } else {
#line 1832
          goto while_break___4;
        }
#line 1833
        tmp___10 = dest;
#line 1833
        dest ++;
#line 1833
        tmp___12 = current;
#line 1833
        current ++;
#line 1833
        tmp___11 = *tmp___12;
#line 1833
        *tmp___10 = tmp___11;
#line 1833
        if ((int )tmp___11 == -125) {
#line 1834
          tmp___8 = dest;
#line 1834
          dest ++;
#line 1834
          tmp___9 = current;
#line 1834
          current ++;
#line 1834
          *tmp___8 = *tmp___9;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1837
  return (1);
}
}
#line 1841 "/tmp/zsh-5.4.2/Src/hist.c"
int chrealpath(char **junkptr ) 
{ 
  char *str ;
  char *lastpos ;
  char *nonreal ;
  char *real ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 1854
  if (! *(*junkptr)) {
#line 1855
    return (1);
  }
  {
#line 1858
  tmp = chabspath(junkptr);
  }
#line 1858
  if (! tmp) {
#line 1859
    return (0);
  }
#line 1868
  if ((int )*(*junkptr) != 47) {
#line 1869
    return (0);
  }
  {
#line 1871
  unmetafy(*junkptr, (int *)((void *)0));
#line 1873
  lastpos = strend(*junkptr);
#line 1874
  nonreal = lastpos + 1;
  }
  {
#line 1876
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1876
    real = realpath((char const   */* __restrict  */)*junkptr, (char */* __restrict  */)((void *)0));
    }
#line 1876
    if (real) {
#line 1876
      goto while_break;
    }
    {
#line 1885
    tmp___0 = __errno_location();
    }
#line 1885
    if (*tmp___0 == 22) {
#line 1886
      return (0);
    } else {
      {
#line 1885
      tmp___1 = __errno_location();
      }
#line 1885
      if (*tmp___1 == 12) {
#line 1886
        return (0);
      }
    }
#line 1888
    if ((unsigned long )nonreal == (unsigned long )*junkptr) {
#line 1892
      goto while_break;
    }
    {
#line 1895
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1895
      if ((int )*nonreal != 47) {
#line 1895
        if (! ((unsigned long )nonreal >= (unsigned long )*junkptr)) {
#line 1895
          goto while_break___0;
        }
      } else {
#line 1895
        goto while_break___0;
      }
#line 1896
      nonreal --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1897
    *nonreal = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 1900
  str = nonreal;
  {
#line 1901
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1901
    if (! ((unsigned long )str <= (unsigned long )lastpos)) {
#line 1901
      goto while_break___1;
    }
#line 1902
    if ((int )*str == 0) {
#line 1903
      *str = (char )'/';
    }
#line 1904
    str ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1907
  if (real) {
    {
#line 1908
    str = bicat((char const   *)real, (char const   *)nonreal);
#line 1908
    *junkptr = metafy(str, -1, 6);
#line 1909
    zsfree(str);
#line 1911
    free((void *)real);
    }
  } else {
    {
#line 1914
    *junkptr = metafy(nonreal, (int )((lastpos - nonreal) + 1L), 6);
    }
  }
#line 1918
  return (1);
}
}
#line 1922 "/tmp/zsh-5.4.2/Src/hist.c"
int remtpath(char **junkptr ) 
{ 
  char *str ;
  char *tmp ;

  {
  {
#line 1925
  tmp = strend(*junkptr);
#line 1925
  str = tmp;
  }
  {
#line 1928
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1928
    if ((unsigned long )str >= (unsigned long )*junkptr) {
#line 1928
      if (! ((int )*str == 47)) {
#line 1928
        goto while_break;
      }
    } else {
#line 1928
      goto while_break;
    }
#line 1929
    str --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1931
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1931
    if ((unsigned long )str >= (unsigned long )*junkptr) {
#line 1931
      if (! (! ((int )*str == 47))) {
#line 1931
        goto while_break___0;
      }
    } else {
#line 1931
      goto while_break___0;
    }
#line 1932
    str --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1933
  if ((unsigned long )str < (unsigned long )*junkptr) {
#line 1934
    if ((int )*(*junkptr) == 47) {
      {
#line 1935
      *junkptr = dupstring("/");
      }
    } else {
      {
#line 1937
      *junkptr = dupstring(".");
      }
    }
#line 1939
    return (0);
  }
  {
#line 1942
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1942
    if ((unsigned long )str > (unsigned long )*junkptr) {
#line 1942
      if (! ((int )*(str + -1) == 47)) {
#line 1942
        goto while_break___1;
      }
    } else {
#line 1942
      goto while_break___1;
    }
#line 1943
    str --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1945
  if ((unsigned long )str == (unsigned long )*junkptr) {
#line 1946
    str ++;
#line 1950
    if ((int )*str == 47) {
#line 1950
      if (! ((int )*(str + 1) == 47)) {
#line 1951
        str ++;
      }
    }
  }
#line 1953
  *str = (char )'\000';
#line 1954
  return (1);
}
}
#line 1958 "/tmp/zsh-5.4.2/Src/hist.c"
int remtext(char **junkptr ) 
{ 
  char *str ;

  {
  {
#line 1963
  str = strend(*junkptr);
  }
  {
#line 1963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1963
    if ((unsigned long )str >= (unsigned long )*junkptr) {
#line 1963
      if (! (! ((int )*str == 47))) {
#line 1963
        goto while_break;
      }
    } else {
#line 1963
      goto while_break;
    }
#line 1964
    if ((int )*str == 46) {
#line 1965
      *str = (char )'\000';
#line 1966
      return (1);
    }
#line 1963
    str --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1968
  return (0);
}
}
#line 1972 "/tmp/zsh-5.4.2/Src/hist.c"
int rembutext(char **junkptr ) 
{ 
  char *str ;

  {
  {
#line 1977
  str = strend(*junkptr);
  }
  {
#line 1977
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1977
    if ((unsigned long )str >= (unsigned long )*junkptr) {
#line 1977
      if (! (! ((int )*str == 47))) {
#line 1977
        goto while_break;
      }
    } else {
#line 1977
      goto while_break;
    }
#line 1978
    if ((int )*str == 46) {
      {
#line 1979
      *junkptr = dupstring((char const   *)(str + 1));
      }
#line 1980
      return (1);
    }
#line 1977
    str --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1983
  *junkptr = dupstring("");
  }
#line 1984
  return (0);
}
}
#line 1988 "/tmp/zsh-5.4.2/Src/hist.c"
int remlpaths(char **junkptr ) 
{ 
  char *str ;
  char *tmp ;

  {
  {
#line 1991
  tmp = strend(*junkptr);
#line 1991
  str = tmp;
  }
#line 1993
  if ((int )*str == 47) {
    {
#line 1995
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1995
      if ((unsigned long )str >= (unsigned long )*junkptr) {
#line 1995
        if (! ((int )*str == 47)) {
#line 1995
          goto while_break;
        }
      } else {
#line 1995
        goto while_break;
      }
#line 1996
      str --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1997
    *(str + 1) = (char )'\000';
  }
  {
#line 1999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1999
    if (! ((unsigned long )str >= (unsigned long )*junkptr)) {
#line 1999
      goto while_break___0;
    }
#line 2000
    if ((int )*str == 47) {
      {
#line 2001
      *str = (char )'\000';
#line 2002
      *junkptr = dupstring((char const   *)(str + 1));
      }
#line 2003
      return (1);
    }
#line 1999
    str --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2005
  return (0);
}
}
#line 2015 "/tmp/zsh-5.4.2/Src/hist.c"
char *casemodify(char *str , int how ) 
{ 
  char *str2 ;
  size_t tmp ;
  void *tmp___0 ;
  char *ptr2 ;
  int nextupper ;
  char *mbstr ;
  size_t tmp___1 ;
  void *tmp___2 ;
  mbstate_t ps ;
  wint_t wc ;
  int len ;
  int tmp___3 ;
  int mod ;
  int len2 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *mbptr ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  int c ;
  char *tmp___20 ;
  int __res ;
  __int32_t const   **tmp___22 ;
  unsigned short const   **tmp___23 ;
  int __res___0 ;
  __int32_t const   **tmp___25 ;
  unsigned short const   **tmp___26 ;
  int __res___1 ;
  __int32_t const   **tmp___28 ;
  unsigned short const   **tmp___29 ;
  int __res___2 ;
  __int32_t const   **tmp___31 ;
  unsigned short const   **tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;

  {
  {
#line 2018
  tmp = strlen((char const   *)str);
#line 2018
  tmp___0 = zhalloc(2UL * tmp + 1UL);
#line 2018
  str2 = (char *)tmp___0;
#line 2019
  ptr2 = str2;
#line 2020
  nextupper = 1;
  }
#line 2023
  if (opts[117]) {
    {
#line 2024
    tmp___1 = __ctype_get_mb_cur_max();
#line 2024
    tmp___2 = zhalloc(sizeof(char ) * tmp___1);
#line 2024
    mbstr = (char *)tmp___2;
#line 2027
    mb_charinit();
#line 2028
    memset((void *)(& ps), 0, sizeof(ps));
    }
    {
#line 2029
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2029
      if (! *str) {
#line 2029
        goto while_break;
      }
      {
#line 2031
      tmp___3 = mb_metacharlenconv((char const   *)str, & wc);
#line 2031
      len = tmp___3;
#line 2031
      mod = 0;
      }
#line 2037
      if (wc == 4294967295U) {
        {
#line 2038
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2038
          tmp___6 = len;
#line 2038
          len --;
#line 2038
          if (! tmp___6) {
#line 2038
            goto while_break___0;
          }
#line 2039
          tmp___4 = ptr2;
#line 2039
          ptr2 ++;
#line 2039
          tmp___5 = str;
#line 2039
          str ++;
#line 2039
          *tmp___4 = *tmp___5;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2041
        nextupper = 1;
#line 2042
        goto while_continue;
      }
      {
#line 2045
      if (how == 2) {
#line 2045
        goto case_2;
      }
#line 2052
      if (how == 1) {
#line 2052
        goto case_1;
      }
#line 2060
      goto switch_default;
      case_2: /* CIL Label */ 
      {
#line 2046
      tmp___7 = iswupper(wc);
      }
#line 2046
      if (tmp___7) {
        {
#line 2047
        wc = towlower(wc);
#line 2048
        mod = 1;
        }
      }
#line 2050
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 2053
      tmp___8 = iswlower(wc);
      }
#line 2053
      if (tmp___8) {
        {
#line 2054
        wc = towupper(wc);
#line 2055
        mod = 1;
        }
      }
#line 2057
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2061
      if (wc != 0U) {
        {
#line 2061
        tmp___9 = wcwidth((wchar_t )wc);
        }
#line 2061
        if (tmp___9 == 0) {
#line 2062
          goto switch_break;
        }
      }
      {
#line 2063
      tmp___12 = iswalnum(wc);
      }
#line 2063
      if (tmp___12) {
#line 2065
        if (nextupper) {
          {
#line 2066
          tmp___10 = iswlower(wc);
          }
#line 2066
          if (tmp___10) {
            {
#line 2067
            wc = towupper(wc);
#line 2068
            mod = 1;
            }
          }
#line 2070
          nextupper = 0;
        } else {
          {
#line 2071
          tmp___11 = iswupper(wc);
          }
#line 2071
          if (tmp___11) {
            {
#line 2072
            wc = towlower(wc);
#line 2073
            mod = 1;
            }
          }
        }
      } else {
#line 2064
        nextupper = 1;
      }
#line 2075
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 2077
      if (mod) {
        {
#line 2077
        tmp___19 = wcrtomb((char */* __restrict  */)mbstr, (wchar_t )wc, (mbstate_t */* __restrict  */)(& ps));
#line 2077
        len2 = (int )tmp___19;
        }
#line 2077
        if (len2 > 0) {
#line 2080
          mbptr = mbstr;
          {
#line 2080
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2080
            if (! ((unsigned long )mbptr < (unsigned long )(mbstr + len2))) {
#line 2080
              goto while_break___1;
            }
#line 2081
            if ((int )typtab[(unsigned char )*mbptr] & (1 << 12)) {
#line 2082
              tmp___13 = ptr2;
#line 2082
              ptr2 ++;
#line 2082
              *tmp___13 = (char)-125;
#line 2083
              tmp___14 = ptr2;
#line 2083
              ptr2 ++;
#line 2083
              *tmp___14 = (char )((int )*mbptr ^ 32);
            } else {
#line 2085
              tmp___15 = ptr2;
#line 2085
              ptr2 ++;
#line 2085
              *tmp___15 = *mbptr;
            }
#line 2080
            mbptr ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2087
          str += len;
        } else {
#line 2077
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 2089
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2089
          tmp___18 = len;
#line 2089
          len --;
#line 2089
          if (! tmp___18) {
#line 2089
            goto while_break___2;
          }
#line 2090
          tmp___16 = ptr2;
#line 2090
          ptr2 ++;
#line 2090
          tmp___17 = str;
#line 2090
          str ++;
#line 2090
          *tmp___16 = *tmp___17;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2096
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2096
      if (! *str) {
#line 2096
        goto while_break___3;
      }
#line 2098
      if ((int )*str == -125) {
#line 2099
        c = (int )*(str + 1) ^ 32;
#line 2100
        str += 2;
      } else {
#line 2102
        tmp___20 = str;
#line 2102
        str ++;
#line 2102
        c = (int )*tmp___20;
      }
      {
#line 2104
      if (how == 2) {
#line 2104
        goto case_2___0;
      }
#line 2109
      if (how == 1) {
#line 2109
        goto case_1___0;
      }
#line 2115
      goto switch_default___0;
      case_2___0: /* CIL Label */ 
      {
#line 2105
      tmp___23 = __ctype_b_loc();
      }
#line 2105
      if ((int const   )*(*tmp___23 + c) & 256) {
#line 2106
        if (sizeof(c) > 1UL) {
          {
#line 2106
          __res = tolower(c);
          }
        } else {
          {
#line 2106
          tmp___22 = __ctype_tolower_loc();
#line 2106
          __res = (int )*(*tmp___22 + c);
          }
        }
#line 2106
        c = __res;
      }
#line 2107
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 2110
      tmp___26 = __ctype_b_loc();
      }
#line 2110
      if ((int const   )*(*tmp___26 + c) & 512) {
#line 2111
        if (sizeof(c) > 1UL) {
          {
#line 2111
          __res___0 = toupper(c);
          }
        } else {
          {
#line 2111
          tmp___25 = __ctype_toupper_loc();
#line 2111
          __res___0 = (int )*(*tmp___25 + c);
          }
        }
#line 2111
        c = __res___0;
      }
#line 2112
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 2116
      if (! ((int )typtab[(unsigned char )c] & (1 << 1))) {
#line 2117
        nextupper = 1;
      } else
#line 2118
      if (nextupper) {
        {
#line 2119
        tmp___29 = __ctype_b_loc();
        }
#line 2119
        if ((int const   )*(*tmp___29 + c) & 512) {
#line 2120
          if (sizeof(c) > 1UL) {
            {
#line 2120
            __res___1 = toupper(c);
            }
          } else {
            {
#line 2120
            tmp___28 = __ctype_toupper_loc();
#line 2120
            __res___1 = (int )*(*tmp___28 + c);
            }
          }
#line 2120
          c = __res___1;
        }
#line 2121
        nextupper = 0;
      } else {
        {
#line 2122
        tmp___32 = __ctype_b_loc();
        }
#line 2122
        if ((int const   )*(*tmp___32 + c) & 256) {
#line 2123
          if (sizeof(c) > 1UL) {
            {
#line 2123
            __res___2 = tolower(c);
            }
          } else {
            {
#line 2123
            tmp___31 = __ctype_tolower_loc();
#line 2123
            __res___2 = (int )*(*tmp___31 + c);
            }
          }
#line 2123
          c = __res___2;
        }
      }
#line 2124
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 2126
      if ((int )typtab[(unsigned char )c] & (1 << 12)) {
#line 2127
        tmp___33 = ptr2;
#line 2127
        ptr2 ++;
#line 2127
        *tmp___33 = (char)-125;
#line 2128
        tmp___34 = ptr2;
#line 2128
        ptr2 ++;
#line 2128
        *tmp___34 = (char )(c ^ 32);
      } else {
#line 2130
        tmp___35 = ptr2;
#line 2130
        ptr2 ++;
#line 2130
        *tmp___35 = (char )c;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 2132
  *ptr2 = (char )'\000';
#line 2133
  return (str2);
}
}
#line 2146 "/tmp/zsh-5.4.2/Src/hist.c"
int subst(char **strptr , char *in , char *out , int gbal ) 
{ 
  char *str ;
  char *substcut ;
  char *sptr ;
  int off ;
  int inlen ;
  int outlen ;
  int fl ;
  char *oldin ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 2149
  str = *strptr;
#line 2152
  if (! *in) {
#line 2153
    in = str;
#line 2153
    gbal = 0;
  }
#line 2155
  if (opts[85]) {
#line 2156
    fl = 2066;
#line 2157
    oldin = in;
#line 2158
    if (gbal) {
#line 2159
      fl |= 512;
    }
#line 2160
    if ((int )*in == 35) {
#line 2162
      fl |= 4096;
#line 2163
      in ++;
    } else
#line 2160
    if ((int )*in == -124) {
#line 2162
      fl |= 4096;
#line 2163
      in ++;
    }
#line 2165
    if ((int )*in == 37) {
#line 2167
      in ++;
#line 2168
      fl |= 1;
    }
#line 2170
    if ((unsigned long )in == (unsigned long )oldin) {
#line 2172
      fl |= 4;
    }
#line 2174
    if ((unsigned long )in == (unsigned long )str) {
      {
#line 2175
      in = dupstring((char const   *)in);
      }
    }
    {
#line 2176
    tmp = parse_subst_string(in);
    }
#line 2176
    if (tmp) {
#line 2177
      return (1);
    } else
#line 2176
    if (errflag) {
#line 2177
      return (1);
    }
    {
#line 2178
    tmp___0 = parse_subst_string(out);
    }
#line 2178
    if (tmp___0) {
#line 2179
      return (1);
    } else
#line 2178
    if (errflag) {
#line 2179
      return (1);
    }
    {
#line 2180
    singsub(& in);
#line 2181
    tmp___1 = getmatch(strptr, in, fl, 1, out);
    }
#line 2181
    if (tmp___1) {
#line 2182
      return (0);
    }
  } else {
    {
#line 2184
    tmp___5 = strstr((char const   *)str, (char const   *)in);
#line 2184
    substcut = tmp___5;
    }
#line 2184
    if (substcut) {
      {
#line 2185
      tmp___2 = strlen((char const   *)in);
#line 2185
      inlen = (int )tmp___2;
#line 2186
      sptr = convamps(out, in, inlen);
#line 2187
      tmp___3 = strlen((char const   *)sptr);
#line 2187
      outlen = (int )tmp___3;
      }
      {
#line 2189
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 2190
        *substcut = (char )'\000';
#line 2191
        off = (int )((substcut - *strptr) + (long )outlen);
#line 2192
        substcut += inlen;
#line 2193
        *strptr = zhtricat((char const   *)*strptr, (char const   *)sptr, (char const   *)substcut);
#line 2194
        str = *strptr + off;
        }
#line 2189
        if (gbal) {
          {
#line 2189
          tmp___4 = strstr((char const   *)str, (char const   *)in);
#line 2189
          substcut = tmp___4;
          }
#line 2189
          if (! substcut) {
#line 2189
            goto while_break;
          }
        } else {
#line 2189
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 2197
      return (0);
    }
  }
#line 2201
  return (1);
}
}
#line 2205 "/tmp/zsh-5.4.2/Src/hist.c"
static char *convamps(char *out , char *in , int inlen ) 
{ 
  char *ptr___0 ;
  char *ret ;
  char *pp ;
  int slen ;
  int sdup ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 2209
  sdup = 0;
#line 2211
  ptr___0 = out;
#line 2211
  slen = 0;
  {
#line 2211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2211
    if (! *ptr___0) {
#line 2211
      goto while_break;
    }
#line 2212
    if ((int )*ptr___0 == 92) {
#line 2213
      ptr___0 ++;
#line 2213
      sdup = 1;
    } else
#line 2214
    if ((int )*ptr___0 == 38) {
#line 2215
      slen += inlen - 1;
#line 2215
      sdup = 1;
    }
#line 2211
    ptr___0 ++;
#line 2211
    slen ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2216
  if (! sdup) {
#line 2217
    return (out);
  }
  {
#line 2218
  tmp = zhalloc((size_t )(slen + 1));
#line 2218
  pp = (char *)tmp;
#line 2218
  ret = pp;
#line 2219
  ptr___0 = out;
  }
  {
#line 2219
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2219
    if (! *ptr___0) {
#line 2219
      goto while_break___0;
    }
#line 2220
    if ((int )*ptr___0 == 92) {
#line 2221
      tmp___0 = pp;
#line 2221
      pp ++;
#line 2221
      ptr___0 ++;
#line 2221
      *tmp___0 = *ptr___0;
    } else
#line 2222
    if ((int )*ptr___0 == 38) {
      {
#line 2223
      strcpy((char */* __restrict  */)pp, (char const   */* __restrict  */)in);
#line 2224
      pp += inlen;
      }
    } else {
#line 2226
      tmp___1 = pp;
#line 2226
      pp ++;
#line 2226
      *tmp___1 = *ptr___0;
    }
#line 2219
    ptr___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2227
  *pp = (char )'\000';
#line 2228
  return (ret);
}
}
#line 2232 "/tmp/zsh-5.4.2/Src/hist.c"
void checkcurline(Histent he ) 
{ 


  {
#line 2235
  if (he->histnum == curhist) {
#line 2235
    if (histactive & 1) {
#line 2236
      curline.node.nam = chline;
#line 2237
      curline.nwords = chwordpos / 2;
#line 2238
      curline.words = chwords;
    }
  }
#line 2240
  return;
}
}
#line 2243 "/tmp/zsh-5.4.2/Src/hist.c"
Histent quietgethist(int ev ) 
{ 
  Histent tmp ;

  {
  {
#line 2246
  tmp = gethistent((zlong )ev, 0);
  }
#line 2246
  return (tmp);
}
}
#line 2250 "/tmp/zsh-5.4.2/Src/hist.c"
static Histent gethist(int ev ) 
{ 
  Histent ret ;

  {
  {
#line 2255
  ret = quietgethist(ev);
  }
#line 2256
  if (! ret) {
    {
#line 2257
    herrflush();
#line 2258
    zerr("no such event: %d", ev);
    }
  }
#line 2260
  return (ret);
}
}
#line 2264 "/tmp/zsh-5.4.2/Src/hist.c"
static char *getargs(Histent elist , int arg1 , int arg2 ) 
{ 
  short *words ;
  int pos1 ;
  int pos2 ;
  int nwords ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 2267
  words = elist->words;
#line 2268
  nwords = elist->nwords;
#line 2270
  if (arg2 < arg1) {
    {
#line 2272
    herrflush();
#line 2273
    zerr("no such word in event");
    }
#line 2274
    return ((char *)((void *)0));
  } else
#line 2270
  if (arg1 >= nwords) {
    {
#line 2272
    herrflush();
#line 2273
    zerr("no such word in event");
    }
#line 2274
    return ((char *)((void *)0));
  } else
#line 2270
  if (arg2 >= nwords) {
    {
#line 2272
    herrflush();
#line 2273
    zerr("no such word in event");
    }
#line 2274
    return ((char *)((void *)0));
  }
#line 2278
  if (arg1 == 0) {
#line 2278
    if (arg2 == nwords - 1) {
      {
#line 2279
      tmp = dupstring((char const   *)elist->node.nam);
      }
#line 2279
      return (tmp);
    }
  }
#line 2281
  pos1 = (int )*(words + 2 * arg1);
#line 2282
  pos2 = (int )*(words + (2 * arg2 + 1));
#line 2287
  if (pos1 < 0) {
    {
#line 2288
    herrflush();
#line 2289
    zerr("history event too long, can\'t index requested words");
    }
#line 2290
    return ((char *)((void *)0));
  } else
#line 2287
  if (pos1 < arg1) {
    {
#line 2288
    herrflush();
#line 2289
    zerr("history event too long, can\'t index requested words");
    }
#line 2290
    return ((char *)((void *)0));
  } else
#line 2287
  if (pos2 < 0) {
    {
#line 2288
    herrflush();
#line 2289
    zerr("history event too long, can\'t index requested words");
    }
#line 2290
    return ((char *)((void *)0));
  } else
#line 2287
  if (pos2 < arg2) {
    {
#line 2288
    herrflush();
#line 2289
    zerr("history event too long, can\'t index requested words");
    }
#line 2290
    return ((char *)((void *)0));
  }
  {
#line 2292
  tmp___0 = dupstrpfx((char const   *)(elist->node.nam + pos1), pos2 - pos1);
  }
#line 2292
  return (tmp___0);
}
}
#line 2296 "/tmp/zsh-5.4.2/Src/hist.c"
static int quote(char **tr ) 
{ 
  char *ptr___0 ;
  char *rptr ;
  char **str ;
  int len ;
  int inquotes ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 2299
  str = tr;
#line 2300
  len = 3;
#line 2301
  inquotes = 0;
#line 2303
  ptr___0 = *str;
  {
#line 2303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2303
    if (! *ptr___0) {
#line 2303
      goto while_break;
    }
#line 2304
    if ((int )*ptr___0 == 39) {
#line 2305
      len += 3;
#line 2306
      if (! inquotes) {
#line 2307
        inquotes = 1;
      } else {
#line 2309
        inquotes = 0;
      }
    } else
#line 2310
    if ((int )typtab[(unsigned char )*ptr___0] & (1 << 3)) {
#line 2310
      if (! inquotes) {
#line 2310
        if ((int )*(ptr___0 + -1) != 92) {
#line 2311
          len += 2;
        }
      }
    }
#line 2303
    ptr___0 ++;
#line 2303
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2312
  ptr___0 = *str;
#line 2313
  tmp = zhalloc((size_t )len);
#line 2313
  rptr = (char *)tmp;
#line 2313
  *str = rptr;
#line 2314
  tmp___0 = rptr;
#line 2314
  rptr ++;
#line 2314
  *tmp___0 = (char )'\'';
  }
  {
#line 2315
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2315
    if (! *ptr___0) {
#line 2315
      goto while_break___0;
    }
#line 2316
    if ((int )*ptr___0 == 39) {
#line 2317
      if (! inquotes) {
#line 2318
        inquotes = 1;
      } else {
#line 2320
        inquotes = 0;
      }
#line 2321
      tmp___1 = rptr;
#line 2321
      rptr ++;
#line 2321
      *tmp___1 = (char )'\'';
#line 2322
      tmp___2 = rptr;
#line 2322
      rptr ++;
#line 2322
      *tmp___2 = (char )'\\';
#line 2323
      tmp___3 = rptr;
#line 2323
      rptr ++;
#line 2323
      *tmp___3 = (char )'\'';
#line 2324
      tmp___4 = rptr;
#line 2324
      rptr ++;
#line 2324
      *tmp___4 = (char )'\'';
    } else
#line 2325
    if ((int )typtab[(unsigned char )*ptr___0] & (1 << 3)) {
#line 2325
      if (! inquotes) {
#line 2325
        if ((int )*(ptr___0 + -1) != 92) {
#line 2326
          tmp___5 = rptr;
#line 2326
          rptr ++;
#line 2326
          *tmp___5 = (char )'\'';
#line 2327
          tmp___6 = rptr;
#line 2327
          rptr ++;
#line 2327
          *tmp___6 = *ptr___0;
#line 2328
          tmp___7 = rptr;
#line 2328
          rptr ++;
#line 2328
          *tmp___7 = (char )'\'';
        } else {
#line 2330
          tmp___8 = rptr;
#line 2330
          rptr ++;
#line 2330
          *tmp___8 = *ptr___0;
        }
      } else {
#line 2330
        tmp___8 = rptr;
#line 2330
        rptr ++;
#line 2330
        *tmp___8 = *ptr___0;
      }
    } else {
#line 2330
      tmp___8 = rptr;
#line 2330
      rptr ++;
#line 2330
      *tmp___8 = *ptr___0;
    }
#line 2315
    ptr___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2331
  tmp___9 = rptr;
#line 2331
  rptr ++;
#line 2331
  *tmp___9 = (char )'\'';
#line 2332
  tmp___10 = rptr;
#line 2332
  rptr ++;
#line 2332
  *tmp___10 = (char)0;
#line 2333
  return (0);
}
}
#line 2337 "/tmp/zsh-5.4.2/Src/hist.c"
static int quotebreak(char **tr ) 
{ 
  char *ptr___0 ;
  char *rptr ;
  char **str ;
  int len ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 2340
  str = tr;
#line 2341
  len = 3;
#line 2343
  ptr___0 = *str;
  {
#line 2343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2343
    if (! *ptr___0) {
#line 2343
      goto while_break;
    }
#line 2344
    if ((int )*ptr___0 == 39) {
#line 2345
      len += 3;
    } else
#line 2346
    if ((int )typtab[(unsigned char )*ptr___0] & (1 << 3)) {
#line 2347
      len += 2;
    }
#line 2343
    ptr___0 ++;
#line 2343
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2348
  ptr___0 = *str;
#line 2349
  tmp = zhalloc((size_t )len);
#line 2349
  rptr = (char *)tmp;
#line 2349
  *str = rptr;
#line 2350
  tmp___0 = rptr;
#line 2350
  rptr ++;
#line 2350
  *tmp___0 = (char )'\'';
  }
  {
#line 2351
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2351
    if (! *ptr___0) {
#line 2351
      goto while_break___0;
    }
#line 2352
    if ((int )*ptr___0 == 39) {
#line 2353
      tmp___1 = rptr;
#line 2353
      rptr ++;
#line 2353
      *tmp___1 = (char )'\'';
#line 2354
      tmp___2 = rptr;
#line 2354
      rptr ++;
#line 2354
      *tmp___2 = (char )'\\';
#line 2355
      tmp___3 = rptr;
#line 2355
      rptr ++;
#line 2355
      *tmp___3 = (char )'\'';
#line 2356
      tmp___4 = rptr;
#line 2356
      rptr ++;
#line 2356
      *tmp___4 = (char )'\'';
#line 2357
      ptr___0 ++;
    } else
#line 2358
    if ((int )typtab[(unsigned char )*ptr___0] & (1 << 3)) {
#line 2359
      tmp___5 = rptr;
#line 2359
      rptr ++;
#line 2359
      *tmp___5 = (char )'\'';
#line 2360
      tmp___6 = rptr;
#line 2360
      rptr ++;
#line 2360
      tmp___7 = ptr___0;
#line 2360
      ptr___0 ++;
#line 2360
      *tmp___6 = *tmp___7;
#line 2361
      tmp___8 = rptr;
#line 2361
      rptr ++;
#line 2361
      *tmp___8 = (char )'\'';
    } else {
#line 2363
      tmp___9 = rptr;
#line 2363
      rptr ++;
#line 2363
      tmp___10 = ptr___0;
#line 2363
      ptr___0 ++;
#line 2363
      *tmp___9 = *tmp___10;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2364
  tmp___11 = rptr;
#line 2364
  rptr ++;
#line 2364
  *tmp___11 = (char )'\'';
#line 2365
  tmp___12 = rptr;
#line 2365
  rptr ++;
#line 2365
  *tmp___12 = (char )'\000';
#line 2366
  return (0);
}
}
#line 2400 "/tmp/zsh-5.4.2/Src/hist.c"
static char *hdynread2(int stop ) 
{ 
  int bsiz ;
  int ct ;
  int c ;
  char *buf___7 ;
  void *tmp ;
  char *ptr___0 ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 2403
  bsiz = 256;
#line 2403
  ct = 0;
#line 2404
  tmp = zalloc((size_t )bsiz);
#line 2404
  buf___7 = (char *)tmp;
#line 2406
  ptr___0 = buf___7;
  }
  {
#line 2407
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2407
    c = ingetc();
    }
#line 2407
    if (c != stop) {
#line 2407
      if (c != 10) {
#line 2407
        if (! (! lexstop)) {
#line 2407
          goto while_break;
        }
      } else {
#line 2407
        goto while_break;
      }
    } else {
#line 2407
      goto while_break;
    }
#line 2408
    if (c == 92) {
      {
#line 2409
      c = ingetc();
      }
    }
#line 2410
    tmp___0 = ptr___0;
#line 2410
    ptr___0 ++;
#line 2410
    *tmp___0 = (char )c;
#line 2411
    ct ++;
#line 2411
    if (ct == bsiz) {
      {
#line 2412
      bsiz *= 2;
#line 2412
      tmp___1 = realloc((void *)buf___7, (size_t )bsiz);
#line 2412
      buf___7 = (char *)tmp___1;
#line 2413
      ptr___0 = buf___7 + ct;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2416
  *ptr___0 = (char)0;
#line 2417
  if (c == 10) {
    {
#line 2418
    inungetc('\n');
    }
  }
#line 2419
  return (buf___7);
}
}
#line 2423 "/tmp/zsh-5.4.2/Src/hist.c"
void inithist(void) 
{ 


  {
  {
#line 2426
  createhisttable();
  }
#line 2427
  return;
}
}
#line 2430 "/tmp/zsh-5.4.2/Src/hist.c"
void resizehistents(void) 
{ 


  {
#line 2433
  if (histlinect > histsiz) {
    {
#line 2436
    putoldhistentryontop((short)0);
#line 2437
    freehistnode(& hist_ring->node);
    }
    {
#line 2438
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2438
      if (! (histlinect > histsiz)) {
#line 2438
        goto while_break;
      }
      {
#line 2439
      putoldhistentryontop((short)1);
#line 2440
      freehistnode(& hist_ring->node);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2443
  return;
}
}
#line 2445 "/tmp/zsh-5.4.2/Src/hist.c"
static int readhistline(int start , char **bufp , int *bufsiz , FILE *in ) 
{ 
  char *buf___7 ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 2448
  buf___7 = *bufp;
#line 2449
  tmp___5 = fgets((char */* __restrict  */)(buf___7 + start), *bufsiz - start, (FILE */* __restrict  */)in);
  }
#line 2449
  if (tmp___5) {
    {
#line 2450
    tmp = strlen((char const   *)(buf___7 + start));
#line 2450
    len = (int )((size_t )start + tmp);
    }
#line 2451
    if (len == start) {
#line 2452
      return (-1);
    }
#line 2453
    if ((int )*(buf___7 + (len - 1)) != 10) {
      {
#line 2454
      tmp___2 = feof(in);
      }
#line 2454
      if (! tmp___2) {
#line 2455
        if (len < *bufsiz - 1) {
#line 2456
          return (-1);
        }
        {
#line 2457
        tmp___0 = zrealloc((void *)buf___7, (size_t )(2 * *bufsiz));
#line 2457
        *bufp = (char *)tmp___0;
#line 2458
        *bufsiz = 2 * *bufsiz;
#line 2459
        tmp___1 = readhistline(len, bufp, bufsiz, in);
        }
#line 2459
        return (tmp___1);
      }
    } else {
#line 2463
      *(buf___7 + (len - 1)) = (char )'\000';
#line 2464
      if (len > 1) {
#line 2464
        if ((int )*(buf___7 + (len - 2)) == 92) {
          {
#line 2465
          len --;
#line 2465
          *(buf___7 + (len - 1)) = (char )'\n';
#line 2466
          tmp___4 = feof(in);
          }
#line 2466
          if (! tmp___4) {
            {
#line 2467
            tmp___3 = readhistline(len, bufp, bufsiz, in);
            }
#line 2467
            return (tmp___3);
          }
        }
      }
    }
#line 2470
    return (len);
  }
#line 2472
  return (0);
}
}
#line 2476 "/tmp/zsh-5.4.2/Src/hist.c"
void readhistfile(char *fn___0 , int err , int readflags ) 
{ 
  char *buf___7 ;
  char *start ;
  FILE *in ;
  Histent he ;
  time_t stim ;
  time_t ftim ;
  time_t tim ;
  time_t tmp ;
  off_t fpos ;
  short *words ;
  struct stat sb ;
  int nwordpos ;
  int nwords ;
  int bufsiz ;
  int searching ;
  int newflags ;
  int l ;
  int ret ;
  int uselex ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *pt ;
  int remeta ;
  int tmp___7 ;
  time_t tmp___8 ;
  time_t tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 2479
  start = (char *)((void *)0);
#line 2482
  tmp = time((time_t *)((void *)0));
#line 2482
  tim = tmp;
  }
#line 2489
  if (! fn___0) {
    {
#line 2489
    fn___0 = getsparam((char *)"HISTFILE");
    }
#line 2489
    if (! fn___0) {
#line 2490
      return;
    }
  }
  {
#line 2491
  tmp___0 = unmeta((char const   *)fn___0);
#line 2491
  tmp___1 = stat((char const   */* __restrict  */)tmp___0, (struct stat */* __restrict  */)(& sb));
  }
#line 2491
  if (tmp___1 < 0) {
#line 2493
    return;
  } else
#line 2491
  if (sb.st_size == 0L) {
#line 2493
    return;
  }
#line 2494
  if (readflags & 16) {
#line 2495
    if (lasthist.fsiz == sb.st_size) {
#line 2495
      if (lasthist.mtim == sb.st_mtim.tv_sec) {
#line 2497
        return;
      } else {
#line 2495
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 2495
      tmp___2 = lockhistfile(fn___0, 0);
      }
#line 2495
      if (tmp___2) {
#line 2497
        return;
      }
    }
#line 2498
    lasthist.fsiz = sb.st_size;
#line 2499
    lasthist.mtim = sb.st_mtim.tv_sec;
  } else {
    {
#line 2500
    ret = lockhistfile(fn___0, 1);
    }
#line 2500
    if (ret) {
#line 2501
      if (ret == 2) {
        {
#line 2502
        tmp___3 = __errno_location();
#line 2502
        zwarn("locking failed for %s: %e: reading anyway", fn___0, *tmp___3);
        }
      } else {
        {
#line 2504
        tmp___4 = __errno_location();
#line 2504
        zerr("locking failed for %s: %e", fn___0, *tmp___4);
        }
#line 2505
        return;
      }
    }
  }
  {
#line 2508
  tmp___12 = unmeta((char const   *)fn___0);
#line 2508
  in = fopen((char const   */* __restrict  */)tmp___12, (char const   */* __restrict  */)"r");
  }
#line 2508
  if (in) {
    {
#line 2509
    nwords = 64;
#line 2510
    tmp___5 = zalloc((unsigned long )nwords * sizeof(short ));
#line 2510
    words = (short *)tmp___5;
#line 2511
    bufsiz = 1024;
#line 2512
    tmp___6 = zalloc((size_t )bufsiz);
#line 2512
    buf___7 = (char *)tmp___6;
#line 2514
    pushheap();
    }
#line 2515
    if (readflags & 16) {
#line 2515
      if (lasthist.text) {
#line 2516
        if (lasthist.fpos < lasthist.fsiz) {
          {
#line 2517
          fseeko(in, lasthist.fpos, 0);
#line 2518
          searching = 1;
          }
        } else {
#line 2521
          histfile_linect = (zlong )0;
#line 2522
          searching = -1;
        }
      } else {
#line 2525
        searching = 0;
      }
    } else {
#line 2525
      searching = 0;
    }
#line 2527
    newflags = 6;
#line 2528
    if (readflags & 16) {
#line 2529
      newflags |= 16;
    }
#line 2530
    if (readflags & 2) {
#line 2532
      newflags |= 1;
    } else
#line 2530
    if (hist_ignore_all_dups) {
#line 2530
      if (newflags & hist_skip_flags) {
#line 2532
        newflags |= 1;
      }
    }
    {
#line 2533
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2533
      fpos = ftello(in);
#line 2533
      l = readhistline(0, & buf___7, & bufsiz, in);
      }
#line 2533
      if (! l) {
#line 2533
        goto while_break;
      }
#line 2535
      remeta = 0;
#line 2537
      if (l < 0) {
        {
#line 2538
        zerr("corrupt history file %s", fn___0);
        }
#line 2539
        goto while_break;
      }
#line 2553
      pt = buf___7;
      {
#line 2553
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2553
        if (! *pt) {
#line 2553
          goto while_break___0;
        }
#line 2554
        if ((int )*pt == -125) {
#line 2554
          if (*(pt + 1)) {
#line 2555
            pt ++;
          } else {
#line 2554
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 2556
        if ((int )typtab[(unsigned char )*pt] & (1 << 12)) {
#line 2557
          remeta = 1;
#line 2558
          goto while_break___0;
        }
#line 2553
        pt ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2561
      if (remeta) {
        {
#line 2562
        unmetafy(buf___7, & remeta);
#line 2563
        pt = metafy(buf___7, remeta, 1);
        }
      } else {
#line 2565
        pt = buf___7;
      }
#line 2568
      if ((int )*pt == 58) {
        {
#line 2569
        pt ++;
#line 2570
        stim = zstrtol((char const   *)pt, (char **)((void *)0), 0);
        }
        {
#line 2571
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2571
          if ((int )*pt != 58) {
#line 2571
            if (! *pt) {
#line 2571
              goto while_break___1;
            }
          } else {
#line 2571
            goto while_break___1;
          }
#line 2571
          pt ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2572
        if (*pt) {
          {
#line 2573
          pt ++;
#line 2574
          ftim = zstrtol((char const   *)pt, (char **)((void *)0), 0);
          }
          {
#line 2575
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2575
            if ((int )*pt != 59) {
#line 2575
              if (! *pt) {
#line 2575
                goto while_break___2;
              }
            } else {
#line 2575
              goto while_break___2;
            }
#line 2575
            pt ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2576
          if (*pt) {
#line 2577
            pt ++;
          }
        } else {
#line 2579
          ftim = stim;
        }
      } else {
#line 2581
        if ((int )*pt == 92) {
#line 2581
          if ((int )*(pt + 1) == 58) {
#line 2582
            pt ++;
          }
        }
#line 2583
        ftim = (time_t )0;
#line 2583
        stim = ftim;
      }
#line 2586
      if (searching) {
#line 2587
        if (searching > 0) {
#line 2588
          if (stim == lasthist.stim) {
            {
#line 2588
            tmp___7 = histstrcmp((char const   *)pt, (char const   *)lasthist.text);
            }
#line 2588
            if (tmp___7 == 0) {
#line 2590
              searching = 0;
            } else {
              {
#line 2592
              fseeko(in, (__off_t )0, 0);
#line 2593
              histfile_linect = (zlong )0;
#line 2594
              searching = -1;
              }
            }
          } else {
            {
#line 2592
            fseeko(in, (__off_t )0, 0);
#line 2593
            histfile_linect = (zlong )0;
#line 2594
            searching = -1;
            }
          }
#line 2596
          goto while_continue;
        } else
#line 2598
        if (stim < lasthist.stim) {
#line 2599
          histfile_linect ++;
#line 2600
          goto while_continue;
        }
#line 2602
        searching = 0;
      }
#line 2605
      if (readflags & 32768) {
#line 2606
        histfile_linect ++;
#line 2607
        lasthist.fpos = fpos;
#line 2608
        lasthist.stim = stim;
      }
      {
#line 2611
      he = prepnexthistent();
#line 2612
      he->node.nam = ztrdup((char const   *)pt);
#line 2613
      he->node.flags = newflags;
#line 2614
      tmp___9 = stim;
#line 2614
      he->stim = tmp___9;
      }
#line 2614
      if (tmp___9 == 0L) {
#line 2615
        tmp___8 = tim;
#line 2615
        he->ftim = tmp___8;
#line 2615
        he->stim = tmp___8;
      } else
#line 2616
      if (ftim < stim) {
#line 2617
        he->ftim = stim + ftim;
      } else {
#line 2619
        he->ftim = ftim;
      }
#line 2624
      start = pt;
#line 2625
      if (opts[79]) {
#line 2625
        if (! (readflags & 16)) {
#line 2625
          tmp___10 = 1;
        } else {
#line 2625
          tmp___10 = 0;
        }
      } else {
#line 2625
        tmp___10 = 0;
      }
      {
#line 2625
      uselex = tmp___10;
#line 2626
      histsplitwords(pt, & words, & nwords, & nwordpos, uselex);
#line 2628
      he->nwords = nwordpos / 2;
      }
#line 2629
      if (he->nwords) {
        {
#line 2630
        tmp___11 = zalloc((unsigned long )nwordpos * sizeof(short ));
#line 2630
        he->words = (short *)tmp___11;
#line 2631
        memcpy((void */* __restrict  */)he->words, (void const   */* __restrict  */)words,
               (unsigned long )nwordpos * sizeof(short ));
        }
      } else {
#line 2633
        he->words = (short *)((void *)0);
      }
      {
#line 2634
      addhistnode(histtab, he->node.nam, (void *)he);
      }
#line 2635
      if (he->node.flags & 8) {
        {
#line 2636
        freehistnode(& he->node);
#line 2637
        curhist --;
        }
      }
#line 2643
      if (uselex) {
        {
#line 2644
        freeheap();
        }
      } else
#line 2643
      if (remeta) {
        {
#line 2644
        freeheap();
        }
      }
#line 2645
      if (errflag & 2) {
#line 2646
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2648
    if (start) {
#line 2648
      if (readflags & 32768) {
        {
#line 2649
        zsfree(lasthist.text);
#line 2650
        lasthist.text = ztrdup((char const   *)start);
        }
      }
    }
    {
#line 2652
    zfree((void *)words, (int )((unsigned long )nwords * sizeof(short )));
#line 2653
    zfree((void *)buf___7, bufsiz);
#line 2655
    popheap();
#line 2656
    fclose(in);
    }
  } else
#line 2657
  if (err) {
    {
#line 2658
    zerr("can\'t read history file %s", fn___0);
    }
  }
  {
#line 2660
  unlockhistfile(fn___0);
  }
#line 2662
  if (zleactive) {
    {
#line 2663
    zleentry(8, curhist);
    }
  }
#line 2664
  return;
}
}
#line 2667 "/tmp/zsh-5.4.2/Src/hist.c"
static int flock_fd  =    -1;
#line 2674 "/tmp/zsh-5.4.2/Src/hist.c"
static int flockhistfile(char *fn___0 , int keep_trying ) 
{ 
  struct flock lck ;
  long sleep_us ;
  time_t end_time ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  time_t tmp___3 ;
  time_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2678
  sleep_us = 65536L;
#line 2681
  if (flock_fd >= 0) {
#line 2682
    return (0);
  }
  {
#line 2684
  tmp___2 = unmeta((char const   *)fn___0);
#line 2684
  flock_fd = open((char const   *)tmp___2, 258);
  }
#line 2684
  if (flock_fd < 0) {
    {
#line 2685
    tmp___1 = __errno_location();
    }
#line 2685
    if (*tmp___1 == 2) {
#line 2685
      tmp___0 = 0;
    } else {
#line 2685
      tmp___0 = 2;
    }
#line 2685
    return (tmp___0);
  }
  {
#line 2687
  lck.l_type = (short)1;
#line 2688
  lck.l_whence = (short)0;
#line 2689
  lck.l_start = (__off_t )0;
#line 2690
  lck.l_len = (__off_t )0;
#line 2695
  tmp___3 = time((time_t *)((void *)0));
#line 2695
  end_time = tmp___3 + 10L;
  }
  {
#line 2696
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2696
    tmp___6 = fcntl(flock_fd, 7, & lck);
    }
#line 2696
    if (! (tmp___6 == -1)) {
#line 2696
      goto while_break;
    }
#line 2697
    if (! keep_trying) {
      {
#line 2703
      close(flock_fd);
#line 2704
      flock_fd = -1;
      }
#line 2705
      return (1);
    } else {
      {
#line 2697
      tmp___4 = time((time_t *)((void *)0));
      }
#line 2697
      if (tmp___4 >= end_time) {
        {
#line 2703
        close(flock_fd);
#line 2704
        flock_fd = -1;
        }
#line 2705
        return (1);
      } else {
        {
#line 2697
        tmp___5 = zsleep_random(sleep_us, end_time);
        }
#line 2697
        if (! tmp___5) {
          {
#line 2703
          close(flock_fd);
#line 2704
          flock_fd = -1;
          }
#line 2705
          return (1);
        }
      }
    }
#line 2707
    sleep_us <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 2710
  return (0);
}
}
#line 2715 "/tmp/zsh-5.4.2/Src/hist.c"
void savehistfile(char *fn___0 , int err , int writeflags ) 
{ 
  char *t ;
  char *tmpfile___0 ;
  char *start ;
  FILE *out ;
  Histent he ;
  zlong xcurhist ;
  int extended_history ;
  int ret ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int fd ;
  char *tmp___3 ;
  int tmp___4 ;
  FILE *tmp___5 ;
  int fd___0 ;
  char *tmp___6 ;
  int tmp___7 ;
  FILE *tmp___8 ;
  char *tmp___9 ;
  struct stat sb ;
  int old_exists ;
  char *tmp___10 ;
  int tmp___11 ;
  uid_t euid ;
  __uid_t tmp___12 ;
  int fd___1 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *history_ignore ;
  Patprog histpat ;
  int count_backslashes ;
  char *tmp___20 ;
  int tmp___21 ;
  long tmp___22 ;
  struct stat sb___0 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int remember_histactive ;
  int *tmp___28 ;
  int *tmp___29 ;

  {
#line 2718
  start = (char *)((void *)0);
#line 2721
  xcurhist = curhist - (zlong )(! (! (histactive & 1)));
#line 2722
  extended_history = (int )opts[54];
#line 2725
  if (! opts[93]) {
#line 2727
    return;
  } else
#line 2725
  if (savehistsiz <= 0L) {
#line 2727
    return;
  } else
#line 2725
  if (! hist_ring) {
#line 2727
    return;
  } else
#line 2725
  if (! fn___0) {
    {
#line 2725
    fn___0 = getsparam((char *)"HISTFILE");
    }
#line 2725
    if (! fn___0) {
#line 2727
      return;
    }
  }
#line 2728
  if (writeflags & 16) {
    {
#line 2729
    he = gethistent(lasthist.next_write_ev, 1);
    }
    {
#line 2730
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2730
      if (he) {
#line 2730
        if (! (he->node.flags & 2)) {
#line 2730
          goto while_break;
        }
      } else {
#line 2730
        goto while_break;
      }
      {
#line 2731
      lasthist.next_write_ev = he->histnum + 1L;
#line 2732
      he = down_histent(he);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2734
    if (! he) {
#line 2735
      return;
    } else {
      {
#line 2734
      tmp = lockhistfile(fn___0, 0);
      }
#line 2734
      if (tmp) {
#line 2735
        return;
      }
    }
#line 2736
    if (histfile_linect > savehistsiz + savehistsiz / 5L) {
#line 2737
      writeflags &= -17;
    }
  } else {
    {
#line 2740
    tmp___1 = lockhistfile(fn___0, 1);
    }
#line 2740
    if (tmp___1) {
      {
#line 2741
      tmp___0 = __errno_location();
#line 2741
      zerr("locking failed for %s: %e", fn___0, *tmp___0);
      }
#line 2742
      return;
    }
#line 2744
    he = hist_ring->down;
  }
#line 2746
  if (writeflags & 32768) {
#line 2747
    if (opts[6]) {
#line 2749
      writeflags |= 3;
    } else
#line 2747
    if (opts[91]) {
#line 2749
      writeflags |= 3;
    } else
#line 2747
    if (opts[92]) {
#line 2749
      writeflags |= 3;
    } else
#line 2747
    if (opts[157]) {
#line 2749
      writeflags |= 3;
    } else {
#line 2751
      histfile_linect = (zlong )0;
    }
#line 2752
    if (opts[84]) {
#line 2753
      writeflags |= 4;
    }
#line 2754
    if (opts[157]) {
#line 2755
      extended_history = 1;
    }
  }
  {
#line 2757
  tmp___2 = __errno_location();
#line 2757
  *tmp___2 = 0;
  }
#line 2758
  if (writeflags & 1) {
    {
#line 2759
    tmp___3 = unmeta((char const   *)fn___0);
#line 2759
    tmp___4 = open((char const   *)tmp___3, 1345, 384);
#line 2759
    fd = tmp___4;
#line 2760
    tmpfile___0 = (char *)((void *)0);
    }
#line 2761
    if (fd >= 0) {
      {
#line 2761
      tmp___5 = fdopen(fd, "a");
#line 2761
      out = tmp___5;
      }
    } else {
#line 2761
      out = (FILE *)((void *)0);
    }
  } else
#line 2762
  if (! opts[83]) {
    {
#line 2763
    tmp___6 = unmeta((char const   *)fn___0);
#line 2763
    tmp___7 = open((char const   *)tmp___6, 833, 384);
#line 2763
    fd___0 = tmp___7;
#line 2764
    tmpfile___0 = (char *)((void *)0);
    }
#line 2765
    if (fd___0 >= 0) {
      {
#line 2765
      tmp___8 = fdopen(fd___0, "w");
#line 2765
      out = tmp___8;
      }
    } else {
#line 2765
      out = (FILE *)((void *)0);
    }
  } else {
    {
#line 2767
    tmp___9 = unmeta((char const   *)fn___0);
#line 2767
    tmpfile___0 = bicat((char const   *)tmp___9, ".new");
#line 2768
    tmp___18 = unlink((char const   *)tmpfile___0);
    }
#line 2768
    if (tmp___18 < 0) {
      {
#line 2768
      tmp___19 = __errno_location();
      }
#line 2768
      if (*tmp___19 != 2) {
#line 2769
        out = (FILE *)((void *)0);
      } else {
#line 2768
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 2772
      tmp___10 = unmeta((char const   *)fn___0);
#line 2772
      tmp___11 = stat((char const   */* __restrict  */)tmp___10, (struct stat */* __restrict  */)(& sb));
#line 2772
      old_exists = tmp___11 == 0;
#line 2773
      tmp___12 = geteuid();
#line 2773
      euid = tmp___12;
      }
#line 2775
      if (old_exists) {
#line 2775
        if (euid) {
#line 2775
          if (sb.st_uid != euid) {
            {
#line 2780
            free((void *)tmpfile___0);
#line 2781
            tmpfile___0 = (char *)((void *)0);
            }
#line 2782
            if (err) {
#line 2783
              if (opts[6]) {
                {
#line 2785
                zerr("rewriting %s would change its ownership -- skipped", fn___0);
                }
              } else
#line 2783
              if (opts[91]) {
                {
#line 2785
                zerr("rewriting %s would change its ownership -- skipped", fn___0);
                }
              } else
#line 2783
              if (opts[92]) {
                {
#line 2785
                zerr("rewriting %s would change its ownership -- skipped", fn___0);
                }
              } else
#line 2783
              if (opts[157]) {
                {
#line 2785
                zerr("rewriting %s would change its ownership -- skipped", fn___0);
                }
              } else {
                {
#line 2787
                zerr("rewriting %s would change its ownership -- history not saved",
                     fn___0);
                }
              }
#line 2788
              err = 0;
            }
#line 2790
            out = (FILE *)((void *)0);
          } else {
#line 2775
            goto _L___0;
          }
        } else {
#line 2775
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 2792
        tmp___13 = open((char const   *)tmpfile___0, 193, 384);
#line 2792
        fd___1 = tmp___13;
        }
#line 2793
        if (fd___1 >= 0) {
          {
#line 2794
          out = fdopen(fd___1, "w");
          }
#line 2795
          if (! out) {
            {
#line 2796
            close(fd___1);
            }
          }
        } else {
#line 2798
          out = (FILE *)((void *)0);
        }
      }
#line 2802
      if (old_exists) {
#line 2802
        if (out) {
          {
#line 2804
          tmp___14 = fileno(out);
#line 2804
          tmp___15 = fchown(tmp___14, sb.st_uid, sb.st_gid);
#line 2806
          tmp___16 = fileno(out);
#line 2806
          tmp___17 = fchmod(tmp___16, sb.st_mode);
          }
        }
      }
    }
  }
#line 2811
  if (out) {
    {
#line 2813
    histpat = (Patprog )((void *)0);
#line 2815
    pushheap();
#line 2817
    history_ignore = getsparam((char *)"HISTORY_IGNORE");
    }
#line 2817
    if ((unsigned long )history_ignore != (unsigned long )((void *)0)) {
      {
#line 2818
      history_ignore = dupstring((char const   *)history_ignore);
#line 2818
      tokenize(history_ignore);
#line 2819
      remnulargs(history_ignore);
#line 2820
      histpat = patcompile(history_ignore, 0, (char **)((void *)0));
      }
    }
#line 2823
    ret = 0;
    {
#line 2824
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2824
      if (he) {
#line 2824
        if (! (he->histnum <= xcurhist)) {
#line 2824
          goto while_break___0;
        }
      } else {
#line 2824
        goto while_break___0;
      }
#line 2825
      count_backslashes = 0;
#line 2827
      if (writeflags & 4) {
#line 2827
        if (he->node.flags & 8) {
#line 2830
          goto __Cont;
        } else {
#line 2827
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 2827
      if (writeflags & 8) {
#line 2827
        if (he->node.flags & 16) {
#line 2830
          goto __Cont;
        } else {
#line 2827
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 2827
      if (he->node.flags & 32) {
#line 2830
        goto __Cont;
      }
#line 2831
      if (histpat) {
        {
#line 2831
        tmp___20 = metafy(he->node.nam, -1, 6);
#line 2831
        tmp___21 = pattry(histpat, tmp___20);
        }
#line 2831
        if (tmp___21) {
#line 2833
          goto __Cont;
        }
      }
#line 2835
      if (writeflags & 2) {
#line 2836
        if (he->node.flags & 66) {
#line 2837
          goto __Cont;
        }
#line 2838
        he->node.flags |= 2;
#line 2839
        if (writeflags & 32768) {
#line 2840
          lasthist.next_write_ev = he->histnum + 1L;
        }
      }
#line 2842
      if (writeflags & 32768) {
        {
#line 2843
        lasthist.fpos = ftello(out);
#line 2844
        lasthist.stim = he->stim;
#line 2845
        histfile_linect ++;
        }
      }
#line 2847
      start = he->node.nam;
#line 2847
      t = start;
#line 2848
      if (extended_history) {
#line 2849
        if (he->ftim) {
#line 2849
          tmp___22 = he->ftim - he->stim;
        } else {
#line 2849
          tmp___22 = 0L;
        }
        {
#line 2849
        ret = fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)": %ld:%ld;",
                      he->stim, tmp___22);
        }
      } else
#line 2851
      if ((int )*t == 58) {
        {
#line 2852
        ret = fputc('\\', out);
        }
      }
      {
#line 2854
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2854
        if (ret >= 0) {
#line 2854
          if (! *t) {
#line 2854
            goto while_break___1;
          }
        } else {
#line 2854
          goto while_break___1;
        }
#line 2855
        if ((int )*t == 10) {
          {
#line 2856
          ret = fputc('\\', out);
          }
#line 2856
          if (ret < 0) {
#line 2857
            goto while_break___1;
          }
        }
#line 2858
        if ((int )*t == 92) {
#line 2859
          count_backslashes ++;
        } else {
#line 2861
          count_backslashes = 0;
        }
        {
#line 2862
        ret = fputc((int )*t, out);
        }
#line 2862
        if (ret < 0) {
#line 2863
          goto while_break___1;
        }
#line 2854
        t ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2865
      if (ret < 0) {
#line 2866
        goto while_break___0;
      }
#line 2867
      if (count_backslashes) {
#line 2867
        if (count_backslashes % 2 == 0) {
          {
#line 2868
          ret = fputc(' ', out);
          }
#line 2868
          if (ret < 0) {
#line 2869
            goto while_break___0;
          }
        }
      }
#line 2870
      if (ret < 0) {
#line 2871
        goto while_break___0;
      } else {
        {
#line 2870
        ret = fputc('\n', out);
        }
#line 2870
        if (ret < 0) {
#line 2871
          goto while_break___0;
        }
      }
      __Cont: /* CIL Label */ 
      {
#line 2824
      he = down_histent(he);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2873
    if (ret >= 0) {
#line 2873
      if (start) {
#line 2873
        if (writeflags & 32768) {
          {
#line 2875
          ret = fflush(out);
          }
#line 2875
          if (ret >= 0) {
            {
#line 2876
            tmp___23 = fileno(out);
#line 2876
            tmp___24 = fstat(tmp___23, & sb___0);
            }
#line 2876
            if (tmp___24 == 0) {
#line 2877
              lasthist.fsiz = sb___0.st_size;
#line 2878
              lasthist.mtim = sb___0.st_mtim.tv_sec;
            }
            {
#line 2880
            zsfree(lasthist.text);
#line 2881
            lasthist.text = ztrdup((char const   *)start);
            }
          }
        }
      }
    }
    {
#line 2884
    tmp___25 = fclose(out);
    }
#line 2884
    if (tmp___25 < 0) {
#line 2884
      if (ret >= 0) {
#line 2885
        ret = -1;
      }
    }
#line 2886
    if (ret >= 0) {
#line 2887
      if (tmpfile___0) {
        {
#line 2888
        tmp___26 = unmeta((char const   *)fn___0);
#line 2888
        tmp___27 = rename((char const   *)tmpfile___0, (char const   *)tmp___26);
        }
#line 2888
        if (tmp___27 < 0) {
          {
#line 2889
          zerr("can\'t rename %s.new to $HISTFILE", fn___0);
#line 2890
          ret = -1;
#line 2891
          err = 0;
          }
        } else
#line 2896
        if (flock_fd >= 0) {
          {
#line 2897
          close(flock_fd);
#line 2898
          flock_fd = -1;
          }
        }
      }
#line 2904
      if (ret >= 0) {
#line 2904
        if (writeflags & 2) {
#line 2904
          if (! (writeflags & 48)) {
            {
#line 2906
            remember_histactive = histactive;
#line 2909
            histactive = 0;
#line 2911
            pushhiststack((char *)((void *)0), savehistsiz, savehistsiz, -1);
#line 2913
            hist_ignore_all_dups |= (int )opts[84];
#line 2914
            readhistfile(fn___0, err, 0);
#line 2915
            hist_ignore_all_dups = (int )opts[76];
            }
#line 2916
            if (histlinect) {
              {
#line 2917
              savehistfile(fn___0, err, 0);
              }
            }
            {
#line 2919
            pophiststack();
#line 2920
            histactive = remember_histactive;
            }
          }
        }
      }
    }
    {
#line 2924
    popheap();
    }
  } else {
#line 2926
    ret = -1;
  }
#line 2928
  if (ret < 0) {
#line 2928
    if (err) {
#line 2929
      if (tmpfile___0) {
        {
#line 2930
        tmp___28 = __errno_location();
#line 2930
        zerr("failed to write history file %s.new: %e", fn___0, *tmp___28);
        }
      } else {
        {
#line 2932
        tmp___29 = __errno_location();
#line 2932
        zerr("failed to write history file %s: %e", fn___0, *tmp___29);
        }
      }
    }
  }
#line 2934
  if (tmpfile___0) {
    {
#line 2935
    free((void *)tmpfile___0);
    }
  }
  {
#line 2937
  unlockhistfile(fn___0);
  }
#line 2938
  return;
}
}
#line 2940 "/tmp/zsh-5.4.2/Src/hist.c"
static int lockhistct  ;
#line 2942 "/tmp/zsh-5.4.2/Src/hist.c"
static int checklocktime(char *lockfile , long *sleep_usp , time_t then ) 
{ 
  time_t now ;
  time_t tmp ;
  int *tmp___0 ;

  {
  {
#line 2945
  tmp = time((time_t *)((void *)0));
#line 2945
  now = tmp;
  }
#line 2947
  if (now + 10L < then) {
    {
#line 2949
    tmp___0 = __errno_location();
#line 2949
    *tmp___0 = 17;
    }
#line 2950
    return (-1);
  }
#line 2953
  if (now - then < 10L) {
    {
#line 2963
    zsleep_random(*sleep_usp, then + 10L);
#line 2964
    *sleep_usp <<= 1;
    }
  } else {
    {
#line 2966
    unlink((char const   *)lockfile);
    }
  }
#line 2968
  return (0);
}
}
#line 2977 "/tmp/zsh-5.4.2/Src/hist.c"
int lockhistfile(char *fn___0 , int keep_trying ) 
{ 
  int ct ;
  int ret ;
  long sleep_us ;
  struct stat sb ;
  int fd ;
  char *lockfile ;
  char pidbuf[32] ;
  char *lnk ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2980
  ct = lockhistct;
#line 2981
  ret = 0;
#line 2982
  sleep_us = 65536L;
#line 2984
  if (! fn___0) {
    {
#line 2984
    fn___0 = getsparam((char *)"HISTFILE");
    }
#line 2984
    if (! fn___0) {
#line 2985
      return (1);
    }
  }
#line 2987
  tmp___6 = lockhistct;
#line 2987
  lockhistct ++;
#line 2987
  if (! tmp___6) {
#line 3000
    if (opts[74]) {
      {
#line 3001
      tmp = flockhistfile(fn___0, keep_trying);
      }
#line 3001
      return (tmp);
    }
    {
#line 3004
    tmp___0 = unmeta((char const   *)fn___0);
#line 3004
    lockfile = bicat((char const   *)tmp___0, ".LOCK");
#line 3009
    sprintf((char */* __restrict  */)(pidbuf), (char const   */* __restrict  */)"/pid-%ld/host-",
            mypid);
#line 3010
    lnk = getsparam((char *)"HOST");
    }
#line 3011
    if (lnk) {
#line 3011
      tmp___1 = (char const   *)lnk;
    } else {
#line 3011
      tmp___1 = "";
    }
    {
#line 3011
    lnk = bicat((char const   *)(pidbuf), tmp___1);
    }
    {
#line 3013
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3013
      fd = symlink((char const   *)lnk, (char const   *)lockfile);
      }
#line 3013
      if (! (fd < 0)) {
#line 3013
        goto while_break;
      }
      {
#line 3014
      tmp___2 = __errno_location();
      }
#line 3014
      if (*tmp___2 != 17) {
#line 3015
        ret = 2;
#line 3016
        goto while_break;
      } else
#line 3017
      if (! keep_trying) {
#line 3018
        ret = 1;
#line 3019
        goto while_break;
      }
      {
#line 3021
      tmp___4 = lstat((char const   */* __restrict  */)lockfile, (struct stat */* __restrict  */)(& sb));
      }
#line 3021
      if (tmp___4 < 0) {
        {
#line 3022
        tmp___3 = __errno_location();
        }
#line 3022
        if (*tmp___3 == 2) {
#line 3023
          goto while_continue;
        }
#line 3024
        goto while_break;
      }
      {
#line 3026
      tmp___5 = checklocktime(lockfile, & sleep_us, sb.st_mtim.tv_sec);
      }
#line 3026
      if (tmp___5 < 0) {
#line 3027
        ret = 1;
#line 3028
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3031
    if (fd < 0) {
#line 3032
      lockhistct --;
    }
    {
#line 3033
    free((void *)lnk);
#line 3098
    free((void *)lockfile);
    }
  }
#line 3101
  if (ct == lockhistct) {
#line 3103
    if (flock_fd >= 0) {
      {
#line 3104
      close(flock_fd);
#line 3105
      flock_fd = -1;
      }
    }
#line 3109
    return (ret);
  }
#line 3111
  return (0);
}
}
#line 3119 "/tmp/zsh-5.4.2/Src/hist.c"
void unlockhistfile(char *fn___0 ) 
{ 
  char *lockfile ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 3122
  if (! fn___0) {
    {
#line 3122
    fn___0 = getsparam((char *)"HISTFILE");
    }
#line 3122
    if (! fn___0) {
#line 3123
      return;
    }
  }
#line 3124
  lockhistct --;
#line 3124
  if (lockhistct) {
#line 3125
    if (lockhistct < 0) {
#line 3126
      lockhistct = 0;
    }
  } else {
    {
#line 3130
    fn___0 = unmeta((char const   *)fn___0);
#line 3131
    tmp = strlen((char const   *)fn___0);
#line 3131
    tmp___0 = zalloc((tmp + 5UL) + 1UL);
#line 3131
    lockfile = (char *)tmp___0;
#line 3132
    sprintf((char */* __restrict  */)lockfile, (char const   */* __restrict  */)"%s.LOCK",
            fn___0);
#line 3133
    unlink((char const   *)lockfile);
#line 3134
    free((void *)lockfile);
    }
#line 3136
    if (flock_fd >= 0) {
      {
#line 3137
      close(flock_fd);
#line 3138
      flock_fd = -1;
      }
    }
  }
#line 3142
  return;
}
}
#line 3145 "/tmp/zsh-5.4.2/Src/hist.c"
int histfileIsLocked(void) 
{ 


  {
#line 3148
  return (lockhistct > 0);
}
}
#line 3180 "/tmp/zsh-5.4.2/Src/hist.c"
LinkList bufferwords(LinkList list , char *buf___7 , int *index___0 , int flags ) 
{ 
  int num ;
  int cur ;
  int got ;
  int ne ;
  int owb ;
  int owe ;
  int oadx ;
  int onc ;
  int ona ;
  int ocs ;
  int oll ;
  int forloop ;
  int rcquotes ;
  char *p ;
  char *addedspaceptr ;
  int l ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int ll ;
  int cs ;
  char *linein ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int plen ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char b[20] ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int plen___0 ;
  size_t tmp___10 ;

  {
#line 3183
  num = 0;
#line 3183
  cur = -1;
#line 3183
  got = 0;
#line 3183
  ne = noerrs;
#line 3184
  owb = wb;
#line 3184
  owe = we;
#line 3184
  oadx = addedx;
#line 3184
  onc = nocomments;
#line 3185
  ona = noaliases;
#line 3185
  ocs = zlemetacs;
#line 3185
  oll = zlemetall;
#line 3186
  forloop = 0;
#line 3186
  rcquotes = (int )opts[150];
#line 3189
  if (! list) {
    {
#line 3190
    list = newlinklist();
    }
  }
  {
#line 3197
  opts[150] = (char)0;
#line 3198
  addedx = 0;
#line 3199
  noerrs = 1;
#line 3200
  zcontext_save();
#line 3201
  lexflags = flags | 1;
#line 3205
  nocomments = ! (flags & 12);
  }
#line 3207
  if (buf___7) {
    {
#line 3208
    tmp = strlen((char const   *)buf___7);
#line 3208
    l = (int )tmp;
#line 3210
    tmp___0 = zhalloc((size_t )(l + 2));
#line 3210
    p = (char *)tmp___0;
#line 3211
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)buf___7, (size_t )l);
#line 3219
    addedspaceptr = p + l;
#line 3220
    *addedspaceptr = (char )' ';
#line 3221
    *(addedspaceptr + 1) = (char )'\000';
#line 3222
    inpush(p, 0, (Alias )((void *)0));
#line 3223
    tmp___1 = strlen((char const   *)p);
#line 3223
    zlemetall = (int )tmp___1;
#line 3224
    zlemetacs = zlemetall + 1;
    }
  } else {
    {
#line 3229
    linein = zleentry(0, & ll, & cs);
#line 3230
    zlemetall = ll + 1;
#line 3231
    zlemetacs = cs;
    }
#line 3233
    if (! isfirstln) {
#line 3233
      if (chline) {
        {
#line 3234
        tmp___2 = zhalloc((size_t )(((hptr - chline) + (long )ll) + 2L));
#line 3234
        p = (char *)tmp___2;
#line 3235
        memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)chline,
               (size_t )(hptr - chline));
#line 3236
        memcpy((void */* __restrict  */)(p + (hptr - chline)), (void const   */* __restrict  */)linein,
               (size_t )ll);
#line 3237
        addedspaceptr = (p + (hptr - chline)) + ll;
#line 3238
        *addedspaceptr = (char )' ';
#line 3239
        *(addedspaceptr + 1) = (char )'\000';
#line 3240
        inpush(p, 0, (Alias )((void *)0));
#line 3246
        zlemetall = (int )((long )zlemetall + (hptr - chline));
#line 3247
        zlemetacs = (int )((long )zlemetacs + (hptr - chline));
        }
      } else {
#line 3233
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 3249
      tmp___3 = zhalloc((size_t )(ll + 2));
#line 3249
      p = (char *)tmp___3;
#line 3250
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)linein,
             (size_t )ll);
#line 3251
      addedspaceptr = p + ll;
#line 3252
      *addedspaceptr = (char )' ';
#line 3253
      *(p + zlemetall) = (char )'\000';
#line 3254
      inpush(p, 0, (Alias )((void *)0));
      }
    }
    {
#line 3256
    zsfree(linein);
    }
  }
#line 3258
  if (zlemetacs) {
#line 3259
    zlemetacs --;
  }
  {
#line 3260
  strinbeg(0);
#line 3261
  noaliases = 1;
  }
  {
#line 3262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3263
    if (incond) {
#line 3264
      if ((unsigned int )tok != 40U) {
#line 3264
        if ((unsigned int )tok != 6U) {
#line 3264
          if ((unsigned int )tok != 8U) {
#line 3264
            if ((unsigned int )tok != 9U) {
#line 3264
              if ((unsigned int )tok != 39U) {
#line 3264
                tmp___4 = 1;
              } else {
#line 3264
                tmp___4 = 0;
              }
            } else {
#line 3264
              tmp___4 = 0;
            }
          } else {
#line 3264
            tmp___4 = 0;
          }
        } else {
#line 3264
          tmp___4 = 0;
        }
      } else {
#line 3264
        tmp___4 = 0;
      }
#line 3264
      incond = 1 + tmp___4;
    }
    {
#line 3267
    ctxtlex();
    }
#line 3268
    if ((unsigned int )tok == 37U) {
#line 3269
      goto while_break;
    } else
#line 3268
    if ((unsigned int )tok == 38U) {
#line 3269
      goto while_break;
    }
#line 3270
    if ((unsigned int )tok == 52U) {
#line 3283
      forloop = 5;
    } else {
      {
#line 3286
      if (forloop == 1) {
#line 3286
        goto case_1;
      }
#line 3293
      if (forloop == 4) {
#line 3293
        goto case_4;
      }
#line 3293
      if (forloop == 3) {
#line 3293
        goto case_4;
      }
#line 3293
      if (forloop == 2) {
#line 3293
        goto case_4;
      }
#line 3298
      goto switch_default;
      case_1: /* CIL Label */ 
#line 3287
      if ((unsigned int )tok != 29U) {
#line 3288
        forloop = 0;
      }
#line 3289
      goto switch_break;
      case_4: /* CIL Label */ 
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 3294
      if ((unsigned int )tok != 28U) {
#line 3295
        forloop = 0;
      }
#line 3296
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 3300
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 3303
    if (tokstr) {
      {
#line 3305
      if ((unsigned int )tok == 36U) {
#line 3305
        goto case_36;
      }
#line 3309
      if ((unsigned int )tok == 28U) {
#line 3309
        goto case_28;
      }
#line 3324
      goto switch_default___0;
      case_36: /* CIL Label */ 
      {
#line 3306
      p = dyncat((char const   *)tokstr, "=(");
      }
#line 3307
      goto switch_break___0;
      case_28: /* CIL Label */ 
#line 3310
      if (forloop) {
        {
#line 3312
        p = dyncat((char const   *)tokstr, ";");
        }
      } else {
        {
#line 3320
        p = zhtricat("((", (char const   *)tokstr, "))");
        }
      }
#line 3322
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 3325
      p = dupstring((char const   *)tokstr);
      }
#line 3326
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 3328
      if (*p) {
        {
#line 3329
        untokenize(p);
#line 3330
        tmp___6 = ingetptr();
        }
#line 3330
        if ((unsigned long )tmp___6 == (unsigned long )(addedspaceptr + 1)) {
          {
#line 3340
          tmp___5 = strlen((char const   *)p);
#line 3340
          plen = (int )tmp___5;
          }
#line 3341
          if (plen) {
#line 3341
            if ((int )*(p + (plen - 1)) == 32) {
#line 3341
              if (plen == 1) {
#line 3343
                *(p + (plen - 1)) = (char )'\000';
              } else
#line 3341
              if ((int )*(p + (plen - 2)) != -125) {
#line 3343
                *(p + (plen - 1)) = (char )'\000';
              }
            }
          }
        }
        {
#line 3345
        insertlinknode(list, list->list.last, (void *)p);
#line 3346
        num ++;
        }
      }
    } else
#line 3348
    if (buf___7) {
#line 3349
      if ((unsigned int )tok >= 10U) {
#line 3349
        if ((unsigned int )tok <= 24U) {
#line 3349
          if (tokfd >= 0) {
            {
#line 3352
            sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"%d%s",
                    tokfd, tokstrings[tok]);
#line 3353
            tmp___7 = dupstring((char const   *)(b));
#line 3353
            insertlinknode(list, list->list.last, (void *)tmp___7);
#line 3354
            num ++;
            }
          } else {
#line 3349
            goto _L___1;
          }
        } else {
#line 3349
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 3355
      if ((unsigned int )tok != 2U) {
        {
#line 3356
        tmp___8 = dupstring((char const   *)tokstrings[tok]);
#line 3356
        insertlinknode(list, list->list.last, (void *)tmp___8);
#line 3357
        num ++;
        }
      }
    }
#line 3360
    if (forloop) {
#line 3361
      if (forloop == 1) {
        {
#line 3366
        tmp___9 = dupstring("))");
#line 3366
        insertlinknode(list, list->list.last, (void *)tmp___9);
        }
      }
#line 3368
      forloop --;
    }
#line 3370
    if (! got) {
#line 3370
      if (! lexflags) {
#line 3371
        got = 1;
#line 3372
        cur = num - 1;
      }
    }
#line 3262
    if ((unsigned int )tok != 37U) {
#line 3262
      if ((unsigned int )tok != 38U) {
#line 3262
        if (! (! (errflag & 2))) {
#line 3262
          goto while_break;
        }
      } else {
#line 3262
        goto while_break;
      }
    } else {
#line 3262
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3375
  if (buf___7) {
#line 3375
    if ((unsigned int )tok == 38U) {
#line 3375
      if (tokstr) {
#line 3375
        if (*tokstr) {
          {
#line 3377
          p = dupstring((char const   *)tokstr);
#line 3377
          untokenize(p);
#line 3378
          tmp___10 = strlen((char const   *)p);
#line 3378
          plen___0 = (int )tmp___10;
          }
#line 3384
          if (plen___0) {
#line 3384
            if ((int )*(p + (plen___0 - 1)) == 32) {
#line 3384
              if (plen___0 == 1) {
#line 3385
                *(p + (plen___0 - 1)) = (char )'\000';
              } else
#line 3384
              if ((int )*(p + (plen___0 - 2)) != -125) {
#line 3385
                *(p + (plen___0 - 1)) = (char )'\000';
              }
            }
          }
          {
#line 3386
          insertlinknode(list, list->list.last, (void *)p);
#line 3387
          num ++;
          }
        }
      }
    }
  }
#line 3389
  if (cur < 0) {
#line 3389
    if (num) {
#line 3390
      cur = num - 1;
    }
  }
  {
#line 3391
  noaliases = ona;
#line 3392
  strinend();
#line 3393
  inpop();
#line 3394
  errflag &= -2;
#line 3395
  nocomments = onc;
#line 3396
  noerrs = ne;
#line 3397
  zcontext_restore();
#line 3398
  zlemetacs = ocs;
#line 3399
  zlemetall = oll;
#line 3400
  wb = owb;
#line 3401
  we = owe;
#line 3402
  addedx = oadx;
#line 3403
  opts[150] = (char )rcquotes;
  }
#line 3405
  if (index___0) {
#line 3406
    *index___0 = cur;
  }
#line 3408
  return (list);
}
}
#line 3436 "/tmp/zsh-5.4.2/Src/hist.c"
void histsplitwords(char *lineptr , short **wordsp , int *nwordsp , int *nwordposp ,
                    int uselex ) 
{ 
  int nwords ;
  int nwordpos ;
  short *words ;
  char *start ;
  LinkList wordlist ;
  LinkNode wordnode ;
  int nwords_max ;
  int tmp ;
  void *tmp___0 ;
  char *word ;
  char *lptr ;
  char *wptr ;
  int loop_next ;
  int skipping ;
  int len ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int bad ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 3440
  nwords = *nwordsp;
#line 3440
  nwordpos = 0;
#line 3441
  words = *wordsp;
#line 3442
  start = lineptr;
#line 3444
  if (uselex) {
    {
#line 3449
    wordlist = bufferwords((LinkList )((void *)0), lineptr, (int *)((void *)0), 4);
    }
#line 3451
    if (errflag) {
#line 3452
      return;
    }
    {
#line 3453
    tmp = countlinknodes(wordlist);
#line 3453
    nwords_max = 2 * tmp;
    }
#line 3454
    if (nwords_max > nwords) {
      {
#line 3455
      nwords = nwords_max;
#line 3455
      *nwordsp = nwords;
#line 3456
      tmp___0 = zrealloc((void *)words, (unsigned long )nwords * sizeof(short ));
#line 3456
      words = (short *)tmp___0;
#line 3456
      *wordsp = words;
      }
    }
#line 3458
    wordnode = wordlist->list.first;
    {
#line 3458
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3458
      if (! wordnode) {
#line 3458
        goto while_break;
      }
#line 3461
      word = (char *)wordnode->dat;
#line 3462
      wptr = word;
#line 3463
      loop_next = 0;
      {
#line 3466
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3471
        if ((int )typtab[(unsigned char )*lineptr] & (1 << 3)) {
#line 3472
          lineptr ++;
        } else
#line 3473
        if ((int )*(lineptr + 0) == 92) {
#line 3473
          if ((int )*(lineptr + 1) == 10) {
#line 3478
            lineptr += 2;
          } else {
#line 3480
            goto while_break___0;
          }
        } else {
#line 3480
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3482
      lptr = lineptr;
      {
#line 3494
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 3495
        skipping = 0;
#line 3496
        tmp___5 = strpfx((char const   *)wptr, (char const   *)lptr);
        }
#line 3496
        if (tmp___5) {
          {
#line 3502
          tmp___1 = strcmp((char const   *)wptr, ";");
          }
#line 3502
          if (! tmp___1) {
            {
#line 3502
            tmp___2 = strpfx(";;", (char const   *)lptr);
            }
#line 3502
            if (tmp___2) {
#line 3508
              loop_next = 2;
#line 3509
              goto while_break___1;
            }
          }
          {
#line 3511
          tmp___3 = strlen((char const   *)wptr);
#line 3511
          len = (int )tmp___3;
#line 3512
          lptr += len;
#line 3513
          wptr += len;
          }
        } else {
          {
#line 3519
          bad = 0;
#line 3523
          tmp___4 = strcmp((char const   *)wptr, ";");
          }
#line 3523
          if (! tmp___4) {
#line 3525
            loop_next = 2;
#line 3526
            goto while_break___1;
          }
          {
#line 3528
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 3528
            if (! *lptr) {
#line 3528
              goto while_break___2;
            }
#line 3529
            if (! *wptr) {
#line 3534
              bad = 1;
#line 3535
              loop_next = 1;
#line 3536
              goto while_break___2;
            }
#line 3541
            if ((int )*lptr == (int )*wptr) {
#line 3541
              goto _L;
            } else
#line 3541
            if ((int )*lptr == 33) {
#line 3541
              if ((int )*wptr == 124) {
                _L: /* CIL Label */ 
#line 3543
                lptr ++;
#line 3544
                wptr ++;
#line 3544
                if (! *wptr) {
#line 3545
                  goto while_break___2;
                }
              } else {
#line 3541
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 3546
            if ((int )*(lptr + 0) == 92) {
#line 3546
              if ((int )*(lptr + 1) == 10) {
#line 3554
                lptr += 2;
#line 3555
                skipping = 1;
#line 3556
                goto while_break___2;
              } else {
#line 3558
                bad = 1;
#line 3559
                loop_next = 1;
#line 3560
                goto while_break___2;
              }
            } else {
#line 3558
              bad = 1;
#line 3559
              loop_next = 1;
#line 3560
              goto while_break___2;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 3563
          if (bad) {
#line 3569
            lineptr = start;
#line 3570
            nwordpos = 0;
#line 3571
            uselex = 0;
#line 3572
            loop_next = 1;
          }
        }
#line 3494
        if (! skipping) {
#line 3494
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3576
      if (loop_next) {
#line 3577
        if (loop_next == 1) {
#line 3578
          goto while_break;
        }
#line 3579
        goto __Cont;
      }
#line 3582
      tmp___6 = nwordpos;
#line 3582
      nwordpos ++;
#line 3582
      *(words + tmp___6) = (short )(lineptr - start);
#line 3583
      tmp___7 = nwordpos;
#line 3583
      nwordpos ++;
#line 3583
      *(words + tmp___7) = (short )(lptr - start);
#line 3586
      lineptr = lptr;
      __Cont: /* CIL Label */ 
#line 3458
      wordnode = wordnode->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3589
  if (! uselex) {
    {
#line 3590
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 3591
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3592
        if ((int )typtab[(unsigned char )*lineptr] & (1 << 3)) {
#line 3593
          lineptr ++;
        } else
#line 3594
        if ((int )*(lineptr + 0) == 92) {
#line 3594
          if ((int )*(lineptr + 1) == 10) {
#line 3595
            lineptr += 2;
          } else {
#line 3597
            goto while_break___4;
          }
        } else {
#line 3597
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 3599
      if (*lineptr) {
#line 3600
        if (nwordpos >= nwords) {
          {
#line 3601
          nwords += 64;
#line 3601
          *nwordsp = nwords;
#line 3602
          tmp___8 = zrealloc((void *)words, (unsigned long )nwords * sizeof(*words));
#line 3602
          words = (short *)tmp___8;
#line 3602
          *wordsp = words;
          }
        }
#line 3605
        tmp___9 = nwordpos;
#line 3605
        nwordpos ++;
#line 3605
        *(words + tmp___9) = (short )(lineptr - start);
        {
#line 3606
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 3606
          if (*lineptr) {
#line 3606
            if (! (! ((int )typtab[(unsigned char )*lineptr] & (1 << 3)))) {
#line 3606
              goto while_break___5;
            }
          } else {
#line 3606
            goto while_break___5;
          }
#line 3607
          lineptr ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 3608
        tmp___10 = nwordpos;
#line 3608
        nwordpos ++;
#line 3608
        *(words + tmp___10) = (short )(lineptr - start);
      }
#line 3590
      if (! *lineptr) {
#line 3590
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 3613
  *nwordposp = nwordpos;
#line 3614
  return;
}
}
#line 3625 "/tmp/zsh-5.4.2/Src/hist.c"
int pushhiststack(char *hf , zlong hs , zlong shs , int level ) 
{ 
  struct histsave *h ;
  int curline_in_ring ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 3629
  if (histactive & 1) {
#line 3629
    if ((unsigned long )hist_ring == (unsigned long )(& curline)) {
#line 3629
      tmp = 1;
    } else {
#line 3629
      tmp = 0;
    }
  } else {
#line 3629
    tmp = 0;
  }
#line 3629
  curline_in_ring = tmp;
#line 3631
  if (histsave_stack_pos == histsave_stack_size) {
    {
#line 3632
    histsave_stack_size += 5;
#line 3633
    tmp___0 = zrealloc((void *)histsave_stack, (unsigned long )histsave_stack_size * sizeof(struct histsave ));
#line 3633
    histsave_stack = (struct histsave *)tmp___0;
    }
  }
#line 3637
  if (curline_in_ring) {
    {
#line 3638
    unlinkcurline();
    }
  }
#line 3640
  tmp___1 = histsave_stack_pos;
#line 3640
  histsave_stack_pos ++;
#line 3640
  h = histsave_stack + tmp___1;
#line 3642
  h->lasthist = lasthist;
#line 3643
  if (hf) {
    {
#line 3644
    tmp___2 = getsparam((char *)"HISTFILE");
#line 3644
    h->histfile = tmp___2;
    }
#line 3644
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 3644
      if (*(h->histfile)) {
        {
#line 3645
        h->histfile = ztrdup((char const   *)h->histfile);
        }
      } else {
#line 3647
        h->histfile = (char *)"";
      }
    } else {
#line 3647
      h->histfile = (char *)"";
    }
  } else {
#line 3649
    h->histfile = (char *)((void *)0);
  }
  {
#line 3650
  h->histtab = histtab;
#line 3651
  h->hist_ring = hist_ring;
#line 3652
  h->curhist = curhist;
#line 3653
  h->histlinect = histlinect;
#line 3654
  h->histsiz = histsiz;
#line 3655
  h->savehistsiz = savehistsiz;
#line 3656
  h->locallevel = level;
#line 3658
  memset((void *)(& lasthist), 0, sizeof(lasthist));
  }
#line 3659
  if (hf) {
#line 3660
    if (*hf) {
      {
#line 3661
      tmp___3 = ztrdup((char const   *)hf);
#line 3661
      setsparam((char *)"HISTFILE", tmp___3);
      }
    } else {
      {
#line 3663
      unsetparam((char *)"HISTFILE");
      }
    }
  }
#line 3665
  hist_ring = (Histent )((void *)0);
#line 3666
  histlinect = (zlong )0;
#line 3666
  curhist = histlinect;
#line 3667
  if (zleactive) {
    {
#line 3668
    zleentry(8, curhist);
    }
  }
  {
#line 3669
  histsiz = hs;
#line 3670
  savehistsiz = shs;
#line 3671
  inithist();
  }
#line 3673
  if (curline_in_ring) {
    {
#line 3674
    linkcurline();
    }
  }
#line 3676
  return (histsave_stack_pos);
}
}
#line 3681 "/tmp/zsh-5.4.2/Src/hist.c"
int pophiststack(void) 
{ 
  struct histsave *h ;
  int curline_in_ring ;
  int tmp ;

  {
#line 3685
  if (histactive & 1) {
#line 3685
    if ((unsigned long )hist_ring == (unsigned long )(& curline)) {
#line 3685
      tmp = 1;
    } else {
#line 3685
      tmp = 0;
    }
  } else {
#line 3685
    tmp = 0;
  }
#line 3685
  curline_in_ring = tmp;
#line 3687
  if (histsave_stack_pos == 0) {
#line 3688
    return (0);
  }
#line 3690
  if (curline_in_ring) {
    {
#line 3691
    unlinkcurline();
    }
  }
  {
#line 3693
  deletehashtable(histtab);
#line 3694
  zsfree(lasthist.text);
#line 3696
  histsave_stack_pos --;
#line 3696
  h = histsave_stack + histsave_stack_pos;
#line 3698
  lasthist = h->lasthist;
  }
#line 3699
  if (h->histfile) {
#line 3700
    if (*(h->histfile)) {
      {
#line 3701
      setsparam((char *)"HISTFILE", h->histfile);
      }
    } else {
      {
#line 3703
      unsetparam((char *)"HISTFILE");
      }
    }
  }
#line 3705
  histtab = h->histtab;
#line 3706
  hist_ring = h->hist_ring;
#line 3707
  curhist = h->curhist;
#line 3708
  if (zleactive) {
    {
#line 3709
    zleentry(8, curhist);
    }
  }
#line 3710
  histlinect = h->histlinect;
#line 3711
  histsiz = h->histsiz;
#line 3712
  savehistsiz = h->savehistsiz;
#line 3714
  if (curline_in_ring) {
    {
#line 3715
    linkcurline();
    }
  }
#line 3717
  return (histsave_stack_pos + 1);
}
}
#line 3727 "/tmp/zsh-5.4.2/Src/hist.c"
int saveandpophiststack(int pop_through , int writeflags ) 
{ 


  {
#line 3730
  if (pop_through <= 0) {
#line 3731
    pop_through += histsave_stack_pos + 1;
#line 3732
    if (pop_through <= 0) {
#line 3733
      pop_through = 1;
    }
  }
  {
#line 3735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3735
    if (pop_through > 1) {
#line 3735
      if (! ((histsave_stack + (pop_through - 2))->locallevel > locallevel)) {
#line 3735
        goto while_break;
      }
    } else {
#line 3735
      goto while_break;
    }
#line 3737
    pop_through --;
  }
  while_break: /* CIL Label */ ;
  }
#line 3738
  if (histsave_stack_pos < pop_through) {
#line 3739
    return (0);
  }
  {
#line 3740
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3741
    if (! nohistsave) {
      {
#line 3742
      savehistfile((char *)((void *)0), 1, writeflags);
      }
    }
    {
#line 3743
    pophiststack();
    }
#line 3740
    if (! (histsave_stack_pos >= pop_through)) {
#line 3740
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3745
  return (1);
}
}
#line 71 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 77
extern void endpwent(void) ;
#line 83
extern struct passwd *getpwent(void) ;
#line 5 "./hashnameddir.epro"
HashTable nameddirtab  ;
#line 2 "./hashnameddir.pro"
static void emptynameddirtable(HashTable ht ) ;
#line 3
static void fillnameddirtable(HashTable ht  __attribute__((__unused__)) ) ;
#line 4
static void addnameddirnode(HashTable ht , char *nam , void *nodeptr ) ;
#line 5
static HashNode removenameddirnode(HashTable ht , char const   *nam ) ;
#line 6
static void freenameddirnode(HashNode hn ) ;
#line 7
static void printnameddirnode(HashNode hn , int printflags ) ;
#line 64 "/tmp/zsh-5.4.2/Src/hashnameddir.c"
static int allusersadded  ;
#line 69 "/tmp/zsh-5.4.2/Src/hashnameddir.c"
void createnameddirtable(void) 
{ 


  {
  {
#line 72
  nameddirtab = newhashtable(201, "nameddirtab", (void (*)(HashTable  ))((void *)0));
#line 74
  nameddirtab->hash = & hasher;
#line 75
  nameddirtab->emptytable = & emptynameddirtable;
#line 76
  nameddirtab->filltable = & fillnameddirtable;
#line 77
  nameddirtab->cmpnodes = (int (*)(char const   * , char const   * ))(& strcmp);
#line 78
  nameddirtab->addnode = & addnameddirnode;
#line 79
  nameddirtab->getnode = & gethashnode;
#line 80
  nameddirtab->getnode2 = & gethashnode2;
#line 81
  nameddirtab->removenode = & removenameddirnode;
#line 82
  nameddirtab->disablenode = (void (*)(HashNode  , int  ))((void *)0);
#line 83
  nameddirtab->enablenode = (void (*)(HashNode  , int  ))((void *)0);
#line 84
  nameddirtab->freenode = & freenameddirnode;
#line 85
  nameddirtab->printnode = & printnameddirnode;
#line 87
  allusersadded = 0;
#line 88
  finddir((char *)((void *)0));
  }
#line 89
  return;
}
}
#line 94 "/tmp/zsh-5.4.2/Src/hashnameddir.c"
static void emptynameddirtable(HashTable ht ) 
{ 


  {
  {
#line 97
  emptyhashtable(ht);
#line 98
  allusersadded = 0;
#line 99
  finddir((char *)((void *)0));
  }
#line 100
  return;
}
}
#line 152 "/tmp/zsh-5.4.2/Src/hashnameddir.c"
static void fillnameddirtable(HashTable ht  __attribute__((__unused__)) ) 
{ 
  struct passwd *pw ;

  {
#line 155
  if (! allusersadded) {
    {
#line 224
    setpwent();
    }
    {
#line 228
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 228
      pw = getpwent();
      }
#line 228
      if (pw) {
#line 228
        if (! (! errflag)) {
#line 228
          goto while_break;
        }
      } else {
#line 228
        goto while_break;
      }
      {
#line 229
      adduserdir(pw->pw_name, pw->pw_dir, 1 << 1, 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 231
    endpwent();
#line 234
    allusersadded = 1;
    }
  }
#line 236
  return;
}
}
#line 243 "/tmp/zsh-5.4.2/Src/hashnameddir.c"
static void addnameddirnode(HashTable ht , char *nam , void *nodeptr ) 
{ 
  Nameddir nd ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 246
  nd = (Nameddir )nodeptr;
#line 248
  tmp = strlen((char const   *)nd->dir);
#line 248
  tmp___0 = strlen((char const   *)nam);
#line 248
  nd->diff = (int )(tmp - tmp___0);
#line 249
  finddir((char *)((void *)0));
#line 250
  addhashnode(ht, nam, nodeptr);
  }
#line 251
  return;
}
}
#line 257 "/tmp/zsh-5.4.2/Src/hashnameddir.c"
static HashNode removenameddirnode(HashTable ht , char const   *nam ) 
{ 
  HashNode hn ;
  HashNode tmp ;

  {
  {
#line 260
  tmp = removehashnode(ht, nam);
#line 260
  hn = tmp;
  }
#line 262
  if (hn) {
    {
#line 263
    finddir((char *)((void *)0));
    }
  }
#line 264
  return (hn);
}
}
#line 270 "/tmp/zsh-5.4.2/Src/hashnameddir.c"
static void freenameddirnode(HashNode hn ) 
{ 
  Nameddir nd ;

  {
  {
#line 273
  nd = (Nameddir )hn;
#line 275
  zsfree(nd->node.nam);
#line 276
  zsfree(nd->dir);
#line 277
  zfree((void *)nd, (int )sizeof(struct nameddir ));
  }
#line 278
  return;
}
}
#line 283 "/tmp/zsh-5.4.2/Src/hashnameddir.c"
static void printnameddirnode(HashNode hn , int printflags ) 
{ 
  Nameddir nd ;

  {
#line 286
  nd = (Nameddir )hn;
#line 288
  if (printflags & 1) {
    {
#line 289
    zputs((char const   *)nd->node.nam, stdout);
#line 290
    putchar('\n');
    }
#line 291
    return;
  }
#line 294
  if (printflags & (1 << 2)) {
    {
#line 295
    printf((char const   */* __restrict  */)"hash -d ");
    }
#line 297
    if ((int )*(nd->node.nam + 0) == 45) {
      {
#line 298
      printf((char const   */* __restrict  */)"-- ");
      }
    }
  }
  {
#line 301
  quotedzputs((char const   *)nd->node.nam, stdout);
#line 302
  putchar('=');
#line 303
  quotedzputs((char const   *)nd->dir, stdout);
#line 304
  putchar('\n');
  }
#line 305
  return;
}
}
#line 40 "./exec.epro"
int isrelative(char *s ) ;
#line 21 "./hashtable.epro"
HashTable___0 cmdnamtab  ;
#line 22 "./hashtable.epro"
char **pathchecked  ;
#line 24
void hashdir(char **dirp ) ;
#line 25 "./hashtable.epro"
HashTable___0 shfunctab  ;
#line 27
int scanmatchshfunc(Patprog pprog , int sorted , int flags1 , int flags2 , void (*scanfunc)(HashNode  ,
                                                                                            int  ) ,
                    int scanflags , int expand ) ;
#line 28
int scanshfunc(int sorted , int flags1 , int flags2 , void (*scanfunc)(HashNode  ,
                                                                       int  ) , int scanflags ,
               int expand ) ;
#line 29
void printshfuncexpand(HashNode hn , int printflags , int expand ) ;
#line 30
char *getshfuncfile(Shfunc shf ) ;
#line 31 "./hashtable.epro"
HashTable___0 reswdtab  ;
#line 33 "./hashtable.epro"
HashTable___0 aliastab  ;
#line 34 "./hashtable.epro"
HashTable___0 sufaliastab  ;
#line 35
void createaliastable(HashTable___0 ht ) ;
#line 37
Alias createaliasnode(char *txt , int flags ) ;
#line 39
unsigned int histhasher(char const   *str ) ;
#line 40
void emptyhisttable(HashTable___0 ht ) ;
#line 2 "./hashtable.pro"
static int hnamcmp(void const   *ap , void const   *bp ) ;
#line 3
static void expandhashtable(HashTable___0 ht ) ;
#line 4
static void resizehashtable(HashTable___0 ht , int newsize ) ;
#line 8
static void emptycmdnamtable(HashTable___0 ht ) ;
#line 9
static void fillcmdnamtable(HashTable___0 ht  __attribute__((__unused__)) ) ;
#line 10
static void freecmdnamnode(HashNode hn ) ;
#line 11
static void printcmdnamnode(HashNode hn , int printflags ) ;
#line 12
static HashNode removeshfuncnode(HashTable___0 ht  __attribute__((__unused__)) , char const   *nam ) ;
#line 13
static void disableshfuncnode(HashNode hn , int flags  __attribute__((__unused__)) ) ;
#line 14
static void enableshfuncnode(HashNode hn , int flags  __attribute__((__unused__)) ) ;
#line 15
static void freeshfuncnode(HashNode hn ) ;
#line 16
static void printshfuncnode(HashNode hn , int printflags ) ;
#line 17
static void printreswdnode(HashNode hn , int printflags ) ;
#line 18
static void freealiasnode(HashNode hn ) ;
#line 19
static void printaliasnode(HashNode hn , int printflags ) ;
#line 80 "/tmp/zsh-5.4.2/Src/hashtable.c"
unsigned int hasher(char const   *str ) 
{ 
  unsigned int hashval ;
  unsigned int c ;
  char const   *tmp ;

  {
#line 83
  hashval = 0U;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    tmp = str;
#line 85
    str ++;
#line 85
    c = (unsigned int )*((unsigned char *)tmp);
#line 85
    if (! c) {
#line 85
      goto while_break;
    }
#line 86
    hashval += (hashval << 5) + c;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (hashval);
}
}
#line 94 "/tmp/zsh-5.4.2/Src/hashtable.c"
HashTable___0 newhashtable(int size , char const   *name  __attribute__((__unused__)) ,
                           void (*printinfo)(HashTable___0  )  __attribute__((__unused__)) ) 
{ 
  HashTable___0 ht ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 99
  tmp = zshcalloc(sizeof(*ht));
#line 99
  ht = (HashTable___0 )tmp;
#line 111
  tmp___0 = zshcalloc((unsigned long )size * sizeof(HashNode ));
#line 111
  ht->nodes = (HashNode *)tmp___0;
#line 112
  ht->hsize = size;
#line 113
  ht->ct = 0;
#line 114
  ht->scan = (ScanStatus )((void *)0);
#line 115
  ht->scantab = (void (*)(HashTable___0  , void (*)(HashNode  , int  ) , int  ))((void *)0);
  }
#line 116
  return (ht);
}
}
#line 123 "/tmp/zsh-5.4.2/Src/hashtable.c"
void deletehashtable(HashTable___0 ht ) 
{ 


  {
  {
#line 126
  (*(ht->emptytable))(ht);
#line 138
  zfree((void *)ht->nodes, (int )((unsigned long )ht->hsize * sizeof(HashNode )));
#line 139
  zfree((void *)ht, (int )sizeof(*ht));
  }
#line 140
  return;
}
}
#line 151 "/tmp/zsh-5.4.2/Src/hashtable.c"
void addhashnode(HashTable___0 ht , char *nam , void *nodeptr ) 
{ 
  HashNode oldnode ;
  HashNode tmp ;

  {
  {
#line 154
  tmp = addhashnode2(ht, nam, nodeptr);
#line 154
  oldnode = tmp;
  }
#line 155
  if (oldnode) {
    {
#line 156
    (*(ht->freenode))(oldnode);
    }
  }
#line 157
  return;
}
}
#line 162 "/tmp/zsh-5.4.2/Src/hashtable.c"
HashNode addhashnode2(HashTable___0 ht , char *nam , void *nodeptr ) 
{ 
  unsigned int hashval ;
  HashNode hn ;
  HashNode hp ;
  HashNode hq ;
  unsigned int tmp ;
  HashNode *hashtab ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 168
  hn = (HashNode )nodeptr;
#line 169
  hn->nam = nam;
#line 171
  tmp = (*(ht->hash))((char const   *)hn->nam);
#line 171
  hashval = tmp % (unsigned int )ht->hsize;
#line 172
  hp = *(ht->nodes + hashval);
  }
#line 175
  if (! hp) {
#line 176
    hn->next = (HashNode )((void *)0);
#line 177
    *(ht->nodes + hashval) = hn;
#line 178
    (ht->ct) ++;
#line 178
    if (ht->ct >= ht->hsize * 2) {
#line 178
      if (! ht->scan) {
        {
#line 179
        expandhashtable(ht);
        }
      }
    }
#line 180
    return ((HashNode )((void *)0));
  }
  {
#line 184
  tmp___1 = (*(ht->cmpnodes))((char const   *)hp->nam, (char const   *)hn->nam);
  }
#line 184
  if (tmp___1 == 0) {
#line 185
    *(ht->nodes + hashval) = hn;
    replacing: 
#line 187
    hn->next = hp->next;
#line 188
    if (ht->scan) {
#line 189
      if ((ht->scan)->sorted) {
#line 190
        hashtab = (ht->scan)->u.s.hashtab;
#line 192
        i = (ht->scan)->u.s.ct;
        {
#line 192
        while (1) {
          while_continue: /* CIL Label */ ;
#line 192
          tmp___0 = i;
#line 192
          i --;
#line 192
          if (! tmp___0) {
#line 192
            goto while_break;
          }
#line 193
          if ((unsigned long )*(hashtab + i) == (unsigned long )hp) {
#line 194
            *(hashtab + i) = hn;
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else
#line 195
      if ((unsigned long )(ht->scan)->u.u == (unsigned long )hp) {
#line 196
        (ht->scan)->u.u = hn;
      }
    }
#line 198
    return (hp);
  }
#line 202
  hq = hp;
#line 203
  hp = hp->next;
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    if (! hp) {
#line 204
      goto while_break___0;
    }
    {
#line 205
    tmp___2 = (*(ht->cmpnodes))((char const   *)hp->nam, (char const   *)hn->nam);
    }
#line 205
    if (tmp___2 == 0) {
#line 206
      hq->next = hn;
#line 207
      goto replacing;
    }
#line 204
    hq = hp;
#line 204
    hp = hp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 212
  hn->next = *(ht->nodes + hashval);
#line 213
  *(ht->nodes + hashval) = hn;
#line 214
  (ht->ct) ++;
#line 214
  if (ht->ct >= ht->hsize * 2) {
#line 214
    if (! ht->scan) {
      {
#line 215
      expandhashtable(ht);
      }
    }
  }
#line 216
  return ((HashNode )((void *)0));
}
}
#line 225 "/tmp/zsh-5.4.2/Src/hashtable.c"
HashNode gethashnode(HashTable___0 ht , char const   *nam ) 
{ 
  unsigned int hashval ;
  HashNode hp ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 231
  tmp = (*(ht->hash))(nam);
#line 231
  hashval = tmp % (unsigned int )ht->hsize;
#line 232
  hp = *(ht->nodes + hashval);
  }
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! hp) {
#line 232
      goto while_break;
    }
    {
#line 233
    tmp___0 = (*(ht->cmpnodes))((char const   *)hp->nam, nam);
    }
#line 233
    if (tmp___0 == 0) {
#line 234
      if (hp->flags & 1) {
#line 235
        return ((HashNode )((void *)0));
      } else {
#line 237
        return (hp);
      }
    }
#line 232
    hp = hp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return ((HashNode )((void *)0));
}
}
#line 249 "/tmp/zsh-5.4.2/Src/hashtable.c"
HashNode gethashnode2(HashTable___0 ht , char const   *nam ) 
{ 
  unsigned int hashval ;
  HashNode hp ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 255
  tmp = (*(ht->hash))(nam);
#line 255
  hashval = tmp % (unsigned int )ht->hsize;
#line 256
  hp = *(ht->nodes + hashval);
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! hp) {
#line 256
      goto while_break;
    }
    {
#line 257
    tmp___0 = (*(ht->cmpnodes))((char const   *)hp->nam, nam);
    }
#line 257
    if (tmp___0 == 0) {
#line 258
      return (hp);
    }
#line 256
    hp = hp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  return ((HashNode )((void *)0));
}
}
#line 269 "/tmp/zsh-5.4.2/Src/hashtable.c"
HashNode removehashnode(HashTable___0 ht , char const   *nam ) 
{ 
  unsigned int hashval ;
  HashNode hp ;
  HashNode hq ;
  unsigned int tmp ;
  HashNode *hashtab ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 275
  tmp = (*(ht->hash))(nam);
#line 275
  hashval = tmp % (unsigned int )ht->hsize;
#line 276
  hp = *(ht->nodes + hashval);
  }
#line 279
  if (! hp) {
#line 280
    return ((HashNode )((void *)0));
  }
  {
#line 283
  tmp___1 = (*(ht->cmpnodes))((char const   *)hp->nam, nam);
  }
#line 283
  if (tmp___1 == 0) {
#line 284
    *(ht->nodes + hashval) = hp->next;
    gotit: 
#line 286
    (ht->ct) --;
#line 287
    if (ht->scan) {
#line 288
      if ((ht->scan)->sorted) {
#line 289
        hashtab = (ht->scan)->u.s.hashtab;
#line 291
        i = (ht->scan)->u.s.ct;
        {
#line 291
        while (1) {
          while_continue: /* CIL Label */ ;
#line 291
          tmp___0 = i;
#line 291
          i --;
#line 291
          if (! tmp___0) {
#line 291
            goto while_break;
          }
#line 292
          if ((unsigned long )*(hashtab + i) == (unsigned long )hp) {
#line 293
            *(hashtab + i) = (HashNode )((void *)0);
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else
#line 294
      if ((unsigned long )(ht->scan)->u.u == (unsigned long )hp) {
#line 295
        (ht->scan)->u.u = hp->next;
      }
    }
#line 297
    return (hp);
  }
#line 301
  hq = hp;
#line 302
  hp = hp->next;
  {
#line 303
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 303
    if (! hp) {
#line 303
      goto while_break___0;
    }
    {
#line 304
    tmp___2 = (*(ht->cmpnodes))((char const   *)hp->nam, nam);
    }
#line 304
    if (tmp___2 == 0) {
#line 305
      hq->next = hp->next;
#line 306
      goto gotit;
    }
#line 303
    hq = hp;
#line 303
    hp = hp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 311
  return ((HashNode )((void *)0));
}
}
#line 317 "/tmp/zsh-5.4.2/Src/hashtable.c"
void disablehashnode(HashNode hn , int flags  __attribute__((__unused__)) ) 
{ 


  {
#line 320
  hn->flags |= 1;
#line 321
  return;
}
}
#line 326 "/tmp/zsh-5.4.2/Src/hashtable.c"
void enablehashnode(HashNode hn , int flags  __attribute__((__unused__)) ) 
{ 


  {
#line 329
  hn->flags &= -2;
#line 330
  return;
}
}
#line 335 "/tmp/zsh-5.4.2/Src/hashtable.c"
static int hnamcmp(void const   *ap , void const   *bp ) 
{ 
  HashNode a ;
  HashNode b ;
  int tmp ;

  {
  {
#line 338
  a = *((HashNode *)ap);
#line 339
  b = *((HashNode *)bp);
#line 340
  tmp = ztrcmp((char const   *)a->nam, (char const   *)b->nam);
  }
#line 340
  return (tmp);
}
}
#line 367 "/tmp/zsh-5.4.2/Src/hashtable.c"
int scanmatchtable(HashTable___0 ht , Patprog pprog , int sorted , int flags1 , int flags2 ,
                   void (*scanfunc)(HashNode  , int  ) , int scanflags ) 
{ 
  int match ;
  struct scanstatus st___0 ;
  int i ;
  int ct ;
  HashNode *hnsorttab ;
  void *tmp ;
  HashNode *htp ;
  HashNode hn ;
  HashNode *tmp___0 ;
  int tmp___1 ;
  int i___0 ;
  int hsize ;
  HashNode *nodes ;
  HashNode hn___0 ;
  int tmp___2 ;

  {
#line 371
  match = 0;
#line 380
  if (! pprog) {
#line 380
    if (ht->scantab) {
      {
#line 381
      (*(ht->scantab))(ht, scanfunc, scanflags);
      }
#line 382
      return (ht->ct);
    }
  }
#line 384
  if (sorted) {
    {
#line 385
    ct = ht->ct;
#line 386
    tmp = zhalloc(sizeof(HashNode ) * (unsigned long )ct);
#line 386
    hnsorttab = (HashNode *)tmp;
#line 394
    htp = hnsorttab;
#line 394
    i = 0;
    }
    {
#line 394
    while (1) {
      while_continue: /* CIL Label */ ;
#line 394
      if (! (i < ht->hsize)) {
#line 394
        goto while_break;
      }
#line 395
      hn = *(ht->nodes + i);
      {
#line 395
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 395
        if (! hn) {
#line 395
          goto while_break___0;
        }
#line 396
        tmp___0 = htp;
#line 396
        htp ++;
#line 396
        *tmp___0 = hn;
#line 395
        hn = hn->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 394
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 397
    qsort((void *)hnsorttab, (size_t )ct, sizeof(HashNode ), & hnamcmp);
#line 399
    st___0.sorted = 1;
#line 400
    st___0.u.s.hashtab = hnsorttab;
#line 401
    st___0.u.s.ct = ct;
#line 402
    ht->scan = & st___0;
#line 404
    htp = hnsorttab;
#line 404
    i = 0;
    }
    {
#line 404
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 404
      if (! (i < ct)) {
#line 404
        goto while_break___1;
      }
#line 405
      if (! flags1) {
#line 405
        goto _L;
      } else
#line 405
      if ((*htp)->flags & flags1) {
        _L: /* CIL Label */ 
#line 405
        if (! ((*htp)->flags & flags2)) {
#line 405
          if (! pprog) {
            {
#line 408
            match ++;
#line 409
            (*scanfunc)(*htp, scanflags);
            }
          } else {
            {
#line 405
            tmp___1 = pattry(pprog, (*htp)->nam);
            }
#line 405
            if (tmp___1) {
              {
#line 408
              match ++;
#line 409
              (*scanfunc)(*htp, scanflags);
              }
            }
          }
        }
      }
#line 404
      i ++;
#line 404
      htp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 413
    ht->scan = (ScanStatus )((void *)0);
  } else {
#line 415
    hsize = ht->hsize;
#line 416
    nodes = ht->nodes;
#line 418
    st___0.sorted = 0;
#line 419
    ht->scan = & st___0;
#line 421
    i___0 = 0;
    {
#line 421
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 421
      if (! (i___0 < hsize)) {
#line 421
        goto while_break___2;
      }
#line 422
      st___0.u.u = *(nodes + i___0);
      {
#line 422
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 422
        if (! st___0.u.u) {
#line 422
          goto while_break___3;
        }
#line 423
        hn___0 = st___0.u.u;
#line 424
        st___0.u.u = (st___0.u.u)->next;
#line 425
        if (! flags1) {
#line 425
          goto _L___0;
        } else
#line 425
        if (hn___0->flags & flags1) {
          _L___0: /* CIL Label */ 
#line 425
          if (! (hn___0->flags & flags2)) {
#line 425
            if (! pprog) {
              {
#line 427
              match ++;
#line 428
              (*scanfunc)(hn___0, scanflags);
              }
            } else {
              {
#line 425
              tmp___2 = pattry(pprog, hn___0->nam);
              }
#line 425
              if (tmp___2) {
                {
#line 427
                match ++;
#line 428
                (*scanfunc)(hn___0, scanflags);
                }
              }
            }
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 421
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 432
    ht->scan = (ScanStatus )((void *)0);
  }
#line 435
  return (match);
}
}
#line 440 "/tmp/zsh-5.4.2/Src/hashtable.c"
int scanhashtable(HashTable___0 ht , int sorted , int flags1 , int flags2 , void (*scanfunc)(HashNode  ,
                                                                                             int  ) ,
                  int scanflags ) 
{ 
  int tmp ;

  {
  {
#line 444
  tmp = scanmatchtable(ht, (Patprog )((void *)0), sorted, flags1, flags2, scanfunc,
                       scanflags);
  }
#line 444
  return (tmp);
}
}
#line 452 "/tmp/zsh-5.4.2/Src/hashtable.c"
static void expandhashtable(HashTable___0 ht ) 
{ 
  struct hashnode **onodes ;
  struct hashnode **ha ;
  struct hashnode *hn ;
  struct hashnode *hp ;
  int i ;
  int osize ;
  void *tmp ;

  {
  {
#line 458
  osize = ht->hsize;
#line 459
  onodes = ht->nodes;
#line 461
  ht->hsize = osize * 4;
#line 462
  tmp = zshcalloc((unsigned long )ht->hsize * sizeof(HashNode ));
#line 462
  ht->nodes = (HashNode *)tmp;
#line 463
  ht->ct = 0;
#line 467
  i = 0;
#line 467
  ha = onodes;
  }
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    if (! (i < osize)) {
#line 467
      goto while_break;
    }
#line 468
    hn = *ha;
    {
#line 468
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 468
      if (! hn) {
#line 468
        goto while_break___0;
      }
      {
#line 469
      hp = hn->next;
#line 470
      (*(ht->addnode))(ht, hn->nam, (void *)hn);
#line 471
      hn = hp;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 467
    i ++;
#line 467
    ha ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 474
  zfree((void *)onodes, (int )((unsigned long )osize * sizeof(HashNode )));
  }
#line 475
  return;
}
}
#line 480 "/tmp/zsh-5.4.2/Src/hashtable.c"
static void resizehashtable(HashTable___0 ht , int newsize ) 
{ 
  struct hashnode **ha ;
  struct hashnode *hn ;
  struct hashnode *hp ;
  int i ;
  void *tmp ;

  {
#line 487
  ha = ht->nodes;
#line 488
  i = 0;
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 488
    if (! (i < ht->hsize)) {
#line 488
      goto while_break;
    }
#line 489
    hn = *ha;
    {
#line 489
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 489
      if (! hn) {
#line 489
        goto while_break___0;
      }
      {
#line 490
      hp = hn->next;
#line 491
      (*(ht->freenode))(hn);
#line 492
      hn = hp;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 488
    i ++;
#line 488
    ha ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 498
  if (ht->hsize != newsize) {
    {
#line 499
    zfree((void *)ht->nodes, (int )((unsigned long )ht->hsize * sizeof(HashNode )));
#line 500
    tmp = zshcalloc((unsigned long )newsize * sizeof(HashNode ));
#line 500
    ht->nodes = (HashNode *)tmp;
#line 501
    ht->hsize = newsize;
    }
  } else {
    {
#line 504
    memset((void *)ht->nodes, 0, (unsigned long )newsize * sizeof(HashNode ));
    }
  }
#line 507
  ht->ct = 0;
#line 508
  return;
}
}
#line 513 "/tmp/zsh-5.4.2/Src/hashtable.c"
void emptyhashtable(HashTable___0 ht ) 
{ 


  {
  {
#line 516
  resizehashtable(ht, ht->hsize);
  }
#line 517
  return;
}
}
#line 595 "/tmp/zsh-5.4.2/Src/hashtable.c"
void createcmdnamtable(void) 
{ 


  {
  {
#line 598
  cmdnamtab = newhashtable(201, "cmdnamtab", (void (*)(HashTable___0  ))((void *)0));
#line 600
  cmdnamtab->hash = & hasher;
#line 601
  cmdnamtab->emptytable = & emptycmdnamtable;
#line 602
  cmdnamtab->filltable = & fillcmdnamtable;
#line 603
  cmdnamtab->cmpnodes = (int (*)(char const   * , char const   * ))(& strcmp);
#line 604
  cmdnamtab->addnode = & addhashnode;
#line 605
  cmdnamtab->getnode = & gethashnode2;
#line 606
  cmdnamtab->getnode2 = & gethashnode2;
#line 607
  cmdnamtab->removenode = & removehashnode;
#line 608
  cmdnamtab->disablenode = (void (*)(HashNode  , int  ))((void *)0);
#line 609
  cmdnamtab->enablenode = (void (*)(HashNode  , int  ))((void *)0);
#line 610
  cmdnamtab->freenode = & freecmdnamnode;
#line 611
  cmdnamtab->printnode = & printcmdnamnode;
#line 613
  pathchecked = path;
  }
#line 614
  return;
}
}
#line 617 "/tmp/zsh-5.4.2/Src/hashtable.c"
static void emptycmdnamtable(HashTable___0 ht ) 
{ 


  {
  {
#line 620
  emptyhashtable(ht);
#line 621
  pathchecked = path;
  }
#line 622
  return;
}
}
#line 628 "/tmp/zsh-5.4.2/Src/hashtable.c"
void hashdir(char **dirp ) 
{ 
  Cmdnam cn ;
  DIR *dir ;
  char *fn___0 ;
  char *unmetadir ;
  char *pathbuf___0 ;
  char *pathptr ;
  int dirlen ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *fname ;
  char *tmp___2 ;
  struct stat statbuf ;
  int add___0 ;
  int dummylen ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  HashNode tmp___7 ;

  {
  {
#line 639
  tmp = isrelative(*dirp);
  }
#line 639
  if (tmp) {
#line 640
    return;
  }
  {
#line 641
  unmetadir = unmeta((char const   *)*dirp);
#line 642
  dir = opendir((char const   *)unmetadir);
  }
#line 642
  if (! dir) {
#line 643
    return;
  }
  {
#line 645
  tmp___0 = strlen((char const   *)unmetadir);
#line 645
  dirlen = (int )tmp___0;
#line 646
  tmp___1 = zalloc((size_t )((dirlen + 4096) + 2));
#line 646
  pathbuf___0 = (char *)tmp___1;
#line 647
  sprintf((char */* __restrict  */)pathbuf___0, (char const   */* __restrict  */)"%s/",
          unmetadir);
#line 648
  pathptr = (pathbuf___0 + dirlen) + 1;
  }
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 650
    fn___0 = zreaddir(dir, 1);
    }
#line 650
    if (! fn___0) {
#line 650
      goto while_break;
    }
    {
#line 651
    tmp___7 = (*(cmdnamtab->getnode))(cmdnamtab, (char const   *)fn___0);
    }
#line 651
    if (! tmp___7) {
      {
#line 652
      tmp___2 = ztrdup((char const   *)fn___0);
#line 652
      fname = tmp___2;
#line 654
      add___0 = 0;
#line 656
      unmetafy(fn___0, & dummylen);
#line 657
      tmp___5 = strlen((char const   *)fn___0);
      }
#line 657
      if (tmp___5 > 4096UL) {
#line 659
        add___0 = 1;
      } else {
        {
#line 661
        strcpy((char */* __restrict  */)pathptr, (char const   */* __restrict  */)fn___0);
        }
#line 666
        if (! opts[69]) {
#line 670
          add___0 = 1;
        } else {
          {
#line 666
          tmp___3 = access((char const   *)pathbuf___0, 1);
          }
#line 666
          if (tmp___3 == 0) {
            {
#line 666
            tmp___4 = stat((char const   */* __restrict  */)pathbuf___0, (struct stat */* __restrict  */)(& statbuf));
            }
#line 666
            if (tmp___4 == 0) {
#line 666
              if ((statbuf.st_mode & 61440U) == 32768U) {
#line 666
                if (statbuf.st_mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 670
                  add___0 = 1;
                }
              }
            }
          }
        }
      }
#line 672
      if (add___0) {
        {
#line 673
        tmp___6 = zshcalloc(sizeof(*cn));
#line 673
        cn = (Cmdnam )tmp___6;
#line 674
        cn->node.flags = 0;
#line 675
        cn->u.name = dirp;
#line 676
        (*(cmdnamtab->addnode))(cmdnamtab, fname, (void *)cn);
        }
      } else {
        {
#line 678
        zsfree(fname);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 698
  closedir(dir);
#line 699
  zfree((void *)pathbuf___0, (dirlen + 4096) + 2);
  }
#line 700
  return;
}
}
#line 706 "/tmp/zsh-5.4.2/Src/hashtable.c"
static void fillcmdnamtable(HashTable___0 ht  __attribute__((__unused__)) ) 
{ 
  char **pq ;

  {
#line 711
  pq = pathchecked;
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (! *pq) {
#line 711
      goto while_break;
    }
    {
#line 712
    hashdir(pq);
#line 711
    pq ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  pathchecked = pq;
#line 715
  return;
}
}
#line 718 "/tmp/zsh-5.4.2/Src/hashtable.c"
static void freecmdnamnode(HashNode hn ) 
{ 
  Cmdnam cn ;

  {
  {
#line 721
  cn = (Cmdnam )hn;
#line 723
  zsfree(cn->node.nam);
  }
#line 724
  if (cn->node.flags & (1 << 1)) {
    {
#line 725
    zsfree(cn->u.cmd);
    }
  }
  {
#line 727
  zfree((void *)cn, (int )sizeof(struct cmdnam ));
  }
#line 728
  return;
}
}
#line 733 "/tmp/zsh-5.4.2/Src/hashtable.c"
static void printcmdnamnode(HashNode hn , int printflags ) 
{ 
  Cmdnam cn ;
  char const   *tmp ;

  {
#line 736
  cn = (Cmdnam )hn;
#line 738
  if (printflags & (1 << 10)) {
#line 739
    if (cn->node.flags & (1 << 1)) {
#line 739
      tmp = "hashed";
    } else {
#line 739
      tmp = "command";
    }
    {
#line 739
    printf((char const   */* __restrict  */)"%s: %s\n", cn->node.nam, tmp);
    }
#line 741
    return;
  }
#line 744
  if (printflags & (1 << 6)) {
#line 744
    goto _L;
  } else
#line 744
  if (printflags & (1 << 8)) {
    _L: /* CIL Label */ 
#line 745
    if (cn->node.flags & (1 << 1)) {
      {
#line 746
      zputs((char const   *)cn->u.cmd, stdout);
#line 747
      putchar('\n');
      }
    } else {
      {
#line 749
      zputs((char const   *)*(cn->u.name), stdout);
#line 750
      putchar('/');
#line 751
      zputs((char const   *)cn->node.nam, stdout);
#line 752
      putchar('\n');
      }
    }
#line 754
    return;
  }
#line 757
  if (printflags & (1 << 7)) {
#line 758
    if (cn->node.flags & (1 << 1)) {
      {
#line 759
      mb_niceformat((char const   *)cn->node.nam, stdout, (char **)((void *)0), 0);
#line 760
      printf((char const   */* __restrict  */)" is hashed to ");
#line 761
      mb_niceformat((char const   *)cn->u.cmd, stdout, (char **)((void *)0), 0);
#line 762
      putchar('\n');
      }
    } else {
      {
#line 764
      mb_niceformat((char const   *)cn->node.nam, stdout, (char **)((void *)0), 0);
#line 765
      printf((char const   */* __restrict  */)" is ");
#line 766
      mb_niceformat((char const   *)*(cn->u.name), stdout, (char **)((void *)0), 0);
#line 767
      putchar('/');
#line 768
      mb_niceformat((char const   *)cn->node.nam, stdout, (char **)((void *)0), 0);
#line 769
      putchar('\n');
      }
    }
#line 771
    return;
  }
#line 774
  if (printflags & (1 << 2)) {
    {
#line 775
    printf((char const   */* __restrict  */)"hash ");
    }
#line 777
    if ((int )*(cn->node.nam + 0) == 45) {
      {
#line 778
      printf((char const   */* __restrict  */)"-- ");
      }
    }
  }
#line 781
  if (cn->node.flags & (1 << 1)) {
    {
#line 782
    quotedzputs((char const   *)cn->node.nam, stdout);
#line 783
    putchar('=');
#line 784
    quotedzputs((char const   *)cn->u.cmd, stdout);
#line 785
    putchar('\n');
    }
  } else {
    {
#line 787
    quotedzputs((char const   *)cn->node.nam, stdout);
#line 788
    putchar('=');
#line 789
    quotedzputs((char const   *)*(cn->u.name), stdout);
#line 790
    putchar('/');
#line 791
    quotedzputs((char const   *)cn->node.nam, stdout);
#line 792
    putchar('\n');
    }
  }
#line 794
  return;
}
}
#line 806 "/tmp/zsh-5.4.2/Src/hashtable.c"
void createshfunctable(void) 
{ 


  {
  {
#line 809
  shfunctab = newhashtable(7, "shfunctab", (void (*)(HashTable___0  ))((void *)0));
#line 811
  shfunctab->hash = & hasher;
#line 812
  shfunctab->emptytable = (void (*)(HashTable___0  ))((void *)0);
#line 813
  shfunctab->filltable = (void (*)(HashTable___0  ))((void *)0);
#line 814
  shfunctab->cmpnodes = (int (*)(char const   * , char const   * ))(& strcmp);
#line 815
  shfunctab->addnode = & addhashnode;
#line 816
  shfunctab->getnode = & gethashnode;
#line 817
  shfunctab->getnode2 = & gethashnode2;
#line 818
  shfunctab->removenode = & removeshfuncnode;
#line 819
  shfunctab->disablenode = & disableshfuncnode;
#line 820
  shfunctab->enablenode = & enableshfuncnode;
#line 821
  shfunctab->freenode = & freeshfuncnode;
#line 822
  shfunctab->printnode = & printshfuncnode;
  }
#line 823
  return;
}
}
#line 830 "/tmp/zsh-5.4.2/Src/hashtable.c"
static HashNode removeshfuncnode(HashTable___0 ht  __attribute__((__unused__)) , char const   *nam ) 
{ 
  HashNode hn ;
  int signum ;
  int tmp ;

  {
  {
#line 836
  tmp = strncmp(nam, "TRAP", (size_t )4);
  }
#line 836
  if (tmp) {
    {
#line 839
    hn = removehashnode(shfunctab, nam);
    }
  } else {
    {
#line 836
    signum = getsignum(nam + 4);
    }
#line 836
    if (signum != -1) {
      {
#line 837
      hn = removetrap(signum);
      }
    } else {
      {
#line 839
      hn = removehashnode(shfunctab, nam);
      }
    }
  }
#line 841
  return (hn);
}
}
#line 849 "/tmp/zsh-5.4.2/Src/hashtable.c"
static void disableshfuncnode(HashNode hn , int flags  __attribute__((__unused__)) ) 
{ 
  int signum ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 852
  hn->flags |= 1;
#line 853
  tmp___0 = strncmp((char const   *)hn->nam, "TRAP", (size_t )4);
  }
#line 853
  if (! tmp___0) {
    {
#line 854
    tmp = getsignum((char const   *)(hn->nam + 4));
#line 854
    signum = tmp;
    }
#line 855
    if (signum != -1) {
      {
#line 856
      sigtrapped[signum] &= ~ (1 << 2);
#line 857
      unsettrap(signum);
      }
    }
  }
#line 860
  return;
}
}
#line 867 "/tmp/zsh-5.4.2/Src/hashtable.c"
static void enableshfuncnode(HashNode hn , int flags  __attribute__((__unused__)) ) 
{ 
  Shfunc shf ;
  int signum ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 870
  shf = (Shfunc )hn;
#line 872
  shf->node.flags &= -2;
#line 873
  tmp___0 = strncmp((char const   *)shf->node.nam, "TRAP", (size_t )4);
  }
#line 873
  if (! tmp___0) {
    {
#line 874
    tmp = getsignum((char const   *)(shf->node.nam + 4));
#line 874
    signum = tmp;
    }
#line 875
    if (signum != -1) {
      {
#line 876
      settrap(signum, (Eprog )((void *)0), 1 << 2);
      }
    }
  }
#line 879
  return;
}
}
#line 882 "/tmp/zsh-5.4.2/Src/hashtable.c"
static void freeshfuncnode(HashNode hn ) 
{ 
  Shfunc shf ;

  {
  {
#line 885
  shf = (Shfunc )hn;
#line 887
  zsfree(shf->node.nam);
  }
#line 888
  if (shf->funcdef) {
    {
#line 889
    freeeprog(shf->funcdef);
    }
  }
#line 890
  if (shf->redir) {
    {
#line 891
    freeeprog(shf->redir);
    }
  }
  {
#line 892
  dircache_set(& shf->filename, (char *)((void *)0));
  }
#line 893
  if (shf->sticky) {
#line 894
    if ((shf->sticky)->n_on_opts) {
      {
#line 895
      zfree((void *)(shf->sticky)->on_opts, (int )((unsigned long )(shf->sticky)->n_on_opts * sizeof(*((shf->sticky)->on_opts))));
      }
    }
#line 897
    if ((shf->sticky)->n_off_opts) {
      {
#line 898
      zfree((void *)(shf->sticky)->off_opts, (int )((unsigned long )(shf->sticky)->n_off_opts * sizeof(*((shf->sticky)->off_opts))));
      }
    }
    {
#line 900
    zfree((void *)shf->sticky, (int )sizeof(*(shf->sticky)));
    }
  }
  {
#line 902
  zfree((void *)shf, (int )sizeof(struct shfunc ));
  }
#line 903
  return;
}
}
#line 908 "/tmp/zsh-5.4.2/Src/hashtable.c"
static void printshfuncnode(HashNode hn , int printflags ) 
{ 
  Shfunc f ;
  char *t ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *fopt ;
  int flgs[7] ;
  int fl ;

  {
#line 911
  f = (Shfunc )hn;
#line 912
  t = (char *)0;
#line 914
  if (printflags & 1) {
    {
#line 917
    zputs((char const   *)f->node.nam, stdout);
#line 918
    putchar('\n');
    }
#line 919
    return;
  } else
#line 914
  if (printflags & (1 << 8)) {
#line 914
    if (! (printflags & (1 << 9))) {
      {
#line 917
      zputs((char const   *)f->node.nam, stdout);
#line 918
      putchar('\n');
      }
#line 919
      return;
    }
  }
#line 922
  if (printflags & ((1 << 7) | (1 << 10))) {
#line 922
    if (! (printflags & (1 << 9))) {
      {
#line 924
      mb_niceformat((char const   *)f->node.nam, stdout, (char **)((void *)0), 0);
      }
#line 925
      if (printflags & (1 << 10)) {
#line 925
        tmp___0 = ": function";
      } else {
#line 925
        if (f->node.flags & (1 << 9)) {
#line 925
          tmp = " is an autoload shell function";
        } else {
#line 925
          tmp = " is a shell function";
        }
#line 925
        tmp___0 = tmp;
      }
      {
#line 925
      printf((char const   */* __restrict  */)tmp___0);
      }
#line 929
      if (printflags & (1 << 7)) {
#line 929
        if (f->filename) {
          {
#line 930
          printf((char const   */* __restrict  */)" from ");
#line 931
          quotedzputs((char const   *)f->filename, stdout);
          }
#line 932
          if (f->node.flags & (1 << 19)) {
            {
#line 933
            printf((char const   */* __restrict  */)"/");
#line 934
            quotedzputs((char const   *)f->node.nam, stdout);
            }
          }
        }
      }
      {
#line 937
      putchar('\n');
      }
#line 938
      return;
    }
  }
  {
#line 941
  quotedzputs((char const   *)f->node.nam, stdout);
  }
#line 942
  if (f->funcdef) {
#line 942
    goto _L;
  } else
#line 942
  if (f->node.flags & (1 << 9)) {
    _L: /* CIL Label */ 
    {
#line 943
    printf((char const   */* __restrict  */)" () {\n");
#line 944
    zoutputtab(stdout);
    }
#line 945
    if (f->node.flags & (1 << 9)) {
      {
#line 946
      printf((char const   */* __restrict  */)"%c undefined\n", (int )hashchar);
#line 947
      zoutputtab(stdout);
      }
    } else {
      {
#line 949
      t = getpermtext(f->funcdef, (Wordcode )((void *)0), 1);
      }
    }
#line 950
    if (f->node.flags & ((1 << 11) | (1 << 16))) {
      {
#line 951
      printf((char const   */* __restrict  */)"%c traced\n", (int )hashchar);
#line 952
      zoutputtab(stdout);
      }
    }
#line 954
    if (! t) {
      {
#line 955
      fopt = (char *)"UtTkzc";
#line 956
      flgs[0] = 1 << 13;
#line 956
      flgs[1] = 1 << 11;
#line 956
      flgs[2] = 1 << 16;
#line 956
      flgs[3] = 1 << 17;
#line 956
      flgs[4] = 1 << 18;
#line 956
      flgs[5] = 1 << 14;
#line 956
      flgs[6] = 0;
#line 962
      zputs("builtin autoload -X", stdout);
#line 963
      fl = 0;
      }
      {
#line 963
      while (1) {
        while_continue: /* CIL Label */ ;
#line 963
        if (! *(fopt + fl)) {
#line 963
          goto while_break;
        }
#line 964
        if (f->node.flags & flgs[fl]) {
          {
#line 964
          putchar((int )*(fopt + fl));
          }
        }
#line 963
        fl ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 965
      if (f->filename) {
#line 965
        if (f->node.flags & (1 << 19)) {
          {
#line 966
          putchar(' ');
#line 967
          zputs((char const   *)f->filename, stdout);
          }
        }
      }
    } else {
      {
#line 970
      zputs((char const   *)t, stdout);
#line 971
      zsfree(t);
      }
#line 972
      if ((f->funcdef)->flags & 8) {
        {
#line 973
        printf((char const   */* __restrict  */)"\n");
#line 974
        zoutputtab(stdout);
#line 975
        quotedzputs((char const   *)f->node.nam, stdout);
#line 976
        printf((char const   */* __restrict  */)" \"$@\"");
        }
      }
    }
    {
#line 979
    printf((char const   */* __restrict  */)"\n}");
    }
  } else {
    {
#line 981
    printf((char const   */* __restrict  */)" () { }");
    }
  }
#line 983
  if (f->redir) {
    {
#line 984
    t = getpermtext(f->redir, (Wordcode )((void *)0), 1);
    }
#line 985
    if (t) {
      {
#line 986
      zputs((char const   *)t, stdout);
#line 987
      zsfree(t);
      }
    }
  }
  {
#line 991
  putchar('\n');
  }
#line 992
  return;
}
}
#line 1007 "/tmp/zsh-5.4.2/Src/hashtable.c"
int scanmatchshfunc(Patprog pprog , int sorted , int flags1 , int flags2 , void (*scanfunc)(HashNode  ,
                                                                                            int  ) ,
                    int scanflags , int expand ) 
{ 
  int ret ;
  int save_expand ;

  {
  {
#line 1013
  save_expand = text_expand_tabs;
#line 1014
  text_expand_tabs = expand;
#line 1015
  ret = scanmatchtable(shfunctab, pprog, sorted, flags1, flags2, scanfunc, scanflags);
#line 1017
  text_expand_tabs = save_expand;
  }
#line 1019
  return (ret);
}
}
#line 1025 "/tmp/zsh-5.4.2/Src/hashtable.c"
int scanshfunc(int sorted , int flags1 , int flags2 , void (*scanfunc)(HashNode  ,
                                                                       int  ) , int scanflags ,
               int expand ) 
{ 
  int tmp ;

  {
  {
#line 1029
  tmp = scanmatchshfunc((Patprog )((void *)0), sorted, flags1, flags2, scanfunc, scanflags,
                        expand);
  }
#line 1029
  return (tmp);
}
}
#line 1036 "/tmp/zsh-5.4.2/Src/hashtable.c"
void printshfuncexpand(HashNode hn , int printflags , int expand ) 
{ 
  int save_expand ;

  {
  {
#line 1041
  save_expand = text_expand_tabs;
#line 1042
  text_expand_tabs = expand;
#line 1043
  (*(shfunctab->printnode))(hn, printflags);
#line 1044
  text_expand_tabs = save_expand;
  }
#line 1045
  return;
}
}
#line 1053 "/tmp/zsh-5.4.2/Src/hashtable.c"
char *getshfuncfile(Shfunc shf ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 1056
  if (shf->node.flags & (1 << 19)) {
    {
#line 1057
    tmp = zhtricat((char const   *)shf->filename, "/", (char const   *)shf->node.nam);
    }
#line 1057
    return (tmp);
  } else
#line 1058
  if (shf->filename) {
    {
#line 1059
    tmp___0 = dupstring((char const   *)shf->filename);
    }
#line 1059
    return (tmp___0);
  } else {
#line 1061
    return ((char *)((void *)0));
  }
}
}
#line 1071 "/tmp/zsh-5.4.2/Src/hashtable.c"
static struct reswd reswds[32]  = 
#line 1071
  {      {{(HashNode )((void *)0), (char *)"!", 0}, 39}, 
        {{(HashNode )((void *)0), (char *)"[[", 0}, 40}, 
        {{(HashNode )((void *)0), (char *)"{", 0}, 41}, 
        {{(HashNode )((void *)0), (char *)"}", 0}, 42}, 
        {{(HashNode )((void *)0), (char *)"case", 0}, 43}, 
        {{(HashNode )((void *)0), (char *)"coproc", 0}, 44}, 
        {{(HashNode )((void *)0), (char *)"declare", 0}, 63}, 
        {{(HashNode )((void *)0), (char *)"do", 0}, 45}, 
        {{(HashNode )((void *)0), (char *)"done", 0}, 46}, 
        {{(HashNode )((void *)0), (char *)"elif", 0}, 47}, 
        {{(HashNode )((void *)0), (char *)"else", 0}, 48}, 
        {{(HashNode )((void *)0), (char *)"end", 0}, 49}, 
        {{(HashNode )((void *)0), (char *)"esac", 0}, 50}, 
        {{(HashNode )((void *)0), (char *)"export", 0}, 63}, 
        {{(HashNode )((void *)0), (char *)"fi", 0}, 51}, 
        {{(HashNode )((void *)0), (char *)"float", 0}, 63}, 
        {{(HashNode )((void *)0), (char *)"for", 0}, 52}, 
        {{(HashNode )((void *)0), (char *)"foreach", 0}, 53}, 
        {{(HashNode )((void *)0), (char *)"function", 0}, 54}, 
        {{(HashNode )((void *)0), (char *)"if", 0}, 55}, 
        {{(HashNode )((void *)0), (char *)"integer", 0}, 63}, 
        {{(HashNode )((void *)0), (char *)"local", 0}, 63}, 
        {{(HashNode )((void *)0), (char *)"nocorrect", 0}, 56}, 
        {{(HashNode )((void *)0), (char *)"readonly", 0}, 63}, 
        {{(HashNode )((void *)0), (char *)"repeat", 0}, 57}, 
        {{(HashNode )((void *)0), (char *)"select", 0}, 58}, 
        {{(HashNode )((void *)0), (char *)"then", 0}, 59}, 
        {{(HashNode )((void *)0), (char *)"time", 0}, 60}, 
        {{(HashNode )((void *)0), (char *)"typeset", 0}, 63}, 
        {{(HashNode )((void *)0), (char *)"until", 0}, 61}, 
        {{(HashNode )((void *)0), (char *)"while", 0}, 62}, 
        {{(HashNode )((void *)0), (char *)((void *)0), 0}, 0}};
#line 1114 "/tmp/zsh-5.4.2/Src/hashtable.c"
void createreswdtable(void) 
{ 
  Reswd rw ;

  {
  {
#line 1119
  reswdtab = newhashtable(23, "reswdtab", (void (*)(HashTable___0  ))((void *)0));
#line 1121
  reswdtab->hash = & hasher;
#line 1122
  reswdtab->emptytable = (void (*)(HashTable___0  ))((void *)0);
#line 1123
  reswdtab->filltable = (void (*)(HashTable___0  ))((void *)0);
#line 1124
  reswdtab->cmpnodes = (int (*)(char const   * , char const   * ))(& strcmp);
#line 1125
  reswdtab->addnode = & addhashnode;
#line 1126
  reswdtab->getnode = & gethashnode;
#line 1127
  reswdtab->getnode2 = & gethashnode2;
#line 1128
  reswdtab->removenode = (HashNode (*)(HashTable___0  , char const   * ))((void *)0);
#line 1129
  reswdtab->disablenode = & disablehashnode;
#line 1130
  reswdtab->enablenode = & enablehashnode;
#line 1131
  reswdtab->freenode = (void (*)(HashNode  ))((void *)0);
#line 1132
  reswdtab->printnode = & printreswdnode;
#line 1134
  rw = reswds;
  }
  {
#line 1134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1134
    if (! rw->node.nam) {
#line 1134
      goto while_break;
    }
    {
#line 1135
    (*(reswdtab->addnode))(reswdtab, rw->node.nam, (void *)rw);
#line 1134
    rw ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1136
  return;
}
}
#line 1141 "/tmp/zsh-5.4.2/Src/hashtable.c"
static void printreswdnode(HashNode hn , int printflags ) 
{ 
  Reswd rw ;

  {
#line 1144
  rw = (Reswd )hn;
#line 1146
  if (printflags & (1 << 10)) {
    {
#line 1147
    printf((char const   */* __restrict  */)"%s: reserved\n", rw->node.nam);
    }
#line 1148
    return;
  }
#line 1151
  if (printflags & (1 << 6)) {
    {
#line 1152
    printf((char const   */* __restrict  */)"%s: shell reserved word\n", rw->node.nam);
    }
#line 1153
    return;
  }
#line 1156
  if (printflags & (1 << 7)) {
    {
#line 1157
    printf((char const   */* __restrict  */)"%s is a reserved word\n", rw->node.nam);
    }
#line 1158
    return;
  }
  {
#line 1162
  printf((char const   */* __restrict  */)"%s\n", rw->node.nam);
  }
#line 1163
  return;
}
}
#line 1182 "/tmp/zsh-5.4.2/Src/hashtable.c"
void createaliastable(HashTable___0 ht ) 
{ 


  {
#line 1185
  ht->hash = & hasher;
#line 1186
  ht->emptytable = (void (*)(HashTable___0  ))((void *)0);
#line 1187
  ht->filltable = (void (*)(HashTable___0  ))((void *)0);
#line 1188
  ht->cmpnodes = (int (*)(char const   * , char const   * ))(& strcmp);
#line 1189
  ht->addnode = & addhashnode;
#line 1190
  ht->getnode = & gethashnode;
#line 1191
  ht->getnode2 = & gethashnode2;
#line 1192
  ht->removenode = & removehashnode;
#line 1193
  ht->disablenode = & disablehashnode;
#line 1194
  ht->enablenode = & enablehashnode;
#line 1195
  ht->freenode = & freealiasnode;
#line 1196
  ht->printnode = & printaliasnode;
#line 1197
  return;
}
}
#line 1200 "/tmp/zsh-5.4.2/Src/hashtable.c"
void createaliastables(void) 
{ 
  char *tmp ;
  Alias tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  Alias tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1205
  aliastab = newhashtable(23, "aliastab", (void (*)(HashTable___0  ))((void *)0));
#line 1207
  createaliastable(aliastab);
#line 1210
  tmp = ztrdup("man");
#line 1210
  tmp___0 = createaliasnode(tmp, 0);
#line 1210
  tmp___1 = ztrdup("run-help");
#line 1210
  (*(aliastab->addnode))(aliastab, tmp___1, (void *)tmp___0);
#line 1211
  tmp___2 = ztrdup("whence");
#line 1211
  tmp___3 = createaliasnode(tmp___2, 0);
#line 1211
  tmp___4 = ztrdup("which-command");
#line 1211
  (*(aliastab->addnode))(aliastab, tmp___4, (void *)tmp___3);
#line 1216
  sufaliastab = newhashtable(11, "sufaliastab", (void (*)(HashTable___0  ))((void *)0));
#line 1218
  createaliastable(sufaliastab);
  }
#line 1219
  return;
}
}
#line 1224 "/tmp/zsh-5.4.2/Src/hashtable.c"
Alias createaliasnode(char *txt , int flags ) 
{ 
  Alias al ;
  void *tmp ;

  {
  {
#line 1229
  tmp = zshcalloc(sizeof(*al));
#line 1229
  al = (Alias )tmp;
#line 1230
  al->node.flags = flags;
#line 1231
  al->text = txt;
#line 1232
  al->inuse = 0;
  }
#line 1233
  return (al);
}
}
#line 1237 "/tmp/zsh-5.4.2/Src/hashtable.c"
static void freealiasnode(HashNode hn ) 
{ 
  Alias al ;

  {
  {
#line 1240
  al = (Alias )hn;
#line 1242
  zsfree(al->node.nam);
#line 1243
  zsfree(al->text);
#line 1244
  zfree((void *)al, (int )sizeof(struct alias ));
  }
#line 1245
  return;
}
}
#line 1250 "/tmp/zsh-5.4.2/Src/hashtable.c"
static void printaliasnode(HashNode hn , int printflags ) 
{ 
  Alias a ;
  char *tmp ;

  {
#line 1253
  a = (Alias )hn;
#line 1255
  if (printflags & 1) {
    {
#line 1256
    zputs((char const   *)a->node.nam, stdout);
#line 1257
    putchar('\n');
    }
#line 1258
    return;
  }
#line 1261
  if (printflags & (1 << 10)) {
#line 1262
    if (a->node.flags & (1 << 2)) {
      {
#line 1263
      printf((char const   */* __restrict  */)"%s: suffix alias\n", a->node.nam);
      }
    } else {
      {
#line 1265
      printf((char const   */* __restrict  */)"%s: alias\n", a->node.nam);
      }
    }
#line 1266
    return;
  }
#line 1269
  if (printflags & (1 << 8)) {
    {
#line 1270
    zputs((char const   *)a->text, stdout);
#line 1271
    putchar('\n');
    }
#line 1272
    return;
  }
#line 1275
  if (printflags & (1 << 6)) {
    {
#line 1276
    mb_niceformat((char const   *)a->node.nam, stdout, (char **)((void *)0), 0);
#line 1277
    printf((char const   */* __restrict  */)": ");
    }
#line 1278
    if (a->node.flags & (1 << 2)) {
      {
#line 1279
      printf((char const   */* __restrict  */)"suffix ");
      }
    } else
#line 1280
    if (a->node.flags & (1 << 1)) {
      {
#line 1281
      printf((char const   */* __restrict  */)"globally ");
      }
    }
    {
#line 1282
    printf((char const   */* __restrict  */)"aliased to ");
#line 1283
    mb_niceformat((char const   *)a->text, stdout, (char **)((void *)0), 0);
#line 1284
    putchar('\n');
    }
#line 1285
    return;
  }
#line 1288
  if (printflags & (1 << 7)) {
    {
#line 1289
    mb_niceformat((char const   *)a->node.nam, stdout, (char **)((void *)0), 0);
#line 1290
    printf((char const   */* __restrict  */)" is a");
    }
#line 1291
    if (a->node.flags & (1 << 2)) {
      {
#line 1292
      printf((char const   */* __restrict  */)" suffix");
      }
    } else
#line 1293
    if (a->node.flags & (1 << 1)) {
      {
#line 1294
      printf((char const   */* __restrict  */)" global");
      }
    } else {
      {
#line 1296
      printf((char const   */* __restrict  */)"n");
      }
    }
    {
#line 1297
    printf((char const   */* __restrict  */)" alias for ");
#line 1298
    mb_niceformat((char const   *)a->text, stdout, (char **)((void *)0), 0);
#line 1299
    putchar('\n');
    }
#line 1300
    return;
  }
#line 1303
  if (printflags & (1 << 2)) {
    {
#line 1305
    tmp = strchr((char const   *)a->node.nam, '=');
    }
#line 1305
    if (tmp) {
      {
#line 1306
      zwarn("invalid alias \'%s\' encountered while printing aliases", a->node.nam);
      }
#line 1309
      return;
    }
    {
#line 1313
    printf((char const   */* __restrict  */)"alias ");
    }
#line 1314
    if (a->node.flags & (1 << 2)) {
      {
#line 1315
      printf((char const   */* __restrict  */)"-s ");
      }
    } else
#line 1316
    if (a->node.flags & (1 << 1)) {
      {
#line 1317
      printf((char const   */* __restrict  */)"-g ");
      }
    }
#line 1321
    if ((int )*(a->node.nam + 0) == 45) {
      {
#line 1322
      printf((char const   */* __restrict  */)"-- ");
      }
    } else
#line 1321
    if ((int )*(a->node.nam + 0) == 43) {
      {
#line 1322
      printf((char const   */* __restrict  */)"-- ");
      }
    }
  }
  {
#line 1325
  quotedzputs((char const   *)a->node.nam, stdout);
#line 1326
  putchar('=');
#line 1327
  quotedzputs((char const   *)a->text, stdout);
#line 1329
  putchar('\n');
  }
#line 1330
  return;
}
}
#line 1337 "/tmp/zsh-5.4.2/Src/hashtable.c"
void createhisttable(void) 
{ 


  {
  {
#line 1340
  histtab = newhashtable(599, "histtab", (void (*)(HashTable___0  ))((void *)0));
#line 1342
  histtab->hash = & histhasher;
#line 1343
  histtab->emptytable = & emptyhisttable;
#line 1344
  histtab->filltable = (void (*)(HashTable___0  ))((void *)0);
#line 1345
  histtab->cmpnodes = & histstrcmp;
#line 1346
  histtab->addnode = & addhistnode;
#line 1347
  histtab->getnode = & gethashnode2;
#line 1348
  histtab->getnode2 = & gethashnode2;
#line 1349
  histtab->removenode = & removehashnode;
#line 1350
  histtab->disablenode = (void (*)(HashNode  , int  ))((void *)0);
#line 1351
  histtab->enablenode = (void (*)(HashNode  , int  ))((void *)0);
#line 1352
  histtab->freenode = & freehistnode;
#line 1353
  histtab->printnode = (void (*)(HashNode  , int  ))((void *)0);
  }
#line 1354
  return;
}
}
#line 1357 "/tmp/zsh-5.4.2/Src/hashtable.c"
unsigned int histhasher(char const   *str ) 
{ 
  unsigned int hashval ;
  char const   *tmp ;

  {
#line 1360
  hashval = 0U;
  {
#line 1362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1362
    if (! ((int )typtab[(unsigned char )*str] & (1 << 3))) {
#line 1362
      goto while_break;
    }
#line 1362
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1364
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1364
    if (! *str) {
#line 1364
      goto while_break___0;
    }
#line 1365
    if ((int )typtab[(unsigned char )*str] & (1 << 3)) {
      {
#line 1366
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1366
        str ++;
#line 1366
        if (! ((int )typtab[(unsigned char )*str] & (1 << 3))) {
#line 1366
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1367
      if (*str) {
#line 1368
        hashval += (hashval << 5) + 32U;
      }
    } else {
#line 1371
      tmp = str;
#line 1371
      str ++;
#line 1371
      hashval += (hashval << 5) + (unsigned int )*((unsigned char *)tmp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1373
  return (hashval);
}
}
#line 1377 "/tmp/zsh-5.4.2/Src/hashtable.c"
void emptyhisttable(HashTable___0 ht ) 
{ 


  {
  {
#line 1380
  emptyhashtable(ht);
  }
#line 1381
  if (hist_ring) {
    {
#line 1382
    histremovedups();
    }
  }
#line 1383
  return;
}
}
#line 1388 "/tmp/zsh-5.4.2/Src/hashtable.c"
int histstrcmp(char const   *str1 , char const   *str2 ) 
{ 


  {
  {
#line 1391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1391
    if (! ((int )typtab[(unsigned char )*str1] & (1 << 3))) {
#line 1391
      goto while_break;
    }
#line 1391
    str1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1392
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1392
    if (! ((int )typtab[(unsigned char )*str2] & (1 << 3))) {
#line 1392
      goto while_break___0;
    }
#line 1392
    str2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1393
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1393
    if (*str1) {
#line 1393
      if (! *str2) {
#line 1393
        goto while_break___1;
      }
    } else {
#line 1393
      goto while_break___1;
    }
#line 1394
    if ((int )typtab[(unsigned char )*str1] & (1 << 3)) {
#line 1395
      if (! ((int )typtab[(unsigned char )*str2] & (1 << 3))) {
#line 1396
        goto while_break___1;
      }
      {
#line 1397
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1397
        str1 ++;
#line 1397
        if (! ((int )typtab[(unsigned char )*str1] & (1 << 3))) {
#line 1397
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1398
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1398
        str2 ++;
#line 1398
        if (! ((int )typtab[(unsigned char )*str2] & (1 << 3))) {
#line 1398
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 1401
      if ((int const   )*str1 != (int const   )*str2) {
#line 1402
        goto while_break___1;
      }
#line 1403
      str1 ++;
#line 1404
      str2 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1407
  return ((int )((int const   )*str1 - (int const   )*str2));
}
}
#line 1411 "/tmp/zsh-5.4.2/Src/hashtable.c"
void addhistnode(HashTable___0 ht , char *nam , void *nodeptr ) 
{ 
  HashNode oldnode ;
  HashNode tmp ;
  Histent he ;

  {
  {
#line 1414
  tmp = addhashnode2(ht, nam, nodeptr);
#line 1414
  oldnode = tmp;
#line 1415
  he = (Histent )nodeptr;
  }
#line 1416
  if (oldnode) {
#line 1416
    if ((unsigned long )oldnode != (unsigned long )((HashNode )nodeptr)) {
#line 1417
      if (he->node.flags & 1) {
        {
#line 1419
        addhashnode2(ht, oldnode->nam, (void *)oldnode);
#line 1420
        he->node.flags |= 8;
#line 1421
        he->node.flags &= -2;
        }
      } else
#line 1417
      if (he->node.flags & 16) {
#line 1417
        if ((unsigned long )((Histent )oldnode) == (unsigned long )he->up) {
          {
#line 1419
          addhashnode2(ht, oldnode->nam, (void *)oldnode);
#line 1420
          he->node.flags |= 8;
#line 1421
          he->node.flags &= -2;
          }
        } else {
#line 1417
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1424
        oldnode->flags |= 8;
#line 1425
        if (hist_ignore_all_dups) {
          {
#line 1426
          freehistnode(oldnode);
          }
        }
      }
    } else {
#line 1430
      he->node.flags &= -2;
    }
  } else {
#line 1430
    he->node.flags &= -2;
  }
#line 1431
  return;
}
}
#line 1434 "/tmp/zsh-5.4.2/Src/hashtable.c"
void freehistnode(HashNode nodeptr ) 
{ 


  {
  {
#line 1437
  freehistdata((Histent )nodeptr, 1);
#line 1438
  zfree((void *)nodeptr, (int )sizeof(struct histent ));
  }
#line 1439
  return;
}
}
#line 1442 "/tmp/zsh-5.4.2/Src/hashtable.c"
void freehistdata(Histent he , int unlink___0 ) 
{ 


  {
#line 1445
  if (! he) {
#line 1446
    return;
  }
#line 1448
  if ((unsigned long )he == (unsigned long )(& curline)) {
#line 1449
    return;
  }
#line 1451
  if (! (he->node.flags & 40)) {
    {
#line 1452
    removehashnode(histtab, (char const   *)he->node.nam);
    }
  }
  {
#line 1454
  zsfree(he->node.nam);
  }
#line 1455
  if (he->nwords) {
    {
#line 1456
    zfree((void *)he->words, (int )((unsigned long )(he->nwords * 2) * sizeof(short )));
    }
  }
#line 1458
  if (unlink___0) {
#line 1459
    histlinect --;
#line 1459
    if (histlinect) {
#line 1462
      if ((unsigned long )he == (unsigned long )hist_ring) {
#line 1463
        hist_ring = hist_ring->up;
      }
#line 1464
      (he->up)->down = he->down;
#line 1465
      (he->down)->up = he->up;
    } else {
#line 1460
      hist_ring = (Histent )((void *)0);
    }
  }
#line 1468
  return;
}
}
#line 1502 "/tmp/zsh-5.4.2/Src/hashtable.c"
static struct dircache_entry *dircache  ;
#line 1502 "/tmp/zsh-5.4.2/Src/hashtable.c"
static struct dircache_entry *dircache_lastentry  ;
#line 1503 "/tmp/zsh-5.4.2/Src/hashtable.c"
static int dircache_size  ;
#line 1521 "/tmp/zsh-5.4.2/Src/hashtable.c"
void dircache_set(char **name , char *value ) 
{ 
  struct dircache_entry *dcptr ;
  struct dircache_entry *dcnew ;
  ptrdiff_t ind ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 1526
  if (! value) {
#line 1527
    if (! *name) {
#line 1528
      return;
    }
#line 1529
    if (! dircache_size) {
      {
#line 1530
      zsfree(*name);
#line 1531
      *name = (char *)((void *)0);
      }
#line 1532
      return;
    }
#line 1535
    dcptr = dircache;
    {
#line 1535
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1535
      if (! ((unsigned long )dcptr < (unsigned long )(dircache + dircache_size))) {
#line 1535
        goto while_break;
      }
#line 1538
      if ((unsigned long )*name == (unsigned long )dcptr->name) {
#line 1540
        (dcptr->refs) --;
#line 1541
        if (! dcptr->refs) {
          {
#line 1542
          ind = dcptr - dircache;
#line 1543
          zsfree(dcptr->name);
#line 1544
          dircache_size --;
          }
#line 1546
          if (! dircache_size) {
            {
#line 1547
            zfree((void *)dircache, (int )sizeof(*dircache));
#line 1548
            dircache = (struct dircache_entry *)((void *)0);
#line 1549
            dircache_lastentry = (struct dircache_entry *)((void *)0);
#line 1550
            *name = (char *)((void *)0);
            }
#line 1551
            return;
          }
          {
#line 1553
          tmp = zalloc((unsigned long )dircache_size * sizeof(*dcnew));
#line 1553
          dcnew = (struct dircache_entry *)tmp;
          }
#line 1555
          if (ind) {
            {
#line 1556
            memcpy((void */* __restrict  */)dcnew, (void const   */* __restrict  */)dircache,
                   (unsigned long )ind * sizeof(*dcnew));
            }
          }
#line 1557
          if (ind < (ptrdiff_t )dircache_size) {
            {
#line 1558
            memcpy((void */* __restrict  */)(dcnew + ind), (void const   */* __restrict  */)(dcptr + 1),
                   (unsigned long )((ptrdiff_t )dircache_size - ind) * sizeof(*dcnew));
            }
          }
          {
#line 1560
          zfree((void *)dircache, (int )((unsigned long )(dircache_size + 1) * sizeof(*dcnew)));
#line 1561
          dircache = dcnew;
#line 1562
          dircache_lastentry = (struct dircache_entry *)((void *)0);
          }
        }
#line 1564
        *name = (char *)((void *)0);
#line 1565
        return;
      }
#line 1535
      dcptr ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1568
    zsfree(*name);
#line 1569
    *name = (char *)((void *)0);
    }
  } else {
#line 1575
    if ((int )*value != 47) {
      {
#line 1576
      tmp___0 = zgetcwd();
#line 1576
      tmp___1 = metafy(tmp___0, -1, 6);
#line 1576
      value = zhtricat((char const   *)tmp___1, "/", (char const   *)value);
#line 1578
      value = xsymlink(value, 1);
      }
    }
#line 1587
    if (dircache_lastentry) {
      {
#line 1587
      tmp___5 = strcmp((char const   *)value, (char const   *)dircache_lastentry->name);
      }
#line 1587
      if (tmp___5) {
#line 1587
        goto _L;
      } else {
#line 1589
        *name = dircache_lastentry->name;
#line 1590
        (dircache_lastentry->refs) ++;
#line 1591
        return;
      }
    } else
    _L: /* CIL Label */ 
#line 1592
    if (! dircache_size) {
      {
#line 1593
      dircache_size = 1;
#line 1594
      tmp___2 = zalloc(sizeof(*dircache));
#line 1594
      dircache = (struct dircache_entry *)tmp___2;
#line 1594
      dcptr = dircache;
      }
    } else {
#line 1597
      dcptr = dircache;
      {
#line 1597
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1597
        if (! ((unsigned long )dcptr < (unsigned long )(dircache + dircache_size))) {
#line 1597
          goto while_break___0;
        }
        {
#line 1599
        tmp___3 = strcmp((char const   *)value, (char const   *)dcptr->name);
        }
#line 1599
        if (! tmp___3) {
#line 1600
          *name = dcptr->name;
#line 1601
          (dcptr->refs) ++;
#line 1602
          return;
        }
#line 1597
        dcptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1605
      dircache_size ++;
#line 1606
      tmp___4 = zrealloc((void *)dircache, sizeof(*dircache) * (unsigned long )dircache_size);
#line 1606
      dircache = (struct dircache_entry *)tmp___4;
#line 1608
      dcptr = (dircache + dircache_size) - 1;
      }
    }
    {
#line 1610
    dcptr->name = ztrdup((char const   *)value);
#line 1611
    *name = dcptr->name;
#line 1612
    dcptr->refs = 1;
#line 1613
    dircache_lastentry = dcptr;
    }
  }
#line 1615
  return;
}
}
#line 107 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 5 "./glob.epro"
int badcshglob  ;
#line 6 "./glob.epro"
int pathpos  ;
#line 7 "./glob.epro"
char *pathbuf  ;
#line 8 "./glob.epro"
char *glob_pre  ;
#line 9 "./glob.epro"
char *glob_suf  ;
#line 10
int checkglobqual(char *str , int sl , int nobareglob , char **sp___0 ) ;
#line 12
char file_type(mode_t filemode ) ;
#line 14
int xpandredir(struct redir *fn___0 , LinkList redirtab___0 ) ;
#line 16
int matchpat(char *a , char *b ) ;
#line 19
int getmatchlist(char *str , Patprog p , LinkList *repllistp ) ;
#line 20
void freematchlist(LinkList repllist ) ;
#line 2 "./glob.pro"
static void addpath(char *s , int l ) ;
#line 3
static int statfullpath(char const   *s , struct stat *st___0 , int l ) ;
#line 4
static void insert(char *s , int checked ) ;
#line 5
static void scanner(Complist q , int shortcircuit ) ;
#line 6
static Complist parsecomplist(char *instr___0 ) ;
#line 7
static Complist parsepat(char *str ) ;
#line 8
static off_t qgetnum(char **s ) ;
#line 9
static zlong qgetmodespec(char **s ) ;
#line 10
static char *glob_exec_string(char **sp___0 ) ;
#line 11
static int bracechardots(char *str , convchar_t *c1p , convchar_t *c2p ) ;
#line 12
static char *get_match_ret(Imatchdata imd , int b , int e ) ;
#line 13
static void set_pat_start(Patprog p , int offs ) ;
#line 14
static void set_pat_end(Patprog p , char null_me ) ;
#line 16
static int iincchar(char **tp , int left ) ;
#line 17
static int igetmatch(char **sp___0 , Patprog p , int fl , int n , char *replstr ,
                     LinkList *repllistp ) ;
#line 21
static void zshtokenize(char *s , int flags ) ;
#line 22
static int qualdev(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                   off_t dv , char *dummy___0  __attribute__((__unused__)) ) ;
#line 23
static int qualnlink(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t ct , char *dummy___0  __attribute__((__unused__)) ) ;
#line 24
static int qualuid(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                   off_t uid , char *dummy___0  __attribute__((__unused__)) ) ;
#line 25
static int qualgid(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                   off_t gid , char *dummy___0  __attribute__((__unused__)) ) ;
#line 26
static int qualisdev(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) ;
#line 27
static int qualisblk(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) ;
#line 28
static int qualischr(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) ;
#line 29
static int qualisdir(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) ;
#line 30
static int qualisfifo(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                      off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) ;
#line 31
static int qualislnk(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) ;
#line 32
static int qualisreg(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) ;
#line 33
static int qualissock(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                      off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) ;
#line 34
static int qualflags(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t mod , char *dummy___0  __attribute__((__unused__)) ) ;
#line 35
static int qualmodeflags(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                         off_t mod , char *dummy___0  __attribute__((__unused__)) ) ;
#line 36
static int qualiscom(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t mod  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) ;
#line 37
static int qualsize(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                    off_t size , char *dummy___0  __attribute__((__unused__)) ) ;
#line 38
static int qualtime(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                    off_t days , char *dummy___0  __attribute__((__unused__)) ) ;
#line 39
static int qualsheval(char *name , struct stat *buf___7  __attribute__((__unused__)) ,
                      off_t days  __attribute__((__unused__)) , char *str ) ;
#line 40
static int qualnonemptydir(char *name , struct stat *buf___7 , off_t days  __attribute__((__unused__)) ,
                           char *str  __attribute__((__unused__)) ) ;
#line 197 "/tmp/zsh-5.4.2/Src/glob.c"
static struct globdata curglobdata  ;
#line 264 "/tmp/zsh-5.4.2/Src/glob.c"
static void addpath(char *s , int l ) 
{ 
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! ((pathpos + l) + 1 >= curglobdata.gd_pathbufsz)) {
#line 268
      goto while_break;
    }
    {
#line 269
    curglobdata.gd_pathbufsz *= 2;
#line 269
    tmp = zrealloc((void *)pathbuf, (size_t )curglobdata.gd_pathbufsz);
#line 269
    pathbuf = (char *)tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 270
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 270
    tmp___2 = l;
#line 270
    l --;
#line 270
    if (! tmp___2) {
#line 270
      goto while_break___0;
    }
#line 271
    tmp___0 = pathpos;
#line 271
    pathpos ++;
#line 271
    tmp___1 = s;
#line 271
    s ++;
#line 271
    *(pathbuf + tmp___0) = *tmp___1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 272
  tmp___3 = pathpos;
#line 272
  pathpos ++;
#line 272
  *(pathbuf + tmp___3) = (char )'/';
#line 273
  *(pathbuf + pathpos) = (char )'\000';
#line 274
  return;
}
}
#line 283 "/tmp/zsh-5.4.2/Src/glob.c"
static int statfullpath(char const   *s , struct stat *st___0 , int l ) 
{ 
  char buf___7[4097] ;
  char lbuf[1] ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 290
  strcpy((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)(pathbuf + curglobdata.gd_pathbufcwd));
#line 291
  strcpy((char */* __restrict  */)((buf___7 + pathpos) - curglobdata.gd_pathbufcwd),
         (char const   */* __restrict  */)s);
  }
#line 292
  if (! *s) {
#line 292
    if (buf___7[0]) {
#line 297
      buf___7[pathpos - curglobdata.gd_pathbufcwd] = (char )'.';
#line 298
      buf___7[(pathpos - curglobdata.gd_pathbufcwd) + 1] = (char )'\000';
#line 299
      l = 0;
    }
  }
  {
#line 301
  unmetafy(buf___7, (int *)((void *)0));
  }
#line 302
  if (! st___0) {
    {
#line 304
    tmp = access((char const   *)(buf___7), 0);
    }
#line 304
    if (tmp) {
#line 304
      if (! l) {
#line 304
        tmp___1 = 1;
      } else {
        {
#line 304
        tmp___0 = readlink((char const   */* __restrict  */)(buf___7), (char */* __restrict  */)(lbuf),
                           (size_t )1);
        }
#line 304
        if (tmp___0 < 0L) {
#line 304
          tmp___1 = 1;
        } else {
#line 304
          tmp___1 = 0;
        }
      }
    } else {
#line 304
      tmp___1 = 0;
    }
#line 304
    return (tmp___1);
  }
#line 306
  if (l) {
    {
#line 306
    tmp___2 = lstat((char const   */* __restrict  */)(buf___7), (struct stat */* __restrict  */)st___0);
#line 306
    tmp___4 = tmp___2;
    }
  } else {
    {
#line 306
    tmp___3 = stat((char const   */* __restrict  */)(buf___7), (struct stat */* __restrict  */)st___0);
#line 306
    tmp___4 = tmp___3;
    }
  }
#line 306
  return (tmp___4);
}
}
#line 312 "/tmp/zsh-5.4.2/Src/glob.c"
static char **inserts  ;
#line 317 "/tmp/zsh-5.4.2/Src/glob.c"
static void insert(char *s , int checked ) 
{ 
  struct stat buf___7 ;
  struct stat buf2 ;
  struct stat *bp ;
  char *news ;
  int statted ;
  mode_t mode ;
  sigset_t oset ;
  int tmp ;
  int tmp___0 ;
  int ll ;
  size_t tmp___1 ;
  void *tmp___2 ;
  struct qual *qo ;
  struct qual *qn ;
  sigset_t oset___0 ;
  int tmp___3 ;
  int tmp___4 ;
  sigset_t oset___1 ;
  int tmp___5 ;
  int tmp___6 ;
  sigset_t oset___2 ;
  int tmp___7 ;
  char *mod ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  char **tmp___11 ;
  sigset_t oset___3 ;

  {
#line 321
  news = s;
#line 322
  statted = 0;
#line 324
  queueing_enabled ++;
#line 325
  inserts = (char **)((void *)0);
#line 327
  if (curglobdata.gd_gf_listtypes) {
#line 327
    goto _L___0;
  } else
#line 327
  if (curglobdata.gd_gf_markdirs) {
    _L___0: /* CIL Label */ 
    {
#line 330
    statted = 1;
#line 330
    checked = statted;
#line 331
    tmp = statfullpath((char const   *)s, & buf___7, 1);
    }
#line 331
    if (tmp) {
      {
#line 332
      while (1) {
        while_continue: /* CIL Label */ ;
#line 332
        queueing_enabled --;
#line 332
        if (! queueing_enabled) {
          {
#line 332
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 332
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 332
              if (! (queue_front != queue_rear)) {
#line 332
                goto while_break___1;
              }
              {
#line 332
              queue_front = (queue_front + 1) % 128;
#line 332
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 332
              zhandler(signal_queue[queue_front]);
#line 332
              signal_setmask(oset);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 332
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 332
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 333
      return;
    }
#line 335
    mode = buf___7.st_mode;
#line 336
    if (curglobdata.gd_gf_follow) {
#line 337
      if (! ((mode & 61440U) == 40960U)) {
        {
#line 338
        memcpy((void */* __restrict  */)(& buf2), (void const   */* __restrict  */)(& buf___7),
               sizeof(buf___7));
        }
      } else {
        {
#line 337
        tmp___0 = statfullpath((char const   *)s, & buf2, 0);
        }
#line 337
        if (tmp___0) {
          {
#line 338
          memcpy((void */* __restrict  */)(& buf2), (void const   */* __restrict  */)(& buf___7),
                 sizeof(buf___7));
          }
        }
      }
#line 339
      statted |= 2;
#line 340
      mode = buf2.st_mode;
    }
#line 342
    if (curglobdata.gd_gf_listtypes) {
#line 342
      goto _L;
    } else
#line 342
    if ((mode & 61440U) == 16384U) {
      _L: /* CIL Label */ 
      {
#line 343
      tmp___1 = strlen((char const   *)s);
#line 343
      ll = (int )tmp___1;
#line 345
      tmp___2 = hcalloc((size_t )(ll + 2));
#line 345
      news = (char *)tmp___2;
#line 346
      strcpy((char */* __restrict  */)news, (char const   */* __restrict  */)s);
#line 347
      *(news + ll) = file_type(mode);
#line 348
      *(news + (ll + 1)) = (char )'\000';
      }
    }
  }
#line 351
  if (curglobdata.gd_qualct) {
#line 351
    goto _L___1;
  } else
#line 351
  if (curglobdata.gd_qualorct) {
    _L___1: /* CIL Label */ 
#line 355
    if (! statted) {
      {
#line 355
      tmp___3 = statfullpath((char const   *)s, & buf___7, 1);
      }
#line 355
      if (tmp___3) {
        {
#line 356
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 356
          queueing_enabled --;
#line 356
          if (! queueing_enabled) {
            {
#line 356
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 356
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 356
                if (! (queue_front != queue_rear)) {
#line 356
                  goto while_break___4;
                }
                {
#line 356
                queue_front = (queue_front + 1) % 128;
#line 356
                oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 356
                zhandler(signal_queue[queue_front]);
#line 356
                signal_setmask(oset___0);
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 356
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 356
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 357
        return;
      }
    }
    {
#line 359
    news = dyncat((char const   *)pathbuf, (char const   *)news);
#line 361
    statted = 1;
#line 362
    qo = curglobdata.gd_quals;
#line 363
    qn = qo;
    }
    {
#line 363
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 363
      if (qn) {
#line 363
        if (! qn->func) {
#line 363
          goto while_break___5;
        }
      } else {
#line 363
        goto while_break___5;
      }
#line 364
      curglobdata.gd_range = qn->range;
#line 365
      curglobdata.gd_amc = qn->amc;
#line 366
      curglobdata.gd_units = qn->units;
#line 367
      if (qn->sense & 2) {
#line 367
        if (! (statted & 2)) {
#line 369
          if (! ((buf___7.st_mode & 61440U) == 40960U)) {
            {
#line 370
            memcpy((void */* __restrict  */)(& buf2), (void const   */* __restrict  */)(& buf___7),
                   sizeof(buf___7));
            }
          } else {
            {
#line 369
            tmp___4 = statfullpath((char const   *)s, & buf2, 0);
            }
#line 369
            if (tmp___4) {
              {
#line 370
              memcpy((void */* __restrict  */)(& buf2), (void const   */* __restrict  */)(& buf___7),
                     sizeof(buf___7));
              }
            }
          }
#line 371
          statted |= 2;
        }
      }
#line 373
      if (qn->sense & 2) {
#line 373
        bp = & buf2;
      } else {
#line 373
        bp = & buf___7;
      }
      {
#line 377
      tmp___5 = (*(qn->func))(news, bp, qn->data, qn->sdata);
      }
#line 377
      if (tmp___5) {
#line 377
        tmp___6 = 0;
      } else {
#line 377
        tmp___6 = 1;
      }
#line 377
      if ((tmp___6 ^ qn->sense) & 1) {
#line 380
        qo = qo->or;
#line 380
        if (! qo) {
          {
#line 381
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 381
            queueing_enabled --;
#line 381
            if (! queueing_enabled) {
              {
#line 381
              while (1) {
                while_continue___7: /* CIL Label */ ;
                {
#line 381
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 381
                  if (! (queue_front != queue_rear)) {
#line 381
                    goto while_break___8;
                  }
                  {
#line 381
                  queue_front = (queue_front + 1) % 128;
#line 381
                  oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 381
                  zhandler(signal_queue[queue_front]);
#line 381
                  signal_setmask(oset___1);
                  }
                }
                while_break___8: /* CIL Label */ ;
                }
#line 381
                goto while_break___7;
              }
              while_break___7: /* CIL Label */ ;
              }
            }
#line 381
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 382
          return;
        }
#line 384
        qn = qo;
#line 385
        goto __Cont;
      }
#line 387
      qn = qn->next;
      __Cont: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else
#line 389
  if (! checked) {
    {
#line 390
    tmp___7 = statfullpath((char const   *)s, (struct stat *)((void *)0), 1);
    }
#line 390
    if (tmp___7) {
      {
#line 391
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 391
        queueing_enabled --;
#line 391
        if (! queueing_enabled) {
          {
#line 391
          while (1) {
            while_continue___10: /* CIL Label */ ;
            {
#line 391
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 391
              if (! (queue_front != queue_rear)) {
#line 391
                goto while_break___11;
              }
              {
#line 391
              queue_front = (queue_front + 1) % 128;
#line 391
              oset___2 = signal_setmask(signal_mask_queue[queue_front]);
#line 391
              zhandler(signal_queue[queue_front]);
#line 391
              signal_setmask(oset___2);
              }
            }
            while_break___11: /* CIL Label */ ;
            }
#line 391
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
        }
#line 391
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 392
      return;
    }
    {
#line 394
    statted = 1;
#line 395
    news = dyncat((char const   *)pathbuf, (char const   *)news);
    }
  } else {
    {
#line 397
    news = dyncat((char const   *)pathbuf, (char const   *)news);
    }
  }
  {
#line 399
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 399
    if (! (! inserts)) {
      {
#line 399
      tmp___11 = inserts;
#line 399
      inserts ++;
#line 399
      news = dupstring((char const   *)*tmp___11);
      }
#line 399
      if (! news) {
#line 399
        goto while_break___12;
      }
    }
#line 400
    if (curglobdata.gd_colonmod) {
      {
#line 402
      mod = curglobdata.gd_colonmod;
#line 403
      modify(& news, & mod);
      }
    }
#line 405
    if (! statted) {
#line 405
      if (curglobdata.gd_gf_sorts & ((((8 | (8 << 1)) | (8 << 2)) | (8 << 3)) | (8 << 4))) {
        {
#line 406
        statfullpath((char const   *)s, & buf___7, 1);
#line 407
        statted = 1;
        }
      }
    }
#line 409
    if (! (statted & 2)) {
#line 409
      if (curglobdata.gd_gf_sorts & (((((8 | (8 << 1)) | (8 << 2)) | (8 << 3)) | (8 << 4)) << 5)) {
#line 410
        if (statted) {
#line 411
          if (! ((buf___7.st_mode & 61440U) == 40960U)) {
            {
#line 412
            memcpy((void */* __restrict  */)(& buf2), (void const   */* __restrict  */)(& buf___7),
                   sizeof(buf___7));
            }
          } else {
            {
#line 411
            tmp___8 = statfullpath((char const   *)s, & buf2, 0);
            }
#line 411
            if (tmp___8) {
              {
#line 412
              memcpy((void */* __restrict  */)(& buf2), (void const   */* __restrict  */)(& buf___7),
                     sizeof(buf___7));
              }
            }
          }
        } else {
          {
#line 413
          tmp___9 = statfullpath((char const   *)s, & buf2, 0);
          }
#line 413
          if (tmp___9) {
            {
#line 414
            statfullpath((char const   *)s, & buf2, 1);
            }
          }
        }
#line 415
        statted |= 2;
      }
    }
#line 417
    (curglobdata.gd_matchptr)->name = news;
#line 418
    if (statted & 1) {
#line 419
      (curglobdata.gd_matchptr)->size = buf___7.st_size;
#line 420
      (curglobdata.gd_matchptr)->atime = buf___7.st_atim.tv_sec;
#line 421
      (curglobdata.gd_matchptr)->mtime = buf___7.st_mtim.tv_sec;
#line 422
      (curglobdata.gd_matchptr)->ctime = buf___7.st_ctim.tv_sec;
#line 423
      (curglobdata.gd_matchptr)->links = (long )buf___7.st_nlink;
#line 425
      (curglobdata.gd_matchptr)->ansec = buf___7.st_atim.tv_nsec;
#line 428
      (curglobdata.gd_matchptr)->mnsec = buf___7.st_mtim.tv_nsec;
#line 431
      (curglobdata.gd_matchptr)->cnsec = buf___7.st_ctim.tv_nsec;
    }
#line 434
    if (statted & 2) {
#line 435
      (curglobdata.gd_matchptr)->_size = buf2.st_size;
#line 436
      (curglobdata.gd_matchptr)->_atime = buf2.st_atim.tv_sec;
#line 437
      (curglobdata.gd_matchptr)->_mtime = buf2.st_mtim.tv_sec;
#line 438
      (curglobdata.gd_matchptr)->_ctime = buf2.st_ctim.tv_sec;
#line 439
      (curglobdata.gd_matchptr)->_links = (long )buf2.st_nlink;
#line 441
      (curglobdata.gd_matchptr)->_ansec = buf2.st_atim.tv_nsec;
#line 444
      (curglobdata.gd_matchptr)->_mnsec = buf2.st_mtim.tv_nsec;
#line 447
      (curglobdata.gd_matchptr)->_cnsec = buf2.st_ctim.tv_nsec;
    }
#line 450
    (curglobdata.gd_matchptr) ++;
#line 452
    (curglobdata.gd_matchct) ++;
#line 452
    if (curglobdata.gd_matchct == curglobdata.gd_matchsz) {
      {
#line 453
      curglobdata.gd_matchsz *= 2;
#line 453
      tmp___10 = zrealloc((void *)((char *)curglobdata.gd_matchbuf), sizeof(struct gmatch ) * (unsigned long )curglobdata.gd_matchsz);
#line 453
      curglobdata.gd_matchbuf = (Gmatch )tmp___10;
#line 456
      curglobdata.gd_matchptr = curglobdata.gd_matchbuf + curglobdata.gd_matchct;
      }
    }
#line 458
    if (! inserts) {
#line 459
      goto while_break___12;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 461
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 461
    queueing_enabled --;
#line 461
    if (! queueing_enabled) {
      {
#line 461
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 461
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 461
          if (! (queue_front != queue_rear)) {
#line 461
            goto while_break___15;
          }
          {
#line 461
          queue_front = (queue_front + 1) % 128;
#line 461
          oset___3 = signal_setmask(signal_mask_queue[queue_front]);
#line 461
          zhandler(signal_queue[queue_front]);
#line 461
          signal_setmask(oset___3);
          }
        }
        while_break___15: /* CIL Label */ ;
        }
#line 461
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 461
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 462
  return;
}
}
#line 470 "/tmp/zsh-5.4.2/Src/glob.c"
static void scanner(Complist q , int shortcircuit ) 
{ 
  Patprog p ;
  int closure ;
  int pbcwdsav ;
  int errssofar ;
  struct dirsav ds ;
  char *str ;
  int l ;
  int err ;
  char *tmp ;
  int oppos ;
  int add___0 ;
  struct stat sc ;
  struct stat sr ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  Complist tmp___6 ;
  int tmp___7 ;
  char *fn___0 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  int dirs ;
  DIR *lock ;
  DIR *tmp___10 ;
  char *subdirs ;
  int subdirlen ;
  int tmp___11 ;
  int tmp___12 ;
  int err___0 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  int l___0 ;
  int tmp___15 ;
  struct stat buf___7 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  int oppos___0 ;
  int l___1 ;
  size_t tmp___24 ;
  Complist tmp___25 ;
  int tmp___26 ;

  {
#line 475
  pbcwdsav = curglobdata.gd_pathbufcwd;
#line 476
  errssofar = errsfound;
#line 479
  if (! q) {
#line 480
    return;
  } else
#line 479
  if (errflag) {
#line 480
    return;
  }
  {
#line 481
  init_dirsav(& ds);
#line 483
  closure = q->closure;
  }
#line 483
  if (closure) {
#line 485
    if (q->closure == 2) {
#line 486
      q->closure = 1;
    } else {
      {
#line 488
      scanner(q->next, shortcircuit);
      }
#line 489
      if (shortcircuit) {
#line 489
        if (shortcircuit == curglobdata.gd_matchct) {
#line 490
          return;
        }
      }
    }
  }
#line 493
  p = q->pat;
#line 495
  if (p->flags & 32) {
#line 499
    str = (char *)p + p->startoff;
#line 500
    l = (int )p->patmlen;
#line 502
    if (((l + ! l) + pathpos) - curglobdata.gd_pathbufcwd >= 4096) {
#line 505
      if (l >= 4096) {
#line 506
        return;
      }
      {
#line 507
      tmp = unmeta((char const   *)(pathbuf + curglobdata.gd_pathbufcwd));
#line 507
      err = lchdir((char const   *)tmp, & ds, 0);
      }
#line 508
      if (err == -1) {
#line 509
        return;
      }
#line 510
      if (err) {
        {
#line 511
        zerr("current directory lost during glob");
        }
#line 512
        return;
      }
#line 514
      curglobdata.gd_pathbufcwd = pathpos;
    }
#line 516
    if (q->next) {
#line 518
      oppos = pathpos;
#line 520
      if (! errflag) {
#line 521
        add___0 = 1;
#line 523
        if (q->closure) {
#line 523
          if (*pathbuf) {
            {
#line 524
            tmp___5 = strcmp((char const   *)str, ".");
            }
#line 524
            if (tmp___5) {
              {
#line 526
              tmp___4 = strcmp((char const   *)str, "..");
              }
#line 526
              if (! tmp___4) {
                {
#line 529
                tmp___0 = stat((char const   */* __restrict  */)"/", (struct stat */* __restrict  */)(& sr));
                }
#line 529
                if (tmp___0) {
#line 529
                  tmp___3 = 1;
                } else {
                  {
#line 529
                  tmp___1 = unmeta((char const   *)pathbuf);
#line 529
                  tmp___2 = stat((char const   */* __restrict  */)tmp___1, (struct stat */* __restrict  */)(& sc));
                  }
#line 529
                  if (tmp___2) {
#line 529
                    tmp___3 = 1;
                  } else
#line 529
                  if (sr.st_ino != sc.st_ino) {
#line 529
                    tmp___3 = 1;
                  } else
#line 529
                  if (sr.st_dev != sc.st_dev) {
#line 529
                    tmp___3 = 1;
                  } else {
#line 529
                    tmp___3 = 0;
                  }
                }
#line 529
                add___0 = tmp___3;
              }
            } else {
#line 525
              add___0 = 0;
            }
          }
        }
#line 534
        if (add___0) {
          {
#line 535
          addpath(str, l);
          }
#line 536
          if (! closure) {
#line 536
            goto _L;
          } else {
            {
#line 536
            tmp___7 = statfullpath("", (struct stat *)((void *)0), 1);
            }
#line 536
            if (! tmp___7) {
              _L: /* CIL Label */ 
#line 537
              if (q->closure) {
#line 537
                tmp___6 = q;
              } else {
#line 537
                tmp___6 = q->next;
              }
              {
#line 537
              scanner(tmp___6, shortcircuit);
              }
#line 538
              if (shortcircuit) {
#line 538
                if (shortcircuit == curglobdata.gd_matchct) {
#line 539
                  return;
                }
              }
            }
          }
#line 541
          pathpos = oppos;
#line 541
          *(pathbuf + pathpos) = (char )'\000';
        }
      }
    } else {
#line 545
      if (*(str + l)) {
        {
#line 546
        str = dupstrpfx((char const   *)str, l);
        }
      }
      {
#line 547
      insert(str, 0);
      }
#line 548
      if (shortcircuit) {
#line 548
        if (shortcircuit == curglobdata.gd_matchct) {
#line 549
          return;
        }
      }
    }
  } else {
#line 553
    if (*(pathbuf + curglobdata.gd_pathbufcwd)) {
      {
#line 553
      tmp___8 = unmeta((char const   *)(pathbuf + curglobdata.gd_pathbufcwd));
#line 553
      tmp___9 = (char const   *)tmp___8;
      }
    } else {
#line 553
      tmp___9 = ".";
    }
    {
#line 553
    fn___0 = (char *)tmp___9;
#line 554
    dirs = ! (! q->next);
#line 555
    tmp___10 = opendir((char const   *)fn___0);
#line 555
    lock = tmp___10;
#line 556
    subdirs = (char *)((void *)0);
#line 557
    subdirlen = 0;
    }
#line 559
    if ((unsigned long )lock == (unsigned long )((void *)0)) {
#line 560
      return;
    }
    {
#line 561
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 561
      fn___0 = zreaddir(lock, 1);
      }
#line 561
      if (fn___0) {
#line 561
        if (! (! errflag)) {
#line 561
          goto while_break;
        }
      } else {
#line 561
        goto while_break;
      }
#line 563
      if (! dirs) {
#line 563
        if (! curglobdata.gd_colonmod) {
#line 563
          if (glob_pre) {
            {
#line 563
            tmp___11 = strpfx((char const   *)glob_pre, (char const   *)fn___0);
            }
#line 563
            if (tmp___11) {
#line 563
              goto _L___0;
            } else {
#line 566
              goto while_continue;
            }
          } else
          _L___0: /* CIL Label */ 
#line 563
          if (glob_suf) {
            {
#line 563
            tmp___12 = strsfx(glob_suf, fn___0);
            }
#line 563
            if (! tmp___12) {
#line 566
              goto while_continue;
            }
          }
        }
      }
      {
#line 567
      errsfound = errssofar;
#line 568
      tmp___23 = pattry(p, fn___0);
      }
#line 568
      if (tmp___23) {
#line 570
        if (pbcwdsav == curglobdata.gd_pathbufcwd) {
          {
#line 570
          tmp___14 = strlen((char const   *)fn___0);
          }
#line 570
          if ((tmp___14 + (size_t )pathpos) - (size_t )curglobdata.gd_pathbufcwd >= 4096UL) {
            {
#line 576
            tmp___13 = unmeta((char const   *)(pathbuf + curglobdata.gd_pathbufcwd));
#line 576
            err___0 = lchdir((char const   *)tmp___13, & ds, 0);
            }
#line 577
            if (err___0 == -1) {
#line 578
              goto while_break;
            }
#line 579
            if (err___0) {
              {
#line 580
              zerr("current directory lost during glob");
              }
#line 581
              goto while_break;
            }
#line 583
            curglobdata.gd_pathbufcwd = pathpos;
          }
        }
#line 585
        if (dirs) {
#line 603
          if (errsfound > errssofar) {
#line 604
            forceerrs = errsfound - 1;
            {
#line 605
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 605
              if (! (forceerrs >= errssofar)) {
#line 605
                goto while_break___0;
              }
              {
#line 606
              errsfound = errssofar;
#line 607
              tmp___15 = pattry(p, fn___0);
              }
#line 607
              if (! tmp___15) {
#line 608
                goto while_break___0;
              }
#line 609
              forceerrs = errsfound - 1;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 611
            errsfound = forceerrs + 1;
#line 612
            forceerrs = -1;
          }
#line 614
          if (closure) {
            {
#line 618
            tmp___20 = statfullpath((char const   *)fn___0, & buf___7, ! q->follow);
            }
#line 618
            if (tmp___20) {
              {
#line 619
              tmp___17 = __errno_location();
              }
#line 619
              if (*tmp___17 != 2) {
                {
#line 619
                tmp___18 = __errno_location();
                }
#line 619
                if (*tmp___18 != 4) {
                  {
#line 619
                  tmp___19 = __errno_location();
                  }
#line 619
                  if (*tmp___19 != 20) {
#line 619
                    if (! errflag) {
                      {
#line 621
                      tmp___16 = __errno_location();
#line 621
                      zwarn("%e: %s", *tmp___16, fn___0);
                      }
                    }
                  }
                }
              }
#line 623
              goto while_continue;
            }
#line 625
            if (! ((buf___7.st_mode & 61440U) == 16384U)) {
#line 626
              goto while_continue;
            }
          }
          {
#line 628
          tmp___21 = strlen((char const   *)fn___0);
#line 628
          l___0 = (int )(tmp___21 + 1UL);
#line 629
          tmp___22 = hrealloc(subdirs, (size_t )subdirlen, (unsigned long )(subdirlen + l___0) + sizeof(int ));
#line 629
          subdirs = (char *)tmp___22;
#line 631
          strcpy((char */* __restrict  */)(subdirs + subdirlen), (char const   */* __restrict  */)fn___0);
#line 632
          subdirlen += l___0;
#line 634
          memcpy((void */* __restrict  */)(subdirs + subdirlen), (void const   */* __restrict  */)((char *)(& errsfound)),
                 sizeof(int ));
#line 636
          subdirlen = (int )((unsigned long )subdirlen + sizeof(int ));
          }
        } else {
          {
#line 639
          insert(fn___0, 1);
          }
#line 640
          if (shortcircuit) {
#line 640
            if (shortcircuit == curglobdata.gd_matchct) {
              {
#line 641
              closedir(lock);
              }
#line 642
              return;
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 647
    closedir(lock);
    }
#line 648
    if (subdirs) {
#line 649
      oppos___0 = pathpos;
#line 651
      fn___0 = subdirs;
      {
#line 651
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 651
        if (! ((unsigned long )fn___0 < (unsigned long )(subdirs + subdirlen))) {
#line 651
          goto while_break___1;
        }
        {
#line 652
        tmp___24 = strlen((char const   *)fn___0);
#line 652
        l___1 = (int )tmp___24;
#line 653
        addpath(fn___0, l___1);
#line 654
        fn___0 += l___1 + 1;
#line 655
        memcpy((void */* __restrict  */)((char *)(& errsfound)), (void const   */* __restrict  */)fn___0,
               sizeof(int ));
#line 656
        fn___0 += sizeof(int );
        }
#line 658
        if (q->closure) {
#line 658
          tmp___25 = q;
        } else {
#line 658
          tmp___25 = q->next;
        }
        {
#line 658
        scanner(tmp___25, shortcircuit);
        }
#line 659
        if (shortcircuit) {
#line 659
          if (shortcircuit == curglobdata.gd_matchct) {
#line 660
            return;
          }
        }
#line 661
        pathpos = oppos___0;
#line 661
        *(pathbuf + pathpos) = (char )'\000';
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 663
      hrealloc(subdirs, (size_t )subdirlen, (size_t )0);
      }
    }
  }
#line 666
  if (pbcwdsav < curglobdata.gd_pathbufcwd) {
    {
#line 667
    tmp___26 = restoredir(& ds);
    }
#line 667
    if (tmp___26) {
      {
#line 668
      zerr("current directory lost during glob");
      }
    }
    {
#line 669
    zsfree(ds.dirname);
    }
#line 670
    if (ds.dirfd >= 0) {
      {
#line 671
      close(ds.dirfd);
      }
    }
#line 672
    curglobdata.gd_pathbufcwd = pbcwdsav;
  }
#line 674
  return;
}
}
#line 680 "/tmp/zsh-5.4.2/Src/glob.c"
static Complist parsecomplist(char *instr___0 ) 
{ 
  Patprog p1 ;
  Complist l1 ;
  char *str ;
  int compflags ;
  int tmp ;
  int shortglob ;
  int follow ;
  int tmp___0 ;
  void *tmp___1 ;
  Complist tmp___2 ;
  int pdflag ;
  void *tmp___3 ;
  Complist tmp___4 ;
  int ef ;
  void *tmp___5 ;
  Complist tmp___6 ;
  Complist tmp___7 ;
  int tmp___8 ;

  {
#line 686
  if (curglobdata.gd_gf_noglobdots) {
#line 686
    tmp = 17;
  } else {
#line 686
    tmp = 1;
  }
#line 686
  compflags = tmp;
#line 688
  if ((int )*(instr___0 + 0) == -121) {
#line 688
    if ((int )*(instr___0 + 1) == -121) {
#line 689
      shortglob = 0;
#line 690
      if ((int )*(instr___0 + 2) == 47) {
#line 690
        goto _L;
      } else
#line 690
      if ((int )*(instr___0 + 2) == -121) {
#line 690
        if ((int )*(instr___0 + 3) == 47) {
#line 690
          goto _L;
        } else {
#line 690
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 690
        shortglob = (int )opts[65];
#line 690
        if (shortglob) {
          _L: /* CIL Label */ 
#line 696
          follow = (int )*(instr___0 + 2) == -121;
#line 701
          if (shortglob) {
#line 701
            tmp___0 = 1;
          } else {
#line 701
            tmp___0 = 3;
          }
          {
#line 701
          instr___0 += tmp___0 + follow;
#line 704
          tmp___1 = zhalloc(sizeof(*l1));
#line 704
          l1 = (Complist )tmp___1;
#line 705
          tmp___2 = parsecomplist(instr___0);
#line 705
          l1->next = tmp___2;
          }
#line 705
          if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 706
            errflag |= 1;
#line 707
            return ((Complist )((void *)0));
          }
          {
#line 709
          l1->pat = patcompile((char *)((void *)0), compflags | 4, (char **)((void *)0));
#line 710
          l1->closure = 1;
#line 711
          l1->follow = follow;
          }
#line 712
          return (l1);
        }
      }
    }
  }
#line 717
  str = instr___0;
#line 717
  if ((int )*str == (int )zpc_special[5]) {
    {
#line 717
    tmp___8 = skipparens((char)-120, (char)-118, & str);
    }
#line 717
    if (tmp___8) {
#line 717
      goto _L___4;
    } else
#line 717
    if ((int )*str == (int )zpc_special[11]) {
#line 717
      if ((int )*(str + -2) == 47) {
        {
#line 720
        instr___0 ++;
#line 721
        p1 = patcompile(instr___0, compflags, & instr___0);
        }
#line 721
        if (! p1) {
#line 722
          return ((Complist )((void *)0));
        }
#line 723
        if ((int )*(instr___0 + 0) == 47) {
#line 723
          if ((int )*(instr___0 + 1) == -118) {
#line 723
            if ((int )*(instr___0 + 2) == -124) {
#line 724
              pdflag = 0;
#line 726
              instr___0 += 3;
#line 727
              if ((int )*instr___0 == -124) {
#line 728
                pdflag = 1;
#line 729
                instr___0 ++;
              }
              {
#line 731
              tmp___3 = zhalloc(sizeof(*l1));
#line 731
              l1 = (Complist )tmp___3;
#line 732
              l1->pat = p1;
              }
#line 734
              if (*((char *)p1 + p1->startoff)) {
#line 734
                l1->closure = 1 + pdflag;
              } else {
#line 734
                l1->closure = 0;
              }
              {
#line 735
              l1->follow = 0;
#line 736
              l1->next = parsecomplist(instr___0);
              }
#line 737
              if (l1->pat) {
#line 737
                tmp___4 = l1;
              } else {
#line 737
                tmp___4 = (Complist )((void *)0);
              }
#line 737
              return (tmp___4);
            }
          }
        }
      } else {
#line 717
        goto _L___4;
      }
    } else {
#line 717
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
    {
#line 741
    p1 = patcompile(instr___0, compflags | 2, & instr___0);
    }
#line 741
    if (! p1) {
#line 742
      return ((Complist )((void *)0));
    }
#line 744
    if ((int )*instr___0 == 47) {
#line 744
      goto _L___1;
    } else
#line 744
    if (! *instr___0) {
      _L___1: /* CIL Label */ 
      {
#line 745
      ef = (int )*instr___0 == 47;
#line 747
      tmp___5 = zhalloc(sizeof(*l1));
#line 747
      l1 = (Complist )tmp___5;
#line 748
      l1->pat = p1;
#line 749
      l1->closure = 0;
      }
#line 750
      if (ef) {
        {
#line 750
        tmp___6 = parsecomplist(instr___0 + 1);
#line 750
        l1->next = tmp___6;
        }
      } else {
#line 750
        l1->next = (Complist )((void *)0);
      }
#line 751
      if (ef) {
#line 751
        if (! l1->next) {
#line 751
          tmp___7 = (Complist )((void *)0);
        } else {
#line 751
          tmp___7 = l1;
        }
      } else {
#line 751
        tmp___7 = l1;
      }
#line 751
      return (tmp___7);
    }
  }
#line 754
  errflag |= 1;
#line 755
  return ((Complist )((void *)0));
}
}
#line 761 "/tmp/zsh-5.4.2/Src/glob.c"
static Complist parsepat(char *str ) 
{ 
  long assert ;
  int ignore ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  Complist tmp___2 ;

  {
  {
#line 767
  patcompstart();
  }
#line 772
  if ((int )*str == (int )zpc_special[5]) {
#line 772
    if ((int )*(str + 1) == (int )zpc_special[11]) {
#line 772
      goto _L;
    } else {
#line 772
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 772
  if ((int )*str == (int )zpc_special[18]) {
#line 772
    if ((int )*(str + 1) == -120) {
#line 772
      if ((int )*(str + 2) == (int )zpc_special[11]) {
        _L: /* CIL Label */ 
#line 775
        if ((int )*str == -120) {
#line 775
          tmp = 2;
        } else {
#line 775
          tmp = 3;
        }
        {
#line 775
        str += tmp;
#line 776
        tmp___0 = patgetglobflags(& str, & assert, & ignore);
        }
#line 776
        if (! tmp___0) {
#line 777
          return ((Complist )((void *)0));
        }
      }
    }
  }
#line 781
  if (! pathbuf) {
    {
#line 782
    curglobdata.gd_pathbufsz = 4097;
#line 782
    tmp___1 = zalloc((size_t )curglobdata.gd_pathbufsz);
#line 782
    pathbuf = (char *)tmp___1;
    }
  }
#line 784
  if ((int )*str == 47) {
#line 785
    str ++;
#line 786
    *(pathbuf + 0) = (char )'/';
#line 787
    pathpos = 1;
#line 787
    *(pathbuf + pathpos) = (char )'\000';
  } else {
#line 789
    pathpos = 0;
#line 789
    *(pathbuf + pathpos) = (char )'\000';
  }
  {
#line 791
  tmp___2 = parsecomplist(str);
  }
#line 791
  return (tmp___2);
}
}
#line 797 "/tmp/zsh-5.4.2/Src/glob.c"
static off_t qgetnum(char **s ) 
{ 
  off_t v ;
  char *tmp ;

  {
#line 800
  v = (off_t )0;
#line 802
  if (! ((int )typtab[(unsigned char )*(*s)] & 1)) {
    {
#line 803
    zerr("number expected");
    }
#line 804
    return ((off_t )0);
  }
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if (! ((int )typtab[(unsigned char )*(*s)] & 1)) {
#line 806
      goto while_break;
    }
#line 807
    tmp = *s;
#line 807
    (*s) ++;
#line 807
    v = (v * 10L + (off_t )*tmp) - 48L;
  }
  while_break: /* CIL Label */ ;
  }
#line 808
  return (v);
}
}
#line 814 "/tmp/zsh-5.4.2/Src/glob.c"
static zlong qgetmodespec(char **s ) 
{ 
  zlong yes ;
  zlong no ;
  zlong val ;
  zlong mask ;
  zlong t ;
  char *p ;
  char c ;
  char how ;
  char end ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 817
  yes = (zlong )0;
#line 817
  no = (zlong )0;
#line 818
  p = *s;
#line 820
  c = *p;
#line 820
  if ((int )c == 61) {
#line 822
    end = (char)0;
#line 823
    c = (char)0;
  } else
#line 820
  if ((int )c == -115) {
#line 822
    end = (char)0;
#line 823
    c = (char)0;
  } else
#line 820
  if ((int )c == 43) {
#line 822
    end = (char)0;
#line 823
    c = (char)0;
  } else
#line 820
  if ((int )c == 45) {
#line 822
    end = (char)0;
#line 823
    c = (char)0;
  } else
#line 820
  if ((int )c == 63) {
#line 822
    end = (char)0;
#line 823
    c = (char)0;
  } else
#line 820
  if ((int )c == -105) {
#line 822
    end = (char)0;
#line 823
    c = (char)0;
  } else
#line 820
  if ((int )c >= 48) {
#line 820
    if ((int )c <= 55) {
#line 822
      end = (char)0;
#line 823
      c = (char)0;
    } else {
#line 820
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 825
    if ((int )c == 60) {
#line 825
      end = (char )'>';
    } else {
#line 825
      if ((int )c == 91) {
#line 825
        tmp___3 = ']';
      } else {
#line 825
        if ((int )c == 123) {
#line 825
          tmp___2 = '}';
        } else {
#line 825
          if ((int )c == -108) {
#line 825
            tmp___1 = -107;
          } else {
#line 825
            if ((int )c == -111) {
#line 825
              tmp___0 = -110;
            } else {
#line 825
              if ((int )c == -113) {
#line 825
                tmp = -112;
              } else {
#line 825
                tmp = (int )c;
              }
#line 825
              tmp___0 = tmp;
            }
#line 825
            tmp___1 = tmp___0;
          }
#line 825
          tmp___2 = tmp___1;
        }
#line 825
        tmp___3 = tmp___2;
      }
#line 825
      end = (char )tmp___3;
    }
#line 831
    p ++;
  }
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 834
    mask = (zlong )0;
    {
#line 835
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 835
      c = *p;
#line 835
      if ((int )c == 117) {
#line 835
        goto _L___0;
      } else
#line 835
      if ((int )c == 103) {
#line 835
        goto _L___0;
      } else
#line 835
      if ((int )c == 111) {
#line 835
        goto _L___0;
      } else
#line 835
      if ((int )c == 97) {
        _L___0: /* CIL Label */ 
#line 835
        if (! end) {
#line 835
          goto while_break___0;
        }
      } else {
#line 835
        goto while_break___0;
      }
      {
#line 837
      if ((int )c == 111) {
#line 837
        goto case_111;
      }
#line 838
      if ((int )c == 103) {
#line 838
        goto case_103;
      }
#line 839
      if ((int )c == 117) {
#line 839
        goto case_117;
      }
#line 840
      if ((int )c == 97) {
#line 840
        goto case_97;
      }
#line 836
      goto switch_break;
      case_111: /* CIL Label */ 
#line 837
      mask |= 519L;
#line 837
      goto switch_break;
      case_103: /* CIL Label */ 
#line 838
      mask |= 1080L;
#line 838
      goto switch_break;
      case_117: /* CIL Label */ 
#line 839
      mask |= 2496L;
#line 839
      goto switch_break;
      case_97: /* CIL Label */ 
#line 840
      mask |= 4095L;
#line 840
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 842
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 844
    if ((int )c == 43) {
#line 844
      how = c;
    } else
#line 844
    if ((int )c == 45) {
#line 844
      how = c;
    } else {
#line 844
      how = (char )'=';
    }
#line 845
    if ((int )c == 43) {
#line 846
      p ++;
    } else
#line 845
    if ((int )c == 45) {
#line 846
      p ++;
    } else
#line 845
    if ((int )c == 61) {
#line 846
      p ++;
    } else
#line 845
    if ((int )c == -115) {
#line 846
      p ++;
    }
#line 847
    val = (zlong )0;
#line 848
    if (mask) {
      {
#line 849
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 849
        tmp___4 = p;
#line 849
        p ++;
#line 849
        c = *tmp___4;
#line 849
        if ((int )c != 44) {
#line 849
          if (! ((int )c != (int )end)) {
#line 849
            goto while_break___1;
          }
        } else {
#line 849
          goto while_break___1;
        }
        {
#line 851
        if ((int )c == 120) {
#line 851
          goto case_120;
        }
#line 852
        if ((int )c == 119) {
#line 852
          goto case_119;
        }
#line 853
        if ((int )c == 114) {
#line 853
          goto case_114;
        }
#line 854
        if ((int )c == 115) {
#line 854
          goto case_115;
        }
#line 855
        if ((int )c == 116) {
#line 855
          goto case_116;
        }
#line 857
        if ((int )c == 55) {
#line 857
          goto case_55;
        }
#line 857
        if ((int )c == 54) {
#line 857
          goto case_55;
        }
#line 857
        if ((int )c == 53) {
#line 857
          goto case_55;
        }
#line 857
        if ((int )c == 52) {
#line 857
          goto case_55;
        }
#line 857
        if ((int )c == 51) {
#line 857
          goto case_55;
        }
#line 857
        if ((int )c == 50) {
#line 857
          goto case_55;
        }
#line 857
        if ((int )c == 49) {
#line 857
          goto case_55;
        }
#line 857
        if ((int )c == 48) {
#line 857
          goto case_55;
        }
#line 861
        goto switch_default;
        case_120: /* CIL Label */ 
#line 851
        val |= 73L;
#line 851
        goto switch_break___0;
        case_119: /* CIL Label */ 
#line 852
        val |= 146L;
#line 852
        goto switch_break___0;
        case_114: /* CIL Label */ 
#line 853
        val |= 292L;
#line 853
        goto switch_break___0;
        case_115: /* CIL Label */ 
#line 854
        val |= 3072L;
#line 854
        goto switch_break___0;
        case_116: /* CIL Label */ 
#line 855
        val |= 512L;
#line 855
        goto switch_break___0;
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 858
        t = (zlong )c - 48L;
#line 859
        val |= (t | (t << 3)) | (t << 6);
#line 860
        goto switch_break___0;
        switch_default: /* CIL Label */ 
        {
#line 862
        zerr("invalid mode specification");
        }
#line 863
        return ((zlong )0);
        switch_break___0: /* CIL Label */ ;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 866
      if ((int )how == 61) {
#line 867
        yes |= val & mask;
#line 868
        val = ~ val;
      } else
#line 866
      if ((int )how == 43) {
#line 867
        yes |= val & mask;
#line 868
        val = ~ val;
      }
#line 870
      if ((int )how == 61) {
#line 871
        no |= val & mask;
      } else
#line 870
      if ((int )how == 45) {
#line 871
        no |= val & mask;
      }
    } else
#line 872
    if (end) {
#line 872
      if ((int )c == (int )end) {
        {
#line 897
        zerr("invalid mode specification");
        }
#line 898
        return ((zlong )0);
      } else {
#line 872
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 872
    if ((int )c != 44) {
#line 872
      if (c) {
#line 873
        t = (zlong )4095;
        {
#line 874
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 874
          c = *p;
#line 874
          if (! ((int )c == 63)) {
#line 874
            if (! ((int )c == -105)) {
#line 874
              if ((int )c >= 48) {
#line 874
                if (! ((int )c <= 55)) {
#line 874
                  goto while_break___2;
                }
              } else {
#line 874
                goto while_break___2;
              }
            }
          }
#line 876
          if ((int )c == 63) {
#line 877
            t = (t << 3) | 7L;
#line 878
            val <<= 3;
          } else
#line 876
          if ((int )c == -105) {
#line 877
            t = (t << 3) | 7L;
#line 878
            val <<= 3;
          } else {
#line 880
            t <<= 3;
#line 881
            val = (val << 3) | ((zlong )c - 48L);
          }
#line 883
          p ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 885
        if (end) {
#line 885
          if ((int )c != (int )end) {
#line 885
            if ((int )c != 44) {
              {
#line 886
              zerr("invalid mode specification");
              }
#line 887
              return ((zlong )0);
            }
          }
        }
#line 889
        if ((int )how == 61) {
#line 890
          yes = (yes & ~ t) | val;
#line 891
          no = (no & ~ t) | (~ val & ~ t);
        } else
#line 892
        if ((int )how == 43) {
#line 893
          yes |= val;
        } else {
#line 895
          no |= val;
        }
      } else {
        {
#line 897
        zerr("invalid mode specification");
        }
#line 898
        return ((zlong )0);
      }
    } else {
      {
#line 897
      zerr("invalid mode specification");
      }
#line 898
      return ((zlong )0);
    }
#line 833
    if (end) {
#line 833
      if (! ((int )c != (int )end)) {
#line 833
        goto while_break;
      }
    } else {
#line 833
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 902
  *s = p;
#line 903
  return ((yes & 4095L) | ((no & 4095L) << 12));
}
}
#line 906 "/tmp/zsh-5.4.2/Src/glob.c"
static int gmatchcmp(Gmatch a , Gmatch b ) 
{ 
  int i ;
  off_t r ;
  struct globsort *s ;
  char **asortstrp ;
  char **bsortstrp ;
  int tmp ;
  int tmp___0 ;
  char *aptr ;
  char *bptr ;
  int slasha ;
  int slashb ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 910
  r = 0L;
#line 912
  asortstrp = (char **)((void *)0);
#line 912
  bsortstrp = (char **)((void *)0);
#line 914
  i = curglobdata.gd_gf_nsorts;
#line 914
  s = curglobdata.gd_gf_sortlist;
  {
#line 914
  while (1) {
    while_continue: /* CIL Label */ ;
#line 914
    if (! i) {
#line 914
      goto while_break;
    }
    {
#line 916
    if ((s->tp & ~ (8 << 10)) == 1) {
#line 916
      goto case_1;
    }
#line 920
    if ((s->tp & ~ (8 << 10)) == 2) {
#line 920
      goto case_2;
    }
#line 945
    if ((s->tp & ~ (8 << 10)) == 4) {
#line 945
      goto case_4;
    }
#line 956
    if ((s->tp & ~ (8 << 10)) == 8) {
#line 956
      goto case_8;
    }
#line 959
    if ((s->tp & ~ (8 << 10)) == 8 << 1) {
#line 959
      goto case_exp;
    }
#line 966
    if ((s->tp & ~ (8 << 10)) == 8 << 2) {
#line 966
      goto case_exp___0;
    }
#line 973
    if ((s->tp & ~ (8 << 10)) == 8 << 3) {
#line 973
      goto case_exp___1;
    }
#line 980
    if ((s->tp & ~ (8 << 10)) == 8 << 4) {
#line 980
      goto case_exp___2;
    }
#line 983
    if ((s->tp & ~ (8 << 10)) == 8 << 5) {
#line 983
      goto case_exp___3;
    }
#line 986
    if ((s->tp & ~ (8 << 10)) == (8 << 1) << 5) {
#line 986
      goto case_exp___4;
    }
#line 993
    if ((s->tp & ~ (8 << 10)) == (8 << 2) << 5) {
#line 993
      goto case_exp___5;
    }
#line 1000
    if ((s->tp & ~ (8 << 10)) == (8 << 3) << 5) {
#line 1000
      goto case_exp___6;
    }
#line 1007
    if ((s->tp & ~ (8 << 10)) == (8 << 4) << 5) {
#line 1007
      goto case_exp___7;
    }
#line 915
    goto switch_break;
    case_1: /* CIL Label */ 
#line 917
    if (curglobdata.gd_gf_numsort) {
#line 917
      tmp = 2;
    } else {
#line 917
      tmp = 0;
    }
    {
#line 917
    tmp___0 = zstrcmp((char const   *)b->uname, (char const   *)a->uname, tmp);
#line 917
    r = (off_t )tmp___0;
    }
#line 919
    goto switch_break;
    case_2: /* CIL Label */ 
#line 922
    aptr = a->name;
#line 922
    bptr = b->name;
#line 923
    slasha = 0;
#line 923
    slashb = 0;
    {
#line 925
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 925
      if (*aptr) {
#line 925
        if (! ((int )*aptr == (int )*bptr)) {
#line 925
          goto while_break___0;
        }
      } else {
#line 925
        goto while_break___0;
      }
#line 926
      aptr ++;
#line 926
      bptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 928
    if (! *aptr) {
#line 928
      goto _L;
    } else
#line 928
    if (! *bptr) {
      _L: /* CIL Label */ 
#line 928
      if ((unsigned long )aptr > (unsigned long )a->name) {
#line 928
        if ((int )*(aptr + -1) == 47) {
#line 929
          aptr --;
#line 929
          bptr --;
        }
      }
    }
#line 930
    if (*aptr) {
      {
#line 931
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 931
        if (! *(aptr + 1)) {
#line 931
          goto while_break___1;
        }
#line 932
        if ((int )*aptr == 47) {
#line 933
          slasha = 1;
#line 934
          goto while_break___1;
        }
#line 931
        aptr ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 936
    if (*bptr) {
      {
#line 937
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 937
        if (! *(bptr + 1)) {
#line 937
          goto while_break___2;
        }
#line 938
        if ((int )*bptr == 47) {
#line 939
          slashb = 1;
#line 940
          goto while_break___2;
        }
#line 937
        bptr ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 942
    r = (off_t )(slasha - slashb);
#line 944
    goto switch_break;
    case_4: /* CIL Label */ 
#line 946
    if (! asortstrp) {
#line 947
      asortstrp = a->sortstrs;
#line 948
      bsortstrp = b->sortstrs;
    } else {
#line 950
      asortstrp ++;
#line 951
      bsortstrp ++;
    }
#line 953
    if (curglobdata.gd_gf_numsort) {
#line 953
      tmp___1 = 2;
    } else {
#line 953
      tmp___1 = 0;
    }
    {
#line 953
    tmp___2 = zstrcmp((char const   *)*bsortstrp, (char const   *)*asortstrp, tmp___1);
#line 953
    r = (off_t )tmp___2;
    }
#line 955
    goto switch_break;
    case_8: /* CIL Label */ 
#line 957
    r = b->size - a->size;
#line 958
    goto switch_break;
    case_exp: /* CIL Label */ 
#line 960
    r = a->atime - b->atime;
#line 962
    if (! r) {
#line 963
      r = a->ansec - b->ansec;
    }
#line 965
    goto switch_break;
    case_exp___0: /* CIL Label */ 
#line 967
    r = a->mtime - b->mtime;
#line 969
    if (! r) {
#line 970
      r = a->mnsec - b->mnsec;
    }
#line 972
    goto switch_break;
    case_exp___1: /* CIL Label */ 
#line 974
    r = a->ctime - b->ctime;
#line 976
    if (! r) {
#line 977
      r = a->cnsec - b->cnsec;
    }
#line 979
    goto switch_break;
    case_exp___2: /* CIL Label */ 
#line 981
    r = b->links - a->links;
#line 982
    goto switch_break;
    case_exp___3: /* CIL Label */ 
#line 984
    r = b->_size - a->_size;
#line 985
    goto switch_break;
    case_exp___4: /* CIL Label */ 
#line 987
    r = a->_atime - b->_atime;
#line 989
    if (! r) {
#line 990
      r = a->_ansec - b->_ansec;
    }
#line 992
    goto switch_break;
    case_exp___5: /* CIL Label */ 
#line 994
    r = a->_mtime - b->_mtime;
#line 996
    if (! r) {
#line 997
      r = a->_mnsec - b->_mnsec;
    }
#line 999
    goto switch_break;
    case_exp___6: /* CIL Label */ 
#line 1001
    r = a->_ctime - b->_ctime;
#line 1003
    if (! r) {
#line 1004
      r = a->_cnsec - b->_cnsec;
    }
#line 1006
    goto switch_break;
    case_exp___7: /* CIL Label */ 
#line 1008
    r = b->_links - a->_links;
#line 1009
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1011
    if (r) {
#line 1012
      if (s->tp & (8 << 10)) {
#line 1012
        if (r < 0L) {
#line 1012
          tmp___3 = 1;
        } else {
#line 1012
          tmp___3 = -1;
        }
#line 1012
        tmp___5 = tmp___3;
      } else {
#line 1012
        if (r > 0L) {
#line 1012
          tmp___4 = 1;
        } else {
#line 1012
          tmp___4 = -1;
        }
#line 1012
        tmp___5 = tmp___4;
      }
#line 1012
      return (tmp___5);
    }
#line 914
    i --;
#line 914
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1016
  return (0);
}
}
#line 1025 "/tmp/zsh-5.4.2/Src/glob.c"
static struct qual *dup_qual_list(struct qual *orig , struct qual **lastp ) 
{ 
  struct qual *qfirst ;
  struct qual *qlast ;
  struct qual *qnew ;
  void *tmp ;
  struct qual *tmp___0 ;

  {
#line 1027
  qfirst = (struct qual *)((void *)0);
#line 1027
  qlast = (struct qual *)((void *)0);
  {
#line 1029
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1029
    if (! orig) {
#line 1029
      goto while_break;
    }
    {
#line 1030
    tmp = zhalloc(sizeof(struct qual ));
#line 1030
    qnew = (struct qual *)tmp;
#line 1031
    *qnew = *orig;
#line 1032
    tmp___0 = (struct qual *)((void *)0);
#line 1032
    qnew->or = tmp___0;
#line 1032
    qnew->next = tmp___0;
    }
#line 1034
    if (! qfirst) {
#line 1035
      qfirst = qnew;
    }
#line 1036
    if (qlast) {
#line 1037
      qlast->next = qnew;
    }
#line 1038
    qlast = qnew;
#line 1040
    orig = orig->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1043
  if (lastp) {
#line 1044
    *lastp = qlast;
  }
#line 1045
  return (qfirst);
}
}
#line 1055 "/tmp/zsh-5.4.2/Src/glob.c"
static char *glob_exec_string(char **sp___0 ) 
{ 
  char sav ;
  char *tt ;
  char *sdata ;
  char *s ;
  int plus ;

  {
#line 1058
  s = *sp___0;
#line 1061
  if ((int )*(s + -1) == 43) {
    {
#line 1062
    plus = 0;
#line 1063
    tt = itype_end((char const   *)s, 1 << 7, 0);
    }
#line 1064
    if ((unsigned long )tt == (unsigned long )s) {
      {
#line 1066
      zerr("missing identifier after `+\'");
      }
#line 1067
      return ((char *)((void *)0));
    }
  } else {
    {
#line 1070
    tt = get_strarg(s, & plus);
    }
#line 1071
    if (! *tt) {
      {
#line 1073
      zerr("missing end of string");
      }
#line 1074
      return ((char *)((void *)0));
    }
  }
  {
#line 1078
  sav = *tt;
#line 1079
  *tt = (char )'\000';
#line 1080
  sdata = dupstring((char const   *)(s + plus));
#line 1081
  untokenize(sdata);
#line 1082
  *tt = sav;
  }
#line 1083
  if (sav) {
#line 1084
    *sp___0 = tt + plus;
  } else {
#line 1086
    *sp___0 = tt;
  }
#line 1088
  return (sdata);
}
}
#line 1095 "/tmp/zsh-5.4.2/Src/glob.c"
static void insert_glob_match(LinkList list , LinkNode next___0 , char *data ) 
{ 
  LinkNode added ;
  char *tmp ;
  LinkNode added___0 ;
  char *tmp___0 ;

  {
#line 1098
  if (curglobdata.gd_gf_pre_words) {
#line 1100
    added = (curglobdata.gd_gf_pre_words)->list.first;
    {
#line 1100
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1100
      if (! added) {
#line 1100
        goto while_break;
      }
      {
#line 1101
      tmp = dupstring((char const   *)added->dat);
#line 1101
      next___0 = insertlinknode(list, next___0, (void *)tmp);
#line 1100
      added = added->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1105
  next___0 = insertlinknode(list, next___0, (void *)data);
  }
#line 1107
  if (curglobdata.gd_gf_post_words) {
#line 1109
    added___0 = (curglobdata.gd_gf_post_words)->list.first;
    {
#line 1109
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1109
      if (! added___0) {
#line 1109
        goto while_break___0;
      }
      {
#line 1110
      tmp___0 = dupstring((char const   *)added___0->dat);
#line 1110
      next___0 = insertlinknode(list, next___0, (void *)tmp___0);
#line 1109
      added___0 = added___0->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1113
  return;
}
}
#line 1128 "/tmp/zsh-5.4.2/Src/glob.c"
int checkglobqual(char *str , int sl , int nobareglob , char **sp___0 ) 
{ 
  char *s ;
  int paren ;
  int ret ;

  {
#line 1132
  ret = 1;
#line 1134
  if ((int )*(str + (sl - 1)) != -118) {
#line 1135
    return (0);
  }
#line 1141
  paren = 0;
#line 1142
  s = (str + sl) - 2;
  {
#line 1142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1142
    if (*s) {
#line 1142
      if (! ((int )*s != -120)) {
#line 1142
        if (! paren) {
#line 1142
          goto while_break;
        }
      }
    } else {
#line 1142
      goto while_break;
    }
    {
#line 1144
    if ((int )*s == -118) {
#line 1144
      goto case_neg_118;
    }
#line 1146
    if ((int )*s == -114) {
#line 1146
      goto case_neg_114;
    }
#line 1150
    if ((int )*s == -104) {
#line 1150
      goto case_neg_104;
    }
#line 1154
    if ((int )*s == -120) {
#line 1154
      goto case_neg_120;
    }
#line 1143
    goto switch_break;
    case_neg_118: /* CIL Label */ 
#line 1145
    paren ++;
    case_neg_114: /* CIL Label */ 
#line 1147
    if (! zpc_disables[2]) {
#line 1148
      nobareglob = 1;
    }
#line 1149
    goto switch_break;
    case_neg_104: /* CIL Label */ 
#line 1151
    if (opts[53]) {
#line 1151
      if (! zpc_disables[4]) {
#line 1152
        nobareglob = 1;
      }
    }
#line 1153
    goto switch_break;
    case_neg_120: /* CIL Label */ 
#line 1155
    paren --;
#line 1156
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1158
    if ((unsigned long )s == (unsigned long )str) {
#line 1159
      goto while_break;
    }
#line 1142
    s --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1161
  if ((int )*s != -120) {
#line 1162
    return (0);
  }
#line 1163
  if (opts[53]) {
#line 1163
    if (! zpc_disables[11]) {
#line 1163
      if ((int )*(s + 1) == -124) {
#line 1164
        if ((int )*(s + 2) != 113) {
#line 1165
          return (0);
        }
#line 1166
        ret = 2;
      } else {
#line 1163
        goto _L___0;
      }
    } else {
#line 1163
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1167
  if (nobareglob) {
#line 1168
    return (0);
  }
#line 1170
  if (sp___0) {
#line 1171
    *sp___0 = s;
  }
#line 1173
  return (ret);
}
}
#line 1181 "/tmp/zsh-5.4.2/Src/glob.c"
void zglob(LinkList list , LinkNode np , int nountok ) 
{ 
  struct qual *qo ;
  struct qual *qn ;
  struct qual *ql ;
  LinkNode node ;
  char *str ;
  int sl ;
  Complist q ;
  char *ostr ;
  int first ;
  int end ;
  struct globdata saved ;
  int nobareglob ;
  int shortcircuit ;
  int tmp ;
  sigset_t oset ;
  struct qual *newquals ;
  char *s ;
  int sense ;
  int qualsfound ;
  off_t data ;
  char *sdata ;
  char *newcolonmod ;
  char *ptr___0 ;
  int (*func)(char * , Statptr  , off_t  , char * ) ;
  size_t tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  __uid_t tmp___4 ;
  __gid_t tmp___5 ;
  char sav ;
  char *tt ;
  int arglen ;
  struct passwd *pw ;
  char sav___0 ;
  char *tt___0 ;
  int arglen___0 ;
  struct group *gr ;
  char const   *s_saved ;
  sigset_t oset___0 ;
  int tmp___6 ;
  int t ;
  char *send ;
  sigset_t oset___1 ;
  sigset_t oset___2 ;
  char *tmp___7 ;
  sigset_t oset___3 ;
  sigset_t oset___4 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tt___1 ;
  char *os ;
  struct value v ;
  sigset_t oset___5 ;
  int tmp___10 ;
  char *tt___2 ;
  LinkList *words ;
  LinkList *tmp___11 ;
  sigset_t oset___6 ;
  void *tmp___12 ;
  sigset_t oset___7 ;
  struct qual *qorhead ;
  struct qual *qortail ;
  struct qual *qfirst ;
  struct qual *qlast ;
  int islast ;
  int tmp___13 ;
  struct qual *tmp___14 ;
  sigset_t oset___8 ;
  void *tmp___15 ;
  sigset_t oset___9 ;
  char *tmp___16 ;
  int nexecs ;
  struct globsort *sortp ;
  struct globsort *lastsortp ;
  Gmatch gmptr ;
  Gmatch tmpptr ;
  int iexec ;
  void *tmp___17 ;
  Eprog prog ;
  int ef ;
  int lv ;
  char *tmp___18 ;
  char *tmp___19 ;
  int dummy___0 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  sigset_t oset___10 ;

  {
#line 1185
  node = np->prev;
#line 1189
  ostr = (char *)np->dat;
#line 1191
  first = 0;
#line 1191
  end = -1;
#line 1194
  nobareglob = ! opts[19];
#line 1195
  shortcircuit = 0;
#line 1198
  if (! opts[59]) {
#line 1198
    goto _L;
  } else {
    {
#line 1198
    tmp = haswilds(ostr);
    }
#line 1198
    if (tmp) {
#line 1198
      if (! opts[52]) {
        _L: /* CIL Label */ 
#line 1199
        if (! nountok) {
          {
#line 1200
          untokenize(ostr);
          }
        }
#line 1201
        return;
      }
    } else {
#line 1198
      goto _L;
    }
  }
  {
#line 1203
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1203
    queueing_enabled ++;
#line 1203
    memcpy((void */* __restrict  */)(& saved), (void const   */* __restrict  */)(& curglobdata),
           sizeof(struct globdata ));
#line 1203
    saved.gd_pathpos = pathpos;
#line 1203
    saved.gd_pathbuf = pathbuf;
#line 1203
    saved.gd_glob_pre = glob_pre;
#line 1203
    saved.gd_glob_suf = glob_suf;
#line 1203
    pathbuf = (char *)((void *)0);
    }
    {
#line 1203
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1203
      queueing_enabled --;
#line 1203
      if (! queueing_enabled) {
        {
#line 1203
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1203
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1203
            if (! (queue_front != queue_rear)) {
#line 1203
              goto while_break___2;
            }
            {
#line 1203
            queue_front = (queue_front + 1) % 128;
#line 1203
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1203
            zhandler(signal_queue[queue_front]);
#line 1203
            signal_setmask(oset);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1203
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1203
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1203
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1205
  str = dupstring((char const   *)ostr);
#line 1206
  uremnode(list, np);
#line 1209
  curglobdata.gd_quals = (struct qual *)((void *)0);
#line 1215
  curglobdata.gd_qualorct = 0;
#line 1215
  curglobdata.gd_qualct = curglobdata.gd_qualorct;
#line 1220
  curglobdata.gd_colonmod = (char *)((void *)0);
#line 1222
  curglobdata.gd_gf_nullglob = (int )opts[122];
#line 1223
  curglobdata.gd_gf_markdirs = (int )opts[114];
#line 1224
  curglobdata.gd_gf_follow = 0;
#line 1224
  curglobdata.gd_gf_listtypes = curglobdata.gd_gf_follow;
#line 1225
  curglobdata.gd_gf_noglobdots = ! opts[64];
#line 1226
  curglobdata.gd_gf_numsort = (int )opts[123];
#line 1227
  curglobdata.gd_gf_nsorts = 0;
#line 1227
  curglobdata.gd_gf_sorts = curglobdata.gd_gf_nsorts;
#line 1228
  curglobdata.gd_gf_post_words = (LinkList )((void *)0);
#line 1228
  curglobdata.gd_gf_pre_words = curglobdata.gd_gf_post_words;
  }
  {
#line 1231
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1231
    if (! (! nobareglob)) {
#line 1231
      if (opts[53]) {
#line 1231
        if (! (! zpc_disables[11])) {
#line 1231
          goto while_break___3;
        }
      } else {
#line 1231
        goto while_break___3;
      }
    }
    {
#line 1262
    ql = (struct qual *)((void *)0);
#line 1262
    qn = ql;
#line 1262
    qo = qn;
#line 1262
    newquals = qo;
#line 1264
    tmp___0 = strlen((char const   *)str);
#line 1264
    sl = (int )tmp___0;
#line 1265
    qualsfound = checkglobqual(str, sl, nobareglob, & s);
    }
#line 1265
    if (! qualsfound) {
#line 1266
      goto while_break___3;
    }
#line 1269
    nobareglob = 1;
#line 1270
    sense = 0;
#line 1272
    data = (off_t )0;
#line 1273
    sdata = (char *)((void *)0);
#line 1274
    newcolonmod = (char *)((void *)0);
#line 1276
    *(str + (sl - 1)) = (char)0;
#line 1277
    tmp___1 = s;
#line 1277
    s ++;
#line 1277
    *tmp___1 = (char)0;
#line 1278
    if (qualsfound == 2) {
#line 1279
      s += 2;
    }
#line 1280
    ptr___0 = s;
    {
#line 1280
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1280
      if (! *ptr___0) {
#line 1280
        goto while_break___4;
      }
#line 1281
      if ((int )*ptr___0 == -101) {
#line 1282
        *ptr___0 = (char )'-';
      }
#line 1280
      ptr___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1283
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1283
      if (*s) {
#line 1283
        if (! (! newcolonmod)) {
#line 1283
          goto while_break___5;
        }
      } else {
#line 1283
        goto while_break___5;
      }
#line 1284
      func = (int (*)(char * , Statptr  , off_t  , char * ))0;
#line 1285
      if ((int )*s == 44) {
#line 1287
        s ++;
#line 1288
        sense = 0;
#line 1289
        if (curglobdata.gd_qualct) {
          {
#line 1290
          tmp___2 = hcalloc(sizeof(*qn));
#line 1290
          qn = (struct qual *)tmp___2;
#line 1291
          qo->or = qn;
#line 1292
          qo = qn;
#line 1293
          (curglobdata.gd_qualorct) ++;
#line 1294
          curglobdata.gd_qualct = 0;
#line 1295
          ql = (struct qual *)((void *)0);
          }
        }
      } else {
#line 1298
        tmp___3 = s;
#line 1298
        s ++;
        {
#line 1299
        if ((int )*tmp___3 == 58) {
#line 1299
          goto case_58;
        }
#line 1311
        if ((int )*tmp___3 == 94) {
#line 1311
          goto case_94;
        }
#line 1311
        if ((int )*tmp___3 == -122) {
#line 1311
          goto case_94;
        }
#line 1317
        if ((int )*tmp___3 == -101) {
#line 1317
          goto case_neg_101;
        }
#line 1317
        if ((int )*tmp___3 == 45) {
#line 1317
          goto case_neg_101;
        }
#line 1321
        if ((int )*tmp___3 == 64) {
#line 1321
          goto case_64;
        }
#line 1326
        if ((int )*tmp___3 == 61) {
#line 1326
          goto case_61;
        }
#line 1326
        if ((int )*tmp___3 == -115) {
#line 1326
          goto case_61;
        }
#line 1330
        if ((int )*tmp___3 == 112) {
#line 1330
          goto case_112;
        }
#line 1334
        if ((int )*tmp___3 == 47) {
#line 1334
          goto case_47;
        }
#line 1338
        if ((int )*tmp___3 == 46) {
#line 1338
          goto case_46;
        }
#line 1342
        if ((int )*tmp___3 == 37) {
#line 1342
          goto case_37;
        }
#line 1352
        if ((int )*tmp___3 == -121) {
#line 1352
          goto case_neg_121;
        }
#line 1356
        if ((int )*tmp___3 == 82) {
#line 1356
          goto case_82;
        }
#line 1361
        if ((int )*tmp___3 == 87) {
#line 1361
          goto case_87;
        }
#line 1366
        if ((int )*tmp___3 == 88) {
#line 1366
          goto case_88;
        }
#line 1371
        if ((int )*tmp___3 == 65) {
#line 1371
          goto case_65;
        }
#line 1375
        if ((int )*tmp___3 == 73) {
#line 1375
          goto case_73;
        }
#line 1379
        if ((int )*tmp___3 == 69) {
#line 1379
          goto case_69;
        }
#line 1383
        if ((int )*tmp___3 == 114) {
#line 1383
          goto case_114;
        }
#line 1388
        if ((int )*tmp___3 == 119) {
#line 1388
          goto case_119;
        }
#line 1393
        if ((int )*tmp___3 == 120) {
#line 1393
          goto case_120;
        }
#line 1398
        if ((int )*tmp___3 == 115) {
#line 1398
          goto case_115;
        }
#line 1403
        if ((int )*tmp___3 == 83) {
#line 1403
          goto case_83;
        }
#line 1408
        if ((int )*tmp___3 == 116) {
#line 1408
          goto case_116;
        }
#line 1412
        if ((int )*tmp___3 == 100) {
#line 1412
          goto case_100;
        }
#line 1418
        if ((int )*tmp___3 == 108) {
#line 1418
          goto case_108;
        }
#line 1423
        if ((int )*tmp___3 == 85) {
#line 1423
          goto case_85;
        }
#line 1428
        if ((int )*tmp___3 == 71) {
#line 1428
          goto case_71;
        }
#line 1433
        if ((int )*tmp___3 == 117) {
#line 1433
          goto case_117;
        }
#line 1474
        if ((int )*tmp___3 == 103) {
#line 1474
          goto case_103;
        }
#line 1514
        if ((int )*tmp___3 == 102) {
#line 1514
          goto case_102;
        }
#line 1519
        if ((int )*tmp___3 == 70) {
#line 1519
          goto case_70;
        }
#line 1522
        if ((int )*tmp___3 == 77) {
#line 1522
          goto case_77;
        }
#line 1527
        if ((int )*tmp___3 == 84) {
#line 1527
          goto case_84;
        }
#line 1532
        if ((int )*tmp___3 == 78) {
#line 1532
          goto case_78;
        }
#line 1536
        if ((int )*tmp___3 == 68) {
#line 1536
          goto case_68;
        }
#line 1540
        if ((int )*tmp___3 == 110) {
#line 1540
          goto case_110;
        }
#line 1544
        if ((int )*tmp___3 == 89) {
#line 1544
          goto case_89;
        }
#line 1561
        if ((int )*tmp___3 == 97) {
#line 1561
          goto case_97;
        }
#line 1566
        if ((int )*tmp___3 == 109) {
#line 1566
          goto case_109;
        }
#line 1571
        if ((int )*tmp___3 == 99) {
#line 1571
          goto case_99;
        }
#line 1576
        if ((int )*tmp___3 == 76) {
#line 1576
          goto case_76;
        }
#line 1618
        if ((int )*tmp___3 == 79) {
#line 1618
          goto case_79;
        }
#line 1618
        if ((int )*tmp___3 == 111) {
#line 1618
          goto case_79;
        }
#line 1674
        if ((int )*tmp___3 == 101) {
#line 1674
          goto case_101___0;
        }
#line 1674
        if ((int )*tmp___3 == 43) {
#line 1674
          goto case_101___0;
        }
#line 1689
        if ((int )*tmp___3 == -111) {
#line 1689
          goto case_neg_111;
        }
#line 1689
        if ((int )*tmp___3 == 91) {
#line 1689
          goto case_neg_111;
        }
#line 1707
        if ((int )*tmp___3 == 80) {
#line 1707
          goto case_80;
        }
#line 1721
        goto switch_default___0;
        case_58: /* CIL Label */ 
        {
#line 1302
        newcolonmod = s - 1;
#line 1303
        untokenize(newcolonmod);
        }
#line 1304
        if (curglobdata.gd_colonmod) {
          {
#line 1306
          curglobdata.gd_colonmod = dyncat((char const   *)newcolonmod, (char const   *)curglobdata.gd_colonmod);
          }
        } else {
#line 1308
          curglobdata.gd_colonmod = newcolonmod;
        }
#line 1309
        goto switch_break;
        case_94: /* CIL Label */ 
        case_neg_122: /* CIL Label */ 
#line 1314
        sense ^= 1;
#line 1315
        goto switch_break;
        case_neg_101: /* CIL Label */ 
        case_45: /* CIL Label */ 
#line 1319
        sense ^= 2;
#line 1320
        goto switch_break;
        case_64: /* CIL Label */ 
#line 1323
        func = & qualislnk;
#line 1324
        goto switch_break;
        case_61: /* CIL Label */ 
        case_neg_115: /* CIL Label */ 
#line 1328
        func = & qualissock;
#line 1329
        goto switch_break;
        case_112: /* CIL Label */ 
#line 1332
        func = & qualisfifo;
#line 1333
        goto switch_break;
        case_47: /* CIL Label */ 
#line 1336
        func = & qualisdir;
#line 1337
        goto switch_break;
        case_46: /* CIL Label */ 
#line 1340
        func = & qualisreg;
#line 1341
        goto switch_break;
        case_37: /* CIL Label */ 
#line 1345
        if ((int )*s == 98) {
#line 1346
          s ++;
#line 1346
          func = & qualisblk;
        } else
#line 1347
        if ((int )*s == 99) {
#line 1348
          s ++;
#line 1348
          func = & qualischr;
        } else {
#line 1350
          func = & qualisdev;
        }
#line 1351
        goto switch_break;
        case_neg_121: /* CIL Label */ 
#line 1354
        func = & qualiscom;
#line 1355
        goto switch_break;
        case_82: /* CIL Label */ 
#line 1358
        func = & qualflags;
#line 1359
        data = (off_t )4;
#line 1360
        goto switch_break;
        case_87: /* CIL Label */ 
#line 1363
        func = & qualflags;
#line 1364
        data = (off_t )2;
#line 1365
        goto switch_break;
        case_88: /* CIL Label */ 
#line 1368
        func = & qualflags;
#line 1369
        data = (off_t )1;
#line 1370
        goto switch_break;
        case_65: /* CIL Label */ 
#line 1372
        func = & qualflags;
#line 1373
        data = (off_t )32;
#line 1374
        goto switch_break;
        case_73: /* CIL Label */ 
#line 1376
        func = & qualflags;
#line 1377
        data = (off_t )16;
#line 1378
        goto switch_break;
        case_69: /* CIL Label */ 
#line 1380
        func = & qualflags;
#line 1381
        data = (off_t )8;
#line 1382
        goto switch_break;
        case_114: /* CIL Label */ 
#line 1385
        func = & qualflags;
#line 1386
        data = (off_t )256;
#line 1387
        goto switch_break;
        case_119: /* CIL Label */ 
#line 1390
        func = & qualflags;
#line 1391
        data = (off_t )128;
#line 1392
        goto switch_break;
        case_120: /* CIL Label */ 
#line 1395
        func = & qualflags;
#line 1396
        data = (off_t )64;
#line 1397
        goto switch_break;
        case_115: /* CIL Label */ 
#line 1400
        func = & qualflags;
#line 1401
        data = (off_t )2048;
#line 1402
        goto switch_break;
        case_83: /* CIL Label */ 
#line 1405
        func = & qualflags;
#line 1406
        data = (off_t )1024;
#line 1407
        goto switch_break;
        case_116: /* CIL Label */ 
#line 1409
        func = & qualflags;
#line 1410
        data = (off_t )512;
#line 1411
        goto switch_break;
        case_100: /* CIL Label */ 
        {
#line 1415
        func = & qualdev;
#line 1416
        data = qgetnum(& s);
        }
#line 1417
        goto switch_break;
        case_108: /* CIL Label */ 
#line 1420
        func = & qualnlink;
#line 1421
        curglobdata.gd_amc = -1;
#line 1422
        goto getrange;
        case_85: /* CIL Label */ 
        {
#line 1425
        func = & qualuid;
#line 1426
        tmp___4 = geteuid();
#line 1426
        data = (off_t )tmp___4;
        }
#line 1427
        goto switch_break;
        case_71: /* CIL Label */ 
        {
#line 1430
        func = & qualgid;
#line 1431
        tmp___5 = getegid();
#line 1431
        data = (off_t )tmp___5;
        }
#line 1432
        goto switch_break;
        case_117: /* CIL Label */ 
#line 1435
        func = & qualuid;
#line 1437
        if ((int )typtab[(unsigned char )*s] & 1) {
          {
#line 1438
          data = qgetnum(& s);
          }
        } else {
          {
#line 1445
          tt = get_strarg(s, & arglen);
          }
#line 1446
          if (! *tt) {
            {
#line 1447
            zerr("missing delimiter for \'u\' glob qualifier");
#line 1448
            data = (off_t )0;
            }
          } else {
            {
#line 1452
            sav = *tt;
#line 1453
            *tt = (char )'\000';
#line 1455
            pw = getpwnam((char const   *)(s + arglen));
            }
#line 1455
            if (pw) {
#line 1456
              data = (off_t )pw->pw_uid;
            } else {
              {
#line 1458
              zerr("unknown user");
#line 1459
              data = (off_t )0;
              }
            }
#line 1461
            *tt = sav;
#line 1467
            if (sav) {
#line 1468
              s = tt + arglen;
            } else {
#line 1470
              s = tt;
            }
          }
        }
#line 1473
        goto switch_break;
        case_103: /* CIL Label */ 
#line 1476
        func = & qualgid;
#line 1478
        if ((int )typtab[(unsigned char )*s] & 1) {
          {
#line 1479
          data = qgetnum(& s);
          }
        } else {
          {
#line 1485
          tt___0 = get_strarg(s, & arglen___0);
          }
#line 1486
          if (! *tt___0) {
            {
#line 1487
            zerr("missing delimiter for \'g\' glob qualifier");
#line 1488
            data = (off_t )0;
            }
          } else {
            {
#line 1492
            sav___0 = *tt___0;
#line 1493
            *tt___0 = (char )'\000';
#line 1495
            gr = getgrnam((char const   *)(s + arglen___0));
            }
#line 1495
            if (gr) {
#line 1496
              data = (off_t )gr->gr_gid;
            } else {
              {
#line 1498
              zerr("unknown group");
#line 1499
              data = (off_t )0;
              }
            }
#line 1501
            *tt___0 = sav___0;
#line 1507
            if (sav___0) {
#line 1508
              s = tt___0 + arglen___0;
            } else {
#line 1510
              s = tt___0;
            }
          }
        }
#line 1513
        goto switch_break;
        case_102: /* CIL Label */ 
        {
#line 1516
        func = & qualmodeflags;
#line 1517
        data = qgetmodespec(& s);
        }
#line 1518
        goto switch_break;
        case_70: /* CIL Label */ 
#line 1520
        func = & qualnonemptydir;
#line 1521
        goto switch_break;
        case_77: /* CIL Label */ 
#line 1524
        curglobdata.gd_gf_markdirs = ! (sense & 1);
#line 1524
        if (curglobdata.gd_gf_markdirs) {
#line 1525
          curglobdata.gd_gf_follow = sense & 2;
        }
#line 1526
        goto switch_break;
        case_84: /* CIL Label */ 
#line 1529
        curglobdata.gd_gf_listtypes = ! (sense & 1);
#line 1529
        if (curglobdata.gd_gf_listtypes) {
#line 1530
          curglobdata.gd_gf_follow = sense & 2;
        }
#line 1531
        goto switch_break;
        case_78: /* CIL Label */ 
#line 1534
        curglobdata.gd_gf_nullglob = ! (sense & 1);
#line 1535
        goto switch_break;
        case_68: /* CIL Label */ 
#line 1538
        curglobdata.gd_gf_noglobdots = sense & 1;
#line 1539
        goto switch_break;
        case_110: /* CIL Label */ 
#line 1542
        curglobdata.gd_gf_numsort = ! (sense & 1);
#line 1543
        goto switch_break;
        case_89: /* CIL Label */ 
#line 1547
        s_saved = (char const   *)s;
#line 1548
        shortcircuit = ! (sense & 1);
#line 1549
        if (shortcircuit) {
          {
#line 1551
          data = qgetnum(& s);
#line 1552
          shortcircuit = (int )data;
          }
#line 1552
          if ((off_t )shortcircuit != data) {
            {
#line 1554
            zerr("value too big: Y%s", s_saved);
            }
            {
#line 1555
            while (1) {
              while_continue___6: /* CIL Label */ ;
              {
#line 1555
              queueing_enabled ++;
#line 1555
              zfree((void *)pathbuf, curglobdata.gd_pathbufsz);
#line 1555
              memcpy((void */* __restrict  */)(& curglobdata), (void const   */* __restrict  */)(& saved),
                     sizeof(struct globdata ));
#line 1555
              pathpos = saved.gd_pathpos;
#line 1555
              pathbuf = saved.gd_pathbuf;
#line 1555
              glob_pre = saved.gd_glob_pre;
#line 1555
              glob_suf = saved.gd_glob_suf;
              }
              {
#line 1555
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 1555
                queueing_enabled --;
#line 1555
                if (! queueing_enabled) {
                  {
#line 1555
                  while (1) {
                    while_continue___8: /* CIL Label */ ;
                    {
#line 1555
                    while (1) {
                      while_continue___9: /* CIL Label */ ;
#line 1555
                      if (! (queue_front != queue_rear)) {
#line 1555
                        goto while_break___9;
                      }
                      {
#line 1555
                      queue_front = (queue_front + 1) % 128;
#line 1555
                      oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 1555
                      zhandler(signal_queue[queue_front]);
#line 1555
                      signal_setmask(oset___0);
                      }
                    }
                    while_break___9: /* CIL Label */ ;
                    }
#line 1555
                    goto while_break___8;
                  }
                  while_break___8: /* CIL Label */ ;
                  }
                }
#line 1555
                goto while_break___7;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 1555
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 1556
            return;
          }
        }
#line 1559
        goto switch_break;
        case_97: /* CIL Label */ 
#line 1563
        curglobdata.gd_amc = 0;
#line 1564
        func = & qualtime;
#line 1565
        goto getrange;
        case_109: /* CIL Label */ 
#line 1568
        curglobdata.gd_amc = 1;
#line 1569
        func = & qualtime;
#line 1570
        goto getrange;
        case_99: /* CIL Label */ 
#line 1573
        curglobdata.gd_amc = 2;
#line 1574
        func = & qualtime;
#line 1575
        goto getrange;
        case_76: /* CIL Label */ 
#line 1578
        func = & qualsize;
#line 1579
        curglobdata.gd_amc = -1;
#line 1581
        curglobdata.gd_units = 0;
#line 1582
        if ((int )*s == 112) {
#line 1583
          curglobdata.gd_units = 1;
#line 1583
          s ++;
        } else
#line 1582
        if ((int )*s == 80) {
#line 1583
          curglobdata.gd_units = 1;
#line 1583
          s ++;
        } else
#line 1584
        if ((int )*s == 107) {
#line 1585
          curglobdata.gd_units = 2;
#line 1585
          s ++;
        } else
#line 1584
        if ((int )*s == 75) {
#line 1585
          curglobdata.gd_units = 2;
#line 1585
          s ++;
        } else
#line 1586
        if ((int )*s == 109) {
#line 1587
          curglobdata.gd_units = 3;
#line 1587
          s ++;
        } else
#line 1586
        if ((int )*s == 77) {
#line 1587
          curglobdata.gd_units = 3;
#line 1587
          s ++;
        } else
#line 1589
        if ((int )*s == 103) {
#line 1590
          curglobdata.gd_units = 4;
#line 1590
          s ++;
        } else
#line 1589
        if ((int )*s == 71) {
#line 1590
          curglobdata.gd_units = 4;
#line 1590
          s ++;
        } else
#line 1591
        if ((int )*s == 116) {
#line 1592
          curglobdata.gd_units = 5;
#line 1592
          s ++;
        } else
#line 1591
        if ((int )*s == 84) {
#line 1592
          curglobdata.gd_units = 5;
#line 1592
          s ++;
        }
        getrange: 
#line 1596
        if (curglobdata.gd_amc >= 0) {
#line 1597
          curglobdata.gd_units = 0;
#line 1598
          if ((int )*s == 104) {
#line 1599
            curglobdata.gd_units = 1;
#line 1599
            s ++;
          } else
#line 1600
          if ((int )*s == 109) {
#line 1601
            curglobdata.gd_units = 2;
#line 1601
            s ++;
          } else
#line 1602
          if ((int )*s == 119) {
#line 1603
            curglobdata.gd_units = 3;
#line 1603
            s ++;
          } else
#line 1604
          if ((int )*s == 77) {
#line 1605
            curglobdata.gd_units = 4;
#line 1605
            s ++;
          } else
#line 1606
          if ((int )*s == 115) {
#line 1607
            curglobdata.gd_units = 5;
#line 1607
            s ++;
          } else
#line 1608
          if ((int )*s == 100) {
#line 1609
            s ++;
          }
        }
#line 1612
        if ((int )*s == 43) {
#line 1612
          curglobdata.gd_range = 1;
        } else {
#line 1612
          if ((int )*s == 45) {
#line 1612
            tmp___6 = -1;
          } else
#line 1612
          if ((int )*s == -101) {
#line 1612
            tmp___6 = -1;
          } else {
#line 1612
            tmp___6 = 0;
          }
#line 1612
          curglobdata.gd_range = tmp___6;
        }
#line 1612
        if (curglobdata.gd_range) {
#line 1613
          s ++;
        }
        {
#line 1614
        data = qgetnum(& s);
        }
#line 1615
        goto switch_break;
        case_79: /* CIL Label */ 
        case_111: /* CIL Label */ 
#line 1623
        if (curglobdata.gd_gf_nsorts == 12) {
          {
#line 1624
          zerr("too many glob sort specifiers");
          }
          {
#line 1625
          while (1) {
            while_continue___10: /* CIL Label */ ;
            {
#line 1625
            queueing_enabled ++;
#line 1625
            zfree((void *)pathbuf, curglobdata.gd_pathbufsz);
#line 1625
            memcpy((void */* __restrict  */)(& curglobdata), (void const   */* __restrict  */)(& saved),
                   sizeof(struct globdata ));
#line 1625
            pathpos = saved.gd_pathpos;
#line 1625
            pathbuf = saved.gd_pathbuf;
#line 1625
            glob_pre = saved.gd_glob_pre;
#line 1625
            glob_suf = saved.gd_glob_suf;
            }
            {
#line 1625
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 1625
              queueing_enabled --;
#line 1625
              if (! queueing_enabled) {
                {
#line 1625
                while (1) {
                  while_continue___12: /* CIL Label */ ;
                  {
#line 1625
                  while (1) {
                    while_continue___13: /* CIL Label */ ;
#line 1625
                    if (! (queue_front != queue_rear)) {
#line 1625
                      goto while_break___13;
                    }
                    {
#line 1625
                    queue_front = (queue_front + 1) % 128;
#line 1625
                    oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 1625
                    zhandler(signal_queue[queue_front]);
#line 1625
                    signal_setmask(oset___1);
                    }
                  }
                  while_break___13: /* CIL Label */ ;
                  }
#line 1625
                  goto while_break___12;
                }
                while_break___12: /* CIL Label */ ;
                }
              }
#line 1625
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 1625
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 1626
          return;
        }
#line 1630
        send = s + 1;
        {
#line 1632
        if ((int )*s == 110) {
#line 1632
          goto case_110___0;
        }
#line 1633
        if ((int )*s == 76) {
#line 1633
          goto case_76___0;
        }
#line 1634
        if ((int )*s == 108) {
#line 1634
          goto case_108___0;
        }
#line 1635
        if ((int )*s == 97) {
#line 1635
          goto case_97___0;
        }
#line 1636
        if ((int )*s == 109) {
#line 1636
          goto case_109___0;
        }
#line 1637
        if ((int )*s == 99) {
#line 1637
          goto case_99___0;
        }
#line 1638
        if ((int )*s == 100) {
#line 1638
          goto case_100___0;
        }
#line 1639
        if ((int )*s == 78) {
#line 1639
          goto case_78___0;
        }
#line 1641
        if ((int )*s == 43) {
#line 1641
          goto case_43;
        }
#line 1641
        if ((int )*s == 101) {
#line 1641
          goto case_43;
        }
#line 1652
        goto switch_default;
        case_110___0: /* CIL Label */ 
#line 1632
        t = 1;
#line 1632
        goto switch_break___0;
        case_76___0: /* CIL Label */ 
#line 1633
        t = 8;
#line 1633
        goto switch_break___0;
        case_108___0: /* CIL Label */ 
#line 1634
        t = 8 << 4;
#line 1634
        goto switch_break___0;
        case_97___0: /* CIL Label */ 
#line 1635
        t = 8 << 1;
#line 1635
        goto switch_break___0;
        case_109___0: /* CIL Label */ 
#line 1636
        t = 8 << 2;
#line 1636
        goto switch_break___0;
        case_99___0: /* CIL Label */ 
#line 1637
        t = 8 << 3;
#line 1637
        goto switch_break___0;
        case_100___0: /* CIL Label */ 
#line 1638
        t = 2;
#line 1638
        goto switch_break___0;
        case_78___0: /* CIL Label */ 
#line 1639
        t = 8 << 11;
#line 1639
        goto switch_break___0;
        case_43: /* CIL Label */ 
        case_101: /* CIL Label */ 
        {
#line 1643
        t = 4;
#line 1644
        tmp___7 = glob_exec_string(& send);
#line 1644
        curglobdata.gd_gf_sortlist[curglobdata.gd_gf_nsorts].exec = tmp___7;
        }
#line 1644
        if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
          {
#line 1647
          while (1) {
            while_continue___14: /* CIL Label */ ;
            {
#line 1647
            queueing_enabled ++;
#line 1647
            zfree((void *)pathbuf, curglobdata.gd_pathbufsz);
#line 1647
            memcpy((void */* __restrict  */)(& curglobdata), (void const   */* __restrict  */)(& saved),
                   sizeof(struct globdata ));
#line 1647
            pathpos = saved.gd_pathpos;
#line 1647
            pathbuf = saved.gd_pathbuf;
#line 1647
            glob_pre = saved.gd_glob_pre;
#line 1647
            glob_suf = saved.gd_glob_suf;
            }
            {
#line 1647
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 1647
              queueing_enabled --;
#line 1647
              if (! queueing_enabled) {
                {
#line 1647
                while (1) {
                  while_continue___16: /* CIL Label */ ;
                  {
#line 1647
                  while (1) {
                    while_continue___17: /* CIL Label */ ;
#line 1647
                    if (! (queue_front != queue_rear)) {
#line 1647
                      goto while_break___17;
                    }
                    {
#line 1647
                    queue_front = (queue_front + 1) % 128;
#line 1647
                    oset___2 = signal_setmask(signal_mask_queue[queue_front]);
#line 1647
                    zhandler(signal_queue[queue_front]);
#line 1647
                    signal_setmask(oset___2);
                    }
                  }
                  while_break___17: /* CIL Label */ ;
                  }
#line 1647
                  goto while_break___16;
                }
                while_break___16: /* CIL Label */ ;
                }
              }
#line 1647
              goto while_break___15;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 1647
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 1648
          return;
        }
#line 1650
        goto switch_break___0;
        switch_default: /* CIL Label */ 
        {
#line 1653
        zerr("unknown sort specifier");
        }
        {
#line 1654
        while (1) {
          while_continue___18: /* CIL Label */ ;
          {
#line 1654
          queueing_enabled ++;
#line 1654
          zfree((void *)pathbuf, curglobdata.gd_pathbufsz);
#line 1654
          memcpy((void */* __restrict  */)(& curglobdata), (void const   */* __restrict  */)(& saved),
                 sizeof(struct globdata ));
#line 1654
          pathpos = saved.gd_pathpos;
#line 1654
          pathbuf = saved.gd_pathbuf;
#line 1654
          glob_pre = saved.gd_glob_pre;
#line 1654
          glob_suf = saved.gd_glob_suf;
          }
          {
#line 1654
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 1654
            queueing_enabled --;
#line 1654
            if (! queueing_enabled) {
              {
#line 1654
              while (1) {
                while_continue___20: /* CIL Label */ ;
                {
#line 1654
                while (1) {
                  while_continue___21: /* CIL Label */ ;
#line 1654
                  if (! (queue_front != queue_rear)) {
#line 1654
                    goto while_break___21;
                  }
                  {
#line 1654
                  queue_front = (queue_front + 1) % 128;
#line 1654
                  oset___3 = signal_setmask(signal_mask_queue[queue_front]);
#line 1654
                  zhandler(signal_queue[queue_front]);
#line 1654
                  signal_setmask(oset___3);
                  }
                }
                while_break___21: /* CIL Label */ ;
                }
#line 1654
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
            }
#line 1654
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 1654
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
#line 1655
        return;
        switch_break___0: /* CIL Label */ ;
        }
#line 1657
        if (sense & 2) {
#line 1657
          if (t & ((((8 | (8 << 1)) | (8 << 2)) | (8 << 3)) | (8 << 4))) {
#line 1659
            t <<= 5;
          }
        }
#line 1660
        if (t != 4) {
#line 1661
          if (curglobdata.gd_gf_sorts & t) {
            {
#line 1662
            zerr("doubled sort specifier");
            }
            {
#line 1663
            while (1) {
              while_continue___22: /* CIL Label */ ;
              {
#line 1663
              queueing_enabled ++;
#line 1663
              zfree((void *)pathbuf, curglobdata.gd_pathbufsz);
#line 1663
              memcpy((void */* __restrict  */)(& curglobdata), (void const   */* __restrict  */)(& saved),
                     sizeof(struct globdata ));
#line 1663
              pathpos = saved.gd_pathpos;
#line 1663
              pathbuf = saved.gd_pathbuf;
#line 1663
              glob_pre = saved.gd_glob_pre;
#line 1663
              glob_suf = saved.gd_glob_suf;
              }
              {
#line 1663
              while (1) {
                while_continue___23: /* CIL Label */ ;
#line 1663
                queueing_enabled --;
#line 1663
                if (! queueing_enabled) {
                  {
#line 1663
                  while (1) {
                    while_continue___24: /* CIL Label */ ;
                    {
#line 1663
                    while (1) {
                      while_continue___25: /* CIL Label */ ;
#line 1663
                      if (! (queue_front != queue_rear)) {
#line 1663
                        goto while_break___25;
                      }
                      {
#line 1663
                      queue_front = (queue_front + 1) % 128;
#line 1663
                      oset___4 = signal_setmask(signal_mask_queue[queue_front]);
#line 1663
                      zhandler(signal_queue[queue_front]);
#line 1663
                      signal_setmask(oset___4);
                      }
                    }
                    while_break___25: /* CIL Label */ ;
                    }
#line 1663
                    goto while_break___24;
                  }
                  while_break___24: /* CIL Label */ ;
                  }
                }
#line 1663
                goto while_break___23;
              }
              while_break___23: /* CIL Label */ ;
              }
#line 1663
              goto while_break___22;
            }
            while_break___22: /* CIL Label */ ;
            }
#line 1664
            return;
          }
        }
#line 1667
        curglobdata.gd_gf_sorts |= t;
#line 1668
        tmp___8 = curglobdata.gd_gf_nsorts;
#line 1668
        (curglobdata.gd_gf_nsorts) ++;
#line 1668
        if ((sense & 1) ^ ((int )*(s + -1) == 79)) {
#line 1668
          tmp___9 = 8 << 10;
        } else {
#line 1668
          tmp___9 = 0;
        }
#line 1668
        curglobdata.gd_gf_sortlist[tmp___8].tp = t | tmp___9;
#line 1670
        s = send;
#line 1671
        goto switch_break;
        case_101___0: /* CIL Label */ 
        case_43___0: /* CIL Label */ 
        {
#line 1678
        tt___1 = glob_exec_string(& s);
        }
#line 1680
        if ((unsigned long )tt___1 == (unsigned long )((void *)0)) {
#line 1681
          data = (off_t )0;
        } else {
#line 1683
          func = & qualsheval;
#line 1684
          sdata = tt___1;
        }
#line 1686
        goto switch_break;
        case_neg_111: /* CIL Label */ 
        case_91: /* CIL Label */ 
        {
#line 1691
        s --;
#line 1691
        os = s;
#line 1694
        v.isarr = 1;
#line 1695
        v.pm = (Param )((void *)0);
#line 1696
        v.end = -1;
#line 1697
        v.flags = 0;
#line 1698
        tmp___10 = getindex(& s, & v, 0);
        }
#line 1698
        if (tmp___10) {
#line 1698
          goto _L___0;
        } else
#line 1698
        if ((unsigned long )s == (unsigned long )os) {
          _L___0: /* CIL Label */ 
          {
#line 1699
          zerr("invalid subscript");
          }
          {
#line 1700
          while (1) {
            while_continue___26: /* CIL Label */ ;
            {
#line 1700
            queueing_enabled ++;
#line 1700
            zfree((void *)pathbuf, curglobdata.gd_pathbufsz);
#line 1700
            memcpy((void */* __restrict  */)(& curglobdata), (void const   */* __restrict  */)(& saved),
                   sizeof(struct globdata ));
#line 1700
            pathpos = saved.gd_pathpos;
#line 1700
            pathbuf = saved.gd_pathbuf;
#line 1700
            glob_pre = saved.gd_glob_pre;
#line 1700
            glob_suf = saved.gd_glob_suf;
            }
            {
#line 1700
            while (1) {
              while_continue___27: /* CIL Label */ ;
#line 1700
              queueing_enabled --;
#line 1700
              if (! queueing_enabled) {
                {
#line 1700
                while (1) {
                  while_continue___28: /* CIL Label */ ;
                  {
#line 1700
                  while (1) {
                    while_continue___29: /* CIL Label */ ;
#line 1700
                    if (! (queue_front != queue_rear)) {
#line 1700
                      goto while_break___29;
                    }
                    {
#line 1700
                    queue_front = (queue_front + 1) % 128;
#line 1700
                    oset___5 = signal_setmask(signal_mask_queue[queue_front]);
#line 1700
                    zhandler(signal_queue[queue_front]);
#line 1700
                    signal_setmask(oset___5);
                    }
                  }
                  while_break___29: /* CIL Label */ ;
                  }
#line 1700
                  goto while_break___28;
                }
                while_break___28: /* CIL Label */ ;
                }
              }
#line 1700
              goto while_break___27;
            }
            while_break___27: /* CIL Label */ ;
            }
#line 1700
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
#line 1701
          return;
        }
#line 1703
        first = v.start;
#line 1704
        end = v.end;
#line 1705
        goto switch_break;
        case_80: /* CIL Label */ 
        {
#line 1710
        tt___2 = glob_exec_string(& s);
        }
#line 1712
        if ((unsigned long )tt___2 != (unsigned long )((void *)0)) {
#line 1714
          if (sense & 1) {
#line 1714
            tmp___11 = & curglobdata.gd_gf_post_words;
          } else {
#line 1714
            tmp___11 = & curglobdata.gd_gf_pre_words;
          }
#line 1714
          words = tmp___11;
#line 1715
          if (! *words) {
            {
#line 1716
            *words = newlinklist();
            }
          }
          {
#line 1717
          insertlinknode(*words, (*words)->list.last, (void *)tt___2);
          }
        }
#line 1719
        goto switch_break;
        switch_default___0: /* CIL Label */ 
        {
#line 1722
        s --;
#line 1722
        untokenize(s);
#line 1723
        zerr("unknown file attribute: %c", (int )*s);
        }
        {
#line 1724
        while (1) {
          while_continue___30: /* CIL Label */ ;
          {
#line 1724
          queueing_enabled ++;
#line 1724
          zfree((void *)pathbuf, curglobdata.gd_pathbufsz);
#line 1724
          memcpy((void */* __restrict  */)(& curglobdata), (void const   */* __restrict  */)(& saved),
                 sizeof(struct globdata ));
#line 1724
          pathpos = saved.gd_pathpos;
#line 1724
          pathbuf = saved.gd_pathbuf;
#line 1724
          glob_pre = saved.gd_glob_pre;
#line 1724
          glob_suf = saved.gd_glob_suf;
          }
          {
#line 1724
          while (1) {
            while_continue___31: /* CIL Label */ ;
#line 1724
            queueing_enabled --;
#line 1724
            if (! queueing_enabled) {
              {
#line 1724
              while (1) {
                while_continue___32: /* CIL Label */ ;
                {
#line 1724
                while (1) {
                  while_continue___33: /* CIL Label */ ;
#line 1724
                  if (! (queue_front != queue_rear)) {
#line 1724
                    goto while_break___33;
                  }
                  {
#line 1724
                  queue_front = (queue_front + 1) % 128;
#line 1724
                  oset___6 = signal_setmask(signal_mask_queue[queue_front]);
#line 1724
                  zhandler(signal_queue[queue_front]);
#line 1724
                  signal_setmask(oset___6);
                  }
                }
                while_break___33: /* CIL Label */ ;
                }
#line 1724
                goto while_break___32;
              }
              while_break___32: /* CIL Label */ ;
              }
            }
#line 1724
            goto while_break___31;
          }
          while_break___31: /* CIL Label */ ;
          }
#line 1724
          goto while_break___30;
        }
        while_break___30: /* CIL Label */ ;
        }
#line 1725
        return;
        switch_break: /* CIL Label */ ;
        }
      }
#line 1728
      if (func) {
#line 1730
        if (! qn) {
          {
#line 1731
          tmp___12 = hcalloc(sizeof(*qn));
#line 1731
          qn = (struct qual *)tmp___12;
          }
        }
#line 1732
        if (ql) {
#line 1733
          ql->next = qn;
        }
#line 1734
        ql = qn;
#line 1735
        if (! newquals) {
#line 1736
          qo = qn;
#line 1736
          newquals = qo;
        }
#line 1737
        qn->func = func;
#line 1738
        qn->sense = sense;
#line 1739
        qn->data = data;
#line 1740
        qn->sdata = sdata;
#line 1741
        qn->range = curglobdata.gd_range;
#line 1742
        qn->units = curglobdata.gd_units;
#line 1743
        qn->amc = curglobdata.gd_amc;
#line 1745
        qn = (struct qual *)((void *)0);
#line 1746
        (curglobdata.gd_qualct) ++;
      }
#line 1748
      if (errflag) {
        {
#line 1749
        while (1) {
          while_continue___34: /* CIL Label */ ;
          {
#line 1749
          queueing_enabled ++;
#line 1749
          zfree((void *)pathbuf, curglobdata.gd_pathbufsz);
#line 1749
          memcpy((void */* __restrict  */)(& curglobdata), (void const   */* __restrict  */)(& saved),
                 sizeof(struct globdata ));
#line 1749
          pathpos = saved.gd_pathpos;
#line 1749
          pathbuf = saved.gd_pathbuf;
#line 1749
          glob_pre = saved.gd_glob_pre;
#line 1749
          glob_suf = saved.gd_glob_suf;
          }
          {
#line 1749
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 1749
            queueing_enabled --;
#line 1749
            if (! queueing_enabled) {
              {
#line 1749
              while (1) {
                while_continue___36: /* CIL Label */ ;
                {
#line 1749
                while (1) {
                  while_continue___37: /* CIL Label */ ;
#line 1749
                  if (! (queue_front != queue_rear)) {
#line 1749
                    goto while_break___37;
                  }
                  {
#line 1749
                  queue_front = (queue_front + 1) % 128;
#line 1749
                  oset___7 = signal_setmask(signal_mask_queue[queue_front]);
#line 1749
                  zhandler(signal_queue[queue_front]);
#line 1749
                  signal_setmask(oset___7);
                  }
                }
                while_break___37: /* CIL Label */ ;
                }
#line 1749
                goto while_break___36;
              }
              while_break___36: /* CIL Label */ ;
              }
            }
#line 1749
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
#line 1749
          goto while_break___34;
        }
        while_break___34: /* CIL Label */ ;
        }
#line 1750
        return;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1754
    if (curglobdata.gd_quals) {
#line 1754
      if (newquals) {
#line 1756
        if ((curglobdata.gd_quals)->or) {
#line 1756
          goto _L___1;
        } else
#line 1756
        if (newquals->or) {
          _L___1: /* CIL Label */ 
#line 1758
          qorhead = (struct qual *)((void *)0);
#line 1758
          qortail = (struct qual *)((void *)0);
#line 1765
          qn = newquals;
          {
#line 1765
          while (1) {
            while_continue___38: /* CIL Label */ ;
#line 1765
            if (! qn) {
#line 1765
              goto while_break___38;
            }
#line 1766
            qo = curglobdata.gd_quals;
            {
#line 1766
            while (1) {
              while_continue___39: /* CIL Label */ ;
#line 1766
              if (! qo) {
#line 1766
                goto while_break___39;
              }
#line 1768
              if (! qn->or) {
#line 1768
                if (! qo->or) {
#line 1768
                  tmp___13 = 1;
                } else {
#line 1768
                  tmp___13 = 0;
                }
              } else {
#line 1768
                tmp___13 = 0;
              }
#line 1768
              islast = tmp___13;
#line 1770
              if (islast) {
#line 1772
                qfirst = qn;
#line 1773
                qlast = qfirst;
                {
#line 1773
                while (1) {
                  while_continue___40: /* CIL Label */ ;
#line 1773
                  if (! qlast->next) {
#line 1773
                    goto while_break___40;
                  }
#line 1773
                  qlast = qlast->next;
                }
                while_break___40: /* CIL Label */ ;
                }
              } else {
                {
#line 1777
                qfirst = dup_qual_list(qn, & qlast);
                }
              }
#line 1779
              if (! qorhead) {
#line 1780
                qorhead = qfirst;
              }
#line 1781
              if (qortail) {
#line 1782
                qortail->or = qfirst;
              }
#line 1783
              qortail = qfirst;
#line 1785
              if (islast) {
#line 1785
                qlast->next = qo;
              } else {
                {
#line 1785
                tmp___14 = dup_qual_list(qo, (struct qual **)((void *)0));
#line 1785
                qlast->next = tmp___14;
                }
              }
#line 1766
              qo = qo->or;
            }
            while_break___39: /* CIL Label */ ;
            }
#line 1765
            qn = qn->or;
          }
          while_break___38: /* CIL Label */ ;
          }
#line 1788
          curglobdata.gd_quals = qorhead;
        } else {
#line 1796
          qn = newquals;
          {
#line 1797
          while (1) {
            while_continue___41: /* CIL Label */ ;
#line 1797
            if (! newquals->next) {
#line 1797
              goto while_break___41;
            }
#line 1797
            newquals = newquals->next;
          }
          while_break___41: /* CIL Label */ ;
          }
#line 1799
          newquals->next = curglobdata.gd_quals;
#line 1800
          curglobdata.gd_quals = qn;
        }
      } else {
#line 1754
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1802
    if (newquals) {
#line 1803
      curglobdata.gd_quals = newquals;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1805
  q = parsepat(str);
  }
#line 1806
  if (! q) {
#line 1806
    goto _L___3;
  } else
#line 1806
  if (errflag) {
    _L___3: /* CIL Label */ 
    {
#line 1807
    while (1) {
      while_continue___42: /* CIL Label */ ;
      {
#line 1807
      queueing_enabled ++;
#line 1807
      zfree((void *)pathbuf, curglobdata.gd_pathbufsz);
#line 1807
      memcpy((void */* __restrict  */)(& curglobdata), (void const   */* __restrict  */)(& saved),
             sizeof(struct globdata ));
#line 1807
      pathpos = saved.gd_pathpos;
#line 1807
      pathbuf = saved.gd_pathbuf;
#line 1807
      glob_pre = saved.gd_glob_pre;
#line 1807
      glob_suf = saved.gd_glob_suf;
      }
      {
#line 1807
      while (1) {
        while_continue___43: /* CIL Label */ ;
#line 1807
        queueing_enabled --;
#line 1807
        if (! queueing_enabled) {
          {
#line 1807
          while (1) {
            while_continue___44: /* CIL Label */ ;
            {
#line 1807
            while (1) {
              while_continue___45: /* CIL Label */ ;
#line 1807
              if (! (queue_front != queue_rear)) {
#line 1807
                goto while_break___45;
              }
              {
#line 1807
              queue_front = (queue_front + 1) % 128;
#line 1807
              oset___8 = signal_setmask(signal_mask_queue[queue_front]);
#line 1807
              zhandler(signal_queue[queue_front]);
#line 1807
              signal_setmask(oset___8);
              }
            }
            while_break___45: /* CIL Label */ ;
            }
#line 1807
            goto while_break___44;
          }
          while_break___44: /* CIL Label */ ;
          }
        }
#line 1807
        goto while_break___43;
      }
      while_break___43: /* CIL Label */ ;
      }
#line 1807
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
#line 1808
    if (! opts[17]) {
#line 1809
      if (! nountok) {
        {
#line 1810
        untokenize(ostr);
        }
      }
      {
#line 1811
      insertlinknode(list, node, (void *)ostr);
      }
#line 1812
      return;
    }
    {
#line 1814
    errflag &= -2;
#line 1815
    zerr("bad pattern: %s", ostr);
    }
#line 1816
    return;
  }
#line 1818
  if (! curglobdata.gd_gf_nsorts) {
#line 1819
    if (shortcircuit) {
#line 1819
      curglobdata.gd_gf_sorts = 8 << 11;
    } else {
#line 1819
      curglobdata.gd_gf_sorts = 1;
    }
#line 1819
    curglobdata.gd_gf_sortlist[0].tp = curglobdata.gd_gf_sorts;
#line 1820
    curglobdata.gd_gf_nsorts = 1;
  }
  {
#line 1824
  curglobdata.gd_matchsz = 16;
#line 1824
  tmp___15 = zalloc((unsigned long )curglobdata.gd_matchsz * sizeof(struct gmatch ));
#line 1824
  curglobdata.gd_matchbuf = (Gmatch )tmp___15;
#line 1824
  curglobdata.gd_matchptr = curglobdata.gd_matchbuf;
#line 1826
  curglobdata.gd_matchct = 0;
#line 1827
  pattrystart();
#line 1831
  scanner(q, shortcircuit);
  }
#line 1834
  if (curglobdata.gd_matchct) {
#line 1835
    badcshglob |= 2;
  } else
#line 1836
  if (! curglobdata.gd_gf_nullglob) {
#line 1837
    if (opts[46]) {
#line 1838
      badcshglob |= 1;
    } else
#line 1839
    if (opts[120]) {
      {
#line 1840
      zerr("no matches found: %s", ostr);
#line 1841
      zfree((void *)curglobdata.gd_matchbuf, 0);
      }
      {
#line 1842
      while (1) {
        while_continue___46: /* CIL Label */ ;
        {
#line 1842
        queueing_enabled ++;
#line 1842
        zfree((void *)pathbuf, curglobdata.gd_pathbufsz);
#line 1842
        memcpy((void */* __restrict  */)(& curglobdata), (void const   */* __restrict  */)(& saved),
               sizeof(struct globdata ));
#line 1842
        pathpos = saved.gd_pathpos;
#line 1842
        pathbuf = saved.gd_pathbuf;
#line 1842
        glob_pre = saved.gd_glob_pre;
#line 1842
        glob_suf = saved.gd_glob_suf;
        }
        {
#line 1842
        while (1) {
          while_continue___47: /* CIL Label */ ;
#line 1842
          queueing_enabled --;
#line 1842
          if (! queueing_enabled) {
            {
#line 1842
            while (1) {
              while_continue___48: /* CIL Label */ ;
              {
#line 1842
              while (1) {
                while_continue___49: /* CIL Label */ ;
#line 1842
                if (! (queue_front != queue_rear)) {
#line 1842
                  goto while_break___49;
                }
                {
#line 1842
                queue_front = (queue_front + 1) % 128;
#line 1842
                oset___9 = signal_setmask(signal_mask_queue[queue_front]);
#line 1842
                zhandler(signal_queue[queue_front]);
#line 1842
                signal_setmask(oset___9);
                }
              }
              while_break___49: /* CIL Label */ ;
              }
#line 1842
              goto while_break___48;
            }
            while_break___48: /* CIL Label */ ;
            }
          }
#line 1842
          goto while_break___47;
        }
        while_break___47: /* CIL Label */ ;
        }
#line 1842
        goto while_break___46;
      }
      while_break___46: /* CIL Label */ ;
      }
#line 1843
      return;
    } else {
      {
#line 1846
      tmp___16 = dupstring((char const   *)ostr);
#line 1846
      (curglobdata.gd_matchptr)->name = tmp___16;
#line 1846
      untokenize(tmp___16);
#line 1847
      (curglobdata.gd_matchptr) ++;
#line 1848
      curglobdata.gd_matchct = 1;
      }
    }
  }
#line 1852
  if (! (curglobdata.gd_gf_sortlist[0].tp & (8 << 11))) {
#line 1857
    nexecs = 0;
#line 1859
    lastsortp = curglobdata.gd_gf_sortlist + curglobdata.gd_gf_nsorts;
#line 1863
    sortp = curglobdata.gd_gf_sortlist;
    {
#line 1863
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 1863
      if (! ((unsigned long )sortp < (unsigned long )lastsortp)) {
#line 1863
        goto while_break___50;
      }
#line 1865
      if (sortp->tp & 4) {
#line 1866
        nexecs ++;
      }
#line 1863
      sortp ++;
    }
    while_break___50: /* CIL Label */ ;
    }
#line 1869
    if (nexecs) {
#line 1871
      iexec = 0;
#line 1874
      tmpptr = curglobdata.gd_matchbuf;
      {
#line 1874
      while (1) {
        while_continue___51: /* CIL Label */ ;
#line 1874
        if (! ((unsigned long )tmpptr < (unsigned long )curglobdata.gd_matchptr)) {
#line 1874
          goto while_break___51;
        }
        {
#line 1875
        tmp___17 = zhalloc((unsigned long )nexecs * sizeof(char *));
#line 1875
        tmpptr->sortstrs = (char **)tmp___17;
#line 1874
        tmpptr ++;
        }
      }
      while_break___51: /* CIL Label */ ;
      }
#line 1878
      sortp = curglobdata.gd_gf_sortlist;
      {
#line 1878
      while (1) {
        while_continue___52: /* CIL Label */ ;
#line 1878
        if (! ((unsigned long )sortp < (unsigned long )lastsortp)) {
#line 1878
          goto while_break___52;
        }
#line 1881
        if (sortp->tp & 4) {
          {
#line 1884
          prog = parse_string(sortp->exec, 0);
          }
#line 1884
          if (prog) {
#line 1885
            ef = errflag;
#line 1885
            lv = (int )lastval;
#line 1888
            tmpptr = curglobdata.gd_matchbuf;
            {
#line 1888
            while (1) {
              while_continue___53: /* CIL Label */ ;
#line 1888
              if (! ((unsigned long )tmpptr < (unsigned long )curglobdata.gd_matchptr)) {
#line 1888
                goto while_break___53;
              }
              {
#line 1889
              tmp___18 = ztrdup((char const   *)tmpptr->name);
#line 1889
              setsparam((char *)"REPLY", tmp___18);
#line 1890
              execode(prog, 1, 0, (char *)"globsort");
              }
#line 1891
              if (! errflag) {
                {
#line 1892
                tmp___19 = getsparam((char *)"REPLY");
#line 1892
                *(tmpptr->sortstrs + iexec) = dupstring((char const   *)tmp___19);
                }
              } else {
#line 1895
                *(tmpptr->sortstrs + iexec) = tmpptr->name;
              }
#line 1888
              tmpptr ++;
            }
            while_break___53: /* CIL Label */ ;
            }
#line 1899
            errflag = ef | (errflag & 2);
#line 1900
            lastval = (zlong )lv;
          } else {
#line 1903
            tmpptr = curglobdata.gd_matchbuf;
            {
#line 1903
            while (1) {
              while_continue___54: /* CIL Label */ ;
#line 1903
              if (! ((unsigned long )tmpptr < (unsigned long )curglobdata.gd_matchptr)) {
#line 1903
                goto while_break___54;
              }
#line 1904
              *(tmpptr->sortstrs + iexec) = tmpptr->name;
#line 1903
              tmpptr ++;
            }
            while_break___54: /* CIL Label */ ;
            }
          }
#line 1907
          iexec ++;
        }
#line 1878
        sortp ++;
      }
      while_break___52: /* CIL Label */ ;
      }
    }
#line 1917
    gmptr = curglobdata.gd_matchbuf;
    {
#line 1917
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 1917
      if (! ((unsigned long )gmptr < (unsigned long )curglobdata.gd_matchptr)) {
#line 1917
        goto while_break___55;
      }
      {
#line 1919
      tmp___20 = strchr((char const   *)gmptr->name, -125);
      }
#line 1919
      if (tmp___20) {
        {
#line 1922
        gmptr->uname = dupstring((char const   *)gmptr->name);
#line 1923
        unmetafy(gmptr->uname, & dummy___0);
        }
      } else {
#line 1925
        gmptr->uname = gmptr->name;
      }
#line 1917
      gmptr ++;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 1931
    qsort((void *)(curglobdata.gd_matchbuf + 0), (size_t )curglobdata.gd_matchct,
          sizeof(struct gmatch ), (int (*)(void const   * , void const   * ))(& gmatchcmp));
    }
  }
#line 1935
  if (first < 0) {
#line 1936
    first += curglobdata.gd_matchct;
#line 1937
    if (first < 0) {
#line 1938
      first = 0;
    }
  }
#line 1940
  if (end < 0) {
#line 1941
    end += curglobdata.gd_matchct + 1;
  } else
#line 1942
  if (end > curglobdata.gd_matchct) {
#line 1943
    end = curglobdata.gd_matchct;
  }
#line 1944
  end -= first;
#line 1944
  if (end > 0) {
#line 1945
    if (curglobdata.gd_gf_sortlist[0].tp & (8 << 11)) {
#line 1947
      curglobdata.gd_matchptr = ((curglobdata.gd_matchbuf + curglobdata.gd_matchct) - first) - 1;
      {
#line 1948
      while (1) {
        while_continue___56: /* CIL Label */ ;
#line 1948
        tmp___21 = end;
#line 1948
        end --;
#line 1948
        if (! (tmp___21 > 0)) {
#line 1948
          goto while_break___56;
        }
        {
#line 1950
        insert_glob_match(list, node, (curglobdata.gd_matchptr)->name);
#line 1951
        (curglobdata.gd_matchptr) --;
        }
      }
      while_break___56: /* CIL Label */ ;
      }
    } else {
#line 1954
      curglobdata.gd_matchptr = ((curglobdata.gd_matchbuf + curglobdata.gd_matchct) - first) - end;
      {
#line 1955
      while (1) {
        while_continue___57: /* CIL Label */ ;
#line 1955
        tmp___22 = end;
#line 1955
        end --;
#line 1955
        if (! (tmp___22 > 0)) {
#line 1955
          goto while_break___57;
        }
        {
#line 1957
        insert_glob_match(list, node, (curglobdata.gd_matchptr)->name);
#line 1958
        (curglobdata.gd_matchptr) ++;
        }
      }
      while_break___57: /* CIL Label */ ;
      }
    }
  } else
#line 1961
  if (! badcshglob) {
#line 1961
    if (! opts[120]) {
#line 1961
      if (curglobdata.gd_matchct == 1) {
        {
#line 1962
        (curglobdata.gd_matchptr) --;
#line 1962
        insert_glob_match(list, node, (curglobdata.gd_matchptr)->name);
        }
      }
    }
  }
  {
#line 1964
  zfree((void *)curglobdata.gd_matchbuf, 0);
  }
  {
#line 1966
  while (1) {
    while_continue___58: /* CIL Label */ ;
    {
#line 1966
    queueing_enabled ++;
#line 1966
    zfree((void *)pathbuf, curglobdata.gd_pathbufsz);
#line 1966
    memcpy((void */* __restrict  */)(& curglobdata), (void const   */* __restrict  */)(& saved),
           sizeof(struct globdata ));
#line 1966
    pathpos = saved.gd_pathpos;
#line 1966
    pathbuf = saved.gd_pathbuf;
#line 1966
    glob_pre = saved.gd_glob_pre;
#line 1966
    glob_suf = saved.gd_glob_suf;
    }
    {
#line 1966
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 1966
      queueing_enabled --;
#line 1966
      if (! queueing_enabled) {
        {
#line 1966
        while (1) {
          while_continue___60: /* CIL Label */ ;
          {
#line 1966
          while (1) {
            while_continue___61: /* CIL Label */ ;
#line 1966
            if (! (queue_front != queue_rear)) {
#line 1966
              goto while_break___61;
            }
            {
#line 1966
            queue_front = (queue_front + 1) % 128;
#line 1966
            oset___10 = signal_setmask(signal_mask_queue[queue_front]);
#line 1966
            zhandler(signal_queue[queue_front]);
#line 1966
            signal_setmask(oset___10);
            }
          }
          while_break___61: /* CIL Label */ ;
          }
#line 1966
          goto while_break___60;
        }
        while_break___60: /* CIL Label */ ;
        }
      }
#line 1966
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
#line 1966
    goto while_break___58;
  }
  while_break___58: /* CIL Label */ ;
  }
#line 1967
  return;
}
}
#line 1972 "/tmp/zsh-5.4.2/Src/glob.c"
char file_type(mode_t filemode ) 
{ 
  int tmp ;

  {
#line 1975
  if ((filemode & 61440U) == 24576U) {
#line 1976
    return ((char )'#');
  } else
#line 1977
  if ((filemode & 61440U) == 8192U) {
#line 1978
    return ((char )'%');
  } else
#line 1979
  if ((filemode & 61440U) == 16384U) {
#line 1980
    return ((char )'/');
  } else
#line 1981
  if ((filemode & 61440U) == 4096U) {
#line 1982
    return ((char )'|');
  } else
#line 1983
  if ((filemode & 61440U) == 40960U) {
#line 1984
    return ((char )'@');
  } else
#line 1985
  if ((filemode & 61440U) == 32768U) {
#line 1986
    if (filemode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 1986
      tmp = '*';
    } else {
#line 1986
      tmp = ' ';
    }
#line 1986
    return ((char )tmp);
  } else
#line 1987
  if ((filemode & 61440U) == 49152U) {
#line 1988
    return ((char )'=');
  } else {
#line 1990
    return ((char )'?');
  }
}
}
#line 1996 "/tmp/zsh-5.4.2/Src/glob.c"
int hasbraces(char *str ) 
{ 
  char *lbr ;
  char *mbr ;
  char *comma ;
  int bc ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *s ;
  char tmp___2 ;
  int tmp___3 ;

  {
#line 2001
  if (opts[24]) {
#line 2006
    bc = 0;
    {
#line 2006
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2006
      c = (int )*str;
#line 2006
      if (! c) {
#line 2006
        goto while_break;
      }
#line 2007
      if (c == -113) {
#line 2008
        if (! bc) {
#line 2008
          if ((int )*(str + 1) == -112) {
#line 2009
            tmp = str;
#line 2009
            str ++;
#line 2009
            *tmp = (char )'{';
#line 2009
            *str = (char )'}';
          } else {
#line 2011
            bc ++;
          }
        } else {
#line 2011
          bc ++;
        }
      } else
#line 2012
      if (c == -112) {
#line 2013
        if (! bc) {
#line 2014
          *str = (char )'}';
        } else {
#line 2015
          bc --;
#line 2015
          if (! bc) {
#line 2016
            return (1);
          }
        }
      }
#line 2006
      str ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2018
    return (0);
  }
#line 2021
  comma = (char *)((void *)0);
#line 2021
  mbr = comma;
#line 2021
  lbr = mbr;
  {
#line 2022
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2023
    tmp___0 = str;
#line 2023
    str ++;
    {
#line 2024
    if ((int )*tmp___0 == -113) {
#line 2024
      goto case_neg_113;
    }
#line 2067
    if ((int )*tmp___0 == -112) {
#line 2067
      goto case_neg_112;
    }
#line 2080
    if ((int )*tmp___0 == -102) {
#line 2080
      goto case_neg_102;
    }
#line 2086
    if ((int )*tmp___0 == 0) {
#line 2086
      goto case_0;
    }
#line 2023
    goto switch_break;
    case_neg_113: /* CIL Label */ 
#line 2025
    if (! lbr) {
      {
#line 2026
      tmp___1 = bracechardots(str - 1, (convchar_t *)((void *)0), (convchar_t *)((void *)0));
      }
#line 2026
      if (tmp___1) {
#line 2027
        return (1);
      }
#line 2028
      lbr = str - 1;
#line 2029
      if ((int )*str == 45) {
#line 2030
        str ++;
      } else
#line 2029
      if ((int )*str == -101) {
#line 2030
        str ++;
      }
      {
#line 2031
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2031
        if (! ((int )typtab[(unsigned char )*str] & 1)) {
#line 2031
          goto while_break___1;
        }
#line 2032
        str ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2033
      if ((int )*str == 46) {
#line 2033
        if ((int )*(str + 1) == 46) {
#line 2034
          str ++;
#line 2034
          str ++;
#line 2035
          if ((int )*str == 45) {
#line 2036
            str ++;
          } else
#line 2035
          if ((int )*str == -101) {
#line 2036
            str ++;
          }
          {
#line 2037
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2037
            if (! ((int )typtab[(unsigned char )*str] & 1)) {
#line 2037
              goto while_break___2;
            }
#line 2038
            str ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2039
          if ((int )*str == -112) {
#line 2039
            if ((int )typtab[(unsigned char )*(lbr + 1)] & 1) {
#line 2041
              return (1);
            } else
#line 2039
            if ((int )typtab[(unsigned char )*(str + -1)] & 1) {
#line 2041
              return (1);
            } else {
#line 2039
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 2042
          if ((int )*str == 46) {
#line 2042
            if ((int )*(str + 1) == 46) {
#line 2043
              str ++;
#line 2043
              str ++;
#line 2044
              if ((int )*str == 45) {
#line 2045
                str ++;
              } else
#line 2044
              if ((int )*str == -101) {
#line 2045
                str ++;
              }
              {
#line 2046
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 2046
                if (! ((int )typtab[(unsigned char )*str] & 1)) {
#line 2046
                  goto while_break___3;
                }
#line 2047
                str ++;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 2048
              if ((int )*str == -112) {
#line 2048
                if ((int )typtab[(unsigned char )*(lbr + 1)] & 1) {
#line 2050
                  return (1);
                } else
#line 2048
                if ((int )typtab[(unsigned char )*(str + -1)] & 1) {
#line 2050
                  return (1);
                }
              }
            }
          }
        }
      }
    } else {
      {
#line 2054
      str --;
#line 2054
      s = str;
#line 2056
      tmp___3 = skipparens((char)-113, (char)-112, & str);
      }
#line 2056
      if (tmp___3) {
#line 2057
        tmp___2 = (char )'{';
#line 2057
        *s = tmp___2;
#line 2057
        *lbr = tmp___2;
#line 2058
        if (comma) {
#line 2059
          str = comma;
        }
#line 2060
        if (mbr) {
#line 2060
          if ((unsigned long )mbr < (unsigned long )str) {
#line 2061
            str = mbr;
          }
        }
#line 2062
        comma = (char *)((void *)0);
#line 2062
        mbr = comma;
#line 2062
        lbr = mbr;
      } else
#line 2063
      if (! mbr) {
#line 2064
        mbr = s;
      }
    }
#line 2066
    goto switch_break;
    case_neg_112: /* CIL Label */ 
#line 2068
    if (! lbr) {
#line 2069
      *(str + -1) = (char )'}';
    } else
#line 2070
    if (comma) {
#line 2071
      return (1);
    } else {
#line 2073
      *lbr = (char )'{';
#line 2074
      *(str + -1) = (char )'}';
#line 2075
      if (mbr) {
#line 2076
        str = mbr;
      }
#line 2077
      lbr = (char *)((void *)0);
#line 2077
      mbr = lbr;
    }
#line 2079
    goto switch_break;
    case_neg_102: /* CIL Label */ 
#line 2081
    if (! lbr) {
#line 2082
      *(str + -1) = (char )',';
    } else
#line 2083
    if (! comma) {
#line 2084
      comma = str - 1;
    }
#line 2085
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2087
    if (lbr) {
#line 2088
      *lbr = (char )'{';
    }
#line 2089
    if (! mbr) {
#line 2089
      if (! comma) {
#line 2090
        return (0);
      }
    }
#line 2091
    if (comma) {
#line 2092
      str = comma;
    }
#line 2093
    if (mbr) {
#line 2093
      if ((unsigned long )mbr < (unsigned long )str) {
#line 2094
        str = mbr;
      }
    }
#line 2095
    comma = (char *)((void *)0);
#line 2095
    mbr = comma;
#line 2095
    lbr = mbr;
#line 2096
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 2104 "/tmp/zsh-5.4.2/Src/glob.c"
int xpandredir(struct redir *fn___0 , LinkList redirtab___0 ) 
{ 
  char *nam ;
  struct redir *ff ;
  int ret ;
  union linkroot fake ;
  struct linknode __n0 ;
  int tmp ;
  char *s ;
  zlong tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 2109
  ret = 0;
  {
#line 2113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2113
    fake.list.first = & __n0;
#line 2113
    fake.list.last = & __n0;
#line 2113
    fake.list.flags = 0;
#line 2113
    __n0.next = (LinkNode )((void *)0);
#line 2113
    __n0.prev = & fake.node;
#line 2113
    __n0.dat = (void *)fn___0->name;
#line 2113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2115
  if (opts[119]) {
#line 2115
    tmp = 0;
  } else {
#line 2115
    tmp = 4;
  }
  {
#line 2115
  prefork(& fake, tmp, (int *)((void *)0));
  }
#line 2117
  if (! errflag) {
#line 2117
    if (opts[119]) {
      {
#line 2118
      globlist(& fake, 0);
      }
    }
  }
#line 2119
  if (errflag) {
#line 2120
    return (0);
  }
#line 2121
  if ((unsigned long )fake.list.first != (unsigned long )((void *)0)) {
#line 2121
    if (! (fake.list.first)->next) {
      {
#line 2123
      s = (char *)(fake.list.first)->dat;
#line 2124
      fn___0->name = s;
#line 2125
      untokenize(s);
      }
#line 2126
      if (fn___0->type == 13) {
#line 2126
        goto _L___3;
      } else
#line 2126
      if (fn___0->type == 14) {
        _L___3: /* CIL Label */ 
#line 2127
        if ((int )*(s + 0) == 45) {
#line 2127
          goto _L___2;
        } else
#line 2127
        if ((int )*(s + 0) == -101) {
          _L___2: /* CIL Label */ 
#line 2127
          if (! *(s + 1)) {
#line 2128
            fn___0->type = 15;
          } else {
#line 2127
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 2129
        if ((int )*(s + 0) == 112) {
#line 2129
          if (! *(s + 1)) {
#line 2130
            fn___0->fd2 = -2;
          } else {
#line 2129
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 2132
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2132
            if (! ((int )typtab[(unsigned char )*s] & 1)) {
#line 2132
              goto while_break___0;
            }
#line 2133
            s ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 2134
          if (! *s) {
#line 2134
            if ((unsigned long )s > (unsigned long )fn___0->name) {
              {
#line 2135
              tmp___0 = zstrtol((char const   *)fn___0->name, (char **)((void *)0),
                                10);
#line 2135
              fn___0->fd2 = (int )tmp___0;
              }
            } else {
#line 2134
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 2136
          if (fn___0->type == 13) {
            {
#line 2137
            zerr("file number expected");
            }
          } else {
#line 2139
            fn___0->type = 4;
          }
        }
      }
    } else {
#line 2121
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 2142
  if (fn___0->type == 13) {
    {
#line 2143
    zerr("file number expected");
    }
  } else {
#line 2145
    if (fn___0->type == 14) {
#line 2146
      fn___0->type = 4;
    }
    {
#line 2147
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 2147
      tmp___2 = ugetnode(& fake);
#line 2147
      nam = (char *)tmp___2;
      }
#line 2147
      if (! nam) {
#line 2147
        goto while_break___1;
      }
      {
#line 2150
      tmp___1 = zhalloc(sizeof(*ff));
#line 2150
      ff = (struct redir *)tmp___1;
#line 2151
      *ff = *fn___0;
#line 2152
      ff->name = nam;
#line 2153
      insertlinknode(redirtab___0, redirtab___0->list.last, (void *)ff);
#line 2154
      ret = 1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 2157
  return (ret);
}
}
#line 2173 "/tmp/zsh-5.4.2/Src/glob.c"
static int bracechardots(char *str , convchar_t *c1p , convchar_t *c2p ) 
{ 
  convchar_t cstart ;
  convchar_t cend ;
  char *pnext ;
  char *pconv ;
  char convstr[2] ;
  int tmp ;
  int tmp___0 ;

  {
#line 2177
  pnext = str + 1;
#line 2178
  if ((int )typtab[(unsigned char )*pnext] & (1 << 4)) {
#line 2179
    if ((int )*pnext == -113) {
#line 2180
      return (0);
    }
#line 2181
    convstr[0] = ztokens[(int )*pnext - -124];
#line 2182
    convstr[1] = (char )'\000';
#line 2183
    pconv = convstr;
  } else {
#line 2185
    pconv = pnext;
  }
  {
#line 2186
  mb_charinit();
#line 2187
  tmp = mb_metacharlenconv((char const   *)pconv, & cstart);
#line 2187
  pnext += tmp;
  }
#line 2188
  if (cstart == 4294967295U) {
#line 2195
    return (0);
  } else
#line 2188
  if ((int )*(pnext + 0) != 46) {
#line 2195
    return (0);
  } else
#line 2188
  if ((int )*(pnext + 1) != 46) {
#line 2195
    return (0);
  }
#line 2196
  pnext += 2;
#line 2197
  if (! *pnext) {
#line 2198
    return (0);
  }
#line 2199
  if ((int )typtab[(unsigned char )*pnext] & (1 << 4)) {
#line 2200
    if ((int )*pnext == -113) {
#line 2201
      return (0);
    }
#line 2202
    convstr[0] = ztokens[(int )*pnext - -124];
#line 2203
    convstr[1] = (char )'\000';
#line 2204
    pconv = convstr;
  } else {
#line 2206
    pconv = pnext;
  }
  {
#line 2207
  mb_charinit();
#line 2208
  tmp___0 = mb_metacharlenconv((char const   *)pconv, & cend);
#line 2208
  pnext += tmp___0;
  }
#line 2209
  if (cend == 4294967295U) {
#line 2216
    return (0);
  } else
#line 2209
  if ((int )*pnext != -112) {
#line 2216
    return (0);
  }
#line 2217
  if (c1p) {
#line 2218
    *c1p = cstart;
  }
#line 2219
  if (c2p) {
#line 2220
    *c2p = cend;
  }
#line 2221
  return (1);
}
}
#line 2227 "/tmp/zsh-5.4.2/Src/glob.c"
void xpandbraces(LinkList list , LinkNode *np ) 
{ 
  LinkNode node ;
  LinkNode last ;
  char *str ;
  char *str3 ;
  char *str2 ;
  int prev ;
  int bc ;
  int comma ;
  int dotdot ;
  char *dots ;
  char *p ;
  char *dots2 ;
  LinkNode olast ;
  zlong rstart ;
  zlong rend ;
  int err ;
  int rev ;
  int rincr ;
  int wid1 ;
  int wid2 ;
  int wid3 ;
  int strp ;
  convchar_t cstart ;
  convchar_t cend ;
  int lenalloc ;
  convchar_t ctmp ;
  size_t tmp ;
  char *ncptr ;
  int nclen ;
  size_t tmp___0 ;
  void *tmp___1 ;
  convchar_t tmp___2 ;
  int tmp___3 ;
  zlong tmp___4 ;
  int minw ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  zlong rt ;
  char ccl[256] ;
  char *p___0 ;
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned int len ;
  unsigned int pl ;
  int lastch ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *zz ;
  char *str4 ;
  int cnt ;
  size_t tmp___16 ;
  void *tmp___17 ;

  {
#line 2230
  node = *np;
#line 2230
  last = node->prev;
#line 2231
  str = (char *)node->dat;
#line 2231
  str3 = str;
  {
#line 2234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2234
    if (! ((int )*str != -113)) {
#line 2234
      goto while_break;
    }
#line 2234
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2236
  str2 = str;
#line 2236
  dotdot = 0;
#line 2236
  comma = dotdot;
#line 2236
  bc = comma;
  {
#line 2236
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2236
    if (! *str2) {
#line 2236
      goto while_break___0;
    }
#line 2237
    if ((int )*str2 == -113) {
#line 2238
      bc ++;
    } else
#line 2239
    if ((int )*str2 == -112) {
#line 2240
      bc --;
#line 2240
      if (bc == 0) {
#line 2241
        goto while_break___0;
      }
    } else
#line 2242
    if (bc == 1) {
#line 2243
      if ((int )*str2 == -102) {
#line 2244
        comma ++;
      } else
#line 2245
      if ((int )*str2 == 46) {
#line 2245
        if ((int )*(str2 + 1) == 46) {
#line 2246
          dotdot ++;
#line 2247
          str2 ++;
        }
      }
    }
#line 2236
    str2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2251
  if (! comma) {
#line 2251
    if (dotdot) {
      {
#line 2254
      dots2 = (char *)((void *)0);
#line 2255
      olast = last;
#line 2258
      err = 0;
#line 2258
      rev = 0;
#line 2258
      rincr = 1;
#line 2262
      tmp___3 = bracechardots(str, & cstart, & cend);
      }
#line 2262
      if (tmp___3) {
#line 2267
        if (cend < cstart) {
#line 2268
          ctmp = cend;
#line 2269
          cend = cstart;
#line 2270
          cstart = ctmp;
#line 2271
          rev = 1;
        }
        {
#line 2273
        uremnode(list, node);
#line 2274
        strp = (int )(str - str3);
#line 2275
        tmp = strlen((char const   *)(str2 + 1));
#line 2275
        lenalloc = (int )(((size_t )strp + tmp) + 1UL);
        }
        {
#line 2276
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 2280
          mb_charinit();
#line 2281
          ncptr = wcs_nicechar((wchar_t )cend, (size_t *)((void *)0), (char **)((void *)0));
#line 2282
          tmp___0 = strlen((char const   *)ncptr);
#line 2282
          nclen = (int )tmp___0;
#line 2283
          tmp___1 = zhalloc((size_t )(lenalloc + nclen));
#line 2283
          p = (char *)tmp___1;
#line 2284
          memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)str3,
                 (size_t )strp);
#line 2285
          memcpy((void */* __restrict  */)(p + strp), (void const   */* __restrict  */)ncptr,
                 (size_t )nclen);
#line 2286
          strcpy((char */* __restrict  */)((p + strp) + nclen), (char const   */* __restrict  */)(str2 + 1));
#line 2293
          insertlinknode(list, last, (void *)p);
          }
#line 2294
          if (rev) {
#line 2295
            last = last->next;
          }
#line 2276
          tmp___2 = cend;
#line 2276
          cend --;
#line 2276
          if (! (tmp___2 > cstart)) {
#line 2276
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2297
        *np = olast->next;
#line 2298
        return;
      }
      {
#line 2302
      rstart = zstrtol((char const   *)(str + 1), & dots, 10);
#line 2303
      rend = (zlong )0;
#line 2304
      wid1 = (int )((dots - str) - 1L);
#line 2305
      wid2 = (int )((str2 - dots) - 2L);
#line 2306
      wid3 = 0;
#line 2307
      strp = (int )(str - str3);
      }
#line 2309
      if ((unsigned long )dots == (unsigned long )(str + 1)) {
#line 2310
        err ++;
      } else
#line 2309
      if ((int )*dots != 46) {
#line 2310
        err ++;
      } else
#line 2309
      if ((int )*(dots + 1) != 46) {
#line 2310
        err ++;
      } else {
        {
#line 2313
        rend = zstrtol((char const   *)(dots + 2), & p, 10);
        }
#line 2314
        if ((unsigned long )p == (unsigned long )(dots + 2)) {
#line 2315
          err ++;
        }
#line 2317
        if ((unsigned long )p != (unsigned long )str2) {
#line 2318
          wid2 = (int )((p - dots) - 2L);
#line 2319
          dots2 = p;
#line 2320
          if (dotdot == 2) {
#line 2320
            if ((int )*p == 46) {
#line 2320
              if ((int )*(p + 1) == 46) {
                {
#line 2321
                tmp___4 = zstrtol((char const   *)(p + 2), & p, 10);
#line 2321
                rincr = (int )tmp___4;
#line 2322
                wid3 = (int )((p - dots2) - 2L);
                }
#line 2323
                if ((unsigned long )p != (unsigned long )str2) {
#line 2324
                  err ++;
                } else
#line 2323
                if (! rincr) {
#line 2324
                  err ++;
                }
              } else {
#line 2326
                err ++;
              }
            } else {
#line 2326
              err ++;
            }
          } else {
#line 2326
            err ++;
          }
        }
      }
#line 2329
      if (! err) {
#line 2335
        if ((int )*(str + 1) == 48) {
#line 2335
          tmp___7 = wid1;
        } else
#line 2335
        if ((int )*(str + 1) == 45) {
#line 2335
          goto _L___3;
        } else
#line 2335
        if ((int )*(str + 1) == -101) {
          _L___3: /* CIL Label */ 
#line 2335
          if ((int )*(str + 2) == 48) {
#line 2335
            tmp___7 = wid1;
          } else {
#line 2335
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 2335
          if ((int )*(dots + 2) == 48) {
#line 2335
            tmp___6 = wid2;
          } else
#line 2335
          if ((int )*(dots + 2) == 45) {
#line 2335
            goto _L___1;
          } else
#line 2335
          if ((int )*(dots + 2) == -101) {
            _L___1: /* CIL Label */ 
#line 2335
            if ((int )*(dots + 3) == 48) {
#line 2335
              tmp___6 = wid2;
            } else {
#line 2335
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
#line 2335
            if (dots2) {
#line 2335
              if ((int )*(dots2 + 2) == 48) {
#line 2335
                tmp___5 = wid3;
              } else
#line 2335
              if ((int )*(dots2 + 2) == 45) {
#line 2335
                goto _L;
              } else
#line 2335
              if ((int )*(dots2 + 2) == -101) {
                _L: /* CIL Label */ 
#line 2335
                if ((int )*(dots2 + 3) == 48) {
#line 2335
                  tmp___5 = wid3;
                } else {
#line 2335
                  tmp___5 = 0;
                }
              } else {
#line 2335
                tmp___5 = 0;
              }
            } else {
#line 2335
              tmp___5 = 0;
            }
#line 2335
            tmp___6 = tmp___5;
          }
#line 2335
          tmp___7 = tmp___6;
        }
#line 2335
        minw = tmp___7;
#line 2345
        if (rincr < 0) {
#line 2347
          rincr = - rincr;
#line 2348
          rev = ! rev;
        }
#line 2350
        if (rstart > rend) {
#line 2352
          rt = rend;
#line 2353
          rend = rstart;
#line 2354
          rstart = rt;
#line 2355
          rev = ! rev;
        } else
#line 2356
        if (rincr > 1) {
#line 2359
          rend -= (rend - rstart) % (long )rincr;
        }
        {
#line 2361
        uremnode(list, node);
        }
        {
#line 2362
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2362
          if (! (rend >= rstart)) {
#line 2362
            goto while_break___2;
          }
          {
#line 2364
          p = dupstring((char const   *)str3);
#line 2368
          sprintf((char */* __restrict  */)(p + strp), (char const   */* __restrict  */)"%0*ld",
                  minw, rend);
#line 2370
          strcat((char */* __restrict  */)(p + strp), (char const   */* __restrict  */)(str2 + 1));
#line 2371
          insertlinknode(list, last, (void *)p);
          }
#line 2372
          if (rev) {
#line 2373
            last = last->next;
          }
#line 2362
          rend -= (zlong )rincr;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2375
        *np = olast->next;
#line 2376
        return;
      }
    }
  }
#line 2379
  if (! comma) {
#line 2379
    if (opts[24]) {
      {
#line 2387
      lastch = -1;
#line 2389
      uremnode(list, node);
#line 2390
      memset((void *)(ccl), 0, sizeof(ccl) / sizeof(ccl[0]));
#line 2391
      p___0 = str + 1;
      }
      {
#line 2391
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2391
        if (! ((unsigned long )p___0 < (unsigned long )str2)) {
#line 2391
          goto while_break___3;
        }
#line 2392
        tmp___8 = p___0;
#line 2392
        p___0 ++;
#line 2392
        c1 = (unsigned char )*tmp___8;
#line 2392
        if ((int )typtab[c1] & (1 << 4)) {
#line 2393
          c1 = (unsigned char )ztokens[(int )c1 - 132];
        }
#line 2394
        if ((int )((char )c1) == -125) {
#line 2395
          tmp___9 = p___0;
#line 2395
          p___0 ++;
#line 2395
          c1 = (unsigned char )(32 ^ (int )*tmp___9);
        }
#line 2396
        c2 = (unsigned char )*p___0;
#line 2396
        if ((int )typtab[c2] & (1 << 4)) {
#line 2397
          c2 = (unsigned char )ztokens[(int )c2 - 132];
        }
#line 2398
        if ((int )((char )c2) == -125) {
#line 2399
          c2 = (unsigned char )(32 ^ (int )*(p___0 + 1));
        }
#line 2400
        if ((int )((char )c1) == 45) {
#line 2400
          goto _L___4;
        } else
#line 2400
        if ((int )((char )c1) == -101) {
          _L___4: /* CIL Label */ 
#line 2400
          if (lastch >= 0) {
#line 2400
            if ((unsigned long )p___0 < (unsigned long )str2) {
#line 2400
              if (lastch <= (int )c2) {
                {
#line 2402
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 2402
                  if (! (lastch < (int )c2)) {
#line 2402
                    goto while_break___4;
                  }
#line 2403
                  tmp___10 = lastch;
#line 2403
                  lastch ++;
#line 2403
                  ccl[tmp___10] = (char)1;
                }
                while_break___4: /* CIL Label */ ;
                }
#line 2404
                lastch = -1;
              } else {
#line 2406
                lastch = (int )c1;
#line 2406
                ccl[lastch] = (char)1;
              }
            } else {
#line 2406
              lastch = (int )c1;
#line 2406
              ccl[lastch] = (char)1;
            }
          } else {
#line 2406
            lastch = (int )c1;
#line 2406
            ccl[lastch] = (char)1;
          }
        } else {
#line 2406
          lastch = (int )c1;
#line 2406
          ccl[lastch] = (char)1;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 2408
      pl = (unsigned int )(str - str3);
#line 2409
      str2 ++;
#line 2409
      tmp___11 = strlen((char const   *)str2);
#line 2409
      len = (unsigned int )(((size_t )pl + tmp___11) + 2UL);
#line 2410
      p___0 = ccl + 256;
      }
      {
#line 2410
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2410
        tmp___14 = p___0;
#line 2410
        p___0 --;
#line 2410
        if (! ((unsigned long )tmp___14 > (unsigned long )(ccl))) {
#line 2410
          goto while_break___5;
        }
#line 2411
        if (*p___0) {
#line 2412
          c1 = (unsigned char )(p___0 - ccl);
#line 2413
          if ((int )typtab[c1] & (1 << 12)) {
            {
#line 2414
            tmp___12 = hcalloc((size_t )(len + 1U));
#line 2414
            str = (char *)tmp___12;
#line 2415
            *(str + pl) = (char)-125;
#line 2416
            *(str + (pl + 1U)) = (char )((int )c1 ^ 32);
#line 2417
            strcpy((char */* __restrict  */)((str + pl) + 2), (char const   */* __restrict  */)str2);
            }
          } else {
            {
#line 2419
            tmp___13 = hcalloc((size_t )len);
#line 2419
            str = (char *)tmp___13;
#line 2420
            *(str + pl) = (char )c1;
#line 2421
            strcpy((char */* __restrict  */)((str + pl) + 1), (char const   */* __restrict  */)str2);
            }
          }
          {
#line 2423
          memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)str3,
                 (size_t )pl);
#line 2424
          insertlinknode(list, last, (void *)str);
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2426
      *np = last->next;
#line 2427
      return;
    }
  }
  {
#line 2429
  tmp___15 = str;
#line 2429
  str ++;
#line 2429
  prev = (int )(tmp___15 - str3);
#line 2430
  str2 ++;
#line 2431
  uremnode(list, node);
#line 2432
  node = last;
  }
  {
#line 2436
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2440
    str4 = str;
#line 2440
    cnt = 0;
    {
#line 2440
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2440
      if (! cnt) {
#line 2440
        if ((int )*str != -102) {
#line 2440
          if (! ((int )*str != -112)) {
#line 2440
            goto while_break___7;
          }
        } else {
#line 2440
          goto while_break___7;
        }
      }
#line 2442
      if ((int )*str == -113) {
#line 2443
        cnt ++;
      } else
#line 2444
      if ((int )*str == -112) {
#line 2445
        cnt --;
      }
#line 2440
      str ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 2450
    tmp___16 = strlen((char const   *)str2);
#line 2450
    tmp___17 = hcalloc(((size_t )((long )prev + (str - str4)) + tmp___16) + 1UL);
#line 2450
    zz = (char *)tmp___17;
#line 2451
    ztrncpy(zz, str3, prev);
#line 2452
    strncat((char */* __restrict  */)zz, (char const   */* __restrict  */)str4, (size_t )(str - str4));
#line 2453
    strcat((char */* __restrict  */)zz, (char const   */* __restrict  */)str2);
#line 2455
    insertlinknode(list, node, (void *)zz);
#line 2456
    node = node->next;
    }
#line 2457
    if ((int )*str != -112) {
#line 2458
      str ++;
    } else {
#line 2460
      goto while_break___6;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2462
  *np = last->next;
#line 2463
  return;
}
}
#line 2468 "/tmp/zsh-5.4.2/Src/glob.c"
int matchpat(char *a , char *b ) 
{ 
  Patprog p ;
  int ret ;
  sigset_t oset ;

  {
  {
#line 2474
  queueing_enabled ++;
#line 2476
  p = patcompile(b, 64, (char **)((void *)0));
  }
#line 2476
  if (p) {
    {
#line 2480
    ret = pattry(p, a);
    }
  } else {
    {
#line 2477
    zerr("bad pattern: %s", b);
#line 2478
    ret = 0;
    }
  }
  {
#line 2482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2482
    queueing_enabled --;
#line 2482
    if (! queueing_enabled) {
      {
#line 2482
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2482
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2482
          if (! (queue_front != queue_rear)) {
#line 2482
            goto while_break___1;
          }
          {
#line 2482
          queue_front = (queue_front + 1) % 128;
#line 2482
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 2482
          zhandler(signal_queue[queue_front]);
#line 2482
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2482
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2482
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2484
  return (ret);
}
}
#line 2504 "/tmp/zsh-5.4.2/Src/glob.c"
static char *get_match_ret(Imatchdata imd , int b , int e ) 
{ 
  char buf___7[80] ;
  char *r ;
  char *p ;
  char *rr ;
  char *replstr ;
  int ll ;
  int bl ;
  int t ;
  int add___0 ;
  int fl ;
  int i ;
  Repldata rd ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
#line 2507
  replstr = imd->replstr;
#line 2508
  ll = 0;
#line 2508
  bl = 0;
#line 2508
  t = 0;
#line 2508
  add___0 = 0;
#line 2508
  fl = imd->flags;
#line 2511
  p = imd->ustr;
  {
#line 2511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2511
    if (! ((unsigned long )p < (unsigned long )(imd->ustr + b))) {
#line 2511
      goto while_break;
    }
#line 2512
    if ((int )typtab[(unsigned char )*p] & (1 << 12)) {
#line 2513
      add___0 ++;
    }
#line 2511
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2514
  b += add___0;
  {
#line 2515
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2515
    if (! ((unsigned long )p < (unsigned long )(imd->ustr + e))) {
#line 2515
      goto while_break___0;
    }
#line 2516
    if ((int )typtab[(unsigned char )*p] & (1 << 12)) {
#line 2517
      add___0 ++;
    }
#line 2515
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2518
  e += add___0;
#line 2521
  if (replstr) {
#line 2521
    goto _L;
  } else
#line 2521
  if (fl & 8192) {
    _L: /* CIL Label */ 
#line 2522
    if (fl & 1024) {
      {
#line 2523
      replstr = dupstring((char const   *)replstr);
#line 2524
      singsub(& replstr);
#line 2525
      untokenize(replstr);
      }
    }
#line 2527
    if (fl & 8704) {
#line 2527
      if (imd->repllist) {
#line 2529
        if (fl & 8192) {
          {
#line 2529
          tmp = zalloc(sizeof(*rd));
#line 2529
          tmp___1 = tmp;
          }
        } else {
          {
#line 2529
          tmp___0 = zhalloc(sizeof(*rd));
#line 2529
          tmp___1 = tmp___0;
          }
        }
#line 2529
        rd = (Repldata )tmp___1;
#line 2531
        rd->b = b;
#line 2532
        rd->e = e;
#line 2533
        rd->replstr = replstr;
#line 2534
        if (fl & 8192) {
          {
#line 2535
          zinsertlinknode(imd->repllist, (imd->repllist)->list.last, (void *)rd);
          }
        } else {
          {
#line 2537
          insertlinknode(imd->repllist, (imd->repllist)->list.last, (void *)rd);
          }
        }
#line 2538
        return (imd->mstr);
      }
    }
    {
#line 2540
    tmp___2 = strlen((char const   *)replstr);
#line 2540
    ll = (int )((size_t )ll + tmp___2);
    }
  }
#line 2542
  if (fl & 8) {
#line 2543
    ll += 1 + (e - b);
  }
#line 2544
  if (fl & 16) {
#line 2545
    ll += 1 + (imd->mlen - (e - b));
  }
#line 2546
  if (fl & 32) {
    {
#line 2548
    tmp___3 = mb_metastrlenend(imd->mstr, 0, imd->mstr + b);
#line 2548
    sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%d ",
            tmp___3 + 1);
#line 2549
    tmp___4 = strlen((char const   *)(buf___7));
#line 2549
    bl = (int )tmp___4;
#line 2549
    ll += bl;
    }
  }
#line 2551
  if (fl & 64) {
    {
#line 2553
    tmp___5 = mb_metastrlenend(imd->mstr, 0, imd->mstr + e);
#line 2553
    sprintf((char */* __restrict  */)(buf___7 + bl), (char const   */* __restrict  */)"%d ",
            tmp___5 + 1);
#line 2555
    tmp___6 = strlen((char const   *)(buf___7));
#line 2555
    bl = (int )tmp___6;
#line 2555
    ll += bl;
    }
  }
#line 2557
  if (fl & 128) {
    {
#line 2559
    tmp___7 = mb_metastrlenend(imd->mstr + b, 0, imd->mstr + e);
#line 2559
    sprintf((char */* __restrict  */)(buf___7 + bl), (char const   */* __restrict  */)"%d ",
            tmp___7);
#line 2561
    tmp___8 = strlen((char const   *)(buf___7));
#line 2561
    bl = (int )tmp___8;
#line 2561
    ll += bl;
    }
  }
#line 2563
  if (bl) {
#line 2564
    buf___7[bl - 1] = (char )'\000';
  }
  {
#line 2566
  tmp___9 = hcalloc((size_t )ll);
#line 2566
  r = (char *)tmp___9;
#line 2566
  rr = r;
  }
#line 2568
  if (fl & 8) {
#line 2570
    i = b;
#line 2570
    p = imd->mstr + b;
    {
#line 2570
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2570
      if (! (i < e)) {
#line 2570
        goto while_break___1;
      }
#line 2571
      tmp___10 = rr;
#line 2571
      rr ++;
#line 2571
      tmp___11 = p;
#line 2571
      p ++;
#line 2571
      *tmp___10 = *tmp___11;
#line 2570
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2572
    t = 1;
  }
#line 2574
  if (fl & 16) {
#line 2577
    if (t) {
#line 2578
      tmp___12 = rr;
#line 2578
      rr ++;
#line 2578
      *tmp___12 = (char )' ';
    }
#line 2580
    i = 0;
#line 2580
    p = imd->mstr;
    {
#line 2580
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2580
      if (! (i < b)) {
#line 2580
        goto while_break___2;
      }
#line 2581
      tmp___13 = rr;
#line 2581
      rr ++;
#line 2581
      tmp___14 = p;
#line 2581
      p ++;
#line 2581
      *tmp___13 = *tmp___14;
#line 2580
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2582
    if (replstr) {
#line 2583
      p = replstr;
      {
#line 2583
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2583
        if (! *p) {
#line 2583
          goto while_break___3;
        }
#line 2584
        tmp___15 = rr;
#line 2584
        rr ++;
#line 2584
        tmp___16 = p;
#line 2584
        p ++;
#line 2584
        *tmp___15 = *tmp___16;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 2585
    i = e;
#line 2585
    p = imd->mstr + e;
    {
#line 2585
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2585
      if (! (i < imd->mlen)) {
#line 2585
        goto while_break___4;
      }
#line 2586
      tmp___17 = rr;
#line 2586
      rr ++;
#line 2586
      tmp___18 = p;
#line 2586
      p ++;
#line 2586
      *tmp___17 = *tmp___18;
#line 2585
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2587
    t = 1;
  }
#line 2589
  *rr = (char )'\000';
#line 2590
  if (bl) {
#line 2593
    if (t) {
#line 2594
      tmp___19 = rr;
#line 2594
      rr ++;
#line 2594
      *tmp___19 = (char )' ';
    }
    {
#line 2595
    strcpy((char */* __restrict  */)rr, (char const   */* __restrict  */)(buf___7));
    }
  }
#line 2597
  return (r);
}
}
#line 2600 "/tmp/zsh-5.4.2/Src/glob.c"
static Patprog compgetmatch(char *pat , int *flp , char **replstrp ) 
{ 
  Patprog p ;
  int patflags___0 ;
  int tmp ;

  {
#line 2616
  if (*replstrp) {
#line 2616
    tmp = 0;
  } else {
#line 2616
    tmp = 64;
  }
#line 2616
  patflags___0 = 136 | tmp;
#line 2623
  if (*flp & 256) {
#line 2624
    patflags___0 &= -9;
  } else
#line 2623
  if (*flp & 1) {
#line 2623
    if (! (*flp & 4)) {
#line 2624
      patflags___0 &= -9;
    }
  }
  {
#line 2625
  p = patcompile(pat, patflags___0, (char **)((void *)0));
  }
#line 2626
  if (! p) {
    {
#line 2627
    zerr("bad pattern: %s", pat);
    }
#line 2628
    return ((Patprog )((void *)0));
  }
#line 2630
  if (*replstrp) {
#line 2631
    if (p->patnpar) {
#line 2636
      *flp |= 1024;
    } else
#line 2631
    if (p->globend & 2048) {
#line 2636
      *flp |= 1024;
    } else {
      {
#line 2638
      singsub(replstrp);
#line 2639
      untokenize(*replstrp);
      }
    }
  }
#line 2643
  return (p);
}
}
#line 2660 "/tmp/zsh-5.4.2/Src/glob.c"
int getmatch(char **sp___0 , char *pat , int fl , int n , char *replstr ) 
{ 
  Patprog p ;
  int tmp ;

  {
  {
#line 2665
  p = compgetmatch(pat, & fl, & replstr);
  }
#line 2665
  if (! p) {
#line 2666
    return (1);
  }
  {
#line 2668
  tmp = igetmatch(sp___0, p, fl, n, replstr, (LinkList *)((void *)0));
  }
#line 2668
  return (tmp);
}
}
#line 2677 "/tmp/zsh-5.4.2/Src/glob.c"
void getmatcharr(char ***ap , char *pat , int fl , int n , char *replstr ) 
{ 
  char **arr ;
  char **pp ;
  Patprog p ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char **tmp___3 ;

  {
  {
#line 2680
  arr = *ap;
#line 2683
  p = compgetmatch(pat, & fl, & replstr);
  }
#line 2683
  if (! p) {
#line 2684
    return;
  }
  {
#line 2686
  tmp = arrlen(arr);
#line 2686
  tmp___0 = hcalloc(sizeof(char *) * (unsigned long )(tmp + 1));
#line 2686
  pp = (char **)tmp___0;
#line 2686
  *ap = pp;
  }
  {
#line 2687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2687
    tmp___3 = arr;
#line 2687
    arr ++;
#line 2687
    tmp___2 = *tmp___3;
#line 2687
    *pp = tmp___2;
#line 2687
    if (! tmp___2) {
#line 2687
      goto while_break;
    }
    {
#line 2688
    tmp___1 = igetmatch(pp, p, fl, n, replstr, (LinkList *)((void *)0));
    }
#line 2688
    if (tmp___1) {
#line 2689
      pp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2690
  return;
}
}
#line 2699 "/tmp/zsh-5.4.2/Src/glob.c"
int getmatchlist(char *str , Patprog p , LinkList *repllistp ) 
{ 
  char **sp___0 ;
  int tmp ;

  {
  {
#line 2702
  sp___0 = & str;
#line 2712
  tmp = igetmatch(sp___0, p, 8710, 0, (char *)((void *)0), repllistp);
  }
#line 2712
  return (tmp);
}
}
#line 2716 "/tmp/zsh-5.4.2/Src/glob.c"
static void freerepldata(void *ptr___0 ) 
{ 


  {
  {
#line 2719
  zfree(ptr___0, (int )sizeof(struct repldata ));
  }
#line 2720
  return;
}
}
#line 2723 "/tmp/zsh-5.4.2/Src/glob.c"
void freematchlist(LinkList repllist ) 
{ 


  {
  {
#line 2726
  freelinklist(repllist, & freerepldata);
  }
#line 2727
  return;
}
}
#line 2730 "/tmp/zsh-5.4.2/Src/glob.c"
static void set_pat_start(Patprog p , int offs ) 
{ 


  {
#line 2740
  if (offs) {
#line 2741
    p->flags |= 512;
  } else {
#line 2743
    p->flags &= -513;
  }
#line 2744
  return;
}
}
#line 2747 "/tmp/zsh-5.4.2/Src/glob.c"
static void set_pat_end(Patprog p , char null_me ) 
{ 


  {
#line 2756
  if (null_me) {
#line 2757
    p->flags |= 1024;
  } else {
#line 2759
    p->flags &= -1025;
  }
#line 2760
  return;
}
}
#line 2772 "/tmp/zsh-5.4.2/Src/glob.c"
static int iincchar(char **tp , int left ) 
{ 
  char *t ;
  int mbclen ;
  int tmp ;

  {
  {
#line 2774
  t = *tp;
#line 2775
  tmp = mb_charlenconv((char const   *)t, left, (wint_t *)((void *)0));
#line 2775
  mbclen = tmp;
#line 2776
  *tp = t + mbclen;
  }
#line 2778
  return (mbclen);
}
}
#line 2782 "/tmp/zsh-5.4.2/Src/glob.c"
static int igetmatch(char **sp___0 , Patprog p , int fl , int n , char *replstr ,
                     LinkList *repllistp ) 
{ 
  char *s ;
  char *t ;
  char *tmatch ;
  char *send ;
  int ioff ;
  int l ;
  size_t tmp ;
  int matched ;
  int umltot ;
  int tmp___0 ;
  int umlen ;
  int nmatches ;
  struct patstralloc patstralloc ;
  struct imatchdata imd ;
  char *muststr ;
  int tmp___1 ;
  int i ;
  int tmp___2 ;
  int tmp___3 ;
  int mlen ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  LinkList tmp___15 ;
  LinkList tmp___16 ;
  char *mpos ;
  int tmp___17 ;
  char *ptr___0 ;
  int umlen2 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char *mpos___0 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  LinkNode nd ;
  Repldata rd ;
  int lleft ;
  char *ptr___1 ;
  char *start ;
  int i___0 ;
  size_t tmp___38 ;
  void *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;

  {
  {
#line 2786
  s = *sp___0;
#line 2799
  tmp = strlen((char const   *)*sp___0);
#line 2799
  l = (int )tmp;
#line 2799
  matched = 1;
#line 2799
  tmp___0 = ztrlen((char const   *)*sp___0);
#line 2799
  umltot = tmp___0;
#line 2804
  patallocstr(p, s, l, umltot, 1, & patstralloc);
#line 2805
  s = patstralloc.alloced;
#line 2807
  send = s + umltot;
#line 2809
  imd.mstr = *sp___0;
#line 2810
  imd.mlen = l;
#line 2811
  imd.ustr = s;
#line 2812
  imd.ulen = umltot;
#line 2813
  imd.flags = fl;
#line 2814
  imd.replstr = replstr;
#line 2815
  imd.repllist = (LinkList )((void *)0);
  }
#line 2818
  if (p->mustoff) {
#line 2820
    muststr = (char *)p + p->mustoff;
#line 2822
    matched = 0;
#line 2823
    if (p->patmlen <= (long )umltot) {
#line 2825
      t = s;
      {
#line 2825
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2825
        if (! ((unsigned long )t <= (unsigned long )(send - p->patmlen))) {
#line 2825
          goto while_break;
        }
        {
#line 2827
        tmp___1 = memcmp((void const   *)muststr, (void const   *)t, (size_t )p->patmlen);
        }
#line 2827
        if (! tmp___1) {
#line 2828
          matched = 1;
#line 2829
          goto while_break;
        }
#line 2825
        t ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2836
  p->flags &= -1537;
#line 2838
  if (fl & 256) {
#line 2839
    if (matched) {
      {
#line 2839
      tmp___2 = pattrylen(p, s, umltot, 0, & patstralloc, 0);
      }
#line 2839
      if (tmp___2) {
#line 2839
        tmp___3 = 1;
      } else {
#line 2839
        tmp___3 = 0;
      }
    } else {
#line 2839
      tmp___3 = 0;
    }
#line 2839
    i = tmp___3;
#line 2840
    if (! i) {
#line 2842
      umltot = 0;
#line 2843
      imd.replstr = (char *)((void *)0);
    }
    {
#line 2845
    *sp___0 = get_match_ret(& imd, 0, umltot);
    }
#line 2846
    if (! *(*sp___0)) {
#line 2846
      if (fl & 8) {
#line 2846
        if (! i) {
#line 2847
          return (0);
        } else {
#line 2846
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2846
      if (fl & 16) {
#line 2846
        if (i) {
#line 2847
          return (0);
        }
      }
    }
#line 2848
    return (1);
  }
#line 2850
  if (matched) {
    {
#line 2868
    if ((fl & 7) == 2) {
#line 2868
      goto case_2;
    }
#line 2868
    if ((fl & 7) == 0) {
#line 2868
      goto case_2;
    }
#line 2897
    if ((fl & 7) == 1) {
#line 2897
      goto case_1;
    }
#line 2929
    if ((fl & 7) == 3) {
#line 2929
      goto case_3;
    }
#line 2953
    if ((fl & 7) == 4) {
#line 2953
      goto case_4;
    }
#line 2962
    if ((fl & 7) == 6) {
#line 2962
      goto case_6;
    }
#line 3052
    if ((fl & 7) == 7) {
#line 3052
      goto case_7;
    }
#line 3052
    if ((fl & 7) == 5) {
#line 3052
      goto case_7;
    }
#line 2866
    goto switch_break;
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 2873
    tmp___7 = pattrylen(p, s, umltot, 0, & patstralloc, 0);
    }
#line 2873
    if (tmp___7) {
      {
#line 2875
      tmp___4 = patmatchlen();
#line 2875
      mlen = tmp___4;
      }
#line 2876
      if (! (fl & 2)) {
#line 2876
        if (! (p->flags & 32)) {
          {
#line 2877
          send = s + mlen;
#line 2882
          mb_charinit();
#line 2883
          t = s;
#line 2883
          umlen = 0;
          }
          {
#line 2883
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2883
            if (! ((unsigned long )t < (unsigned long )send)) {
#line 2883
              goto while_break___0;
            }
            {
#line 2884
            set_pat_end(p, *t);
#line 2885
            tmp___5 = pattrylen(p, s, umlen, 0, & patstralloc, 0);
            }
#line 2885
            if (tmp___5) {
              {
#line 2886
              mlen = patmatchlen();
              }
#line 2887
              goto while_break___0;
            }
            {
#line 2889
            tmp___6 = iincchar(& t, (int )(send - t));
#line 2889
            umlen += tmp___6;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
      {
#line 2892
      *sp___0 = get_match_ret(& imd, 0, mlen);
      }
#line 2893
      return (1);
    }
#line 2895
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 2908
    mb_charinit();
#line 2909
    tmatch = (char *)((void *)0);
#line 2910
    ioff = 0;
#line 2910
    t = s;
#line 2910
    umlen = umltot;
    }
    {
#line 2910
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2910
      if (! ((unsigned long )t < (unsigned long )send)) {
#line 2910
        goto while_break___1;
      }
      {
#line 2911
      set_pat_start(p, (int )(t - s));
#line 2912
      tmp___8 = pattrylen(p, t, umlen, 0, & patstralloc, ioff);
      }
#line 2912
      if (tmp___8) {
#line 2913
        tmatch = t;
      }
#line 2914
      if (fl & 4096) {
#line 2915
        goto while_break___1;
      }
      {
#line 2916
      tmp___9 = iincchar(& t, (int )(send - t));
#line 2916
      umlen -= tmp___9;
#line 2910
      ioff ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2918
    if (tmatch) {
      {
#line 2919
      *sp___0 = get_match_ret(& imd, (int )(tmatch - s), umltot);
      }
#line 2920
      return (1);
    }
#line 2922
    if (! (fl & 4096)) {
      {
#line 2922
      tmp___10 = pattrylen(p, s + umltot, 0, 0, & patstralloc, ioff);
      }
#line 2922
      if (tmp___10) {
        {
#line 2924
        *sp___0 = get_match_ret(& imd, umltot, umltot);
        }
#line 2925
        return (1);
      }
    }
#line 2927
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 2933
    mb_charinit();
#line 2934
    ioff = 0;
#line 2934
    t = s;
#line 2934
    umlen = umltot;
    }
    {
#line 2934
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2934
      if (! ((unsigned long )t <= (unsigned long )send)) {
#line 2934
        goto while_break___2;
      }
      {
#line 2935
      set_pat_start(p, (int )(t - s));
#line 2936
      tmp___11 = pattrylen(p, t, umlen, 0, & patstralloc, ioff);
      }
#line 2936
      if (tmp___11) {
        {
#line 2937
        *sp___0 = get_match_ret(& imd, (int )(t - s), umltot);
        }
#line 2938
        return (1);
      }
#line 2940
      if (fl & 4096) {
#line 2941
        goto while_break___2;
      }
#line 2942
      if ((unsigned long )t == (unsigned long )send) {
#line 2943
        goto while_break___2;
      }
      {
#line 2944
      tmp___12 = iincchar(& t, (int )(send - t));
#line 2944
      umlen -= tmp___12;
#line 2934
      ioff ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2946
    if (! (fl & 4096)) {
      {
#line 2946
      tmp___13 = pattrylen(p, send, 0, 0, & patstralloc, ioff);
      }
#line 2946
      if (tmp___13) {
        {
#line 2948
        *sp___0 = get_match_ret(& imd, umltot, umltot);
        }
#line 2949
        return (1);
      }
    }
#line 2951
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 2955
    set_pat_start(p, l);
    }
#line 2956
    if (! (fl & 512)) {
      {
#line 2956
      tmp___14 = pattrylen(p, send, 0, 0, & patstralloc, 0);
      }
#line 2956
      if (tmp___14) {
#line 2956
        n --;
#line 2956
        if (! n) {
          {
#line 2959
          *sp___0 = get_match_ret(& imd, 0, 0);
          }
#line 2960
          return (1);
        }
      }
    }
    case_6: /* CIL Label */ 
#line 2964
    t = s;
#line 2965
    if (fl & 512) {
#line 2966
      if (fl & 8192) {
        {
#line 2966
        tmp___15 = znewlinklist();
#line 2966
        imd.repllist = tmp___15;
        }
      } else {
        {
#line 2966
        tmp___16 = newlinklist();
#line 2966
        imd.repllist = tmp___16;
        }
      }
#line 2967
      if (repllistp) {
#line 2968
        *repllistp = imd.repllist;
      }
    }
    {
#line 2970
    ioff = 0;
#line 2971
    umlen = umltot;
#line 2972
    mb_charinit();
    }
    {
#line 2973
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2975
      matched = 0;
      {
#line 2976
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2976
        if (! ((unsigned long )t <= (unsigned long )send)) {
#line 2976
          goto while_break___4;
        }
        {
#line 2978
        set_pat_start(p, (int )(t - s));
#line 2979
        tmp___24 = pattrylen(p, t, umlen, 0, & patstralloc, ioff);
        }
#line 2979
        if (tmp___24) {
          {
#line 2980
          tmp___17 = patmatchlen();
#line 2980
          mpos = t + tmp___17;
          }
#line 2981
          if (! (fl & 2)) {
#line 2981
            if (! (p->flags & 32)) {
#line 2991
              ptr___0 = t;
#line 2991
              umlen2 = 0;
              {
#line 2991
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 2991
                if (! ((unsigned long )ptr___0 < (unsigned long )mpos)) {
#line 2991
                  goto while_break___5;
                }
                {
#line 2992
                set_pat_end(p, *ptr___0);
#line 2993
                tmp___19 = pattrylen(p, t, umlen2, 0, & patstralloc, ioff);
                }
#line 2993
                if (tmp___19) {
                  {
#line 2995
                  tmp___18 = patmatchlen();
#line 2995
                  mpos = t + tmp___18;
                  }
#line 2996
                  goto while_break___5;
                }
                {
#line 2998
                tmp___20 = iincchar(& ptr___0, (int )(mpos - ptr___0));
#line 2998
                umlen2 += tmp___20;
                }
              }
              while_break___5: /* CIL Label */ ;
              }
            }
          }
#line 3001
          n --;
#line 3001
          if (n) {
#line 3001
            if (n <= 0) {
#line 3001
              if (fl & 512) {
                _L___0: /* CIL Label */ 
                {
#line 3002
                *sp___0 = get_match_ret(& imd, (int )(t - s), (int )(mpos - s));
                }
#line 3003
                if ((unsigned long )mpos == (unsigned long )t) {
                  {
#line 3004
                  tmp___21 = mb_charlenconv((char const   *)mpos, (int )(send - mpos),
                                            (wint_t *)((void *)0));
#line 3004
                  mpos += tmp___21;
                  }
                }
              }
            }
          } else {
#line 3001
            goto _L___0;
          }
#line 3006
          if (! (fl & 512)) {
#line 3007
            if (n) {
              {
#line 3014
              tmp___22 = iincchar(& t, (int )(send - t));
#line 3014
              umlen -= tmp___22;
              }
#line 3015
              goto __Cont;
            } else {
#line 3017
              return (1);
            }
          }
#line 3024
          matched = 1;
#line 3025
          if ((unsigned long )t == (unsigned long )send) {
#line 3026
            goto while_break___4;
          }
          {
#line 3027
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 3027
            if (! ((unsigned long )t < (unsigned long )mpos)) {
#line 3027
              goto while_break___6;
            }
            {
#line 3028
            ioff ++;
#line 3029
            tmp___23 = iincchar(& t, (int )(send - t));
#line 3029
            umlen -= tmp___23;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
#line 3031
          goto while_break___4;
        }
#line 3033
        if ((unsigned long )t == (unsigned long )send) {
#line 3034
          goto while_break___4;
        }
        {
#line 3035
        tmp___25 = iincchar(& t, (int )(send - t));
#line 3035
        umlen -= tmp___25;
        }
        __Cont: /* CIL Label */ 
#line 2976
        ioff ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2973
      if (matched) {
#line 2973
        if (! ((unsigned long )t < (unsigned long )send)) {
#line 2973
          goto while_break___3;
        }
      } else {
#line 2973
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 3043
    set_pat_start(p, l);
    }
#line 3044
    if ((fl & 514) == 2) {
      {
#line 3044
      tmp___26 = pattrylen(p, send, 0, 0, & patstralloc, 0);
      }
#line 3044
      if (tmp___26) {
#line 3044
        n --;
#line 3044
        if (! n) {
          {
#line 3046
          *sp___0 = get_match_ret(& imd, 0, 0);
          }
#line 3047
          return (1);
        }
      }
    }
#line 3049
    goto switch_break;
    case_7: /* CIL Label */ 
    case_5: /* CIL Label */ 
#line 3054
    if (! (fl & 2)) {
      {
#line 3055
      set_pat_start(p, l);
#line 3056
      tmp___27 = pattrylen(p, send, 0, 0, & patstralloc, umltot);
      }
#line 3056
      if (tmp___27) {
#line 3056
        n --;
#line 3056
        if (! n) {
          {
#line 3058
          *sp___0 = get_match_ret(& imd, umltot, umltot);
          }
#line 3059
          return (1);
        }
      }
    }
    {
#line 3072
    nmatches = 0;
#line 3073
    tmatch = (char *)((void *)0);
#line 3074
    mb_charinit();
#line 3075
    ioff = 0;
#line 3075
    t = s;
#line 3075
    umlen = umltot;
    }
    {
#line 3075
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 3075
      if (! ((unsigned long )t < (unsigned long )send)) {
#line 3075
        goto while_break___7;
      }
      {
#line 3076
      set_pat_start(p, (int )(t - s));
#line 3077
      tmp___28 = pattrylen(p, t, umlen, 0, & patstralloc, ioff);
      }
#line 3077
      if (tmp___28) {
#line 3078
        nmatches ++;
#line 3079
        tmatch = t;
      }
      {
#line 3081
      tmp___29 = iincchar(& t, (int )(send - t));
#line 3081
      umlen -= tmp___29;
#line 3075
      ioff ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 3083
    if (nmatches) {
#line 3085
      if (n > 1) {
        {
#line 3089
        n = nmatches - n;
#line 3090
        mb_charinit();
#line 3091
        ioff = 0;
#line 3091
        t = s;
#line 3091
        umlen = umltot;
        }
        {
#line 3091
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 3091
          if (! ((unsigned long )t < (unsigned long )send)) {
#line 3091
            goto while_break___8;
          }
          {
#line 3092
          set_pat_start(p, (int )(t - s));
#line 3093
          tmp___30 = pattrylen(p, t, umlen, 0, & patstralloc, ioff);
          }
#line 3093
          if (tmp___30) {
#line 3093
            tmp___31 = n;
#line 3093
            n --;
#line 3093
            if (! tmp___31) {
#line 3095
              tmatch = t;
#line 3096
              goto while_break___8;
            }
          }
          {
#line 3098
          tmp___32 = iincchar(& t, (int )(send - t));
#line 3098
          umlen -= tmp___32;
#line 3091
          ioff ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
      }
      {
#line 3101
      tmp___33 = patmatchlen();
#line 3101
      mpos___0 = tmatch + tmp___33;
      }
#line 3103
      if (! (fl & 2)) {
#line 3103
        if (! (p->flags & 32)) {
#line 3104
          t = tmatch;
#line 3104
          umlen = 0;
          {
#line 3104
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 3104
            if (! ((unsigned long )t < (unsigned long )mpos___0)) {
#line 3104
              goto while_break___9;
            }
            {
#line 3105
            set_pat_end(p, *t);
#line 3106
            tmp___35 = pattrylen(p, tmatch, umlen, 0, & patstralloc, ioff);
            }
#line 3106
            if (tmp___35) {
              {
#line 3108
              tmp___34 = patmatchlen();
#line 3108
              mpos___0 = tmatch + tmp___34;
              }
#line 3109
              goto while_break___9;
            }
            {
#line 3111
            tmp___36 = iincchar(& t, (int )(mpos___0 - t));
#line 3111
            umlen += tmp___36;
            }
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
      {
#line 3114
      *sp___0 = get_match_ret(& imd, (int )(tmatch - s), (int )(mpos___0 - s));
      }
#line 3115
      return (1);
    }
    {
#line 3117
    set_pat_start(p, l);
    }
#line 3118
    if (fl & 2) {
      {
#line 3118
      tmp___37 = pattrylen(p, send, 0, 0, & patstralloc, umltot);
      }
#line 3118
      if (tmp___37) {
#line 3118
        n --;
#line 3118
        if (! n) {
          {
#line 3121
          *sp___0 = get_match_ret(& imd, umltot, umltot);
          }
#line 3122
          return (1);
        }
      }
    }
#line 3124
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 3128
  if (imd.repllist) {
#line 3128
    if ((unsigned long )(imd.repllist)->list.first != (unsigned long )((void *)0)) {
#line 3140
      s = *sp___0;
#line 3141
      if (! (fl & 8192)) {
#line 3142
        lleft = 0;
#line 3143
        i___0 = 0;
#line 3144
        nd = (imd.repllist)->list.first;
        {
#line 3144
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 3144
          if (! nd) {
#line 3144
            goto while_break___10;
          }
          {
#line 3145
          rd = (Repldata )nd->dat;
#line 3146
          lleft += rd->b - i___0;
#line 3147
          tmp___38 = strlen((char const   *)rd->replstr);
#line 3147
          lleft = (int )((size_t )lleft + tmp___38);
#line 3148
          i___0 = rd->e;
#line 3144
          nd = nd->next;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 3150
        lleft += l - i___0;
#line 3151
        tmp___39 = zhalloc((size_t )(lleft + 1));
#line 3151
        t = (char *)tmp___39;
#line 3151
        start = t;
#line 3152
        i___0 = 0;
#line 3153
        nd = (imd.repllist)->list.first;
        }
        {
#line 3153
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 3153
          if (! nd) {
#line 3153
            goto while_break___11;
          }
          {
#line 3154
          rd = (Repldata )nd->dat;
#line 3155
          memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)(s + i___0),
                 (size_t )(rd->b - i___0));
#line 3156
          t += rd->b - i___0;
#line 3157
          ptr___1 = rd->replstr;
          }
          {
#line 3158
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 3158
            if (! *ptr___1) {
#line 3158
              goto while_break___12;
            }
#line 3159
            tmp___40 = t;
#line 3159
            t ++;
#line 3159
            tmp___41 = ptr___1;
#line 3159
            ptr___1 ++;
#line 3159
            *tmp___40 = *tmp___41;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 3160
          i___0 = rd->e;
#line 3153
          nd = nd->next;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 3162
        memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)(s + i___0),
               (size_t )(l - i___0));
#line 3163
        *(start + lleft) = (char )'\000';
#line 3164
        *sp___0 = start;
        }
      }
#line 3166
      return (1);
    }
  }
#line 3168
  if (fl & 8192) {
#line 3169
    return (0);
  }
  {
#line 3173
  imd.replstr = (char *)((void *)0);
#line 3174
  imd.repllist = (LinkList )((void *)0);
#line 3175
  *sp___0 = get_match_ret(& imd, 0, 0);
  }
#line 3176
  if (fl & 2048) {
#line 3176
    tmp___42 = 0;
  } else {
#line 3176
    tmp___42 = 1;
  }
#line 3176
  return (tmp___42);
}
}
#line 3485 "/tmp/zsh-5.4.2/Src/glob.c"
void tokenize(char *s ) 
{ 


  {
  {
#line 3488
  zshtokenize(s, 0);
  }
#line 3489
  return;
}
}
#line 3502 "/tmp/zsh-5.4.2/Src/glob.c"
void shtokenize(char *s ) 
{ 
  int flags ;

  {
#line 3505
  flags = 1;
#line 3506
  if (opts[159]) {
#line 3507
    flags |= 2;
  }
  {
#line 3508
  zshtokenize(s, flags);
  }
#line 3509
  return;
}
}
#line 3512 "/tmp/zsh-5.4.2/Src/glob.c"
static void zshtokenize(char *s , int flags ) 
{ 
  char *t ;
  int bslash ;

  {
#line 3516
  bslash = 0;
  {
#line 3518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3518
    if (! *s) {
#line 3518
      goto while_break;
    }
    cont: 
    {
#line 3521
    if ((int )*s == -125) {
#line 3521
      goto case_neg_125;
    }
#line 3527
    if ((int )*s == 92) {
#line 3527
      goto case_92;
    }
#line 3527
    if ((int )*s == -96) {
#line 3527
      goto case_92;
    }
#line 3527
    if ((int )*s == -97) {
#line 3527
      goto case_92;
    }
#line 3534
    if ((int )*s == 60) {
#line 3534
      goto case_60;
    }
#line 3553
    if ((int )*s == 41) {
#line 3553
      goto case_41;
    }
#line 3553
    if ((int )*s == 124) {
#line 3553
      goto case_41;
    }
#line 3553
    if ((int )*s == 40) {
#line 3553
      goto case_41;
    }
#line 3567
    if ((int )*s == 33) {
#line 3567
      goto case_33;
    }
#line 3567
    if ((int )*s == 45) {
#line 3567
      goto case_33;
    }
#line 3567
    if ((int )*s == 61) {
#line 3567
      goto case_33;
    }
#line 3567
    if ((int )*s == 63) {
#line 3567
      goto case_33;
    }
#line 3567
    if ((int )*s == 42) {
#line 3567
      goto case_33;
    }
#line 3567
    if ((int )*s == 93) {
#line 3567
      goto case_33;
    }
#line 3567
    if ((int )*s == 91) {
#line 3567
      goto case_33;
    }
#line 3567
    if ((int )*s == 126) {
#line 3567
      goto case_33;
    }
#line 3567
    if ((int )*s == 35) {
#line 3567
      goto case_33;
    }
#line 3567
    if ((int )*s == 94) {
#line 3567
      goto case_33;
    }
#line 3567
    if ((int )*s == 62) {
#line 3567
      goto case_33;
    }
#line 3520
    goto switch_break;
    case_neg_125: /* CIL Label */ 
#line 3523
    s ++;
#line 3524
    goto switch_break;
    case_92: /* CIL Label */ 
    case_neg_96: /* CIL Label */ 
    case_neg_97: /* CIL Label */ 
#line 3528
    if (bslash) {
#line 3529
      if (flags & 1) {
#line 3529
        *(s + -1) = (char)-96;
      } else {
#line 3529
        *(s + -1) = (char)-97;
      }
#line 3530
      goto switch_break;
    }
#line 3532
    bslash = 1;
#line 3533
    goto __Cont;
    case_60: /* CIL Label */ 
#line 3535
    if (flags & 2) {
#line 3536
      goto switch_break;
    }
#line 3537
    if (bslash) {
#line 3538
      if (flags & 1) {
#line 3538
        *(s + -1) = (char)-96;
      } else {
#line 3538
        *(s + -1) = (char)-97;
      }
#line 3539
      goto switch_break;
    }
#line 3541
    t = s;
    {
#line 3542
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3542
      s ++;
#line 3542
      if (! ((int )typtab[(unsigned char )*s] & 1)) {
#line 3542
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3543
    if (! ((int )*s == 45)) {
#line 3543
      if (! ((int )*s == -101)) {
#line 3544
        goto cont;
      }
    }
    {
#line 3545
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3545
      s ++;
#line 3545
      if (! ((int )typtab[(unsigned char )*s] & 1)) {
#line 3545
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3546
    if ((int )*s != 62) {
#line 3547
      goto cont;
    }
#line 3548
    *t = (char)-108;
#line 3549
    *s = (char)-107;
#line 3550
    goto switch_break;
    case_41: /* CIL Label */ 
    case_124: /* CIL Label */ 
    case_40: /* CIL Label */ 
#line 3554
    if (flags & 2) {
#line 3555
      goto switch_break;
    }
    case_33: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_61: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_62: /* CIL Label */ 
#line 3568
    t = ztokens;
    {
#line 3568
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3568
      if (! *t) {
#line 3568
        goto while_break___2;
      }
#line 3569
      if ((int )*t == (int )*s) {
#line 3570
        if (bslash) {
#line 3571
          if (flags & 1) {
#line 3571
            *(s + -1) = (char)-96;
          } else {
#line 3571
            *(s + -1) = (char)-97;
          }
        } else {
#line 3573
          *s = (char )((t - ztokens) + -124L);
        }
#line 3574
        goto while_break___2;
      }
#line 3568
      t ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3577
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3579
    bslash = 0;
    __Cont: /* CIL Label */ 
#line 3518
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3581
  return;
}
}
#line 3586 "/tmp/zsh-5.4.2/Src/glob.c"
void remnulargs(char *s ) 
{ 
  char *o ;
  char c ;
  char *t ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 3589
  if (*s) {
#line 3590
    o = s;
    {
#line 3592
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3592
      tmp___2 = s;
#line 3592
      s ++;
#line 3592
      c = *tmp___2;
#line 3592
      if (! c) {
#line 3592
        goto while_break;
      }
#line 3593
      if ((int )c == -96) {
#line 3600
        goto while_continue;
      } else
#line 3601
      if ((int )typtab[(unsigned char )c] & (1 << 14)) {
#line 3602
        t = s - 1;
        {
#line 3604
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3604
          tmp___1 = s;
#line 3604
          s ++;
#line 3604
          c = *tmp___1;
#line 3604
          if (! c) {
#line 3604
            goto while_break___0;
          }
#line 3605
          if ((int )c == -96) {
#line 3606
            tmp = t;
#line 3606
            t ++;
#line 3606
            *tmp = (char )'\\';
          } else
#line 3607
          if (! ((int )typtab[(unsigned char )c] & (1 << 14))) {
#line 3608
            tmp___0 = t;
#line 3608
            t ++;
#line 3608
            *tmp___0 = c;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 3610
        *t = (char )'\000';
#line 3611
        if (! *o) {
#line 3612
          *(o + 0) = (char)-95;
#line 3613
          *(o + 1) = (char )'\000';
        }
#line 3615
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3618
  return;
}
}
#line 3625 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualdev(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                   off_t dv , char *dummy___0  __attribute__((__unused__)) ) 
{ 


  {
#line 3628
  return ((off_t )buf___7->st_dev == dv);
}
}
#line 3634 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualnlink(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t ct , char *dummy___0  __attribute__((__unused__)) ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 3637
  if (curglobdata.gd_range < 0) {
#line 3637
    tmp___0 = buf___7->st_nlink < (__nlink_t )ct;
  } else {
#line 3637
    if (curglobdata.gd_range > 0) {
#line 3637
      tmp = buf___7->st_nlink > (__nlink_t )ct;
    } else {
#line 3637
      tmp = buf___7->st_nlink == (__nlink_t )ct;
    }
#line 3637
    tmp___0 = tmp;
  }
#line 3637
  return (tmp___0);
}
}
#line 3645 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualuid(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                   off_t uid , char *dummy___0  __attribute__((__unused__)) ) 
{ 


  {
#line 3648
  return ((off_t )buf___7->st_uid == uid);
}
}
#line 3654 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualgid(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                   off_t gid , char *dummy___0  __attribute__((__unused__)) ) 
{ 


  {
#line 3657
  return ((off_t )buf___7->st_gid == gid);
}
}
#line 3663 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualisdev(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) 
{ 
  int tmp ;

  {
#line 3666
  if ((buf___7->st_mode & 61440U) == 24576U) {
#line 3666
    tmp = 1;
  } else
#line 3666
  if ((buf___7->st_mode & 61440U) == 8192U) {
#line 3666
    tmp = 1;
  } else {
#line 3666
    tmp = 0;
  }
#line 3666
  return (tmp);
}
}
#line 3672 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualisblk(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) 
{ 


  {
#line 3675
  return ((buf___7->st_mode & 61440U) == 24576U);
}
}
#line 3681 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualischr(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) 
{ 


  {
#line 3684
  return ((buf___7->st_mode & 61440U) == 8192U);
}
}
#line 3690 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualisdir(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) 
{ 


  {
#line 3693
  return ((buf___7->st_mode & 61440U) == 16384U);
}
}
#line 3699 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualisfifo(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                      off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) 
{ 


  {
#line 3702
  return ((buf___7->st_mode & 61440U) == 4096U);
}
}
#line 3708 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualislnk(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) 
{ 


  {
#line 3711
  return ((buf___7->st_mode & 61440U) == 40960U);
}
}
#line 3717 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualisreg(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) 
{ 


  {
#line 3720
  return ((buf___7->st_mode & 61440U) == 32768U);
}
}
#line 3726 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualissock(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                      off_t junk  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) 
{ 


  {
#line 3729
  return ((buf___7->st_mode & 61440U) == 49152U);
}
}
#line 3735 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualflags(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t mod , char *dummy___0  __attribute__((__unused__)) ) 
{ 
  int tmp ;

  {
  {
#line 3738
  tmp = mode_to_octal(buf___7->st_mode);
  }
#line 3738
  return ((int )((long )tmp & mod));
}
}
#line 3744 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualmodeflags(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                         off_t mod , char *dummy___0  __attribute__((__unused__)) ) 
{ 
  long v ;
  int tmp ;
  long y ;
  long n ;
  int tmp___0 ;

  {
  {
#line 3747
  tmp = mode_to_octal(buf___7->st_mode);
#line 3747
  v = (long )tmp;
#line 3747
  y = mod & 4095L;
#line 3747
  n = mod >> 12;
  }
#line 3749
  if ((v & y) == y) {
#line 3749
    if (! (v & n)) {
#line 3749
      tmp___0 = 1;
    } else {
#line 3749
      tmp___0 = 0;
    }
  } else {
#line 3749
    tmp___0 = 0;
  }
#line 3749
  return (tmp___0);
}
}
#line 3755 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualiscom(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                     off_t mod  __attribute__((__unused__)) , char *dummy___0  __attribute__((__unused__)) ) 
{ 
  int tmp ;

  {
#line 3758
  if ((buf___7->st_mode & 61440U) == 32768U) {
#line 3758
    if (buf___7->st_mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 3758
      tmp = 1;
    } else {
#line 3758
      tmp = 0;
    }
  } else {
#line 3758
    tmp = 0;
  }
#line 3758
  return (tmp);
}
}
#line 3764 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualsize(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                    off_t size , char *dummy___0  __attribute__((__unused__)) ) 
{ 
  zlong scaled ;
  int tmp ;
  int tmp___0 ;

  {
#line 3769
  scaled = buf___7->st_size;
  {
#line 3776
  if (curglobdata.gd_units == 1) {
#line 3776
    goto case_1;
  }
#line 3780
  if (curglobdata.gd_units == 2) {
#line 3780
    goto case_2;
  }
#line 3784
  if (curglobdata.gd_units == 3) {
#line 3784
    goto case_3;
  }
#line 3789
  if (curglobdata.gd_units == 4) {
#line 3789
    goto case_4;
  }
#line 3793
  if (curglobdata.gd_units == 5) {
#line 3793
    goto case_5;
  }
#line 3775
  goto switch_break;
  case_1: /* CIL Label */ 
#line 3777
  scaled += 511L;
#line 3778
  scaled /= 512L;
#line 3779
  goto switch_break;
  case_2: /* CIL Label */ 
#line 3781
  scaled += 1023L;
#line 3782
  scaled /= 1024L;
#line 3783
  goto switch_break;
  case_3: /* CIL Label */ 
#line 3785
  scaled += 1048575L;
#line 3786
  scaled /= 1048576L;
#line 3787
  goto switch_break;
  case_4: /* CIL Label */ 
#line 3790
  scaled += 1073741823L;
#line 3791
  scaled /= 1073741824L;
#line 3792
  goto switch_break;
  case_5: /* CIL Label */ 
#line 3794
  scaled += 1099511627775L;
#line 3795
  scaled /= 1099511627776L;
#line 3796
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3800
  if (curglobdata.gd_range < 0) {
#line 3800
    tmp___0 = scaled < size;
  } else {
#line 3800
    if (curglobdata.gd_range > 0) {
#line 3800
      tmp = scaled > size;
    } else {
#line 3800
      tmp = scaled == size;
    }
#line 3800
    tmp___0 = tmp;
  }
#line 3800
  return (tmp___0);
}
}
#line 3809 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualtime(char *name  __attribute__((__unused__)) , struct stat *buf___7 ,
                    off_t days , char *dummy___0  __attribute__((__unused__)) ) 
{ 
  time_t now ;
  time_t diff ;
  __time_t tmp ;
  __time_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3814
  time(& now);
  }
#line 3815
  if (curglobdata.gd_amc == 0) {
#line 3815
    tmp___0 = buf___7->st_atim.tv_sec;
  } else {
#line 3815
    if (curglobdata.gd_amc == 1) {
#line 3815
      tmp = buf___7->st_mtim.tv_sec;
    } else {
#line 3815
      tmp = buf___7->st_ctim.tv_sec;
    }
#line 3815
    tmp___0 = tmp;
  }
#line 3815
  diff = now - tmp___0;
  {
#line 3819
  if (curglobdata.gd_units == 0) {
#line 3819
    goto case_0;
  }
#line 3822
  if (curglobdata.gd_units == 1) {
#line 3822
    goto case_1;
  }
#line 3825
  if (curglobdata.gd_units == 2) {
#line 3825
    goto case_2;
  }
#line 3828
  if (curglobdata.gd_units == 3) {
#line 3828
    goto case_3;
  }
#line 3831
  if (curglobdata.gd_units == 4) {
#line 3831
    goto case_4;
  }
#line 3818
  goto switch_break;
  case_0: /* CIL Label */ 
#line 3820
  diff /= 86400L;
#line 3821
  goto switch_break;
  case_1: /* CIL Label */ 
#line 3823
  diff /= 3600L;
#line 3824
  goto switch_break;
  case_2: /* CIL Label */ 
#line 3826
  diff /= 60L;
#line 3827
  goto switch_break;
  case_3: /* CIL Label */ 
#line 3829
  diff /= 604800L;
#line 3830
  goto switch_break;
  case_4: /* CIL Label */ 
#line 3832
  diff /= 2592000L;
#line 3833
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3836
  if (curglobdata.gd_range < 0) {
#line 3836
    tmp___2 = diff < days;
  } else {
#line 3836
    if (curglobdata.gd_range > 0) {
#line 3836
      tmp___1 = diff > days;
    } else {
#line 3836
      tmp___1 = diff == days;
    }
#line 3836
    tmp___2 = tmp___1;
  }
#line 3836
  return (tmp___2);
}
}
#line 3870 "/tmp/zsh-5.4.2/Src/glob.c"
static char *tmparr[2]  ;
#line 3844 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualsheval(char *name , struct stat *buf___7  __attribute__((__unused__)) ,
                      off_t days  __attribute__((__unused__)) , char *str ) 
{ 
  Eprog prog ;
  int ef ;
  int lv ;
  int ret ;
  int cshglob ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 3849
  prog = parse_string(str, 0);
  }
#line 3849
  if (prog) {
    {
#line 3850
    ef = errflag;
#line 3850
    lv = (int )lastval;
#line 3851
    cshglob = badcshglob;
#line 3853
    unsetparam((char *)"reply");
#line 3854
    tmp = ztrdup((char const   *)name);
#line 3854
    setsparam((char *)"REPLY", tmp);
#line 3855
    badcshglob = 0;
#line 3857
    execode(prog, 1, 0, (char *)"globqual");
#line 3859
    ret = (int )lastval;
    }
#line 3859
    if (ret) {
#line 3860
      badcshglob |= cshglob;
    }
    {
#line 3862
    errflag = ef | (errflag & 2);
#line 3863
    lastval = (zlong )lv;
#line 3865
    inserts = getaparam((char *)"reply");
    }
#line 3865
    if (! inserts) {
      {
#line 3865
      inserts = gethparam((char *)"reply");
      }
#line 3865
      if (! inserts) {
        {
#line 3869
        tmp___0 = getsparam((char *)"reply");
        }
#line 3869
        if (tmp___0) {
#line 3872
          tmparr[0] = tmp___0;
#line 3873
          tmparr[1] = (char *)((void *)0);
#line 3875
          inserts = tmparr;
        } else {
          {
#line 3869
          tmp___0 = getsparam((char *)"REPLY");
          }
#line 3869
          if (tmp___0) {
#line 3872
            tmparr[0] = tmp___0;
#line 3873
            tmparr[1] = (char *)((void *)0);
#line 3875
            inserts = tmparr;
          }
        }
      }
    }
#line 3879
    return (! ret);
  }
#line 3881
  return (0);
}
}
#line 3885 "/tmp/zsh-5.4.2/Src/glob.c"
static int qualnonemptydir(char *name , struct stat *buf___7 , off_t days  __attribute__((__unused__)) ,
                           char *str  __attribute__((__unused__)) ) 
{ 
  DIR *dirh ;
  struct dirent *de ;
  int unamelen ;
  char *uname___0 ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3891
  tmp = dupstring((char const   *)name);
#line 3891
  tmp___0 = unmetafy(tmp, & unamelen);
#line 3891
  uname___0 = tmp___0;
  }
#line 3893
  if (! ((buf___7->st_mode & 61440U) == 16384U)) {
#line 3894
    return (0);
  }
#line 3896
  if (buf___7->st_nlink > 2UL) {
#line 3897
    return (1);
  }
  {
#line 3899
  dirh = opendir((char const   *)uname___0);
  }
#line 3899
  if (! dirh) {
#line 3900
    return (0);
  }
  {
#line 3902
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3902
    de = readdir(dirh);
    }
#line 3902
    if (! de) {
#line 3902
      goto while_break;
    }
    {
#line 3903
    tmp___1 = strcmp((char const   *)(de->d_name), ".");
    }
#line 3903
    if (tmp___1) {
      {
#line 3903
      tmp___2 = strcmp((char const   *)(de->d_name), "..");
      }
#line 3903
      if (tmp___2) {
        {
#line 3904
        closedir(dirh);
        }
#line 3905
        return (1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3909
  closedir(dirh);
  }
#line 3910
  return (0);
}
}
#line 554 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) execve)(char const   *__path ,
                                                                                     char * const  *__argv ,
                                                                                     char * const  *__envp ) ;
#line 601
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 759
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 792
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) link)(char const   *__from ,
                                                                                   char const   *__to ) ;
#line 69 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit  const  *__rlimits ) ;
#line 8 "./builtin.epro"
int execbuiltin(LinkList args , LinkList assigns , Builtin bn ) ;
#line 11
int doprintdir ;
#line 17
char *cd_able_vars(char *s ) ;
#line 18
int fixdir(char *src ) ;
#line 27
int bin_whence(char *nam , char **argv , Options ops , int func ) ;
#line 36
int optcind ;
#line 39
int exit_level ;
#line 46
int ineval ;
#line 5 "./cond.epro"
int tracingcond ;
#line 6
int evalcond(Estate state , char *fromtest ) ;
#line 5 "./exec.epro"
int noerrexit  ;
#line 6 "./exec.epro"
int this_noerrexit  ;
#line 7 "./exec.epro"
int noerrs  ;
#line 8 "./exec.epro"
int nohistsave  ;
#line 9 "./exec.epro"
int errflag  ;
#line 10 "./exec.epro"
int trap_state  ;
#line 11 "./exec.epro"
int trap_return  ;
#line 12 "./exec.epro"
int subsh  ;
#line 13 "./exec.epro"
int retflag  ;
#line 14 "./exec.epro"
long lastval2  ;
#line 15 "./exec.epro"
unsigned char *fdtable  ;
#line 16 "./exec.epro"
int fdtable_size  ;
#line 17 "./exec.epro"
int max_zsh_fd  ;
#line 18 "./exec.epro"
int coprocin  ;
#line 19 "./exec.epro"
int coprocout  ;
#line 20 "./exec.epro"
int fdtable_flocks  ;
#line 21 "./exec.epro"
int zleactive  ;
#line 22 "./exec.epro"
pid_t cmdoutpid  ;
#line 23 "./exec.epro"
int cmdoutval  ;
#line 24 "./exec.epro"
int use_cmdoutval  ;
#line 25 "./exec.epro"
int sfcontext  ;
#line 26 "./exec.epro"
struct execstack *exstack  ;
#line 27 "./exec.epro"
Funcstack funcstack  ;
#line 30 "./exec.epro"
struct rlimit current_limits[16]  ;
#line 31 "./exec.epro"
struct rlimit limits[16]  ;
#line 32
int zsetlimit(int limnum , char *nam ) ;
#line 33
int setlimits(char *nam ) ;
#line 38
int iscom(char *s ) ;
#line 39
int isreallycom(Cmdnam cn ) ;
#line 42 "./exec.epro"
int forklevel  ;
#line 50
void closem(int how ) ;
#line 53
LinkList readoutput(int in , int qt ) ;
#line 57
void shfunc_set_sticky(Shfunc shf ) ;
#line 58
Shfunc loadautofn(Shfunc shf , int fksh , int autol , int current_fpath ) ;
#line 59
int sticky_emulation_differs(Emulation_options sticky2 ) ;
#line 61
void runshfunc(Eprog prog , FuncWrap wrap , char *name ) ;
#line 63
Eprog stripkshdef(Eprog prog , char *name ) ;
#line 4 "./exec.pro"
static pid_t zfork(struct timeval *tv ) ;
#line 5
static int execcursh(Estate state , int do_exec ) ;
#line 6
static int zexecve(char *pth , char **argv , char **newenvp ) ;
#line 7
static int isgooderr(int e , char *dir ) ;
#line 8
static int commandnotfound(char *arg0 , LinkList args ) ;
#line 9
static void execute(LinkList args , int flags , int defpath ) ;
#line 10
static void entersubsh(int flags ) ;
#line 11
static int execsimple(Estate state ) ;
#line 12
static int execpline(Estate state , wordcode slcode , int how , int last1 ) ;
#line 13
static void execpline2(Estate state , wordcode pcode , int how , int input , int output ,
                       int last1 ) ;
#line 14
static char **makecline(LinkList list ) ;
#line 15
static int clobber_open(struct redir *f ) ;
#line 16
static void closemn(struct multio **mfds , int fd , int type___0 ) ;
#line 17
static void closemnodes(struct multio **mfds ) ;
#line 18
static void closeallelse(struct multio *mn ) ;
#line 19
static void addfd(int forked , int *save , struct multio **mfds , int fd1 , int fd2 ,
                  int rflag , char *varid ) ;
#line 20
static void addvars(Estate state , Wordcode pc , int addflags ) ;
#line 21
static HashNode resolvebuiltin(char const   *cmdarg , HashNode hn ) ;
#line 22
static void execcmd_analyse(Estate state , Execcmd_params eparams ) ;
#line 23
static void execcmd_exec(Estate state , Execcmd_params eparams , int input , int output ,
                         int how , int last1 ) ;
#line 24
static void save_params(Estate state , Wordcode pc , LinkList *restore_p , LinkList *remove_p ) ;
#line 25
static void restore_params(LinkList restorelist , LinkList removelist ) ;
#line 26
static void fixfds(int *save ) ;
#line 27
static int getherestr(struct redir *fn___0 ) ;
#line 28
static Eprog parsecmd(char *cmd , char **eptr ) ;
#line 29
static int getpipe(char *cmd , int nullexec ) ;
#line 30
static int mpipe(int *pp ) ;
#line 31
static void spawnpipes(LinkList l , int nullexec ) ;
#line 32
static int execcond(Estate state , int do_exec  __attribute__((__unused__)) ) ;
#line 33
static int execarith(Estate state , int do_exec  __attribute__((__unused__)) ) ;
#line 34
static int exectime(Estate state , int do_exec  __attribute__((__unused__)) ) ;
#line 35
static int execfuncdef(Estate state , Eprog redir_prog ) ;
#line 36
static void execshfunc(Shfunc shf , LinkList args ) ;
#line 37
static int execautofn_basic(Estate state , int do_exec  __attribute__((__unused__)) ) ;
#line 38
static int execautofn(Estate state , int do_exec  __attribute__((__unused__)) ) ;
#line 39
static void loadautofnsetfile(Shfunc shf , char *fdir ) ;
#line 40
static char *cancd(char *s ) ;
#line 41
static int cancd2(char *s ) ;
#line 203 "/tmp/zsh-5.4.2/Src/exec.c"
static int doneps4  ;
#line 204 "/tmp/zsh-5.4.2/Src/exec.c"
static char *STTYval  ;
#line 205 "/tmp/zsh-5.4.2/Src/exec.c"
static char *blank_env[1]  = {      (char *)((void *)0)};
#line 209 "/tmp/zsh-5.4.2/Src/exec.c"
static int (*execfuncs[13])(Estate  , int  )  = 
#line 209
  {      & execcursh,      & exectime,      (int (*)(Estate  , int  ))((void *)0),      & execfor, 
        & execselect,      & execwhile,      & execrepeat,      & execcase, 
        & execif,      & execcond,      & execarith,      & execautofn, 
        & exectry};
#line 217 "/tmp/zsh-5.4.2/Src/exec.c"
static struct builtin commandbn  =    {{(HashNode )((void *)0), (char *)"command", 0}, & bin_whence, 0, -1, 27, (char *)"pvV",
    (char *)((void *)0)};
#line 223 "/tmp/zsh-5.4.2/Src/exec.c"
Eprog parse_string(char *s , int reset_lineno ) 
{ 
  Eprog p ;
  zlong oldlineno ;

  {
  {
#line 229
  zcontext_save();
#line 230
  inpush(s, 1 << 6, (Alias )((void *)0));
#line 231
  strinbeg(0);
#line 232
  oldlineno = lineno;
  }
#line 233
  if (reset_lineno) {
#line 234
    lineno = (zlong )1;
  }
  {
#line 235
  p = parse_list();
#line 236
  lineno = oldlineno;
  }
#line 237
  if ((unsigned int )tok == 38U) {
#line 237
    if (! lastval) {
#line 238
      lastval = (zlong )1;
    }
  }
  {
#line 239
  strinend();
#line 240
  inpop();
#line 241
  zcontext_restore();
  }
#line 242
  return (p);
}
}
#line 254 "/tmp/zsh-5.4.2/Src/exec.c"
int zsetlimit(int limnum , char *nam ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 257
  if (limits[limnum].rlim_max != current_limits[limnum].rlim_max) {
#line 257
    goto _L;
  } else
#line 257
  if (limits[limnum].rlim_cur != current_limits[limnum].rlim_cur) {
    _L: /* CIL Label */ 
    {
#line 259
    tmp___0 = setrlimit((__rlimit_resource_t )limnum, (struct rlimit  const  *)(limits + limnum));
    }
#line 259
    if (tmp___0) {
#line 260
      if (nam) {
        {
#line 261
        tmp = __errno_location();
#line 261
        zwarnnam((char const   *)nam, "setrlimit failed: %e", *tmp);
        }
      }
#line 262
      limits[limnum] = current_limits[limnum];
#line 263
      return (-1);
    }
#line 265
    current_limits[limnum] = limits[limnum];
  }
#line 267
  return (0);
}
}
#line 271 "/tmp/zsh-5.4.2/Src/exec.c"
int setlimits(char *nam ) 
{ 
  int limnum ;
  int ret ;
  int tmp ;

  {
#line 275
  ret = 0;
#line 277
  limnum = 0;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (limnum < 16)) {
#line 277
      goto while_break;
    }
    {
#line 278
    tmp = zsetlimit(limnum, nam);
    }
#line 278
    if (tmp) {
#line 279
      ret ++;
    }
#line 277
    limnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return (ret);
}
}
#line 289 "/tmp/zsh-5.4.2/Src/exec.c"
static pid_t zfork(struct timeval *tv ) 
{ 
  pid_t pid ;
  struct timezone dummy_tz ;
  int tmp ;
  sigset_t oset ;
  int *tmp___0 ;

  {
#line 298
  if (thisjob != -1) {
#line 298
    if (thisjob >= jobtabsize - 1) {
      {
#line 298
      tmp = expandjobtab();
      }
#line 298
      if (! tmp) {
        {
#line 299
        zerr("job table full");
        }
#line 300
        return (-1);
      }
    }
  }
#line 302
  if (tv) {
    {
#line 303
    gettimeofday((struct timeval */* __restrict  */)tv, (__timezone_ptr_t )(& dummy_tz));
    }
  }
  {
#line 310
  queueing_enabled ++;
#line 311
  pid = fork();
  }
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    queueing_enabled --;
#line 312
    if (! queueing_enabled) {
      {
#line 312
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 312
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 312
          if (! (queue_front != queue_rear)) {
#line 312
            goto while_break___1;
          }
          {
#line 312
          queue_front = (queue_front + 1) % 128;
#line 312
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 312
          zhandler(signal_queue[queue_front]);
#line 312
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 312
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 312
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (pid == -1) {
    {
#line 314
    tmp___0 = __errno_location();
#line 314
    zerr("fork failed: %e", *tmp___0);
    }
#line 315
    return (-1);
  }
#line 318
  if (! pid) {
    {
#line 320
    setlimits((char *)((void *)0));
    }
  }
#line 322
  return (pid);
}
}
#line 399 "/tmp/zsh-5.4.2/Src/exec.c"
int list_pipe  =    0;
#line 399 "/tmp/zsh-5.4.2/Src/exec.c"
int simple_pline  =    0;
#line 401 "/tmp/zsh-5.4.2/Src/exec.c"
static pid_t list_pipe_pid  ;
#line 402 "/tmp/zsh-5.4.2/Src/exec.c"
static struct timeval list_pipe_start  ;
#line 403 "/tmp/zsh-5.4.2/Src/exec.c"
static int nowait  ;
#line 403 "/tmp/zsh-5.4.2/Src/exec.c"
static int pline_level  =    0;
#line 404 "/tmp/zsh-5.4.2/Src/exec.c"
static int list_pipe_child  =    0;
#line 404 "/tmp/zsh-5.4.2/Src/exec.c"
static int list_pipe_job  ;
#line 405 "/tmp/zsh-5.4.2/Src/exec.c"
static char list_pipe_text[80]  ;
#line 410 "/tmp/zsh-5.4.2/Src/exec.c"
static int execcursh(Estate state , int do_exec ) 
{ 
  Wordcode end ;
  int tmp ;

  {
#line 413
  end = state->pc + (*(state->pc + -1) >> 5);
#line 416
  (state->pc) ++;
#line 427
  if (! list_pipe) {
#line 427
    if (thisjob != -1) {
#line 427
      if (thisjob != list_pipe_job) {
        {
#line 427
        tmp = hasprocs(thisjob);
        }
#line 427
        if (! tmp) {
          {
#line 429
          deletejob(jobtab + thisjob, 0);
          }
        }
      }
    }
  }
  {
#line 430
  cmdpush(19);
#line 431
  execlist(state, 1, do_exec);
#line 432
  cmdpop();
#line 434
  state->pc = end;
#line 435
  this_noerrexit = 1;
  }
#line 437
  return ((int )lastval);
}
}
#line 449 "/tmp/zsh-5.4.2/Src/exec.c"
static char buf___6[8193]  ;
#line 445 "/tmp/zsh-5.4.2/Src/exec.c"
static int zexecve(char *pth , char **argv , char **newenvp ) 
{ 
  int eno ;
  char **eep ;
  sigset_t tmp ;
  char execvebuf[65] ;
  char *ptr___0 ;
  char *ptr2 ;
  char *argv0 ;
  int fd ;
  int ct ;
  int t0 ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  char *pprog ;
  sigset_t tmp___2 ;
  sigset_t tmp___3 ;
  sigset_t tmp___4 ;
  sigset_t tmp___5 ;
  sigset_t tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
  {
#line 452
  unmetafy(pth, (int *)((void *)0));
#line 453
  eep = argv;
  }
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! *eep) {
#line 453
      goto while_break;
    }
#line 454
    if ((unsigned long )*eep != (unsigned long )pth) {
      {
#line 455
      unmetafy(*eep, (int *)((void *)0));
      }
    }
#line 453
    eep ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  buf___6[0] = (char )'_';
#line 457
  buf___6[1] = (char )'=';
#line 458
  if ((int )*pth == 47) {
    {
#line 459
    strcpy((char */* __restrict  */)(buf___6 + 2), (char const   */* __restrict  */)pth);
    }
  } else {
    {
#line 461
    sprintf((char */* __restrict  */)(buf___6 + 2), (char const   */* __restrict  */)"%s/%s",
            pwd, pth);
    }
  }
  {
#line 462
  zputenv(buf___6);
  }
#line 467
  if ((unsigned long )newenvp == (unsigned long )((void *)0)) {
#line 468
    newenvp = environ;
  }
  {
#line 469
  tmp = signal_mask(28);
#line 469
  signal_unblock(tmp);
#line 470
  execve((char const   *)pth, (char * const  *)argv, (char * const  *)newenvp);
#line 476
  tmp___9 = __errno_location();
#line 476
  eno = *tmp___9;
  }
#line 476
  if (eno == 8) {
#line 476
    goto _L;
  } else
#line 476
  if (eno == 2) {
    _L: /* CIL Label */ 
    {
#line 480
    fd = open((char const   *)pth, 256);
    }
#line 480
    if (fd >= 0) {
      {
#line 481
      argv0 = *argv;
#line 482
      *argv = pth;
#line 483
      execvebuf[0] = (char )'\000';
#line 484
      tmp___0 = read(fd, (void *)(execvebuf), (size_t )64);
#line 484
      ct = (int )tmp___0;
#line 485
      close(fd);
      }
#line 486
      if (ct >= 0) {
#line 487
        if ((int )execvebuf[0] == 35) {
#line 488
          if ((int )execvebuf[1] == 33) {
#line 489
            t0 = 0;
            {
#line 489
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 489
              if (! (t0 != ct)) {
#line 489
                goto while_break___0;
              }
#line 490
              if ((int )execvebuf[t0] == 10) {
#line 491
                goto while_break___0;
              }
#line 489
              t0 ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 492
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 492
              if (! ((int )typtab[(unsigned char )execvebuf[t0]] & (1 << 3))) {
#line 492
                goto while_break___1;
              }
#line 493
              tmp___1 = t0;
#line 493
              t0 --;
#line 493
              execvebuf[tmp___1] = (char )'\000';
            }
            while_break___1: /* CIL Label */ ;
            }
#line 494
            execvebuf[64] = (char )'\000';
#line 495
            ptr___0 = execvebuf + 2;
            {
#line 495
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 495
              if (*ptr___0) {
#line 495
                if (! ((int )*ptr___0 == 32)) {
#line 495
                  goto while_break___2;
                }
              } else {
#line 495
                goto while_break___2;
              }
#line 495
              ptr___0 ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 496
            ptr2 = ptr___0;
            {
#line 496
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 496
              if (*ptr___0) {
#line 496
                if (! ((int )*ptr___0 != 32)) {
#line 496
                  goto while_break___3;
                }
              } else {
#line 496
                goto while_break___3;
              }
#line 496
              ptr___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 497
            if (eno == 2) {
#line 499
              if (*ptr___0) {
#line 500
                *ptr___0 = (char )'\000';
              }
#line 501
              if ((int )*ptr2 != 47) {
                {
#line 501
                pprog = pathprog(ptr2, (char **)((void *)0));
                }
#line 501
                if (pprog) {
                  {
#line 503
                  *(argv + -2) = ptr2;
#line 504
                  *(argv + -1) = ptr___0 + 1;
#line 505
                  tmp___2 = signal_mask(28);
#line 505
                  signal_unblock(tmp___2);
#line 506
                  execve((char const   *)pprog, (char * const  *)(argv - 2), (char * const  *)newenvp);
                  }
                }
              }
              {
#line 508
              zerr("%s: bad interpreter: %s: %e", pth, ptr2, eno);
              }
            } else
#line 510
            if (*ptr___0) {
              {
#line 511
              *ptr___0 = (char )'\000';
#line 512
              *(argv + -2) = ptr2;
#line 513
              *(argv + -1) = ptr___0 + 1;
#line 514
              tmp___3 = signal_mask(28);
#line 514
              signal_unblock(tmp___3);
#line 515
              execve((char const   *)ptr2, (char * const  *)(argv - 2), (char * const  *)newenvp);
              }
            } else {
              {
#line 517
              *(argv + -1) = ptr2;
#line 518
              tmp___4 = signal_mask(28);
#line 518
              signal_unblock(tmp___4);
#line 519
              execve((char const   *)ptr2, (char * const  *)(argv - 1), (char * const  *)newenvp);
              }
            }
          } else
#line 521
          if (eno == 8) {
            {
#line 522
            *(argv + -1) = (char *)"sh";
#line 523
            tmp___5 = signal_mask(28);
#line 523
            signal_unblock(tmp___5);
#line 524
            execve("/bin/sh", (char * const  *)(argv - 1), (char * const  *)newenvp);
            }
          }
        } else
#line 526
        if (eno == 8) {
#line 527
          t0 = 0;
          {
#line 527
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 527
            if (! (t0 != ct)) {
#line 527
              goto while_break___4;
            }
#line 528
            if (! execvebuf[t0]) {
#line 529
              goto while_break___4;
            }
#line 527
            t0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 530
          if (t0 == ct) {
            {
#line 531
            *(argv + -1) = (char *)"sh";
#line 532
            tmp___6 = signal_mask(28);
#line 532
            signal_unblock(tmp___6);
#line 533
            execve("/bin/sh", (char * const  *)(argv - 1), (char * const  *)newenvp);
            }
          }
        }
      } else {
        {
#line 537
        tmp___7 = __errno_location();
#line 537
        eno = *tmp___7;
        }
      }
#line 538
      *argv = argv0;
    } else {
      {
#line 540
      tmp___8 = __errno_location();
#line 540
      eno = *tmp___8;
      }
    }
  }
  {
#line 545
  pth = metafy(pth, -1, 5);
#line 546
  eep = argv;
  }
  {
#line 546
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 546
    if (! *eep) {
#line 546
      goto while_break___5;
    }
#line 547
    if ((unsigned long )*eep != (unsigned long )pth) {
      {
#line 548
      metafy(*eep, -1, 5);
      }
    }
#line 546
    eep ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 549
  return (eno);
}
}
#line 557 "/tmp/zsh-5.4.2/Src/exec.c"
static int isgooderr(int e , char *dir ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 564
  if (e != 13) {
#line 564
    goto _L;
  } else {
    {
#line 564
    tmp = access((char const   *)dir, 1);
    }
#line 564
    if (tmp) {
#line 564
      tmp___0 = 0;
    } else
    _L: /* CIL Label */ 
#line 564
    if (e != 2) {
#line 564
      if (e != 20) {
#line 564
        tmp___0 = 1;
      } else {
#line 564
        tmp___0 = 0;
      }
    } else {
#line 564
      tmp___0 = 0;
    }
  }
#line 564
  return (tmp___0);
}
}
#line 574 "/tmp/zsh-5.4.2/Src/exec.c"
static int commandnotfound(char *arg0 , LinkList args ) 
{ 
  Shfunc shf ;
  HashNode tmp ;
  int tmp___0 ;

  {
  {
#line 577
  tmp = (*(shfunctab->getnode))(shfunctab, "command_not_found_handler");
#line 577
  shf = (Shfunc )tmp;
  }
#line 580
  if (! shf) {
#line 581
    lastval = (zlong )127;
#line 582
    return (1);
  }
  {
#line 585
  insertlinknode(args, & args->node, (void *)arg0);
#line 586
  tmp___0 = doshfunc(shf, args, 1);
#line 586
  lastval = (zlong )tmp___0;
  }
#line 587
  return (0);
}
}
#line 596 "/tmp/zsh-5.4.2/Src/exec.c"
static char *search_defpath(char *cmd , char *pbuf , int plen ) 
{ 
  char *ps ;
  char *pe ;
  char *s ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 599
  ps = (char *)"/bin:/usr/bin";
#line 599
  pe = (char *)((void *)0);
#line 601
  ps = (char *)"/bin:/usr/bin";
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    if (! ps) {
#line 601
      goto while_break;
    }
    {
#line 602
    pe = strchr((char const   *)ps, ':');
    }
#line 603
    if ((int )*ps == 47) {
#line 604
      s = pbuf;
#line 605
      if (pe) {
#line 606
        if (pe - ps >= (long )plen) {
#line 607
          goto __Cont;
        }
        {
#line 608
        struncpy(& s, ps, (int )(pe - ps));
        }
      } else {
        {
#line 610
        tmp = strlen((char const   *)ps);
        }
#line 610
        if (tmp >= (size_t )plen) {
#line 611
          goto __Cont;
        }
        {
#line 612
        strucpy(& s, ps);
        }
      }
      {
#line 614
      tmp___0 = s;
#line 614
      s ++;
#line 614
      *tmp___0 = (char )'/';
#line 615
      tmp___1 = strlen((char const   *)cmd);
      }
#line 615
      if ((size_t )(s - pbuf) + tmp___1 >= (size_t )plen) {
#line 616
        goto __Cont;
      }
      {
#line 617
      strucpy(& s, cmd);
#line 618
      tmp___2 = iscom(pbuf);
      }
#line 618
      if (tmp___2) {
#line 619
        return (pbuf);
      }
    }
    __Cont: /* CIL Label */ 
#line 601
    if (pe) {
#line 601
      ps = pe + 1;
    } else {
#line 601
      ps = (char *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 622
  return ((char *)((void *)0));
}
}
#line 628 "/tmp/zsh-5.4.2/Src/exec.c"
static void execute(LinkList args , int flags , int defpath ) 
{ 
  Cmdnam cn ;
  char buf___7[16385] ;
  char buf2[16385] ;
  char *s ;
  char *z ;
  char *arg0 ;
  char **argv ;
  char **pp ;
  char **newenvp ;
  int eno ;
  int ee ;
  char *tmp ;
  char *t ;
  char *tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  __pid_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  int lerrno ;
  int tmp___7 ;
  int tmp___8 ;
  char pbuf[4097] ;
  char *dptr ;
  int tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char nn[4097] ;
  char *dptr___0 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  HashNode tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 634
  newenvp = (char **)((void *)0);
#line 635
  eno = 0;
#line 637
  arg0 = (char *)(args->list.first)->dat;
#line 638
  if (opts[154]) {
    {
#line 638
    tmp = strchr((char const   *)arg0, '/');
    }
#line 638
    if (tmp) {
      {
#line 639
      zerr("%s: restricted", arg0);
#line 640
      _exit(1);
      }
    } else
#line 638
    if (defpath) {
      {
#line 639
      zerr("%s: restricted", arg0);
#line 640
      _exit(1);
      }
    }
  }
#line 646
  s = STTYval;
#line 646
  if (s) {
    {
#line 646
    tmp___1 = isatty(0);
    }
#line 646
    if (tmp___1) {
      {
#line 646
      tmp___2 = getpgrp();
#line 646
      tmp___3 = getpid();
      }
#line 646
      if (tmp___2 == tmp___3) {
        {
#line 647
        tmp___0 = tricat("stty", " ", (char const   *)s);
#line 647
        t = tmp___0;
#line 649
        STTYval = (char *)0;
#line 650
        zsfree(s);
#line 651
        execstring(t, 1, 0, (char *)"stty");
#line 652
        zsfree(t);
        }
      } else {
#line 646
        goto _L___0;
      }
    } else {
#line 646
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 653
  if (s) {
    {
#line 654
    STTYval = (char *)0;
#line 655
    zsfree(s);
    }
  }
#line 660
  if (! opts[154]) {
    {
#line 660
    z = zgetenv((char *)"ARGV0");
    }
#line 660
    if (z) {
      {
#line 661
      tmp___4 = ztrdup((char const   *)z);
#line 661
      (args->list.first)->dat = (void *)tmp___4;
#line 668
      unsetenv("ARGV0");
      }
    } else {
#line 660
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 672
  if (flags & (1 << 6)) {
    {
#line 675
    sprintf((char */* __restrict  */)(buf2), (char const   */* __restrict  */)"-%s",
            arg0);
#line 676
    tmp___5 = ztrdup((char const   *)(buf2));
#line 676
    (args->list.first)->dat = (void *)tmp___5;
    }
  }
  {
#line 679
  argv = makecline(args);
  }
#line 680
  if (flags & (1 << 16)) {
#line 681
    newenvp = blank_env;
  }
  {
#line 687
  closem(4);
#line 694
  signal_unblock(sigchld_mask);
#line 695
  tmp___6 = strlen((char const   *)arg0);
  }
#line 695
  if ((int )tmp___6 >= 4096) {
    {
#line 696
    zerr("command too long: %s", arg0);
#line 697
    _exit(1);
    }
  }
#line 699
  s = arg0;
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! *s) {
#line 699
      goto while_break;
    }
#line 700
    if ((int )*s == 47) {
      {
#line 701
      tmp___7 = zexecve(arg0, argv, newenvp);
#line 701
      lerrno = tmp___7;
      }
#line 702
      if ((unsigned long )arg0 == (unsigned long )s) {
#line 702
        goto _L___3;
      } else
#line 702
      if (! opts[126]) {
#line 702
        goto _L___3;
      } else
#line 702
      if ((int )*(arg0 + 0) == 46) {
#line 702
        if ((unsigned long )(arg0 + 1) == (unsigned long )s) {
#line 702
          goto _L___3;
        } else
#line 702
        if ((int )*(arg0 + 1) == 46) {
#line 702
          if ((unsigned long )(arg0 + 2) == (unsigned long )s) {
            _L___3: /* CIL Label */ 
            {
#line 705
            zerr("%e: %s", lerrno, arg0);
            }
#line 706
            if (lerrno == 13) {
#line 706
              tmp___8 = 126;
            } else
#line 706
            if (lerrno == 8) {
#line 706
              tmp___8 = 126;
            } else {
#line 706
              tmp___8 = 127;
            }
            {
#line 706
            _exit(tmp___8);
            }
          }
        }
      }
#line 708
      goto while_break;
    }
#line 699
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 712
  if (defpath) {
    {
#line 716
    tmp___10 = search_defpath(arg0, pbuf, 4096);
    }
#line 716
    if (! tmp___10) {
      {
#line 717
      tmp___9 = commandnotfound(arg0, args);
      }
#line 717
      if (tmp___9 == 0) {
        {
#line 718
        _exit((int )lastval);
        }
      }
      {
#line 719
      zerr("command not found: %s", arg0);
#line 720
      _exit(127);
      }
    }
    {
#line 723
    ee = zexecve(pbuf, argv, newenvp);
#line 725
    dptr = strrchr((char const   *)(pbuf), '/');
    }
#line 725
    if (dptr) {
#line 726
      *dptr = (char )'\000';
    }
#line 727
    if (pbuf[0]) {
#line 727
      tmp___11 = (char const   *)(pbuf);
    } else {
#line 727
      tmp___11 = "/";
    }
    {
#line 727
    tmp___12 = isgooderr(ee, (char *)tmp___11);
    }
#line 727
    if (tmp___12) {
#line 728
      eno = ee;
    }
  } else {
    {
#line 732
    tmp___19 = (*(cmdnamtab->getnode))(cmdnamtab, (char const   *)arg0);
#line 732
    cn = (Cmdnam )tmp___19;
    }
#line 732
    if (cn) {
#line 735
      if (cn->node.flags & (1 << 1)) {
        {
#line 736
        strcpy((char */* __restrict  */)(nn), (char const   */* __restrict  */)cn->u.cmd);
        }
      } else {
#line 738
        pp = path;
        {
#line 738
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 738
          if (! ((unsigned long )pp < (unsigned long )cn->u.name)) {
#line 738
            goto while_break___0;
          }
#line 739
          if (! *(*pp)) {
#line 739
            goto _L___4;
          } else
#line 739
          if ((int )*(*pp) == 46) {
#line 739
            if ((int )*(*pp + 1) == 0) {
              _L___4: /* CIL Label */ 
              {
#line 740
              ee = zexecve(arg0, argv, newenvp);
#line 741
              tmp___13 = isgooderr(ee, *pp);
              }
#line 741
              if (tmp___13) {
#line 742
                eno = ee;
              }
            } else {
#line 739
              goto _L___5;
            }
          } else
          _L___5: /* CIL Label */ 
#line 743
          if ((int )*(*pp) != 47) {
            {
#line 744
            z = buf___7;
#line 745
            strucpy(& z, *pp);
#line 746
            tmp___14 = z;
#line 746
            z ++;
#line 746
            *tmp___14 = (char )'/';
#line 747
            strcpy((char */* __restrict  */)z, (char const   */* __restrict  */)arg0);
#line 748
            ee = zexecve(buf___7, argv, newenvp);
#line 749
            tmp___15 = isgooderr(ee, *pp);
            }
#line 749
            if (tmp___15) {
#line 750
              eno = ee;
            }
          }
#line 738
          pp ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 752
        if (cn->u.name) {
#line 752
          tmp___16 = (char const   *)*(cn->u.name);
        } else {
#line 752
          tmp___16 = "";
        }
        {
#line 752
        strcpy((char */* __restrict  */)(nn), (char const   */* __restrict  */)tmp___16);
#line 753
        strcat((char */* __restrict  */)(nn), (char const   */* __restrict  */)"/");
#line 754
        strcat((char */* __restrict  */)(nn), (char const   */* __restrict  */)cn->node.nam);
        }
      }
      {
#line 756
      ee = zexecve(nn, argv, newenvp);
#line 758
      dptr___0 = strrchr((char const   *)(nn), '/');
      }
#line 758
      if (dptr___0) {
#line 759
        *dptr___0 = (char )'\000';
      }
#line 760
      if (nn[0]) {
#line 760
        tmp___17 = (char const   *)(nn);
      } else {
#line 760
        tmp___17 = "/";
      }
      {
#line 760
      tmp___18 = isgooderr(ee, (char *)tmp___17);
      }
#line 760
      if (tmp___18) {
#line 761
        eno = ee;
      }
    }
#line 763
    pp = path;
    {
#line 763
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 763
      if (! *pp) {
#line 763
        goto while_break___1;
      }
#line 764
      if (! *(*pp + 0)) {
#line 764
        goto _L___6;
      } else
#line 764
      if ((int )*(*pp + 0) == 46) {
#line 764
        if (! *(*pp + 1)) {
          _L___6: /* CIL Label */ 
          {
#line 765
          ee = zexecve(arg0, argv, newenvp);
#line 766
          tmp___20 = isgooderr(ee, *pp);
          }
#line 766
          if (tmp___20) {
#line 767
            eno = ee;
          }
        } else {
#line 764
          goto _L___7;
        }
      } else {
        _L___7: /* CIL Label */ 
        {
#line 769
        z = buf___7;
#line 770
        strucpy(& z, *pp);
#line 771
        tmp___21 = z;
#line 771
        z ++;
#line 771
        *tmp___21 = (char )'/';
#line 772
        strcpy((char */* __restrict  */)z, (char const   */* __restrict  */)arg0);
#line 773
        ee = zexecve(buf___7, argv, newenvp);
#line 774
        tmp___22 = isgooderr(ee, *pp);
        }
#line 774
        if (tmp___22) {
#line 775
          eno = ee;
        }
      }
#line 763
      pp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 779
  if (eno) {
    {
#line 780
    zerr("%e: %s", eno, arg0);
    }
  } else {
    {
#line 781
    tmp___23 = commandnotfound(arg0, args);
    }
#line 781
    if (tmp___23 == 0) {
      {
#line 782
      _exit((int )lastval);
      }
    } else {
      {
#line 784
      zerr("command not found: %s", arg0);
      }
    }
  }
#line 785
  if (eno == 13) {
#line 785
    tmp___24 = 126;
  } else
#line 785
  if (eno == 8) {
#line 785
    tmp___24 = 126;
  } else {
#line 785
    tmp___24 = 127;
  }
  {
#line 785
  _exit(tmp___24);
  }
}
}
#line 800 "/tmp/zsh-5.4.2/Src/exec.c"
char *findcmd(char *arg0 , int docopy , int default_path ) 
{ 
  char **pp ;
  char *z ;
  char *s ;
  char buf___7[16384] ;
  Cmdnam cn ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  HashNode tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char nn[4097] ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;

  {
#line 807
  if (default_path) {
    {
#line 809
    tmp___1 = search_defpath(arg0, buf___7, 16384);
    }
#line 809
    if (tmp___1) {
#line 810
      if (docopy) {
        {
#line 810
        tmp = dupstring((char const   *)(buf___7));
#line 810
        tmp___0 = tmp;
        }
      } else {
#line 810
        tmp___0 = arg0;
      }
#line 810
      return (tmp___0);
    }
#line 811
    return ((char *)((void *)0));
  }
  {
#line 813
  tmp___2 = (*(cmdnamtab->getnode))(cmdnamtab, (char const   *)arg0);
#line 813
  cn = (Cmdnam )tmp___2;
  }
#line 814
  if (! cn) {
#line 814
    if (opts[67]) {
      {
#line 814
      tmp___3 = isrelative(arg0);
      }
#line 814
      if (! tmp___3) {
        {
#line 815
        cn = hashcmd(arg0, path);
        }
      }
    }
  }
  {
#line 816
  tmp___4 = strlen((char const   *)arg0);
  }
#line 816
  if ((int )tmp___4 > 4096) {
#line 817
    return ((char *)((void *)0));
  }
  {
#line 818
  s = strchr((char const   *)arg0, '/');
  }
#line 818
  if (s) {
    {
#line 819
    tmp___7 = iscom(arg0);
    }
#line 819
    if (tmp___7) {
#line 819
      if (docopy) {
        {
#line 819
        tmp___5 = dupstring((char const   *)arg0);
#line 819
        tmp___6 = tmp___5;
        }
      } else {
#line 819
        tmp___6 = arg0;
      }
#line 819
      return (tmp___6);
    }
#line 820
    if ((unsigned long )arg0 == (unsigned long )s) {
#line 822
      return ((char *)((void *)0));
    } else
#line 820
    if (! opts[126]) {
#line 822
      return ((char *)((void *)0));
    } else {
      {
#line 820
      tmp___8 = strncmp((char const   *)arg0, "./", (size_t )2);
      }
#line 820
      if (tmp___8) {
        {
#line 820
        tmp___9 = strncmp((char const   *)arg0, "../", (size_t )3);
        }
#line 820
        if (! tmp___9) {
#line 822
          return ((char *)((void *)0));
        }
      } else {
#line 822
        return ((char *)((void *)0));
      }
    }
  }
#line 825
  if (cn) {
#line 828
    if (cn->node.flags & (1 << 1)) {
      {
#line 829
      strcpy((char */* __restrict  */)(nn), (char const   */* __restrict  */)cn->u.cmd);
      }
    } else {
#line 831
      pp = path;
      {
#line 831
      while (1) {
        while_continue: /* CIL Label */ ;
#line 831
        if (! ((unsigned long )pp < (unsigned long )cn->u.name)) {
#line 831
          goto while_break;
        }
#line 832
        if ((int )*(*pp) != 47) {
#line 833
          z = buf___7;
#line 834
          if (*(*pp)) {
            {
#line 835
            strucpy(& z, *pp);
#line 836
            tmp___10 = z;
#line 836
            z ++;
#line 836
            *tmp___10 = (char )'/';
            }
          }
          {
#line 838
          strcpy((char */* __restrict  */)z, (char const   */* __restrict  */)arg0);
#line 839
          tmp___13 = iscom(buf___7);
          }
#line 839
          if (tmp___13) {
#line 839
            if (docopy) {
              {
#line 839
              tmp___11 = dupstring((char const   *)(buf___7));
#line 839
              tmp___12 = tmp___11;
              }
            } else {
#line 839
              tmp___12 = arg0;
            }
#line 839
            return (tmp___12);
          }
        }
#line 831
        pp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 841
      if (cn->u.name) {
#line 841
        tmp___14 = (char const   *)*(cn->u.name);
      } else {
#line 841
        tmp___14 = "";
      }
      {
#line 841
      strcpy((char */* __restrict  */)(nn), (char const   */* __restrict  */)tmp___14);
#line 842
      strcat((char */* __restrict  */)(nn), (char const   */* __restrict  */)"/");
#line 843
      strcat((char */* __restrict  */)(nn), (char const   */* __restrict  */)cn->node.nam);
      }
    }
    {
#line 845
    tmp___17 = iscom(nn);
    }
#line 845
    if (tmp___17) {
#line 845
      if (docopy) {
        {
#line 845
        tmp___15 = dupstring((char const   *)(nn));
#line 845
        tmp___16 = tmp___15;
        }
      } else {
#line 845
        tmp___16 = arg0;
      }
#line 845
      return (tmp___16);
    }
  }
#line 847
  pp = path;
  {
#line 847
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 847
    if (! *pp) {
#line 847
      goto while_break___0;
    }
#line 848
    z = buf___7;
#line 849
    if (*(*pp)) {
      {
#line 850
      strucpy(& z, *pp);
#line 851
      tmp___18 = z;
#line 851
      z ++;
#line 851
      *tmp___18 = (char )'/';
      }
    }
    {
#line 853
    strcpy((char */* __restrict  */)z, (char const   */* __restrict  */)arg0);
#line 854
    tmp___21 = iscom(buf___7);
    }
#line 854
    if (tmp___21) {
#line 854
      if (docopy) {
        {
#line 854
        tmp___19 = dupstring((char const   *)(buf___7));
#line 854
        tmp___20 = tmp___19;
        }
      } else {
#line 854
        tmp___20 = arg0;
      }
#line 854
      return (tmp___20);
    }
#line 847
    pp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 856
  return ((char *)((void *)0));
}
}
#line 865 "/tmp/zsh-5.4.2/Src/exec.c"
int iscom(char *s ) 
{ 
  struct stat statbuf ;
  char *us ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 869
  tmp = unmeta((char const   *)s);
#line 869
  us = tmp;
#line 871
  tmp___0 = access((char const   *)us, 1);
  }
#line 871
  if (tmp___0 == 0) {
    {
#line 871
    tmp___1 = stat((char const   */* __restrict  */)us, (struct stat */* __restrict  */)(& statbuf));
    }
#line 871
    if (tmp___1 >= 0) {
#line 871
      if ((statbuf.st_mode & 61440U) == 32768U) {
#line 871
        tmp___2 = 1;
      } else {
#line 871
        tmp___2 = 0;
      }
    } else {
#line 871
      tmp___2 = 0;
    }
  } else {
#line 871
    tmp___2 = 0;
  }
#line 871
  return (tmp___2);
}
}
#line 876 "/tmp/zsh-5.4.2/Src/exec.c"
int isreallycom(Cmdnam cn ) 
{ 
  char fullnam[16384] ;
  int tmp ;

  {
#line 881
  if (cn->node.flags & (1 << 1)) {
    {
#line 882
    strcpy((char */* __restrict  */)(fullnam), (char const   */* __restrict  */)cn->u.cmd);
    }
  } else
#line 883
  if (! cn->u.name) {
#line 884
    return (0);
  } else {
    {
#line 886
    strcpy((char */* __restrict  */)(fullnam), (char const   */* __restrict  */)*(cn->u.name));
#line 887
    strcat((char */* __restrict  */)(fullnam), (char const   */* __restrict  */)"/");
#line 888
    strcat((char */* __restrict  */)(fullnam), (char const   */* __restrict  */)cn->node.nam);
    }
  }
  {
#line 890
  tmp = iscom(fullnam);
  }
#line 890
  return (tmp);
}
}
#line 899 "/tmp/zsh-5.4.2/Src/exec.c"
int isrelative(char *s ) 
{ 


  {
#line 902
  if ((int )*s != 47) {
#line 903
    return (1);
  }
  {
#line 904
  while (1) {
    while_continue: /* CIL Label */ ;
#line 904
    if (! *s) {
#line 904
      goto while_break;
    }
#line 905
    if ((int )*s == 46) {
#line 905
      if ((int )*(s + -1) == 47) {
#line 905
        if ((int )*(s + 1) == 47) {
#line 908
          return (1);
        } else
#line 905
        if ((int )*(s + 1) == 0) {
#line 908
          return (1);
        } else
#line 905
        if ((int )*(s + 1) == 46) {
#line 905
          if ((int )*(s + 2) == 47) {
#line 908
            return (1);
          } else
#line 905
          if ((int )*(s + 2) == 0) {
#line 908
            return (1);
          }
        }
      }
    }
#line 904
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  return (0);
}
}
#line 913 "/tmp/zsh-5.4.2/Src/exec.c"
Cmdnam hashcmd(char *arg0 , char **pp ) 
{ 
  Cmdnam cn ;
  char *s ;
  char buf___7[4097] ;
  char **pq ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 920
  while (1) {
    while_continue: /* CIL Label */ ;
#line 920
    if (! *pp) {
#line 920
      goto while_break;
    }
#line 921
    if ((int )*(*pp) == 47) {
      {
#line 922
      s = buf___7;
#line 923
      strucpy(& s, *pp);
#line 924
      tmp = s;
#line 924
      s ++;
#line 924
      *tmp = (char )'/';
#line 925
      tmp___0 = strlen((char const   *)arg0);
      }
#line 925
      if ((size_t )(s - buf___7) + tmp___0 >= 4096UL) {
#line 926
        goto __Cont;
      }
      {
#line 927
      strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)arg0);
#line 928
      tmp___1 = iscom(buf___7);
      }
#line 928
      if (tmp___1) {
#line 929
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ 
#line 920
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 932
  if (! *pp) {
#line 933
    return ((Cmdnam )((void *)0));
  }
  {
#line 935
  tmp___2 = zshcalloc(sizeof(*cn));
#line 935
  cn = (Cmdnam )tmp___2;
#line 936
  cn->node.flags = 0;
#line 937
  cn->u.name = pp;
#line 938
  tmp___3 = ztrdup((char const   *)arg0);
#line 938
  (*(cmdnamtab->addnode))(cmdnamtab, tmp___3, (void *)cn);
  }
#line 940
  if (opts[68]) {
#line 941
    pq = pathchecked;
    {
#line 941
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 941
      if (! ((unsigned long )pq <= (unsigned long )pp)) {
#line 941
        goto while_break___0;
      }
      {
#line 942
      hashdir(pq);
#line 941
      pq ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 943
    pathchecked = pp + 1;
  }
#line 946
  return (cn);
}
}
#line 975 "/tmp/zsh-5.4.2/Src/exec.c"
static void entersubsh(int flags ) 
{ 
  int i ;
  int sig ;
  int monitor ;
  int job_control_ok ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  pid_t tmp___3 ;
  __pid_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  __pid_t tmp___8 ;
  sigset_t tmp___9 ;

  {
#line 980
  if (! (flags & 4)) {
#line 981
    sig = 0;
    {
#line 981
    while (1) {
      while_continue: /* CIL Label */ ;
#line 981
      if (! (sig < 31)) {
#line 981
        goto while_break;
      }
#line 982
      if (! (sigtrapped[sig] & (1 << 2))) {
        {
#line 983
        unsettrap(sig);
        }
      }
#line 981
      sig ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 984
  monitor = (int )opts[116];
#line 985
  if (monitor) {
#line 985
    if (flags & 64) {
#line 985
      if (opts[134]) {
#line 985
        tmp = 1;
      } else {
#line 985
        tmp = 0;
      }
    } else {
#line 985
      tmp = 0;
    }
  } else {
#line 985
    tmp = 0;
  }
#line 985
  job_control_ok = tmp;
#line 986
  if (flags & 32) {
#line 987
    opts[116] = (char)0;
  }
#line 988
  if (! opts[116]) {
#line 989
    if (flags & 1) {
      {
#line 990
      settrap(2, (Eprog )((void *)0), 0);
#line 991
      settrap(3, (Eprog )((void *)0), 0);
#line 992
      tmp___2 = isatty(0);
      }
#line 992
      if (tmp___2) {
        {
#line 993
        close(0);
#line 994
        tmp___1 = open("/dev/null", 258);
        }
#line 994
        if (tmp___1) {
          {
#line 995
          tmp___0 = __errno_location();
#line 995
          zerr("can\'t open /dev/null: %e", *tmp___0);
#line 996
          _exit(1);
          }
        }
      }
    }
  } else
#line 1000
  if (thisjob != -1) {
#line 1000
    if (flags & 2) {
#line 1001
      if ((jobtab + list_pipe_job)->gleader) {
#line 1001
        if (list_pipe) {
#line 1001
          goto _L___2;
        } else
#line 1001
        if (list_pipe_child) {
          _L___2: /* CIL Label */ 
          {
#line 1002
          tmp___5 = setpgid((__pid_t )0L, (jobtab + list_pipe_job)->gleader);
          }
#line 1002
          if (tmp___5 == -1) {
#line 1002
            goto _L;
          } else {
            {
#line 1002
            tmp___6 = killpg((jobtab + list_pipe_job)->gleader, 0);
            }
#line 1002
            if (tmp___6 == -1) {
              _L: /* CIL Label */ 
#line 1004
              if (list_pipe_child) {
#line 1004
                tmp___3 = mypgrp;
              } else {
                {
#line 1004
                tmp___4 = getpid();
#line 1004
                tmp___3 = tmp___4;
                }
              }
              {
#line 1004
              (jobtab + thisjob)->gleader = tmp___3;
#line 1004
              (jobtab + list_pipe_job)->gleader = tmp___3;
#line 1006
              setpgid((__pid_t )0L, (jobtab + list_pipe_job)->gleader);
              }
#line 1007
              if (! (flags & 1)) {
                {
#line 1008
                attachtty((jobtab + thisjob)->gleader);
                }
              }
            }
          }
        } else {
#line 1001
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1011
      if (! (jobtab + thisjob)->gleader) {
#line 1011
        goto _L___0;
      } else {
        {
#line 1011
        tmp___7 = setpgid((__pid_t )0L, (jobtab + thisjob)->gleader);
        }
#line 1011
        if (tmp___7 == -1) {
          _L___0: /* CIL Label */ 
          {
#line 1023
          (jobtab + thisjob)->gleader = getpid();
          }
#line 1024
          if (list_pipe_job != thisjob) {
#line 1024
            if (! (jobtab + list_pipe_job)->gleader) {
#line 1026
              (jobtab + list_pipe_job)->gleader = (jobtab + thisjob)->gleader;
            }
          }
          {
#line 1027
          setpgid((__pid_t )0L, (jobtab + thisjob)->gleader);
          }
#line 1028
          if (! (flags & 1)) {
            {
#line 1029
            attachtty((jobtab + thisjob)->gleader);
            }
          }
        }
      }
    }
  }
#line 1032
  if (! (flags & 8)) {
#line 1033
    subsh = 1;
  }
#line 1040
  zsh_subshell ++;
#line 1041
  if (flags & 16) {
    {
#line 1041
    tmp___8 = getpid();
    }
#line 1041
    if (tmp___8 == mypgrp) {
      {
#line 1042
      release_pgrp();
      }
    }
  }
#line 1043
  shout = (FILE *)((void *)0);
#line 1044
  if (flags & 32) {
    {
#line 1050
    signal(22, (void (*)(int  ))1);
#line 1051
    signal(21, (void (*)(int  ))1);
#line 1052
    signal(20, (void (*)(int  ))1);
    }
  } else
#line 1053
  if (! job_control_ok) {
    {
#line 1060
    signal(22, (void (*)(int  ))0);
#line 1061
    signal(21, (void (*)(int  ))0);
#line 1062
    signal(20, (void (*)(int  ))0);
    }
  }
#line 1064
  if (opts[93]) {
    {
#line 1065
    signal(15, (void (*)(int  ))0);
    }
#line 1066
    if (! (sigtrapped[2] & (1 << 1))) {
      {
#line 1067
      signal(2, (void (*)(int  ))0);
      }
    }
#line 1068
    if (! sigtrapped[13]) {
      {
#line 1069
      signal(13, (void (*)(int  ))0);
      }
    }
  }
#line 1071
  if (! (sigtrapped[3] & (1 << 1))) {
    {
#line 1072
    signal(3, (void (*)(int  ))0);
    }
  }
#line 1081
  if (intrap) {
#line 1082
    sig = 1;
    {
#line 1082
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1082
      if (! (sig < 31)) {
#line 1082
        goto while_break___0;
      }
#line 1083
      if (sigtrapped[sig]) {
#line 1083
        if (sigtrapped[sig] != 1 << 1) {
          {
#line 1084
          tmp___9 = signal_mask(sig);
#line 1084
          signal_unblock(tmp___9);
          }
        }
      }
#line 1082
      sig ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1085
  if (! job_control_ok) {
#line 1086
    opts[116] = (char)0;
  }
#line 1087
  opts[178] = (char)0;
#line 1088
  zleactive = 0;
#line 1093
  i = 10;
  {
#line 1093
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1093
    if (! (i <= max_zsh_fd)) {
#line 1093
      goto while_break___1;
    }
#line 1094
    if ((int )*(fdtable + i) & 16) {
      {
#line 1095
      zclose(i);
      }
    }
#line 1093
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1097
  if (flags & 2) {
    {
#line 1098
    clearjobtab(monitor);
    }
  }
  {
#line 1099
  get_usage();
#line 1100
  forklevel = locallevel;
  }
#line 1101
  return;
}
}
#line 1106 "/tmp/zsh-5.4.2/Src/exec.c"
void execstring(char *s , int dont_change_job , int exiting , char *context ) 
{ 
  Eprog prog ;

  {
  {
#line 1111
  pushheap();
  }
#line 1112
  if (opts[173]) {
    {
#line 1113
    zputs((char const   *)s, stderr);
#line 1114
    fputc('\n', stderr);
#line 1115
    fflush(stderr);
    }
  }
  {
#line 1117
  prog = parse_string(s, 0);
  }
#line 1117
  if (prog) {
    {
#line 1118
    execode(prog, dont_change_job, exiting, context);
    }
  }
  {
#line 1119
  popheap();
  }
#line 1120
  return;
}
}
#line 1127 "/tmp/zsh-5.4.2/Src/exec.c"
static int zsh_eval_context_len  ;
#line 1123 "/tmp/zsh-5.4.2/Src/exec.c"
void execode(Eprog p , int dont_change_job , int exiting , char *context ) 
{ 
  struct estate s ;
  int alen ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1130
  if (! zsh_eval_context_len) {
    {
#line 1131
    zsh_eval_context_len = 16;
#line 1132
    alen = 0;
#line 1133
    tmp = zalloc((unsigned long )zsh_eval_context_len * sizeof(*zsh_eval_context));
#line 1133
    zsh_eval_context = (char **)tmp;
    }
  } else {
    {
#line 1136
    alen = arrlen(zsh_eval_context);
    }
#line 1137
    if (zsh_eval_context_len == alen + 1) {
      {
#line 1138
      zsh_eval_context_len *= 2;
#line 1139
      tmp___0 = zrealloc((void *)zsh_eval_context, (unsigned long )zsh_eval_context_len * sizeof(*zsh_eval_context));
#line 1139
      zsh_eval_context = (char **)tmp___0;
      }
    }
  }
  {
#line 1144
  *(zsh_eval_context + alen) = context;
#line 1145
  *(zsh_eval_context + (alen + 1)) = (char *)((void *)0);
#line 1147
  s.prog = p;
#line 1148
  s.pc = p->prog;
#line 1149
  s.strs = p->strs;
#line 1150
  useeprog(p);
#line 1152
  execlist(& s, dont_change_job, exiting);
#line 1154
  freeeprog(p);
#line 1160
  *(zsh_eval_context + alen) = (char *)((void *)0);
  }
#line 1161
  return;
}
}
#line 1168 "/tmp/zsh-5.4.2/Src/exec.c"
static int execsimple(Estate state ) 
{ 
  wordcode code ;
  Wordcode tmp ;
  int lv ;
  int otj ;
  Wordcode tmp___0 ;
  int q ;
  sigset_t oset ;

  {
#line 1171
  tmp = state->pc;
#line 1171
  (state->pc) ++;
#line 1171
  code = *tmp;
#line 1174
  if (errflag) {
#line 1175
    lastval = (zlong )1;
#line 1175
    return ((int )lastval);
  }
#line 1177
  if (! opts[52]) {
#line 1178
    lastval = (zlong )0;
#line 1178
    return ((int )lastval);
  }
#line 1181
  if (intrap) {
#line 1181
    if (! trapisfunc) {
#line 1181
      if (! (traplocallevel == locallevel)) {
#line 1181
        goto _L___0;
      }
    } else {
#line 1181
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1181
  if (! ineval) {
#line 1181
    if (code) {
#line 1182
      lineno = (zlong )(code - 1U);
    }
  }
#line 1184
  tmp___0 = state->pc;
#line 1184
  (state->pc) ++;
#line 1184
  code = *tmp___0 & (wordcode )((1 << 5) - 1);
#line 1190
  otj = thisjob;
#line 1191
  thisjob = -1;
#line 1193
  if (code == 5U) {
    {
#line 1194
    cmdoutval = 0;
#line 1195
    addvars(state, state->pc - 1, 0);
#line 1196
    setunderscore((char *)"");
    }
#line 1197
    if (opts[177]) {
      {
#line 1198
      fputc('\n', xtrerr);
#line 1199
      fflush(xtrerr);
      }
    }
#line 1201
    if (errflag) {
#line 1201
      lv = errflag;
    } else {
#line 1201
      lv = cmdoutval;
    }
  } else {
#line 1203
    q = queueing_enabled;
    {
#line 1204
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1204
      queueing_enabled = 0;
      {
#line 1204
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1204
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1204
          if (! (queue_front != queue_rear)) {
#line 1204
            goto while_break___1;
          }
          {
#line 1204
          queue_front = (queue_front + 1) % 128;
#line 1204
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1204
          zhandler(signal_queue[queue_front]);
#line 1204
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1204
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1204
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1205
    if (code == 11U) {
      {
#line 1206
      lv = execfuncdef(state, (Eprog )((void *)0));
      }
    } else {
      {
#line 1208
      lv = (*(execfuncs[code - 9U]))(state, 0);
      }
    }
#line 1209
    queueing_enabled = q;
  }
#line 1212
  thisjob = otj;
#line 1214
  lastval = (zlong )lv;
#line 1214
  return ((int )lastval);
}
}
#line 1228 "/tmp/zsh-5.4.2/Src/exec.c"
static int donetrap  ;
#line 1225 "/tmp/zsh-5.4.2/Src/exec.c"
void execlist(Estate state , int dont_change_job , int exiting ) 
{ 
  Wordcode next___0 ;
  wordcode code ;
  int ret ;
  int cj ;
  int csp ;
  int ltype ;
  int old_pline_level ;
  int old_list_pipe ;
  int old_list_pipe_job ;
  char *old_list_pipe_text ;
  zlong oldlineno ;
  int oldnoerrexit ;
  Wordcode tmp ;
  int donedebug ;
  int this_donetrap ;
  wordcode code2 ;
  wordcode lnp1 ;
  Wordcode pc2 ;
  int oerrexit_opt ;
  Param pm ;
  char *tmp___0 ;
  Wordcode tmp___1 ;
  Wordcode tmp___2 ;
  int isend ;
  int tmp___3 ;
  Wordcode tmp___4 ;
  Wordcode tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Wordcode tmp___8 ;
  Wordcode tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  Wordcode tmp___12 ;
  int oerrexit_opt___0 ;
  int errreturn ;
  int tmp___13 ;
  int errexit ;
  int tmp___14 ;
  __pid_t tmp___15 ;
  Wordcode tmp___16 ;
  sigset_t oset ;

  {
#line 1241
  oldnoerrexit = noerrexit;
#line 1243
  queueing_enabled ++;
#line 1245
  cj = thisjob;
#line 1246
  old_pline_level = pline_level;
#line 1247
  old_list_pipe = list_pipe;
#line 1248
  old_list_pipe_job = list_pipe_job;
#line 1249
  if (list_pipe_text[0]) {
    {
#line 1250
    old_list_pipe_text = ztrdup((char const   *)(list_pipe_text));
    }
  } else {
#line 1252
    old_list_pipe_text = (char *)((void *)0);
  }
#line 1253
  oldlineno = lineno;
#line 1255
  if (sourcelevel) {
#line 1255
    if (! opts[160]) {
#line 1256
      list_pipe_job = 0;
#line 1256
      list_pipe = list_pipe_job;
#line 1256
      pline_level = list_pipe;
#line 1257
      list_pipe_text[0] = (char )'\000';
    }
  }
#line 1262
  tmp = state->pc;
#line 1262
  (state->pc) ++;
#line 1262
  code = *tmp;
#line 1263
  if ((code & (wordcode )((1 << 5) - 1)) != 1U) {
#line 1265
    lastval = (zlong )0;
  }
  {
#line 1267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1267
    if ((code & (wordcode )((1 << 5) - 1)) == 1U) {
#line 1267
      if (! breaks) {
#line 1267
        if (! retflag) {
#line 1267
          if (! (! errflag)) {
#line 1267
            goto while_break;
          }
        } else {
#line 1267
          goto while_break;
        }
      } else {
#line 1267
        goto while_break;
      }
    } else {
#line 1267
      goto while_break;
    }
#line 1269
    this_donetrap = 0;
#line 1270
    this_noerrexit = 0;
#line 1272
    ltype = (int )(code >> 5);
#line 1273
    csp = cmdsp;
#line 1275
    if (intrap) {
#line 1275
      if (! trapisfunc) {
#line 1275
        if (! (traplocallevel == locallevel)) {
#line 1275
          goto _L___0;
        }
      } else {
#line 1275
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1275
    if (! ineval) {
#line 1287
      code2 = *(state->pc);
#line 1287
      lnp1 = (wordcode )0;
#line 1288
      if (ltype & (1 << 5)) {
#line 1289
        lnp1 = code2;
      } else
#line 1290
      if ((code2 & (wordcode )((1 << 5) - 1)) == 2U) {
#line 1291
        if (((code2 >> 5) & 28U) == 16U) {
#line 1292
          lnp1 = *(state->pc + 1);
        } else {
#line 1294
          lnp1 = (*(state->pc + 1) >> 5) >> 1;
        }
      }
#line 1296
      if (lnp1) {
#line 1297
        lineno = (zlong )(lnp1 - 1U);
      }
    }
#line 1300
    if (sigtrapped[33]) {
#line 1300
      if (opts[47]) {
#line 1300
        if (! intrap) {
#line 1301
          pc2 = state->pc;
#line 1302
          oerrexit_opt = (int )opts[50];
#line 1304
          opts[50] = (char)0;
#line 1305
          noerrexit = 3;
#line 1306
          if (ltype & (1 << 5)) {
#line 1307
            pc2 ++;
          }
          {
#line 1308
          tmp___0 = getpermtext(state->prog, pc2, 0);
#line 1308
          pm = setsparam((char *)"ZSH_DEBUG_CMD", tmp___0);
#line 1310
          exiting = donetrap;
#line 1311
          ret = (int )lastval;
#line 1312
          dotrap(33);
          }
#line 1313
          if (! retflag) {
#line 1314
            lastval = (zlong )ret;
          }
#line 1315
          donetrap = exiting;
#line 1316
          noerrexit = oldnoerrexit;
#line 1321
          if (opts[50]) {
#line 1321
            donedebug = 2;
          } else {
#line 1321
            donedebug = 1;
          }
#line 1322
          opts[50] = (char )oerrexit_opt;
#line 1323
          if (pm) {
            {
#line 1324
            unsetparam_pm(pm, 0, 1);
            }
          }
        } else {
#line 1300
          goto _L___2;
        }
      } else {
#line 1300
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1326
    if (intrap) {
#line 1326
      donedebug = 1;
    } else {
#line 1326
      donedebug = 0;
    }
#line 1330
    donetrap = 0;
#line 1331
    if (ltype & (1 << 5)) {
#line 1332
      next___0 = state->pc + ((code >> 5) >> 6);
#line 1333
      if (donedebug != 2) {
        {
#line 1334
        execsimple(state);
        }
      }
#line 1335
      state->pc = next___0;
#line 1336
      goto sublist_done;
    }
#line 1340
    tmp___1 = state->pc;
#line 1340
    (state->pc) ++;
#line 1340
    code = *tmp___1;
#line 1341
    if (donedebug == 2) {
      {
#line 1343
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1343
        if (! ((code & (wordcode )((1 << 5) - 1)) == 2U)) {
#line 1343
          goto while_break___0;
        }
#line 1344
        state->pc += (code >> 5) >> 5;
#line 1345
        if (((code >> 5) & 3U) == 0U) {
#line 1346
          goto while_break___0;
        }
#line 1347
        tmp___2 = state->pc;
#line 1347
        (state->pc) ++;
#line 1347
        code = *tmp___2;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1349
      donetrap = 1;
#line 1351
      goto sublist_done;
    }
    {
#line 1353
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1353
      if (! ((code & (wordcode )((1 << 5) - 1)) == 2U)) {
#line 1353
        goto while_break___1;
      }
#line 1354
      isend = ((code >> 5) & 3U) == 0U;
#line 1355
      next___0 = state->pc + ((code >> 5) >> 5);
#line 1356
      if (! oldnoerrexit) {
#line 1357
        if (isend) {
#line 1357
          noerrexit = 0;
        } else {
#line 1357
          noerrexit = 3;
        }
      }
#line 1358
      if (((code >> 5) & 28U) & 8U) {
#line 1360
        if (isend) {
#line 1361
          this_noerrexit = 1;
        }
#line 1363
        noerrexit = 3;
      }
      {
#line 1366
      if (((code >> 5) & 3U) == 0U) {
#line 1366
        goto case_0;
      }
#line 1375
      if (((code >> 5) & 3U) == 1U) {
#line 1375
        goto case_1;
      }
#line 1408
      if (((code >> 5) & 3U) == 2U) {
#line 1408
        goto case_2;
      }
#line 1365
      goto switch_break;
      case_0: /* CIL Label */ 
#line 1368
      if (((code >> 5) & 28U) & 16U) {
        {
#line 1369
        execsimple(state);
        }
      } else {
#line 1371
        if (ltype & (1 << 4)) {
#line 1371
          if (exiting) {
#line 1371
            tmp___3 = 1;
          } else {
#line 1371
            tmp___3 = 0;
          }
        } else {
#line 1371
          tmp___3 = 0;
        }
        {
#line 1371
        execpline(state, code, ltype, tmp___3);
        }
      }
#line 1372
      state->pc = next___0;
#line 1373
      goto sublist_done;
#line 1374
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1378
      if (((code >> 5) & 28U) & 16U) {
        {
#line 1378
        tmp___6 = execsimple(state);
#line 1378
        ret = tmp___6;
        }
      } else {
        {
#line 1378
        tmp___7 = execpline(state, code, 1 << 1, 0);
#line 1378
        ret = tmp___7;
        }
      }
#line 1378
      if (ret) {
#line 1381
        state->pc = next___0;
#line 1382
        tmp___4 = state->pc;
#line 1382
        (state->pc) ++;
#line 1382
        code = *tmp___4;
#line 1383
        next___0 = state->pc + ((code >> 5) >> 5);
        {
#line 1384
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1384
          if ((code & (wordcode )((1 << 5) - 1)) == 2U) {
#line 1384
            if (! (((code >> 5) & 3U) == 1U)) {
#line 1384
              goto while_break___2;
            }
          } else {
#line 1384
            goto while_break___2;
          }
#line 1386
          state->pc = next___0;
#line 1387
          tmp___5 = state->pc;
#line 1387
          (state->pc) ++;
#line 1387
          code = *tmp___5;
#line 1388
          next___0 = state->pc + ((code >> 5) >> 5);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1390
        if ((code & (wordcode )((1 << 5) - 1)) != 2U) {
#line 1394
          this_donetrap = 1;
#line 1395
          goto sublist_done;
        } else
#line 1396
        if (((code >> 5) & 3U) == 0U) {
#line 1397
          this_donetrap = 1;
#line 1402
          state->pc = next___0;
#line 1403
          goto sublist_done;
        }
      }
      {
#line 1406
      cmdpush(12);
      }
#line 1407
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1411
      if (((code >> 5) & 28U) & 16U) {
        {
#line 1411
        tmp___10 = execsimple(state);
#line 1411
        ret = tmp___10;
        }
      } else {
        {
#line 1411
        tmp___11 = execpline(state, code, 1 << 1, 0);
#line 1411
        ret = tmp___11;
        }
      }
#line 1411
      if (! ret) {
#line 1414
        state->pc = next___0;
#line 1415
        tmp___8 = state->pc;
#line 1415
        (state->pc) ++;
#line 1415
        code = *tmp___8;
#line 1416
        next___0 = state->pc + ((code >> 5) >> 5);
        {
#line 1417
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1417
          if ((code & (wordcode )((1 << 5) - 1)) == 2U) {
#line 1417
            if (! (((code >> 5) & 3U) == 2U)) {
#line 1417
              goto while_break___3;
            }
          } else {
#line 1417
            goto while_break___3;
          }
#line 1419
          state->pc = next___0;
#line 1420
          tmp___9 = state->pc;
#line 1420
          (state->pc) ++;
#line 1420
          code = *tmp___9;
#line 1421
          next___0 = state->pc + ((code >> 5) >> 5);
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1423
        if ((code & (wordcode )((1 << 5) - 1)) != 2U) {
#line 1427
          this_donetrap = 1;
#line 1428
          goto sublist_done;
        } else
#line 1429
        if (((code >> 5) & 3U) == 0U) {
#line 1430
          this_donetrap = 1;
#line 1435
          state->pc = next___0;
#line 1436
          goto sublist_done;
        }
      }
      {
#line 1439
      cmdpush(11);
      }
#line 1440
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1442
      state->pc = next___0;
#line 1443
      tmp___12 = state->pc;
#line 1443
      (state->pc) ++;
#line 1443
      code = *tmp___12;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1445
    (state->pc) --;
    sublist_done: 
#line 1454
    if (! (oldnoerrexit & 4)) {
#line 1455
      noerrexit = oldnoerrexit;
    }
#line 1457
    if (sigtrapped[33]) {
#line 1457
      if (! opts[47]) {
#line 1457
        if (! donedebug) {
          {
#line 1462
          oerrexit_opt___0 = (int )opts[50];
#line 1463
          opts[50] = (char)0;
#line 1464
          noerrexit = 3;
#line 1465
          exiting = donetrap;
#line 1466
          ret = (int )lastval;
#line 1467
          dotrap(33);
          }
#line 1468
          if (! retflag) {
#line 1469
            lastval = (zlong )ret;
          }
#line 1470
          donetrap = exiting;
#line 1471
          noerrexit = oldnoerrexit;
#line 1472
          opts[50] = (char )oerrexit_opt___0;
        }
      }
    }
#line 1475
    cmdsp = csp;
#line 1480
    if (! this_noerrexit) {
#line 1480
      if (! donetrap) {
#line 1480
        if (! this_donetrap) {
#line 1481
          if (sigtrapped[32]) {
#line 1481
            if (lastval) {
#line 1481
              if (! (noerrexit & 1)) {
                {
#line 1483
                dotrap(32);
#line 1484
                donetrap = 1;
                }
              }
            }
          }
#line 1486
          if (lastval) {
#line 1487
            if (opts[51]) {
#line 1487
              if (opts[93]) {
#line 1487
                goto _L___3;
              } else
#line 1487
              if (locallevel) {
#line 1487
                goto _L___3;
              } else
#line 1487
              if (sourcelevel) {
                _L___3: /* CIL Label */ 
#line 1487
                if (! (noerrexit & 2)) {
#line 1487
                  tmp___13 = 1;
                } else {
#line 1487
                  tmp___13 = 0;
                }
              } else {
#line 1487
                tmp___13 = 0;
              }
            } else {
#line 1487
              tmp___13 = 0;
            }
#line 1487
            errreturn = tmp___13;
#line 1490
            if (opts[50]) {
#line 1490
              goto _L___4;
            } else
#line 1490
            if (opts[51]) {
#line 1490
              if (! errreturn) {
                _L___4: /* CIL Label */ 
#line 1490
                if (! (noerrexit & 1)) {
#line 1490
                  tmp___14 = 1;
                } else {
#line 1490
                  tmp___14 = 0;
                }
              } else {
#line 1490
                tmp___14 = 0;
              }
            } else {
#line 1490
              tmp___14 = 0;
            }
#line 1490
            errexit = tmp___14;
#line 1493
            if (errexit) {
#line 1494
              if (sigtrapped[0]) {
                {
#line 1495
                dotrap(0);
                }
              }
              {
#line 1496
              tmp___15 = getpid();
              }
#line 1496
              if (mypid != (zlong )tmp___15) {
                {
#line 1497
                _exit((int )lastval);
                }
              } else {
                {
#line 1499
                exit((int )lastval);
                }
              }
            }
#line 1501
            if (errreturn) {
#line 1502
              retflag = 1;
#line 1503
              breaks = loops;
            }
          }
        }
      }
    }
#line 1507
    if (ltype & (1 << 4)) {
#line 1508
      goto while_break;
    }
#line 1509
    tmp___16 = state->pc;
#line 1509
    (state->pc) ++;
#line 1509
    code = *tmp___16;
  }
  while_break: /* CIL Label */ ;
  }
#line 1511
  pline_level = old_pline_level;
#line 1512
  list_pipe = old_list_pipe;
#line 1513
  list_pipe_job = old_list_pipe_job;
#line 1514
  if (old_list_pipe_text) {
    {
#line 1515
    strcpy((char */* __restrict  */)(list_pipe_text), (char const   */* __restrict  */)old_list_pipe_text);
#line 1516
    zsfree(old_list_pipe_text);
    }
  } else {
#line 1518
    list_pipe_text[0] = (char )'\000';
  }
#line 1520
  lineno = oldlineno;
#line 1521
  if (dont_change_job) {
#line 1522
    thisjob = cj;
  }
#line 1524
  if (exiting) {
#line 1524
    if (sigtrapped[0]) {
      {
#line 1525
      dotrap(0);
#line 1527
      sigtrapped[0] = 0;
      }
    }
  }
  {
#line 1530
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1530
    queueing_enabled --;
#line 1530
    if (! queueing_enabled) {
      {
#line 1530
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 1530
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1530
          if (! (queue_front != queue_rear)) {
#line 1530
            goto while_break___6;
          }
          {
#line 1530
          queue_front = (queue_front + 1) % 128;
#line 1530
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1530
          zhandler(signal_queue[queue_front]);
#line 1530
          signal_setmask(oset);
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1530
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1530
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1531
  return;
}
}
#line 1552 "/tmp/zsh-5.4.2/Src/exec.c"
static int lastwj  ;
#line 1552 "/tmp/zsh-5.4.2/Src/exec.c"
static int lpforked  ;
#line 1544 "/tmp/zsh-5.4.2/Src/exec.c"
static int execpline(Estate state , wordcode slcode , int how , int last1 ) 
{ 
  int ipipe[2] ;
  int opipe[2] ;
  int pj ;
  int newjob ;
  int old_simple_pline ;
  int slflags ;
  wordcode code ;
  Wordcode tmp ;
  sigset_t oset ;
  unsigned char tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  sigset_t oset___0 ;
  Job jn ;
  int updated ;
  int jobsub ;
  struct process *pn ;
  struct process *qn ;
  Job jnsub ;
  int q ;
  sigset_t oset___1 ;
  int tmp___4 ;
  pid_t pid ;
  int synch[2] ;
  struct timeval bgtime ;
  int *tmp___5 ;
  char dummy___0 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  __pid_t tmp___10 ;
  int tmp___11 ;
  sigset_t oset___2 ;
  sigset_t oset___3 ;

  {
#line 1549
  old_simple_pline = simple_pline;
#line 1550
  slflags = (int )((slcode >> 5) & 28U);
#line 1551
  tmp = state->pc;
#line 1551
  (state->pc) ++;
#line 1551
  code = *tmp;
#line 1554
  if ((code & (wordcode )((1 << 5) - 1)) != 3U) {
#line 1555
    lastval = (zlong )((slflags & 8) != 0);
#line 1555
    return ((int )lastval);
  } else
#line 1556
  if (slflags & 8) {
#line 1557
    last1 = 0;
  }
  {
#line 1565
  queueing_enabled ++;
#line 1567
  pj = thisjob;
#line 1568
  opipe[1] = 0;
#line 1568
  opipe[0] = opipe[1];
#line 1568
  ipipe[1] = opipe[0];
#line 1568
  ipipe[0] = ipipe[1];
#line 1569
  signal_block(sigchld_mask);
#line 1577
  newjob = initjob();
#line 1577
  thisjob = newjob;
  }
#line 1577
  if (thisjob == -1) {
    {
#line 1578
    signal_unblock(sigchld_mask);
    }
    {
#line 1579
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1579
      queueing_enabled --;
#line 1579
      if (! queueing_enabled) {
        {
#line 1579
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1579
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1579
            if (! (queue_front != queue_rear)) {
#line 1579
              goto while_break___1;
            }
            {
#line 1579
            queue_front = (queue_front + 1) % 128;
#line 1579
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1579
            zhandler(signal_queue[queue_front]);
#line 1579
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1579
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1579
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1580
    return (1);
  }
#line 1582
  if (how & 1) {
#line 1583
    (jobtab + thisjob)->stat |= 4;
  }
#line 1585
  if (slflags & 4) {
#line 1586
    how = 1 << 2;
#line 1587
    if (coprocin >= 0) {
      {
#line 1588
      zclose(coprocin);
#line 1589
      zclose(coprocout);
      }
    }
    {
#line 1591
    tmp___2 = mpipe(ipipe);
    }
#line 1591
    if (tmp___2 < 0) {
#line 1592
      coprocout = -1;
#line 1592
      coprocin = coprocout;
#line 1593
      slflags &= -5;
    } else {
      {
#line 1594
      tmp___1 = mpipe(opipe);
      }
#line 1594
      if (tmp___1 < 0) {
        {
#line 1595
        close(ipipe[0]);
#line 1596
        close(ipipe[1]);
#line 1597
        coprocout = -1;
#line 1597
        coprocin = coprocout;
#line 1598
        slflags &= -5;
        }
      } else {
#line 1600
        coprocin = ipipe[0];
#line 1601
        coprocout = opipe[1];
#line 1602
        tmp___0 = (unsigned char)0;
#line 1602
        *(fdtable + coprocout) = tmp___0;
#line 1602
        *(fdtable + coprocin) = tmp___0;
      }
    }
  }
#line 1609
  tmp___3 = pline_level;
#line 1609
  pline_level ++;
#line 1609
  if (! tmp___3) {
#line 1610
    list_pipe_pid = 0;
#line 1611
    nowait = 0;
#line 1612
    simple_pline = ((code >> 5) & 1U) == 0U;
#line 1613
    list_pipe_job = newjob;
  }
  {
#line 1615
  lpforked = 0;
#line 1615
  lastwj = lpforked;
#line 1616
  execpline2(state, code, how, opipe[0], ipipe[1], last1);
#line 1617
  pline_level --;
  }
#line 1618
  if (how & (1 << 2)) {
#line 1619
    lastwj = newjob;
#line 1621
    if (thisjob == list_pipe_job) {
#line 1622
      list_pipe_job = 0;
    }
#line 1623
    (jobtab + thisjob)->stat |= 2048;
#line 1624
    if (slflags & 4) {
      {
#line 1625
      zclose(ipipe[1]);
#line 1626
      zclose(opipe[0]);
      }
    }
#line 1628
    if (how & (1 << 3)) {
      {
#line 1629
      pipecleanfilelist((jobtab + thisjob)->filelist, 0);
#line 1630
      deletejob(jobtab + thisjob, 1);
#line 1631
      thisjob = -1;
      }
    } else {
      {
#line 1634
      spawnjob();
      }
    }
    {
#line 1635
    signal_unblock(sigchld_mask);
    }
    {
#line 1636
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1636
      queueing_enabled --;
#line 1636
      if (! queueing_enabled) {
        {
#line 1636
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1636
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1636
            if (! (queue_front != queue_rear)) {
#line 1636
              goto while_break___4;
            }
            {
#line 1636
            queue_front = (queue_front + 1) % 128;
#line 1636
            oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 1636
            zhandler(signal_queue[queue_front]);
#line 1636
            signal_setmask(oset___0);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1636
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1636
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1638
    lastval = (zlong )0;
#line 1638
    return ((int )lastval);
  } else {
#line 1640
    if (newjob != lastwj) {
#line 1641
      jn = jobtab + newjob;
#line 1644
      if (newjob == list_pipe_job) {
#line 1644
        if (list_pipe_child) {
          {
#line 1645
          _exit(0);
          }
        }
      }
#line 1647
      thisjob = newjob;
#line 1647
      lastwj = thisjob;
#line 1649
      if (list_pipe) {
#line 1650
        jn->stat |= 32;
      } else
#line 1649
      if (pline_level) {
#line 1649
        if (! (how & 1)) {
#line 1650
          jn->stat |= 32;
        }
      }
#line 1652
      if (nowait) {
#line 1653
        if (! pline_level) {
          {
#line 1657
          curjob = newjob;
#line 1659
          addproc(list_pipe_pid, list_pipe_text, 0, & list_pipe_start);
          }
#line 1664
          if (! (jn->procs)->next) {
#line 1664
            goto _L;
          } else
#line 1664
          if (lpforked == 2) {
            _L: /* CIL Label */ 
#line 1665
            jn->gleader = list_pipe_pid;
#line 1666
            jn->stat |= 8192;
#line 1672
            jobsub = 1;
            {
#line 1672
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 1672
              if (! (jobsub <= maxjob)) {
#line 1672
                goto while_break___5;
              }
#line 1673
              jnsub = jobtab + jobsub;
#line 1674
              if (jnsub->stat & 32768) {
#line 1675
                jn->other = jobsub;
#line 1676
                jn->stat |= 128;
#line 1677
                jnsub->stat &= -32769;
#line 1678
                jnsub->other = list_pipe_pid;
              }
#line 1672
              jobsub ++;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
#line 1682
          pn = (jobtab + jn->other)->procs;
          {
#line 1682
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1682
            if (! pn) {
#line 1682
              goto while_break___6;
            }
#line 1683
            if ((pn->status & 255) == 127) {
#line 1684
              goto while_break___6;
            }
#line 1682
            pn = pn->next;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1686
          if (pn) {
#line 1687
            qn = jn->procs;
            {
#line 1687
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 1687
              if (! qn->next) {
#line 1687
                goto while_break___7;
              }
#line 1687
              qn = qn->next;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 1688
            qn->status = pn->status;
          }
          {
#line 1691
          jn->stat &= -41;
#line 1692
          jn->stat |= 83;
#line 1694
          printjob(jn, ! (! opts[111]), 1);
          }
        } else
#line 1696
        if (newjob != list_pipe_job) {
          {
#line 1697
          deletejob(jn, 0);
          }
        } else {
#line 1699
          lastwj = -1;
        }
      }
#line 1702
      errbrk_saved = 0;
      {
#line 1703
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1703
        if (! (! nowait)) {
#line 1703
          goto while_break___8;
        }
#line 1704
        if (list_pipe_child) {
          {
#line 1705
          jn->stat |= 32;
#line 1706
          makerunning(jn);
          }
        }
#line 1708
        if (! (jn->stat & 16)) {
          {
#line 1709
          updated = hasprocs(thisjob);
#line 1710
          waitjobs();
#line 1711
          signal_block(sigchld_mask);
          }
        } else {
#line 1713
          updated = 0;
        }
#line 1714
        if (! updated) {
#line 1714
          if (list_pipe_job) {
            {
#line 1714
            tmp___4 = hasprocs(list_pipe_job);
            }
#line 1714
            if (tmp___4) {
#line 1714
              if (! ((jobtab + list_pipe_job)->stat & 2)) {
                {
#line 1717
                q = queueing_enabled;
#line 1718
                signal_unblock(sigchld_mask);
#line 1719
                signal_block(sigchld_mask);
                }
                {
#line 1720
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 1720
                  queueing_enabled = 0;
                  {
#line 1720
                  while (1) {
                    while_continue___10: /* CIL Label */ ;
                    {
#line 1720
                    while (1) {
                      while_continue___11: /* CIL Label */ ;
#line 1720
                      if (! (queue_front != queue_rear)) {
#line 1720
                        goto while_break___11;
                      }
                      {
#line 1720
                      queue_front = (queue_front + 1) % 128;
#line 1720
                      oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 1720
                      zhandler(signal_queue[queue_front]);
#line 1720
                      signal_setmask(oset___1);
                      }
                    }
                    while_break___11: /* CIL Label */ ;
                    }
#line 1720
                    goto while_break___10;
                  }
                  while_break___10: /* CIL Label */ ;
                  }
#line 1720
                  goto while_break___9;
                }
                while_break___9: /* CIL Label */ ;
                }
#line 1721
                queueing_enabled = q;
              }
            }
          }
        }
#line 1723
        if (list_pipe_child) {
#line 1723
          if (jn->stat & 8) {
#line 1723
            if (lastval2 & 128L) {
              {
#line 1726
              killpg(mypgrp, (int )(lastval2 & -129L));
              }
            }
          }
        }
#line 1727
        if (! list_pipe_child) {
#line 1727
          if (! lpforked) {
#line 1727
            if (! subsh) {
#line 1727
              if (opts[116]) {
#line 1727
                if (list_pipe) {
#line 1727
                  goto _L___5;
                } else
#line 1727
                if (last1) {
#line 1727
                  goto _L___5;
                } else
#line 1727
                if (pline_level) {
                  _L___5: /* CIL Label */ 
#line 1727
                  if (jn->stat & 2) {
#line 1727
                    goto _L___3;
                  } else
#line 1727
                  if (list_pipe_job) {
#line 1727
                    if (pline_level) {
#line 1727
                      if ((jobtab + list_pipe_job)->stat & 2) {
                        _L___3: /* CIL Label */ 
                        {
#line 1732
                        pid = 0;
#line 1741
                        tmp___11 = pipe((int *)(synch));
                        }
#line 1741
                        if (tmp___11 < 0) {
#line 1741
                          goto _L___1;
                        } else {
                          {
#line 1741
                          pid = zfork(& bgtime);
                          }
#line 1741
                          if (pid == -1) {
                            _L___1: /* CIL Label */ 
#line 1743
                            if (pid < 0) {
                              {
#line 1744
                              close(synch[0]);
#line 1745
                              close(synch[1]);
                              }
                            } else {
                              {
#line 1747
                              tmp___5 = __errno_location();
#line 1747
                              zerr("pipe failed: %e", *tmp___5);
                              }
                            }
                            {
#line 1748
                            zleentry(3);
#line 1749
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"zsh: job can\'t be suspended\n");
#line 1750
                            fflush(stderr);
#line 1751
                            makerunning(jn);
#line 1752
                            killjb(jn, 18);
#line 1753
                            thisjob = newjob;
                            }
                          } else
#line 1755
                          if (pid) {
                            {
#line 1770
                            tmp___7 = killpg((jobtab + list_pipe_job)->gleader, 0);
                            }
#line 1770
                            if (tmp___7 == -1) {
#line 1770
                              lpforked = 2;
                            } else {
#line 1770
                              lpforked = 1;
                            }
                            {
#line 1772
                            list_pipe_pid = pid;
#line 1773
                            list_pipe_start = bgtime;
#line 1774
                            nowait = 1;
#line 1775
                            errflag |= 1;
#line 1776
                            breaks = loops;
#line 1777
                            close(synch[1]);
#line 1778
                            read_loop(synch[0], & dummy___0, (size_t )1);
#line 1779
                            close(synch[0]);
                            }
#line 1782
                            if (! (jn->stat & 8)) {
                              {
#line 1783
                              (jobtab + list_pipe_job)->other = newjob;
#line 1784
                              (jobtab + list_pipe_job)->stat |= 128;
#line 1785
                              jn->stat |= 288;
#line 1786
                              jn->other = list_pipe_pid;
#line 1787
                              tmp___8 = hasprocs(list_pipe_job);
                              }
#line 1787
                              if (tmp___8) {
#line 1788
                                jn->gleader = (jobtab + list_pipe_job)->gleader;
                              }
                            }
#line 1790
                            if (list_pipe) {
#line 1790
                              goto _L___0;
                            } else
#line 1790
                            if (last1) {
                              _L___0: /* CIL Label */ 
                              {
#line 1790
                              tmp___9 = hasprocs(list_pipe_job);
                              }
#line 1790
                              if (tmp___9) {
                                {
#line 1791
                                killpg((jobtab + list_pipe_job)->gleader, 19);
                                }
                              }
                            }
#line 1792
                            goto while_break___8;
                          } else {
                            {
#line 1795
                            close(synch[0]);
#line 1796
                            entersubsh(1);
#line 1811
                            mypgrp = getpid();
#line 1811
                            setpgid((__pid_t )0L, mypgrp);
#line 1812
                            close(synch[1]);
#line 1813
                            tmp___10 = getpid();
#line 1813
                            kill(tmp___10, 19);
#line 1814
                            list_pipe = 0;
#line 1815
                            list_pipe_child = 1;
#line 1816
                            opts[93] = (char)0;
                            }
#line 1817
                            if (errbrk_saved) {
#line 1821
                              errflag = prev_errflag | (errflag & 2);
#line 1822
                              breaks = prev_breaks;
                            }
#line 1824
                            goto while_break___8;
                          }
                        }
                      } else {
#line 1727
                        goto _L___8;
                      }
                    } else {
#line 1727
                      goto _L___8;
                    }
                  } else {
#line 1727
                    goto _L___8;
                  }
                } else {
#line 1727
                  goto _L___8;
                }
              } else {
#line 1727
                goto _L___8;
              }
            } else {
#line 1727
              goto _L___8;
            }
          } else {
#line 1727
            goto _L___8;
          }
        } else
        _L___8: /* CIL Label */ 
#line 1827
        if (subsh) {
#line 1827
          if (jn->stat & 2) {
#line 1828
            thisjob = newjob;
          } else {
#line 1830
            goto while_break___8;
          }
        } else {
#line 1830
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 1832
      signal_unblock(sigchld_mask);
      }
      {
#line 1833
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1833
        queueing_enabled --;
#line 1833
        if (! queueing_enabled) {
          {
#line 1833
          while (1) {
            while_continue___13: /* CIL Label */ ;
            {
#line 1833
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 1833
              if (! (queue_front != queue_rear)) {
#line 1833
                goto while_break___14;
              }
              {
#line 1833
              queue_front = (queue_front + 1) % 128;
#line 1833
              oset___2 = signal_setmask(signal_mask_queue[queue_front]);
#line 1833
              zhandler(signal_queue[queue_front]);
#line 1833
              signal_setmask(oset___2);
              }
            }
            while_break___14: /* CIL Label */ ;
            }
#line 1833
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
#line 1833
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 1835
      if (list_pipe) {
#line 1835
        if (lastval & 128L) {
#line 1835
          if (pj >= 0) {
#line 1835
            if (! (jn->stat & 64)) {
#line 1835
              goto _L___9;
            } else
#line 1835
            if (jn->stat & 8) {
              _L___9: /* CIL Label */ 
              {
#line 1837
              deletejob(jn, 0);
#line 1838
              jn = jobtab + pj;
              }
#line 1839
              if (jn->gleader) {
                {
#line 1840
                killjb(jn, (int )(lastval & -129L));
                }
              }
            }
          }
        }
      }
#line 1842
      if (list_pipe_child) {
        {
#line 1845
        deletejob(jn, 0);
        }
      } else
#line 1842
      if (jn->stat & 8) {
#line 1842
        if (list_pipe) {
          {
#line 1845
          deletejob(jn, 0);
          }
        } else
#line 1842
        if (pline_level) {
#line 1842
          if (! (jn->stat & 256)) {
            {
#line 1845
            deletejob(jn, 0);
            }
          }
        }
      }
#line 1846
      thisjob = pj;
    } else {
      {
#line 1849
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1849
        queueing_enabled --;
#line 1849
        if (! queueing_enabled) {
          {
#line 1849
          while (1) {
            while_continue___16: /* CIL Label */ ;
            {
#line 1849
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 1849
              if (! (queue_front != queue_rear)) {
#line 1849
                goto while_break___17;
              }
              {
#line 1849
              queue_front = (queue_front + 1) % 128;
#line 1849
              oset___3 = signal_setmask(signal_mask_queue[queue_front]);
#line 1849
              zhandler(signal_queue[queue_front]);
#line 1849
              signal_setmask(oset___3);
              }
            }
            while_break___17: /* CIL Label */ ;
            }
#line 1849
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
        }
#line 1849
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
    }
#line 1850
    if (slflags & 8) {
#line 1850
      if (! errflag) {
#line 1851
        lastval = (zlong )(! lastval);
      }
    }
  }
#line 1853
  if (! pline_level) {
#line 1854
    simple_pline = old_simple_pline;
  }
#line 1855
  return ((int )lastval);
}
}
#line 1861 "/tmp/zsh-5.4.2/Src/exec.c"
static void execpline2(Estate state , wordcode pcode , int how , int input , int output ,
                       int last1 ) 
{ 
  pid_t pid ;
  int pipes[2] ;
  struct execcmd_params eparams ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int old_list_pipe ;
  int subsh_close ;
  Wordcode next___0 ;
  Wordcode start_pc ;
  int tmp___2 ;
  int synch[2] ;
  struct timeval bgtime ;
  int *tmp___3 ;
  char dummy___0 ;
  char *text ;
  int tmp___4 ;
  int tmp___5 ;
  Wordcode tmp___6 ;

  {
#line 1869
  if (breaks) {
#line 1870
    return;
  } else
#line 1869
  if (retflag) {
#line 1870
    return;
  }
#line 1873
  if (intrap) {
#line 1873
    if (! trapisfunc) {
#line 1873
      if (! (traplocallevel == locallevel)) {
#line 1873
        goto _L___0;
      }
    } else {
#line 1873
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1873
  if (! ineval) {
#line 1873
    if ((pcode >> 5) >> 1) {
#line 1874
      lineno = (zlong )(((pcode >> 5) >> 1) - 1U);
    }
  }
#line 1876
  if (pline_level == 1) {
#line 1877
    if (how & (1 << 2)) {
#line 1877
      goto _L___1;
    } else
#line 1877
    if (! sfcontext) {
      _L___1: /* CIL Label */ 
#line 1878
      if (((pcode >> 5) & 1U) == 0U) {
#line 1878
        tmp = 0;
      } else {
#line 1878
        tmp = 1;
      }
      {
#line 1878
      tmp___0 = getjobtext(state->prog, state->pc + tmp);
#line 1878
      strcpy((char */* __restrict  */)(list_pipe_text), (char const   */* __restrict  */)tmp___0);
      }
    } else {
#line 1883
      list_pipe_text[0] = (char )'\000';
    }
  }
#line 1885
  if (((pcode >> 5) & 1U) == 0U) {
    {
#line 1886
    execcmd_analyse(state, & eparams);
    }
#line 1887
    if (last1) {
#line 1887
      tmp___1 = 1;
    } else {
#line 1887
      tmp___1 = 2;
    }
    {
#line 1887
    execcmd_exec(state, & eparams, input, output, how, tmp___1);
    }
  } else {
    {
#line 1889
    old_list_pipe = list_pipe;
#line 1890
    subsh_close = -1;
#line 1891
    next___0 = state->pc + *(state->pc);
#line 1893
    (state->pc) ++;
#line 1893
    start_pc = state->pc;
#line 1894
    execcmd_analyse(state, & eparams);
#line 1896
    tmp___2 = mpipe(pipes);
    }
#line 1903
    if (eparams.type >= 9) {
#line 1903
      goto _L___2;
    } else
#line 1903
    if (! eparams.args) {
      _L___2: /* CIL Label */ 
#line 1903
      if (how & (1 << 1)) {
        {
#line 1908
        tmp___5 = pipe((int *)(synch));
        }
#line 1908
        if (tmp___5 < 0) {
          {
#line 1909
          tmp___3 = __errno_location();
#line 1909
          zerr("pipe failed: %e", *tmp___3);
#line 1910
          lastval = (zlong )1;
#line 1911
          errflag |= 1;
          }
#line 1912
          return;
        } else {
          {
#line 1913
          pid = zfork(& bgtime);
          }
#line 1913
          if (pid == -1) {
            {
#line 1914
            close(synch[0]);
#line 1915
            close(synch[1]);
#line 1916
            lastval = (zlong )1;
#line 1917
            errflag |= 1;
            }
#line 1918
            return;
          } else
#line 1919
          if (pid) {
            {
#line 1922
            text = getjobtext(state->prog, start_pc);
#line 1923
            addproc(pid, text, 0, & bgtime);
#line 1924
            close(synch[1]);
#line 1925
            read_loop(synch[0], & dummy___0, (size_t )1);
#line 1926
            close(synch[0]);
            }
          } else {
            {
#line 1928
            zclose(pipes[0]);
#line 1929
            close(synch[0]);
            }
#line 1930
            if (how & (1 << 2)) {
#line 1930
              tmp___4 = 1;
            } else {
#line 1930
              tmp___4 = 0;
            }
            {
#line 1930
            entersubsh((tmp___4 | 2) | 4);
#line 1932
            close(synch[1]);
            }
#line 1933
            if (sigtrapped[0]) {
              {
#line 1935
              unsettrap(0);
              }
            }
            {
#line 1937
            execcmd_exec(state, & eparams, input, pipes[1], how, 1);
#line 1938
            _exit((int )lastval);
            }
          }
        }
      } else {
        {
#line 1942
        addfilelist((char const   *)((void *)0), pipes[0]);
#line 1943
        subsh_close = pipes[0];
#line 1944
        execcmd_exec(state, & eparams, input, pipes[1], how, 0);
        }
      }
    } else {
      {
#line 1942
      addfilelist((char const   *)((void *)0), pipes[0]);
#line 1943
      subsh_close = pipes[0];
#line 1944
      execcmd_exec(state, & eparams, input, pipes[1], how, 0);
      }
    }
    {
#line 1946
    zclose(pipes[1]);
#line 1947
    state->pc = next___0;
#line 1951
    cmdpush(13);
#line 1952
    list_pipe = 1;
#line 1953
    tmp___6 = state->pc;
#line 1953
    (state->pc) ++;
#line 1953
    execpline2(state, *tmp___6, how, pipes[0], output, last1);
#line 1954
    list_pipe = old_list_pipe;
#line 1955
    cmdpop();
    }
#line 1956
    if (subsh_close != pipes[0]) {
      {
#line 1957
      zclose(pipes[0]);
      }
    }
  }
#line 1959
  return;
}
}
#line 1964 "/tmp/zsh-5.4.2/Src/exec.c"
static char **makecline(LinkList list ) 
{ 
  LinkNode node ;
  char **argv ;
  char **ptr___0 ;
  int tmp ;
  void *tmp___0 ;
  char **tmp___1 ;
  char **tmp___2 ;

  {
  {
#line 1971
  tmp = countlinknodes(list);
#line 1971
  tmp___0 = hcalloc((unsigned long )(tmp + 4) * sizeof(char *));
#line 1971
  argv = (char **)tmp___0 + 2;
#line 1971
  ptr___0 = argv;
  }
#line 1974
  if (opts[177]) {
#line 1975
    if (! doneps4) {
      {
#line 1976
      printprompt4();
      }
    }
#line 1978
    node = list->list.first;
    {
#line 1978
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1978
      if (! node) {
#line 1978
        goto while_break;
      }
      {
#line 1979
      tmp___1 = ptr___0;
#line 1979
      ptr___0 ++;
#line 1979
      *tmp___1 = (char *)node->dat;
#line 1980
      quotedzputs((char const   *)node->dat, xtrerr);
      }
#line 1981
      if (node->next) {
        {
#line 1982
        fputc(' ', xtrerr);
        }
      }
#line 1978
      node = node->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1984
    fputc('\n', xtrerr);
#line 1985
    fflush(xtrerr);
    }
  } else {
#line 1987
    node = list->list.first;
    {
#line 1987
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1987
      if (! node) {
#line 1987
        goto while_break___0;
      }
#line 1988
      tmp___2 = ptr___0;
#line 1988
      ptr___0 ++;
#line 1988
      *tmp___2 = (char *)node->dat;
#line 1987
      node = node->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1990
  *ptr___0 = (char *)((void *)0);
#line 1991
  return (argv);
}
}
#line 1995 "/tmp/zsh-5.4.2/Src/exec.c"
void untokenize(char *s ) 
{ 
  int c ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 1998
  if (*s) {
    {
#line 2001
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2001
      tmp___3 = s;
#line 2001
      s ++;
#line 2001
      c = (int )*tmp___3;
#line 2001
      if (! c) {
#line 2001
        goto while_break;
      }
#line 2002
      if ((int )typtab[(unsigned char )c] & (1 << 4)) {
#line 2003
        p = s - 1;
#line 2005
        if (c != -95) {
#line 2006
          tmp = p;
#line 2006
          p ++;
#line 2006
          *tmp = ztokens[c - -124];
        }
        {
#line 2008
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2008
          tmp___2 = s;
#line 2008
          s ++;
#line 2008
          c = (int )*tmp___2;
#line 2008
          if (! c) {
#line 2008
            goto while_break___0;
          }
#line 2009
          if ((int )typtab[(unsigned char )c] & (1 << 4)) {
#line 2010
            if (c != -95) {
#line 2011
              tmp___0 = p;
#line 2011
              p ++;
#line 2011
              *tmp___0 = ztokens[c - -124];
            }
          } else {
#line 2013
            tmp___1 = p;
#line 2013
            p ++;
#line 2013
            *tmp___1 = (char )c;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2015
        *p = (char )'\000';
#line 2016
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2019
  return;
}
}
#line 2032 "/tmp/zsh-5.4.2/Src/exec.c"
void quote_tokenized_output(char *str , FILE *file ) 
{ 
  char *s ;

  {
#line 2035
  s = str;
  {
#line 2037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2037
    if (! *s) {
#line 2037
      goto while_break;
    }
    {
#line 2039
    if ((int )*s == -125) {
#line 2039
      goto case_neg_125;
    }
#line 2043
    if ((int )*s == -95) {
#line 2043
      goto case_neg_95;
    }
#line 2061
    if ((int )*s == 32) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 36) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 63) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 42) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 93) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 91) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 126) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 35) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 94) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 41) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 124) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 40) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 62) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 60) {
#line 2061
      goto case_32;
    }
#line 2061
    if ((int )*s == 92) {
#line 2061
      goto case_32;
    }
#line 2065
    if ((int )*s == 9) {
#line 2065
      goto case_9;
    }
#line 2069
    if ((int )*s == 10) {
#line 2069
      goto case_10;
    }
#line 2073
    if ((int )*s == 13) {
#line 2073
      goto case_13;
    }
#line 2077
    if ((int )*s == 61) {
#line 2077
      goto case_61;
    }
#line 2082
    goto switch_default;
    case_neg_125: /* CIL Label */ 
    {
#line 2040
    s ++;
#line 2040
    _IO_putc((int )*s ^ 32, file);
    }
#line 2041
    goto __Cont;
    case_neg_95: /* CIL Label */ 
#line 2045
    goto __Cont;
    case_32: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_124: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_62: /* CIL Label */ 
    case_60: /* CIL Label */ 
    case_92: /* CIL Label */ 
    {
#line 2062
    _IO_putc('\\', file);
    }
#line 2063
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 2066
    fputs((char const   */* __restrict  */)"$\'\\t\'", (FILE */* __restrict  */)file);
    }
#line 2067
    goto __Cont;
    case_10: /* CIL Label */ 
    {
#line 2070
    fputs((char const   */* __restrict  */)"$\'\\n\'", (FILE */* __restrict  */)file);
    }
#line 2071
    goto __Cont;
    case_13: /* CIL Label */ 
    {
#line 2074
    fputs((char const   */* __restrict  */)"$\'\\r\'", (FILE */* __restrict  */)file);
    }
#line 2075
    goto __Cont;
    case_61: /* CIL Label */ 
#line 2078
    if ((unsigned long )s == (unsigned long )str) {
      {
#line 2079
      _IO_putc('\\', file);
      }
    }
#line 2080
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2083
    if ((int )typtab[(unsigned char )*s] & (1 << 4)) {
      {
#line 2084
      _IO_putc((int )ztokens[(int )*s - -124], file);
      }
#line 2085
      goto __Cont;
    }
#line 2087
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 2090
    _IO_putc((int )*s, file);
    }
    __Cont: /* CIL Label */ 
#line 2037
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2092
  return;
}
}
#line 2096 "/tmp/zsh-5.4.2/Src/exec.c"
static int checkclobberparam(struct redir *f ) 
{ 
  struct value vbuf ;
  Value v ;
  char *s ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  zlong tmp___1 ;

  {
#line 2101
  s = f->varid;
#line 2104
  if (! s) {
#line 2105
    return (1);
  }
  {
#line 2107
  v = getvalue(& vbuf, & s, 0);
  }
#line 2107
  if (! v) {
#line 2108
    return (1);
  }
#line 2110
  if ((v->pm)->node.flags & (1 << 10)) {
    {
#line 2111
    zwarn("can\'t allocate file descriptor to readonly parameter %s", f->varid);
#line 2114
    tmp = __errno_location();
#line 2114
    *tmp = 0;
    }
#line 2115
    return (0);
  }
#line 2124
  if (! opts[33]) {
    {
#line 2124
    s = getstrvalue(v);
    }
#line 2124
    if (s) {
      {
#line 2124
      tmp___1 = zstrtol((char const   *)s, & s, 10);
#line 2124
      fd = (int )tmp___1;
      }
#line 2124
      if (fd >= 0) {
#line 2124
        if (! *s) {
#line 2124
          if (fd <= max_zsh_fd) {
#line 2124
            if ((int )*(fdtable + fd) == 2) {
              {
#line 2127
              zwarn("can\'t clobber parameter %s containing file descriptor %d", f->varid,
                    fd);
#line 2130
              tmp___0 = __errno_location();
#line 2130
              *tmp___0 = 0;
              }
#line 2131
              return (0);
            }
          }
        }
      }
    }
  }
#line 2133
  return (1);
}
}
#line 2139 "/tmp/zsh-5.4.2/Src/exec.c"
static int clobber_open(struct redir *f ) 
{ 
  struct stat buf___7 ;
  int fd ;
  int oerrno ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;

  {
#line 2146
  if (opts[33]) {
    {
#line 2147
    tmp = unmeta((char const   *)f->name);
#line 2147
    tmp___0 = open((char const   *)tmp, 833, 438);
    }
#line 2147
    return (tmp___0);
  } else
#line 2146
  if (f->type >= 0) {
#line 2146
    if (f->type <= 8) {
#line 2146
      if (f->type & 1) {
        {
#line 2147
        tmp = unmeta((char const   *)f->name);
#line 2147
        tmp___0 = open((char const   *)tmp, 833, 438);
        }
#line 2147
        return (tmp___0);
      }
    }
  }
  {
#line 2151
  tmp___1 = unmeta((char const   *)f->name);
#line 2151
  fd = open((char const   *)tmp___1, 449, 438);
  }
#line 2151
  if (fd >= 0) {
#line 2153
    return (fd);
  }
  {
#line 2158
  tmp___2 = __errno_location();
#line 2158
  oerrno = *tmp___2;
#line 2159
  tmp___4 = unmeta((char const   *)f->name);
#line 2159
  fd = open((char const   *)tmp___4, 257);
  }
#line 2159
  if (fd != -1) {
    {
#line 2160
    tmp___3 = fstat(fd, & buf___7);
    }
#line 2160
    if (! tmp___3) {
#line 2160
      if (! ((buf___7.st_mode & 61440U) == 32768U)) {
#line 2161
        return (fd);
      }
    }
    {
#line 2162
    close(fd);
    }
  }
  {
#line 2164
  tmp___5 = __errno_location();
#line 2164
  *tmp___5 = oerrno;
  }
#line 2165
  return (-1);
}
}
#line 2174 "/tmp/zsh-5.4.2/Src/exec.c"
static void closemn(struct multio **mfds , int fd , int type___0 ) 
{ 
  struct multio *mn ;
  char buf___7[4092] ;
  int len ;
  int i ;
  pid_t pid ;
  struct timeval bgtime ;
  int *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 2177
  if (fd >= 0) {
#line 2177
    if (*(mfds + fd)) {
#line 2177
      if ((*(mfds + fd))->ct >= 2) {
        {
#line 2178
        mn = *(mfds + fd);
#line 2189
        signal_block(sigchld_mask);
#line 2190
        pid = zfork(& bgtime);
        }
#line 2190
        if (pid) {
#line 2191
          i = 0;
          {
#line 2191
          while (1) {
            while_continue: /* CIL Label */ ;
#line 2191
            if (! (i < mn->ct)) {
#line 2191
              goto while_break;
            }
            {
#line 2192
            zclose(mn->fds[i]);
#line 2191
            i ++;
            }
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 2193
          zclose(mn->pipe);
          }
#line 2194
          if (pid == -1) {
            {
#line 2195
            *(mfds + fd) = (struct multio *)((void *)0);
#line 2196
            signal_unblock(sigchld_mask);
            }
#line 2197
            return;
          }
          {
#line 2199
          mn->ct = 1;
#line 2200
          mn->fds[0] = fd;
#line 2201
          addproc(pid, (char *)((void *)0), 1, & bgtime);
#line 2202
          signal_unblock(sigchld_mask);
          }
#line 2203
          return;
        }
        {
#line 2206
        signal_unblock(sigchld_mask);
#line 2207
        closeallelse(mn);
        }
#line 2208
        if (mn->rflag) {
          {
#line 2210
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 2210
            tmp___0 = read(mn->pipe, (void *)(buf___7), (size_t )4092);
#line 2210
            len = (int )tmp___0;
            }
#line 2210
            if (! (len != 0)) {
#line 2210
              goto while_break___0;
            }
#line 2211
            if (len < 0) {
              {
#line 2212
              tmp = __errno_location();
              }
#line 2212
              if (*tmp == 4) {
#line 2213
                goto while_continue___0;
              } else {
#line 2215
                goto while_break___0;
              }
            }
#line 2217
            i = 0;
            {
#line 2217
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2217
              if (! (i < mn->ct)) {
#line 2217
                goto while_break___1;
              }
              {
#line 2218
              write_loop(mn->fds[i], (char const   *)(buf___7), (size_t )len);
#line 2217
              i ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 2222
          i = 0;
          {
#line 2222
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2222
            if (! (i < mn->ct)) {
#line 2222
              goto while_break___2;
            }
            {
#line 2223
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 2223
              tmp___2 = read(mn->fds[i], (void *)(buf___7), (size_t )4092);
#line 2223
              len = (int )tmp___2;
              }
#line 2223
              if (! (len != 0)) {
#line 2223
                goto while_break___3;
              }
#line 2224
              if (len < 0) {
                {
#line 2225
                tmp___1 = __errno_location();
                }
#line 2225
                if (*tmp___1 == 4) {
#line 2226
                  goto while_continue___3;
                } else {
#line 2228
                  goto while_break___3;
                }
              }
              {
#line 2230
              write_loop(mn->pipe, (char const   *)(buf___7), (size_t )len);
              }
            }
            while_break___3: /* CIL Label */ ;
            }
#line 2222
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 2233
        _exit(0);
        }
      } else {
#line 2177
        goto _L___0;
      }
    } else {
#line 2177
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2234
  if (fd >= 0) {
#line 2234
    if (type___0 == 15) {
#line 2235
      *(mfds + fd) = (struct multio *)((void *)0);
    }
  }
#line 2236
  return;
}
}
#line 2241 "/tmp/zsh-5.4.2/Src/exec.c"
static void closemnodes(struct multio **mfds ) 
{ 
  int i ;
  int j ;

  {
#line 2246
  i = 0;
  {
#line 2246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2246
    if (! (i < 10)) {
#line 2246
      goto while_break;
    }
#line 2247
    if (*(mfds + i)) {
#line 2248
      j = 0;
      {
#line 2248
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2248
        if (! (j < (*(mfds + i))->ct)) {
#line 2248
          goto while_break___0;
        }
        {
#line 2249
        zclose((*(mfds + i))->fds[j]);
#line 2248
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2250
      *(mfds + i) = (struct multio *)((void *)0);
    }
#line 2246
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2252
  return;
}
}
#line 2255 "/tmp/zsh-5.4.2/Src/exec.c"
static void closeallelse(struct multio *mn ) 
{ 
  int i ;
  int j ;
  long openmax ;

  {
#line 2261
  openmax = (long )fdtable_size;
#line 2263
  i = 0;
  {
#line 2263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2263
    if (! ((long )i < openmax)) {
#line 2263
      goto while_break;
    }
#line 2264
    if (mn->pipe != i) {
#line 2265
      j = 0;
      {
#line 2265
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2265
        if (! (j < mn->ct)) {
#line 2265
          goto while_break___0;
        }
#line 2266
        if (mn->fds[j] == i) {
#line 2267
          goto while_break___0;
        }
#line 2265
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2268
      if (j == mn->ct) {
        {
#line 2269
        zclose(i);
        }
      }
    }
#line 2263
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2271
  return;
}
}
#line 2294 "/tmp/zsh-5.4.2/Src/exec.c"
static void addfd(int forked , int *save , struct multio **mfds , int fd1 , int fd2 ,
                  int rflag , char *varid ) 
{ 
  int pipes[2] ;
  int *tmp ;
  void *tmp___0 ;
  int fdN ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int fdN___0 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int fdN___1 ;
  int new ;
  int old ;
  void *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;

  {
#line 2300
  if (varid) {
    {
#line 2302
    fd1 = movefd(fd2);
    }
#line 2303
    if (fd1 == -1) {
      {
#line 2304
      tmp = __errno_location();
#line 2304
      zerr("cannot moved fd %d: %e", fd2, *tmp);
      }
#line 2305
      return;
    } else {
      {
#line 2307
      *(fdtable + fd1) = (unsigned char)2;
#line 2308
      setiparam(varid, (zlong )fd1);
      }
#line 2313
      if (errflag) {
        {
#line 2314
        zclose(fd1);
        }
      }
    }
  } else
#line 2316
  if (! *(mfds + fd1)) {
#line 2316
    goto _L;
  } else
#line 2316
  if (! opts[119]) {
    _L: /* CIL Label */ 
#line 2317
    if (! *(mfds + fd1)) {
      {
#line 2318
      tmp___0 = zhalloc(sizeof(struct multio ));
#line 2318
      *(mfds + fd1) = (struct multio *)tmp___0;
      }
#line 2319
      if (! forked) {
#line 2319
        if (*(save + fd1) == -2) {
#line 2320
          if (fd1 == fd2) {
#line 2321
            *(save + fd1) = -1;
          } else {
            {
#line 2323
            tmp___1 = movefd(fd1);
#line 2323
            fdN = tmp___1;
            }
#line 2328
            if (fdN < 0) {
              {
#line 2328
              tmp___3 = __errno_location();
              }
#line 2328
              if (*tmp___3 != 9) {
                {
#line 2329
                tmp___2 = __errno_location();
#line 2329
                zerr("cannot duplicate fd %d: %e", fd1, *tmp___2);
#line 2330
                *(mfds + fd1) = (struct multio *)((void *)0);
#line 2331
                closemnodes(mfds);
                }
#line 2332
                return;
              }
            }
#line 2334
            *(save + fd1) = fdN;
#line 2337
            *(fdtable + fdN) = (unsigned char )((int )*(fdtable + fdN) | 16);
          }
        }
      }
    }
#line 2341
    if (! varid) {
      {
#line 2342
      redup(fd2, fd1);
      }
    }
#line 2343
    (*(mfds + fd1))->ct = 1;
#line 2344
    (*(mfds + fd1))->fds[0] = fd1;
#line 2345
    (*(mfds + fd1))->rflag = rflag;
  } else {
#line 2347
    if ((*(mfds + fd1))->rflag != rflag) {
      {
#line 2348
      zerr("file mode mismatch on fd %d", fd1);
#line 2349
      closemnodes(mfds);
      }
#line 2350
      return;
    }
#line 2352
    if ((*(mfds + fd1))->ct == 1) {
      {
#line 2353
      tmp___4 = movefd(fd1);
#line 2353
      fdN___0 = tmp___4;
      }
#line 2354
      if (fdN___0 < 0) {
        {
#line 2355
        tmp___5 = __errno_location();
#line 2355
        zerr("multio failed for fd %d: %e", fd1, *tmp___5);
#line 2356
        closemnodes(mfds);
        }
#line 2357
        return;
      }
      {
#line 2359
      (*(mfds + fd1))->fds[0] = fdN___0;
#line 2360
      fdN___0 = movefd(fd2);
      }
#line 2361
      if (fdN___0 < 0) {
        {
#line 2362
        tmp___6 = __errno_location();
#line 2362
        zerr("multio failed for fd %d: %e", fd2, *tmp___6);
#line 2363
        closemnodes(mfds);
        }
#line 2364
        return;
      }
      {
#line 2366
      (*(mfds + fd1))->fds[1] = fdN___0;
#line 2367
      tmp___8 = mpipe(pipes);
      }
#line 2367
      if (tmp___8 < 0) {
        {
#line 2368
        tmp___7 = __errno_location();
#line 2368
        zerr("multio failed for fd %d: %e", fd2, *tmp___7);
#line 2369
        closemnodes(mfds);
        }
#line 2370
        return;
      }
      {
#line 2372
      (*(mfds + fd1))->pipe = pipes[1 - rflag];
#line 2373
      redup(pipes[rflag], fd1);
#line 2374
      (*(mfds + fd1))->ct = 2;
      }
    } else {
#line 2377
      if (! ((*(mfds + fd1))->ct % 8)) {
        {
#line 2378
        new = (int )(sizeof(struct multio ) + sizeof(int ) * (unsigned long )(*(mfds + fd1))->ct);
#line 2379
        old = (int )((unsigned long )new - sizeof(int ) * 8UL);
#line 2380
        tmp___9 = hrealloc((char *)*(mfds + fd1), (size_t )old, (size_t )new);
#line 2380
        *(mfds + fd1) = (struct multio *)tmp___9;
        }
      }
      {
#line 2382
      fdN___1 = movefd(fd2);
      }
#line 2382
      if (fdN___1 < 0) {
        {
#line 2383
        tmp___10 = __errno_location();
#line 2383
        zerr("multio failed for fd %d: %e", fd2, *tmp___10);
#line 2384
        closemnodes(mfds);
        }
#line 2385
        return;
      }
#line 2387
      tmp___11 = (*(mfds + fd1))->ct;
#line 2387
      ((*(mfds + fd1))->ct) ++;
#line 2387
      (*(mfds + fd1))->fds[tmp___11] = fdN___1;
    }
  }
#line 2390
  return;
}
}
#line 2393 "/tmp/zsh-5.4.2/Src/exec.c"
static void addvars(Estate state , Wordcode pc , int addflags ) 
{ 
  LinkList vl ;
  int xtr ;
  int isstr ;
  int htok ;
  char **arr ;
  char **ptr___0 ;
  char *name ;
  int flags ;
  Wordcode opc ;
  wordcode ac ;
  union linkroot svl ;
  struct linknode __n0 ;
  int myflags ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Param pm ;
  char *val ;
  int allexp ;
  void *tmp___3 ;
  HashNode tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char **tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  Wordcode tmp___12 ;

  {
#line 2397
  htok = 0;
#line 2401
  opc = state->pc;
#line 2411
  if (! (addflags & 4)) {
#line 2411
    flags = 6;
  } else {
#line 2411
    flags = 0;
  }
#line 2412
  xtr = (int )opts[177];
#line 2413
  if (xtr) {
    {
#line 2414
    printprompt4();
#line 2415
    doneps4 = 1;
    }
  }
#line 2417
  state->pc = pc;
  {
#line 2418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2418
    tmp___12 = state->pc;
#line 2418
    (state->pc) ++;
#line 2418
    ac = *tmp___12;
#line 2418
    if (! ((ac & (wordcode )((1 << 5) - 1)) == 5U)) {
#line 2418
      goto while_break;
    }
    {
#line 2419
    myflags = flags;
#line 2420
    name = ecgetstr(state, 2, & htok);
    }
#line 2421
    if (htok) {
      {
#line 2422
      untokenize(name);
      }
    }
#line 2423
    if (((ac >> 5) & 2U) >> 1 == 1U) {
#line 2424
      myflags |= 1;
    }
#line 2425
    if (xtr) {
#line 2426
      if (((ac >> 5) & 2U) >> 1 == 1U) {
#line 2426
        tmp = "%s+=";
      } else {
#line 2426
        tmp = "%s=";
      }
      {
#line 2426
      fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)tmp,
              name);
      }
    }
#line 2428
    isstr = ((ac >> 5) & 1U) == 0U;
#line 2428
    if (isstr) {
      {
#line 2429
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2429
        svl.list.first = & __n0;
#line 2429
        svl.list.last = & __n0;
#line 2429
        svl.list.flags = 0;
#line 2429
        __n0.next = (LinkNode )((void *)0);
#line 2429
        __n0.prev = & svl.node;
#line 2429
        tmp___0 = ecgetstr(state, 2, & htok);
#line 2429
        __n0.dat = (void *)tmp___0;
        }
#line 2429
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2430
      vl = & svl;
    } else {
      {
#line 2432
      vl = ecgetlist(state, (int )((ac >> 5) >> 2), 2, & htok);
      }
    }
#line 2434
    if (vl) {
#line 2434
      if (htok) {
#line 2435
        if (isstr) {
#line 2435
          tmp___1 = 6;
        } else {
#line 2435
          tmp___1 = 2;
        }
        {
#line 2435
        prefork(vl, tmp___1, (int *)((void *)0));
        }
#line 2437
        if (errflag) {
#line 2438
          state->pc = opc;
#line 2439
          return;
        }
#line 2441
        if (! isstr) {
#line 2441
          goto _L;
        } else
#line 2441
        if (opts[62]) {
#line 2441
          if (isstr) {
            {
#line 2441
            tmp___2 = haswilds((char *)(vl->list.first)->dat);
            }
#line 2441
            if (tmp___2) {
              _L: /* CIL Label */ 
              {
#line 2443
              globlist(vl, 0);
              }
#line 2448
              if (opts[62]) {
#line 2448
                if (isstr) {
                  {
#line 2449
                  unsetparam(name);
                  }
                }
              }
            }
          }
        }
#line 2451
        if (errflag) {
#line 2452
          state->pc = opc;
#line 2453
          return;
        }
      }
    }
#line 2456
    if (isstr) {
#line 2456
      if ((unsigned long )vl->list.first == (unsigned long )((void *)0)) {
#line 2456
        goto _L___0;
      } else
#line 2456
      if (! (vl->list.first)->next) {
        _L___0: /* CIL Label */ 
#line 2461
        if ((unsigned long )vl->list.first == (unsigned long )((void *)0)) {
          {
#line 2462
          val = ztrdup("");
          }
        } else {
          {
#line 2464
          untokenize((char *)(vl->list.first)->dat);
#line 2465
          tmp___3 = ugetnode(vl);
#line 2465
          val = ztrdup((char const   *)tmp___3);
          }
        }
#line 2467
        if (xtr) {
          {
#line 2468
          quotedzputs((char const   *)val, xtrerr);
#line 2469
          fputc(' ', xtrerr);
          }
        }
#line 2471
        if (addflags & 1) {
          {
#line 2471
          tmp___6 = strchr((char const   *)name, '[');
          }
#line 2471
          if (tmp___6) {
            {
#line 2491
            pm = assignsparam(name, val, myflags);
            }
          } else {
#line 2472
            if (addflags & 2) {
#line 2472
              if (opts[154]) {
                {
#line 2472
                tmp___4 = (*(paramtab->removenode))(paramtab, (char const   *)name);
#line 2472
                pm = (Param )tmp___4;
                }
#line 2472
                if (pm) {
#line 2472
                  if (pm->node.flags & (1 << 24)) {
                    {
#line 2475
                    zerr("%s: restricted", pm->node.nam);
#line 2476
                    zsfree(val);
#line 2477
                    state->pc = opc;
                    }
#line 2478
                    return;
                  }
                }
              }
            }
            {
#line 2480
            tmp___5 = strcmp((char const   *)name, "STTY");
            }
#line 2480
            if (tmp___5 == 0) {
              {
#line 2481
              zsfree(STTYval);
#line 2482
              STTYval = ztrdup((char const   *)val);
              }
            }
#line 2484
            allexp = (int )opts[3];
#line 2485
            opts[3] = (char)1;
#line 2486
            if (opts[95]) {
              {
#line 2487
              unsetparam(name);
              }
            }
            {
#line 2488
            pm = assignsparam(name, val, myflags);
#line 2489
            opts[3] = (char )allexp;
            }
          }
        } else {
          {
#line 2491
          pm = assignsparam(name, val, myflags);
          }
        }
#line 2492
        if (errflag) {
#line 2493
          state->pc = opc;
#line 2494
          return;
        }
#line 2496
        goto while_continue;
      }
    }
#line 2498
    if (vl) {
      {
#line 2499
      tmp___7 = countlinknodes(vl);
#line 2499
      tmp___8 = zalloc(sizeof(char *) * (unsigned long )(tmp___7 + 1));
#line 2499
      arr = (char **)tmp___8;
#line 2499
      ptr___0 = arr;
      }
      {
#line 2502
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2502
        if (! ((unsigned long )vl->list.first != (unsigned long )((void *)0))) {
#line 2502
          goto while_break___1;
        }
        {
#line 2503
        tmp___9 = ptr___0;
#line 2503
        ptr___0 ++;
#line 2503
        tmp___10 = ugetnode(vl);
#line 2503
        *tmp___9 = ztrdup((char const   *)((char *)tmp___10));
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 2505
      tmp___11 = zalloc(sizeof(char *));
#line 2505
      arr = (char **)tmp___11;
#line 2505
      ptr___0 = arr;
      }
    }
#line 2507
    *ptr___0 = (char *)((void *)0);
#line 2508
    if (xtr) {
      {
#line 2509
      fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)"( ");
#line 2510
      ptr___0 = arr;
      }
      {
#line 2510
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2510
        if (! *ptr___0) {
#line 2510
          goto while_break___2;
        }
        {
#line 2511
        quotedzputs((char const   *)*ptr___0, xtrerr);
#line 2512
        fputc(' ', xtrerr);
#line 2510
        ptr___0 ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2514
      fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)") ");
      }
    }
    {
#line 2516
    assignaparam(name, arr, myflags);
    }
#line 2517
    if (errflag) {
#line 2518
      state->pc = opc;
#line 2519
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2522
  state->pc = opc;
#line 2523
  return;
}
}
#line 2526 "/tmp/zsh-5.4.2/Src/exec.c"
void setunderscore(char *str ) 
{ 
  int l ;
  size_t tmp ;
  int nl___0 ;
  void *tmp___0 ;
  void *tmp___1 ;
  sigset_t oset ;

  {
#line 2529
  queueing_enabled ++;
#line 2530
  if (str) {
#line 2530
    if (*str) {
      {
#line 2531
      tmp = strlen((char const   *)str);
#line 2531
      l = (int )(tmp + 1UL);
#line 2531
      nl___0 = (l + 31) & -32;
      }
#line 2533
      if (nl___0 > underscorelen) {
        {
#line 2534
        zfree((void *)zunderscore, underscorelen);
#line 2535
        underscorelen = nl___0;
#line 2535
        tmp___0 = zalloc((size_t )underscorelen);
#line 2535
        zunderscore = (char *)tmp___0;
        }
      } else
#line 2533
      if (underscorelen - nl___0 > 64) {
        {
#line 2534
        zfree((void *)zunderscore, underscorelen);
#line 2535
        underscorelen = nl___0;
#line 2535
        tmp___0 = zalloc((size_t )underscorelen);
#line 2535
        zunderscore = (char *)tmp___0;
        }
      }
      {
#line 2537
      strcpy((char */* __restrict  */)zunderscore, (char const   */* __restrict  */)str);
#line 2538
      underscoreused = l;
      }
    } else {
#line 2530
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 2540
    if (underscorelen > 128) {
      {
#line 2541
      zfree((void *)zunderscore, underscorelen);
#line 2542
      underscorelen = 32;
#line 2542
      tmp___1 = zalloc((size_t )underscorelen);
#line 2542
      zunderscore = (char *)tmp___1;
      }
    }
#line 2544
    *zunderscore = (char )'\000';
#line 2545
    underscoreused = 1;
  }
  {
#line 2547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2547
    queueing_enabled --;
#line 2547
    if (! queueing_enabled) {
      {
#line 2547
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2547
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2547
          if (! (queue_front != queue_rear)) {
#line 2547
            goto while_break___1;
          }
          {
#line 2547
          queue_front = (queue_front + 1) % 128;
#line 2547
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 2547
          zhandler(signal_queue[queue_front]);
#line 2547
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2547
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2547
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2548
  return;
}
}
#line 2555 "/tmp/zsh-5.4.2/Src/exec.c"
static int esprefork  ;
#line 2555 "/tmp/zsh-5.4.2/Src/exec.c"
static int esglob  =    1;
#line 2558 "/tmp/zsh-5.4.2/Src/exec.c"
void execsubst(LinkList strs ) 
{ 
  LinkList ostrs ;

  {
#line 2561
  if (strs) {
    {
#line 2562
    prefork(strs, esprefork, (int *)((void *)0));
    }
#line 2563
    if (esglob) {
#line 2563
      if (! errflag) {
        {
#line 2564
        ostrs = strs;
#line 2565
        globlist(strs, 0);
#line 2566
        strs = ostrs;
        }
      }
    }
  }
#line 2569
  return;
}
}
#line 2577 "/tmp/zsh-5.4.2/Src/exec.c"
static HashNode resolvebuiltin(char const   *cmdarg , HashNode hn ) 
{ 
  char *modname ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 2580
  if (! ((Builtin )hn)->handlerfunc) {
    {
#line 2581
    tmp = dupstring((char const   *)((Builtin )hn)->optstr);
#line 2581
    modname = tmp;
    }
#line 2587
    if (hn->flags & (1 << 17)) {
#line 2587
      tmp___0 = (char *)((void *)0);
    } else {
#line 2587
      tmp___0 = hn->nam;
    }
    {
#line 2587
    ensurefeature((char const   *)modname, "b:", (char const   *)tmp___0);
#line 2590
    hn = (*(builtintab->getnode))(builtintab, cmdarg);
    }
#line 2591
    if (! hn) {
      {
#line 2592
      lastval = (zlong )1;
#line 2593
      zerr("autoloading module %s failed to define builtin: %s", modname, cmdarg);
      }
#line 2595
      return ((HashNode )((void *)0));
    }
  }
#line 2598
  return (hn);
}
}
#line 2607 "/tmp/zsh-5.4.2/Src/exec.c"
static void execcmd_analyse(Estate state , Execcmd_params eparams ) 
{ 
  wordcode code ;
  int i ;
  LinkList tmp ;
  wordcode tmp___0 ;
  Wordcode tmp___1 ;
  Wordcode tmp___2 ;
  wordcode tmp___3 ;

  {
#line 2613
  eparams->beg = state->pc;
#line 2614
  if ((*(state->pc) & (wordcode )((1 << 5) - 1)) == 4U) {
    {
#line 2614
    tmp = ecgetredirs(state);
#line 2614
    eparams->redir = tmp;
    }
  } else {
#line 2614
    eparams->redir = (LinkList )((void *)0);
  }
#line 2616
  if ((*(state->pc) & (wordcode )((1 << 5) - 1)) == 5U) {
#line 2617
    cmdoutval = 0;
#line 2618
    eparams->varspc = state->pc;
    {
#line 2619
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2619
      code = *(state->pc);
#line 2619
      if (! ((code & (wordcode )((1 << 5) - 1)) == 5U)) {
#line 2619
        goto while_break;
      }
#line 2620
      if (((code >> 5) & 1U) == 0U) {
#line 2620
        tmp___0 = (wordcode )3;
      } else {
#line 2620
        tmp___0 = ((code >> 5) >> 2) + 2U;
      }
#line 2620
      state->pc += tmp___0;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 2623
    eparams->varspc = (Wordcode )((void *)0);
  }
#line 2625
  tmp___1 = state->pc;
#line 2625
  (state->pc) ++;
#line 2625
  code = *tmp___1;
#line 2627
  eparams->type = (int )(code & (wordcode )((1 << 5) - 1));
#line 2628
  eparams->postassigns = 0;
  {
#line 2634
  if (eparams->type == 6) {
#line 2634
    goto case_6;
  }
#line 2640
  if (eparams->type == 7) {
#line 2640
    goto case_7;
  }
#line 2654
  goto switch_default;
  case_6: /* CIL Label */ 
  {
#line 2635
  eparams->args = ecgetlist(state, (int )(code >> 5), 1, & eparams->htok);
#line 2637
  eparams->assignspc = (Wordcode )((void *)0);
  }
#line 2638
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2641
  eparams->args = ecgetlist(state, (int )(code >> 5), 1, & eparams->htok);
#line 2643
  tmp___2 = state->pc;
#line 2643
  (state->pc) ++;
#line 2643
  eparams->postassigns = (int )*tmp___2;
#line 2644
  eparams->assignspc = state->pc;
#line 2645
  i = 0;
  }
  {
#line 2645
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2645
    if (! (i < eparams->postassigns)) {
#line 2645
      goto while_break___0;
    }
#line 2646
    code = *(state->pc);
#line 2649
    if (((code >> 5) & 1U) == 0U) {
#line 2649
      tmp___3 = (wordcode )3;
    } else {
#line 2649
      tmp___3 = ((code >> 5) >> 2) + 2U;
    }
#line 2649
    state->pc += tmp___3;
#line 2645
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2652
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2655
  eparams->args = (LinkList )((void *)0);
#line 2656
  eparams->assignspc = (Wordcode )((void *)0);
#line 2657
  eparams->htok = 0;
#line 2658
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2660
  return;
}
}
#line 2666 "/tmp/zsh-5.4.2/Src/exec.c"
static void execcmd_getargs(LinkList preargs , LinkList args , int expand ) 
{ 
  union linkroot svl ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2668
  if (! args->list.first) {
#line 2669
    return;
  } else
#line 2670
  if (expand) {
    {
#line 2672
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2672
      svl.list.first = (LinkNode )((void *)0);
#line 2672
      svl.list.last = & svl.node;
#line 2672
      svl.list.flags = 0;
#line 2672
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2674
    tmp = uremnode(args, args->list.first);
#line 2674
    insertlinknode(& svl, svl.list.last, tmp);
#line 2676
    prefork(& svl, 0, (int *)((void *)0));
#line 2677
    joinlists(preargs, & svl);
    }
  } else {
    {
#line 2679
    tmp___0 = uremnode(args, args->list.first);
#line 2679
    insertlinknode(preargs, preargs->list.last, tmp___0);
    }
  }
#line 2681
  return;
}
}
#line 2688 "/tmp/zsh-5.4.2/Src/exec.c"
static void execcmd_exec(Estate state , Execcmd_params eparams , int input , int output ,
                         int how , int last1 ) 
{ 
  HashNode hn ;
  LinkList filelist ;
  LinkNode node ;
  Redir fn___0 ;
  struct multio *mfds[10] ;
  char *text ;
  int save[10] ;
  int fil ;
  int dfil ;
  int is_cursh ;
  int do_exec ;
  int redir_err ;
  int i ;
  int nullexec ;
  int magic_assign ;
  int forked ;
  int is_shfunc ;
  int is_builtin ;
  int is_exec ;
  int use_defpath ;
  int cflags ;
  int orig_cflags ;
  int checked ;
  int oautocont ;
  FILE *oxtrerr ;
  FILE *newxtrerr ;
  LinkList args ;
  LinkList redir ;
  Wordcode varspc ;
  int type___0 ;
  LinkList preargs ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *cmdarg ;
  int tmp___4 ;
  int tmp___5 ;
  LinkNode argnode ;
  LinkNode oldnode ;
  LinkNode pnode ;
  char *argdata ;
  char *cmdopt ;
  int has_p ;
  int has_vV ;
  int has_other ;
  LinkNode argnode___0 ;
  LinkNode oldnode___0 ;
  char *argdata___0 ;
  char *cmdopt___0 ;
  char *exec_argv0 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *str ;
  char *s ;
  size_t sz___0 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int unglobbed ;
  char *cmdarg___0 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  LinkNode node___0 ;
  LinkNode next___0 ;
  char *s___0 ;
  int l ;
  size_t tmp___16 ;
  int tmp___17 ;
  char t ;
  char const   *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  Shfunc shf ;
  struct estate s___1 ;
  LinkList redir2 ;
  void *tmp___21 ;
  char *s___2 ;
  char trycd ;
  int tmp___22 ;
  char *cmdarg___1 ;
  char **checkpath ;
  int dohashcmd ;
  int tmp___23 ;
  Cmdnam tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  pid_t pid ;
  int synch[2] ;
  int flags ;
  char dummy___0 ;
  struct timeval bgtime ;
  int *tmp___29 ;
  int tmp___30 ;
  Wordcode p ;
  wordcode ac ;
  char *tmp___31 ;
  int tmp___32 ;
  wordcode tmp___33 ;
  int tmp___34 ;
  int *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  LinkList oargs ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  void *tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int closed ;
  int tmp___45 ;
  int tmp___46 ;
  int *tmp___47 ;
  int *tmp___48 ;
  int *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  int tmp___52 ;
  int *tmp___53 ;
  int *tmp___54 ;
  char *s___3 ;
  char *t___0 ;
  struct value vbuf ;
  Value v ;
  int bad ;
  zlong tmp___55 ;
  zlong tmp___56 ;
  char const   *bad_msg[3] ;
  int *tmp___57 ;
  int tmp___58 ;
  int *tmp___59 ;
  int fd ;
  int tmp___60 ;
  int tmp___61 ;
  char fdstr[(int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3] ;
  int *tmp___62 ;
  char const   *tmp___63 ;
  int *tmp___64 ;
  int tmp___65 ;
  char *tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int *tmp___69 ;
  int *tmp___70 ;
  int *tmp___71 ;
  LinkList restorelist ;
  LinkList removelist ;
  int q ;
  int flags___0 ;
  int tmp___72 ;
  Eprog redir_prog ;
  struct estate s___4 ;
  sigset_t oset ;
  int tmp___73 ;
  sigset_t oset___0 ;
  int tmp___74 ;
  int tmp___75 ;
  LinkList restorelist___0 ;
  LinkList removelist___0 ;
  int do_save ;
  int flags___1 ;
  LinkList assigns ;
  int postassigns ;
  Wordcode opc ;
  int htok ;
  wordcode ac___0 ;
  Wordcode tmp___76 ;
  char *name ;
  char *tmp___77 ;
  Asgment asg___0 ;
  union linkroot svl ;
  struct linknode __n0 ;
  char *data ;
  char *ptr___0 ;
  void *tmp___78 ;
  char *tmp___79 ;
  void *tmp___80 ;
  void *tmp___81 ;
  char *val ;
  char *tmp___82 ;
  int tmp___83 ;
  sigset_t oset___1 ;
  int tmp___84 ;
  int *tmp___85 ;
  int tmp___86 ;
  int addflags ;

  {
#line 2692
  hn = (HashNode )((void *)0);
#line 2693
  filelist = (LinkList )((void *)0);
#line 2699
  do_exec = 0;
#line 2699
  redir_err = 0;
#line 2700
  nullexec = 0;
#line 2700
  magic_assign = 0;
#line 2700
  forked = 0;
#line 2701
  is_shfunc = 0;
#line 2701
  is_builtin = 0;
#line 2701
  is_exec = 0;
#line 2701
  use_defpath = 0;
#line 2703
  cflags = 0;
#line 2703
  orig_cflags = 0;
#line 2703
  checked = 0;
#line 2703
  oautocont = -1;
#line 2704
  oxtrerr = xtrerr;
#line 2704
  newxtrerr = (FILE *)((void *)0);
#line 2709
  args = eparams->args;
#line 2710
  redir = eparams->redir;
#line 2711
  varspc = eparams->varspc;
#line 2712
  type___0 = eparams->type;
#line 2719
  doneps4 = 0;
#line 2725
  if (! args) {
#line 2725
    if (varspc) {
#line 2726
      if (errflag) {
#line 2726
        lastval = (zlong )errflag;
      } else {
#line 2726
        lastval = (zlong )cmdoutval;
      }
    }
  }
#line 2734
  use_cmdoutval = ! args;
#line 2736
  i = 0;
  {
#line 2736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2736
    if (! (i < 10)) {
#line 2736
      goto while_break;
    }
#line 2737
    save[i] = -2;
#line 2738
    mfds[i] = (struct multio *)((void *)0);
#line 2736
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2743
  if (type___0 == 6) {
#line 2743
    goto _L;
  } else
#line 2743
  if (type___0 == 7) {
    _L: /* CIL Label */ 
#line 2743
    if (args) {
#line 2743
      if ((unsigned long )args->list.first != (unsigned long )((void *)0)) {
#line 2743
        if ((int )*((char *)(args->list.first)->dat) == 37) {
#line 2745
          if (how & (1 << 3)) {
#line 2746
            oautocont = (int )opts[8];
#line 2747
            opts[8] = (char)1;
          }
#line 2749
          if (how & (1 << 3)) {
#line 2749
            tmp___0 = "disown";
          } else {
#line 2749
            if (how & (1 << 2)) {
#line 2749
              tmp = "bg";
            } else {
#line 2749
              tmp = "fg";
            }
#line 2749
            tmp___0 = tmp;
          }
          {
#line 2749
          tmp___1 = dupstring(tmp___0);
#line 2749
          insertlinknode(args, & args->node, (void *)tmp___1);
#line 2751
          how = 1 << 1;
          }
        }
      }
    }
  }
#line 2758
  if (opts[16]) {
#line 2758
    if (type___0 == 6) {
#line 2758
      if (how & (1 << 1)) {
#line 2758
        if (args) {
#line 2758
          if ((unsigned long )args->list.first != (unsigned long )((void *)0)) {
#line 2758
            if (! redir) {
#line 2758
              goto _L___0;
            } else
#line 2758
            if ((unsigned long )redir->list.first == (unsigned long )((void *)0)) {
              _L___0: /* CIL Label */ 
#line 2758
              if (! input) {
#line 2758
                if (! (args->list.first)->next) {
#line 2761
                  if (! opts[121]) {
                    {
#line 2762
                    scanjobs();
                    }
                  }
                  {
#line 2763
                  tmp___3 = findjobnam((char const   *)(args->list.first)->dat);
                  }
#line 2763
                  if (tmp___3 != -1) {
                    {
#line 2764
                    tmp___2 = dupstring("fg");
#line 2764
                    insertlinknode(args, & args->node, (void *)tmp___2);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 2772
  if (type___0 == 6) {
#line 2772
    goto _L___9;
  } else
#line 2772
  if (type___0 == 7) {
    _L___9: /* CIL Label */ 
#line 2772
    if (args) {
      {
#line 2781
      preargs = newlinklist();
#line 2782
      execcmd_getargs(preargs, args, eparams->htok);
      }
      {
#line 2783
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2783
        if (! ((unsigned long )preargs->list.first != (unsigned long )((void *)0))) {
#line 2783
          goto while_break___0;
        }
        {
#line 2784
        cmdarg = (char *)(preargs->list.first)->dat;
#line 2785
        tmp___4 = has_token((char const   *)cmdarg);
        }
#line 2785
        if (tmp___4) {
#line 2785
          tmp___5 = 0;
        } else {
#line 2785
          tmp___5 = 1;
        }
#line 2785
        checked = tmp___5;
#line 2786
        if (! checked) {
#line 2787
          goto while_break___0;
        }
#line 2788
        if (type___0 == 7) {
          {
#line 2788
          hn = (*(builtintab->getnode2))(builtintab, (char const   *)cmdarg);
          }
#line 2788
          if (hn) {
#line 2797
            checked = 1;
          } else {
#line 2788
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 2798
        if (opts[131]) {
#line 2798
          if (cflags & (1 << 9)) {
#line 2803
            goto while_break___0;
          } else {
#line 2798
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 2805
          if (! (cflags & ((1 << 7) | (1 << 8)))) {
            {
#line 2805
            hn = (*(shfunctab->getnode))(shfunctab, (char const   *)cmdarg);
            }
#line 2805
            if (hn) {
#line 2807
              is_shfunc = 1;
#line 2808
              goto while_break___0;
            }
          }
          {
#line 2810
          hn = (*(builtintab->getnode))(builtintab, (char const   *)cmdarg);
          }
#line 2810
          if (! hn) {
#line 2811
            checked = ! (cflags & (1 << 7));
#line 2812
            goto while_break___0;
          }
        }
#line 2815
        orig_cflags |= cflags;
#line 2816
        cflags &= ~ (1 << 7) & ~ (1 << 8);
#line 2817
        cflags |= hn->flags;
#line 2818
        if (! (hn->flags & (1 << 5))) {
          {
#line 2819
          is_builtin = 1;
#line 2822
          hn = resolvebuiltin((char const   *)cmdarg, hn);
          }
#line 2822
          if (! hn) {
#line 2823
            return;
          }
#line 2824
          if (type___0 != 7) {
#line 2825
            magic_assign = hn->flags & (1 << 4);
          }
#line 2826
          goto while_break___0;
        }
        {
#line 2828
        checked = 0;
#line 2835
        uremnode(preargs, preargs->list.first);
        }
#line 2836
        if (! preargs->list.first) {
          {
#line 2837
          execcmd_getargs(preargs, args, eparams->htok);
          }
#line 2838
          if (! preargs->list.first) {
#line 2839
            goto while_break___0;
          }
        }
#line 2841
        if (cflags & (1 << 8)) {
#line 2851
          pnode = (LinkNode )((void *)0);
#line 2853
          has_p = 0;
#line 2853
          has_vV = 0;
#line 2853
          has_other = 0;
#line 2854
          argnode = preargs->list.first;
#line 2855
          argdata = (char *)argnode->dat;
          {
#line 2856
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2856
            if (! ((int )*argdata == 45)) {
#line 2856
              if (! ((int )*argdata == -101)) {
#line 2856
                goto while_break___1;
              }
            }
#line 2858
            if (! *(argdata + 1)) {
#line 2860
              goto while_break___1;
            } else
#line 2858
            if ((int )*(argdata + 1) == 45) {
#line 2858
              goto _L___3;
            } else
#line 2858
            if ((int )*(argdata + 1) == -101) {
              _L___3: /* CIL Label */ 
#line 2858
              if (! *(argdata + 2)) {
#line 2860
                goto while_break___1;
              }
            }
#line 2861
            cmdopt = argdata + 1;
            {
#line 2861
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 2861
              if (! *cmdopt) {
#line 2861
                goto while_break___2;
              }
              {
#line 2863
              if ((int )*cmdopt == 112) {
#line 2863
                goto case_112;
              }
#line 2875
              if ((int )*cmdopt == 86) {
#line 2875
                goto case_86;
              }
#line 2875
              if ((int )*cmdopt == 118) {
#line 2875
                goto case_86;
              }
#line 2878
              goto switch_default;
              case_112: /* CIL Label */ 
#line 2871
              has_p = 1;
#line 2872
              pnode = argnode;
#line 2873
              goto switch_break;
              case_86: /* CIL Label */ 
              case_118: /* CIL Label */ 
#line 2876
              has_vV = 1;
#line 2877
              goto switch_break;
              switch_default: /* CIL Label */ 
#line 2879
              has_other = 1;
#line 2880
              goto switch_break;
              switch_break: /* CIL Label */ ;
              }
#line 2861
              cmdopt ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 2883
            if (has_other) {
#line 2885
              has_vV = 0;
#line 2885
              has_p = has_vV;
#line 2886
              goto while_break___1;
            }
#line 2889
            oldnode = argnode;
#line 2890
            argnode = argnode->next;
#line 2891
            if (! argnode) {
              {
#line 2892
              execcmd_getargs(preargs, args, eparams->htok);
#line 2893
              argnode = oldnode->next;
              }
#line 2893
              if (! argnode) {
#line 2894
                goto while_break___1;
              }
            }
#line 2896
            argdata = (char *)argnode->dat;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2898
          if (has_vV) {
            {
#line 2903
            insertlinknode(preargs, & preargs->node, (void *)"command");
#line 2904
            hn = & commandbn.node;
#line 2905
            is_builtin = 1;
            }
#line 2906
            goto while_break___0;
          } else
#line 2907
          if (has_p) {
#line 2909
            use_defpath = 1;
#line 2914
            if (pnode) {
              {
#line 2915
              uremnode(preargs, pnode);
              }
            }
          }
#line 2925
          if ((int )*(argdata + 0) == 45) {
#line 2925
            goto _L___5;
          } else
#line 2925
          if ((int )*(argdata + 0) == -101) {
            _L___5: /* CIL Label */ 
#line 2925
            if ((int )*(argdata + 1) == 45) {
#line 2925
              goto _L___4;
            } else
#line 2925
            if ((int )*(argdata + 1) == -101) {
              _L___4: /* CIL Label */ 
#line 2925
              if (! *(argdata + 2)) {
                {
#line 2926
                uremnode(preargs, argnode);
                }
              }
            }
          }
        } else
#line 2927
        if (cflags & (1 << 9)) {
#line 2934
          argnode___0 = preargs->list.first;
#line 2935
          argdata___0 = (char *)argnode___0->dat;
#line 2936
          exec_argv0 = (char *)((void *)0);
          {
#line 2945
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2945
            if (argdata___0) {
#line 2945
              if ((int )*argdata___0 == 45) {
#line 2945
                goto _L___8;
              } else
#line 2945
              if ((int )*argdata___0 == -101) {
                _L___8: /* CIL Label */ 
                {
#line 2945
                tmp___7 = strlen((char const   *)argdata___0);
                }
#line 2945
                if (! (tmp___7 >= 2UL)) {
#line 2945
                  goto while_break___3;
                }
              } else {
#line 2945
                goto while_break___3;
              }
            } else {
#line 2945
              goto while_break___3;
            }
#line 2946
            oldnode___0 = argnode___0;
#line 2947
            argnode___0 = oldnode___0->next;
#line 2948
            if (! argnode___0) {
              {
#line 2949
              execcmd_getargs(preargs, args, eparams->htok);
#line 2950
              argnode___0 = oldnode___0->next;
              }
            }
#line 2952
            if (! argnode___0) {
              {
#line 2953
              zerr("exec requires a command to execute");
#line 2954
              lastval = (zlong )1;
#line 2955
              errflag |= 1;
              }
#line 2956
              goto done;
            }
            {
#line 2958
            uremnode(preargs, oldnode___0);
            }
#line 2959
            if ((int )*(argdata___0 + 0) == 45) {
#line 2959
              goto _L___7;
            } else
#line 2959
            if ((int )*(argdata___0 + 0) == -101) {
              _L___7: /* CIL Label */ 
#line 2959
              if ((int )*(argdata___0 + 1) == 45) {
#line 2959
                goto _L___6;
              } else
#line 2959
              if ((int )*(argdata___0 + 1) == -101) {
                _L___6: /* CIL Label */ 
#line 2959
                if (! *(argdata___0 + 2)) {
#line 2960
                  goto while_break___3;
                }
              }
            }
#line 2961
            cmdopt___0 = argdata___0 + 1;
            {
#line 2961
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 2961
              if (! *cmdopt___0) {
#line 2961
                goto while_break___4;
              }
              {
#line 2963
              if ((int )*cmdopt___0 == 97) {
#line 2963
                goto case_97;
              }
#line 2991
              if ((int )*cmdopt___0 == 99) {
#line 2991
                goto case_99;
              }
#line 2994
              if ((int )*cmdopt___0 == 108) {
#line 2994
                goto case_108;
              }
#line 2997
              goto switch_default___0;
              case_97: /* CIL Label */ 
#line 2965
              if (*(cmdopt___0 + 1)) {
                {
#line 2966
                exec_argv0 = cmdopt___0 + 1;
#line 2968
                tmp___6 = strlen((char const   *)(cmdopt___0 + 1));
#line 2968
                cmdopt___0 += tmp___6;
                }
              } else {
#line 2970
                if (! argnode___0) {
                  {
#line 2971
                  zerr("exec requires a command to execute");
#line 2972
                  lastval = (zlong )1;
#line 2973
                  errflag |= 1;
                  }
#line 2974
                  goto done;
                }
#line 2976
                if (! argnode___0->next) {
                  {
#line 2977
                  execcmd_getargs(preargs, args, eparams->htok);
                  }
                }
#line 2979
                if (! argnode___0->next) {
                  {
#line 2980
                  zerr("exec flag -a requires a parameter");
#line 2981
                  lastval = (zlong )1;
#line 2982
                  errflag |= 1;
                  }
#line 2983
                  goto done;
                }
                {
#line 2985
                exec_argv0 = (char *)argnode___0->dat;
#line 2986
                oldnode___0 = argnode___0;
#line 2987
                argnode___0 = argnode___0->next;
#line 2988
                uremnode(args, oldnode___0);
                }
              }
#line 2990
              goto switch_break___0;
              case_99: /* CIL Label */ 
#line 2992
              cflags |= 1 << 16;
#line 2993
              goto switch_break___0;
              case_108: /* CIL Label */ 
#line 2995
              cflags |= 1 << 6;
#line 2996
              goto switch_break___0;
              switch_default___0: /* CIL Label */ 
              {
#line 2998
              zerr("unknown exec flag -%c", (int )*cmdopt___0);
#line 2999
              lastval = (zlong )1;
#line 3000
              errflag |= 1;
              }
#line 3001
              return;
              switch_break___0: /* CIL Label */ ;
              }
#line 2961
              cmdopt___0 ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 3004
            if (! argnode___0) {
#line 3005
              goto while_break___3;
            }
#line 3006
            argdata___0 = (char *)argnode___0->dat;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 3008
          if (exec_argv0) {
            {
#line 3010
            tmp___8 = strlen((char const   *)exec_argv0);
#line 3010
            sz___0 = tmp___8;
#line 3011
            tmp___9 = zalloc((6UL + sz___0) + 1UL);
#line 3011
            s = (char *)tmp___9;
#line 3011
            str = s;
#line 3012
            strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)"ARGV0=");
#line 3013
            s += 6;
#line 3014
            strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)exec_argv0);
#line 3015
            zputenv(str);
            }
          }
        }
#line 3018
        hn = (HashNode )((void *)0);
#line 3019
        if (cflags & (1 << 8)) {
#line 3019
          if (! opts[131]) {
#line 3020
            goto while_break___0;
          }
        }
#line 3021
        if (! ((unsigned long )preargs->list.first != (unsigned long )((void *)0))) {
          {
#line 3022
          execcmd_getargs(preargs, args, eparams->htok);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 3025
      preargs = (LinkList )((void *)0);
    }
  } else {
#line 3025
    preargs = (LinkList )((void *)0);
  }
#line 3028
  if (noerrexit & 4) {
#line 3028
    if (! is_shfunc) {
#line 3029
      noerrexit = 0;
    }
  }
#line 3044
  if (magic_assign) {
#line 3044
    esprefork = 1;
  } else
#line 3044
  if (opts[112]) {
#line 3044
    if (type___0 != 7) {
#line 3044
      esprefork = 1;
    } else {
#line 3044
      esprefork = 0;
    }
  } else {
#line 3044
    esprefork = 0;
  }
#line 3047
  if (args) {
#line 3048
    if (eparams->htok) {
      {
#line 3049
      prefork(args, esprefork, (int *)((void *)0));
      }
    }
#line 3050
    if (preargs) {
      {
#line 3051
      args = joinlists(preargs, args);
      }
    }
  }
#line 3054
  if (type___0 == 6) {
#line 3054
    goto _L___17;
  } else
#line 3054
  if (type___0 == 7) {
    _L___17: /* CIL Label */ 
#line 3055
    unglobbed = 0;
    {
#line 3057
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3060
      if (! (cflags & (1 << 10))) {
        {
#line 3061
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 3061
          if (! checked) {
#line 3061
            if (! errflag) {
#line 3061
              if (args) {
#line 3061
                if ((unsigned long )args->list.first != (unsigned long )((void *)0)) {
                  {
#line 3061
                  tmp___10 = has_token((char const   *)((char *)(args->list.first)->dat));
                  }
#line 3061
                  if (! tmp___10) {
#line 3061
                    goto while_break___6;
                  }
                } else {
#line 3061
                  goto while_break___6;
                }
              } else {
#line 3061
                goto while_break___6;
              }
            } else {
#line 3061
              goto while_break___6;
            }
          } else {
#line 3061
            goto while_break___6;
          }
          {
#line 3063
          zglob(args, args->list.first, 0);
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      } else
#line 3064
      if (! unglobbed) {
#line 3065
        node = args->list.first;
        {
#line 3065
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 3065
          if (! node) {
#line 3065
            goto while_break___7;
          }
          {
#line 3066
          untokenize((char *)node->dat);
#line 3065
          node = node->next;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
#line 3067
        unglobbed = 1;
      }
#line 3072
      if (cflags & (1 << 9)) {
#line 3072
        if (last1) {
#line 3073
          do_exec = 1;
        }
      }
#line 3076
      if (! args) {
#line 3076
        goto _L___16;
      } else
#line 3076
      if ((unsigned long )args->list.first == (unsigned long )((void *)0)) {
        _L___16: /* CIL Label */ 
#line 3077
        if (redir) {
#line 3077
          if ((unsigned long )redir->list.first != (unsigned long )((void *)0)) {
#line 3078
            if (do_exec) {
#line 3080
              nullexec = 1;
#line 3081
              goto while_break___5;
            } else
#line 3082
            if (varspc) {
#line 3083
              nullexec = 2;
#line 3084
              goto while_break___5;
            } else
#line 3085
            if (! nullcmd) {
              {
#line 3087
              zerr("redirection with no command");
#line 3088
              lastval = (zlong )1;
#line 3089
              errflag |= 1;
              }
#line 3090
              return;
            } else
#line 3085
            if (! *nullcmd) {
              {
#line 3087
              zerr("redirection with no command");
#line 3088
              lastval = (zlong )1;
#line 3089
              errflag |= 1;
              }
#line 3090
              return;
            } else
#line 3085
            if (opts[45]) {
              {
#line 3087
              zerr("redirection with no command");
#line 3088
              lastval = (zlong )1;
#line 3089
              errflag |= 1;
              }
#line 3090
              return;
            } else
#line 3085
            if (cflags & (1 << 5)) {
              {
#line 3087
              zerr("redirection with no command");
#line 3088
              lastval = (zlong )1;
#line 3089
              errflag |= 1;
              }
#line 3090
              return;
            } else
#line 3091
            if (! nullcmd) {
#line 3091
              goto _L___13;
            } else
#line 3091
            if (! *nullcmd) {
#line 3091
              goto _L___13;
            } else
#line 3091
            if (opts[161]) {
              _L___13: /* CIL Label */ 
#line 3092
              if (! args) {
                {
#line 3093
                args = newlinklist();
                }
              }
              {
#line 3094
              tmp___11 = dupstring(":");
#line 3094
              insertlinknode(args, args->list.last, (void *)tmp___11);
              }
            } else
#line 3095
            if (readnullcmd) {
#line 3095
              if (*readnullcmd) {
#line 3095
                if (((Redir )(redir->list.first)->dat)->type == 9) {
#line 3095
                  if (! (redir->list.first)->next) {
#line 3098
                    if (! args) {
                      {
#line 3099
                      args = newlinklist();
                      }
                    }
                    {
#line 3100
                    tmp___12 = dupstring((char const   *)readnullcmd);
#line 3100
                    insertlinknode(args, args->list.last, (void *)tmp___12);
                    }
                  } else {
#line 3095
                    goto _L___12;
                  }
                } else {
#line 3095
                  goto _L___12;
                }
              } else {
#line 3095
                goto _L___12;
              }
            } else {
              _L___12: /* CIL Label */ 
#line 3102
              if (! args) {
                {
#line 3103
                args = newlinklist();
                }
              }
              {
#line 3104
              tmp___13 = dupstring((char const   *)nullcmd);
#line 3104
              insertlinknode(args, args->list.last, (void *)tmp___13);
              }
            }
          } else {
#line 3077
            goto _L___15;
          }
        } else
        _L___15: /* CIL Label */ 
#line 3106
        if (cflags & (1 << 5)) {
#line 3106
          if (cflags & (1 << 8)) {
#line 3107
            lastval = (zlong )0;
#line 3108
            return;
          } else {
#line 3106
            goto _L___14;
          }
        } else {
          _L___14: /* CIL Label */ 
#line 3115
          if (badcshglob == 1) {
            {
#line 3116
            zerr("no match");
#line 3117
            lastval = (zlong )1;
            }
#line 3118
            return;
          }
#line 3120
          if (use_cmdoutval) {
#line 3120
            cmdoutval = (int )lastval;
          } else {
#line 3120
            cmdoutval = 0;
          }
#line 3121
          if (varspc) {
            {
#line 3122
            addvars(state, varspc, 0);
            }
          }
#line 3123
          if (errflag) {
#line 3124
            lastval = (zlong )1;
          } else {
#line 3126
            lastval = (zlong )cmdoutval;
          }
#line 3127
          if (opts[177]) {
            {
#line 3128
            fputc('\n', xtrerr);
#line 3129
            fflush(xtrerr);
            }
          }
#line 3131
          return;
        }
      } else
#line 3133
      if (opts[154]) {
#line 3133
        if (cflags & (1 << 9)) {
#line 3133
          if (do_exec) {
            {
#line 3134
            zerrnam("exec", "%s: restricted", (char *)(args->list.first)->dat);
#line 3136
            lastval = (zlong )1;
            }
#line 3137
            return;
          }
        }
      }
#line 3154
      if (errflag) {
#line 3157
        goto while_break___5;
      } else
#line 3154
      if (checked) {
#line 3157
        goto while_break___5;
      } else
#line 3154
      if (is_builtin) {
#line 3157
        goto while_break___5;
      } else {
#line 3154
        if (opts[131]) {
#line 3154
          tmp___14 = cflags & (1 << 9);
        } else {
#line 3154
          tmp___14 = cflags & (1 << 8);
        }
#line 3154
        if (tmp___14) {
#line 3157
          goto while_break___5;
        }
      }
#line 3159
      cmdarg___0 = (char *)(args->list.first)->dat;
#line 3160
      if (! (cflags & ((1 << 7) | (1 << 8)))) {
        {
#line 3160
        hn = (*(shfunctab->getnode))(shfunctab, (char const   *)cmdarg___0);
        }
#line 3160
        if (hn) {
#line 3162
          is_shfunc = 1;
#line 3163
          goto while_break___5;
        }
      }
      {
#line 3165
      hn = (*(builtintab->getnode))(builtintab, (char const   *)cmdarg___0);
      }
#line 3165
      if (! hn) {
#line 3166
        if (cflags & (1 << 7)) {
          {
#line 3167
          zwarn("no such builtin: %s", cmdarg___0);
#line 3168
          lastval = (zlong )1;
          }
#line 3169
          if (oautocont >= 0) {
#line 3170
            opts[8] = (char )oautocont;
          }
#line 3171
          return;
        }
#line 3173
        goto while_break___5;
      }
#line 3175
      if (! (hn->flags & (1 << 5))) {
        {
#line 3176
        is_builtin = 1;
#line 3179
        hn = resolvebuiltin((char const   *)cmdarg___0, hn);
        }
#line 3179
        if (! hn) {
#line 3180
          return;
        }
#line 3181
        goto while_break___5;
      }
      {
#line 3183
      cflags &= ~ (1 << 7) & ~ (1 << 8);
#line 3184
      cflags |= hn->flags;
#line 3185
      uremnode(args, args->list.first);
#line 3186
      hn = (HashNode )((void *)0);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 3190
  if (errflag) {
#line 3191
    lastval = (zlong )1;
#line 3192
    if (oautocont >= 0) {
#line 3193
      opts[8] = (char )oautocont;
    }
#line 3194
    return;
  }
#line 3198
  if (how & (1 << 2)) {
    {
#line 3200
    text = getjobtext(state->prog, eparams->beg);
    }
  } else
#line 3198
  if (! sfcontext) {
#line 3198
    if (opts[116]) {
      {
#line 3200
      text = getjobtext(state->prog, eparams->beg);
      }
    } else
#line 3198
    if (how & 1) {
      {
#line 3200
      text = getjobtext(state->prog, eparams->beg);
      }
    } else {
#line 3202
      text = (char *)((void *)0);
    }
  } else {
#line 3202
    text = (char *)((void *)0);
  }
#line 3209
  if (type___0 != 11) {
#line 3210
    if (args) {
#line 3210
      if ((unsigned long )args->list.first != (unsigned long )((void *)0)) {
#line 3210
        tmp___15 = (char const   *)((char *)(args->list.last)->dat);
      } else {
#line 3210
        tmp___15 = "";
      }
    } else {
#line 3210
      tmp___15 = "";
    }
    {
#line 3210
    setunderscore((char *)tmp___15);
    }
  }
#line 3214
  if (type___0 == 6) {
#line 3214
    if (opts[93]) {
#line 3214
      if (! opts[155]) {
#line 3214
        if (opts[160]) {
#line 3214
          if (args) {
#line 3214
            if ((unsigned long )args->list.first != (unsigned long )((void *)0)) {
#line 3214
              if ((args->list.first)->next) {
                {
#line 3214
                tmp___20 = strcmp((char const   *)(args->list.first)->dat, "rm");
                }
#line 3214
                if (! tmp___20) {
#line 3219
                  node___0 = (args->list.first)->next;
                  {
#line 3219
                  while (1) {
                    while_continue___8: /* CIL Label */ ;
#line 3219
                    if (node___0) {
#line 3219
                      if (! (! errflag)) {
#line 3219
                        goto while_break___8;
                      }
                    } else {
#line 3219
                      goto while_break___8;
                    }
                    {
#line 3220
                    s___0 = (char *)node___0->dat;
#line 3221
                    tmp___16 = strlen((char const   *)s___0);
#line 3221
                    l = (int )tmp___16;
#line 3223
                    next___0 = node___0->next;
                    }
#line 3224
                    if ((int )*(s___0 + 0) == -121) {
#line 3224
                      if (! *(s___0 + 1)) {
                        {
#line 3225
                        tmp___17 = checkrmall(pwd);
                        }
#line 3225
                        if (! tmp___17) {
                          {
#line 3226
                          uremnode(args, node___0);
                          }
                        }
                      } else {
#line 3224
                        goto _L___18;
                      }
                    } else
                    _L___18: /* CIL Label */ 
#line 3227
                    if (l >= 2) {
#line 3227
                      if ((int )*(s___0 + (l - 2)) == 47) {
#line 3227
                        if ((int )*(s___0 + (l - 1)) == -121) {
#line 3228
                          t = *(s___0 + (l - 2));
#line 3230
                          *(s___0 + (l - 2)) = (char)0;
#line 3231
                          if (*s___0) {
#line 3231
                            tmp___18 = (char const   *)s___0;
                          } else {
#line 3231
                            tmp___18 = "/";
                          }
                          {
#line 3231
                          tmp___19 = checkrmall((char *)tmp___18);
                          }
#line 3231
                          if (! tmp___19) {
                            {
#line 3232
                            uremnode(args, node___0);
                            }
                          }
#line 3233
                          *(s___0 + (l - 2)) = t;
                        }
                      }
                    }
#line 3219
                    node___0 = next___0;
                  }
                  while_break___8: /* CIL Label */ ;
                  }
#line 3236
                  if (! (args->list.first)->next) {
#line 3237
                    errflag |= 1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 3240
  if (type___0 == 11) {
#line 3249
    if (*(state->pc) != 0U) {
#line 3251
      redir = (LinkList )((void *)0);
    }
  } else
#line 3253
  if (is_shfunc) {
#line 3253
    goto _L___19;
  } else
#line 3253
  if (type___0 == 20) {
    _L___19: /* CIL Label */ 
#line 3255
    if (is_shfunc) {
#line 3256
      shf = (Shfunc )hn;
    } else {
      {
#line 3258
      shf = loadautofn((state->prog)->shf, 1, 0, 0);
      }
#line 3259
      if (shf) {
#line 3260
        (state->prog)->shf = shf;
      } else {
#line 3265
        lastval = (zlong )1;
#line 3266
        if (oautocont >= 0) {
#line 3267
          opts[8] = (char )oautocont;
        }
#line 3268
        return;
      }
    }
#line 3275
    if (shf->redir) {
      {
#line 3279
      s___1.prog = shf->redir;
#line 3280
      s___1.pc = (shf->redir)->prog;
#line 3281
      s___1.strs = (shf->redir)->strs;
#line 3282
      redir2 = ecgetredirs(& s___1);
      }
#line 3283
      if (! redir) {
#line 3284
        redir = redir2;
      } else {
        {
#line 3286
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 3286
          if (! ((unsigned long )redir2->list.first != (unsigned long )((void *)0))) {
#line 3286
            goto while_break___9;
          }
          {
#line 3287
          tmp___21 = ugetnode(redir2);
#line 3287
          insertlinknode(redir, redir->list.last, tmp___21);
          }
        }
        while_break___9: /* CIL Label */ ;
        }
      }
    }
  }
#line 3292
  if (errflag) {
#line 3293
    lastval = (zlong )1;
#line 3294
    if (oautocont >= 0) {
#line 3295
      opts[8] = (char )oautocont;
    }
#line 3296
    return;
  }
#line 3299
  if (type___0 == 6) {
#line 3299
    goto _L___21;
  } else
#line 3299
  if (type___0 == 7) {
    _L___21: /* CIL Label */ 
#line 3299
    if (! nullexec) {
#line 3301
      if (opts[7]) {
#line 3301
        if (opts[160]) {
#line 3301
          if (! redir) {
#line 3301
            goto _L___20;
          } else
#line 3301
          if ((unsigned long )redir->list.first == (unsigned long )((void *)0)) {
            _L___20: /* CIL Label */ 
#line 3301
            if (args) {
#line 3301
              if (! ((unsigned long )args->list.first == (unsigned long )((void *)0))) {
#line 3301
                if (! (args->list.first)->next) {
#line 3301
                  if (*((char *)(args->list.first)->dat)) {
#line 3301
                    tmp___22 = 1;
                  } else {
#line 3301
                    tmp___22 = 0;
                  }
                } else {
#line 3301
                  tmp___22 = 0;
                }
              } else {
#line 3301
                tmp___22 = 0;
              }
            } else {
#line 3301
              tmp___22 = 0;
            }
          } else {
#line 3301
            tmp___22 = 0;
          }
        } else {
#line 3301
          tmp___22 = 0;
        }
      } else {
#line 3301
        tmp___22 = 0;
      }
#line 3301
      trycd = (char )tmp___22;
#line 3306
      if (! hn) {
        {
#line 3308
        cmdarg___1 = (char *)(args->list.first)->dat;
#line 3309
        checkpath = pathchecked;
#line 3310
        dohashcmd = (int )opts[67];
#line 3312
        hn = (*(cmdnamtab->getnode))(cmdnamtab, (char const   *)cmdarg___1);
        }
#line 3313
        if (hn) {
#line 3313
          if (trycd) {
            {
#line 3313
            tmp___23 = isreallycom((Cmdnam )hn);
            }
#line 3313
            if (! tmp___23) {
#line 3314
              if (! (((Cmdnam )hn)->node.flags & (1 << 1))) {
#line 3315
                checkpath = path;
#line 3316
                dohashcmd = 1;
              }
              {
#line 3318
              (*(cmdnamtab->removenode))(cmdnamtab, (char const   *)cmdarg___1);
#line 3319
              (*(cmdnamtab->freenode))(hn);
#line 3320
              hn = (HashNode )((void *)0);
              }
            }
          }
        }
#line 3322
        if (! hn) {
#line 3322
          if (dohashcmd) {
            {
#line 3322
            tmp___25 = strcmp((char const   *)cmdarg___1, "..");
            }
#line 3322
            if (tmp___25) {
#line 3323
              s___2 = cmdarg___1;
              {
#line 3323
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 3323
                if (*s___2) {
#line 3323
                  if (! ((int )*s___2 != 47)) {
#line 3323
                    goto while_break___10;
                  }
                } else {
#line 3323
                  goto while_break___10;
                }
#line 3323
                s___2 ++;
              }
              while_break___10: /* CIL Label */ ;
              }
#line 3324
              if (! *s___2) {
                {
#line 3325
                tmp___24 = hashcmd(cmdarg___1, checkpath);
#line 3325
                hn = (HashNode )tmp___24;
                }
              }
            }
          }
        }
      }
#line 3331
      if (! hn) {
#line 3331
        if (trycd) {
          {
#line 3331
          s___2 = cancd((char *)(args->list.first)->dat);
          }
#line 3331
          if (s___2) {
            {
#line 3332
            (args->list.first)->dat = (void *)s___2;
#line 3333
            tmp___26 = dupstring("--");
#line 3333
            insertlinknode(args, & args->node, (void *)tmp___26);
#line 3334
            tmp___27 = dupstring("cd");
#line 3334
            insertlinknode(args, & args->node, (void *)tmp___27);
#line 3335
            hn = (*(builtintab->getnode))(builtintab, "cd");
            }
#line 3335
            if (hn) {
#line 3336
              is_builtin = 1;
            }
          }
        }
      }
    }
  }
#line 3341
  if (is_builtin) {
#line 3341
    tmp___28 = 1;
  } else
#line 3341
  if (is_shfunc) {
#line 3341
    tmp___28 = 1;
  } else
#line 3341
  if (nullexec) {
#line 3341
    tmp___28 = 1;
  } else
#line 3341
  if (type___0 >= 9) {
#line 3341
    tmp___28 = 1;
  } else {
#line 3341
    tmp___28 = 0;
  }
#line 3341
  is_cursh = tmp___28;
#line 3364
  if (how & (1 << 2)) {
#line 3364
    goto _L___25;
  } else
#line 3364
  if (! do_exec) {
#line 3364
    if (is_builtin) {
#line 3364
      goto _L___27;
    } else
#line 3364
    if (is_shfunc) {
      _L___27: /* CIL Label */ 
#line 3364
      if (output) {
#line 3364
        goto _L___25;
      } else {
#line 3364
        goto _L___26;
      }
    } else
    _L___26: /* CIL Label */ 
#line 3364
    if (! is_cursh) {
#line 3364
      if (last1 != 1) {
#line 3364
        goto _L___25;
      } else
#line 3364
      if (nsigtrapped) {
#line 3364
        goto _L___25;
      } else {
        {
#line 3364
        tmp___37 = havefiles();
        }
#line 3364
        if (tmp___37) {
#line 3364
          goto _L___25;
        } else
#line 3364
        if (fdtable_flocks) {
          _L___25: /* CIL Label */ 
          {
#line 3375
          signal_block(sigchld_mask);
#line 3377
          tmp___30 = pipe((int *)(synch));
          }
#line 3377
          if (tmp___30 < 0) {
            {
#line 3378
            tmp___29 = __errno_location();
#line 3378
            zerr("pipe failed: %e", *tmp___29);
            }
#line 3379
            goto fatal;
          } else {
            {
#line 3380
            pid = zfork(& bgtime);
            }
#line 3380
            if (pid == -1) {
              {
#line 3381
              close(synch[0]);
#line 3382
              close(synch[1]);
#line 3383
              lastval = (zlong )1;
#line 3384
              errflag |= 1;
              }
#line 3385
              goto fatal;
            }
          }
#line 3387
          if (pid) {
            {
#line 3389
            close(synch[1]);
#line 3390
            read_loop(synch[0], & dummy___0, (size_t )1);
#line 3391
            close(synch[0]);
            }
#line 3392
            if (how & (1 << 2)) {
#line 3393
              lastpid = (zlong )pid;
            } else
#line 3394
            if (! (jobtab + thisjob)->stty_in_env) {
#line 3394
              if (varspc) {
#line 3396
                p = varspc;
                {
#line 3399
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 3399
                  ac = *p;
#line 3399
                  if (! ((ac & (wordcode )((1 << 5) - 1)) == 5U)) {
#line 3399
                    goto while_break___11;
                  }
                  {
#line 3400
                  tmp___31 = ecrawstr(state->prog, p + 1, (int *)((void *)0));
#line 3400
                  tmp___32 = strcmp((char const   *)tmp___31, "STTY");
                  }
#line 3400
                  if (! tmp___32) {
#line 3401
                    (jobtab + thisjob)->stty_in_env = 1;
#line 3402
                    goto while_break___11;
                  }
#line 3404
                  if (((ac >> 5) & 1U) == 0U) {
#line 3404
                    tmp___33 = (wordcode )3;
                  } else {
#line 3404
                    tmp___33 = ((ac >> 5) >> 2) + 2U;
                  }
#line 3404
                  p += tmp___33;
                }
                while_break___11: /* CIL Label */ ;
                }
              }
            }
            {
#line 3408
            addproc(pid, text, 0, & bgtime);
            }
#line 3409
            if (oautocont >= 0) {
#line 3410
              opts[8] = (char )oautocont;
            }
            {
#line 3411
            pipecleanfilelist((jobtab + thisjob)->filelist, 1);
            }
#line 3412
            return;
          }
          {
#line 3415
          close(synch[0]);
          }
#line 3416
          if (how & (1 << 2)) {
#line 3416
            tmp___34 = 1;
          } else {
#line 3416
            tmp___34 = 0;
          }
#line 3416
          flags = tmp___34 | 2;
#line 3417
          if (type___0 != 8) {
#line 3417
            if (! (how & (1 << 2))) {
#line 3418
              flags |= 4;
            }
          }
#line 3419
          if (type___0 == 8) {
#line 3419
            if (! (how & (1 << 2))) {
#line 3420
              flags |= 64;
            }
          }
          {
#line 3421
          filelist = (jobtab + thisjob)->filelist;
#line 3422
          entersubsh(flags);
#line 3423
          close(synch[1]);
#line 3424
          forked = 1;
          }
#line 3425
          if (sigtrapped[2] & (1 << 1)) {
            {
#line 3426
            holdintr();
            }
          }
#line 3429
          if (how & (1 << 2)) {
#line 3429
            if (opts[23]) {
              {
#line 3430
              tmp___36 = nice(5);
              }
#line 3430
              if (tmp___36 < 0) {
                {
#line 3431
                tmp___35 = __errno_location();
#line 3431
                zwarn("nice(5) failed: %e", *tmp___35);
                }
              }
            }
          }
        } else {
#line 3364
          goto _L___23;
        }
      }
    } else {
#line 3364
      goto _L___23;
    }
  } else
  _L___23: /* CIL Label */ 
#line 3434
  if (is_cursh) {
#line 3438
    (jobtab + thisjob)->stat |= 1024;
#line 3439
    if (! (jobtab + thisjob)->procs) {
#line 3440
      (jobtab + thisjob)->stat |= 32;
    }
#line 3441
    if (is_builtin) {
#line 3442
      (jobtab + thisjob)->stat |= 16384;
    }
  } else {
#line 3447
    is_exec = 1;
#line 3455
    if (type___0 == 8) {
#line 3456
      forked = 1;
    }
  }
#line 3459
  esglob = ! (cflags & (1 << 10));
#line 3459
  if (esglob) {
#line 3459
    if (args) {
#line 3459
      if (eparams->htok) {
        {
#line 3460
        oargs = args;
#line 3461
        globlist(args, 0);
#line 3462
        args = oargs;
        }
      }
    }
  }
#line 3464
  if (errflag) {
#line 3465
    lastval = (zlong )1;
#line 3466
    goto err;
  }
  {
#line 3470
  fflush(xtrerr);
  }
#line 3471
  if (opts[177]) {
#line 3471
    if ((unsigned long )xtrerr == (unsigned long )stderr) {
#line 3471
      if (type___0 < 8) {
#line 3471
        goto _L___28;
      } else
#line 3471
      if (type___0 == 10) {
        _L___28: /* CIL Label */ 
        {
#line 3473
        tmp___39 = fileno(stderr);
#line 3473
        tmp___40 = dup(tmp___39);
#line 3473
        tmp___41 = movefd(tmp___40);
#line 3473
        newxtrerr = fdopen(tmp___41, "w");
        }
#line 3473
        if (newxtrerr) {
          {
#line 3474
          xtrerr = newxtrerr;
#line 3475
          tmp___38 = fileno(xtrerr);
#line 3475
          *(fdtable + tmp___38) = (unsigned char)4;
          }
        }
      }
    }
  }
#line 3480
  if (input) {
    {
#line 3481
    addfd(forked, save, mfds, 0, input, 0, (char *)((void *)0));
    }
  }
#line 3482
  if (output) {
    {
#line 3483
    addfd(forked, save, mfds, 1, output, 1, (char *)((void *)0));
    }
  }
#line 3486
  if (redir) {
    {
#line 3487
    spawnpipes(redir, nullexec);
    }
  }
  {
#line 3490
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 3490
    if (redir) {
#line 3490
      if (! ((unsigned long )redir->list.first != (unsigned long )((void *)0))) {
#line 3490
        goto while_break___12;
      }
    } else {
#line 3490
      goto while_break___12;
    }
    {
#line 3491
    tmp___42 = ugetnode(redir);
#line 3491
    fn___0 = (Redir )tmp___42;
    }
#line 3495
    if (fn___0->type == 16) {
      {
#line 3496
      tmp___43 = checkclobberparam(fn___0);
      }
#line 3496
      if (tmp___43) {
#line 3496
        if (fn___0->fd2 == -1) {
          _L___29: /* CIL Label */ 
#line 3497
          if (fn___0->fd2 != -1) {
            {
#line 3498
            zclose(fn___0->fd2);
            }
          }
          {
#line 3499
          closemnodes(mfds);
#line 3500
          fixfds(save);
          }
          {
#line 3501
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 3501
            if (! forked) {
#line 3501
              lastval = (zlong )1;
#line 3501
              redir_err = (int )lastval;
#line 3501
              goto done;
            } else {
              {
#line 3501
              _exit(1);
              }
            }
#line 3501
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
      } else {
#line 3496
        goto _L___29;
      }
      {
#line 3503
      addfd(forked, save, mfds, fn___0->fd1, fn___0->fd2, 0, fn___0->varid);
      }
    } else
#line 3504
    if (fn___0->type == 17) {
      {
#line 3505
      tmp___44 = checkclobberparam(fn___0);
      }
#line 3505
      if (tmp___44) {
#line 3505
        if (fn___0->fd2 == -1) {
          _L___30: /* CIL Label */ 
#line 3506
          if (fn___0->fd2 != -1) {
            {
#line 3507
            zclose(fn___0->fd2);
            }
          }
          {
#line 3508
          closemnodes(mfds);
#line 3509
          fixfds(save);
          }
          {
#line 3510
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 3510
            if (! forked) {
#line 3510
              lastval = (zlong )1;
#line 3510
              redir_err = (int )lastval;
#line 3510
              goto done;
            } else {
              {
#line 3510
              _exit(1);
              }
            }
#line 3510
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
      } else {
#line 3505
        goto _L___30;
      }
      {
#line 3512
      addfd(forked, save, mfds, fn___0->fd1, fn___0->fd2, 1, fn___0->varid);
      }
    } else {
#line 3515
      if (fn___0->type != 12) {
        {
#line 3515
        tmp___45 = xpandredir(fn___0, redir);
        }
#line 3515
        if (tmp___45) {
#line 3516
          goto while_continue___12;
        }
      }
#line 3517
      if (errflag) {
        {
#line 3518
        closemnodes(mfds);
#line 3519
        fixfds(save);
        }
        {
#line 3520
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 3520
          if (! forked) {
#line 3520
            lastval = (zlong )1;
#line 3520
            redir_err = (int )lastval;
#line 3520
            goto done;
          } else {
            {
#line 3520
            _exit(1);
            }
          }
#line 3520
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
#line 3522
      if (opts[154]) {
#line 3522
        if (fn___0->type >= 0) {
#line 3522
          if (fn___0->type <= 8) {
            {
#line 3523
            zwarn("writing redirection not allowed in restricted mode");
            }
            {
#line 3524
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 3524
              if (! forked) {
#line 3524
                lastval = (zlong )1;
#line 3524
                redir_err = (int )lastval;
#line 3524
                goto done;
              } else {
                {
#line 3524
                _exit(1);
                }
              }
#line 3524
              goto while_break___16;
            }
            while_break___16: /* CIL Label */ ;
            }
          }
        }
      }
#line 3526
      if (! opts[52]) {
#line 3527
        goto while_continue___12;
      }
      {
#line 3529
      if (fn___0->type == 12) {
#line 3529
        goto case_12;
      }
#line 3545
      if (fn___0->type == 8) {
#line 3545
        goto case_8;
      }
#line 3545
      if (fn___0->type == 9) {
#line 3545
        goto case_8;
      }
#line 3567
      if (fn___0->type == 15) {
#line 3567
        goto case_15;
      }
#line 3642
      if (fn___0->type == 14) {
#line 3642
        goto case_14;
      }
#line 3642
      if (fn___0->type == 13) {
#line 3642
        goto case_14;
      }
#line 3682
      goto switch_default___1;
      case_12: /* CIL Label */ 
      {
#line 3530
      tmp___46 = checkclobberparam(fn___0);
      }
#line 3530
      if (tmp___46) {
        {
#line 3533
        fil = getherestr(fn___0);
        }
      } else {
#line 3531
        fil = -1;
      }
#line 3534
      if (fil == -1) {
        {
#line 3535
        tmp___48 = __errno_location();
        }
#line 3535
        if (*tmp___48) {
          {
#line 3535
          tmp___49 = __errno_location();
          }
#line 3535
          if (*tmp___49 != 4) {
            {
#line 3536
            tmp___47 = __errno_location();
#line 3536
            zwarn("can\'t create temp file for here document: %e", *tmp___47);
            }
          }
        }
        {
#line 3538
        closemnodes(mfds);
#line 3539
        fixfds(save);
        }
        {
#line 3540
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 3540
          if (! forked) {
#line 3540
            lastval = (zlong )1;
#line 3540
            redir_err = (int )lastval;
#line 3540
            goto done;
          } else {
            {
#line 3540
            _exit(1);
            }
          }
#line 3540
          goto while_break___17;
        }
        while_break___17: /* CIL Label */ ;
        }
      }
      {
#line 3542
      addfd(forked, save, mfds, fn___0->fd1, fil, 0, fn___0->varid);
      }
#line 3543
      goto switch_break___1;
      case_8: /* CIL Label */ 
      case_9: /* CIL Label */ 
      {
#line 3546
      tmp___52 = checkclobberparam(fn___0);
      }
#line 3546
      if (tmp___52) {
#line 3548
        if (fn___0->type == 9) {
          {
#line 3549
          tmp___50 = unmeta((char const   *)fn___0->name);
#line 3549
          fil = open((char const   *)tmp___50, 256);
          }
        } else {
          {
#line 3551
          tmp___51 = unmeta((char const   *)fn___0->name);
#line 3551
          fil = open((char const   *)tmp___51, 322, 438);
          }
        }
      } else {
#line 3547
        fil = -1;
      }
#line 3553
      if (fil == -1) {
        {
#line 3554
        closemnodes(mfds);
#line 3555
        fixfds(save);
#line 3556
        tmp___54 = __errno_location();
        }
#line 3556
        if (*tmp___54 != 4) {
          {
#line 3557
          tmp___53 = __errno_location();
#line 3557
          zwarn("%e: %s", *tmp___53, fn___0->name);
          }
        }
        {
#line 3558
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 3558
          if (! forked) {
#line 3558
            lastval = (zlong )1;
#line 3558
            redir_err = (int )lastval;
#line 3558
            goto done;
          } else {
            {
#line 3558
            _exit(1);
            }
          }
#line 3558
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      }
      {
#line 3560
      addfd(forked, save, mfds, fn___0->fd1, fil, 0, fn___0->varid);
      }
#line 3563
      if (nullexec == 1) {
#line 3563
        if (fn___0->fd1 == 0) {
#line 3563
          if (opts[160]) {
#line 3563
            if (opts[93]) {
#line 3563
              if (! zleactive) {
                {
#line 3565
                init_io((char *)((void *)0));
                }
              }
            }
          }
        }
      }
#line 3566
      goto switch_break___1;
      case_15: /* CIL Label */ 
#line 3568
      if (fn___0->varid) {
        {
#line 3569
        s___3 = fn___0->varid;
#line 3572
        bad = 0;
#line 3574
        v = getvalue(& vbuf, & s___3, 0);
        }
#line 3574
        if (v) {
#line 3576
          if ((v->pm)->node.flags & (1 << 10)) {
#line 3577
            bad = 2;
          } else {
            {
#line 3579
            s___3 = getstrvalue(v);
            }
#line 3580
            if (errflag) {
#line 3581
              bad = 1;
            } else {
              {
#line 3583
              tmp___55 = zstrtol((char const   *)s___3, & t___0, 0);
#line 3583
              fn___0->fd1 = (int )tmp___55;
              }
#line 3584
              if ((unsigned long )s___3 == (unsigned long )t___0) {
#line 3585
                bad = 1;
              } else
#line 3586
              if (*t___0) {
#line 3588
                if ((int )*t___0 == 35) {
#line 3588
                  if ((int )*s___3 != 48) {
                    {
#line 3589
                    s___3 = t___0 + 1;
#line 3589
                    tmp___56 = zstrtol((char const   *)s___3, & t___0, fn___0->fd1);
#line 3589
                    fn___0->fd1 = (int )tmp___56;
                    }
                  }
                }
#line 3590
                if ((unsigned long )s___3 == (unsigned long )t___0) {
#line 3591
                  bad = 1;
                } else
#line 3590
                if (*t___0) {
#line 3591
                  bad = 1;
                }
              }
#line 3593
              if (! bad) {
#line 3593
                if (fn___0->fd1 <= max_zsh_fd) {
#line 3594
                  if (fn___0->fd1 >= 10) {
#line 3594
                    if (((int )*(fdtable + fn___0->fd1) & 15) == 1) {
#line 3597
                      bad = 3;
                    }
                  }
                }
              }
            }
          }
        } else {
#line 3575
          bad = 1;
        }
#line 3601
        if (bad) {
#line 3602
          bad_msg[0] = "parameter %s does not contain a file descriptor";
#line 3602
          bad_msg[1] = "can\'t close file descriptor from readonly parameter %s";
#line 3602
          bad_msg[2] = "file descriptor %d used by shell, not closed";
#line 3607
          if (bad > 2) {
            {
#line 3608
            zwarn(bad_msg[bad - 1], fn___0->fd1);
            }
          } else {
            {
#line 3610
            zwarn(bad_msg[bad - 1], fn___0->varid);
            }
          }
          {
#line 3611
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 3611
            if (! forked) {
#line 3611
              lastval = (zlong )1;
#line 3611
              redir_err = (int )lastval;
#line 3611
              goto done;
            } else {
              {
#line 3611
              _exit(1);
              }
            }
#line 3611
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
        }
      }
#line 3618
      closed = 0;
#line 3619
      if (! forked) {
#line 3619
        if (fn___0->fd1 < 10) {
#line 3619
          if (save[fn___0->fd1] == -2) {
            {
#line 3620
            save[fn___0->fd1] = movefd(fn___0->fd1);
            }
#line 3621
            if (save[fn___0->fd1] >= 0) {
#line 3626
              closed = 1;
            }
          }
        }
      }
#line 3629
      if (fn___0->fd1 < 10) {
        {
#line 3630
        closemn(mfds, fn___0->fd1, 15);
        }
      }
#line 3636
      if (! closed) {
        {
#line 3636
        tmp___58 = zclose(fn___0->fd1);
        }
#line 3636
        if (tmp___58 < 0) {
#line 3636
          if (fn___0->varid) {
            {
#line 3637
            tmp___57 = __errno_location();
#line 3637
            zwarn("failed to close file descriptor %d: %e", fn___0->fd1, *tmp___57);
            }
          }
        }
      }
#line 3640
      goto switch_break___1;
      case_14: /* CIL Label */ 
      case_13: /* CIL Label */ 
#line 3643
      if (fn___0->fd2 < 10) {
        {
#line 3644
        closemn(mfds, fn___0->fd2, fn___0->type);
        }
      }
      {
#line 3645
      tmp___61 = checkclobberparam(fn___0);
      }
#line 3645
      if (tmp___61) {
#line 3647
        if (fn___0->fd2 > 9) {
#line 3647
          if (fn___0->fd2 <= max_zsh_fd) {
#line 3647
            if ((int )*(fdtable + fn___0->fd2) != 0) {
#line 3647
              if ((int )*(fdtable + fn___0->fd2) != 2) {
                {
#line 3659
                fil = -1;
#line 3660
                tmp___59 = __errno_location();
#line 3660
                *tmp___59 = 9;
                }
              } else {
#line 3647
                goto _L___32;
              }
            } else
            _L___32: /* CIL Label */ 
#line 3647
            if (fn___0->fd2 == coprocin) {
              {
#line 3659
              fil = -1;
#line 3660
              tmp___59 = __errno_location();
#line 3660
              *tmp___59 = 9;
              }
            } else
#line 3647
            if (fn___0->fd2 == coprocout) {
              {
#line 3659
              fil = -1;
#line 3660
              tmp___59 = __errno_location();
#line 3660
              *tmp___59 = 9;
              }
            } else {
#line 3647
              goto _L___31;
            }
          } else {
#line 3647
            goto _L___31;
          }
        } else {
          _L___31: /* CIL Label */ 
#line 3662
          fd = fn___0->fd2;
#line 3663
          if (fd == -2) {
#line 3664
            if (fn___0->type == 14) {
#line 3664
              fd = coprocout;
            } else {
#line 3664
              fd = coprocin;
            }
          }
          {
#line 3665
          tmp___60 = dup(fd);
#line 3665
          fil = movefd(tmp___60);
          }
        }
      } else {
#line 3646
        fil = -1;
      }
#line 3667
      if (fil == -1) {
        {
#line 3670
        closemnodes(mfds);
#line 3671
        fixfds(save);
        }
#line 3672
        if (fn___0->fd2 != -2) {
          {
#line 3673
          sprintf((char */* __restrict  */)(fdstr), (char const   */* __restrict  */)"%d",
                  fn___0->fd2);
          }
        }
        {
#line 3674
        tmp___64 = __errno_location();
        }
#line 3674
        if (*tmp___64) {
          {
#line 3675
          tmp___62 = __errno_location();
          }
#line 3675
          if (fn___0->fd2 == -2) {
#line 3675
            tmp___63 = "coprocess";
          } else {
#line 3675
            tmp___63 = (char const   *)(fdstr);
          }
          {
#line 3675
          zwarn("%s: %e", tmp___63, *tmp___62);
          }
        }
        {
#line 3677
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 3677
          if (! forked) {
#line 3677
            lastval = (zlong )1;
#line 3677
            redir_err = (int )lastval;
#line 3677
            goto done;
          } else {
            {
#line 3677
            _exit(1);
            }
          }
#line 3677
          goto while_break___20;
        }
        while_break___20: /* CIL Label */ ;
        }
      }
      {
#line 3679
      addfd(forked, save, mfds, fn___0->fd1, fil, fn___0->type == 14, fn___0->varid);
      }
#line 3681
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
      {
#line 3683
      tmp___67 = checkclobberparam(fn___0);
      }
#line 3683
      if (tmp___67) {
#line 3685
        if (fn___0->type >= 0) {
#line 3685
          if (fn___0->type <= 8) {
#line 3685
            if (fn___0->type & 2) {
#line 3686
              if (! opts[33]) {
#line 3686
                if (! opts[34]) {
#line 3686
                  if (fn___0->type >= 0) {
#line 3686
                    if (fn___0->type <= 8) {
#line 3686
                      if (fn___0->type & 1) {
#line 3686
                        tmp___65 = 1345;
                      } else {
#line 3686
                        tmp___65 = 1281;
                      }
                    } else {
#line 3686
                      tmp___65 = 1281;
                    }
                  } else {
#line 3686
                    tmp___65 = 1281;
                  }
                } else {
#line 3686
                  tmp___65 = 1345;
                }
              } else {
#line 3686
                tmp___65 = 1345;
              }
              {
#line 3686
              tmp___66 = unmeta((char const   *)fn___0->name);
#line 3686
              fil = open((char const   *)tmp___66, tmp___65, 438);
              }
            } else {
              {
#line 3692
              fil = clobber_open(fn___0);
              }
            }
          } else {
            {
#line 3692
            fil = clobber_open(fn___0);
            }
          }
        } else {
          {
#line 3692
          fil = clobber_open(fn___0);
          }
        }
      } else {
#line 3684
        fil = -1;
      }
#line 3693
      if (fil != -1) {
#line 3693
        if (fn___0->type >= 4) {
#line 3693
          if (fn___0->type <= 7) {
            {
#line 3694
            tmp___68 = dup(fil);
#line 3694
            dfil = movefd(tmp___68);
            }
          } else {
#line 3696
            dfil = 0;
          }
        } else {
#line 3696
          dfil = 0;
        }
      } else {
#line 3696
        dfil = 0;
      }
#line 3697
      if (fil == -1) {
#line 3697
        goto _L___33;
      } else
#line 3697
      if (dfil == -1) {
        _L___33: /* CIL Label */ 
#line 3698
        if (fil != -1) {
          {
#line 3699
          close(fil);
          }
        }
        {
#line 3700
        closemnodes(mfds);
#line 3701
        fixfds(save);
#line 3702
        tmp___70 = __errno_location();
        }
#line 3702
        if (*tmp___70) {
          {
#line 3702
          tmp___71 = __errno_location();
          }
#line 3702
          if (*tmp___71 != 4) {
            {
#line 3703
            tmp___69 = __errno_location();
#line 3703
            zwarn("%e: %s", *tmp___69, fn___0->name);
            }
          }
        }
        {
#line 3704
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 3704
          if (! forked) {
#line 3704
            lastval = (zlong )1;
#line 3704
            redir_err = (int )lastval;
#line 3704
            goto done;
          } else {
            {
#line 3704
            _exit(1);
            }
          }
#line 3704
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
      }
      {
#line 3706
      addfd(forked, save, mfds, fn___0->fd1, fil, 1, fn___0->varid);
      }
#line 3707
      if (fn___0->type >= 4) {
#line 3707
        if (fn___0->type <= 7) {
          {
#line 3708
          addfd(forked, save, mfds, 2, dfil, 1, (char *)((void *)0));
          }
        }
      }
#line 3709
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 3712
      if (errflag) {
        {
#line 3713
        closemnodes(mfds);
#line 3714
        fixfds(save);
        }
        {
#line 3715
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 3715
          if (! forked) {
#line 3715
            lastval = (zlong )1;
#line 3715
            redir_err = (int )lastval;
#line 3715
            goto done;
          } else {
            {
#line 3715
            _exit(1);
            }
          }
#line 3715
          goto while_break___22;
        }
        while_break___22: /* CIL Label */ ;
        }
      }
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 3722
  i = 0;
  {
#line 3722
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 3722
    if (! (i < 10)) {
#line 3722
      goto while_break___23;
    }
#line 3723
    if (mfds[i]) {
#line 3723
      if ((mfds[i])->ct >= 2) {
        {
#line 3724
        closemn(mfds, i, 15);
        }
      }
    }
#line 3722
    i ++;
  }
  while_break___23: /* CIL Label */ ;
  }
#line 3726
  if (nullexec) {
#line 3732
    if (varspc) {
#line 3733
      restorelist = (LinkList )0;
#line 3733
      removelist = (LinkList )0;
#line 3734
      if (! opts[131]) {
#line 3734
        if (nullexec != 2) {
          {
#line 3735
          save_params(state, varspc, & restorelist, & removelist);
          }
        }
      }
      {
#line 3736
      addvars(state, varspc, 0);
      }
#line 3737
      if (restorelist) {
        {
#line 3738
        restore_params(restorelist, removelist);
        }
      }
    }
#line 3740
    if (errflag) {
#line 3740
      lastval = (zlong )errflag;
    } else {
#line 3740
      lastval = (zlong )cmdoutval;
    }
#line 3741
    if (nullexec == 1) {
#line 3746
      i = 0;
      {
#line 3746
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 3746
        if (! (i < 10)) {
#line 3746
          goto while_break___24;
        }
#line 3747
        if (save[i] != -2) {
          {
#line 3748
          zclose(save[i]);
          }
        }
#line 3746
        i ++;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 3749
      goto done;
    }
#line 3751
    if (opts[177]) {
      {
#line 3752
      fputc('\n', xtrerr);
#line 3753
      fflush(xtrerr);
      }
    }
  } else
#line 3755
  if (opts[52]) {
#line 3755
    if (! errflag) {
#line 3756
      q = queueing_enabled;
#line 3762
      if (is_exec) {
#line 3763
        if (how & (1 << 2)) {
#line 3763
          tmp___72 = 1;
        } else {
#line 3763
          tmp___72 = 0;
        }
#line 3763
        flags___0 = (tmp___72 | 2) | 8;
#line 3765
        if (type___0 != 8) {
#line 3766
          flags___0 |= 4;
        }
#line 3767
        if (do_exec) {
#line 3767
          goto _L___34;
        } else
#line 3767
        if (type___0 >= 9) {
#line 3767
          if (last1 == 1) {
            _L___34: /* CIL Label */ 
#line 3767
            if (! forked) {
#line 3769
              flags___0 |= 16;
            }
          }
        }
        {
#line 3770
        entersubsh(flags___0);
        }
      }
#line 3772
      if (type___0 == 11) {
#line 3774
        if (! redir) {
#line 3774
          if ((*(eparams->beg) & (wordcode )((1 << 5) - 1)) == 4U) {
            {
#line 3783
            s___4.prog = state->prog;
#line 3784
            s___4.pc = eparams->beg;
#line 3785
            s___4.strs = (state->prog)->strs;
#line 3791
            zcontext_save();
#line 3792
            redir_prog = eccopyredirs(& s___4);
#line 3793
            zcontext_restore();
            }
          } else {
#line 3795
            redir_prog = (Eprog )((void *)0);
          }
        } else {
#line 3795
          redir_prog = (Eprog )((void *)0);
        }
        {
#line 3797
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 3797
          queueing_enabled = 0;
          {
#line 3797
          while (1) {
            while_continue___26: /* CIL Label */ ;
            {
#line 3797
            while (1) {
              while_continue___27: /* CIL Label */ ;
#line 3797
              if (! (queue_front != queue_rear)) {
#line 3797
                goto while_break___27;
              }
              {
#line 3797
              queue_front = (queue_front + 1) % 128;
#line 3797
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3797
              zhandler(signal_queue[queue_front]);
#line 3797
              signal_setmask(oset);
              }
            }
            while_break___27: /* CIL Label */ ;
            }
#line 3797
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
#line 3797
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
        {
#line 3798
        tmp___73 = execfuncdef(state, redir_prog);
#line 3798
        lastval = (zlong )tmp___73;
#line 3799
        queueing_enabled = q;
        }
      } else
#line 3801
      if (type___0 >= 9) {
#line 3802
        if (last1 == 1) {
#line 3803
          do_exec = 1;
        }
        {
#line 3804
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 3804
          queueing_enabled = 0;
          {
#line 3804
          while (1) {
            while_continue___29: /* CIL Label */ ;
            {
#line 3804
            while (1) {
              while_continue___30: /* CIL Label */ ;
#line 3804
              if (! (queue_front != queue_rear)) {
#line 3804
                goto while_break___30;
              }
              {
#line 3804
              queue_front = (queue_front + 1) % 128;
#line 3804
              oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 3804
              zhandler(signal_queue[queue_front]);
#line 3804
              signal_setmask(oset___0);
              }
            }
            while_break___30: /* CIL Label */ ;
            }
#line 3804
            goto while_break___29;
          }
          while_break___29: /* CIL Label */ ;
          }
#line 3804
          goto while_break___28;
        }
        while_break___28: /* CIL Label */ ;
        }
#line 3805
        if (type___0 == 20) {
          {
#line 3810
          tmp___74 = execautofn_basic(state, do_exec);
#line 3810
          lastval = (zlong )tmp___74;
          }
        } else {
          {
#line 3812
          tmp___75 = (*(execfuncs[type___0 - 9]))(state, do_exec);
#line 3812
          lastval = (zlong )tmp___75;
          }
        }
#line 3813
        queueing_enabled = q;
      } else
#line 3814
      if (is_builtin) {
#line 3814
        goto _L___36;
      } else
#line 3814
      if (is_shfunc) {
        _L___36: /* CIL Label */ 
#line 3815
        restorelist___0 = (LinkList )0;
#line 3815
        removelist___0 = (LinkList )0;
#line 3816
        do_save = 0;
#line 3819
        if (! forked) {
#line 3820
          if (opts[131]) {
#line 3826
            if (is_shfunc) {
#line 3827
              do_save = orig_cflags & (1 << 8);
            } else
#line 3826
            if (hn->flags & ((1 << 11) | (1 << 19))) {
#line 3827
              do_save = orig_cflags & (1 << 8);
            } else {
#line 3829
              do_save = 1;
            }
          } else
#line 3835
          if (cflags & ((1 << 8) | (1 << 19))) {
#line 3836
            do_save = 1;
          } else
#line 3835
          if (! magic_assign) {
#line 3836
            do_save = 1;
          }
#line 3838
          if (do_save) {
#line 3838
            if (varspc) {
              {
#line 3839
              save_params(state, varspc, & restorelist___0, & removelist___0);
              }
            }
          }
        }
#line 3841
        if (varspc) {
#line 3845
          flags___1 = 0;
#line 3846
          if (is_shfunc) {
#line 3847
            flags___1 |= 1;
          }
#line 3848
          if (restorelist___0) {
#line 3849
            flags___1 |= 4;
          }
          {
#line 3851
          addvars(state, varspc, flags___1);
          }
#line 3852
          if (errflag) {
#line 3853
            if (restorelist___0) {
              {
#line 3854
              restore_params(restorelist___0, removelist___0);
              }
            }
            {
#line 3855
            lastval = (zlong )1;
#line 3856
            fixfds(save);
            }
#line 3857
            goto done;
          }
        }
#line 3861
        if (is_shfunc) {
          {
#line 3863
          pipecleanfilelist(filelist, 0);
#line 3864
          execshfunc((Shfunc )hn, args);
          }
        } else {
#line 3867
          assigns = (LinkList )0;
#line 3868
          postassigns = eparams->postassigns;
#line 3869
          if (forked) {
            {
#line 3870
            closem(1);
            }
          }
#line 3871
          if (postassigns) {
            {
#line 3872
            opc = state->pc;
#line 3873
            state->pc = eparams->assignspc;
#line 3874
            assigns = newlinklist();
            }
            {
#line 3875
            while (1) {
              while_continue___31: /* CIL Label */ ;
#line 3875
              tmp___83 = postassigns;
#line 3875
              postassigns --;
#line 3875
              if (! tmp___83) {
#line 3875
                goto while_break___31;
              }
              {
#line 3877
              tmp___76 = state->pc;
#line 3877
              (state->pc) ++;
#line 3877
              ac___0 = *tmp___76;
#line 3878
              tmp___77 = ecgetstr(state, 2, & htok);
#line 3878
              name = tmp___77;
              }
#line 3884
              if (htok) {
                {
#line 3885
                while (1) {
                  while_continue___32: /* CIL Label */ ;
#line 3885
                  svl.list.first = & __n0;
#line 3885
                  svl.list.last = & __n0;
#line 3885
                  svl.list.flags = 0;
#line 3885
                  __n0.next = (LinkNode )((void *)0);
#line 3885
                  __n0.prev = & svl.node;
#line 3885
                  __n0.dat = (void *)name;
#line 3885
                  goto while_break___32;
                }
                while_break___32: /* CIL Label */ ;
                }
#line 3886
                if (((ac___0 >> 5) & 1U) == 0U) {
#line 3886
                  if (((ac___0 >> 5) & 2U) >> 1 == 1U) {
                    {
#line 3900
                    ecgetstr(state, 2, & htok);
#line 3901
                    prefork(& svl, 1, (int *)((void *)0));
                    }
#line 3902
                    if (errflag) {
#line 3903
                      state->pc = opc;
#line 3904
                      goto while_break___31;
                    }
                    {
#line 3906
                    globlist(& svl, 0);
                    }
#line 3907
                    if (errflag) {
#line 3908
                      state->pc = opc;
#line 3909
                      goto while_break___31;
                    }
                    {
#line 3911
                    while (1) {
                      while_continue___33: /* CIL Label */ ;
                      {
#line 3911
                      tmp___80 = ugetnode(& svl);
#line 3911
                      data = (char *)tmp___80;
                      }
#line 3911
                      if (! data) {
#line 3911
                        goto while_break___33;
                      }
                      {
#line 3913
                      tmp___78 = zhalloc(sizeof(struct asgment ));
#line 3913
                      asg___0 = (Asgment )tmp___78;
#line 3914
                      asg___0->is_array = 0;
#line 3915
                      ptr___0 = strchr((char const   *)data, '=');
                      }
#line 3915
                      if (ptr___0) {
#line 3916
                        tmp___79 = ptr___0;
#line 3916
                        ptr___0 ++;
#line 3916
                        *tmp___79 = (char )'\000';
#line 3917
                        asg___0->name = data;
#line 3918
                        asg___0->value.scalar = ptr___0;
                      } else {
#line 3920
                        asg___0->name = data;
#line 3921
                        asg___0->value.scalar = (char *)((void *)0);
                      }
                      {
#line 3923
                      uinsertlinknode(assigns, assigns->list.last, & asg___0->node);
                      }
                    }
                    while_break___33: /* CIL Label */ ;
                    }
#line 3925
                    goto while_continue___31;
                  }
                }
                {
#line 3927
                prefork(& svl, 4, (int *)((void *)0));
                }
#line 3928
                if ((unsigned long )svl.list.first == (unsigned long )((void *)0)) {
#line 3928
                  name = (char *)"";
                } else {
#line 3928
                  name = (char *)(svl.list.first)->dat;
                }
              }
              {
#line 3931
              untokenize(name);
#line 3932
              tmp___81 = zhalloc(sizeof(struct asgment ));
#line 3932
              asg___0 = (Asgment )tmp___81;
#line 3933
              asg___0->name = name;
              }
#line 3934
              if (((ac___0 >> 5) & 1U) == 0U) {
                {
#line 3935
                tmp___82 = ecgetstr(state, 2, & htok);
#line 3935
                val = tmp___82;
#line 3936
                asg___0->is_array = 0;
                }
#line 3937
                if (((ac___0 >> 5) & 2U) >> 1 == 1U) {
#line 3939
                  asg___0->value.scalar = (char *)((void *)0);
                } else {
#line 3941
                  if (htok) {
                    {
#line 3942
                    while (1) {
                      while_continue___34: /* CIL Label */ ;
#line 3942
                      svl.list.first = & __n0;
#line 3942
                      svl.list.last = & __n0;
#line 3942
                      svl.list.flags = 0;
#line 3942
                      __n0.next = (LinkNode )((void *)0);
#line 3942
                      __n0.prev = & svl.node;
#line 3942
                      __n0.dat = (void *)val;
#line 3942
                      goto while_break___34;
                    }
                    while_break___34: /* CIL Label */ ;
                    }
                    {
#line 3943
                    prefork(& svl, 6, (int *)((void *)0));
                    }
#line 3946
                    if (errflag) {
#line 3947
                      state->pc = opc;
#line 3948
                      goto while_break___31;
                    }
#line 3954
                    if ((unsigned long )svl.list.first == (unsigned long )((void *)0)) {
#line 3954
                      val = (char *)"";
                    } else {
#line 3954
                      val = (char *)(svl.list.first)->dat;
                    }
                  }
                  {
#line 3957
                  untokenize(val);
#line 3958
                  asg___0->value.scalar = val;
                  }
                }
              } else {
                {
#line 3961
                asg___0->is_array = 1;
#line 3962
                asg___0->value.array = ecgetlist(state, (int )((ac___0 >> 5) >> 2),
                                                 2, & htok);
                }
#line 3965
                if (asg___0->value.array) {
                  {
#line 3967
                  prefork(asg___0->value.array, 2, (int *)((void *)0));
                  }
#line 3968
                  if (errflag) {
#line 3969
                    state->pc = opc;
#line 3970
                    goto while_break___31;
                  }
                  {
#line 3972
                  globlist(asg___0->value.array, 0);
                  }
#line 3973
                  if (errflag) {
#line 3974
                    state->pc = opc;
#line 3975
                    goto while_break___31;
                  }
                }
              }
              {
#line 3980
              uinsertlinknode(assigns, assigns->list.last, & asg___0->node);
              }
            }
            while_break___31: /* CIL Label */ ;
            }
#line 3982
            state->pc = opc;
          }
          {
#line 3984
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 3984
            queueing_enabled = 0;
            {
#line 3984
            while (1) {
              while_continue___36: /* CIL Label */ ;
              {
#line 3984
              while (1) {
                while_continue___37: /* CIL Label */ ;
#line 3984
                if (! (queue_front != queue_rear)) {
#line 3984
                  goto while_break___37;
                }
                {
#line 3984
                queue_front = (queue_front + 1) % 128;
#line 3984
                oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 3984
                zhandler(signal_queue[queue_front]);
#line 3984
                signal_setmask(oset___1);
                }
              }
              while_break___37: /* CIL Label */ ;
              }
#line 3984
              goto while_break___36;
            }
            while_break___36: /* CIL Label */ ;
            }
#line 3984
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
#line 3985
          if (! errflag) {
            {
#line 3986
            tmp___84 = execbuiltin(args, assigns, (Builtin )hn);
#line 3986
            lastval = (zlong )tmp___84;
            }
          }
#line 3987
          if (do_save & (1 << 8)) {
#line 3988
            errflag &= -2;
          }
          {
#line 3989
          queueing_enabled = q;
#line 3990
          fflush(stdout);
          }
#line 3991
          if (save[1] == -2) {
            {
#line 3992
            tmp___86 = ferror(stdout);
            }
#line 3992
            if (tmp___86) {
              {
#line 3993
              tmp___85 = __errno_location();
#line 3993
              zwarn("write error: %e", *tmp___85);
#line 3994
              clearerr(stdout);
              }
            }
          } else {
            {
#line 3997
            clearerr(stdout);
            }
          }
        }
#line 3999
        if (opts[138]) {
#line 3999
          if (opts[160]) {
#line 3999
            if (lastval) {
#line 3999
              if (! subsh) {
                {
#line 4004
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"zsh: exit %ld\n",
                        lastval);
#line 4006
                fflush(stderr);
                }
              }
            }
          }
        }
#line 4009
        if (do_exec) {
#line 4010
          if (subsh) {
            {
#line 4011
            _exit((int )lastval);
            }
          }
#line 4015
          if (opts[151]) {
#line 4015
            if (opts[93]) {
#line 4015
              if (! nohistsave) {
                {
#line 4016
                savehistfile((char *)((void *)0), 1, 32768);
                }
              }
            }
          }
          {
#line 4017
          exit((int )lastval);
          }
        }
#line 4019
        if (restorelist___0) {
          {
#line 4020
          restore_params(restorelist___0, removelist___0);
          }
        }
      } else {
#line 4023
        if (! subsh) {
#line 4026
          if (! forked) {
            {
#line 4027
            shlvl --;
#line 4027
            setiparam((char *)"SHLVL", shlvl);
            }
          }
#line 4031
          if (do_exec) {
#line 4031
            if (opts[151]) {
#line 4031
              if (opts[93]) {
#line 4031
                if (! nohistsave) {
                  {
#line 4032
                  savehistfile((char *)((void *)0), 1, 32768);
                  }
                }
              }
            }
          }
        }
#line 4034
        if (type___0 == 6) {
#line 4034
          goto _L___35;
        } else
#line 4034
        if (type___0 == 7) {
          _L___35: /* CIL Label */ 
#line 4035
          if (varspc) {
#line 4036
            addflags = 3;
#line 4037
            if (forked) {
#line 4038
              addflags |= 4;
            }
            {
#line 4039
            addvars(state, varspc, addflags);
            }
#line 4040
            if (errflag) {
              {
#line 4041
              _exit(1);
              }
            }
          }
          {
#line 4043
          closem(1);
          }
#line 4044
          if (coprocin != -1) {
            {
#line 4045
            zclose(coprocin);
#line 4046
            coprocin = -1;
            }
          }
#line 4048
          if (coprocout != -1) {
            {
#line 4049
            zclose(coprocout);
#line 4050
            coprocout = -1;
            }
          }
#line 4053
          if (! forked) {
            {
#line 4054
            setlimits((char *)((void *)0));
            }
          }
#line 4056
          if (how & (1 << 2)) {
            {
#line 4057
            zsfree(STTYval);
#line 4058
            STTYval = (char *)0;
            }
          }
          {
#line 4060
          execute(args, cflags, use_defpath);
          }
        } else {
          {
#line 4064
          list_pipe = 0;
#line 4065
          pipecleanfilelist(filelist, 0);
#line 4070
          (state->pc) ++;
#line 4071
          execlist(state, 0, 1);
          }
        }
      }
    }
  }
  err: 
#line 4077
  if (forked) {
#line 4102
    i = 0;
    {
#line 4102
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 4102
      if (! (i < 10)) {
#line 4102
        goto while_break___38;
      }
#line 4103
      if ((int )*(fdtable + i) != 0) {
        {
#line 4104
        close(i);
        }
      }
#line 4102
      i ++;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 4105
    closem(0);
    }
#line 4106
    if (thisjob != -1) {
      {
#line 4107
      waitjobs();
      }
    }
    {
#line 4108
    _exit((int )lastval);
    }
  }
  {
#line 4110
  fixfds(save);
  }
  done: 
#line 4113
  if (opts[131]) {
#line 4113
    if (cflags & ((1 << 11) | (1 << 9))) {
#line 4113
      if (! (orig_cflags & (1 << 8))) {
#line 4122
        forked = (int )((long )forked | zsh_subshell);
        fatal: 
#line 4124
        if (redir_err) {
#line 4124
          goto _L___37;
        } else
#line 4124
        if (errflag) {
          _L___37: /* CIL Label */ 
#line 4125
          if (! opts[93]) {
#line 4126
            if (forked) {
              {
#line 4127
              _exit(1);
              }
            } else {
              {
#line 4129
              exit(1);
              }
            }
          }
#line 4131
          errflag |= 1;
        }
      }
    }
  }
#line 4134
  if (newxtrerr) {
    {
#line 4135
    fil = fileno(newxtrerr);
#line 4136
    fclose(newxtrerr);
#line 4137
    xtrerr = oxtrerr;
#line 4138
    zclose(fil);
    }
  }
  {
#line 4141
  zsfree(STTYval);
#line 4142
  STTYval = (char *)0;
  }
#line 4143
  if (oautocont >= 0) {
#line 4144
    opts[8] = (char )oautocont;
  }
#line 4145
  return;
}
}
#line 4150 "/tmp/zsh-5.4.2/Src/exec.c"
static void save_params(Estate state , Wordcode pc , LinkList *restore_p , LinkList *remove_p ) 
{ 
  Param pm ;
  char *s ;
  wordcode ac ;
  Param tpm ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  HashNode tmp___3 ;
  wordcode tmp___4 ;

  {
  {
#line 4157
  *restore_p = newlinklist();
#line 4158
  *remove_p = newlinklist();
  }
  {
#line 4160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4160
    ac = *pc;
#line 4160
    if (! ((ac & (wordcode )((1 << 5) - 1)) == 5U)) {
#line 4160
      goto while_break;
    }
    {
#line 4161
    s = ecrawstr(state->prog, pc + 1, (int *)((void *)0));
#line 4162
    tmp___3 = (*(paramtab->getnode))(paramtab, (char const   *)s);
#line 4162
    pm = (Param )tmp___3;
    }
#line 4162
    if (pm) {
#line 4164
      if (pm->env) {
        {
#line 4165
        delenv(pm);
        }
      }
#line 4166
      if (! (pm->node.flags & (1 << 22))) {
        {
#line 4177
        tmp = zshcalloc(sizeof(*tpm));
#line 4177
        tpm = (Param )tmp;
#line 4178
        tpm->node.nam = ztrdup((char const   *)pm->node.nam);
#line 4179
        copyparam(tpm, pm, 0);
#line 4180
        pm = tpm;
        }
      } else
#line 4181
      if (! (pm->node.flags & (1 << 10))) {
#line 4181
        if (! opts[154]) {
          {
#line 4188
          tmp___0 = hcalloc(sizeof(*tpm));
#line 4188
          tpm = (Param )tmp___0;
#line 4189
          tpm->node.nam = pm->node.nam;
#line 4190
          copyparam(tpm, pm, 1);
#line 4191
          pm = tpm;
          }
        } else
#line 4181
        if (! (pm->node.flags & (1 << 24))) {
          {
#line 4188
          tmp___0 = hcalloc(sizeof(*tpm));
#line 4188
          tpm = (Param )tmp___0;
#line 4189
          tpm->node.nam = pm->node.nam;
#line 4190
          copyparam(tpm, pm, 1);
#line 4191
          pm = tpm;
          }
        }
      }
      {
#line 4193
      tmp___1 = dupstring((char const   *)s);
#line 4193
      insertlinknode(*remove_p, (*remove_p)->list.last, (void *)tmp___1);
#line 4194
      insertlinknode(*restore_p, (*restore_p)->list.last, (void *)pm);
      }
    } else {
      {
#line 4196
      tmp___2 = dupstring((char const   *)s);
#line 4196
      insertlinknode(*remove_p, (*remove_p)->list.last, (void *)tmp___2);
      }
    }
#line 4198
    if (((ac >> 5) & 1U) == 0U) {
#line 4198
      tmp___4 = (wordcode )3;
    } else {
#line 4198
      tmp___4 = ((ac >> 5) >> 2) + 2U;
    }
#line 4198
    pc += tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
#line 4201
  return;
}
}
#line 4206 "/tmp/zsh-5.4.2/Src/exec.c"
static void restore_params(LinkList restorelist , LinkList removelist ) 
{ 
  Param pm ;
  char *s ;
  HashNode tmp ;
  void *tmp___0 ;
  Param tpm ;
  HashNode tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 4213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4213
    tmp___0 = ugetnode(removelist);
#line 4213
    s = (char *)tmp___0;
    }
#line 4213
    if (! s) {
#line 4213
      goto while_break;
    }
    {
#line 4214
    tmp = (*(paramtab->getnode))(paramtab, (char const   *)s);
#line 4214
    pm = (Param )tmp;
    }
#line 4214
    if (pm) {
#line 4214
      if (! (pm->node.flags & (1 << 22))) {
        {
#line 4216
        pm->node.flags &= ~ (1 << 10);
#line 4217
        unsetparam_pm(pm, 0, 0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4221
  if (restorelist) {
    {
#line 4223
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 4223
      tmp___2 = ugetnode(restorelist);
#line 4223
      pm = (Param )tmp___2;
      }
#line 4223
      if (! pm) {
#line 4223
        goto while_break___0;
      }
#line 4224
      if (pm->node.flags & (1 << 22)) {
        {
#line 4225
        tmp___1 = (*(paramtab->getnode))(paramtab, (char const   *)pm->node.nam);
#line 4225
        tpm = (Param )tmp___1;
        }
#line 4230
        if (! pm->env) {
#line 4230
          if (tpm->env) {
            {
#line 4231
            delenv(tpm);
            }
          }
        }
#line 4232
        tpm->node.flags = pm->node.flags;
        {
#line 4234
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 4234
          goto case_0;
        }
#line 4237
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 4237
          goto case_exp;
        }
#line 4241
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 4241
          goto case_exp___0;
        }
#line 4241
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 4241
          goto case_exp___0;
        }
#line 4244
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 4244
          goto case_1;
        }
#line 4247
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
#line 4247
          goto case_exp___2;
        }
#line 4233
        goto switch_break;
        case_0: /* CIL Label */ 
        {
#line 4235
        (*((tpm->gsu.s)->setfn))(tpm, pm->u.str);
        }
#line 4236
        goto switch_break;
        case_exp: /* CIL Label */ 
        {
#line 4238
        (*((tpm->gsu.i)->setfn))(tpm, pm->u.val);
        }
#line 4239
        goto switch_break;
        case_exp___0: /* CIL Label */ 
        case_exp___1: /* CIL Label */ 
        {
#line 4242
        (*((tpm->gsu.f)->setfn))(tpm, pm->u.dval);
        }
#line 4243
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 4245
        (*((tpm->gsu.a)->setfn))(tpm, pm->u.arr);
        }
#line 4246
        goto switch_break;
        case_exp___2: /* CIL Label */ 
        {
#line 4248
        (*((tpm->gsu.h)->setfn))(tpm, pm->u.hash);
        }
#line 4249
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 4251
        pm = tpm;
      } else {
        {
#line 4253
        (*(paramtab->addnode))(paramtab, pm->node.nam, (void *)pm);
        }
      }
#line 4255
      if (pm->node.flags & (1 << 12)) {
        {
#line 4255
        s = getsparam(pm->node.nam);
        }
#line 4255
        if (s) {
          {
#line 4256
          addenv(pm, s);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 4259
  return;
}
}
#line 4264 "/tmp/zsh-5.4.2/Src/exec.c"
static void fixfds(int *save ) 
{ 
  int old_errno ;
  int *tmp ;
  int i ;
  int *tmp___0 ;

  {
  {
#line 4267
  tmp = __errno_location();
#line 4267
  old_errno = *tmp;
#line 4270
  i = 0;
  }
  {
#line 4270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4270
    if (! (i != 10)) {
#line 4270
      goto while_break;
    }
#line 4271
    if (*(save + i) != -2) {
      {
#line 4272
      redup(*(save + i), i);
      }
    }
#line 4270
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4273
  tmp___0 = __errno_location();
#line 4273
  *tmp___0 = old_errno;
  }
#line 4274
  return;
}
}
#line 4284 "/tmp/zsh-5.4.2/Src/exec.c"
void closem(int how ) 
{ 
  int i ;

  {
#line 4289
  i = 10;
  {
#line 4289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4289
    if (! (i <= max_zsh_fd)) {
#line 4289
      goto while_break;
    }
#line 4290
    if ((int )*(fdtable + i) != 0) {
#line 4290
      if (how == 0) {
#line 4290
        goto _L;
      } else
#line 4290
      if (((int )*(fdtable + i) & 15) == how) {
        _L: /* CIL Label */ 
#line 4292
        if (i == SHTTY) {
#line 4293
          SHTTY = -1;
        }
        {
#line 4294
        zclose(i);
        }
      }
    }
#line 4289
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4296
  return;
}
}
#line 4301 "/tmp/zsh-5.4.2/Src/exec.c"
char *gethere(char **strp , int typ ) 
{ 
  char *buf___7 ;
  int bsiz ;
  int qt ;
  int strip ;
  char *s ;
  char *t ;
  char *bptr ;
  char c ;
  char *str ;
  void *tmp ;
  int tmp___0 ;
  char *newbuf ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int ef ;

  {
#line 4305
  qt = 0;
#line 4305
  strip = 0;
#line 4307
  str = *strp;
#line 4309
  s = str;
  {
#line 4309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4309
    if (! *s) {
#line 4309
      goto while_break;
    }
#line 4310
    if ((int )typtab[(unsigned char )*s] & (1 << 14)) {
#line 4311
      qt = 1;
#line 4312
      goto while_break;
    }
#line 4309
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4314
  str = quotesubst(str);
#line 4315
  untokenize(str);
  }
#line 4316
  if (typ == 11) {
#line 4317
    strip = 1;
    {
#line 4318
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4318
      if (! ((int )*str == 9)) {
#line 4318
        goto while_break___0;
      }
#line 4319
      str ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 4321
  *strp = str;
#line 4322
  bsiz = 256;
#line 4322
  tmp = zalloc((size_t )bsiz);
#line 4322
  buf___7 = (char *)tmp;
#line 4322
  bptr = buf___7;
  }
  {
#line 4323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4324
    t = bptr;
    {
#line 4326
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 4326
      tmp___0 = (*hgetc)();
#line 4326
      c = (char )tmp___0;
      }
#line 4326
      if ((int )c == 9) {
#line 4326
        if (! strip) {
#line 4326
          goto while_break___2;
        }
      } else {
#line 4326
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 4328
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 4329
      if ((unsigned long )bptr == (unsigned long )(buf___7 + bsiz)) {
        {
#line 4330
        tmp___1 = realloc((void *)buf___7, (size_t )(2 * bsiz));
#line 4330
        newbuf = (char *)tmp___1;
        }
#line 4331
        if (! newbuf) {
          {
#line 4333
          zfree((void *)buf___7, bsiz);
          }
#line 4334
          return ((char *)((void *)0));
        }
#line 4336
        buf___7 = newbuf;
#line 4337
        t = (buf___7 + bsiz) - (bptr - t);
#line 4338
        bptr = buf___7 + bsiz;
#line 4339
        bsiz *= 2;
      }
#line 4341
      if (lexstop) {
#line 4342
        goto while_break___3;
      } else
#line 4341
      if ((int )c == 10) {
#line 4342
        goto while_break___3;
      }
      {
#line 4343
      tmp___2 = bptr;
#line 4343
      bptr ++;
#line 4343
      *tmp___2 = c;
#line 4344
      tmp___3 = (*hgetc)();
#line 4344
      c = (char )tmp___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 4346
    *bptr = (char )'\000';
#line 4347
    tmp___4 = strcmp((char const   *)t, (char const   *)str);
    }
#line 4347
    if (! tmp___4) {
#line 4348
      goto while_break___1;
    }
#line 4349
    if (lexstop) {
#line 4350
      t = bptr;
#line 4351
      goto while_break___1;
    }
#line 4353
    tmp___5 = bptr;
#line 4353
    bptr ++;
#line 4353
    *tmp___5 = (char )'\n';
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 4355
  *t = (char )'\000';
#line 4356
  s = buf___7;
#line 4357
  buf___7 = dupstring((char const   *)buf___7);
#line 4358
  zfree((void *)s, bsiz);
  }
#line 4359
  if (! qt) {
    {
#line 4360
    ef = errflag;
#line 4362
    parsestr(& buf___7);
    }
#line 4364
    if (! (errflag & 1)) {
#line 4366
      errflag = ef | (errflag & 2);
    }
  }
#line 4369
  return (buf___7);
}
}
#line 4375 "/tmp/zsh-5.4.2/Src/exec.c"
static int getherestr(struct redir *fn___0 ) 
{ 
  char *s ;
  char *t ;
  int fd ;
  int len ;
  int tmp ;

  {
  {
#line 4381
  t = fn___0->name;
#line 4382
  singsub(& t);
#line 4383
  untokenize(t);
#line 4384
  unmetafy(t, & len);
  }
#line 4392
  if (! (fn___0->flags & 1)) {
#line 4393
    tmp = len;
#line 4393
    len ++;
#line 4393
    *(t + tmp) = (char )'\n';
  }
  {
#line 4394
  fd = gettempfile((char const   *)((void *)0), 1, & s);
  }
#line 4394
  if (fd < 0) {
#line 4395
    return (-1);
  }
  {
#line 4396
  write_loop(fd, (char const   *)t, (size_t )len);
#line 4397
  close(fd);
#line 4398
  fd = open((char const   *)s, 256);
#line 4399
  unlink((char const   *)s);
  }
#line 4400
  return (fd);
}
}
#line 4409 "/tmp/zsh-5.4.2/Src/exec.c"
static char *simple_redir_name(Eprog prog , int redir_type ) 
{ 
  Wordcode pc ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 4414
  pc = prog->prog;
#line 4415
  if ((unsigned long )prog != (unsigned long )(& dummy_eprog)) {
#line 4415
    if ((*(pc + 0) & (wordcode )((1 << 5) - 1)) == 1U) {
#line 4415
      if ((*(pc + 0) >> 5) & (unsigned int )(1 << 4)) {
#line 4415
        if ((*(pc + 1) & (wordcode )((1 << 5) - 1)) == 2U) {
#line 4415
          if (! ((*(pc + 1) >> 5) & 28U)) {
#line 4415
            if (((*(pc + 1) >> 5) & 3U) == 0U) {
#line 4415
              if ((*(pc + 2) & (wordcode )((1 << 5) - 1)) == 3U) {
#line 4415
                if (((*(pc + 2) >> 5) & 1U) == 0U) {
#line 4415
                  if ((*(pc + 3) & (wordcode )((1 << 5) - 1)) == 4U) {
#line 4415
                    if ((int )((*(pc + 3) >> 5) & 31U) == redir_type) {
#line 4415
                      if (! ((int )((*(pc + 3) >> 5) & 32U))) {
#line 4415
                        if (! *(pc + 4)) {
#line 4415
                          if ((*(pc + 6) & (wordcode )((1 << 5) - 1)) == 6U) {
#line 4415
                            if (! (*(pc + 6) >> 5)) {
                              {
#line 4424
                              tmp = ecrawstr(prog, pc + 5, (int *)((void *)0));
#line 4424
                              tmp___0 = dupstring((char const   *)tmp);
                              }
#line 4424
                              return (tmp___0);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 4427
  return ((char *)((void *)0));
}
}
#line 4433 "/tmp/zsh-5.4.2/Src/exec.c"
LinkList getoutput(char *cmd , int qt ) 
{ 
  Eprog prog ;
  int pipes[2] ;
  pid_t pid ;
  char *s ;
  int stream ;
  int *tmp ;
  LinkList tmp___0 ;
  char *tmp___1 ;
  LinkList tmp___2 ;
  int tmp___3 ;
  LinkList retval ;
  __pid_t tmp___4 ;

  {
  {
#line 4441
  prog = parse_string(cmd, 0);
  }
#line 4441
  if (! prog) {
#line 4442
    return ((LinkList )((void *)0));
  }
  {
#line 4444
  s = simple_redir_name(prog, 9);
  }
#line 4444
  if (s) {
    {
#line 4448
    singsub(& s);
    }
#line 4449
    if (errflag) {
#line 4450
      return ((LinkList )((void *)0));
    }
    {
#line 4451
    untokenize(s);
#line 4452
    tmp___1 = unmeta((char const   *)s);
#line 4452
    stream = open((char const   *)tmp___1, 256);
    }
#line 4452
    if (stream == -1) {
      {
#line 4453
      tmp = __errno_location();
#line 4453
      zwarn("%e: %s", *tmp, s);
#line 4454
      tmp___0 = newlinklist();
      }
#line 4454
      return (tmp___0);
    }
    {
#line 4456
    tmp___2 = readoutput(stream, qt);
    }
#line 4456
    return (tmp___2);
  }
  {
#line 4458
  tmp___3 = mpipe(pipes);
  }
#line 4458
  if (tmp___3 < 0) {
#line 4459
    errflag |= 1;
#line 4460
    cmdoutpid = 0;
#line 4461
    return ((LinkList )((void *)0));
  }
  {
#line 4463
  signal_block(sigchld_mask);
#line 4464
  cmdoutval = 0;
#line 4465
  pid = zfork((struct timeval *)((void *)0));
#line 4465
  cmdoutpid = pid;
  }
#line 4465
  if (cmdoutpid == -1) {
    {
#line 4467
    zclose(pipes[0]);
#line 4468
    zclose(pipes[1]);
#line 4469
    errflag |= 1;
#line 4470
    cmdoutpid = 0;
#line 4471
    signal_unblock(sigchld_mask);
    }
#line 4472
    return ((LinkList )((void *)0));
  } else
#line 4473
  if (pid) {
    {
#line 4476
    zclose(pipes[1]);
#line 4477
    retval = readoutput(pipes[0], qt);
#line 4478
    *(fdtable + pipes[0]) = (unsigned char)0;
#line 4479
    waitforpid(pid, 0);
#line 4480
    lastval = (zlong )cmdoutval;
    }
#line 4481
    return (retval);
  }
  {
#line 4484
  signal_unblock(sigchld_mask);
#line 4485
  zclose(pipes[0]);
#line 4486
  redup(pipes[1], 1);
#line 4487
  entersubsh(34);
#line 4488
  cmdpush(24);
#line 4489
  execode(prog, 0, 1, (char *)"cmdsubst");
#line 4490
  cmdpop();
#line 4491
  close(1);
#line 4492
  _exit((int )lastval);
#line 4493
  zerr("exit returned in child!!");
#line 4494
  tmp___4 = getpid();
#line 4494
  kill(tmp___4, 9);
  }
#line 4495
  return ((LinkList )((void *)0));
}
}
#line 4501 "/tmp/zsh-5.4.2/Src/exec.c"
LinkList readoutput(int in , int qt ) 
{ 
  LinkList ret ;
  char *buf___7 ;
  char *ptr___0 ;
  int bsiz ;
  int c ;
  int cnt ;
  FILE *fin ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *pp ;
  void *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char **words ;
  char **tmp___6 ;
  char **tmp___7 ;

  {
  {
#line 4506
  cnt = 0;
#line 4509
  fin = fdopen(in, "r");
#line 4510
  ret = newlinklist();
#line 4511
  bsiz = 64;
#line 4511
  tmp = hcalloc((size_t )bsiz);
#line 4511
  buf___7 = (char *)tmp;
#line 4511
  ptr___0 = buf___7;
  }
  {
#line 4512
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4512
    c = fgetc(fin);
    }
#line 4512
    if (! (c != -1)) {
      {
#line 4512
      tmp___4 = __errno_location();
      }
#line 4512
      if (! (*tmp___4 == 4)) {
#line 4512
        goto while_break;
      }
    }
#line 4513
    if (c == -1) {
      {
#line 4514
      tmp___0 = __errno_location();
#line 4514
      *tmp___0 = 0;
#line 4515
      clearerr(fin);
      }
#line 4516
      goto while_continue;
    }
#line 4518
    if ((int )typtab[(unsigned char )c] & (1 << 12)) {
#line 4519
      tmp___1 = ptr___0;
#line 4519
      ptr___0 ++;
#line 4519
      *tmp___1 = (char)-125;
#line 4520
      c ^= 32;
#line 4521
      cnt ++;
    }
#line 4523
    cnt ++;
#line 4523
    if (cnt >= bsiz) {
      {
#line 4524
      bsiz *= 2;
#line 4524
      tmp___2 = hcalloc((size_t )bsiz);
#line 4524
      pp = (char *)tmp___2;
#line 4526
      memcpy((void */* __restrict  */)pp, (void const   */* __restrict  */)buf___7,
             (size_t )(cnt - 1));
#line 4527
      buf___7 = pp;
#line 4527
      ptr___0 = (buf___7 + cnt) - 1;
      }
    }
#line 4529
    tmp___3 = ptr___0;
#line 4529
    ptr___0 ++;
#line 4529
    *tmp___3 = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4531
  fclose(fin);
  }
  {
#line 4532
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4532
    if (cnt) {
#line 4532
      if (! ((int )*(ptr___0 + -1) == 10)) {
#line 4532
        goto while_break___0;
      }
    } else {
#line 4532
      goto while_break___0;
    }
#line 4533
    ptr___0 --;
#line 4533
    cnt --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4534
  *ptr___0 = (char )'\000';
#line 4535
  if (qt) {
#line 4536
    if (! cnt) {
#line 4537
      tmp___5 = ptr___0;
#line 4537
      ptr___0 ++;
#line 4537
      *tmp___5 = (char)-95;
#line 4538
      *ptr___0 = (char )'\000';
    }
    {
#line 4540
    insertlinknode(ret, ret->list.last, (void *)buf___7);
    }
  } else {
    {
#line 4542
    tmp___6 = spacesplit(buf___7, 0, 1, 0);
#line 4542
    words = tmp___6;
    }
    {
#line 4544
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4544
      if (! *words) {
#line 4544
        goto while_break___1;
      }
#line 4545
      if (opts[66]) {
        {
#line 4546
        shtokenize(*words);
        }
      }
      {
#line 4547
      tmp___7 = words;
#line 4547
      words ++;
#line 4547
      insertlinknode(ret, ret->list.last, (void *)*tmp___7);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 4550
  return (ret);
}
}
#line 4554 "/tmp/zsh-5.4.2/Src/exec.c"
static Eprog parsecmd(char *cmd , char **eptr ) 
{ 
  char *str ;
  Eprog prog ;
  char *errstr ;
  char *tmp ;

  {
#line 4560
  str = cmd + 2;
  {
#line 4560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4560
    if (*str) {
#line 4560
      if (! ((int )*str != -118)) {
#line 4560
        goto while_break;
      }
    } else {
#line 4560
      goto while_break;
    }
#line 4560
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4561
  if (! *str) {
    {
#line 4568
    tmp = dupstrpfx((char const   *)cmd, 2);
#line 4568
    errstr = tmp;
#line 4569
    untokenize(errstr);
#line 4570
    zerr("unterminated `%s...)\'", errstr);
    }
#line 4571
    return ((Eprog )((void *)0));
  } else
#line 4561
  if ((int )*(cmd + 1) != -120) {
    {
#line 4568
    tmp = dupstrpfx((char const   *)cmd, 2);
#line 4568
    errstr = tmp;
#line 4569
    untokenize(errstr);
#line 4570
    zerr("unterminated `%s...)\'", errstr);
    }
#line 4571
    return ((Eprog )((void *)0));
  }
#line 4573
  *str = (char )'\000';
#line 4574
  if (eptr) {
#line 4575
    *eptr = str + 1;
  }
  {
#line 4576
  prog = parse_string(cmd + 2, 0);
  }
#line 4576
  if (! prog) {
    {
#line 4577
    zerr("parse error in process substitution");
    }
#line 4578
    return ((Eprog )((void *)0));
  }
#line 4580
  return (prog);
}
}
#line 4586 "/tmp/zsh-5.4.2/Src/exec.c"
char *getoutputfile(char *cmd , char **eptr ) 
{ 
  pid_t pid ;
  char *nam ;
  Eprog prog ;
  int fd ;
  char *s ;
  int *tmp ;
  char *suffix ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int len ;
  int os ;
  __pid_t tmp___4 ;

  {
#line 4595
  if (thisjob == -1) {
    {
#line 4596
    zerr("process substitution %s cannot be used here", cmd);
    }
#line 4597
    return ((char *)((void *)0));
  }
  {
#line 4599
  prog = parsecmd(cmd, eptr);
  }
#line 4599
  if (! prog) {
#line 4600
    return ((char *)((void *)0));
  }
  {
#line 4601
  nam = gettempname((char const   *)((void *)0), 1);
  }
#line 4601
  if (! nam) {
#line 4602
    return ((char *)((void *)0));
  }
  {
#line 4604
  s = simple_redir_name(prog, 12);
  }
#line 4604
  if (s) {
    {
#line 4610
    singsub(& s);
    }
#line 4611
    if (errflag) {
#line 4612
      s = (char *)((void *)0);
    } else {
      {
#line 4614
      untokenize(s);
      }
    }
  }
#line 4617
  if (! s) {
    {
#line 4618
    signal_block(sigchld_mask);
    }
  }
  {
#line 4620
  fd = open((char const   *)nam, 449, 384);
  }
#line 4620
  if (fd < 0) {
    {
#line 4621
    tmp = __errno_location();
#line 4621
    zerr("process substitution failed: %e", *tmp);
#line 4622
    free((void *)nam);
    }
#line 4623
    if (! s) {
      {
#line 4624
      signal_unblock(sigchld_mask);
      }
    }
#line 4625
    return ((char *)((void *)0));
  } else {
    {
#line 4627
    tmp___0 = getsparam((char *)"TMPSUFFIX");
#line 4627
    suffix = tmp___0;
    }
#line 4628
    if (suffix) {
#line 4628
      if (*suffix) {
        {
#line 4628
        tmp___3 = strstr((char const   *)suffix, "/");
        }
#line 4628
        if (! tmp___3) {
          {
#line 4629
          tmp___1 = unmeta((char const   *)suffix);
#line 4629
          suffix = dyncat((char const   *)nam, (char const   *)tmp___1);
#line 4630
          tmp___2 = link((char const   *)nam, (char const   *)suffix);
          }
#line 4630
          if (tmp___2 == 0) {
            {
#line 4631
            addfilelist((char const   *)nam, 0);
#line 4632
            nam = suffix;
            }
          }
        }
      }
    }
  }
  {
#line 4636
  addfilelist((char const   *)nam, 0);
  }
#line 4638
  if (s) {
    {
#line 4641
    unmetafy(s, & len);
#line 4642
    write_loop(fd, (char const   *)s, (size_t )len);
#line 4643
    close(fd);
    }
#line 4644
    return (nam);
  }
  {
#line 4647
  pid = zfork((struct timeval *)((void *)0));
#line 4647
  cmdoutpid = pid;
  }
#line 4647
  if (cmdoutpid == -1) {
    {
#line 4649
    signal_unblock(sigchld_mask);
    }
#line 4650
    return (nam);
  } else
#line 4651
  if (pid) {
    {
#line 4654
    close(fd);
#line 4655
    os = (jobtab + thisjob)->stat;
#line 4656
    waitforpid(pid, 0);
#line 4657
    cmdoutval = 0;
#line 4658
    (jobtab + thisjob)->stat = os;
    }
#line 4659
    return (nam);
  }
  {
#line 4663
  redup(fd, 1);
#line 4664
  entersubsh(34);
#line 4665
  cmdpush(24);
#line 4666
  execode(prog, 0, 1, (char *)"equalsubst");
#line 4667
  cmdpop();
#line 4668
  close(1);
#line 4669
  _exit((int )lastval);
#line 4670
  zerr("exit returned in child!!");
#line 4671
  tmp___4 = getpid();
#line 4671
  kill(tmp___4, 9);
  }
#line 4672
  return ((char *)((void *)0));
}
}
#line 4702 "/tmp/zsh-5.4.2/Src/exec.c"
char *getproc(char *cmd , char **eptr ) 
{ 
  Eprog prog ;
  int out ;
  char *pnam ;
  pid_t pid ;
  struct timeval bgtime ;
  int pipes[2] ;
  int fd ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 4710
  out = (int )*cmd == -108;
#line 4745
  if (thisjob == -1) {
    {
#line 4746
    zerr("process substitution %s cannot be used here", cmd);
    }
#line 4747
    return ((char *)((void *)0));
  }
  {
#line 4749
  tmp = strlen("/proc/self/fd");
#line 4749
  tmp___0 = hcalloc(tmp + 6UL);
#line 4749
  pnam = (char *)tmp___0;
#line 4750
  prog = parsecmd(cmd, eptr);
  }
#line 4750
  if (! prog) {
#line 4751
    return ((char *)((void *)0));
  }
  {
#line 4752
  tmp___1 = mpipe(pipes);
  }
#line 4752
  if (tmp___1 < 0) {
#line 4753
    return ((char *)((void *)0));
  }
  {
#line 4754
  pid = zfork(& bgtime);
  }
#line 4754
  if (pid) {
    {
#line 4755
    sprintf((char */* __restrict  */)pnam, (char const   */* __restrict  */)"%s/%d",
            "/proc/self/fd", pipes[! out]);
#line 4756
    zclose(pipes[out]);
    }
#line 4757
    if (pid == -1) {
      {
#line 4759
      zclose(pipes[! out]);
      }
#line 4760
      return ((char *)((void *)0));
    }
    {
#line 4762
    fd = pipes[! out];
#line 4763
    *(fdtable + fd) = (unsigned char)7;
#line 4764
    addfilelist((char const   *)((void *)0), fd);
    }
#line 4765
    if (! out) {
      {
#line 4767
      addproc(pid, (char *)((void *)0), 1, & bgtime);
      }
    }
#line 4769
    return (pnam);
  }
  {
#line 4771
  entersubsh(3);
#line 4772
  redup(pipes[out], out);
#line 4773
  closem(0);
#line 4776
  cmdpush(24);
  }
#line 4777
  if (out) {
#line 4777
    tmp___2 = "outsubst";
  } else {
#line 4777
    tmp___2 = "insubst";
  }
  {
#line 4777
  execode(prog, 0, 1, (char *)tmp___2);
#line 4778
  cmdpop();
#line 4779
  zclose(out);
#line 4780
  _exit((int )lastval);
  }
#line 4781
  return ((char *)((void *)0));
}
}
#line 4794 "/tmp/zsh-5.4.2/Src/exec.c"
static int getpipe(char *cmd , int nullexec ) 
{ 
  Eprog prog ;
  int pipes[2] ;
  int out ;
  pid_t pid ;
  struct timeval bgtime ;
  char *ends ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 4798
  out = (int )*cmd == -108;
#line 4803
  prog = parsecmd(cmd, & ends);
  }
#line 4803
  if (! prog) {
#line 4804
    return (-1);
  }
#line 4805
  if (*ends) {
    {
#line 4806
    zerr("invalid syntax for process substitution in redirection");
    }
#line 4807
    return (-1);
  }
  {
#line 4809
  tmp = mpipe(pipes);
  }
#line 4809
  if (tmp < 0) {
#line 4810
    return (-1);
  }
  {
#line 4811
  pid = zfork(& bgtime);
  }
#line 4811
  if (pid) {
    {
#line 4812
    zclose(pipes[out]);
    }
#line 4813
    if (pid == -1) {
      {
#line 4814
      zclose(pipes[! out]);
      }
#line 4815
      return (-1);
    }
#line 4817
    if (! nullexec) {
      {
#line 4818
      addproc(pid, (char *)((void *)0), 1, & bgtime);
      }
    }
#line 4819
    return (pipes[! out]);
  }
  {
#line 4821
  entersubsh(2);
#line 4822
  redup(pipes[out], out);
#line 4823
  closem(0);
#line 4824
  cmdpush(24);
  }
#line 4825
  if (out) {
#line 4825
    tmp___0 = "outsubst";
  } else {
#line 4825
    tmp___0 = "insubst";
  }
  {
#line 4825
  execode(prog, 0, 1, (char *)tmp___0);
#line 4826
  cmdpop();
#line 4827
  _exit((int )lastval);
  }
#line 4828
  return (0);
}
}
#line 4834 "/tmp/zsh-5.4.2/Src/exec.c"
static int mpipe(int *pp ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 4837
  tmp___0 = pipe((int *)pp);
  }
#line 4837
  if (tmp___0 < 0) {
    {
#line 4838
    tmp = __errno_location();
#line 4838
    zerr("pipe failed: %e", *tmp);
    }
#line 4839
    return (-1);
  }
  {
#line 4841
  *(pp + 0) = movefd(*(pp + 0));
#line 4842
  *(pp + 1) = movefd(*(pp + 1));
  }
#line 4843
  return (0);
}
}
#line 4858 "/tmp/zsh-5.4.2/Src/exec.c"
static void spawnpipes(LinkList l , int nullexec ) 
{ 
  LinkNode n ;
  Redir f ;
  char *str ;
  int tmp ;

  {
#line 4865
  n = l->list.first;
  {
#line 4866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4866
    if (! n) {
#line 4866
      goto while_break;
    }
#line 4867
    f = (Redir )n->dat;
#line 4868
    if (f->type == 17) {
#line 4868
      goto _L;
    } else
#line 4868
    if (f->type == 16) {
      _L: /* CIL Label */ 
#line 4869
      str = f->name;
#line 4870
      if (nullexec) {
#line 4870
        tmp = 1;
      } else
#line 4870
      if (f->varid) {
#line 4870
        tmp = 1;
      } else {
#line 4870
        tmp = 0;
      }
      {
#line 4870
      f->fd2 = getpipe(str, tmp);
      }
    }
#line 4866
    n = n->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 4873
  return;
}
}
#line 4878 "/tmp/zsh-5.4.2/Src/exec.c"
static int execcond(Estate state , int do_exec  __attribute__((__unused__)) ) 
{ 
  int stat___0 ;

  {
#line 4883
  (state->pc) --;
#line 4884
  if (opts[177]) {
    {
#line 4885
    printprompt4();
#line 4886
    fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)"[[");
#line 4887
    tracingcond ++;
    }
  }
  {
#line 4889
  cmdpush(10);
#line 4890
  stat___0 = evalcond(state, (char *)((void *)0));
  }
#line 4895
  if (stat___0 == 2) {
#line 4896
    errflag |= 1;
  }
  {
#line 4897
  cmdpop();
  }
#line 4898
  if (opts[177]) {
    {
#line 4899
    fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)" ]]\n");
#line 4900
    fflush(xtrerr);
#line 4901
    tracingcond --;
    }
  }
#line 4903
  return (stat___0);
}
}
#line 4909 "/tmp/zsh-5.4.2/Src/exec.c"
static int execarith(Estate state , int do_exec  __attribute__((__unused__)) ) 
{ 
  char *e ;
  mnumber val ;
  int htok ;
  int tmp ;

  {
#line 4913
  val = zero_mnumber;
#line 4914
  htok = 0;
#line 4916
  if (opts[177]) {
    {
#line 4917
    printprompt4();
#line 4918
    fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)"((");
    }
  }
  {
#line 4920
  cmdpush(9);
#line 4921
  e = ecgetstr(state, 2, & htok);
  }
#line 4922
  if (htok) {
    {
#line 4923
    singsub(& e);
    }
  }
#line 4924
  if (opts[177]) {
    {
#line 4925
    fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)" %s",
            e);
    }
  }
  {
#line 4927
  val = matheval(e);
#line 4929
  cmdpop();
  }
#line 4931
  if (opts[177]) {
    {
#line 4932
    fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)" ))\n");
#line 4933
    fflush(xtrerr);
    }
  }
#line 4935
  if (errflag) {
#line 4936
    errflag &= -2;
#line 4937
    return (2);
  }
#line 4940
  if (val.type == 1) {
#line 4940
    tmp = val.u.l == 0L;
  } else {
#line 4940
    tmp = val.u.d == 0.0;
  }
#line 4940
  return (tmp);
}
}
#line 4946 "/tmp/zsh-5.4.2/Src/exec.c"
static int exectime(Estate state , int do_exec  __attribute__((__unused__)) ) 
{ 
  int jb ;
  Wordcode tmp ;

  {
#line 4951
  jb = thisjob;
#line 4952
  if (*(state->pc + -1) >> 5 == 0U) {
    {
#line 4953
    shelltime();
    }
#line 4954
    return (0);
  }
  {
#line 4956
  tmp = state->pc;
#line 4956
  (state->pc) ++;
#line 4956
  execpline(state, *tmp, 1 | (1 << 1), 0);
#line 4957
  thisjob = jb;
  }
#line 4958
  return ((int )lastval);
}
}
#line 4963 "/tmp/zsh-5.4.2/Src/exec.c"
static char const   * const  ANONYMOUS_FUNCTION_NAME  =    (char const   */* const  */)"(anon)";
#line 4966 "/tmp/zsh-5.4.2/Src/exec.c"
static int execfuncdef(Estate state , Eprog redir_prog ) 
{ 
  Shfunc shf ;
  char *s ;
  int signum ;
  int nprg ;
  int sbeg ;
  int nstrs ;
  int npats ;
  int len ;
  int plen ;
  int i ;
  int htok ;
  int ret ;
  int nfunc ;
  int anon_func ;
  Wordcode beg ;
  Wordcode end ;
  Eprog prog ;
  Patprog *pp ;
  LinkList names ;
  Wordcode tmp ;
  Wordcode tmp___0 ;
  Wordcode tmp___1 ;
  Wordcode tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  LinkList args ;
  Wordcode tmp___11 ;
  Wordcode tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  void *tmp___17 ;

  {
  {
#line 4970
  s = (char *)((void *)0);
#line 4971
  htok = 0;
#line 4971
  ret = 0;
#line 4972
  nfunc = 0;
#line 4972
  anon_func = 0;
#line 4973
  beg = state->pc;
#line 4978
  end = beg + (*(state->pc + -1) >> 5);
#line 4979
  tmp = state->pc;
#line 4979
  (state->pc) ++;
#line 4979
  names = ecgetlist(state, (int )*tmp, 2, & htok);
#line 4980
  nprg = (int )(end - beg);
#line 4981
  tmp___0 = state->pc;
#line 4981
  (state->pc) ++;
#line 4981
  sbeg = (int )*tmp___0;
#line 4982
  tmp___1 = state->pc;
#line 4982
  (state->pc) ++;
#line 4982
  nstrs = (int )*tmp___1;
#line 4983
  tmp___2 = state->pc;
#line 4983
  (state->pc) ++;
#line 4983
  npats = (int )*tmp___2;
#line 4985
  nprg = (int )(end - state->pc);
#line 4986
  plen = (int )((unsigned long )nprg * sizeof(wordcode ));
#line 4987
  len = (int )(((unsigned long )plen + (unsigned long )npats * sizeof(Patprog )) + (unsigned long )nstrs);
  }
#line 4989
  if (htok) {
#line 4989
    if (names) {
      {
#line 4990
      execsubst(names);
      }
#line 4991
      if (errflag) {
#line 4992
        state->pc = end;
#line 4993
        return (1);
      }
    }
  }
  {
#line 4999
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4999
    if (! (! names)) {
      {
#line 4999
      tmp___17 = ugetnode(names);
#line 4999
      s = (char *)tmp___17;
      }
#line 4999
      if (! s) {
#line 4999
        goto while_break;
      }
    }
#line 5000
    if (! names) {
      {
#line 5001
      tmp___3 = zhalloc(sizeof(*prog));
#line 5001
      prog = (Eprog )tmp___3;
#line 5002
      prog->nref = -1;
      }
    } else {
      {
#line 5004
      tmp___4 = zalloc(sizeof(*prog));
#line 5004
      prog = (Eprog )tmp___4;
#line 5005
      prog->nref = 1;
      }
    }
#line 5007
    prog->npats = npats;
#line 5008
    prog->len = len;
#line 5009
    if ((state->prog)->dump) {
#line 5009
      goto _L;
    } else
#line 5009
    if (! names) {
      _L: /* CIL Label */ 
#line 5010
      if (! names) {
        {
#line 5011
        prog->flags = 2;
#line 5012
        prog->dump = (FuncDump )((void *)0);
#line 5013
        tmp___5 = zhalloc((unsigned long )npats * sizeof(Patprog ));
#line 5013
        pp = (Patprog *)tmp___5;
#line 5013
        prog->pats = pp;
        }
      } else {
        {
#line 5015
        prog->flags = 4;
#line 5016
        incrdumpcount((state->prog)->dump);
#line 5017
        prog->dump = (state->prog)->dump;
#line 5018
        tmp___6 = zalloc((unsigned long )npats * sizeof(Patprog ));
#line 5018
        pp = (Patprog *)tmp___6;
#line 5018
        prog->pats = pp;
        }
      }
#line 5020
      prog->prog = state->pc;
#line 5021
      prog->strs = state->strs + sbeg;
    } else {
      {
#line 5023
      prog->flags = 1;
#line 5024
      tmp___7 = zalloc((size_t )len);
#line 5024
      pp = (Patprog *)tmp___7;
#line 5024
      prog->pats = pp;
#line 5025
      prog->prog = (Wordcode )(prog->pats + npats);
#line 5026
      prog->strs = (char *)(prog->prog + nprg);
#line 5027
      prog->dump = (FuncDump )((void *)0);
#line 5028
      memcpy((void */* __restrict  */)prog->prog, (void const   */* __restrict  */)state->pc,
             (size_t )plen);
#line 5029
      memcpy((void */* __restrict  */)prog->strs, (void const   */* __restrict  */)(state->strs + sbeg),
             (size_t )nstrs);
      }
    }
#line 5031
    i = npats;
    {
#line 5031
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5031
      tmp___8 = i;
#line 5031
      i --;
#line 5031
      if (! tmp___8) {
#line 5031
        goto while_break___0;
      }
#line 5032
      *pp = (Patprog )1;
#line 5031
      pp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 5033
    prog->shf = (Shfunc )((void *)0);
#line 5035
    tmp___9 = zalloc(sizeof(*shf));
#line 5035
    shf = (Shfunc )tmp___9;
#line 5036
    shf->funcdef = prog;
#line 5037
    shf->node.flags = 0;
#line 5039
    shf->filename = ztrdup((char const   *)scriptfilename);
#line 5040
    shf->lineno = lineno;
#line 5046
    tmp___10 = nfunc;
#line 5046
    nfunc ++;
    }
#line 5046
    if (tmp___10) {
#line 5046
      if (redir_prog) {
        {
#line 5047
        shf->redir = dupeprog(redir_prog, 0);
        }
      } else {
#line 5049
        shf->redir = redir_prog;
      }
    } else {
#line 5049
      shf->redir = redir_prog;
    }
    {
#line 5050
    shfunc_set_sticky(shf);
    }
#line 5052
    if (! names) {
      {
#line 5059
      anon_func = 1;
#line 5061
      state->pc = end;
#line 5062
      tmp___11 = state->pc;
#line 5062
      (state->pc) ++;
#line 5062
      end += *tmp___11;
#line 5063
      tmp___12 = state->pc;
#line 5063
      (state->pc) ++;
#line 5063
      args = ecgetlist(state, (int )*tmp___12, 2, & htok);
      }
#line 5065
      if (htok) {
#line 5065
        if (args) {
          {
#line 5066
          execsubst(args);
          }
#line 5067
          if (errflag) {
            {
#line 5068
            freeeprog(shf->funcdef);
            }
#line 5069
            if (shf->redir) {
              {
#line 5070
              freeeprog(shf->redir);
              }
            }
            {
#line 5071
            dircache_set(& shf->filename, (char *)((void *)0));
#line 5072
            zfree((void *)shf, (int )sizeof(*shf));
#line 5073
            state->pc = end;
            }
#line 5074
            return (1);
          }
        }
      }
#line 5078
      if (args) {
#line 5078
        if ((unsigned long )args->list.first != (unsigned long )((void *)0)) {
#line 5078
          tmp___13 = (char const   *)((char *)(args->list.last)->dat);
        } else {
#line 5078
          tmp___13 = "";
        }
      } else {
#line 5078
        tmp___13 = "";
      }
      {
#line 5078
      setunderscore((char *)tmp___13);
      }
#line 5081
      if (! args) {
        {
#line 5082
        args = newlinklist();
        }
      }
      {
#line 5083
      shf->node.nam = (char *)ANONYMOUS_FUNCTION_NAME;
#line 5084
      insertlinknode(args, & args->node, (void *)shf->node.nam);
#line 5086
      execshfunc(shf, args);
#line 5087
      ret = (int )lastval;
      }
#line 5089
      if (opts[138]) {
#line 5089
        if (opts[160]) {
#line 5089
          if (lastval) {
            {
#line 5094
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"zsh: exit %ld\n",
                    lastval);
#line 5096
            fflush(stderr);
            }
          }
        }
      }
      {
#line 5099
      freeeprog(shf->funcdef);
      }
#line 5100
      if (shf->redir) {
        {
#line 5101
        freeeprog(shf->redir);
        }
      }
      {
#line 5102
      dircache_set(& shf->filename, (char *)((void *)0));
#line 5103
      zfree((void *)shf, (int )sizeof(*shf));
      }
#line 5104
      goto while_break;
    } else {
      {
#line 5107
      tmp___15 = strncmp((char const   *)s, "TRAP", (size_t )4);
      }
#line 5107
      if (! tmp___15) {
        {
#line 5107
        signum = getsignum((char const   *)(s + 4));
        }
#line 5107
        if (signum != -1) {
          {
#line 5109
          tmp___14 = settrap(signum, (Eprog )((void *)0), 1 << 2);
          }
#line 5109
          if (tmp___14) {
            {
#line 5110
            freeeprog(shf->funcdef);
#line 5111
            dircache_set(& shf->filename, (char *)((void *)0));
#line 5112
            zfree((void *)shf, (int )sizeof(*shf));
#line 5113
            state->pc = end;
            }
#line 5114
            return (1);
          }
          {
#line 5121
          removetrapnode(signum);
          }
        }
      }
      {
#line 5123
      tmp___16 = ztrdup((char const   *)s);
#line 5123
      (*(shfunctab->addnode))(shfunctab, tmp___16, (void *)shf);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5126
  if (! anon_func) {
    {
#line 5127
    setunderscore((char *)"");
    }
  }
#line 5128
  if (! nfunc) {
#line 5128
    if (redir_prog) {
      {
#line 5130
      freeeprog(redir_prog);
      }
    }
  }
#line 5132
  state->pc = end;
#line 5133
  return (ret);
}
}
#line 5140 "/tmp/zsh-5.4.2/Src/exec.c"
Emulation_options sticky_emulation_dup(Emulation_options src , int useheap ) 
{ 
  Emulation_options newsticky ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t sz___0 ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t sz___1 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 5143
  if (useheap) {
    {
#line 5143
    tmp = hcalloc(sizeof(*src));
#line 5143
    tmp___1 = tmp;
    }
  } else {
    {
#line 5143
    tmp___0 = zshcalloc(sizeof(*src));
#line 5143
    tmp___1 = tmp___0;
    }
  }
#line 5143
  newsticky = (Emulation_options )tmp___1;
#line 5145
  newsticky->emulation = src->emulation;
#line 5146
  if (src->n_on_opts) {
#line 5147
    sz___0 = (unsigned long )src->n_on_opts * sizeof(*(src->on_opts));
#line 5148
    newsticky->n_on_opts = src->n_on_opts;
#line 5149
    if (useheap) {
      {
#line 5149
      tmp___2 = zhalloc(sz___0);
#line 5149
      newsticky->on_opts = (OptIndex *)tmp___2;
      }
    } else {
      {
#line 5149
      tmp___3 = zalloc(sz___0);
#line 5149
      newsticky->on_opts = (OptIndex *)tmp___3;
      }
    }
    {
#line 5150
    memcpy((void */* __restrict  */)newsticky->on_opts, (void const   */* __restrict  */)src->on_opts,
           sz___0);
    }
  }
#line 5152
  if (src->n_off_opts) {
#line 5153
    sz___1 = (unsigned long )src->n_off_opts * sizeof(*(src->off_opts));
#line 5154
    newsticky->n_off_opts = src->n_off_opts;
#line 5155
    if (useheap) {
      {
#line 5155
      tmp___4 = zhalloc(sz___1);
#line 5155
      newsticky->off_opts = (OptIndex *)tmp___4;
      }
    } else {
      {
#line 5155
      tmp___5 = zalloc(sz___1);
#line 5155
      newsticky->off_opts = (OptIndex *)tmp___5;
      }
    }
    {
#line 5156
    memcpy((void */* __restrict  */)newsticky->off_opts, (void const   */* __restrict  */)src->off_opts,
           sz___1);
    }
  }
#line 5159
  return (newsticky);
}
}
#line 5166 "/tmp/zsh-5.4.2/Src/exec.c"
void shfunc_set_sticky(Shfunc shf ) 
{ 


  {
#line 5169
  if (sticky) {
    {
#line 5170
    shf->sticky = sticky_emulation_dup(sticky, 0);
    }
  } else {
#line 5172
    shf->sticky = (Emulation_options )((void *)0);
  }
#line 5173
  return;
}
}
#line 5179 "/tmp/zsh-5.4.2/Src/exec.c"
static void execshfunc(Shfunc shf , LinkList args ) 
{ 
  LinkList last_file_list ;
  unsigned char *ocs ;
  int ocsp ;
  int osfc ;
  int tmp ;
  LinkNode lptr ;
  void *tmp___0 ;
  sigset_t oset ;

  {
#line 5182
  last_file_list = (LinkList )((void *)0);
#line 5186
  if (errflag) {
#line 5187
    return;
  }
#line 5190
  if (! list_pipe) {
#line 5190
    if (thisjob != -1) {
#line 5190
      if (thisjob != list_pipe_job) {
        {
#line 5190
        tmp = hasprocs(thisjob);
        }
#line 5190
        if (! tmp) {
          {
#line 5194
          last_file_list = (jobtab + thisjob)->filelist;
#line 5195
          (jobtab + thisjob)->filelist = (LinkList )((void *)0);
#line 5196
          deletejob(jobtab + thisjob, 0);
          }
        }
      }
    }
  }
#line 5199
  if (opts[177]) {
    {
#line 5201
    printprompt4();
    }
#line 5202
    if (args) {
#line 5203
      lptr = args->list.first;
      {
#line 5203
      while (1) {
        while_continue: /* CIL Label */ ;
#line 5203
        if (! lptr) {
#line 5203
          goto while_break;
        }
#line 5204
        if ((unsigned long )lptr != (unsigned long )args->list.first) {
          {
#line 5205
          fputc(' ', xtrerr);
          }
        }
        {
#line 5206
        quotedzputs((char const   *)((char *)lptr->dat), xtrerr);
#line 5203
        lptr = lptr->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 5208
    fputc('\n', xtrerr);
#line 5209
    fflush(xtrerr);
    }
  }
  {
#line 5211
  queueing_enabled ++;
#line 5212
  ocs = cmdstack;
#line 5213
  ocsp = cmdsp;
#line 5214
  tmp___0 = zalloc((size_t )256);
#line 5214
  cmdstack = (unsigned char *)tmp___0;
#line 5215
  cmdsp = 0;
#line 5216
  osfc = sfcontext;
  }
#line 5216
  if (osfc == 0) {
#line 5217
    sfcontext = 1;
  }
  {
#line 5218
  xtrerr = stderr;
#line 5220
  doshfunc(shf, args, 0);
#line 5222
  sfcontext = osfc;
#line 5223
  free((void *)cmdstack);
#line 5224
  cmdstack = ocs;
#line 5225
  cmdsp = ocsp;
  }
#line 5227
  if (! list_pipe) {
    {
#line 5228
    deletefilelist(last_file_list, 0);
    }
  }
  {
#line 5229
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5229
    queueing_enabled --;
#line 5229
    if (! queueing_enabled) {
      {
#line 5229
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 5229
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 5229
          if (! (queue_front != queue_rear)) {
#line 5229
            goto while_break___2;
          }
          {
#line 5229
          queue_front = (queue_front + 1) % 128;
#line 5229
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 5229
          zhandler(signal_queue[queue_front]);
#line 5229
          signal_setmask(oset);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 5229
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 5229
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5230
  return;
}
}
#line 5247 "/tmp/zsh-5.4.2/Src/exec.c"
static int execautofn_basic(Estate state , int do_exec  __attribute__((__unused__)) ) 
{ 
  Shfunc shf ;
  char *oldscriptname ;
  char *oldscriptfilename ;

  {
#line 5253
  shf = (state->prog)->shf;
#line 5259
  if (funcstack) {
#line 5259
    if (! funcstack->filename) {
      {
#line 5260
      funcstack->filename = getshfuncfile(shf);
      }
    }
  }
  {
#line 5262
  oldscriptname = scriptname;
#line 5263
  oldscriptfilename = scriptfilename;
#line 5264
  scriptname = dupstring((char const   *)shf->node.nam);
#line 5265
  scriptfilename = getshfuncfile(shf);
#line 5266
  execode(shf->funcdef, 1, 0, (char *)"loadautofunc");
#line 5267
  scriptname = oldscriptname;
#line 5268
  scriptfilename = oldscriptfilename;
  }
#line 5270
  return ((int )lastval);
}
}
#line 5274 "/tmp/zsh-5.4.2/Src/exec.c"
static int execautofn(Estate state , int do_exec  __attribute__((__unused__)) ) 
{ 
  Shfunc shf ;
  int tmp ;

  {
  {
#line 5279
  shf = loadautofn((state->prog)->shf, 1, 0, 0);
  }
#line 5279
  if (! shf) {
#line 5280
    return (1);
  }
  {
#line 5282
  (state->prog)->shf = shf;
#line 5283
  tmp = execautofn_basic(state, 0);
  }
#line 5283
  return (tmp);
}
}
#line 5296 "/tmp/zsh-5.4.2/Src/exec.c"
static void loadautofnsetfile(Shfunc shf , char *fdir ) 
{ 
  int tmp ;

  {
#line 5304
  if (! (shf->node.flags & (1 << 19))) {
#line 5304
    goto _L;
  } else {
    {
#line 5304
    tmp = strcmp((char const   *)shf->filename, (char const   *)fdir);
    }
#line 5304
    if (tmp != 0) {
      _L: /* CIL Label */ 
      {
#line 5307
      dircache_set(& shf->filename, (char *)((void *)0));
      }
#line 5308
      if (fdir) {
        {
#line 5310
        shf->node.flags |= 1 << 19;
#line 5311
        dircache_set(& shf->filename, fdir);
        }
      } else {
        {
#line 5314
        shf->node.flags &= ~ (1 << 19);
#line 5315
        shf->filename = ztrdup((char const   *)shf->node.nam);
        }
      }
    }
  }
#line 5318
  return;
}
}
#line 5321 "/tmp/zsh-5.4.2/Src/exec.c"
Shfunc loadautofn(Shfunc shf , int fksh , int autol , int current_fpath ) 
{ 
  int noalias ;
  int ksh ;
  Eprog prog ;
  char *fdir ;
  char *spec_path[2] ;
  int tmp ;
  char *n ;
  size_t tmp___0 ;
  void *tmp___1 ;
  HashNode tmp___2 ;
  Eprog tmp___3 ;

  {
  {
#line 5324
  noalias = noaliases;
#line 5324
  ksh = 1;
#line 5328
  pushheap();
#line 5330
  noaliases = shf->node.flags & (1 << 13);
  }
#line 5331
  if (shf->filename) {
#line 5331
    if ((int )*(shf->filename + 0) == 47) {
#line 5331
      if (shf->node.flags & (1 << 19)) {
        {
#line 5335
        spec_path[0] = dupstring((char const   *)shf->filename);
#line 5336
        spec_path[1] = (char *)((void *)0);
#line 5337
        prog = getfpfunc(shf->node.nam, & ksh, & fdir, spec_path, 0);
        }
#line 5338
        if ((unsigned long )prog == (unsigned long )(& dummy_eprog)) {
#line 5338
          if (current_fpath) {
            {
#line 5340
            prog = getfpfunc(shf->node.nam, & ksh, & fdir, (char **)((void *)0), 0);
            }
          } else
#line 5338
          if (shf->node.flags & (1 << 14)) {
            {
#line 5340
            prog = getfpfunc(shf->node.nam, & ksh, & fdir, (char **)((void *)0), 0);
            }
          }
        }
      } else {
        {
#line 5343
        prog = getfpfunc(shf->node.nam, & ksh, & fdir, (char **)((void *)0), 0);
        }
      }
    } else {
      {
#line 5343
      prog = getfpfunc(shf->node.nam, & ksh, & fdir, (char **)((void *)0), 0);
      }
    }
  } else {
    {
#line 5343
    prog = getfpfunc(shf->node.nam, & ksh, & fdir, (char **)((void *)0), 0);
    }
  }
#line 5344
  noaliases = noalias;
#line 5346
  if (ksh == 1) {
#line 5347
    ksh = fksh;
#line 5348
    if (ksh == 1) {
#line 5349
      if (shf->node.flags & (1 << 17)) {
#line 5349
        ksh = 2;
      } else {
#line 5349
        if (shf->node.flags & (1 << 18)) {
#line 5349
          tmp = 0;
        } else {
#line 5349
          tmp = 1;
        }
#line 5349
        ksh = tmp;
      }
    }
  }
#line 5353
  if ((unsigned long )prog == (unsigned long )(& dummy_eprog)) {
    {
#line 5355
    locallevel --;
#line 5356
    zwarn("%s: function definition file not found", shf->node.nam);
#line 5357
    locallevel ++;
#line 5358
    popheap();
    }
#line 5359
    return ((Shfunc )((void *)0));
  }
#line 5361
  if (! prog) {
    {
#line 5362
    popheap();
    }
#line 5363
    return ((Shfunc )((void *)0));
  }
#line 5365
  if (ksh == 2) {
#line 5365
    goto _L;
  } else
#line 5365
  if (ksh == 1) {
#line 5365
    if (opts[96]) {
      _L: /* CIL Label */ 
#line 5366
      if (autol) {
        {
#line 5367
        prog->flags |= 8;
#line 5369
        freeeprog(shf->funcdef);
        }
#line 5370
        if (prog->flags & 4) {
#line 5371
          shf->funcdef = prog;
        } else {
          {
#line 5373
          shf->funcdef = dupeprog(prog, 0);
          }
        }
        {
#line 5374
        shf->node.flags &= ~ (1 << 9);
#line 5375
        loadautofnsetfile(shf, fdir);
        }
      } else {
        {
#line 5377
        tmp___0 = strlen((char const   *)shf->node.nam);
#line 5377
        tmp___1 = zhalloc(sizeof(char ) * (tmp___0 + 1UL));
#line 5377
        n = (char *)tmp___1;
#line 5378
        strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)shf->node.nam);
#line 5379
        execode(prog, 1, 0, (char *)"evalautofunc");
#line 5380
        tmp___2 = (*(shfunctab->getnode))(shfunctab, (char const   *)n);
#line 5380
        shf = (Shfunc )tmp___2;
        }
#line 5381
        if (! shf) {
          {
#line 5383
          locallevel --;
#line 5384
          zwarn("%s: function not defined by file", n);
#line 5385
          locallevel ++;
#line 5386
          popheap();
          }
#line 5387
          return ((Shfunc )((void *)0));
        } else
#line 5381
        if (shf->node.flags & (1 << 9)) {
          {
#line 5383
          locallevel --;
#line 5384
          zwarn("%s: function not defined by file", n);
#line 5385
          locallevel ++;
#line 5386
          popheap();
          }
#line 5387
          return ((Shfunc )((void *)0));
        }
      }
    } else {
#line 5365
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 5391
    freeeprog(shf->funcdef);
    }
#line 5392
    if (prog->flags & 4) {
      {
#line 5393
      shf->funcdef = stripkshdef(prog, shf->node.nam);
      }
    } else {
      {
#line 5395
      tmp___3 = stripkshdef(prog, shf->node.nam);
#line 5395
      shf->funcdef = dupeprog(tmp___3, 0);
      }
    }
    {
#line 5396
    shf->node.flags &= ~ (1 << 9);
#line 5397
    loadautofnsetfile(shf, fdir);
    }
  }
  {
#line 5399
  popheap();
  }
#line 5401
  return (shf);
}
}
#line 5410 "/tmp/zsh-5.4.2/Src/exec.c"
int sticky_emulation_differs(Emulation_options sticky2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 5413
  if (! sticky2) {
#line 5414
    return (0);
  }
#line 5416
  if (! sticky) {
#line 5417
    return (1);
  }
#line 5419
  if (sticky->emulation != sticky2->emulation) {
#line 5420
    return (1);
  }
#line 5422
  if (sticky->n_on_opts != sticky2->n_on_opts) {
#line 5424
    return (1);
  } else
#line 5422
  if (sticky->n_off_opts != sticky2->n_off_opts) {
#line 5424
    return (1);
  }
#line 5431
  if (sticky->n_on_opts) {
    {
#line 5431
    tmp = memcmp((void const   *)sticky->on_opts, (void const   *)sticky2->on_opts,
                 (unsigned long )sticky->n_on_opts * sizeof(*(sticky->on_opts)));
    }
#line 5431
    if (tmp != 0) {
#line 5434
      return (1);
    }
  }
#line 5436
  if (sticky->n_off_opts) {
    {
#line 5436
    tmp___0 = memcmp((void const   *)sticky->off_opts, (void const   *)sticky2->off_opts,
                     (unsigned long )sticky->n_off_opts * sizeof(*(sticky->off_opts)));
    }
#line 5436
    if (tmp___0 != 0) {
#line 5439
      return (1);
    }
  }
#line 5440
  return (0);
}
}
#line 5476 "/tmp/zsh-5.4.2/Src/exec.c"
static int oflags  ;
#line 5479 "/tmp/zsh-5.4.2/Src/exec.c"
static int funcdepth  ;
#line 5462 "/tmp/zsh-5.4.2/Src/exec.c"
int doshfunc(Shfunc shfunc , LinkList doshargs , int noreturnval ) 
{ 
  char **pptab ;
  char **x ;
  char *oargv0 ;
  int oldzoptind ;
  int oldlastval ;
  int oldoptcind ;
  int oldnumpipestats ;
  int ret ;
  int *oldpipestats ;
  char saveopts[180] ;
  char *oldscriptname ;
  char *name ;
  int flags ;
  int ooflags ;
  int savnoerrexit ;
  char *fname ;
  char *tmp ;
  int obreaks ;
  int ocontflag ;
  int oloops ;
  int saveemulation ;
  int restore_sticky ;
  Eprog prog ;
  struct funcstack fstack ;
  Emulation_options save_sticky ;
  Heap funcheap ;
  Heap _switch_oldheaps ;
  size_t bytes ;
  void *tmp___0 ;
  OptIndex *onptr ;
  OptIndex *offptr ;
  int tmp___1 ;
  LinkNode node ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  Shfunc shf ;
  HashNode tmp___7 ;
  sigset_t oset ;

  {
  {
#line 5467
  oldpipestats = (int *)((void *)0);
#line 5468
  oldscriptname = scriptname;
#line 5469
  name = shfunc->node.nam;
#line 5470
  flags = shfunc->node.flags;
#line 5472
  tmp = dupstring((char const   *)name);
#line 5472
  fname = tmp;
#line 5477
  save_sticky = (Emulation_options )((void *)0);
#line 5483
  queueing_enabled ++;
  }
  {
#line 5485
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5485
    funcheap = new_heaps();
#line 5485
    _switch_oldheaps = funcheap;
    }
    {
#line 5485
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5486
      oargv0 = (char *)((void *)0);
#line 5487
      obreaks = breaks;
#line 5488
      ocontflag = contflag;
#line 5489
      oloops = loops;
#line 5490
      if (trap_state == 1) {
#line 5491
        trap_return --;
      }
#line 5492
      oldlastval = (int )lastval;
#line 5493
      oldnumpipestats = numpipestats;
#line 5494
      savnoerrexit = noerrexit;
#line 5498
      noerrexit &= -3;
#line 5499
      if (noreturnval) {
        {
#line 5504
        bytes = sizeof(int ) * (unsigned long )numpipestats;
#line 5505
        tmp___0 = zhalloc(bytes);
#line 5505
        oldpipestats = (int *)tmp___0;
#line 5506
        memcpy((void */* __restrict  */)oldpipestats, (void const   */* __restrict  */)(pipestats),
               bytes);
        }
      }
      {
#line 5509
      starttrapscope();
#line 5510
      startpatternscope();
#line 5512
      pptab = pparams;
      }
#line 5513
      if (! (flags & (1 << 9))) {
        {
#line 5514
        scriptname = dupstring((char const   *)name);
        }
      }
#line 5515
      oldzoptind = (int )zoptind;
#line 5516
      oldoptcind = optcind;
#line 5517
      if (! opts[131]) {
#line 5518
        zoptind = (zlong )1;
#line 5519
        optcind = 0;
      }
      {
#line 5525
      memcpy((void */* __restrict  */)(saveopts), (void const   */* __restrict  */)(opts),
             sizeof(opts));
#line 5526
      saveemulation = emulation;
#line 5527
      save_sticky = sticky;
#line 5529
      tmp___1 = sticky_emulation_differs(shfunc->sticky);
      }
#line 5529
      if (tmp___1) {
        {
#line 5542
        sticky = sticky_emulation_dup(shfunc->sticky, 1);
#line 5543
        emulation = sticky->emulation;
#line 5544
        restore_sticky = 1;
#line 5545
        installemulation(emulation, opts);
        }
#line 5546
        if (sticky->n_on_opts) {
#line 5548
          onptr = sticky->on_opts;
          {
#line 5548
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 5548
            if (! ((unsigned long )onptr < (unsigned long )(sticky->on_opts + sticky->n_on_opts))) {
#line 5548
              goto while_break___1;
            }
#line 5551
            opts[*onptr] = (char)1;
#line 5548
            onptr ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 5553
        if (sticky->n_off_opts) {
#line 5555
          offptr = sticky->off_opts;
          {
#line 5555
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 5555
            if (! ((unsigned long )offptr < (unsigned long )(sticky->off_opts + sticky->n_off_opts))) {
#line 5555
              goto while_break___2;
            }
#line 5558
            opts[*offptr] = (char)0;
#line 5555
            offptr ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 5561
        clearpatterndisables();
        }
      } else {
#line 5563
        restore_sticky = 0;
      }
#line 5565
      if (flags & ((1 << 11) | (1 << 16))) {
#line 5566
        opts[177] = (char)1;
      } else
#line 5567
      if (oflags & (1 << 16)) {
#line 5568
        if ((unsigned long )shfunc->node.nam == (unsigned long )ANONYMOUS_FUNCTION_NAME) {
#line 5569
          flags |= 1 << 16;
        } else {
#line 5571
          opts[177] = (char)0;
        }
      }
#line 5573
      if (flags & (1 << 15)) {
#line 5574
        opts[176] = (char)1;
      } else
#line 5575
      if (oflags & (1 << 15)) {
#line 5576
        if ((unsigned long )shfunc->node.nam == (unsigned long )ANONYMOUS_FUNCTION_NAME) {
#line 5577
          flags |= 1 << 15;
        } else {
#line 5579
          opts[176] = (char)0;
        }
      }
#line 5581
      ooflags = oflags;
#line 5587
      oflags = flags;
#line 5588
      opts[138] = (char)0;
#line 5589
      if (doshargs) {
        {
#line 5592
        node = doshargs->list.first;
#line 5593
        tmp___2 = countlinknodes(doshargs);
#line 5593
        tmp___3 = zshcalloc(sizeof(*x) * (unsigned long )(1 + tmp___2));
#line 5593
        x = (char **)tmp___3;
#line 5593
        pparams = x;
        }
#line 5595
        if (opts[58]) {
          {
#line 5596
          oargv0 = argzero;
#line 5597
          argzero = ztrdup((char const   *)node->dat);
          }
        }
#line 5600
        node = node->next;
        {
#line 5601
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 5601
          if (! node) {
#line 5601
            goto while_break___3;
          }
          {
#line 5602
          *x = ztrdup((char const   *)node->dat);
#line 5601
          node = node->next;
#line 5601
          x ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
        {
#line 5604
        tmp___4 = zshcalloc(sizeof(*pparams));
#line 5604
        pparams = (char **)tmp___4;
        }
#line 5605
        if (opts[58]) {
          {
#line 5606
          oargv0 = argzero;
#line 5607
          argzero = ztrdup((char const   *)argzero);
          }
        }
      }
#line 5611
      funcdepth ++;
#line 5611
      if (funcdepth > 1000) {
        {
#line 5613
        zerr("maximum nested function level reached");
        }
#line 5614
        goto undoshfunc;
      }
      {
#line 5617
      fstack.name = dupstring((char const   *)name);
      }
#line 5623
      if (funcstack) {
#line 5623
        fstack.caller = funcstack->name;
      } else {
#line 5623
        if (oargv0) {
#line 5623
          tmp___5 = oargv0;
        } else {
#line 5623
          tmp___5 = argzero;
        }
        {
#line 5623
        tmp___6 = dupstring((char const   *)tmp___5);
#line 5623
        fstack.caller = tmp___6;
        }
      }
      {
#line 5625
      fstack.lineno = lineno;
#line 5626
      fstack.prev = funcstack;
#line 5627
      fstack.tp = 1;
#line 5628
      funcstack = & fstack;
#line 5630
      fstack.flineno = shfunc->lineno;
#line 5631
      fstack.filename = getshfuncfile(shfunc);
#line 5633
      prog = shfunc->funcdef;
      }
#line 5634
      if (prog->flags & 8) {
        {
#line 5637
        prog->flags &= -9;
#line 5639
        runshfunc(prog, (FuncWrap )((void *)0), fstack.name);
#line 5641
        name = fname;
#line 5641
        tmp___7 = (*(shfunctab->getnode))(shfunctab, (char const   *)name);
#line 5641
        shf = (Shfunc )tmp___7;
        }
#line 5641
        if (! shf) {
          {
#line 5643
          zwarn("%s: function not defined by file", name);
          }
#line 5644
          if (noreturnval) {
#line 5645
            errflag |= 1;
          } else {
#line 5647
            lastval = (zlong )1;
          }
#line 5648
          goto doneshfunc;
        }
#line 5650
        prog = shf->funcdef;
      }
      {
#line 5652
      runshfunc(prog, wrappers, fstack.name);
      }
      doneshfunc: 
#line 5654
      funcstack = fstack.prev;
      undoshfunc: 
#line 5657
      funcdepth --;
#line 5659
      if (retflag) {
#line 5660
        retflag = 0;
#line 5661
        breaks = obreaks;
      }
      {
#line 5663
      freearray(pparams);
      }
#line 5664
      if (oargv0) {
        {
#line 5665
        zsfree(argzero);
#line 5666
        argzero = oargv0;
        }
      }
#line 5668
      pparams = pptab;
#line 5669
      if (! opts[131]) {
#line 5670
        zoptind = (zlong )oldzoptind;
#line 5671
        optcind = oldoptcind;
      }
      {
#line 5673
      scriptname = oldscriptname;
#line 5674
      oflags = ooflags;
#line 5676
      endpatternscope();
      }
#line 5678
      if (restore_sticky) {
        {
#line 5684
        memcpy((void */* __restrict  */)(opts), (void const   */* __restrict  */)(saveopts),
               sizeof(opts));
#line 5685
        emulation = saveemulation;
#line 5686
        sticky = save_sticky;
        }
      } else
#line 5687
      if (opts[107]) {
        {
#line 5689
        saveopts[139] = opts[139];
#line 5690
        saveopts[154] = opts[154];
#line 5691
        memcpy((void */* __restrict  */)(opts), (void const   */* __restrict  */)(saveopts),
               sizeof(opts));
#line 5692
        emulation = saveemulation;
        }
      } else {
#line 5695
        opts[177] = saveopts[177];
#line 5696
        opts[138] = saveopts[138];
#line 5697
        opts[107] = saveopts[107];
#line 5698
        opts[106] = saveopts[106];
#line 5699
        opts[176] = saveopts[176];
      }
#line 5702
      if (opts[106]) {
#line 5703
        if (contflag) {
          {
#line 5704
          zwarn("`continue\' active at end of function scope");
          }
        }
#line 5705
        if (breaks) {
          {
#line 5706
          zwarn("`break\' active at end of function scope");
          }
        }
#line 5707
        breaks = obreaks;
#line 5708
        contflag = ocontflag;
#line 5709
        loops = oloops;
      }
      {
#line 5712
      endtrapscope();
      }
#line 5714
      if (trap_state == 1) {
#line 5715
        trap_return ++;
      }
#line 5716
      ret = (int )lastval;
#line 5717
      noerrexit = savnoerrexit;
#line 5718
      if (noreturnval) {
        {
#line 5719
        lastval = (zlong )oldlastval;
#line 5720
        numpipestats = oldnumpipestats;
#line 5721
        memcpy((void */* __restrict  */)(pipestats), (void const   */* __restrict  */)oldpipestats,
               sizeof(int ) * (unsigned long )numpipestats);
        }
      }
#line 5485
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 5723
    old_heaps(_switch_oldheaps);
    }
#line 5485
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5725
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 5725
    queueing_enabled --;
#line 5725
    if (! queueing_enabled) {
      {
#line 5725
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 5725
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 5725
          if (! (queue_front != queue_rear)) {
#line 5725
            goto while_break___6;
          }
          {
#line 5725
          queue_front = (queue_front + 1) % 128;
#line 5725
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 5725
          zhandler(signal_queue[queue_front]);
#line 5725
          signal_setmask(oset);
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 5725
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 5725
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 5738
  if (exit_pending) {
#line 5738
    if (exit_level >= locallevel + 1) {
#line 5738
      if (! in_exit_trap) {
#line 5739
        if (locallevel > forklevel) {
#line 5741
          retflag = 1;
#line 5742
          breaks = loops;
        } else {
          {
#line 5749
          stopmsg = 1;
#line 5750
          zexit(exit_pending >> 1, 0);
          }
        }
      }
    }
  }
#line 5754
  return (ret);
}
}
#line 5762 "/tmp/zsh-5.4.2/Src/exec.c"
void runshfunc(Eprog prog , FuncWrap wrap , char *name ) 
{ 
  int cont ;
  int ouu ;
  char *ou ;
  void *tmp ;
  sigset_t oset ;
  sigset_t oset___0 ;

  {
  {
#line 5768
  queueing_enabled ++;
#line 5770
  ouu = underscoreused;
#line 5770
  tmp = zalloc((size_t )ouu);
#line 5770
  ou = (char *)tmp;
  }
#line 5771
  if (ou) {
    {
#line 5772
    memcpy((void */* __restrict  */)ou, (void const   */* __restrict  */)zunderscore,
           (size_t )underscoreused);
    }
  }
  {
#line 5774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5774
    if (! wrap) {
#line 5774
      goto while_break;
    }
    {
#line 5775
    ((wrap->module)->wrapper) ++;
#line 5776
    cont = (*(wrap->handler))(prog, wrap->next, name);
#line 5777
    ((wrap->module)->wrapper) --;
    }
#line 5779
    if (! (wrap->module)->wrapper) {
#line 5779
      if ((wrap->module)->node.flags & (1 << 1)) {
        {
#line 5781
        unload_module(wrap->module);
        }
      }
    }
#line 5783
    if (! cont) {
#line 5784
      if (ou) {
        {
#line 5785
        zfree((void *)ou, ouu);
        }
      }
      {
#line 5786
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5786
        queueing_enabled --;
#line 5786
        if (! queueing_enabled) {
          {
#line 5786
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 5786
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 5786
              if (! (queue_front != queue_rear)) {
#line 5786
                goto while_break___2;
              }
              {
#line 5786
              queue_front = (queue_front + 1) % 128;
#line 5786
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 5786
              zhandler(signal_queue[queue_front]);
#line 5786
              signal_setmask(oset);
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 5786
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 5786
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 5787
      return;
    }
#line 5789
    wrap = wrap->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5791
  startparamscope();
#line 5792
  execode(prog, 1, 0, (char *)"shfunc");
  }
#line 5793
  if (ou) {
    {
#line 5794
    setunderscore(ou);
#line 5795
    zfree((void *)ou, ouu);
    }
  }
  {
#line 5797
  endparamscope();
  }
  {
#line 5799
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 5799
    queueing_enabled --;
#line 5799
    if (! queueing_enabled) {
      {
#line 5799
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 5799
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 5799
          if (! (queue_front != queue_rear)) {
#line 5799
            goto while_break___5;
          }
          {
#line 5799
          queue_front = (queue_front + 1) % 128;
#line 5799
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 5799
          zhandler(signal_queue[queue_front]);
#line 5799
          signal_setmask(oset___0);
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 5799
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 5799
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 5800
  return;
}
}
#line 5815 "/tmp/zsh-5.4.2/Src/exec.c"
Eprog getfpfunc(char *s , int *ksh , char **fdir , char **alt_path , int test_only ) 
{ 
  char **pp ;
  char buf___7[4097] ;
  off_t len ;
  off_t rlen ;
  char *d___0 ;
  Eprog r ;
  int fd ;
  size_t tmp ;
  size_t tmp___0 ;
  struct stat st___0 ;
  void *tmp___1 ;
  char *oldscriptname ;
  int tmp___2 ;
  int tmp___3 ;
  struct eprog *tmp___4 ;

  {
#line 5825
  if (alt_path) {
#line 5825
    pp = alt_path;
  } else {
#line 5825
    pp = fpath;
  }
  {
#line 5826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5826
    if (! *pp) {
#line 5826
      goto while_break;
    }
    {
#line 5827
    tmp = strlen((char const   *)*pp);
#line 5827
    tmp___0 = strlen((char const   *)s);
    }
#line 5827
    if ((tmp + tmp___0) + 1UL >= 4096UL) {
#line 5828
      goto __Cont;
    }
#line 5829
    if (*(*pp)) {
      {
#line 5830
      sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%s/%s",
              *pp, s);
      }
    } else {
      {
#line 5832
      strcpy((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)s);
      }
    }
    {
#line 5833
    r = try_dump_file(*pp, s, buf___7, ksh, test_only);
    }
#line 5833
    if (r) {
#line 5834
      if (fdir) {
#line 5835
        *fdir = *pp;
      }
#line 5836
      return (r);
    }
    {
#line 5838
    unmetafy(buf___7, (int *)((void *)0));
#line 5839
    tmp___3 = access((char const   *)(buf___7), 4);
    }
#line 5839
    if (! tmp___3) {
      {
#line 5839
      fd = open((char const   *)(buf___7), 256);
      }
#line 5839
      if (fd != -1) {
        {
#line 5841
        tmp___2 = fstat(fd, & st___0);
        }
#line 5841
        if (tmp___2) {
          {
#line 5873
          close(fd);
          }
        } else
#line 5841
        if ((st___0.st_mode & 61440U) == 32768U) {
          {
#line 5841
          len = lseek(fd, (__off_t )0, 2);
          }
#line 5841
          if (len != -1L) {
#line 5843
            if (test_only) {
              {
#line 5844
              close(fd);
              }
#line 5845
              if (fdir) {
#line 5846
                *fdir = *pp;
              }
#line 5847
              return (& dummy_eprog);
            }
            {
#line 5849
            tmp___1 = zalloc((size_t )(len + 1L));
#line 5849
            d___0 = (char *)tmp___1;
#line 5850
            lseek(fd, (__off_t )0, 0);
#line 5851
            rlen = read(fd, (void *)d___0, (size_t )len);
            }
#line 5851
            if (rlen >= 0L) {
              {
#line 5852
              oldscriptname = scriptname;
#line 5854
              close(fd);
#line 5855
              *(d___0 + rlen) = (char )'\000';
#line 5856
              d___0 = metafy(d___0, (int )rlen, 0);
#line 5858
              scriptname = dupstring((char const   *)s);
#line 5859
              r = parse_string(d___0, 1);
#line 5860
              scriptname = oldscriptname;
              }
#line 5862
              if (fdir) {
#line 5863
                *fdir = *pp;
              }
              {
#line 5865
              zfree((void *)d___0, (int )(len + 1L));
              }
#line 5867
              return (r);
            } else {
              {
#line 5869
              close(fd);
              }
            }
            {
#line 5871
            zfree((void *)d___0, (int )(len + 1L));
            }
          } else {
            {
#line 5873
            close(fd);
            }
          }
        } else {
          {
#line 5873
          close(fd);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 5826
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5876
  if (test_only) {
#line 5876
    tmp___4 = (struct eprog *)((void *)0);
  } else {
#line 5876
    tmp___4 = & dummy_eprog;
  }
#line 5876
  return (tmp___4);
}
}
#line 5886 "/tmp/zsh-5.4.2/Src/exec.c"
Eprog stripkshdef(Eprog prog , char *name ) 
{ 
  Wordcode pc ;
  wordcode code ;
  Wordcode tmp ;
  Wordcode tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  Eprog ret ;
  Wordcode end ;
  int sbeg ;
  int nstrs ;
  int nprg ;
  int npats ;
  int plen ;
  int len ;
  int i ;
  Patprog *pp ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
#line 5892
  if (! prog) {
#line 5893
    return ((Eprog )((void *)0));
  }
#line 5894
  pc = prog->prog;
#line 5895
  tmp = pc;
#line 5895
  pc ++;
#line 5895
  code = *tmp;
#line 5896
  if ((code & (wordcode )((1 << 5) - 1)) != 1U) {
#line 5898
    return (prog);
  } else
#line 5896
  if (((code >> 5) & (unsigned int )(((1 << 1) | (1 << 4)) | (1 << 5))) != (unsigned int )(((1 << 1) | (1 << 4)) | (1 << 5))) {
#line 5898
    return (prog);
  }
#line 5899
  pc ++;
#line 5900
  tmp___0 = pc;
#line 5900
  pc ++;
#line 5900
  code = *tmp___0;
#line 5901
  if ((code & (wordcode )((1 << 5) - 1)) != 11U) {
#line 5903
    return (prog);
  } else
#line 5901
  if (*pc != 1U) {
#line 5903
    return (prog);
  } else {
    {
#line 5901
    tmp___1 = ecrawstr(prog, pc + 1, (int *)((void *)0));
#line 5901
    tmp___2 = strcmp((char const   *)name, (char const   *)tmp___1);
    }
#line 5901
    if (tmp___2) {
#line 5903
      return (prog);
    }
  }
#line 5907
  end = pc + (code >> 5);
#line 5908
  sbeg = (int )*(pc + 2);
#line 5908
  nstrs = (int )*(pc + 3);
#line 5908
  npats = (int )*(pc + 4);
#line 5911
  pc += 5;
#line 5913
  nprg = (int )(end - pc);
#line 5914
  plen = (int )((unsigned long )nprg * sizeof(wordcode ));
#line 5915
  len = (int )(((unsigned long )plen + (unsigned long )npats * sizeof(Patprog )) + (unsigned long )nstrs);
#line 5917
  if (prog->flags & 4) {
    {
#line 5918
    ret = prog;
#line 5919
    free((void *)prog->pats);
#line 5920
    tmp___3 = zalloc((unsigned long )npats * sizeof(Patprog ));
#line 5920
    pp = (Patprog *)tmp___3;
#line 5920
    ret->pats = pp;
#line 5921
    ret->prog = pc;
#line 5922
    ret->strs = prog->strs + sbeg;
    }
  } else {
    {
#line 5924
    tmp___4 = zhalloc(sizeof(*ret));
#line 5924
    ret = (Eprog )tmp___4;
#line 5925
    ret->flags = 2;
#line 5926
    tmp___5 = zhalloc((size_t )len);
#line 5926
    pp = (Patprog *)tmp___5;
#line 5926
    ret->pats = pp;
#line 5927
    ret->prog = (Wordcode )(ret->pats + npats);
#line 5928
    ret->strs = (char *)(ret->prog + nprg);
#line 5929
    memcpy((void */* __restrict  */)ret->prog, (void const   */* __restrict  */)pc,
           (size_t )plen);
#line 5930
    memcpy((void */* __restrict  */)ret->strs, (void const   */* __restrict  */)(prog->strs + sbeg),
           (size_t )nstrs);
#line 5931
    ret->dump = (FuncDump )((void *)0);
    }
  }
#line 5933
  ret->len = len;
#line 5934
  ret->npats = npats;
#line 5935
  i = npats;
  {
#line 5935
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5935
    tmp___6 = i;
#line 5935
    i --;
#line 5935
    if (! tmp___6) {
#line 5935
      goto while_break;
    }
#line 5936
    *pp = (Patprog )1;
#line 5935
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5937
  ret->shf = (Shfunc )((void *)0);
#line 5939
  return (ret);
}
}
#line 5946 "/tmp/zsh-5.4.2/Src/exec.c"
static char *cancd(char *s ) 
{ 
  int nocdpath ;
  int tmp ;
  char *t ;
  char sbuf[4097] ;
  char **cp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 5949
  if ((int )*(s + 0) == 46) {
#line 5949
    if ((int )*(s + 1) == 47) {
#line 5949
      tmp = 1;
    } else
#line 5949
    if (! *(s + 1)) {
#line 5949
      tmp = 1;
    } else
#line 5949
    if ((int )*(s + 1) == 46) {
#line 5949
      if ((int )*(s + 2) == 47) {
#line 5949
        tmp = 1;
      } else
#line 5949
      if (! *(s + 1)) {
#line 5949
        tmp = 1;
      } else {
#line 5949
        tmp = 0;
      }
    } else {
#line 5949
      tmp = 0;
    }
  } else {
#line 5949
    tmp = 0;
  }
#line 5949
  nocdpath = tmp;
#line 5953
  if ((int )*s != 47) {
    {
#line 5956
    tmp___0 = cancd2(s);
    }
#line 5956
    if (tmp___0) {
#line 5957
      return (s);
    }
    {
#line 5958
    tmp___1 = unmeta((char const   *)s);
#line 5958
    tmp___2 = access((char const   *)tmp___1, 1);
    }
#line 5958
    if (tmp___2 == 0) {
#line 5959
      return ((char *)((void *)0));
    }
#line 5960
    if (! nocdpath) {
#line 5961
      cp = cdpath;
      {
#line 5961
      while (1) {
        while_continue: /* CIL Label */ ;
#line 5961
        if (! *cp) {
#line 5961
          goto while_break;
        }
        {
#line 5962
        tmp___3 = strlen((char const   *)*cp);
#line 5962
        tmp___4 = strlen((char const   *)s);
        }
#line 5962
        if ((tmp___3 + tmp___4) + 1UL >= 4096UL) {
#line 5963
          goto __Cont;
        }
#line 5964
        if (*(*cp)) {
          {
#line 5965
          sprintf((char */* __restrict  */)(sbuf), (char const   */* __restrict  */)"%s/%s",
                  *cp, s);
          }
        } else {
          {
#line 5967
          strcpy((char */* __restrict  */)(sbuf), (char const   */* __restrict  */)s);
          }
        }
        {
#line 5968
        tmp___6 = cancd2(sbuf);
        }
#line 5968
        if (tmp___6) {
          {
#line 5969
          doprintdir = -1;
#line 5970
          tmp___5 = dupstring((char const   *)(sbuf));
          }
#line 5970
          return (tmp___5);
        }
        __Cont: /* CIL Label */ 
#line 5961
        cp ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 5973
    t = cd_able_vars(s);
    }
#line 5973
    if (t) {
      {
#line 5974
      tmp___7 = cancd2(t);
      }
#line 5974
      if (tmp___7) {
#line 5975
        doprintdir = -1;
#line 5976
        return (t);
      }
    }
#line 5979
    return ((char *)((void *)0));
  }
  {
#line 5981
  tmp___10 = cancd2(s);
  }
#line 5981
  if (tmp___10) {
#line 5981
    tmp___9 = s;
  } else {
#line 5981
    tmp___9 = (char *)((void *)0);
  }
#line 5981
  return (tmp___9);
}
}
#line 5985 "/tmp/zsh-5.4.2/Src/exec.c"
static int cancd2(char *s ) 
{ 
  struct stat buf___7 ;
  char *us ;
  char *us2 ;
  int ret ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 5989
  us2 = (char *)((void *)0);
#line 5997
  if (! opts[30]) {
#line 5997
    if (! opts[31]) {
#line 5998
      if ((int )*s != 47) {
#line 5999
        if (*(pwd + 1)) {
#line 5999
          tmp = (char const   *)pwd;
        } else {
#line 5999
          tmp = "";
        }
        {
#line 5999
        us = tricat(tmp, "/", (char const   *)s);
        }
      } else {
        {
#line 6001
        us = ztrdup((char const   *)s);
        }
      }
      {
#line 6002
      us2 = us;
#line 6002
      fixdir(us2);
      }
    } else {
      {
#line 6004
      us = unmeta((char const   *)s);
      }
    }
  } else {
    {
#line 6004
    us = unmeta((char const   *)s);
    }
  }
  {
#line 6005
  tmp___0 = access((char const   *)us, 1);
  }
#line 6005
  if (tmp___0) {
#line 6005
    tmp___2 = 0;
  } else {
    {
#line 6005
    tmp___1 = stat((char const   */* __restrict  */)us, (struct stat */* __restrict  */)(& buf___7));
    }
#line 6005
    if (tmp___1) {
#line 6005
      tmp___2 = 0;
    } else
#line 6005
    if (! ((buf___7.st_mode & 61440U) == 16384U)) {
#line 6005
      tmp___2 = 0;
    } else {
#line 6005
      tmp___2 = 1;
    }
  }
#line 6005
  ret = tmp___2;
#line 6006
  if (us2) {
    {
#line 6007
    free((void *)us2);
    }
  }
#line 6008
  return (ret);
}
}
#line 6012 "/tmp/zsh-5.4.2/Src/exec.c"
void execsave(void) 
{ 
  struct execstack *es ;
  void *tmp ;

  {
  {
#line 6017
  tmp = zalloc(sizeof(struct execstack ));
#line 6017
  es = (struct execstack *)tmp;
#line 6018
  es->list_pipe_pid = list_pipe_pid;
#line 6019
  es->nowait = nowait;
#line 6020
  es->pline_level = pline_level;
#line 6021
  es->list_pipe_child = list_pipe_child;
#line 6022
  es->list_pipe_job = list_pipe_job;
#line 6023
  strcpy((char */* __restrict  */)(es->list_pipe_text), (char const   */* __restrict  */)(list_pipe_text));
#line 6024
  es->lastval = (int )lastval;
#line 6025
  es->noeval = noeval;
#line 6026
  es->badcshglob = badcshglob;
#line 6027
  es->cmdoutpid = cmdoutpid;
#line 6028
  es->cmdoutval = cmdoutval;
#line 6029
  es->use_cmdoutval = use_cmdoutval;
#line 6030
  es->trap_return = trap_return;
#line 6031
  es->trap_state = trap_state;
#line 6032
  es->trapisfunc = trapisfunc;
#line 6033
  es->traplocallevel = traplocallevel;
#line 6034
  es->noerrs = noerrs;
#line 6035
  es->this_noerrexit = this_noerrexit;
#line 6036
  es->underscore = ztrdup((char const   *)zunderscore);
#line 6037
  es->next = exstack;
#line 6038
  exstack = es;
#line 6039
  cmdoutpid = 0;
#line 6039
  noerrs = cmdoutpid;
  }
#line 6040
  return;
}
}
#line 6043 "/tmp/zsh-5.4.2/Src/exec.c"
void execrestore(void) 
{ 
  struct execstack *en ;
  sigset_t oset ;

  {
  {
#line 6046
  en = exstack;
#line 6050
  queueing_enabled ++;
#line 6051
  exstack = exstack->next;
#line 6053
  list_pipe_pid = en->list_pipe_pid;
#line 6054
  nowait = en->nowait;
#line 6055
  pline_level = en->pline_level;
#line 6056
  list_pipe_child = en->list_pipe_child;
#line 6057
  list_pipe_job = en->list_pipe_job;
#line 6058
  strcpy((char */* __restrict  */)(list_pipe_text), (char const   */* __restrict  */)(en->list_pipe_text));
#line 6059
  lastval = (zlong )en->lastval;
#line 6060
  noeval = en->noeval;
#line 6061
  badcshglob = en->badcshglob;
#line 6062
  cmdoutpid = en->cmdoutpid;
#line 6063
  cmdoutval = en->cmdoutval;
#line 6064
  use_cmdoutval = en->use_cmdoutval;
#line 6065
  trap_return = en->trap_return;
#line 6066
  trap_state = en->trap_state;
#line 6067
  trapisfunc = en->trapisfunc;
#line 6068
  traplocallevel = en->traplocallevel;
#line 6069
  noerrs = en->noerrs;
#line 6070
  this_noerrexit = en->this_noerrexit;
#line 6071
  setunderscore(en->underscore);
#line 6072
  zsfree(en->underscore);
#line 6073
  free((void *)en);
  }
  {
#line 6075
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6075
    queueing_enabled --;
#line 6075
    if (! queueing_enabled) {
      {
#line 6075
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 6075
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 6075
          if (! (queue_front != queue_rear)) {
#line 6075
            goto while_break___1;
          }
          {
#line 6075
          queue_front = (queue_front + 1) % 128;
#line 6075
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 6075
          zhandler(signal_queue[queue_front]);
#line 6075
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 6075
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 6075
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 6076
  return;
}
}
#line 46 "/tmp/zsh-5.4.2/Src/context.c"
static struct context_stack *cstack  ;
#line 51 "/tmp/zsh-5.4.2/Src/context.c"
void zcontext_save_partial(int parts ) 
{ 
  struct context_stack *cs ;
  void *tmp ;
  sigset_t oset ;

  {
  {
#line 56
  queueing_enabled ++;
#line 58
  tmp = malloc(sizeof(struct context_stack ));
#line 58
  cs = (struct context_stack *)tmp;
  }
#line 60
  if (parts & 1) {
    {
#line 61
    hist_context_save(& cs->hist_stack, ! cstack);
    }
  }
#line 63
  if (parts & 2) {
    {
#line 64
    lex_context_save(& cs->lex_stack, ! cstack);
    }
  }
#line 66
  if (parts & 4) {
    {
#line 67
    parse_context_save(& cs->parse_stack, ! cstack);
    }
  }
#line 70
  cs->next = cstack;
#line 71
  cstack = cs;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    queueing_enabled --;
#line 73
    if (! queueing_enabled) {
      {
#line 73
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 73
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 73
          if (! (queue_front != queue_rear)) {
#line 73
            goto while_break___1;
          }
          {
#line 73
          queue_front = (queue_front + 1) % 128;
#line 73
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 73
          zhandler(signal_queue[queue_front]);
#line 73
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 73
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 73
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 79 "/tmp/zsh-5.4.2/Src/context.c"
void zcontext_save(void) 
{ 


  {
  {
#line 82
  zcontext_save_partial(7);
  }
#line 83
  return;
}
}
#line 88 "/tmp/zsh-5.4.2/Src/context.c"
void zcontext_restore_partial(int parts ) 
{ 
  struct context_stack *cs ;
  sigset_t oset ;

  {
#line 91
  cs = cstack;
#line 95
  queueing_enabled ++;
#line 96
  cstack = cstack->next;
#line 98
  if (parts & 1) {
    {
#line 99
    hist_context_restore((struct hist_stack  const  *)(& cs->hist_stack), ! cstack);
    }
  }
#line 101
  if (parts & 2) {
    {
#line 102
    lex_context_restore((struct lex_stack  const  *)(& cs->lex_stack), ! cstack);
    }
  }
#line 104
  if (parts & 4) {
    {
#line 105
    parse_context_restore((struct parse_stack  const  *)(& cs->parse_stack), ! cstack);
    }
  }
  {
#line 108
  free((void *)cs);
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    queueing_enabled --;
#line 110
    if (! queueing_enabled) {
      {
#line 110
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 110
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 110
          if (! (queue_front != queue_rear)) {
#line 110
            goto while_break___1;
          }
          {
#line 110
          queue_front = (queue_front + 1) % 128;
#line 110
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 110
          zhandler(signal_queue[queue_front]);
#line 110
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 110
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 110
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 116 "/tmp/zsh-5.4.2/Src/context.c"
void zcontext_restore(void) 
{ 


  {
  {
#line 119
  zcontext_restore_partial(7);
  }
#line 120
  return;
}
}
#line 5 "./cond.epro"
int tracingcond  ;
#line 7
char *cond_str(char **args , int num , int raw___0 ) ;
#line 8
zlong cond_val(char **args , int num ) ;
#line 9
int cond_match(char **args , int num , char *str ) ;
#line 2 "./cond.pro"
static int doaccess(char *s , int c ) ;
#line 3
static struct stat *getstat(char *s ) ;
#line 4
static mode_t dostat(char *s ) ;
#line 5
static mode_t dolstat(char *s ) ;
#line 6
static int optison(char *name , char *s ) ;
#line 7
static void tracemodcond(char *name , char **args , int inf ) ;
#line 36 "/tmp/zsh-5.4.2/Src/cond.c"
static char *condstr[18]  = 
#line 36 "/tmp/zsh-5.4.2/Src/cond.c"
  {      (char *)"!",      (char *)"&&",      (char *)"||",      (char *)"=", 
        (char *)"==",      (char *)"!=",      (char *)"<",      (char *)">", 
        (char *)"-nt",      (char *)"-ot",      (char *)"-ef",      (char *)"-eq", 
        (char *)"-ne",      (char *)"-lt",      (char *)"-gt",      (char *)"-le", 
        (char *)"-ge",      (char *)"=~"};
#line 41 "/tmp/zsh-5.4.2/Src/cond.c"
static void cond_subst(char **strp , int glob_ok ) 
{ 
  LinkList args ;
  LinkList tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 43
  if (glob_ok) {
    {
#line 43
    tmp___2 = strlen((char const   *)*strp);
#line 43
    tmp___3 = checkglobqual(*strp, (int )tmp___2, 1, (char **)((void *)0));
    }
#line 43
    if (tmp___3) {
      {
#line 45
      tmp = newlinklist();
#line 45
      args = tmp;
#line 46
      insertlinknode(args, args->list.last, (void *)*strp);
#line 47
      prefork(args, 0, (int *)((void *)0));
      }
      {
#line 48
      while (1) {
        while_continue: /* CIL Label */ ;
#line 48
        if (! errflag) {
#line 48
          if (args) {
#line 48
            if ((unsigned long )args->list.first != (unsigned long )((void *)0)) {
              {
#line 48
              tmp___0 = has_token((char const   *)((char *)(args->list.first)->dat));
              }
#line 48
              if (! tmp___0) {
#line 48
                goto while_break;
              }
            } else {
#line 48
              goto while_break;
            }
          } else {
#line 48
            goto while_break;
          }
        } else {
#line 48
          goto while_break;
        }
        {
#line 50
        zglob(args, args->list.first, 0);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 51
      tmp___1 = hlinklist2array(args, 0);
#line 51
      *strp = sepjoin(tmp___1, (char *)((void *)0), 1);
      }
    } else {
      {
#line 53
      singsub(strp);
      }
    }
  } else {
    {
#line 53
    singsub(strp);
    }
  }
#line 54
  return;
}
}
#line 68 "/tmp/zsh-5.4.2/Src/cond.c"
int evalcond(Estate state , char *fromtest ) 
{ 
  struct stat *st___0 ;
  char *left ;
  char *right ;
  char *overridename ;
  char overridebuf[13] ;
  Wordcode pcode ;
  wordcode code ;
  int ctype ;
  int htok ;
  int ret ;
  Wordcode tmp ;
  char *modname ;
  char const   *tmp___0 ;
  Conddef cd ;
  char *name ;
  char *errname ;
  char **strs ;
  int l ;
  char *sbuf[3] ;
  int tmp___1 ;
  int tmp___2 ;
  char *s ;
  int tmp___3 ;
  int tmp___4 ;
  char *rt ;
  char *tmp___5 ;
  char *tmp___6 ;
  mnumber mn1 ;
  mnumber mn2 ;
  char *eptr ;
  char *err ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int test ;
  int npat ;
  Patprog pprog ;
  char *opat ;
  int save ;
  int tmp___19 ;
  int tmp___20 ;
  sigset_t oset ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  sigset_t oset___0 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  mode_t tmp___32 ;
  int tmp___33 ;
  mode_t tmp___34 ;
  int tmp___35 ;
  mode_t tmp___36 ;
  int tmp___37 ;
  mode_t tmp___38 ;
  int tmp___39 ;
  mode_t tmp___40 ;
  int tmp___41 ;
  mode_t tmp___42 ;
  int tmp___43 ;
  size_t tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  mode_t tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  mode_t tmp___52 ;
  int tmp___53 ;
  mode_t tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  mode_t mode ;
  mode_t tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  size_t tmp___65 ;
  int tmp___66 ;
  mode_t tmp___67 ;
  int tmp___68 ;
  __uid_t tmp___69 ;
  int tmp___70 ;
  __gid_t tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  zlong tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  time_t a ;
  long nsecs ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  dev_t d___0 ;
  ino_t i ;
  int tmp___81 ;

  {
#line 75
  htok = 0;
  rec: 
#line 79
  overridename = (char *)((void *)0);
#line 79
  right = overridename;
#line 79
  left = right;
#line 80
  tmp = state->pc;
#line 80
  (state->pc) ++;
#line 80
  pcode = tmp;
#line 81
  code = *pcode;
#line 82
  ctype = (int )((code >> 5) & 127U);
  {
#line 85
  if (ctype == 0) {
#line 85
    goto case_0;
  }
#line 93
  if (ctype == 1) {
#line 93
    goto case_1;
  }
#line 102
  if (ctype == 2) {
#line 102
    goto case_2;
  }
#line 111
  if (ctype == 17) {
#line 111
    goto case_17;
  }
#line 120
  if (ctype == 19) {
#line 120
    goto case_19;
  }
#line 120
  if (ctype == 18) {
#line 120
    goto case_19;
  }
#line 84
  goto switch_break;
  case_0: /* CIL Label */ 
#line 86
  if (tracingcond) {
    {
#line 87
    fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)" %s",
            condstr[ctype]);
    }
  }
  {
#line 88
  ret = evalcond(state, fromtest);
  }
#line 89
  if (ret == 2) {
#line 90
    return (ret);
  } else {
#line 92
    return (! ret);
  }
  case_1: /* CIL Label */ 
  {
#line 94
  ret = evalcond(state, fromtest);
  }
#line 94
  if (ret) {
#line 99
    state->pc = pcode + (((code >> 5) >> 7) + 1U);
#line 100
    return (ret);
  } else {
#line 95
    if (tracingcond) {
      {
#line 96
      fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)" %s",
              condstr[ctype]);
      }
    }
#line 97
    goto rec;
  }
  case_2: /* CIL Label */ 
  {
#line 103
  ret = evalcond(state, fromtest);
  }
#line 103
  if (ret == 1) {
#line 104
    if (tracingcond) {
      {
#line 105
      fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)" %s",
              condstr[ctype]);
      }
    }
#line 106
    goto rec;
  } else {
#line 108
    state->pc = pcode + (((code >> 5) >> 7) + 1U);
#line 109
    return (ret);
  }
  case_17: /* CIL Label */ 
#line 113
  if (opts[153]) {
#line 113
    tmp___0 = "zsh/pcre";
  } else {
#line 113
    tmp___0 = "zsh/regex";
  }
  {
#line 113
  modname = (char *)tmp___0;
#line 114
  overridename = overridebuf;
#line 114
  sprintf((char */* __restrict  */)overridename, (char const   */* __restrict  */)"-%s-match",
          modname + 4);
#line 115
  ensurefeature((char const   *)modname, "C:", (char const   *)(overridename + 1));
#line 116
  ctype = 19;
  }
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 123
  name = overridename;
#line 125
  l = (int )((code >> 5) >> 7);
#line 127
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 128
    name = ecgetstr(state, 0, (int *)((void *)0));
    }
  }
#line 129
  if (ctype == 18) {
    {
#line 130
    strs = ecgetarr(state, l, 1, (int *)((void *)0));
    }
  } else {
    {
#line 134
    sbuf[0] = ecgetstr(state, 0, (int *)((void *)0));
#line 135
    sbuf[1] = ecgetstr(state, 0, (int *)((void *)0));
#line 136
    sbuf[2] = (char *)((void *)0);
#line 138
    strs = arrdup(sbuf);
#line 139
    l = 2;
    }
  }
#line 141
  if (name) {
#line 141
    if ((int )*(name + 0) == 45) {
      {
#line 142
      errname = dupstring((char const   *)name);
#line 142
      untokenize(errname);
      }
    } else
#line 141
    if ((int )*(name + 0) == -101) {
      {
#line 142
      errname = dupstring((char const   *)name);
#line 142
      untokenize(errname);
      }
    } else {
#line 141
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 143
  if (*(strs + 0)) {
#line 143
    if ((int )*(*(strs + 0)) == 45) {
      {
#line 144
      errname = *(strs + 0);
#line 144
      untokenize(errname);
      }
    } else
#line 143
    if ((int )*(*(strs + 0)) == -101) {
      {
#line 144
      errname = *(strs + 0);
#line 144
      untokenize(errname);
      }
    } else {
#line 146
      errname = (char *)"<null>";
    }
  } else {
#line 146
    errname = (char *)"<null>";
  }
#line 147
  if (name) {
#line 147
    if ((int )*(name + 0) == 45) {
#line 147
      goto _L___3;
    } else
#line 147
    if ((int )*(name + 0) == -101) {
      _L___3: /* CIL Label */ 
      {
#line 147
      cd = getconddef(ctype == 19, (char const   *)(name + 1), 1);
      }
#line 147
      if (cd) {
#line 149
        if (ctype == 18) {
#line 149
          if (l < cd->min) {
            {
#line 151
            zwarnnam((char const   *)fromtest, "unknown condition: %s", name);
            }
#line 152
            return (2);
          } else
#line 149
          if (cd->max >= 0) {
#line 149
            if (l > cd->max) {
              {
#line 151
              zwarnnam((char const   *)fromtest, "unknown condition: %s", name);
              }
#line 152
              return (2);
            }
          }
        }
#line 154
        if (tracingcond) {
          {
#line 155
          tracemodcond(name, strs, ctype == 19);
          }
        }
        {
#line 156
        tmp___1 = (*(cd->handler))(strs, cd->condid);
        }
#line 156
        if (tmp___1) {
#line 156
          tmp___2 = 0;
        } else {
#line 156
          tmp___2 = 1;
        }
#line 156
        return (tmp___2);
      } else {
#line 147
        goto _L___2;
      }
    } else {
#line 147
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 159
    s = *(strs + 0);
#line 161
    if (overridename) {
      {
#line 166
      zerrnam((char const   *)fromtest, "%s not available for regex", overridename);
      }
#line 168
      return (2);
    }
    {
#line 171
    *(strs + 0) = dupstring((char const   *)name);
#line 172
    name = s;
    }
#line 174
    if (name) {
#line 174
      if ((int )*(name + 0) == 45) {
#line 174
        goto _L___0;
      } else
#line 174
      if ((int )*(name + 0) == -101) {
        _L___0: /* CIL Label */ 
        {
#line 174
        cd = getconddef(0, (char const   *)(name + 1), 1);
        }
#line 174
        if (cd) {
#line 176
          if (l < cd->min) {
            {
#line 177
            zwarnnam((char const   *)fromtest, "unknown condition: %s", errname);
            }
#line 179
            return (2);
          } else
#line 176
          if (cd->max >= 0) {
#line 176
            if (l > cd->max) {
              {
#line 177
              zwarnnam((char const   *)fromtest, "unknown condition: %s", errname);
              }
#line 179
              return (2);
            }
          }
#line 181
          if (tracingcond) {
            {
#line 182
            tracemodcond(name, strs, ctype == 19);
            }
          }
          {
#line 183
          tmp___3 = (*(cd->handler))(strs, cd->condid);
          }
#line 183
          if (tmp___3) {
#line 183
            tmp___4 = 0;
          } else {
#line 183
            tmp___4 = 1;
          }
#line 183
          return (tmp___4);
        } else {
          {
#line 185
          zwarnnam((char const   *)fromtest, "unknown condition: %s", errname);
          }
        }
      } else {
        {
#line 185
        zwarnnam((char const   *)fromtest, "unknown condition: %s", errname);
        }
      }
    } else {
      {
#line 185
      zwarnnam((char const   *)fromtest, "unknown condition: %s", errname);
      }
    }
  }
#line 191
  return (2);
  switch_break: /* CIL Label */ ;
  }
  {
#line 194
  left = ecgetstr(state, 2, & htok);
  }
#line 195
  if (htok) {
    {
#line 196
    cond_subst(& left, ! fromtest);
#line 197
    untokenize(left);
    }
  }
#line 199
  if (ctype <= 16) {
#line 199
    if (ctype != 3) {
#line 199
      if (ctype != 4) {
#line 199
        if (ctype != 5) {
          {
#line 201
          right = ecgetstr(state, 2, & htok);
          }
#line 202
          if (htok) {
            {
#line 203
            cond_subst(& right, ! fromtest);
#line 204
            untokenize(right);
            }
          }
        }
      }
    }
  }
#line 207
  if (tracingcond) {
#line 208
    if (ctype < 18) {
      {
#line 209
      fputc(' ', xtrerr);
#line 210
      quotedzputs((char const   *)left, xtrerr);
#line 211
      fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)" %s ",
              condstr[ctype]);
      }
#line 212
      if (ctype == 3) {
        {
#line 214
        tmp___5 = ecrawstr(state->prog, state->pc, (int *)((void *)0));
#line 214
        tmp___6 = dupstring((char const   *)tmp___5);
#line 214
        rt = tmp___6;
#line 215
        cond_subst(& rt, ! fromtest);
#line 216
        quote_tokenized_output(rt, xtrerr);
        }
      } else
#line 212
      if (ctype == 4) {
        {
#line 214
        tmp___5 = ecrawstr(state->prog, state->pc, (int *)((void *)0));
#line 214
        tmp___6 = dupstring((char const   *)tmp___5);
#line 214
        rt = tmp___6;
#line 215
        cond_subst(& rt, ! fromtest);
#line 216
        quote_tokenized_output(rt, xtrerr);
        }
      } else
#line 212
      if (ctype == 5) {
        {
#line 214
        tmp___5 = ecrawstr(state->prog, state->pc, (int *)((void *)0));
#line 214
        tmp___6 = dupstring((char const   *)tmp___5);
#line 214
        rt = tmp___6;
#line 215
        cond_subst(& rt, ! fromtest);
#line 216
        quote_tokenized_output(rt, xtrerr);
        }
      } else {
        {
#line 219
        quotedzputs((char const   *)right, xtrerr);
        }
      }
    } else {
      {
#line 221
      fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)" -%c ",
              ctype);
#line 222
      quotedzputs((char const   *)left, xtrerr);
      }
    }
  }
#line 226
  if (ctype >= 11) {
#line 226
    if (ctype <= 16) {
#line 228
      if (fromtest) {
        {
#line 235
        mn1.u.l = zstrtol((char const   *)left, & eptr, 10);
        }
#line 236
        if (! *eptr) {
          {
#line 238
          mn2.u.l = zstrtol((char const   *)right, & eptr, 10);
#line 239
          err = right;
          }
        } else {
#line 242
          err = left;
        }
#line 244
        if (*eptr) {
          {
#line 246
          zwarnnam((char const   *)fromtest, "integer expression expected: %s", err);
          }
#line 247
          return (2);
        }
#line 250
        mn2.type = 1;
#line 250
        mn1.type = mn2.type;
      } else {
        {
#line 252
        mn1 = matheval(left);
#line 253
        mn2 = matheval(right);
        }
      }
#line 256
      if (((mn1.type | mn2.type) & 3) == 3) {
#line 259
        if (mn1.type & 1) {
#line 260
          mn1.type = 2;
#line 261
          mn1.u.d = (double )mn1.u.l;
        }
#line 263
        if (mn2.type & 1) {
#line 264
          mn2.type = 2;
#line 265
          mn2.u.d = (double )mn2.u.l;
        }
      }
      {
#line 269
      if (ctype == 11) {
#line 269
        goto case_11;
      }
#line 272
      if (ctype == 12) {
#line 272
        goto case_12;
      }
#line 275
      if (ctype == 13) {
#line 275
        goto case_13;
      }
#line 278
      if (ctype == 14) {
#line 278
        goto case_14;
      }
#line 281
      if (ctype == 15) {
#line 281
        goto case_15;
      }
#line 284
      if (ctype == 16) {
#line 284
        goto case_16;
      }
#line 268
      goto switch_break___0;
      case_11: /* CIL Label */ 
#line 270
      if (mn1.type & 2) {
#line 270
        tmp___7 = mn1.u.d == mn2.u.d;
      } else {
#line 270
        tmp___7 = mn1.u.l == mn2.u.l;
      }
#line 270
      if (tmp___7) {
#line 270
        tmp___8 = 0;
      } else {
#line 270
        tmp___8 = 1;
      }
#line 270
      return (tmp___8);
      case_12: /* CIL Label */ 
#line 273
      if (mn1.type & 2) {
#line 273
        tmp___9 = mn1.u.d != mn2.u.d;
      } else {
#line 273
        tmp___9 = mn1.u.l != mn2.u.l;
      }
#line 273
      if (tmp___9) {
#line 273
        tmp___10 = 0;
      } else {
#line 273
        tmp___10 = 1;
      }
#line 273
      return (tmp___10);
      case_13: /* CIL Label */ 
#line 276
      if (mn1.type & 2) {
#line 276
        tmp___11 = mn1.u.d < mn2.u.d;
      } else {
#line 276
        tmp___11 = mn1.u.l < mn2.u.l;
      }
#line 276
      if (tmp___11) {
#line 276
        tmp___12 = 0;
      } else {
#line 276
        tmp___12 = 1;
      }
#line 276
      return (tmp___12);
      case_14: /* CIL Label */ 
#line 279
      if (mn1.type & 2) {
#line 279
        tmp___13 = mn1.u.d > mn2.u.d;
      } else {
#line 279
        tmp___13 = mn1.u.l > mn2.u.l;
      }
#line 279
      if (tmp___13) {
#line 279
        tmp___14 = 0;
      } else {
#line 279
        tmp___14 = 1;
      }
#line 279
      return (tmp___14);
      case_15: /* CIL Label */ 
#line 282
      if (mn1.type & 2) {
#line 282
        tmp___15 = mn1.u.d <= mn2.u.d;
      } else {
#line 282
        tmp___15 = mn1.u.l <= mn2.u.l;
      }
#line 282
      if (tmp___15) {
#line 282
        tmp___16 = 0;
      } else {
#line 282
        tmp___16 = 1;
      }
#line 282
      return (tmp___16);
      case_16: /* CIL Label */ 
#line 285
      if (mn1.type & 2) {
#line 285
        tmp___17 = mn1.u.d >= mn2.u.d;
      } else {
#line 285
        tmp___17 = mn1.u.l >= mn2.u.l;
      }
#line 285
      if (tmp___17) {
#line 285
        tmp___18 = 0;
      } else {
#line 285
        tmp___18 = 1;
      }
#line 285
      return (tmp___18);
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 293
  if (ctype == 5) {
#line 293
    goto case_5;
  }
#line 293
  if (ctype == 4) {
#line 293
    goto case_5;
  }
#line 293
  if (ctype == 3) {
#line 293
    goto case_5;
  }
#line 326
  if (ctype == 6) {
#line 326
    goto case_6;
  }
#line 328
  if (ctype == 7) {
#line 328
    goto case_7;
  }
#line 331
  if (ctype == 97) {
#line 331
    goto case_97;
  }
#line 331
  if (ctype == 101) {
#line 331
    goto case_97;
  }
#line 333
  if (ctype == 98) {
#line 333
    goto case_98;
  }
#line 335
  if (ctype == 99) {
#line 335
    goto case_99;
  }
#line 337
  if (ctype == 100) {
#line 337
    goto case_100;
  }
#line 339
  if (ctype == 102) {
#line 339
    goto case_102;
  }
#line 341
  if (ctype == 103) {
#line 341
    goto case_103;
  }
#line 343
  if (ctype == 107) {
#line 343
    goto case_107;
  }
#line 345
  if (ctype == 110) {
#line 345
    goto case_110;
  }
#line 347
  if (ctype == 111) {
#line 347
    goto case_111;
  }
#line 349
  if (ctype == 112) {
#line 349
    goto case_112;
  }
#line 351
  if (ctype == 114) {
#line 351
    goto case_114;
  }
#line 353
  if (ctype == 115) {
#line 353
    goto case_115;
  }
#line 355
  if (ctype == 83) {
#line 355
    goto case_83;
  }
#line 357
  if (ctype == 117) {
#line 357
    goto case_117;
  }
#line 359
  if (ctype == 118) {
#line 359
    goto case_118;
  }
#line 361
  if (ctype == 119) {
#line 361
    goto case_119;
  }
#line 363
  if (ctype == 120) {
#line 363
    goto case_120;
  }
#line 369
  if (ctype == 122) {
#line 369
    goto case_122;
  }
#line 372
  if (ctype == 76) {
#line 372
    goto case_76;
  }
#line 372
  if (ctype == 104) {
#line 372
    goto case_76;
  }
#line 374
  if (ctype == 79) {
#line 374
    goto case_79;
  }
#line 376
  if (ctype == 71) {
#line 376
    goto case_71;
  }
#line 378
  if (ctype == 78) {
#line 378
    goto case_78;
  }
#line 388
  if (ctype == 116) {
#line 388
    goto case_116;
  }
#line 391
  if (ctype == 9) {
#line 391
    goto case_9;
  }
#line 391
  if (ctype == 8) {
#line 391
    goto case_9;
  }
#line 414
  if (ctype == 10) {
#line 414
    goto case_10;
  }
#line 427
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 295
  npat = (int )*(state->pc + 1);
#line 296
  pprog = *((state->prog)->pats + npat);
#line 298
  queueing_enabled ++;
#line 300
  if ((unsigned long )pprog == (unsigned long )((Patprog )1)) {
#line 300
    goto _L___4;
  } else
#line 300
  if ((unsigned long )pprog == (unsigned long )((Patprog )2)) {
    _L___4: /* CIL Label */ 
    {
#line 304
    opat = ecrawstr(state->prog, state->pc, & htok);
#line 304
    right = dupstring((char const   *)opat);
#line 306
    singsub(& right);
    }
#line 307
    if (! ((state->prog)->flags & 2)) {
      {
#line 307
      tmp___19 = strcmp((char const   *)opat, (char const   *)right);
      }
#line 307
      if (tmp___19) {
#line 307
        tmp___20 = 0;
      } else
#line 307
      if ((unsigned long )pprog != (unsigned long )((Patprog )2)) {
#line 307
        tmp___20 = 1;
      } else {
#line 307
        tmp___20 = 0;
      }
    } else {
#line 307
      tmp___20 = 0;
    }
#line 307
    save = tmp___20;
#line 310
    if (save) {
#line 310
      tmp___21 = 256;
    } else {
#line 310
      tmp___21 = 64;
    }
    {
#line 310
    pprog = patcompile(right, tmp___21, (char **)((void *)0));
    }
#line 310
    if (pprog) {
#line 316
      if (save) {
#line 317
        *((state->prog)->pats + npat) = pprog;
      }
    } else {
      {
#line 312
      zwarnnam((char const   *)fromtest, "bad pattern: %s", right);
      }
      {
#line 313
      while (1) {
        while_continue: /* CIL Label */ ;
#line 313
        queueing_enabled --;
#line 313
        if (! queueing_enabled) {
          {
#line 313
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 313
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 313
              if (! (queue_front != queue_rear)) {
#line 313
                goto while_break___1;
              }
              {
#line 313
              queue_front = (queue_front + 1) % 128;
#line 313
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 313
              zhandler(signal_queue[queue_front]);
#line 313
              signal_setmask(oset);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 313
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 313
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 314
      return (2);
    }
  }
#line 319
  state->pc += 2;
#line 320
  if (pprog) {
    {
#line 320
    tmp___22 = pattry(pprog, left);
    }
#line 320
    if (tmp___22) {
#line 320
      tmp___23 = 1;
    } else {
#line 320
      tmp___23 = 0;
    }
  } else {
#line 320
    tmp___23 = 0;
  }
#line 320
  test = tmp___23;
  {
#line 322
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 322
    queueing_enabled --;
#line 322
    if (! queueing_enabled) {
      {
#line 322
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 322
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 322
          if (! (queue_front != queue_rear)) {
#line 322
            goto while_break___4;
          }
          {
#line 322
          queue_front = (queue_front + 1) % 128;
#line 322
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 322
          zhandler(signal_queue[queue_front]);
#line 322
          signal_setmask(oset___0);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 322
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 322
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 324
  if (ctype == 5) {
#line 324
    tmp___24 = ! test;
  } else {
#line 324
    tmp___24 = test;
  }
#line 324
  if (tmp___24) {
#line 324
    tmp___25 = 0;
  } else {
#line 324
    tmp___25 = 1;
  }
#line 324
  return (tmp___25);
  case_6: /* CIL Label */ 
  {
#line 327
  tmp___26 = strcmp((char const   *)left, (char const   *)right);
  }
#line 327
  if (tmp___26 < 0) {
#line 327
    tmp___27 = 0;
  } else {
#line 327
    tmp___27 = 1;
  }
#line 327
  return (tmp___27);
  case_7: /* CIL Label */ 
  {
#line 329
  tmp___28 = strcmp((char const   *)left, (char const   *)right);
  }
#line 329
  if (tmp___28 > 0) {
#line 329
    tmp___29 = 0;
  } else {
#line 329
    tmp___29 = 1;
  }
#line 329
  return (tmp___29);
  case_97: /* CIL Label */ 
  case_101: /* CIL Label */ 
  {
#line 332
  tmp___30 = doaccess(left, 0);
  }
#line 332
  if (tmp___30) {
#line 332
    tmp___31 = 0;
  } else {
#line 332
    tmp___31 = 1;
  }
#line 332
  return (tmp___31);
  case_98: /* CIL Label */ 
  {
#line 334
  tmp___32 = dostat(left);
  }
#line 334
  if ((tmp___32 & 61440U) == 24576U) {
#line 334
    tmp___33 = 0;
  } else {
#line 334
    tmp___33 = 1;
  }
#line 334
  return (tmp___33);
  case_99: /* CIL Label */ 
  {
#line 336
  tmp___34 = dostat(left);
  }
#line 336
  if ((tmp___34 & 61440U) == 8192U) {
#line 336
    tmp___35 = 0;
  } else {
#line 336
    tmp___35 = 1;
  }
#line 336
  return (tmp___35);
  case_100: /* CIL Label */ 
  {
#line 338
  tmp___36 = dostat(left);
  }
#line 338
  if ((tmp___36 & 61440U) == 16384U) {
#line 338
    tmp___37 = 0;
  } else {
#line 338
    tmp___37 = 1;
  }
#line 338
  return (tmp___37);
  case_102: /* CIL Label */ 
  {
#line 340
  tmp___38 = dostat(left);
  }
#line 340
  if ((tmp___38 & 61440U) == 32768U) {
#line 340
    tmp___39 = 0;
  } else {
#line 340
    tmp___39 = 1;
  }
#line 340
  return (tmp___39);
  case_103: /* CIL Label */ 
  {
#line 342
  tmp___40 = dostat(left);
  }
#line 342
  if (tmp___40 & 1024U) {
#line 342
    tmp___41 = 0;
  } else {
#line 342
    tmp___41 = 1;
  }
#line 342
  return (tmp___41);
  case_107: /* CIL Label */ 
  {
#line 344
  tmp___42 = dostat(left);
  }
#line 344
  if (tmp___42 & 512U) {
#line 344
    tmp___43 = 0;
  } else {
#line 344
    tmp___43 = 1;
  }
#line 344
  return (tmp___43);
  case_110: /* CIL Label */ 
  {
#line 346
  tmp___44 = strlen((char const   *)left);
  }
#line 346
  if (tmp___44) {
#line 346
    tmp___45 = 0;
  } else {
#line 346
    tmp___45 = 1;
  }
#line 346
  return (tmp___45);
  case_111: /* CIL Label */ 
  {
#line 348
  tmp___46 = optison(fromtest, left);
  }
#line 348
  return (tmp___46);
  case_112: /* CIL Label */ 
  {
#line 350
  tmp___47 = dostat(left);
  }
#line 350
  if ((tmp___47 & 61440U) == 4096U) {
#line 350
    tmp___48 = 0;
  } else {
#line 350
    tmp___48 = 1;
  }
#line 350
  return (tmp___48);
  case_114: /* CIL Label */ 
  {
#line 352
  tmp___49 = doaccess(left, 4);
  }
#line 352
  if (tmp___49) {
#line 352
    tmp___50 = 0;
  } else {
#line 352
    tmp___50 = 1;
  }
#line 352
  return (tmp___50);
  case_115: /* CIL Label */ 
  {
#line 354
  st___0 = getstat(left);
  }
#line 354
  if (st___0) {
#line 354
    if (! (! st___0->st_size)) {
#line 354
      tmp___51 = 0;
    } else {
#line 354
      tmp___51 = 1;
    }
  } else {
#line 354
    tmp___51 = 1;
  }
#line 354
  return (tmp___51);
  case_83: /* CIL Label */ 
  {
#line 356
  tmp___52 = dostat(left);
  }
#line 356
  if ((tmp___52 & 61440U) == 49152U) {
#line 356
    tmp___53 = 0;
  } else {
#line 356
    tmp___53 = 1;
  }
#line 356
  return (tmp___53);
  case_117: /* CIL Label */ 
  {
#line 358
  tmp___54 = dostat(left);
  }
#line 358
  if (tmp___54 & 2048U) {
#line 358
    tmp___55 = 0;
  } else {
#line 358
    tmp___55 = 1;
  }
#line 358
  return (tmp___55);
  case_118: /* CIL Label */ 
  {
#line 360
  tmp___56 = issetvar(left);
  }
#line 360
  if (tmp___56) {
#line 360
    tmp___57 = 0;
  } else {
#line 360
    tmp___57 = 1;
  }
#line 360
  return (tmp___57);
  case_119: /* CIL Label */ 
  {
#line 362
  tmp___58 = doaccess(left, 2);
  }
#line 362
  if (tmp___58) {
#line 362
    tmp___59 = 0;
  } else {
#line 362
    tmp___59 = 1;
  }
#line 362
  return (tmp___59);
  case_120: /* CIL Label */ 
  {
#line 364
  tmp___62 = privasserted();
  }
#line 364
  if (tmp___62) {
    {
#line 365
    tmp___60 = dostat(left);
#line 365
    mode = tmp___60;
    }
#line 366
    if (mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 366
      tmp___61 = 0;
    } else
#line 366
    if ((mode & 61440U) == 16384U) {
#line 366
      tmp___61 = 0;
    } else {
#line 366
      tmp___61 = 1;
    }
#line 366
    return (tmp___61);
  }
  {
#line 368
  tmp___63 = doaccess(left, 1);
  }
#line 368
  if (tmp___63) {
#line 368
    tmp___64 = 0;
  } else {
#line 368
    tmp___64 = 1;
  }
#line 368
  return (tmp___64);
  case_122: /* CIL Label */ 
  {
#line 370
  tmp___65 = strlen((char const   *)left);
  }
#line 370
  if (tmp___65) {
#line 370
    tmp___66 = 1;
  } else {
#line 370
    tmp___66 = 0;
  }
#line 370
  return (tmp___66);
  case_76: /* CIL Label */ 
  case_104: /* CIL Label */ 
  {
#line 373
  tmp___67 = dolstat(left);
  }
#line 373
  if ((tmp___67 & 61440U) == 40960U) {
#line 373
    tmp___68 = 0;
  } else {
#line 373
    tmp___68 = 1;
  }
#line 373
  return (tmp___68);
  case_79: /* CIL Label */ 
  {
#line 375
  st___0 = getstat(left);
  }
#line 375
  if (st___0) {
    {
#line 375
    tmp___69 = geteuid();
    }
#line 375
    if (st___0->st_uid == tmp___69) {
#line 375
      tmp___70 = 0;
    } else {
#line 375
      tmp___70 = 1;
    }
  } else {
#line 375
    tmp___70 = 1;
  }
#line 375
  return (tmp___70);
  case_71: /* CIL Label */ 
  {
#line 377
  st___0 = getstat(left);
  }
#line 377
  if (st___0) {
    {
#line 377
    tmp___71 = getegid();
    }
#line 377
    if (st___0->st_gid == tmp___71) {
#line 377
      tmp___72 = 0;
    } else {
#line 377
      tmp___72 = 1;
    }
  } else {
#line 377
    tmp___72 = 1;
  }
#line 377
  return (tmp___72);
  case_78: /* CIL Label */ 
  {
#line 380
  st___0 = getstat(left);
  }
#line 380
  if (! st___0) {
#line 381
    return (1);
  }
#line 382
  if (st___0->st_atim.tv_sec == st___0->st_mtim.tv_sec) {
#line 382
    tmp___73 = st___0->st_atim.tv_nsec > st___0->st_mtim.tv_nsec;
  } else {
#line 382
    tmp___73 = st___0->st_atim.tv_sec > st___0->st_mtim.tv_sec;
  }
#line 382
  return (tmp___73);
  case_116: /* CIL Label */ 
  {
#line 389
  tmp___74 = mathevali(left);
#line 389
  tmp___75 = isatty((int )tmp___74);
  }
#line 389
  if (tmp___75) {
#line 389
    tmp___76 = 0;
  } else {
#line 389
    tmp___76 = 1;
  }
#line 389
  return (tmp___76);
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  {
#line 398
  st___0 = getstat(left);
  }
#line 398
  if (! st___0) {
#line 399
    return (1);
  }
  {
#line 400
  a = st___0->st_mtim.tv_sec;
#line 402
  nsecs = st___0->st_mtim.tv_nsec;
#line 404
  st___0 = getstat(right);
  }
#line 404
  if (! st___0) {
#line 405
    return (1);
  }
#line 407
  if (a == st___0->st_mtim.tv_sec) {
#line 408
    if (ctype == 8) {
#line 408
      tmp___77 = nsecs > st___0->st_mtim.tv_nsec;
    } else {
#line 408
      tmp___77 = nsecs < st___0->st_mtim.tv_nsec;
    }
#line 408
    if (tmp___77) {
#line 408
      tmp___78 = 0;
    } else {
#line 408
      tmp___78 = 1;
    }
#line 408
    return (tmp___78);
  }
#line 412
  if (ctype == 8) {
#line 412
    tmp___79 = a > st___0->st_mtim.tv_sec;
  } else {
#line 412
    tmp___79 = a < st___0->st_mtim.tv_sec;
  }
#line 412
  if (tmp___79) {
#line 412
    tmp___80 = 0;
  } else {
#line 412
    tmp___80 = 1;
  }
#line 412
  return (tmp___80);
  case_10: /* CIL Label */ 
  {
#line 419
  st___0 = getstat(left);
  }
#line 419
  if (! st___0) {
#line 420
    return (1);
  }
  {
#line 421
  d___0 = st___0->st_dev;
#line 422
  i = st___0->st_ino;
#line 423
  st___0 = getstat(right);
  }
#line 423
  if (! st___0) {
#line 424
    return (1);
  }
#line 425
  if (d___0 == st___0->st_dev) {
#line 425
    if (i == st___0->st_ino) {
#line 425
      tmp___81 = 0;
    } else {
#line 425
      tmp___81 = 1;
    }
  } else {
#line 425
    tmp___81 = 1;
  }
#line 425
  return (tmp___81);
  switch_default: /* CIL Label */ 
  {
#line 428
  zwarnnam((char const   *)fromtest, "bad cond code");
  }
#line 429
  return (2);
  switch_break___1: /* CIL Label */ ;
  }
}
}
#line 435 "/tmp/zsh-5.4.2/Src/cond.c"
static int doaccess(char *s , int c ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 442
  tmp = unmeta((char const   *)s);
#line 442
  tmp___0 = access((char const   *)tmp, c);
  }
#line 442
  if (tmp___0) {
#line 442
    tmp___1 = 0;
  } else {
#line 442
    tmp___1 = 1;
  }
#line 442
  return (tmp___1);
}
}
#line 446 "/tmp/zsh-5.4.2/Src/cond.c"
static struct stat st  ;
#line 449 "/tmp/zsh-5.4.2/Src/cond.c"
static struct stat *getstat(char *s ) 
{ 
  char *us ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 456
  tmp___1 = strncmp((char const   *)s, "/dev/fd/", (size_t )8);
  }
#line 456
  if (! tmp___1) {
    {
#line 457
    tmp = atoi((char const   *)(s + 8));
#line 457
    tmp___0 = fstat(tmp, & st);
    }
#line 457
    if (tmp___0) {
#line 458
      return ((struct stat *)((void *)0));
    }
#line 459
    return (& st);
  }
  {
#line 462
  us = unmeta((char const   *)s);
  }
#line 462
  if (! us) {
#line 463
    return ((struct stat *)((void *)0));
  }
  {
#line 464
  tmp___2 = stat((char const   */* __restrict  */)us, (struct stat */* __restrict  */)(& st));
  }
#line 464
  if (tmp___2) {
#line 465
    return ((struct stat *)((void *)0));
  }
#line 466
  return (& st);
}
}
#line 471 "/tmp/zsh-5.4.2/Src/cond.c"
static mode_t dostat(char *s ) 
{ 
  struct stat *statp ;

  {
  {
#line 476
  statp = getstat(s);
  }
#line 476
  if (! statp) {
#line 477
    return ((mode_t )0);
  }
#line 478
  return (statp->st_mode);
}
}
#line 485 "/tmp/zsh-5.4.2/Src/cond.c"
static mode_t dolstat(char *s ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 488
  tmp = unmeta((char const   *)s);
#line 488
  tmp___0 = lstat((char const   */* __restrict  */)tmp, (struct stat */* __restrict  */)(& st));
  }
#line 488
  if (tmp___0 < 0) {
#line 489
    return ((mode_t )0);
  }
#line 490
  return (st.st_mode);
}
}
#line 499 "/tmp/zsh-5.4.2/Src/cond.c"
static int optison(char *name , char *s ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
#line 504
  tmp = strlen((char const   *)s);
  }
#line 504
  if (tmp == 1UL) {
    {
#line 505
    i = optlookupc(*s);
    }
  } else {
    {
#line 507
    i = optlookup((char const   *)s);
    }
  }
#line 508
  if (! i) {
    {
#line 509
    zwarnnam((char const   *)name, "no such option: %s", s);
    }
#line 510
    return (2);
  } else
#line 511
  if (i < 0) {
#line 512
    return (! (! opts[- i]));
  } else {
#line 514
    return (! opts[i]);
  }
}
}
#line 518 "/tmp/zsh-5.4.2/Src/cond.c"
char *cond_str(char **args , int num , int raw___0 ) 
{ 
  char *s ;
  int tmp ;

  {
  {
#line 521
  s = *(args + num);
#line 523
  tmp = has_token((char const   *)s);
  }
#line 523
  if (tmp) {
    {
#line 524
    singsub(& s);
    }
#line 525
    if (! raw___0) {
      {
#line 526
      untokenize(s);
      }
    }
  }
#line 528
  return (s);
}
}
#line 532 "/tmp/zsh-5.4.2/Src/cond.c"
zlong cond_val(char **args , int num ) 
{ 
  char *s ;
  int tmp ;
  zlong tmp___0 ;

  {
  {
#line 535
  s = *(args + num);
#line 537
  tmp = has_token((char const   *)s);
  }
#line 537
  if (tmp) {
    {
#line 538
    singsub(& s);
#line 539
    untokenize(s);
    }
  }
  {
#line 541
  tmp___0 = mathevali(s);
  }
#line 541
  return (tmp___0);
}
}
#line 545 "/tmp/zsh-5.4.2/Src/cond.c"
int cond_match(char **args , int num , char *str ) 
{ 
  char *s ;
  int tmp ;

  {
  {
#line 548
  s = *(args + num);
#line 550
  singsub(& s);
#line 552
  tmp = matchpat(str, s);
  }
#line 552
  return (tmp);
}
}
#line 556 "/tmp/zsh-5.4.2/Src/cond.c"
static void tracemodcond(char *name , char **args , int inf ) 
{ 
  char **aptr ;
  char **tmp ;

  {
  {
#line 561
  args = arrdup(args);
#line 562
  aptr = args;
  }
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    if (! *aptr) {
#line 562
      goto while_break;
    }
    {
#line 563
    untokenize(*aptr);
#line 562
    aptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  if (inf) {
    {
#line 565
    fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)" %s %s %s",
            *(args + 0), name, *(args + 1));
    }
  } else {
    {
#line 567
    fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)" %s",
            name);
    }
    {
#line 568
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 568
      if (! *args) {
#line 568
        goto while_break___0;
      }
      {
#line 569
      tmp = args;
#line 569
      args ++;
#line 569
      fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)" %s",
              *tmp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 571
  return;
}
}
#line 514 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 228 "/tmp/zsh-5.4.2/Src/compat.c"
long zopenmax(void) 
{ 
  long openmax ;
  long i ;
  long j ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 233
  openmax = sysconf(4);
  }
#line 233
  if (openmax < 1L) {
#line 234
    openmax = 64L;
  } else
#line 235
  if (openmax > 64L) {
#line 243
    j = 64L;
#line 244
    if (openmax > 64L) {
#line 245
      openmax = 64L;
    }
#line 246
    i = j;
    {
#line 246
    while (1) {
      while_continue: /* CIL Label */ ;
#line 246
      if (! (i < openmax)) {
#line 246
        goto while_break;
      }
      {
#line 247
      tmp___0 = __errno_location();
#line 247
      *tmp___0 = 0;
#line 248
      tmp___1 = fcntl((int )i, 3, 0);
      }
#line 248
      if (tmp___1 < 0) {
        {
#line 248
        tmp___2 = __errno_location();
        }
#line 248
        if (*tmp___2 == 9) {
#line 250
          goto __Cont;
        } else {
          {
#line 248
          tmp___3 = __errno_location();
          }
#line 248
          if (*tmp___3 == 4) {
#line 250
            goto __Cont;
          }
        }
      }
#line 251
      j = i;
      __Cont: /* CIL Label */ 
      {
#line 246
      tmp = __errno_location();
#line 246
      i += (long )(*tmp != 4);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 253
    openmax = j;
  }
#line 256
  if ((long )max_zsh_fd > openmax) {
#line 256
    tmp___4 = (long )max_zsh_fd;
  } else {
#line 256
    tmp___4 = openmax;
  }
#line 256
  return (tmp___4);
}
}
#line 283 "/tmp/zsh-5.4.2/Src/compat.c"
char *zgetdir(struct dirsav *d___0 ) 
{ 
  char nbuf[4099] ;
  char *buf___7 ;
  int bufsiz ;
  int pos ;
  struct stat sbuf ;
  ino_t pino ;
  dev_t pdev ;
  struct dirent *de ;
  DIR *dir ;
  dev_t dev ;
  ino_t ino ;
  int len ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *fn___0 ;
  size_t tmp___3 ;
  char *newbuf ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 300
  bufsiz = 4097;
#line 300
  tmp = zhalloc((size_t )bufsiz);
#line 300
  buf___7 = (char *)tmp;
#line 301
  pos = bufsiz - 1;
#line 302
  *(buf___7 + pos) = (char )'\000';
#line 303
  strcpy((char */* __restrict  */)(nbuf), (char const   */* __restrict  */)"../");
#line 304
  tmp___0 = stat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& sbuf));
  }
#line 304
  if (tmp___0 < 0) {
#line 305
    return ((char *)((void *)0));
  }
#line 309
  pino = sbuf.st_ino;
#line 310
  pdev = sbuf.st_dev;
#line 311
  if (d___0) {
#line 312
    d___0->ino = pino;
#line 312
    d___0->dev = pdev;
  } else {
    {
#line 317
    holdintr();
    }
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 321
    tmp___1 = stat((char const   */* __restrict  */)"..", (struct stat */* __restrict  */)(& sbuf));
    }
#line 321
    if (tmp___1 < 0) {
#line 322
      goto while_break;
    }
#line 325
    ino = pino;
#line 326
    dev = pdev;
#line 328
    pino = sbuf.st_ino;
#line 329
    pdev = sbuf.st_dev;
#line 332
    if (ino == pino) {
#line 332
      if (dev == pdev) {
#line 333
        if (! *(buf___7 + pos)) {
#line 334
          pos --;
#line 334
          *(buf___7 + pos) = (char )'/';
        }
#line 335
        if (d___0) {
          {
#line 340
          tmp___2 = ztrdup((char const   *)(buf___7 + pos));
#line 340
          d___0->dirname = tmp___2;
          }
#line 340
          return (tmp___2);
        }
        {
#line 342
        zchdir(buf___7 + pos);
#line 343
        noholdintr();
        }
#line 344
        return (buf___7 + pos);
      }
    }
    {
#line 348
    dir = opendir("..");
    }
#line 348
    if (! dir) {
#line 349
      goto while_break;
    }
    {
#line 351
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 351
      de = readdir(dir);
      }
#line 351
      if (! de) {
#line 351
        goto while_break___0;
      }
#line 352
      fn___0 = de->d_name;
#line 354
      if ((int )*(fn___0 + 0) == 46) {
#line 354
        if ((int )*(fn___0 + 1) == 0) {
#line 357
          goto while_continue___0;
        } else
#line 354
        if ((int )*(fn___0 + 1) == 46) {
#line 354
          if ((int )*(fn___0 + 2) == 0) {
#line 357
            goto while_continue___0;
          }
        }
      }
#line 366
      if (dev != pdev) {
#line 366
        goto _L;
      } else
#line 366
      if (de->d_ino == ino) {
        _L: /* CIL Label */ 
        {
#line 370
        strncpy((char */* __restrict  */)(nbuf + 3), (char const   */* __restrict  */)fn___0,
                (size_t )4096);
#line 371
        lstat((char const   */* __restrict  */)(nbuf), (struct stat */* __restrict  */)(& sbuf));
        }
#line 372
        if (sbuf.st_dev == dev) {
#line 372
          if (sbuf.st_ino == ino) {
#line 373
            goto while_break___0;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 377
    closedir(dir);
    }
#line 378
    if (! de) {
#line 379
      goto while_break;
    }
    {
#line 385
    tmp___3 = strlen((char const   *)(nbuf + 2));
#line 385
    len = (int )tmp___3;
#line 386
    pos -= len;
    }
    {
#line 387
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 387
      if (! (pos <= 1)) {
#line 387
        goto while_break___1;
      }
      {
#line 388
      tmp___4 = zhalloc((size_t )(2 * bufsiz));
#line 388
      newbuf = (char *)tmp___4;
#line 389
      memcpy((void */* __restrict  */)(newbuf + bufsiz), (void const   */* __restrict  */)buf___7,
             (size_t )bufsiz);
#line 390
      buf___7 = newbuf;
#line 391
      pos += bufsiz;
#line 392
      bufsiz *= 2;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 394
    memcpy((void */* __restrict  */)(buf___7 + pos), (void const   */* __restrict  */)(nbuf + 2),
           (size_t )len);
    }
#line 396
    if (d___0) {
      {
#line 397
      tmp___5 = ztrdup((char const   *)((buf___7 + pos) + 1));
#line 397
      d___0->dirname = tmp___5;
      }
#line 397
      return (tmp___5);
    }
    {
#line 399
    tmp___6 = chdir("..");
    }
#line 399
    if (tmp___6) {
#line 400
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 408
  if (d___0) {
#line 414
    return ((char *)((void *)0));
  }
#line 417
  if (*(buf___7 + pos)) {
    {
#line 418
    zchdir((buf___7 + pos) + 1);
    }
  }
  {
#line 419
  noholdintr();
  }
#line 445
  return ((char *)((void *)0));
}
}
#line 456 "/tmp/zsh-5.4.2/Src/compat.c"
char *zgetcwd(void) 
{ 
  char *ret ;
  char *tmp ;
  char *cwd ;
  char *tmp___0 ;

  {
  {
#line 459
  tmp = zgetdir((struct dirsav *)((void *)0));
#line 459
  ret = tmp;
  }
#line 461
  if (! ret) {
    {
#line 463
    tmp___0 = getcwd((char *)((void *)0), (size_t )0);
#line 463
    cwd = tmp___0;
    }
#line 464
    if (cwd) {
      {
#line 465
      ret = dupstring((char const   *)cwd);
#line 466
      free((void *)cwd);
      }
    }
  }
#line 477
  if (! ret) {
    {
#line 478
    ret = unmeta((char const   *)pwd);
    }
  }
#line 479
  if (! ret) {
    {
#line 480
    ret = dupstring(".");
    }
  }
#line 481
  return (ret);
}
}
#line 493 "/tmp/zsh-5.4.2/Src/compat.c"
int zchdir(char *dir ) 
{ 
  char *s ;
  int currdir ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 497
  currdir = -2;
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 500
    if (! *dir) {
#line 500
      goto _L;
    } else {
      {
#line 500
      tmp = chdir((char const   *)dir);
      }
#line 500
      if (tmp == 0) {
        _L: /* CIL Label */ 
#line 502
        if (currdir >= 0) {
          {
#line 503
          close(currdir);
          }
        }
#line 505
        return (0);
      }
    }
    {
#line 507
    tmp___0 = __errno_location();
    }
#line 507
    if (*tmp___0 != 36) {
      {
#line 507
      tmp___1 = __errno_location();
      }
#line 507
      if (*tmp___1 != 12) {
#line 509
        goto while_break;
      } else {
#line 507
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 507
      tmp___2 = strlen((char const   *)dir);
      }
#line 507
      if (tmp___2 < 4096UL) {
#line 509
        goto while_break;
      }
    }
#line 510
    s = (dir + 4096) - 1;
    {
#line 510
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 510
      if ((unsigned long )s > (unsigned long )dir) {
#line 510
        if (! ((int )*s != 47)) {
#line 510
          goto while_break___0;
        }
      } else {
#line 510
        goto while_break___0;
      }
#line 510
      s --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 512
    if ((unsigned long )s == (unsigned long )dir) {
#line 513
      goto while_break;
    }
#line 515
    if (currdir == -2) {
      {
#line 516
      currdir = open(".", 256);
      }
    }
    {
#line 518
    *s = (char )'\000';
#line 519
    tmp___3 = chdir((char const   *)dir);
    }
#line 519
    if (tmp___3 < 0) {
#line 520
      *s = (char )'/';
#line 521
      goto while_break;
    }
#line 526
    *s = (char )'/';
    {
#line 527
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 527
      s ++;
#line 527
      if (! ((int )*s == 47)) {
#line 527
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 529
    dir = s;
  }
  while_break: /* CIL Label */ ;
  }
#line 532
  if (currdir >= 0) {
    {
#line 533
    tmp___4 = fchdir(currdir);
    }
#line 533
    if (tmp___4 < 0) {
      {
#line 534
      close(currdir);
      }
#line 535
      return (-2);
    }
    {
#line 537
    close(currdir);
    }
#line 538
    return (-1);
  }
#line 541
  if (currdir == -2) {
#line 541
    tmp___5 = -1;
  } else {
#line 541
    tmp___5 = -2;
  }
#line 541
  return (tmp___5);
}
}
#line 284 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 308 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 46 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t times(struct tms *__buffer ) ;
#line 5 "./builtin.epro"
HashTable builtintab  ;
#line 9
int bin_enable(char *name , char **argv , Options ops , int func ) ;
#line 10
int bin_set(char *nam , char **args , Options ops  __attribute__((__unused__)) , int func  __attribute__((__unused__)) ) ;
#line 12
int bin_pwd(char *name  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
            Options ops , int func  __attribute__((__unused__)) ) ;
#line 13 "./builtin.epro"
LinkList dirstack  ;
#line 14
int bin_dirs(char *name  __attribute__((__unused__)) , char **argv , Options ops ,
             int func  __attribute__((__unused__)) ) ;
#line 16
int bin_cd(char *nam , char **argv , Options ops , int func ) ;
#line 19
void printqt(char *str ) ;
#line 20
void printif(char *str , int c ) ;
#line 21
int bin_fc(char *nam , char **argv , Options ops , int func ) ;
#line 22
int bin_typeset(char *name , char **argv , LinkList assigns , Options ops , int func ) ;
#line 24
int bin_functions(char *name , char **argv , Options ops , int func ) ;
#line 26
int bin_unset(char *name , char **argv , Options ops , int func ) ;
#line 28
int bin_hash(char *name , char **argv , Options ops , int func  __attribute__((__unused__)) ) ;
#line 29
int bin_unhash(char *name , char **argv , Options ops , int func ) ;
#line 30
int bin_alias(char *name , char **argv , Options ops , int func  __attribute__((__unused__)) ) ;
#line 31
int bin_true(char *name  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
             Options ops  __attribute__((__unused__)) , int func  __attribute__((__unused__)) ) ;
#line 32
int bin_false(char *name  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
              Options ops  __attribute__((__unused__)) , int func  __attribute__((__unused__)) ) ;
#line 33 "./builtin.epro"
LinkList bufstack  ;
#line 34
int bin_print(char *name , char **args , Options ops , int func ) ;
#line 35
int bin_shift(char *name , char **argv , Options ops , int func  __attribute__((__unused__)) ) ;
#line 36 "./builtin.epro"
int optcind  ;
#line 37
int bin_getopts(char *name  __attribute__((__unused__)) , char **argv , Options ops  __attribute__((__unused__)) ,
                int func  __attribute__((__unused__)) ) ;
#line 38 "./builtin.epro"
int exit_pending  ;
#line 39 "./builtin.epro"
int exit_level  ;
#line 40
int bin_break(char *name , char **argv , Options ops  __attribute__((__unused__)) ,
              int func ) ;
#line 41 "./builtin.epro"
int stopmsg  ;
#line 42 "./builtin.epro"
int shell_exiting  ;
#line 44
int bin_dot(char *name , char **argv , Options ops  __attribute__((__unused__)) ,
            int func  __attribute__((__unused__)) ) ;
#line 45
int bin_emulate(char *nam , char **argv , Options ops , int func  __attribute__((__unused__)) ) ;
#line 46 "./builtin.epro"
int ineval  ;
#line 47
int bin_eval(char *nam  __attribute__((__unused__)) , char **argv , Options ops  __attribute__((__unused__)) ,
             int func  __attribute__((__unused__)) ) ;
#line 48
int bin_read(char *name , char **args , Options ops , int func  __attribute__((__unused__)) ) ;
#line 49 "./builtin.epro"
char **testargs  ;
#line 50 "./builtin.epro"
char **curtestarg  ;
#line 52
int bin_test(char *name , char **argv , Options ops  __attribute__((__unused__)) ,
             int func ) ;
#line 53
int bin_times(char *name  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
              Options ops  __attribute__((__unused__)) , int func  __attribute__((__unused__)) ) ;
#line 54
int bin_trap(char *name , char **argv , Options ops  __attribute__((__unused__)) ,
             int func  __attribute__((__unused__)) ) ;
#line 55
int bin_ttyctl(char *name  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
               Options ops , int func  __attribute__((__unused__)) ) ;
#line 56
int bin_let(char *name  __attribute__((__unused__)) , char **argv , Options ops  __attribute__((__unused__)) ,
            int func  __attribute__((__unused__)) ) ;
#line 57
int bin_umask(char *nam , char **args , Options ops , int func  __attribute__((__unused__)) ) ;
#line 58
int bin_notavail(char *nam , char **argv  __attribute__((__unused__)) , Options ops  __attribute__((__unused__)) ,
                 int func  __attribute__((__unused__)) ) ;
#line 2 "./builtin.pro"
static void printbuiltinnode(HashNode hn , int printflags ) ;
#line 3
static void freebuiltinnode(HashNode hn ) ;
#line 4
static int new_optarg(Options ops ) ;
#line 5
static LinkNode cd_get_dest(char *nam , char **argv , int hard , int func ) ;
#line 6
static char *cd_do_chdir(char *cnam , char *dest , int hard ) ;
#line 7
static char *cd_try_chdir(char *pfix , char *dest , int hard ) ;
#line 8
static void cd_new_pwd(int func , LinkNode dir , int quiet ) ;
#line 9
static void printdirstack(void) ;
#line 10
static zlong fcgetcomm(char *s ) ;
#line 11
static int fcsubs(char **sp___0 , struct asgment *sub ) ;
#line 12
static int fclist(FILE *f , Options ops , zlong first , zlong last , struct asgment *subs ,
                  Patprog pprog , int is_command ) ;
#line 13
static int fcedit(char *ename , char *fn___0 ) ;
#line 14
static Asgment getasg(char ***argvp , LinkList assigns ) ;
#line 15
static Param typeset_single(char *cname , char *pname , Param pm , int func  __attribute__((__unused__)) ,
                            int on , int off , int roff , Asgment asg___0 , Param altpm ,
                            Options ops , int joinchar ) ;
#line 16
static int check_autoload(Shfunc shf , char *name , Options ops , int func ) ;
#line 17
static void checkjobs(void) ;
#line 18
static int zread(int izle , int *readchar , long izle_timeout ) ;
#line 38 "/tmp/zsh-5.4.2/Src/builtin.c"
static struct builtin builtins[77]  = 
#line 38 "/tmp/zsh-5.4.2/Src/builtin.c"
  {      {{(HashNode )((void *)0), (char *)"-", (1 << 6) | (1 << 5)}, (int (*)(char * ,
                                                                           char ** ,
                                                                           Options  ,
                                                                           int  ))0,
      0, 0, 0, (char *)((void *)0), (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"builtin", (1 << 7) | (1 << 5)}, (int (*)(char * ,
                                                                                 char ** ,
                                                                                 Options  ,
                                                                                 int  ))0,
      0, 0, 0, (char *)((void *)0), (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"command", (1 << 8) | (1 << 5)}, (int (*)(char * ,
                                                                                 char ** ,
                                                                                 Options  ,
                                                                                 int  ))0,
      0, 0, 0, (char *)((void *)0), (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"exec", (1 << 9) | (1 << 5)}, (int (*)(char * ,
                                                                              char ** ,
                                                                              Options  ,
                                                                              int  ))0,
      0, 0, 0, (char *)((void *)0), (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"noglob", (1 << 10) | (1 << 5)}, (int (*)(char * ,
                                                                                 char ** ,
                                                                                 Options  ,
                                                                                 int  ))0,
      0, 0, 0, (char *)((void *)0), (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"[", 1 << 18}, & bin_test, 0, -1, 21, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)".", 1 << 11}, & bin_dot, 1, -1, 0, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)":", 1 << 11}, & bin_true, 0, -1, 0, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"alias", (1 << 4) | (1 << 1)}, & bin_alias,
      0, -1, 0, (char *)"Lgmrs", (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"autoload", 1 << 1}, & bin_functions, 0, -1,
      0, (char *)"dmktrRTUwWXz", (char *)"u"}, 
        {{(HashNode )((void *)0), (char *)"bg", 0}, & bin_fg, 0, -1, 1, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"break", 1 << 11}, & bin_break, 0, 1, 6, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"bye", 0}, & bin_break, 0, 1, 8, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"cd", ((1 << 12) | (1 << 14)) | (1 << 15)},
      & bin_cd, 0, 2, 10, (char *)"qsPL", (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"chdir", ((1 << 12) | (1 << 14)) | (1 << 15)},
      & bin_cd, 0, 2, 10, (char *)"qsPL", (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"continue", 1 << 11}, & bin_break, 0, 1, 7,
      (char *)((void *)0), (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"declare", (((1 << 1) | (1 << 4)) | (1 << 11)) | (1 << 19)},
      (int (*)(char * , char ** , Options  , int  ))(& bin_typeset), 0, -1, 0, (char *)"AE:%F:%HL:%R:%TUZ:%afghi:%klmprtuxz",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"dirs", 0}, & bin_dirs, 0, -1, 0, (char *)"clpv",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"disable", 0}, & bin_enable, 0, -1, 24, (char *)"afmprs",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"disown", 0}, & bin_fg, 0, -1, 5, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"echo", 1 << 12}, & bin_print, 0, -1, 23, (char *)"neE",
      (char *)"-"}, 
        {{(HashNode )((void *)0), (char *)"emulate", 0}, & bin_emulate, 0, -1, 0, (char *)"lLR",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"enable", 0}, & bin_enable, 0, -1, 25, (char *)"afmprs",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"eval", 1 << 11}, & bin_eval, 0, -1, 14, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"exit", 1 << 11}, & bin_break, 0, 1, 8, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"export", (((1 << 1) | (1 << 4)) | (1 << 11)) | (1 << 19)},
      (int (*)(char * , char ** , Options  , int  ))(& bin_typeset), 0, -1, 0, (char *)"E:%F:%HL:%R:%TUZ:%afhi:%lprtu",
      (char *)"xg"}, 
        {{(HashNode )((void *)0), (char *)"false", 0}, & bin_false, 0, -1, 0, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"fc", 0}, & bin_fc, 0, -1, 16, (char *)"aAdDe:EfiIlLmnpPrRt:W",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"fg", 0}, & bin_fg, 0, -1, 2, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"float", (((1 << 1) | (1 << 4)) | (1 << 11)) | (1 << 19)},
      (int (*)(char * , char ** , Options  , int  ))(& bin_typeset), 0, -1, 0, (char *)"E:%F:%HL:%R:%Z:%ghlprtux",
      (char *)"E"}, 
        {{(HashNode )((void *)0), (char *)"functions", 1 << 1}, & bin_functions, 0, -1,
      0, (char *)"kmMstTuUWx:z", (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"getln", 0}, & bin_read, 0, -1, 0, (char *)"ecnAlE",
      (char *)"zr"}, 
        {{(HashNode )((void *)0), (char *)"getopts", 0}, & bin_getopts, 2, -1, 0, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"hash", 1 << 4}, & bin_hash, 0, -1, 0, (char *)"Ldfmrv",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"history", 0}, & bin_fc, 0, -1, 16, (char *)"adDEfiLmnpPrt:",
      (char *)"l"}, 
        {{(HashNode )((void *)0), (char *)"integer", (((1 << 1) | (1 << 4)) | (1 << 11)) | (1 << 19)},
      (int (*)(char * , char ** , Options  , int  ))(& bin_typeset), 0, -1, 0, (char *)"HL:%R:%Z:%ghi:%lprtux",
      (char *)"i"}, 
        {{(HashNode )((void *)0), (char *)"jobs", 0}, & bin_fg, 0, -1, 3, (char *)"dlpZrs",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"kill", 1 << 18}, & bin_kill, 0, -1, 0, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"let", 0}, & bin_let, 1, -1, 0, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"local", (((1 << 1) | (1 << 4)) | (1 << 11)) | (1 << 19)},
      (int (*)(char * , char ** , Options  , int  ))(& bin_typeset), 0, -1, 0, (char *)"AE:%F:%HL:%R:%TUZ:%ahi:%lprtux",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"log", 0}, & bin_log, 0, 0, 0, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"logout", 0}, & bin_break, 0, 1, 19, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"popd", ((1 << 12) | (1 << 14)) | (1 << 15)},
      & bin_cd, 0, 1, 11, (char *)"q", (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"print", 1 << 2}, & bin_print, 0, -1, 13, (char *)"abcC:Df:ilmnNoOpPrRsSu:v:x:X:z-",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"printf", (1 << 12) | (1 << 14)}, & bin_print,
      1, -1, 26, (char *)"v:", (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"pushd", ((1 << 12) | (1 << 14)) | (1 << 15)},
      & bin_cd, 0, 2, 12, (char *)"qsPL", (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"pushln", 0}, & bin_print, 0, -1, 13, (char *)((void *)0),
      (char *)"-nz"}, 
        {{(HashNode )((void *)0), (char *)"pwd", 0}, & bin_pwd, 0, 0, 0, (char *)"rLP",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"r", 0}, & bin_fc, 0, -1, 17, (char *)"IlLnr",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"read", 0}, & bin_read, 0, -1, 0, (char *)"cd:ek:%lnpqrst:%zu:AE",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"readonly", (((1 << 1) | (1 << 4)) | (1 << 11)) | (1 << 19)},
      (int (*)(char * , char ** , Options  , int  ))(& bin_typeset), 0, -1, 22, (char *)"AE:%F:%HL:%R:%TUZ:%afghi:%lptux",
      (char *)"r"}, 
        {{(HashNode )((void *)0), (char *)"rehash", 0}, & bin_hash, 0, 0, 0, (char *)"df",
      (char *)"r"}, 
        {{(HashNode )((void *)0), (char *)"return", 1 << 11}, & bin_break, 0, 1, 9, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"set", (1 << 11) | (1 << 18)}, & bin_set, 0,
      -1, 0, (char *)((void *)0), (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"setopt", 0}, & bin_setopt, 0, -1, 0, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"shift", 1 << 11}, & bin_shift, 0, -1, 0, (char *)"p",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"source", 1 << 11}, & bin_dot, 1, -1, 0, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"suspend", 0}, & bin_suspend, 0, 0, 0, (char *)"f",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"test", 1 << 18}, & bin_test, 0, -1, 20, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"ttyctl", 0}, & bin_ttyctl, 0, 0, 0, (char *)"fu",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"times", 1 << 11}, & bin_times, 0, 0, 0, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"trap", (1 << 11) | (1 << 18)}, & bin_trap,
      0, -1, 0, (char *)((void *)0), (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"true", 0}, & bin_true, 0, -1, 0, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"type", 0}, & bin_whence, 0, -1, 0, (char *)"ampfsSw",
      (char *)"v"}, 
        {{(HashNode )((void *)0), (char *)"typeset", (((1 << 1) | (1 << 4)) | (1 << 11)) | (1 << 19)},
      (int (*)(char * , char ** , Options  , int  ))(& bin_typeset), 0, -1, 0, (char *)"AE:%F:%HL:%R:%TUZ:%afghi:%klprtuxmz",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"umask", 0}, & bin_umask, 0, 1, 0, (char *)"S",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"unalias", 0}, & bin_unhash, 0, -1, 29, (char *)"ams",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"unfunction", 0}, & bin_unhash, 1, -1, 30,
      (char *)"m", (char *)"f"}, 
        {{(HashNode )((void *)0), (char *)"unhash", 0}, & bin_unhash, 1, -1, 28, (char *)"adfms",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"unset", 1 << 11}, & bin_unset, 1, -1, 0, (char *)"fmv",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"unsetopt", 0}, & bin_setopt, 0, -1, 1, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"wait", 0}, & bin_fg, 0, -1, 4, (char *)((void *)0),
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"whence", 0}, & bin_whence, 0, -1, 0, (char *)"acmpvfsSwx:",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"where", 0}, & bin_whence, 0, -1, 0, (char *)"pmsSwx:",
      (char *)"ca"}, 
        {{(HashNode )((void *)0), (char *)"which", 0}, & bin_whence, 0, -1, 0, (char *)"ampsSwx:",
      (char *)"c"}, 
        {{(HashNode )((void *)0), (char *)"zmodload", 0}, & bin_zmodload, 0, -1, 0, (char *)"AFRILP:abcfdilmpsue",
      (char *)((void *)0)}, 
        {{(HashNode )((void *)0), (char *)"zcompile", 0}, & bin_zcompile, 0, -1, 0, (char *)"tUMRcmzka",
      (char *)((void *)0)}};
#line 148 "/tmp/zsh-5.4.2/Src/builtin.c"
void createbuiltintable(void) 
{ 


  {
  {
#line 151
  builtintab = newhashtable(85, "builtintab", (void (*)(HashTable  ))((void *)0));
#line 153
  builtintab->hash = & hasher;
#line 154
  builtintab->emptytable = (void (*)(HashTable  ))((void *)0);
#line 155
  builtintab->filltable = (void (*)(HashTable  ))((void *)0);
#line 156
  builtintab->cmpnodes = (int (*)(char const   * , char const   * ))(& strcmp);
#line 157
  builtintab->addnode = & addhashnode;
#line 158
  builtintab->getnode = & gethashnode;
#line 159
  builtintab->getnode2 = & gethashnode2;
#line 160
  builtintab->removenode = & removehashnode;
#line 161
  builtintab->disablenode = & disablehashnode;
#line 162
  builtintab->enablenode = & enablehashnode;
#line 163
  builtintab->freenode = & freebuiltinnode;
#line 164
  builtintab->printnode = & printbuiltinnode;
#line 166
  addbuiltins("zsh", builtins, (int )(sizeof(builtins) / sizeof(builtins[0])));
  }
#line 167
  return;
}
}
#line 172 "/tmp/zsh-5.4.2/Src/builtin.c"
static void printbuiltinnode(HashNode hn , int printflags ) 
{ 
  Builtin bn ;

  {
#line 175
  bn = (Builtin )hn;
#line 177
  if (printflags & (1 << 10)) {
    {
#line 178
    printf((char const   */* __restrict  */)"%s: builtin\n", bn->node.nam);
    }
#line 179
    return;
  }
#line 182
  if (printflags & (1 << 6)) {
    {
#line 183
    printf((char const   */* __restrict  */)"%s: shell built-in command\n", bn->node.nam);
    }
#line 184
    return;
  }
#line 187
  if (printflags & (1 << 7)) {
    {
#line 188
    printf((char const   */* __restrict  */)"%s is a shell builtin\n", bn->node.nam);
    }
#line 189
    return;
  }
  {
#line 193
  printf((char const   */* __restrict  */)"%s\n", bn->node.nam);
  }
#line 194
  return;
}
}
#line 197 "/tmp/zsh-5.4.2/Src/builtin.c"
static void freebuiltinnode(HashNode hn ) 
{ 
  Builtin bn ;

  {
#line 200
  bn = (Builtin )hn;
#line 202
  if (! (bn->node.flags & (1 << 3))) {
    {
#line 203
    zsfree(bn->node.nam);
#line 204
    zsfree(bn->optstr);
#line 205
    zfree((void *)bn, (int )sizeof(struct builtin ));
    }
  }
#line 207
  return;
}
}
#line 210 "/tmp/zsh-5.4.2/Src/builtin.c"
void init_builtins(void) 
{ 
  HashNode hn ;
  HashNode tmp ;

  {
#line 213
  if (! (emulation & (1 << 4))) {
    {
#line 214
    tmp = (*(reswdtab->getnode2))(reswdtab, "repeat");
#line 214
    hn = tmp;
    }
#line 215
    if (hn) {
      {
#line 216
      (*(reswdtab->disablenode))(hn, 0);
      }
    }
  }
#line 218
  return;
}
}
#line 225 "/tmp/zsh-5.4.2/Src/builtin.c"
static int new_optarg(Options ops ) 
{ 
  char **newptr ;
  void *tmp ;

  {
#line 229
  if (ops->argscount == 63) {
#line 230
    return (1);
  }
#line 231
  if (ops->argsalloc == ops->argscount) {
    {
#line 232
    tmp = zhalloc((unsigned long )(ops->argsalloc + 16) * sizeof(char *));
#line 232
    newptr = (char **)tmp;
    }
#line 235
    if (ops->argsalloc) {
      {
#line 236
      memcpy((void */* __restrict  */)newptr, (void const   */* __restrict  */)ops->args,
             (unsigned long )ops->argsalloc * sizeof(char *));
      }
    }
#line 237
    ops->args = newptr;
#line 238
    ops->argsalloc += 16;
  }
#line 240
  (ops->argscount) ++;
#line 241
  return (0);
}
}
#line 248 "/tmp/zsh-5.4.2/Src/builtin.c"
int execbuiltin(LinkList args , LinkList assigns , Builtin bn ) 
{ 
  char *pp ;
  char *name ;
  char *optstr ;
  int flags ;
  int argc ;
  int execop ;
  int xtr ;
  struct options ops ;
  void *tmp ;
  char **argarr ;
  void *tmp___0 ;
  char **argv ;
  char **tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *arg ;
  int sense ;
  int tmp___4 ;
  char *p ;
  char *tmp___5 ;
  char *optptr ;
  char *argptr ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char **fullargv ;
  char **tmp___9 ;
  LinkNode node ;
  Asgment asg___0 ;
  LinkNode arrnode ;
  int (*assignfunc)(char * , char ** , LinkList  , Options  , int  ) ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 252
  xtr = (int )opts[177];
#line 256
  memset((void *)(ops.ind), 0, 128UL * sizeof(unsigned char ));
#line 257
  ops.args = (char **)((void *)0);
#line 258
  ops.argsalloc = 0;
#line 258
  ops.argscount = ops.argsalloc;
#line 261
  tmp = ugetnode(args);
#line 261
  name = (char *)tmp;
  }
#line 263
  if (! bn->handlerfunc) {
    {
#line 265
    deletebuiltin((char const   *)bn->node.nam);
    }
#line 266
    return (1);
  }
  {
#line 269
  flags = bn->node.flags;
#line 270
  optstr = bn->optstr;
#line 274
  argc = countlinknodes(args);
#line 283
  tmp___0 = zhalloc(sizeof(char *) * (unsigned long )(argc + 1));
#line 283
  argarr = (char **)tmp___0;
#line 290
  argv = argarr;
  }
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 291
    tmp___1 = argv;
#line 291
    argv ++;
#line 291
    tmp___3 = ugetnode(args);
#line 291
    tmp___2 = (char *)tmp___3;
#line 291
    *tmp___1 = tmp___2;
    }
#line 291
    if (! tmp___2) {
#line 291
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  argv = argarr;
#line 295
  if (optstr) {
#line 296
    arg = *argv;
    {
#line 299
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 299
      if (arg) {
#line 299
        sense = (int )*arg == 45;
#line 299
        if (! sense) {
#line 299
          if (flags & (1 << 1)) {
#line 299
            if (! ((int )*arg == 43)) {
#line 299
              goto while_break___0;
            }
          } else {
#line 299
            goto while_break___0;
          }
        }
      } else {
#line 299
        goto while_break___0;
      }
#line 304
      if (! (flags & (1 << 13))) {
#line 304
        if ((int )typtab[(unsigned char )*(arg + 1)] & 1) {
#line 305
          goto while_break___0;
        }
      }
#line 307
      if (flags & (1 << 14)) {
#line 307
        if (! *(arg + 1)) {
#line 308
          goto while_break___0;
        }
      }
#line 309
      if (flags & (1 << 15)) {
        {
#line 309
        tmp___4 = strcmp((char const   *)arg, "--");
        }
#line 309
        if (! tmp___4) {
#line 314
          argv ++;
#line 315
          goto while_break___0;
        }
      }
#line 326
      if (flags & (1 << 12)) {
#line 327
        p = arg;
        {
#line 328
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 328
          p ++;
#line 328
          if (*p) {
            {
#line 328
            tmp___5 = strchr((char const   *)optstr, (int )*p);
            }
#line 328
            if (! tmp___5) {
#line 328
              goto while_break___1;
            }
          } else {
#line 328
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 329
        if (*p) {
#line 330
          goto while_break___0;
        }
      }
#line 334
      if ((int )*(arg + 1) == 45) {
#line 335
        arg ++;
      }
#line 336
      if (! *(arg + 1)) {
#line 337
        ops.ind['-'] = (unsigned char)1;
#line 338
        if (! sense) {
#line 339
          ops.ind['+'] = (unsigned char)1;
        }
      }
      {
#line 342
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 342
        arg ++;
#line 342
        if (! *arg) {
#line 342
          goto while_break___2;
        }
        {
#line 344
        execop = (int )*arg;
#line 344
        optptr = strchr((char const   *)optstr, execop);
        }
#line 344
        if (optptr) {
#line 345
          if (sense) {
#line 345
            ops.ind[(int )*arg] = (unsigned char)1;
          } else {
#line 345
            ops.ind[(int )*arg] = (unsigned char)2;
          }
#line 346
          if ((int )*(optptr + 1) == 58) {
#line 347
            argptr = (char *)((void *)0);
#line 348
            if ((int )*(optptr + 2) == 58) {
#line 349
              if (*(arg + 1)) {
#line 350
                argptr = arg + 1;
              }
            } else
#line 352
            if ((int )*(optptr + 2) == 37) {
#line 355
              if (*(arg + 1)) {
#line 355
                if ((int )typtab[(unsigned char )*(arg + 1)] & 1) {
#line 356
                  argptr = arg + 1;
                } else {
#line 355
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 357
              if (*(argv + 1)) {
#line 357
                if ((int )typtab[(unsigned char )*(*(argv + 1))] & 1) {
#line 358
                  argv ++;
#line 358
                  arg = *argv;
#line 358
                  argptr = arg;
                }
              }
            } else
#line 361
            if (*(arg + 1)) {
#line 362
              argptr = arg + 1;
            } else {
#line 363
              argv ++;
#line 363
              arg = *argv;
#line 363
              if (arg) {
#line 364
                argptr = arg;
              } else {
                {
#line 366
                zwarnnam((char const   *)name, "argument expected: -%c", execop);
                }
#line 368
                return (1);
              }
            }
#line 371
            if (argptr) {
              {
#line 372
              tmp___6 = new_optarg(& ops);
              }
#line 372
              if (tmp___6) {
                {
#line 373
                zwarnnam((char const   *)name, "too many option arguments");
                }
#line 375
                return (1);
              }
#line 377
              ops.ind[execop] = (unsigned char )((int )ops.ind[execop] | (ops.argscount << 2));
#line 378
              *(ops.args + (ops.argscount - 1)) = argptr;
              {
#line 379
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 379
                if (! *(arg + 1)) {
#line 379
                  goto while_break___3;
                }
#line 380
                arg ++;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
          }
        } else {
#line 384
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 388
      if (*arg) {
#line 389
        if ((int )*arg == -125) {
#line 390
          arg ++;
#line 390
          *arg = (char )((int )*arg ^ 32);
        }
        {
#line 391
        zwarnnam((char const   *)name, "bad option: %c%c", (int const   )*("+-" + sense),
                 (int )*arg);
        }
#line 392
        return (1);
      }
#line 394
      argv ++;
#line 394
      arg = *argv;
#line 397
      if (flags & (1 << 2)) {
#line 397
        if (ops.ind[82]) {
#line 397
          if (! ops.ind[102]) {
#line 399
            optstr = (char *)"ne";
#line 400
            flags |= 1 << 12;
          }
        }
      }
#line 403
      if (ops.ind[45]) {
#line 404
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 406
  if (! (flags & (1 << 18))) {
#line 406
    if (*argv) {
      {
#line 406
      tmp___7 = strcmp((char const   *)*argv, "--");
      }
#line 406
      if (! tmp___7) {
#line 408
        ops.ind['-'] = (unsigned char)1;
#line 409
        argv ++;
      }
    }
  }
#line 413
  pp = bn->defopts;
#line 413
  if (pp) {
    {
#line 414
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 414
      if (! *pp) {
#line 414
        goto while_break___4;
      }
#line 416
      if (! ops.ind[(int )*pp]) {
#line 417
        ops.ind[(int )*pp] = (unsigned char)1;
      }
#line 418
      pp ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 423
  argc = (int )((long )argc - (argv - argarr));
#line 425
  if (errflag) {
#line 426
    errflag &= -2;
#line 427
    return (1);
  }
#line 431
  if (argc < bn->minargs) {
#line 431
    goto _L___0;
  } else
#line 431
  if (argc > bn->maxargs) {
#line 431
    if (bn->maxargs != -1) {
      _L___0: /* CIL Label */ 
#line 432
      if (argc < bn->minargs) {
#line 432
        tmp___8 = "not enough arguments";
      } else {
#line 432
        tmp___8 = "too many arguments";
      }
      {
#line 432
      zwarnnam((char const   *)name, tmp___8);
      }
#line 434
      return (1);
    }
  }
#line 438
  if (xtr) {
    {
#line 440
    fullargv = argarr;
#line 441
    printprompt4();
#line 442
    fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)"%s",
            name);
    }
    {
#line 443
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 443
      if (! *fullargv) {
#line 443
        goto while_break___5;
      }
      {
#line 444
      fputc(' ', xtrerr);
#line 445
      tmp___9 = fullargv;
#line 445
      fullargv ++;
#line 445
      quotedzputs((char const   *)*tmp___9, xtrerr);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 447
    if (assigns) {
#line 449
      node = assigns->list.first;
      {
#line 449
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 449
        if (! node) {
#line 449
          goto while_break___6;
        }
        {
#line 450
        asg___0 = (Asgment )node;
#line 451
        fputc(' ', xtrerr);
#line 452
        quotedzputs((char const   *)asg___0->name, xtrerr);
        }
#line 453
        if (asg___0->is_array) {
          {
#line 455
          fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)"=(");
          }
#line 456
          if (asg___0->value.array) {
#line 457
            arrnode = (asg___0->value.array)->list.first;
            {
#line 457
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 457
              if (! arrnode) {
#line 457
                goto while_break___7;
              }
              {
#line 460
              fputc(' ', xtrerr);
#line 461
              quotedzputs((char const   *)((char *)arrnode->dat), xtrerr);
#line 457
              arrnode = arrnode->next;
              }
            }
            while_break___7: /* CIL Label */ ;
            }
          }
          {
#line 464
          fprintf((FILE */* __restrict  */)xtrerr, (char const   */* __restrict  */)" )");
          }
        } else
#line 465
        if (asg___0->value.scalar) {
          {
#line 466
          fputc('=', xtrerr);
#line 467
          quotedzputs((char const   *)asg___0->value.scalar, xtrerr);
          }
        }
#line 449
        node = node->next;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 471
    fputc('\n', xtrerr);
#line 472
    fflush(xtrerr);
    }
  }
#line 475
  if (flags & (1 << 19)) {
    {
#line 480
    assignfunc = (int (*)(char * , char ** , LinkList  , Options  , int  ))bn->handlerfunc;
#line 481
    tmp___10 = (*assignfunc)(name, argv, assigns, & ops, bn->funcid);
    }
#line 481
    return (tmp___10);
  } else {
    {
#line 485
    tmp___11 = (*(bn->handlerfunc))(name, argv, & ops, bn->funcid);
    }
#line 485
    return (tmp___11);
  }
}
}
#line 495 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_enable(char *name , char **argv , Options ops , int func ) 
{ 
  HashTable ht ;
  HashNode hn ;
  void (*scanfunc)(HashNode  , int  ) ;
  Patprog pprog ;
  int flags1 ;
  int flags2 ;
  int match ;
  int returnval ;
  int tmp ;
  sigset_t oset ;
  int tmp___0 ;
  sigset_t oset___0 ;
  sigset_t oset___1 ;

  {
#line 502
  flags1 = 0;
#line 502
  flags2 = 0;
#line 503
  match = 0;
#line 503
  returnval = 0;
#line 506
  if ((int )ops->ind[112] != 0) {
    {
#line 507
    tmp = pat_enables((char const   *)name, argv, func == 25);
    }
#line 507
    return (tmp);
  } else
#line 508
  if ((int )ops->ind[102] != 0) {
#line 509
    ht = shfunctab;
  } else
#line 510
  if ((int )ops->ind[114] != 0) {
#line 511
    ht = reswdtab;
  } else
#line 512
  if ((int )ops->ind[115] != 0) {
#line 513
    ht = sufaliastab;
  } else
#line 514
  if ((int )ops->ind[97] != 0) {
#line 515
    ht = aliastab;
  } else {
#line 517
    ht = builtintab;
  }
#line 520
  if (func == 25) {
#line 521
    flags2 = 1;
#line 522
    scanfunc = ht->enablenode;
  } else {
#line 524
    flags1 = 1;
#line 525
    scanfunc = ht->disablenode;
  }
#line 532
  if (! *argv) {
    {
#line 533
    queueing_enabled ++;
#line 534
    scanhashtable(ht, 1, flags1, flags2, ht->printnode, 0);
    }
    {
#line 535
    while (1) {
      while_continue: /* CIL Label */ ;
#line 535
      queueing_enabled --;
#line 535
      if (! queueing_enabled) {
        {
#line 535
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 535
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 535
            if (! (queue_front != queue_rear)) {
#line 535
              goto while_break___1;
            }
            {
#line 535
            queue_front = (queue_front + 1) % 128;
#line 535
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 535
            zhandler(signal_queue[queue_front]);
#line 535
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 535
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 535
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 536
    return (0);
  }
#line 540
  if ((int )ops->ind[109] != 0) {
    {
#line 541
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 541
      if (! *argv) {
#line 541
        goto while_break___2;
      }
      {
#line 542
      queueing_enabled ++;
#line 545
      tokenize(*argv);
#line 546
      pprog = patcompile(*argv, 64, (char **)0);
      }
#line 546
      if (pprog) {
        {
#line 547
        tmp___0 = scanmatchtable(ht, pprog, 0, 0, 0, scanfunc, 0);
#line 547
        match += tmp___0;
        }
      } else {
        {
#line 549
        untokenize(*argv);
#line 550
        zwarnnam((char const   *)name, "bad pattern : %s", *argv);
#line 551
        returnval = 1;
        }
      }
      {
#line 553
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 553
        queueing_enabled --;
#line 553
        if (! queueing_enabled) {
          {
#line 553
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 553
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 553
              if (! (queue_front != queue_rear)) {
#line 553
                goto while_break___5;
              }
              {
#line 553
              queue_front = (queue_front + 1) % 128;
#line 553
              oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 553
              zhandler(signal_queue[queue_front]);
#line 553
              signal_setmask(oset___0);
              }
            }
            while_break___5: /* CIL Label */ ;
            }
#line 553
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 553
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 541
      argv ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 556
    if (! match) {
#line 557
      returnval = 1;
    }
#line 558
    return (returnval);
  }
#line 562
  queueing_enabled ++;
  {
#line 563
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 563
    if (! *argv) {
#line 563
      goto while_break___6;
    }
    {
#line 564
    hn = (*(ht->getnode2))(ht, (char const   *)*argv);
    }
#line 564
    if (hn) {
      {
#line 565
      (*scanfunc)(hn, 0);
      }
    } else {
      {
#line 567
      zwarnnam((char const   *)name, "no such hash table element: %s", *argv);
#line 568
      returnval = 1;
      }
    }
#line 563
    argv ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 571
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 571
    queueing_enabled --;
#line 571
    if (! queueing_enabled) {
      {
#line 571
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 571
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 571
          if (! (queue_front != queue_rear)) {
#line 571
            goto while_break___9;
          }
          {
#line 571
          queue_front = (queue_front + 1) % 128;
#line 571
          oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 571
          zhandler(signal_queue[queue_front]);
#line 571
          signal_setmask(oset___1);
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 571
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 571
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 572
  return (returnval);
}
}
#line 579 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_set(char *nam , char **args , Options ops  __attribute__((__unused__)) , int func  __attribute__((__unused__)) ) 
{ 
  int action ;
  int optno ;
  int array ;
  int hadopt ;
  int hadplus ;
  int hadend ;
  int sort ;
  char **x ;
  char *arrayname ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  sigset_t oset ;
  int tmp___3 ;
  char **a ;
  char **y ;
  int len ;
  int tmp___4 ;
  int al ;
  int tmp___5 ;
  void *tmp___6 ;
  char **tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  sigset_t oset___0 ;

  {
#line 582
  array = 0;
#line 582
  hadopt = 0;
#line 582
  hadplus = 0;
#line 582
  hadend = 0;
#line 582
  sort = 0;
#line 584
  arrayname = (char *)((void *)0);
#line 588
  if (! (emulation & (1 << 4))) {
#line 588
    if (*args) {
#line 588
      if ((int )*(*args) == 45) {
#line 588
        if (! *(*(args + 0) + 1)) {
          {
#line 589
          dosetopt(173, 0, 0, opts);
#line 590
          dosetopt(177, 0, 0, opts);
          }
#line 591
          if (! *(args + 1)) {
#line 592
            return (0);
          }
        }
      }
    }
  }
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;
#line 596
    if (*args) {
#line 596
      if (! ((int )*(*args) == 45)) {
#line 596
        if (! ((int )*(*args) == 43)) {
#line 596
          goto while_break;
        }
      }
    } else {
#line 596
      goto while_break;
    }
#line 597
    action = (int )*(*args) == 45;
#line 598
    hadplus |= ! action;
#line 599
    if (! *(*(args + 0) + 1)) {
#line 600
      *args = (char *)"--";
    }
    {
#line 601
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 601
      (*args) ++;
#line 601
      if (! *(*args)) {
#line 601
        goto while_break___0;
      }
#line 602
      if ((int )*(*args) == -125) {
#line 603
        (*args) ++;
#line 603
        *(*args) = (char )((int )*(*args) ^ 32);
      }
#line 604
      if ((int )*(*args) != 45) {
#line 605
        hadopt = 1;
      } else
#line 604
      if (action) {
#line 605
        hadopt = 1;
      }
#line 607
      if ((int )*(*args) == 45) {
#line 608
        hadend = 1;
#line 609
        args ++;
#line 610
        goto doneoptions;
      } else
#line 611
      if ((int )*(*args) == 111) {
#line 612
        (*args) ++;
#line 612
        if (! *(*args)) {
#line 613
          args ++;
        }
#line 614
        if (! *args) {
          {
#line 615
          printoptionstates(hadplus);
#line 616
          inittyptab();
          }
#line 617
          return (0);
        }
        {
#line 619
        optno = optlookup((char const   *)*args);
        }
#line 619
        if (optno) {
          {
#line 621
          tmp = dosetopt(optno, action, 0, opts);
          }
#line 621
          if (tmp) {
            {
#line 622
            zerrnam((char const   *)nam, "can\'t change option: %s", *args);
            }
          }
        } else {
          {
#line 620
          zerrnam((char const   *)nam, "no such option: %s", *args);
          }
        }
#line 623
        goto while_break___0;
      } else
#line 624
      if ((int )*(*args) == 65) {
#line 625
        (*args) ++;
#line 625
        if (! *(*args)) {
#line 626
          args ++;
        }
#line 627
        if (action) {
#line 627
          array = 1;
        } else {
#line 627
          array = -1;
        }
#line 628
        arrayname = *args;
#line 629
        if (! arrayname) {
#line 630
          goto doneoptions;
        } else
#line 631
        if (! opts[95]) {
#line 633
          args ++;
#line 634
          goto doneoptions;
        }
#line 636
        goto while_break___0;
      } else
#line 637
      if ((int )*(*args) == 115) {
#line 638
        if (action) {
#line 638
          sort = 1;
        } else {
#line 638
          sort = -1;
        }
      } else {
        {
#line 640
        optno = optlookupc(*(*args));
        }
#line 640
        if (optno) {
          {
#line 642
          tmp___0 = dosetopt(optno, action, 0, opts);
          }
#line 642
          if (tmp___0) {
            {
#line 643
            zerrnam((char const   *)nam, "can\'t change option: -%c", (int )*(*args));
            }
          }
        } else {
          {
#line 641
          zerrnam((char const   *)nam, "bad option: -%c", (int )*(*args));
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 646
    args ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 648
  if (errflag) {
#line 649
    return (1);
  }
  doneoptions: 
  {
#line 651
  inittyptab();
#line 654
  queueing_enabled ++;
  }
#line 655
  if (! arrayname) {
#line 657
    if (! hadopt) {
#line 657
      if (! *args) {
#line 658
        if (hadplus) {
#line 658
          tmp___1 = 1;
        } else {
#line 658
          tmp___1 = 0;
        }
        {
#line 658
        scanhashtable(paramtab, 1, 0, 0, paramtab->printnode, tmp___1);
        }
      }
    }
#line 661
    if (array) {
#line 663
      if (hadplus) {
#line 663
        tmp___2 = 1;
      } else {
#line 663
        tmp___2 = 0;
      }
      {
#line 663
      scanhashtable(paramtab, 1, 1, 0, paramtab->printnode, tmp___2);
      }
    }
#line 666
    if (! *args) {
#line 666
      if (! hadend) {
        {
#line 667
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 667
          queueing_enabled --;
#line 667
          if (! queueing_enabled) {
            {
#line 667
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 667
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 667
                if (! (queue_front != queue_rear)) {
#line 667
                  goto while_break___3;
                }
                {
#line 667
                queue_front = (queue_front + 1) % 128;
#line 667
                oset = signal_setmask(signal_mask_queue[queue_front]);
#line 667
                zhandler(signal_queue[queue_front]);
#line 667
                signal_setmask(oset);
                }
              }
              while_break___3: /* CIL Label */ ;
              }
#line 667
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
#line 667
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 668
        return (0);
      }
    }
  }
#line 671
  if (sort) {
#line 672
    if (sort < 0) {
#line 672
      tmp___3 = 4;
    } else {
#line 672
      tmp___3 = 0;
    }
    {
#line 672
    strmetasort(args, tmp___3, (int *)((void *)0));
    }
  }
#line 673
  if (array) {
    {
#line 675
    a = (char **)((void *)0);
#line 676
    tmp___4 = arrlen(args);
#line 676
    len = tmp___4;
    }
#line 678
    if (array < 0) {
      {
#line 678
      a = getaparam(arrayname);
      }
#line 678
      if (a) {
        {
#line 679
        tmp___5 = arrlen(a);
#line 679
        al = tmp___5;
        }
#line 681
        if (al > len) {
#line 682
          len = al;
        }
      }
    }
    {
#line 684
    tmp___6 = zalloc((unsigned long )(len + 1) * sizeof(char *));
#line 684
    y = (char **)tmp___6;
#line 684
    x = y;
    }
    {
#line 684
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 684
      tmp___9 = len;
#line 684
      len --;
#line 684
      if (! tmp___9) {
#line 684
        goto while_break___4;
      }
#line 685
      if (! *args) {
#line 686
        args = a;
      }
      {
#line 687
      tmp___7 = y;
#line 687
      y ++;
#line 687
      tmp___8 = args;
#line 687
      args ++;
#line 687
      *tmp___7 = ztrdup((char const   *)*tmp___8);
#line 684
      a ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 689
    tmp___10 = y;
#line 689
    y ++;
#line 689
    *tmp___10 = (char *)((void *)0);
#line 690
    setaparam(arrayname, x);
    }
  } else {
    {
#line 693
    freearray(pparams);
#line 694
    pparams = zarrdup(args);
    }
  }
  {
#line 696
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 696
    queueing_enabled --;
#line 696
    if (! queueing_enabled) {
      {
#line 696
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 696
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 696
          if (! (queue_front != queue_rear)) {
#line 696
            goto while_break___7;
          }
          {
#line 696
          queue_front = (queue_front + 1) % 128;
#line 696
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 696
          zhandler(signal_queue[queue_front]);
#line 696
          signal_setmask(oset___0);
          }
        }
        while_break___7: /* CIL Label */ ;
        }
#line 696
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 696
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 697
  return (0);
}
}
#line 703 "/tmp/zsh-5.4.2/Src/builtin.c"
int doprintdir  =    0;
#line 708 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_pwd(char *name  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
            Options ops , int func  __attribute__((__unused__)) ) 
{ 
  char *tmp ;

  {
#line 711
  if ((int )ops->ind[114] != 0) {
    {
#line 713
    tmp = zgetcwd();
#line 713
    printf((char const   */* __restrict  */)"%s\n", tmp);
    }
  } else
#line 711
  if ((int )ops->ind[80] != 0) {
    {
#line 713
    tmp = zgetcwd();
#line 713
    printf((char const   */* __restrict  */)"%s\n", tmp);
    }
  } else
#line 711
  if (opts[31]) {
#line 711
    if (! ((int )ops->ind[76] != 0)) {
      {
#line 713
      tmp = zgetcwd();
#line 713
      printf((char const   */* __restrict  */)"%s\n", tmp);
      }
    } else {
      {
#line 715
      zputs((char const   *)pwd, stdout);
#line 716
      putchar('\n');
      }
    }
  } else {
    {
#line 715
    zputs((char const   *)pwd, stdout);
#line 716
    putchar('\n');
    }
  }
#line 718
  return (0);
}
}
#line 729 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_dirs(char *name  __attribute__((__unused__)) , char **argv , Options ops ,
             int func  __attribute__((__unused__)) ) 
{ 
  LinkList l ;
  LinkNode node ;
  char *fmt ;
  int pos ;
  int tmp ;
  sigset_t oset ;
  char **tmp___0 ;
  char *tmp___1 ;
  sigset_t oset___0 ;

  {
#line 734
  queueing_enabled ++;
#line 736
  if (*argv) {
#line 736
    goto _L___0;
  } else
#line 736
  if ((int )ops->ind[99] != 0) {
    _L___0: /* CIL Label */ 
#line 736
    if ((int )ops->ind[118] != 0) {
#line 736
      goto _L;
    } else
#line 736
    if ((int )ops->ind[112] != 0) {
      _L: /* CIL Label */ 
#line 740
      pos = 1;
#line 743
      if ((int )ops->ind[118] != 0) {
        {
#line 744
        printf((char const   */* __restrict  */)"0\t");
#line 745
        fmt = (char *)"\n%d\t";
        }
      } else
#line 747
      if ((int )ops->ind[112] != 0) {
#line 748
        fmt = (char *)"\n";
      } else {
#line 750
        fmt = (char *)" ";
      }
#line 751
      if ((int )ops->ind[108] != 0) {
        {
#line 752
        zputs((char const   *)pwd, stdout);
        }
      } else {
        {
#line 754
        fprintdir(pwd, stdout);
        }
      }
#line 755
      node = dirstack->list.first;
      {
#line 755
      while (1) {
        while_continue: /* CIL Label */ ;
#line 755
        if (! node) {
#line 755
          goto while_break;
        }
        {
#line 756
        tmp = pos;
#line 756
        pos ++;
#line 756
        printf((char const   */* __restrict  */)fmt, tmp);
        }
#line 757
        if ((int )ops->ind[108] != 0) {
          {
#line 758
          zputs((char const   *)node->dat, stdout);
          }
        } else {
          {
#line 760
          fprintdir((char *)node->dat, stdout);
          }
        }
#line 755
        node = node->next;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 763
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 763
        queueing_enabled --;
#line 763
        if (! queueing_enabled) {
          {
#line 763
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 763
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 763
              if (! (queue_front != queue_rear)) {
#line 763
                goto while_break___2;
              }
              {
#line 763
              queue_front = (queue_front + 1) % 128;
#line 763
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 763
              zhandler(signal_queue[queue_front]);
#line 763
              signal_setmask(oset);
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 763
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 763
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 764
      putchar('\n');
      }
#line 765
      return (0);
    }
  } else {
#line 736
    goto _L;
  }
  {
#line 768
  l = znewlinklist();
  }
  {
#line 769
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 769
    if (! *argv) {
#line 769
      goto while_break___3;
    }
    {
#line 770
    tmp___0 = argv;
#line 770
    argv ++;
#line 770
    tmp___1 = ztrdup((char const   *)*tmp___0);
#line 770
    zinsertlinknode(l, l->list.last, (void *)tmp___1);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 771
  freelinklist(dirstack, & freestr);
#line 772
  dirstack = l;
  }
  {
#line 773
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 773
    queueing_enabled --;
#line 773
    if (! queueing_enabled) {
      {
#line 773
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 773
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 773
          if (! (queue_front != queue_rear)) {
#line 773
            goto while_break___6;
          }
          {
#line 773
          queue_front = (queue_front + 1) % 128;
#line 773
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 773
          zhandler(signal_queue[queue_front]);
#line 773
          signal_setmask(oset___0);
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 773
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 773
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 774
  return (0);
}
}
#line 780 "/tmp/zsh-5.4.2/Src/builtin.c"
void set_pwd_env(void) 
{ 
  Param pm ;
  HashNode tmp ;
  HashNode tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  HashNode tmp___3 ;
  HashNode tmp___4 ;

  {
  {
#line 787
  tmp = (*(paramtab->getnode))(paramtab, "PWD");
#line 787
  pm = (Param )tmp;
  }
#line 788
  if (pm) {
#line 788
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) != 0) {
      {
#line 789
      pm->node.flags &= ~ (1 << 10);
#line 790
      unsetparam_pm(pm, 0, 1);
      }
    }
  }
  {
#line 793
  tmp___0 = (*(paramtab->getnode))(paramtab, "OLDPWD");
#line 793
  pm = (Param )tmp___0;
  }
#line 794
  if (pm) {
#line 794
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) != 0) {
      {
#line 795
      pm->node.flags &= ~ (1 << 10);
#line 796
      unsetparam_pm(pm, 0, 1);
      }
    }
  }
  {
#line 799
  tmp___1 = ztrdup((char const   *)pwd);
#line 799
  assignsparam((char *)"PWD", tmp___1, 0);
#line 800
  tmp___2 = ztrdup((char const   *)oldpwd);
#line 800
  assignsparam((char *)"OLDPWD", tmp___2, 0);
#line 802
  tmp___3 = (*(paramtab->getnode))(paramtab, "PWD");
#line 802
  pm = (Param )tmp___3;
  }
#line 803
  if (! (pm->node.flags & (1 << 12))) {
    {
#line 804
    addenv(pm, pwd);
    }
  }
  {
#line 805
  tmp___4 = (*(paramtab->getnode))(paramtab, "OLDPWD");
#line 805
  pm = (Param )tmp___4;
  }
#line 806
  if (! (pm->node.flags & (1 << 12))) {
    {
#line 807
    addenv(pm, oldpwd);
    }
  }
#line 808
  return;
}
}
#line 811 "/tmp/zsh-5.4.2/Src/builtin.c"
static int chasinglinks  ;
#line 820 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_cd(char *nam , char **argv , Options ops , int func ) 
{ 
  LinkNode dir ;
  struct stat st1 ;
  struct stat st2 ;
  int tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  sigset_t oset ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  sigset_t oset___0 ;

  {
#line 826
  if (opts[154]) {
    {
#line 827
    zwarnnam((char const   *)nam, "restricted");
    }
#line 828
    return (1);
  }
#line 830
  doprintdir = doprintdir == -1;
#line 832
  if ((int )ops->ind[80] != 0) {
#line 832
    tmp = 1;
  } else
#line 832
  if (opts[31]) {
#line 832
    if (! ((int )ops->ind[76] != 0)) {
#line 832
      tmp = 1;
    } else {
#line 832
      tmp = 0;
    }
  } else {
#line 832
    tmp = 0;
  }
  {
#line 832
  chasinglinks = tmp;
#line 834
  queueing_enabled ++;
#line 835
  tmp___0 = ztrdup((char const   *)pwd);
#line 835
  zinsertlinknode(dirstack, & dirstack->node, (void *)tmp___0);
#line 836
  dir = cd_get_dest(nam, argv, (int )ops->ind[115] != 0, func);
  }
#line 836
  if (! dir) {
    {
#line 837
    tmp___1 = getlinknode(dirstack);
#line 837
    zsfree((char *)tmp___1);
    }
    {
#line 838
    while (1) {
      while_continue: /* CIL Label */ ;
#line 838
      queueing_enabled --;
#line 838
      if (! queueing_enabled) {
        {
#line 838
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 838
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 838
            if (! (queue_front != queue_rear)) {
#line 838
              goto while_break___1;
            }
            {
#line 838
            queue_front = (queue_front + 1) % 128;
#line 838
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 838
            zhandler(signal_queue[queue_front]);
#line 838
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 838
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 838
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 839
    return (1);
  }
  {
#line 841
  cd_new_pwd(func, dir, (int )ops->ind[113] != 0);
#line 843
  tmp___11 = unmeta((char const   *)pwd);
#line 843
  tmp___12 = stat((char const   */* __restrict  */)tmp___11, (struct stat */* __restrict  */)(& st1));
  }
#line 843
  if (tmp___12 < 0) {
    {
#line 844
    setjobpwd();
#line 845
    zsfree(pwd);
#line 846
    pwd = (char *)((void *)0);
#line 847
    tmp___2 = zgetcwd();
#line 847
    pwd = metafy(tmp___2, -1, 3);
    }
  } else {
    {
#line 848
    tmp___10 = stat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& st2));
    }
#line 848
    if (tmp___10 < 0) {
      {
#line 849
      tmp___4 = unmeta((char const   *)pwd);
#line 849
      tmp___5 = chdir((char const   *)tmp___4);
      }
#line 849
      if (tmp___5 < 0) {
        {
#line 850
        tmp___3 = __errno_location();
#line 850
        zwarn("unable to chdir(%s): %e", pwd, *tmp___3);
        }
      }
    } else
#line 851
    if (st1.st_ino != st2.st_ino) {
#line 851
      goto _L;
    } else
#line 851
    if (st1.st_dev != st2.st_dev) {
      _L: /* CIL Label */ 
#line 852
      if (chasinglinks) {
        {
#line 853
        setjobpwd();
#line 854
        zsfree(pwd);
#line 855
        pwd = (char *)((void *)0);
#line 856
        tmp___6 = zgetcwd();
#line 856
        pwd = metafy(tmp___6, -1, 3);
        }
      } else {
        {
#line 857
        tmp___8 = unmeta((char const   *)pwd);
#line 857
        tmp___9 = chdir((char const   *)tmp___8);
        }
#line 857
        if (tmp___9 < 0) {
          {
#line 858
          tmp___7 = __errno_location();
#line 858
          zwarn("unable to chdir(%s): %e", pwd, *tmp___7);
          }
        }
      }
    }
  }
  {
#line 860
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 860
    queueing_enabled --;
#line 860
    if (! queueing_enabled) {
      {
#line 860
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 860
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 860
          if (! (queue_front != queue_rear)) {
#line 860
            goto while_break___4;
          }
          {
#line 860
          queue_front = (queue_front + 1) % 128;
#line 860
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 860
          zhandler(signal_queue[queue_front]);
#line 860
          signal_setmask(oset___0);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 860
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 860
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 861
  return (0);
}
}
#line 867 "/tmp/zsh-5.4.2/Src/builtin.c"
static LinkNode cd_get_dest(char *nam , char **argv , int hard , int func ) 
{ 
  LinkNode dir ;
  LinkNode target ;
  char *dest ;
  void *tmp ;
  char *tmp___0 ;
  int dd ;
  char *end ;
  zlong tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *u ;
  char *d___0 ;
  int len1 ;
  int len2 ;
  int len3 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  LinkNode tmp___14 ;

  {
#line 870
  dir = (LinkNode )((void *)0);
#line 874
  if (! *(argv + 0)) {
#line 875
    if (func == 11) {
#line 875
      if (! (dirstack->list.first)->next) {
        {
#line 876
        zwarnnam((char const   *)nam, "directory stack empty");
        }
#line 877
        return ((LinkNode )((void *)0));
      }
    }
#line 879
    if (func == 12) {
#line 879
      if (! opts[148]) {
#line 880
        dir = (dirstack->list.first)->next;
      }
    }
#line 881
    if (dir) {
      {
#line 882
      tmp = getlinknode(dirstack);
#line 882
      zinsertlinknode(dirstack, dir, tmp);
      }
    } else
#line 883
    if (func != 11) {
#line 884
      if (! home) {
        {
#line 885
        zwarnnam((char const   *)nam, "HOME not set");
        }
#line 886
        return ((LinkNode )((void *)0));
      }
      {
#line 888
      tmp___0 = ztrdup((char const   *)home);
#line 888
      zinsertlinknode(dirstack, & dirstack->node, (void *)tmp___0);
      }
    }
  } else
#line 890
  if (! *(argv + 1)) {
#line 894
    doprintdir ++;
#line 895
    if (*(*(argv + 0) + 1)) {
#line 895
      if ((int )*(*(argv + 0) + 0) == 43) {
#line 895
        goto _L;
      } else
#line 895
      if ((int )*(*(argv + 0) + 0) == 45) {
        _L: /* CIL Label */ 
        {
#line 895
        tmp___2 = strspn((char const   *)(*(argv + 0) + 1), "0123456789");
#line 895
        tmp___3 = strlen((char const   *)(*(argv + 0) + 1));
        }
#line 895
        if (tmp___2 == tmp___3) {
          {
#line 897
          tmp___1 = zstrtol((char const   *)(*(argv + 0) + 1), & end, 10);
#line 897
          dd = (int )tmp___1;
          }
#line 898
          if ((int )*end == 0) {
#line 899
            if (((int )*(*(argv + 0) + 0) == 43) ^ (int )opts[146]) {
#line 900
              dir = dirstack->list.first;
              {
#line 900
              while (1) {
                while_continue: /* CIL Label */ ;
#line 900
                if (dir) {
#line 900
                  if (! dd) {
#line 900
                    goto while_break;
                  }
                } else {
#line 900
                  goto while_break;
                }
#line 900
                dd --;
#line 900
                dir = dir->next;
              }
              while_break: /* CIL Label */ ;
              }
            } else {
#line 902
              dir = dirstack->list.last;
              {
#line 902
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 902
                if ((unsigned long )dir != (unsigned long )((LinkNode )dirstack)) {
#line 902
                  if (! dd) {
#line 902
                    goto while_break___0;
                  }
                } else {
#line 902
                  goto while_break___0;
                }
#line 902
                dd --;
#line 902
                dir = dir->prev;
              }
              while_break___0: /* CIL Label */ ;
              }
            }
#line 904
            if (! dir) {
              {
#line 905
              zwarnnam((char const   *)nam, "no such entry in dir stack");
              }
#line 906
              return ((LinkNode )((void *)0));
            } else
#line 904
            if ((unsigned long )dir == (unsigned long )((LinkNode )dirstack)) {
              {
#line 905
              zwarnnam((char const   *)nam, "no such entry in dir stack");
              }
#line 906
              return ((LinkNode )((void *)0));
            }
          }
        }
      }
    }
#line 910
    if (! dir) {
      {
#line 911
      tmp___6 = strcmp((char const   *)*(argv + 0), "-");
      }
#line 911
      if (tmp___6) {
#line 911
        doprintdir --;
#line 911
        tmp___5 = *(argv + 0);
      } else {
#line 911
        tmp___5 = oldpwd;
      }
      {
#line 911
      tmp___7 = ztrdup((char const   *)tmp___5);
#line 911
      zinsertlinknode(dirstack, & dirstack->node, (void *)tmp___7);
      }
    }
  } else {
    {
#line 917
    u = strstr((char const   *)pwd, (char const   *)*(argv + 0));
    }
#line 917
    if (! u) {
      {
#line 918
      zwarnnam((char const   *)nam, "string not in pwd: %s", *(argv + 0));
      }
#line 919
      return ((LinkNode )((void *)0));
    }
    {
#line 921
    tmp___8 = strlen((char const   *)*(argv + 0));
#line 921
    len1 = (int )tmp___8;
#line 922
    tmp___9 = strlen((char const   *)*(argv + 1));
#line 922
    len2 = (int )tmp___9;
#line 923
    len3 = (int )(u - pwd);
#line 924
    tmp___10 = strlen((char const   *)(u + len1));
#line 924
    tmp___11 = zalloc(((size_t )(len3 + len2) + tmp___10) + 1UL);
#line 924
    d___0 = (char *)tmp___11;
#line 925
    strncpy((char */* __restrict  */)d___0, (char const   */* __restrict  */)pwd,
            (size_t )len3);
#line 926
    strcpy((char */* __restrict  */)(d___0 + len3), (char const   */* __restrict  */)*(argv + 1));
#line 927
    strcat((char */* __restrict  */)d___0, (char const   */* __restrict  */)(u + len1));
#line 928
    zinsertlinknode(dirstack, & dirstack->node, (void *)d___0);
#line 929
    doprintdir ++;
    }
  }
#line 932
  target = dir;
#line 933
  if (func == 11) {
#line 934
    if (! dir) {
#line 935
      dir = dirstack->list.first;
#line 935
      target = dir;
    } else
#line 936
    if ((unsigned long )dir != (unsigned long )dirstack->list.first) {
#line 937
      return (dir);
    }
#line 939
    dir = dir->next;
  }
#line 941
  if (! dir) {
#line 942
    dir = dirstack->list.first;
  }
#line 944
  if (! dir) {
#line 946
    return ((LinkNode )((void *)0));
  } else
#line 944
  if (! dir->dat) {
#line 946
    return ((LinkNode )((void *)0));
  }
  {
#line 948
  dest = cd_do_chdir(nam, (char *)dir->dat, hard);
  }
#line 948
  if (! dest) {
#line 949
    if (! target) {
      {
#line 950
      tmp___12 = getlinknode(dirstack);
#line 950
      zsfree((char *)tmp___12);
      }
    }
#line 951
    if (func == 11) {
      {
#line 952
      tmp___13 = remnode(dirstack, dir);
#line 952
      zsfree((char *)tmp___13);
      }
    }
#line 953
    return ((LinkNode )((void *)0));
  }
#line 955
  if ((unsigned long )dest != (unsigned long )((char *)dir->dat)) {
    {
#line 956
    zsfree((char *)dir->dat);
#line 957
    dir->dat = (void *)dest;
    }
  }
#line 959
  if (target) {
#line 959
    tmp___14 = target;
  } else {
#line 959
    tmp___14 = dir;
  }
#line 959
  return (tmp___14);
}
}
#line 969 "/tmp/zsh-5.4.2/Src/builtin.c"
static char *cd_do_chdir(char *cnam , char *dest , int hard ) 
{ 
  char **pp ;
  char *ret ;
  int hasdot ;
  int eno ;
  int nocdpath ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 973
  hasdot = 0;
#line 973
  eno = 2;
#line 999
  if ((int )*(dest + 0) == 46) {
#line 999
    if ((int )*(dest + 1) == 47) {
#line 999
      tmp = 1;
    } else
#line 999
    if (! *(dest + 1)) {
#line 999
      tmp = 1;
    } else
#line 999
    if ((int )*(dest + 1) == 46) {
#line 999
      if ((int )*(dest + 2) == 47) {
#line 999
        tmp = 1;
      } else
#line 999
      if (! *(dest + 2)) {
#line 999
        tmp = 1;
      } else {
#line 999
        tmp = 0;
      }
    } else {
#line 999
      tmp = 0;
    }
  } else {
#line 999
    tmp = 0;
  }
#line 999
  nocdpath = tmp;
#line 1006
  if ((int )*dest == 47) {
    {
#line 1007
    ret = cd_try_chdir((char *)((void *)0), dest, hard);
    }
#line 1007
    if (ret) {
#line 1008
      return (ret);
    }
    {
#line 1009
    tmp___0 = __errno_location();
#line 1009
    zwarnnam((char const   *)cnam, "%e: %s", *tmp___0, dest);
    }
#line 1010
    return ((char *)((void *)0));
  }
#line 1018
  if (! nocdpath) {
#line 1018
    if (! opts[132]) {
#line 1019
      pp = cdpath;
      {
#line 1019
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1019
        if (! *pp) {
#line 1019
          goto while_break;
        }
#line 1020
        if (! *(*pp + 0)) {
#line 1021
          hasdot = 1;
        } else
#line 1020
        if ((int )*(*pp + 0) == 46) {
#line 1020
          if ((int )*(*pp + 1) == 0) {
#line 1021
            hasdot = 1;
          }
        }
#line 1019
        pp ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1029
  if (! hasdot) {
#line 1029
    if (! opts[132]) {
      {
#line 1030
      ret = cd_try_chdir((char *)((void *)0), dest, hard);
      }
#line 1030
      if (ret) {
#line 1031
        return (ret);
      }
      {
#line 1032
      tmp___2 = __errno_location();
      }
#line 1032
      if (*tmp___2 != 2) {
        {
#line 1033
        tmp___1 = __errno_location();
#line 1033
        eno = *tmp___1;
        }
      }
    }
  }
#line 1037
  if (! nocdpath) {
#line 1038
    pp = cdpath;
    {
#line 1038
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1038
      if (! *pp) {
#line 1038
        goto while_break___0;
      }
      {
#line 1039
      ret = cd_try_chdir(*pp, dest, hard);
      }
#line 1039
      if (ret) {
#line 1040
        if (opts[132]) {
#line 1047
          if (*(*pp)) {
#line 1048
            doprintdir ++;
          }
        } else {
          {
#line 1050
          tmp___3 = strcmp((char const   *)*pp, ".");
          }
#line 1050
          if (tmp___3) {
#line 1051
            doprintdir ++;
          }
        }
#line 1054
        return (ret);
      }
      {
#line 1056
      tmp___5 = __errno_location();
      }
#line 1056
      if (*tmp___5 != 2) {
        {
#line 1057
        tmp___4 = __errno_location();
#line 1057
        eno = *tmp___4;
        }
      }
#line 1038
      pp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1062
  if (opts[132]) {
    {
#line 1063
    ret = cd_try_chdir((char *)((void *)0), dest, hard);
    }
#line 1063
    if (ret) {
#line 1064
      return (ret);
    }
    {
#line 1065
    tmp___7 = __errno_location();
    }
#line 1065
    if (*tmp___7 != 2) {
      {
#line 1066
      tmp___6 = __errno_location();
#line 1066
      eno = *tmp___6;
      }
    }
  }
  {
#line 1070
  ret = cd_able_vars(dest);
  }
#line 1070
  if (ret) {
    {
#line 1071
    ret = cd_try_chdir((char *)((void *)0), ret, hard);
    }
#line 1071
    if (ret) {
#line 1072
      doprintdir ++;
#line 1073
      return (ret);
    }
    {
#line 1075
    tmp___9 = __errno_location();
    }
#line 1075
    if (*tmp___9 != 2) {
      {
#line 1076
      tmp___8 = __errno_location();
#line 1076
      eno = *tmp___8;
      }
    }
  }
  {
#line 1082
  zwarnnam((char const   *)cnam, "%e: %s", eno, dest);
  }
#line 1083
  return ((char *)((void *)0));
}
}
#line 1090 "/tmp/zsh-5.4.2/Src/builtin.c"
char *cd_able_vars(char *s ) 
{ 
  char *rest ;
  char save ;

  {
#line 1095
  if (opts[29]) {
#line 1096
    rest = s;
    {
#line 1096
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1096
      if (*rest) {
#line 1096
        if (! ((int )*rest != 47)) {
#line 1096
          goto while_break;
        }
      } else {
#line 1096
        goto while_break;
      }
#line 1096
      rest ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1097
    save = *rest;
#line 1098
    *rest = (char)0;
#line 1099
    s = getnameddir(s);
#line 1100
    *rest = save;
    }
#line 1102
    if (s) {
#line 1102
      if (*rest) {
        {
#line 1103
        s = dyncat((char const   *)s, (char const   *)rest);
        }
      }
    }
#line 1105
    return (s);
  }
#line 1107
  return ((char *)((void *)0));
}
}
#line 1118 "/tmp/zsh-5.4.2/Src/builtin.c"
static char *cd_try_chdir(char *pfix , char *dest , int hard ) 
{ 
  char *buf___7 ;
  int dlen ;
  int dochaselinks ;
  int pfl ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 1122
  dochaselinks = 0;
#line 1125
  if (pfix) {
#line 1125
    if (*pfix) {
#line 1126
      if ((int )*pfix == 47) {
        {
#line 1136
        buf___7 = tricat((char const   *)pfix, "/", (char const   *)dest);
        }
      } else {
        {
#line 1139
        tmp = strlen((char const   *)pfix);
#line 1139
        pfl = (int )tmp;
#line 1140
        tmp___0 = strlen((char const   *)pwd);
#line 1140
        dlen = (int )tmp___0;
        }
#line 1141
        if (dlen == 1) {
#line 1141
          if ((int )*pwd == 47) {
#line 1142
            dlen = 0;
          }
        }
        {
#line 1143
        tmp___1 = strlen((char const   *)dest);
#line 1143
        tmp___2 = zalloc(((size_t )(dlen + pfl) + tmp___1) + 3UL);
#line 1143
        buf___7 = (char *)tmp___2;
        }
#line 1144
        if (dlen) {
          {
#line 1145
          strcpy((char */* __restrict  */)buf___7, (char const   */* __restrict  */)pwd);
          }
        }
        {
#line 1146
        *(buf___7 + dlen) = (char )'/';
#line 1147
        strcpy((char */* __restrict  */)((buf___7 + dlen) + 1), (char const   */* __restrict  */)pfix);
#line 1148
        *(buf___7 + ((dlen + 1) + pfl)) = (char )'/';
#line 1149
        strcpy((char */* __restrict  */)(((buf___7 + dlen) + pfl) + 2), (char const   */* __restrict  */)dest);
        }
      }
    } else {
#line 1125
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1151
  if ((int )*dest == 47) {
    {
#line 1152
    buf___7 = ztrdup((char const   *)dest);
    }
  } else {
    {
#line 1154
    tmp___3 = strlen((char const   *)pwd);
#line 1154
    dlen = (int )tmp___3;
    }
#line 1155
    if ((int )*(pwd + (dlen - 1)) == 47) {
#line 1156
      dlen --;
    }
    {
#line 1157
    tmp___4 = strlen((char const   *)dest);
#line 1157
    tmp___5 = zalloc(((size_t )dlen + tmp___4) + 2UL);
#line 1157
    buf___7 = (char *)tmp___5;
#line 1158
    strcpy((char */* __restrict  */)buf___7, (char const   */* __restrict  */)pwd);
#line 1159
    *(buf___7 + dlen) = (char )'/';
#line 1160
    strcpy((char */* __restrict  */)((buf___7 + dlen) + 1), (char const   */* __restrict  */)dest);
    }
  }
#line 1166
  if (! chasinglinks) {
    {
#line 1167
    dochaselinks = fixdir(buf___7);
    }
  } else {
    {
#line 1169
    unmetafy(buf___7, & dlen);
    }
  }
  {
#line 1175
  tmp___6 = lchdir((char const   *)buf___7, (struct dirsav *)((void *)0), hard);
  }
#line 1175
  if (tmp___6) {
#line 1175
    if (pfix) {
      {
#line 1177
      free((void *)buf___7);
      }
#line 1178
      return ((char *)((void *)0));
    } else
#line 1175
    if ((int )*dest == 47) {
      {
#line 1177
      free((void *)buf___7);
      }
#line 1178
      return ((char *)((void *)0));
    } else {
      {
#line 1175
      tmp___7 = unmeta((char const   *)dest);
#line 1175
      tmp___8 = lchdir((char const   *)tmp___7, (struct dirsav *)((void *)0), hard);
      }
#line 1175
      if (tmp___8) {
        {
#line 1177
        free((void *)buf___7);
        }
#line 1178
        return ((char *)((void *)0));
      }
    }
  }
#line 1181
  if (dochaselinks) {
#line 1182
    chasinglinks = 1;
  }
  {
#line 1183
  tmp___9 = metafy(buf___7, -1, 5);
  }
#line 1183
  return (tmp___9);
}
}
#line 1189 "/tmp/zsh-5.4.2/Src/builtin.c"
static void cd_new_pwd(int func , LinkNode dir , int quiet ) 
{ 
  char *new_pwd ;
  char *s ;
  int dirstacksize ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  LinkNode n ;
  void *tmp___2 ;
  int tmp___3 ;
  zlong tmp___4 ;
  int remove___0 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;

  {
#line 1195
  if (func == 12) {
    {
#line 1196
    rolllist(dirstack, dir);
    }
  }
  {
#line 1197
  tmp = remnode(dirstack, dir);
#line 1197
  new_pwd = (char *)tmp;
  }
#line 1199
  if (func == 11) {
#line 1199
    if (dirstack->list.first) {
      {
#line 1200
      zsfree(new_pwd);
#line 1201
      tmp___0 = getlinknode(dirstack);
#line 1201
      new_pwd = (char *)tmp___0;
      }
    } else {
#line 1199
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1202
  if (func == 10) {
#line 1202
    if (! opts[14]) {
      {
#line 1203
      tmp___1 = getlinknode(dirstack);
#line 1203
      zsfree((char *)tmp___1);
      }
    }
  }
#line 1205
  if (chasinglinks) {
    {
#line 1206
    s = findpwd(new_pwd);
    }
#line 1207
    if (s) {
      {
#line 1208
      zsfree(new_pwd);
#line 1209
      new_pwd = s;
      }
    }
  }
#line 1212
  if (opts[145]) {
#line 1214
    n = dirstack->list.first;
    {
#line 1214
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1214
      if (! n) {
#line 1214
        goto while_break;
      }
      {
#line 1215
      tmp___3 = strcmp((char const   *)new_pwd, (char const   *)n->dat);
      }
#line 1215
      if (! tmp___3) {
        {
#line 1216
        tmp___2 = remnode(dirstack, n);
#line 1216
        zsfree((char *)tmp___2);
        }
#line 1217
        goto while_break;
      }
#line 1214
      n = n->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1224
  zsfree(oldpwd);
#line 1225
  oldpwd = pwd;
#line 1226
  setjobpwd();
#line 1227
  pwd = new_pwd;
#line 1228
  set_pwd_env();
  }
#line 1230
  if (opts[93]) {
#line 1230
    goto _L___1;
  } else
#line 1230
  if (opts[132]) {
    _L___1: /* CIL Label */ 
#line 1231
    if (func != 10) {
#line 1231
      if (opts[93]) {
#line 1232
        if (! opts[147]) {
#line 1232
          if (! quiet) {
            {
#line 1233
            printdirstack();
            }
          }
        }
      } else {
#line 1231
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1234
    if (doprintdir) {
      {
#line 1235
      fprintdir(pwd, stdout);
#line 1236
      putchar('\n');
      }
    }
  }
  {
#line 1241
  fflush(stdout);
#line 1242
  fflush(stderr);
  }
#line 1243
  if (! quiet) {
    {
#line 1244
    callhookfunc((char *)"chpwd", (LinkList )((void *)0), 1, (int *)((void *)0));
    }
  }
  {
#line 1246
  tmp___4 = getiparam((char *)"DIRSTACKSIZE");
#line 1246
  dirstacksize = (int )tmp___4;
  }
#line 1248
  if (dirstacksize > 0) {
    {
#line 1249
    tmp___5 = countlinknodes(dirstack);
    }
#line 1249
    if (dirstacksize < 2) {
#line 1249
      tmp___6 = 2;
    } else {
#line 1249
      tmp___6 = dirstacksize;
    }
#line 1249
    remove___0 = tmp___5 - tmp___6;
    {
#line 1251
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1251
      tmp___8 = remove___0;
#line 1251
      remove___0 --;
#line 1251
      if (! (tmp___8 >= 0)) {
#line 1251
        goto while_break___0;
      }
      {
#line 1252
      tmp___7 = remnode(dirstack, dirstack->list.last);
#line 1252
      zsfree((char *)tmp___7);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1254
  return;
}
}
#line 1259 "/tmp/zsh-5.4.2/Src/builtin.c"
static void printdirstack(void) 
{ 
  LinkNode node ;

  {
  {
#line 1264
  fprintdir(pwd, stdout);
#line 1265
  node = dirstack->list.first;
  }
  {
#line 1265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1265
    if (! node) {
#line 1265
      goto while_break;
    }
    {
#line 1266
    putchar(' ');
#line 1267
    fprintdir((char *)node->dat, stdout);
#line 1265
    node = node->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1269
  putchar('\n');
  }
#line 1270
  return;
}
}
#line 1279 "/tmp/zsh-5.4.2/Src/builtin.c"
int fixdir(char *src ) 
{ 
  char *dest ;
  char *d0 ;
  int chasedots ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct stat st___0 ;
  char *ptrd ;
  char *ptrs ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char tmp___5 ;
  char *tmp___6 ;

  {
#line 1282
  dest = src;
#line 1282
  d0 = dest;
#line 1301
  if ((int )*(src + 0) == 46) {
#line 1301
    if ((int )*(pwd + 0) == 46) {
#line 1301
      if ((int )*(pwd + 1) == 0) {
#line 1301
        if ((int )*(src + 1) == 47) {
#line 1301
          tmp = 1;
        } else
#line 1301
        if ((int )*(src + 1) == 46) {
#line 1301
          if ((int )*(src + 2) == 47) {
#line 1301
            tmp = 1;
          } else {
#line 1301
            tmp = 0;
          }
        } else {
#line 1301
          tmp = 0;
        }
      } else {
#line 1301
        tmp = 0;
      }
    } else {
#line 1301
      tmp = 0;
    }
  } else {
#line 1301
    tmp = 0;
  }
#line 1301
  chasedots = tmp * 2;
  {
#line 1316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1318
    if ((int )*src == 47) {
#line 1324
      tmp___0 = dest;
#line 1324
      dest ++;
#line 1324
      tmp___1 = src;
#line 1324
      src ++;
#line 1324
      *tmp___0 = *tmp___1;
      {
#line 1325
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1325
        if (! ((int )*src == 47)) {
#line 1325
          goto while_break___0;
        }
#line 1326
        src ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1330
    if (! *src) {
      {
#line 1331
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1331
        if ((unsigned long )dest > (unsigned long )(d0 + 1)) {
#line 1331
          if (! ((int )*(dest + -1) == 47)) {
#line 1331
            goto while_break___1;
          }
        } else {
#line 1331
          goto while_break___1;
        }
#line 1332
        dest --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1333
      *dest = (char )'\000';
#line 1334
      return (chasedots);
    }
#line 1336
    if ((int )*(src + 0) == 46) {
#line 1336
      if ((int )*(src + 1) == 46) {
#line 1336
        if ((int )*(src + 2) == 0) {
#line 1336
          goto _L___0;
        } else
#line 1336
        if ((int )*(src + 2) == 47) {
          _L___0: /* CIL Label */ 
#line 1338
          if (opts[30]) {
#line 1339
            chasedots = 1;
          } else
#line 1338
          if (chasedots > 1) {
#line 1339
            chasedots = 1;
          } else {
#line 1342
            if ((unsigned long )dest > (unsigned long )(d0 + 1)) {
              {
#line 1348
              *dest = (char )'\000';
#line 1349
              tmp___2 = stat((char const   */* __restrict  */)d0, (struct stat */* __restrict  */)(& st___0));
              }
#line 1349
              if (tmp___2 < 0) {
#line 1349
                goto _L;
              } else
#line 1349
              if (! ((st___0.st_mode & 61440U) == 16384U)) {
                _L: /* CIL Label */ 
#line 1351
                if ((unsigned long )dest == (unsigned long )src) {
#line 1352
                  *dest = (char )'.';
                }
#line 1353
                ptrs = src;
#line 1353
                ptrd = dest;
                {
#line 1353
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 1353
                  if (! *ptrs) {
#line 1353
                    goto while_break___2;
                  }
#line 1354
                  if ((int )*ptrs == -125) {
#line 1354
                    ptrs ++;
#line 1354
                    *ptrd = (char )((int )*ptrs ^ 32);
                  } else {
#line 1354
                    *ptrd = *ptrs;
                  }
#line 1353
                  ptrs ++;
#line 1353
                  ptrd ++;
                }
                while_break___2: /* CIL Label */ ;
                }
#line 1355
                *ptrd = (char )'\000';
#line 1356
                return (1);
              }
#line 1358
              dest --;
              {
#line 1358
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1358
                if ((unsigned long )dest > (unsigned long )(d0 + 1)) {
#line 1358
                  if (! ((int )*(dest + -1) != 47)) {
#line 1358
                    goto while_break___3;
                  }
                } else {
#line 1358
                  goto while_break___3;
                }
#line 1358
                dest --;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 1359
              if ((int )*(dest + -1) != 47) {
#line 1360
                dest --;
              }
            }
#line 1362
            src ++;
            {
#line 1363
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1363
              src ++;
#line 1363
              if (! ((int )*src == 47)) {
#line 1363
                goto while_break___4;
              }
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1364
            goto __Cont;
          }
        }
      }
    }
#line 1367
    if ((int )*(src + 0) == 46) {
#line 1367
      if ((int )*(src + 1) == 47) {
#line 1367
        goto _L___2;
      } else
#line 1367
      if ((int )*(src + 1) == 0) {
        _L___2: /* CIL Label */ 
        {
#line 1369
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1369
          src ++;
#line 1369
          if (! ((int )*src == 47)) {
#line 1369
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
#line 1367
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 1372
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1372
        if ((int )*src != 47) {
#line 1372
          if (! ((int )*src != 0)) {
#line 1372
            goto while_break___6;
          }
        } else {
#line 1372
          goto while_break___6;
        }
#line 1373
        tmp___4 = dest;
#line 1373
        dest ++;
#line 1373
        tmp___6 = src;
#line 1373
        src ++;
#line 1373
        tmp___5 = *tmp___6;
#line 1373
        *tmp___4 = tmp___5;
#line 1373
        if ((int )tmp___5 == -125) {
#line 1374
          tmp___3 = src;
#line 1374
          src ++;
#line 1374
          *(dest + -1) = (char )((int )*tmp___3 ^ 32);
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1381 "/tmp/zsh-5.4.2/Src/builtin.c"
void printqt(char *str ) 
{ 
  char const   *tmp ;

  {
  {
#line 1385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1385
    if (! *str) {
#line 1385
      goto while_break;
    }
#line 1386
    if ((int )*str == 39) {
#line 1387
      if (opts[150]) {
#line 1387
        tmp = "\'\'";
      } else {
#line 1387
        tmp = "\'\\\'\'";
      }
      {
#line 1387
      printf((char const   */* __restrict  */)tmp);
      }
    } else {
      {
#line 1389
      putchar((int )*str);
      }
    }
#line 1385
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1390
  return;
}
}
#line 1393 "/tmp/zsh-5.4.2/Src/builtin.c"
void printif(char *str , int c ) 
{ 


  {
#line 1397
  if (str) {
    {
#line 1398
    printf((char const   */* __restrict  */)" -%c ", c);
#line 1399
    quotedzputs((char const   *)str, stdout);
    }
  }
#line 1401
  return;
}
}
#line 1408 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_fc(char *nam , char **argv , Options ops , int func ) 
{ 
  zlong first ;
  zlong last ;
  int retval ;
  char *s ;
  struct asgment *asgf ;
  struct asgment *asgl ;
  Patprog pprog ;
  char *hf ;
  zlong hs ;
  zlong shs ;
  int level ;
  int tmp ;
  char **tmp___0 ;
  char *check ;
  char **tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  struct stat st___0 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  sigset_t oset ;
  int tmp___10 ;
  sigset_t oset___0 ;
  int tmp___11 ;
  sigset_t oset___1 ;
  sigset_t oset___2 ;
  Asgment a ;
  void *tmp___12 ;
  LinkNode tmp___13 ;
  int tmp___14 ;
  sigset_t oset___3 ;
  sigset_t oset___4 ;
  sigset_t oset___5 ;
  zlong tmp___15 ;
  zlong tmp___16 ;
  zlong tmp___17 ;
  zlong tmp___18 ;
  sigset_t oset___6 ;
  int tempfd ;
  FILE *out ;
  char *fil ;
  sigset_t oset___7 ;
  int *tmp___19 ;
  sigset_t oset___8 ;
  char *editor ;
  sigset_t oset___9 ;
  int *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  sigset_t oset___10 ;
  int tmp___23 ;

  {
#line 1411
  first = (zlong )-1;
#line 1411
  last = (zlong )-1;
#line 1414
  asgf = (struct asgment *)((void *)0);
#line 1414
  asgl = (struct asgment *)((void *)0);
#line 1415
  pprog = (Patprog )((void *)0);
#line 1424
  if ((int )ops->ind[112] != 0) {
#line 1425
    hf = (char *)"";
#line 1426
    hs = (zlong )30;
#line 1427
    shs = (zlong )0;
#line 1428
    if ((int )ops->ind[97] != 0) {
#line 1428
      tmp = locallevel;
    } else {
#line 1428
      tmp = -1;
    }
#line 1428
    level = tmp;
#line 1429
    if (*argv) {
#line 1430
      tmp___0 = argv;
#line 1430
      argv ++;
#line 1430
      hf = *tmp___0;
#line 1431
      if (*argv) {
        {
#line 1433
        tmp___1 = argv;
#line 1433
        argv ++;
#line 1433
        hs = zstrtol((char const   *)*tmp___1, & check, 10);
        }
#line 1434
        if (*check) {
          {
#line 1435
          zwarnnam("fc", "HISTSIZE must be an integer");
          }
#line 1436
          return (1);
        }
#line 1438
        if (*argv) {
          {
#line 1439
          tmp___2 = argv;
#line 1439
          argv ++;
#line 1439
          shs = zstrtol((char const   *)*tmp___2, & check, 10);
          }
#line 1440
          if (*check) {
            {
#line 1441
            zwarnnam("fc", "SAVEHIST must be an integer");
            }
#line 1442
            return (1);
          }
        } else {
#line 1445
          shs = hs;
        }
#line 1446
        if (*argv) {
          {
#line 1447
          zwarnnam("fc", "too many arguments");
          }
#line 1448
          return (1);
        }
      } else {
#line 1451
        hs = histsiz;
#line 1452
        shs = savehistsiz;
      }
    }
    {
#line 1455
    tmp___3 = pushhiststack(hf, hs, shs, level);
    }
#line 1455
    if (! tmp___3) {
#line 1456
      return (1);
    }
#line 1457
    if (*hf) {
      {
#line 1459
      tmp___4 = stat((char const   */* __restrict  */)hf, (struct stat */* __restrict  */)(& st___0));
      }
#line 1459
      if (tmp___4 >= 0) {
        {
#line 1460
        readhistfile(hf, 1, 32768);
        }
      } else {
        {
#line 1459
        tmp___5 = __errno_location();
        }
#line 1459
        if (*tmp___5 != 2) {
          {
#line 1460
          readhistfile(hf, 1, 32768);
          }
        }
      }
    }
#line 1462
    return (0);
  }
#line 1464
  if ((int )ops->ind[80] != 0) {
#line 1465
    if (*argv) {
      {
#line 1466
      zwarnnam("fc", "too many arguments");
      }
#line 1467
      return (1);
    }
    {
#line 1469
    tmp___6 = saveandpophiststack(-1, 32768);
    }
#line 1469
    if (tmp___6) {
#line 1469
      tmp___7 = 0;
    } else {
#line 1469
      tmp___7 = 1;
    }
#line 1469
    return (tmp___7);
  }
#line 1473
  if (*argv) {
#line 1473
    if ((int )ops->ind[109] != 0) {
      {
#line 1474
      tokenize(*argv);
#line 1475
      tmp___8 = argv;
#line 1475
      argv ++;
#line 1475
      pprog = patcompile(*tmp___8, 0, (char **)((void *)0));
      }
#line 1475
      if (! pprog) {
        {
#line 1476
        zwarnnam((char const   *)nam, "invalid match pattern");
        }
#line 1477
        return (1);
      }
    }
  }
#line 1480
  queueing_enabled ++;
#line 1481
  if ((int )ops->ind[82] != 0) {
#line 1483
    if ((int )ops->ind[73] != 0) {
#line 1483
      tmp___9 = 2;
    } else {
#line 1483
      tmp___9 = 0;
    }
    {
#line 1483
    readhistfile(*argv, 1, tmp___9);
    }
    {
#line 1484
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1484
      queueing_enabled --;
#line 1484
      if (! queueing_enabled) {
        {
#line 1484
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1484
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1484
            if (! (queue_front != queue_rear)) {
#line 1484
              goto while_break___1;
            }
            {
#line 1484
            queue_front = (queue_front + 1) % 128;
#line 1484
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 1484
            zhandler(signal_queue[queue_front]);
#line 1484
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1484
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1484
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1485
    return (0);
  }
#line 1487
  if ((int )ops->ind[87] != 0) {
#line 1489
    if ((int )ops->ind[73] != 0) {
#line 1489
      tmp___10 = 2;
    } else {
#line 1489
      tmp___10 = 0;
    }
    {
#line 1489
    savehistfile(*argv, 1, tmp___10);
    }
    {
#line 1490
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1490
      queueing_enabled --;
#line 1490
      if (! queueing_enabled) {
        {
#line 1490
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1490
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1490
            if (! (queue_front != queue_rear)) {
#line 1490
              goto while_break___4;
            }
            {
#line 1490
            queue_front = (queue_front + 1) % 128;
#line 1490
            oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 1490
            zhandler(signal_queue[queue_front]);
#line 1490
            signal_setmask(oset___0);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1490
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1490
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1491
    return (0);
  }
#line 1493
  if ((int )ops->ind[65] != 0) {
#line 1495
    if ((int )ops->ind[73] != 0) {
#line 1495
      tmp___11 = 2;
    } else {
#line 1495
      tmp___11 = 0;
    }
    {
#line 1495
    savehistfile(*argv, 1, 1 | tmp___11);
    }
    {
#line 1497
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1497
      queueing_enabled --;
#line 1497
      if (! queueing_enabled) {
        {
#line 1497
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 1497
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 1497
            if (! (queue_front != queue_rear)) {
#line 1497
              goto while_break___7;
            }
            {
#line 1497
            queue_front = (queue_front + 1) % 128;
#line 1497
            oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 1497
            zhandler(signal_queue[queue_front]);
#line 1497
            signal_setmask(oset___1);
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 1497
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 1497
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1498
    return (0);
  }
#line 1501
  if (zleactive) {
    {
#line 1502
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1502
      queueing_enabled --;
#line 1502
      if (! queueing_enabled) {
        {
#line 1502
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 1502
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 1502
            if (! (queue_front != queue_rear)) {
#line 1502
              goto while_break___10;
            }
            {
#line 1502
            queue_front = (queue_front + 1) % 128;
#line 1502
            oset___2 = signal_setmask(signal_mask_queue[queue_front]);
#line 1502
            zhandler(signal_queue[queue_front]);
#line 1502
            signal_setmask(oset___2);
            }
          }
          while_break___10: /* CIL Label */ ;
          }
#line 1502
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
#line 1502
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1503
    zwarnnam((char const   *)nam, "no interactive history within ZLE");
    }
#line 1504
    return (1);
  }
  {
#line 1508
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1508
    if (*argv) {
      {
#line 1508
      tmp___14 = equalsplit(*argv, & s);
      }
#line 1508
      if (! tmp___14) {
#line 1508
        goto while_break___11;
      }
    } else {
#line 1508
      goto while_break___11;
    }
    {
#line 1509
    tmp___12 = zhalloc(sizeof(*a));
#line 1509
    a = (Asgment )tmp___12;
    }
#line 1511
    if (! *(*argv)) {
      {
#line 1512
      zwarnnam((char const   *)nam, "invalid replacement pattern: =%s", s);
      }
#line 1513
      return (1);
    }
#line 1515
    if (! asgf) {
#line 1516
      asgl = a;
#line 1516
      asgf = asgl;
    } else {
#line 1518
      asgl->node.next = & a->node;
#line 1519
      asgl = a;
    }
#line 1521
    a->name = *argv;
#line 1522
    a->is_array = 0;
#line 1523
    a->value.scalar = s;
#line 1524
    tmp___13 = (LinkNode )((void *)0);
#line 1524
    a->node.prev = tmp___13;
#line 1524
    a->node.next = tmp___13;
#line 1525
    argv ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1528
  if (*argv) {
    {
#line 1529
    first = fcgetcomm(*argv);
    }
#line 1530
    if (first == -1L) {
      {
#line 1531
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1531
        queueing_enabled --;
#line 1531
        if (! queueing_enabled) {
          {
#line 1531
          while (1) {
            while_continue___13: /* CIL Label */ ;
            {
#line 1531
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 1531
              if (! (queue_front != queue_rear)) {
#line 1531
                goto while_break___14;
              }
              {
#line 1531
              queue_front = (queue_front + 1) % 128;
#line 1531
              oset___3 = signal_setmask(signal_mask_queue[queue_front]);
#line 1531
              zhandler(signal_queue[queue_front]);
#line 1531
              signal_setmask(oset___3);
              }
            }
            while_break___14: /* CIL Label */ ;
            }
#line 1531
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
#line 1531
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 1532
      return (1);
    }
#line 1534
    argv ++;
  }
#line 1537
  if (*argv) {
    {
#line 1538
    last = fcgetcomm(*argv);
    }
#line 1539
    if (last == -1L) {
      {
#line 1540
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1540
        queueing_enabled --;
#line 1540
        if (! queueing_enabled) {
          {
#line 1540
          while (1) {
            while_continue___16: /* CIL Label */ ;
            {
#line 1540
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 1540
              if (! (queue_front != queue_rear)) {
#line 1540
                goto while_break___17;
              }
              {
#line 1540
              queue_front = (queue_front + 1) % 128;
#line 1540
              oset___4 = signal_setmask(signal_mask_queue[queue_front]);
#line 1540
              zhandler(signal_queue[queue_front]);
#line 1540
              signal_setmask(oset___4);
              }
            }
            while_break___17: /* CIL Label */ ;
            }
#line 1540
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
        }
#line 1540
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 1541
      return (1);
    }
#line 1543
    argv ++;
  }
#line 1547
  if (*argv) {
    {
#line 1548
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1548
      queueing_enabled --;
#line 1548
      if (! queueing_enabled) {
        {
#line 1548
        while (1) {
          while_continue___19: /* CIL Label */ ;
          {
#line 1548
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 1548
            if (! (queue_front != queue_rear)) {
#line 1548
              goto while_break___20;
            }
            {
#line 1548
            queue_front = (queue_front + 1) % 128;
#line 1548
            oset___5 = signal_setmask(signal_mask_queue[queue_front]);
#line 1548
            zhandler(signal_queue[queue_front]);
#line 1548
            signal_setmask(oset___5);
            }
          }
          while_break___20: /* CIL Label */ ;
          }
#line 1548
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
#line 1548
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 1549
    zwarnnam("fc", "too many arguments");
    }
#line 1550
    return (1);
  }
#line 1553
  if (last == -1L) {
#line 1554
    if ((int )ops->ind[108] != 0) {
#line 1554
      if (first < curhist) {
#line 1566
        if (curline.histnum == curhist) {
          {
#line 1566
          tmp___15 = addhistnum(curhist, -1, 0);
#line 1566
          last = tmp___15;
          }
        } else {
#line 1566
          last = curhist;
        }
#line 1568
        if (hist_ring) {
#line 1568
          tmp___16 = (hist_ring->down)->histnum;
        } else {
#line 1568
          tmp___16 = curhist;
        }
#line 1568
        if (last < tmp___16) {
#line 1569
          if (hist_ring) {
#line 1569
            last = (hist_ring->down)->histnum;
          } else {
#line 1569
            last = curhist;
          }
        }
      } else {
#line 1572
        last = first;
      }
    } else {
#line 1572
      last = first;
    }
  }
#line 1574
  if (first == -1L) {
#line 1583
    if ((int )ops->ind[108] != 0) {
      {
#line 1583
      tmp___17 = addhistnum(curhist, -16, 0);
#line 1583
      first = tmp___17;
      }
    } else {
      {
#line 1583
      tmp___18 = addhistnum(curline.histnum, -1, 0);
#line 1583
      first = tmp___18;
      }
    }
#line 1585
    if (first < 1L) {
#line 1586
      first = (zlong )1;
    }
#line 1587
    if (last < first) {
#line 1588
      last = first;
    }
  }
#line 1590
  if ((int )ops->ind[108] != 0) {
    {
#line 1592
    retval = fclist(stdout, ops, first, last, asgf, pprog, 0);
    }
    {
#line 1593
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 1593
      queueing_enabled --;
#line 1593
      if (! queueing_enabled) {
        {
#line 1593
        while (1) {
          while_continue___22: /* CIL Label */ ;
          {
#line 1593
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 1593
            if (! (queue_front != queue_rear)) {
#line 1593
              goto while_break___23;
            }
            {
#line 1593
            queue_front = (queue_front + 1) % 128;
#line 1593
            oset___6 = signal_setmask(signal_mask_queue[queue_front]);
#line 1593
            zhandler(signal_queue[queue_front]);
#line 1593
            signal_setmask(oset___6);
            }
          }
          while_break___23: /* CIL Label */ ;
          }
#line 1593
          goto while_break___22;
        }
        while_break___22: /* CIL Label */ ;
        }
      }
#line 1593
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
  } else {
    {
#line 1601
    retval = 1;
#line 1602
    tempfd = gettempfile((char const   *)((void *)0), 1, & fil);
    }
#line 1602
    if (tempfd < 0) {
#line 1602
      goto _L;
    } else {
      {
#line 1602
      out = fdopen(tempfd, "w");
      }
#line 1602
      if ((unsigned long )out == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
        {
#line 1604
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 1604
          queueing_enabled --;
#line 1604
          if (! queueing_enabled) {
            {
#line 1604
            while (1) {
              while_continue___25: /* CIL Label */ ;
              {
#line 1604
              while (1) {
                while_continue___26: /* CIL Label */ ;
#line 1604
                if (! (queue_front != queue_rear)) {
#line 1604
                  goto while_break___26;
                }
                {
#line 1604
                queue_front = (queue_front + 1) % 128;
#line 1604
                oset___7 = signal_setmask(signal_mask_queue[queue_front]);
#line 1604
                zhandler(signal_queue[queue_front]);
#line 1604
                signal_setmask(oset___7);
                }
              }
              while_break___26: /* CIL Label */ ;
              }
#line 1604
              goto while_break___25;
            }
            while_break___25: /* CIL Label */ ;
            }
          }
#line 1604
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
        {
#line 1605
        tmp___19 = __errno_location();
#line 1605
        zwarnnam("fc", "can\'t open temp file: %e", *tmp___19);
        }
      } else {
#line 1612
        if (last >= curhist) {
#line 1613
          last = curhist - 1L;
#line 1614
          if (first > last) {
            {
#line 1615
            while (1) {
              while_continue___27: /* CIL Label */ ;
#line 1615
              queueing_enabled --;
#line 1615
              if (! queueing_enabled) {
                {
#line 1615
                while (1) {
                  while_continue___28: /* CIL Label */ ;
                  {
#line 1615
                  while (1) {
                    while_continue___29: /* CIL Label */ ;
#line 1615
                    if (! (queue_front != queue_rear)) {
#line 1615
                      goto while_break___29;
                    }
                    {
#line 1615
                    queue_front = (queue_front + 1) % 128;
#line 1615
                    oset___8 = signal_setmask(signal_mask_queue[queue_front]);
#line 1615
                    zhandler(signal_queue[queue_front]);
#line 1615
                    signal_setmask(oset___8);
                    }
                  }
                  while_break___29: /* CIL Label */ ;
                  }
#line 1615
                  goto while_break___28;
                }
                while_break___28: /* CIL Label */ ;
                }
              }
#line 1615
              goto while_break___27;
            }
            while_break___27: /* CIL Label */ ;
            }
            {
#line 1616
            zwarnnam("fc", "current history line would recurse endlessly, aborted");
#line 1618
            fclose(out);
#line 1619
            unlink((char const   *)fil);
            }
#line 1620
            return (1);
          }
        }
        {
#line 1623
        ops->ind['n'] = (unsigned char)1;
#line 1624
        tmp___23 = fclist(out, ops, first, last, asgf, pprog, 1);
        }
#line 1624
        if (tmp___23) {
          {
#line 1648
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 1648
            queueing_enabled --;
#line 1648
            if (! queueing_enabled) {
              {
#line 1648
              while (1) {
                while_continue___31: /* CIL Label */ ;
                {
#line 1648
                while (1) {
                  while_continue___32: /* CIL Label */ ;
#line 1648
                  if (! (queue_front != queue_rear)) {
#line 1648
                    goto while_break___32;
                  }
                  {
#line 1648
                  queue_front = (queue_front + 1) % 128;
#line 1648
                  oset___10 = signal_setmask(signal_mask_queue[queue_front]);
#line 1648
                  zhandler(signal_queue[queue_front]);
#line 1648
                  signal_setmask(oset___10);
                  }
                }
                while_break___32: /* CIL Label */ ;
                }
#line 1648
                goto while_break___31;
              }
              while_break___31: /* CIL Label */ ;
              }
            }
#line 1648
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
        } else {
#line 1627
          if (func == 17) {
#line 1628
            editor = (char *)"-";
          } else
#line 1629
          if ((int )ops->ind[101] > 3) {
#line 1630
            editor = *(ops->args + (((int )ops->ind[101] >> 2) - 1));
          } else {
            {
#line 1632
            editor = getsparam((char *)"FCEDIT");
            }
          }
#line 1633
          if (! editor) {
            {
#line 1634
            editor = getsparam((char *)"EDITOR");
            }
          }
#line 1635
          if (! editor) {
#line 1636
            editor = (char *)"vi";
          }
          {
#line 1638
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 1638
            queueing_enabled --;
#line 1638
            if (! queueing_enabled) {
              {
#line 1638
              while (1) {
                while_continue___34: /* CIL Label */ ;
                {
#line 1638
                while (1) {
                  while_continue___35: /* CIL Label */ ;
#line 1638
                  if (! (queue_front != queue_rear)) {
#line 1638
                    goto while_break___35;
                  }
                  {
#line 1638
                  queue_front = (queue_front + 1) % 128;
#line 1638
                  oset___9 = signal_setmask(signal_mask_queue[queue_front]);
#line 1638
                  zhandler(signal_queue[queue_front]);
#line 1638
                  signal_setmask(oset___9);
                  }
                }
                while_break___35: /* CIL Label */ ;
                }
#line 1638
                goto while_break___34;
              }
              while_break___34: /* CIL Label */ ;
              }
            }
#line 1638
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
          {
#line 1639
          tmp___22 = fcedit(editor, fil);
          }
#line 1639
          if (tmp___22) {
            {
#line 1640
            tmp___21 = stuff(fil);
            }
#line 1640
            if (tmp___21) {
              {
#line 1641
              tmp___20 = __errno_location();
#line 1641
              zwarnnam("fc", "%e: %s", *tmp___20, fil);
              }
            } else {
              {
#line 1643
              loop(0, 1);
#line 1644
              retval = (int )lastval;
              }
            }
          }
        }
      }
    }
    {
#line 1650
    unlink((char const   *)fil);
    }
  }
#line 1652
  return (retval);
}
}
#line 1664 "/tmp/zsh-5.4.2/Src/builtin.c"
static zlong fcgetcomm(char *s ) 
{ 
  zlong cmd ;
  int tmp ;

  {
  {
#line 1671
  tmp = atoi((char const   *)s);
#line 1671
  cmd = (zlong )tmp;
  }
#line 1671
  if (cmd != 0L) {
#line 1671
    goto _L;
  } else
#line 1671
  if ((int )*s == 48) {
    _L: /* CIL Label */ 
#line 1672
    if (cmd < 0L) {
      {
#line 1673
      cmd = addhistnum(curline.histnum, (int )cmd, 16);
      }
    }
#line 1674
    if (cmd < 0L) {
#line 1675
      cmd = (zlong )0;
    }
#line 1676
    return (cmd);
  }
  {
#line 1679
  cmd = hcomsearch(s);
  }
#line 1680
  if (cmd == -1L) {
    {
#line 1681
    zwarnnam("fc", "event not found: %s", s);
    }
  }
#line 1682
  return (cmd);
}
}
#line 1689 "/tmp/zsh-5.4.2/Src/builtin.c"
static int fcsubs(char **sp___0 , struct asgment *sub ) 
{ 
  char *oldstr ;
  char *newstr ;
  char *oldpos___0 ;
  char *newpos ;
  char *newmem ;
  char *s ;
  int subbed ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;

  {
#line 1692
  s = *sp___0;
#line 1693
  subbed = 0;
  {
#line 1696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1696
    if (! sub) {
#line 1696
      goto while_break;
    }
#line 1697
    oldstr = sub->name;
#line 1698
    newstr = sub->value.scalar;
#line 1699
    sub = (Asgment )sub->node.next;
#line 1700
    oldpos___0 = s;
    {
#line 1702
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1702
      tmp___5 = strstr((char const   *)oldpos___0, (char const   *)oldstr);
#line 1702
      newpos = tmp___5;
      }
#line 1702
      if (! newpos) {
#line 1702
        goto while_break___0;
      }
      {
#line 1703
      tmp = strlen((char const   *)newstr);
#line 1703
      tmp___0 = strlen((char const   *)oldstr);
#line 1703
      tmp___1 = strlen((char const   *)(newpos + tmp___0));
#line 1703
      tmp___2 = zhalloc(((size_t )(1L + (newpos - s)) + tmp) + tmp___1);
#line 1703
      newmem = (char *)tmp___2;
#line 1705
      ztrncpy(newmem, s, (int )(newpos - s));
#line 1706
      strcat((char */* __restrict  */)newmem, (char const   */* __restrict  */)newstr);
#line 1707
      tmp___3 = strlen((char const   *)newmem);
#line 1707
      oldpos___0 = newmem + tmp___3;
#line 1708
      tmp___4 = strlen((char const   *)oldstr);
#line 1708
      strcat((char */* __restrict  */)newmem, (char const   */* __restrict  */)(newpos + tmp___4));
#line 1709
      s = newmem;
#line 1710
      subbed = 1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1713
  *sp___0 = s;
#line 1714
  return (subbed);
}
}
#line 1731 "/tmp/zsh-5.4.2/Src/builtin.c"
static int fclist(FILE *f , Options ops , zlong first , zlong last , struct asgment *subs ,
                  Patprog pprog , int is_command ) 
{ 
  int fclistdone ;
  int xflags ;
  zlong tmp ;
  char *s ;
  char *tdfmt ;
  char *timebuf ;
  Histent ent ;
  int tmp___0 ;
  char buf___7[(int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3] ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char buf___8[(int )(((sizeof(zlong ) * 8UL - 1UL) * 30103UL) / 100000UL) + 3] ;
  int tmp___5 ;
  struct tm *ltm ;
  int len ;
  long diff ;
  int len___0 ;
  int tmp___6 ;

  {
#line 1735
  fclistdone = 0;
#line 1735
  xflags = 0;
#line 1741
  if ((int )ops->ind[114] != 0) {
#line 1742
    tmp = last;
#line 1743
    last = first;
#line 1744
    first = tmp;
  }
#line 1746
  if (is_command) {
#line 1746
    if (first > last) {
      {
#line 1747
      zwarnnam("fc", "history events can\'t be executed backwards, aborted");
      }
#line 1748
      if ((unsigned long )f != (unsigned long )stdout) {
        {
#line 1749
        fclose(f);
        }
      }
#line 1750
      return (1);
    }
  }
#line 1753
  if (first < last) {
#line 1753
    tmp___0 = 1;
  } else {
#line 1753
    tmp___0 = -1;
  }
  {
#line 1753
  ent = gethistent(first, tmp___0);
  }
#line 1754
  if (! ent) {
#line 1754
    goto _L;
  } else {
#line 1754
    if (first < last) {
#line 1754
      tmp___1 = ent->histnum > last;
    } else {
#line 1754
      tmp___1 = ent->histnum < last;
    }
#line 1754
    if (tmp___1) {
      _L: /* CIL Label */ 
#line 1755
      if (first == last) {
        {
#line 1757
        convbase(buf___7, first, 10);
#line 1758
        zwarnnam("fc", "no such event: %s", buf___7);
        }
      } else {
        {
#line 1760
        zwarnnam("fc", "no events in that range");
        }
      }
#line 1761
      if ((unsigned long )f != (unsigned long )stdout) {
        {
#line 1762
        fclose(f);
        }
      }
#line 1763
      return (1);
    }
  }
#line 1766
  if ((int )ops->ind[100] != 0) {
#line 1766
    goto _L___0;
  } else
#line 1766
  if ((int )ops->ind[102] != 0) {
#line 1766
    goto _L___0;
  } else
#line 1766
  if ((int )ops->ind[69] != 0) {
#line 1766
    goto _L___0;
  } else
#line 1766
  if ((int )ops->ind[105] != 0) {
#line 1766
    goto _L___0;
  } else
#line 1766
  if ((int )ops->ind[116] != 0) {
    _L___0: /* CIL Label */ 
#line 1769
    if ((int )ops->ind[116] != 0) {
#line 1770
      tdfmt = *(ops->args + (((int )ops->ind[116] >> 2) - 1));
    } else
#line 1771
    if ((int )ops->ind[105] != 0) {
#line 1772
      tdfmt = (char *)"%Y-%m-%d %H:%M";
    } else
#line 1773
    if ((int )ops->ind[69] != 0) {
#line 1774
      tdfmt = (char *)"%f.%-m.%Y %H:%M";
    } else
#line 1775
    if ((int )ops->ind[102] != 0) {
#line 1776
      tdfmt = (char *)"%-m/%f/%Y %H:%M";
    } else {
#line 1778
      tdfmt = (char *)"%H:%M";
    }
    {
#line 1780
    tmp___2 = zhalloc((size_t )256);
#line 1780
    timebuf = (char *)tmp___2;
    }
  } else {
#line 1782
    timebuf = (char *)((void *)0);
#line 1782
    tdfmt = timebuf;
  }
#line 1786
  if ((int )ops->ind[76] != 0) {
#line 1787
    xflags |= 16;
  }
#line 1789
  if ((int )ops->ind[73] != 0) {
#line 1790
    xflags |= 4;
  }
  {
#line 1793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1794
    if (ent->node.flags & xflags) {
#line 1795
      s = (char *)((void *)0);
    } else {
      {
#line 1797
      s = dupstring((char const   *)ent->node.nam);
      }
    }
#line 1799
    if (s) {
#line 1799
      if (! pprog) {
#line 1799
        goto _L___1;
      } else {
        {
#line 1799
        tmp___6 = pattry(pprog, s);
        }
#line 1799
        if (tmp___6) {
          _L___1: /* CIL Label */ 
#line 1801
          if (subs) {
            {
#line 1801
            tmp___3 = fcsubs(& s, subs);
#line 1801
            tmp___4 = tmp___3;
            }
          } else {
#line 1801
            tmp___4 = 1;
          }
#line 1801
          fclistdone |= tmp___4;
#line 1804
          if (! ((int )ops->ind[110] != 0)) {
            {
#line 1806
            convbase(buf___8, ent->histnum, 10);
            }
#line 1807
            if (ent->node.flags & 16) {
#line 1807
              tmp___5 = '*';
            } else {
#line 1807
              tmp___5 = ' ';
            }
            {
#line 1807
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%5s%c ",
                    buf___8, tmp___5);
            }
          }
#line 1812
          if ((unsigned long )tdfmt != (unsigned long )((void *)0)) {
            {
#line 1815
            ltm = localtime((time_t const   *)(& ent->stim));
#line 1816
            len = ztrftime(timebuf, 256, tdfmt, ltm, 0L);
            }
#line 1816
            if (len >= 0) {
              {
#line 1817
              fwrite((void const   */* __restrict  */)timebuf, (size_t )1, (size_t )len,
                     (FILE */* __restrict  */)f);
#line 1818
              fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  ");
              }
            }
          }
#line 1822
          if ((int )ops->ind[68] != 0) {
#line 1824
            if (ent->ftim) {
#line 1824
              diff = ent->ftim - ent->stim;
            } else {
#line 1824
              diff = 0L;
            }
            {
#line 1825
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld:%02ld  ",
                    diff / 60L, diff % 60L);
            }
          }
#line 1829
          if ((unsigned long )f == (unsigned long )stdout) {
            {
#line 1830
            mb_niceformat((char const   *)s, f, (char **)((void *)0), 0);
#line 1831
            _IO_putc('\n', f);
            }
          } else {
            {
#line 1834
            unmetafy(s, & len___0);
#line 1835
            fwrite((void const   */* __restrict  */)s, (size_t )1, (size_t )len___0,
                   (FILE */* __restrict  */)f);
#line 1836
            _IO_putc('\n', f);
            }
          }
        }
      }
    }
#line 1840
    if (first < last) {
      {
#line 1841
      ent = down_histent(ent);
      }
#line 1841
      if (ent) {
#line 1841
        if (ent->histnum > last) {
#line 1842
          goto while_break;
        }
      } else {
#line 1842
        goto while_break;
      }
    } else {
      {
#line 1845
      ent = up_histent(ent);
      }
#line 1845
      if (ent) {
#line 1845
        if (ent->histnum < last) {
#line 1846
          goto while_break;
        }
      } else {
#line 1846
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1851
  if ((unsigned long )f != (unsigned long )stdout) {
    {
#line 1852
    fclose(f);
    }
  }
#line 1853
  if (! fclistdone) {
#line 1854
    if (subs) {
      {
#line 1855
      zwarnnam("fc", "no substitutions performed");
      }
    } else
#line 1856
    if (xflags) {
      {
#line 1857
      zwarnnam("fc", "no matching events found");
      }
    } else
#line 1856
    if (pprog) {
      {
#line 1857
      zwarnnam("fc", "no matching events found");
      }
    }
#line 1858
    return (1);
  }
#line 1860
  return (0);
}
}
#line 1866 "/tmp/zsh-5.4.2/Src/builtin.c"
static int fcedit(char *ename , char *fn___0 ) 
{ 
  char *s ;
  int tmp ;

  {
  {
#line 1871
  tmp = strcmp((char const   *)ename, "-");
  }
#line 1871
  if (! tmp) {
#line 1872
    return (1);
  }
  {
#line 1874
  s = tricat((char const   *)ename, " ", (char const   *)fn___0);
#line 1875
  execstring(s, 1, 0, (char *)"fc");
#line 1876
  zsfree(s);
  }
#line 1878
  return (! lastval);
}
}
#line 1893 "/tmp/zsh-5.4.2/Src/builtin.c"
static struct asgment asg  ;
#line 1889 "/tmp/zsh-5.4.2/Src/builtin.c"
static Asgment getasg(char ***argvp , LinkList assigns ) 
{ 
  char *s ;
  Asgment asgp ;

  {
#line 1892
  s = *(*argvp);
#line 1896
  if (! s) {
#line 1897
    if (assigns) {
#line 1898
      asgp = (Asgment )assigns->list.first;
#line 1899
      if (! asgp) {
#line 1900
        return ((Asgment )((void *)0));
      }
      {
#line 1901
      uremnode(assigns, & asgp->node);
      }
#line 1902
      return (asgp);
    }
#line 1904
    return ((Asgment )((void *)0));
  }
#line 1908
  if ((int )*s == 61) {
    {
#line 1909
    zerr("bad assignment");
    }
#line 1910
    return ((Asgment )((void *)0));
  }
#line 1912
  asg.name = s;
#line 1913
  asg.is_array = 0;
  {
#line 1916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1916
    if (*s) {
#line 1916
      if (! ((int )*s != 61)) {
#line 1916
        goto while_break;
      }
    } else {
#line 1916
      goto while_break;
    }
#line 1916
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1919
  if (*s) {
#line 1920
    *s = (char )'\000';
#line 1921
    asg.value.scalar = s + 1;
  } else {
#line 1924
    asg.value.scalar = (char *)((void *)0);
  }
#line 1926
  (*argvp) ++;
#line 1927
  return (& asg);
}
}
#line 1937 "/tmp/zsh-5.4.2/Src/builtin.c"
static struct gsu_scalar  const  tiedarr_gsu  =    {& tiedarrgetfn, & tiedarrsetfn, & tiedarrunsetfn};
#line 1942 "/tmp/zsh-5.4.2/Src/builtin.c"
static int typeset_setbase(char const   *name , Param pm , Options ops , int on ,
                           int always ) 
{ 
  char *arg ;
  char *eptr ;
  int base ;
  zlong tmp ;

  {
#line 1945
  arg = (char *)((void *)0);
#line 1947
  if (on & (1 << 1)) {
#line 1947
    if ((int )ops->ind[105] > 3) {
#line 1948
      arg = *(ops->args + (((int )ops->ind[105] >> 2) - 1));
    } else {
#line 1947
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1949
  if (on & (1 << 2)) {
#line 1949
    if ((int )ops->ind[69] > 3) {
#line 1950
      arg = *(ops->args + (((int )ops->ind[69] >> 2) - 1));
    } else {
#line 1949
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1951
  if (on & (1 << 3)) {
#line 1951
    if ((int )ops->ind[70] > 3) {
#line 1952
      arg = *(ops->args + (((int )ops->ind[70] >> 2) - 1));
    }
  }
#line 1954
  if (arg) {
    {
#line 1956
    tmp = zstrtol((char const   *)arg, & eptr, 10);
#line 1956
    base = (int )tmp;
    }
#line 1957
    if (*eptr) {
#line 1958
      if (on & (1 << 1)) {
        {
#line 1959
        zwarnnam(name, "bad base value: %s", arg);
        }
      } else {
        {
#line 1961
        zwarnnam(name, "bad precision value: %s", arg);
        }
      }
#line 1962
      return (1);
    }
#line 1964
    if (on & (1 << 1)) {
#line 1964
      if (base < 2) {
        {
#line 1965
        zwarnnam(name, "invalid base (must be 2 to 36 inclusive): %d", base);
        }
#line 1967
        return (1);
      } else
#line 1964
      if (base > 36) {
        {
#line 1965
        zwarnnam(name, "invalid base (must be 2 to 36 inclusive): %d", base);
        }
#line 1967
        return (1);
      }
    }
#line 1969
    pm->base = base;
  } else
#line 1970
  if (always) {
#line 1971
    pm->base = 0;
  }
#line 1973
  return (0);
}
}
#line 1978 "/tmp/zsh-5.4.2/Src/builtin.c"
static int typeset_setwidth(char const   *name , Param pm , Options ops , int on ,
                            int always ) 
{ 
  char *arg ;
  char *eptr ;
  zlong tmp ;

  {
#line 1981
  arg = (char *)((void *)0);
#line 1983
  if (on & (1 << 5)) {
#line 1983
    if ((int )ops->ind[76] > 3) {
#line 1984
      arg = *(ops->args + (((int )ops->ind[76] >> 2) - 1));
    } else {
#line 1983
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1985
  if (on & (1 << 6)) {
#line 1985
    if ((int )ops->ind[82] > 3) {
#line 1986
      arg = *(ops->args + (((int )ops->ind[82] >> 2) - 1));
    } else {
#line 1985
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1987
  if (on & (1 << 7)) {
#line 1987
    if ((int )ops->ind[90] > 3) {
#line 1988
      arg = *(ops->args + (((int )ops->ind[90] >> 2) - 1));
    }
  }
#line 1990
  if (arg) {
    {
#line 1992
    tmp = zstrtol((char const   *)arg, & eptr, 10);
#line 1992
    pm->width = (int )tmp;
    }
#line 1993
    if (*eptr) {
      {
#line 1994
      zwarnnam(name, "bad width value: %s", arg);
      }
#line 1995
      return (1);
    }
  } else
#line 1997
  if (always) {
#line 1998
    pm->width = 0;
  }
#line 2000
  return (0);
}
}
#line 2006 "/tmp/zsh-5.4.2/Src/builtin.c"
static Param typeset_single(char *cname , char *pname , Param pm , int func  __attribute__((__unused__)) ,
                            int on , int off , int roff , Asgment asg___0 , Param altpm ,
                            Options ops , int joinchar ) 
{ 
  int usepm ;
  int tc ;
  int keeplocal ;
  int newspecial ;
  int readonly ;
  int dont_set ;
  char *subscript ;
  int tmp ;
  int chflags ;
  int tmp___0 ;
  int err ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Param apm ;
  char **x ;
  void *tmp___8 ;
  HashNode tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char **tmp___14 ;
  char **tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  Param tpm ;
  Param pm2 ;
  void *tmp___20 ;
  HashNode tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  HashNode tmp___24 ;
  HashNode tmp___25 ;
  HashNode tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___28 ;
  char **tmp___29 ;
  char **tmp___30 ;
  char **tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  HashNode tmp___35 ;
  int tmp___36 ;
  struct tieddata *tdp ;
  void *tmp___37 ;
  Param ipm ;
  char **arrayval ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char **tmp___41 ;
  HashTable tmp___42 ;

  {
#line 2011
  keeplocal = 0;
#line 2011
  newspecial = 0;
#line 2011
  dont_set = 0;
#line 2024
  if (pm) {
#line 2024
    if (! (pm->node.flags & (1 << 25))) {
#line 2024
      tmp = 1;
    } else
#line 2024
    if (opts[131]) {
#line 2024
      if (pm->node.flags & ((1 << 10) | (1 << 12))) {
#line 2024
        tmp = 1;
      } else {
#line 2024
        tmp = 0;
      }
    } else {
#line 2024
      tmp = 0;
    }
  } else {
#line 2024
    tmp = 0;
  }
#line 2024
  usepm = tmp;
#line 2032
  if (! usepm) {
#line 2032
    if (pm) {
#line 2032
      if (pm->node.flags & (1 << 22)) {
#line 2033
        usepm = 2;
      }
    }
  }
#line 2040
  if (usepm) {
#line 2040
    if (locallevel != pm->level) {
#line 2040
      if (on & (1 << 21)) {
#line 2049
        if (pm->node.flags & (1 << 22)) {
#line 2049
          if (! (on & (1 << 14))) {
#line 2049
            if (! ((pm->node.flags & (1 << 14)) & ~ off)) {
#line 2051
              newspecial = 1;
            }
          }
        }
#line 2052
        usepm = 0;
      }
    }
  }
#line 2056
  tc = 0;
#line 2057
  if (asg___0->is_array) {
#line 2057
    if ((on & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 2057
      if (usepm) {
#line 2057
        if (! ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) & (1 | (1 << 4)))) {
#line 2059
          on |= 1;
        }
      } else {
#line 2059
        on |= 1;
      }
    }
  }
#line 2060
  if (usepm) {
#line 2060
    if (asg___0->is_array) {
#line 2060
      if (newspecial == 0) {
#line 2060
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) != 1) {
#line 2060
          if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) != 1 << 4) {
#line 2063
            if (on & (((1 << 2) | (1 << 3)) | (1 << 1))) {
              {
#line 2064
              zerrnam((char const   *)cname, "%s: can\'t assign array value to non-array",
                      pname);
              }
#line 2065
              return ((Param )((void *)0));
            }
#line 2067
            if (pm->node.flags & (1 << 22)) {
              {
#line 2068
              zerrnam((char const   *)cname, "%s: can\'t assign array value to non-array special",
                      pname);
              }
#line 2069
              return ((Param )((void *)0));
            }
#line 2071
            tc = 1;
#line 2072
            usepm = 0;
          } else {
#line 2060
            goto _L___3;
          }
        } else {
#line 2060
          goto _L___3;
        }
      } else {
#line 2060
        goto _L___3;
      }
    } else {
#line 2060
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 2074
  if (usepm) {
#line 2074
    goto _L;
  } else
#line 2074
  if (newspecial != 0) {
    _L: /* CIL Label */ 
#line 2075
    chflags = ((off & pm->node.flags) | (on & ~ pm->node.flags)) & (((((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) | 1) | (1 << 16)) | (1 << 27));
#line 2079
    if (chflags) {
#line 2079
      if (chflags != ((1 << 2) | (1 << 3))) {
#line 2079
        tmp___0 = 1;
      } else {
#line 2079
        tmp___0 = 0;
      }
    } else {
#line 2079
      tmp___0 = 0;
    }
#line 2079
    tc = tmp___0;
#line 2079
    if (tc) {
#line 2080
      usepm = 0;
    }
  }
#line 2089
  if (usepm) {
#line 2089
    goto _L___4;
  } else
#line 2089
  if (newspecial != 0) {
    _L___4: /* CIL Label */ 
#line 2089
    if ((off & pm->node.flags) & (1 << 10)) {
#line 2089
      tmp___5 = 1;
    } else {
#line 2089
      tmp___5 = 0;
    }
  } else {
#line 2089
    tmp___5 = 0;
  }
#line 2089
  readonly = tmp___5;
#line 2089
  if (readonly) {
#line 2089
    goto _L___5;
  } else
#line 2089
  if (tc) {
    _L___5: /* CIL Label */ 
#line 2093
    if (pm->node.flags & (1 << 22)) {
#line 2094
      err = 1;
#line 2095
      if (! readonly) {
        {
#line 2095
        tmp___3 = strcmp((char const   *)pname, "SECONDS");
        }
#line 2095
        if (! tmp___3) {
#line 2107
          if (newspecial != 0) {
#line 2114
            if ((on & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 2117
              newspecial = 2;
#line 2118
              err = 0;
#line 2119
              tc = 0;
            } else
#line 2114
            if ((on & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 2117
              newspecial = 2;
#line 2118
              err = 0;
#line 2119
              tc = 0;
            } else
#line 2114
            if ((on & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 2117
              newspecial = 2;
#line 2118
              err = 0;
#line 2119
              tc = 0;
            } else
#line 2114
            if ((on & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 2117
              newspecial = 2;
#line 2118
              err = 0;
#line 2119
              tc = 0;
            }
          } else {
            {
#line 2121
            tmp___2 = setsecondstype(pm, on, off);
            }
#line 2121
            if (! tmp___2) {
#line 2122
              if (asg___0->value.scalar) {
                {
#line 2122
                tmp___1 = ztrdup((char const   *)asg___0->value.scalar);
#line 2122
                pm = assignsparam(pname, tmp___1, 0);
                }
#line 2122
                if (! pm) {
#line 2125
                  return ((Param )((void *)0));
                }
              }
#line 2126
              usepm = 1;
#line 2127
              err = 0;
            }
          }
        }
      }
#line 2130
      if (err) {
        {
#line 2132
        zerrnam((char const   *)cname, "%s: can\'t change type of a special parameter",
                pname);
        }
#line 2134
        return ((Param )((void *)0));
      }
    } else
#line 2136
    if (pm->node.flags & (1 << 27)) {
      {
#line 2137
      zerrnam((char const   *)cname, "%s: can\'t change type of autoloaded parameter",
              pname);
      }
#line 2139
      return ((Param )((void *)0));
    }
  } else
#line 2142
  if (newspecial != 0) {
    {
#line 2142
    tmp___4 = strcmp((char const   *)pname, "SECONDS");
    }
#line 2142
    if (tmp___4 == 0) {
#line 2143
      newspecial = 2;
    }
  }
#line 2145
  if (opts[131]) {
#line 2149
    if (on & ((1 << 10) | (1 << 12))) {
#line 2149
      if (! usepm) {
#line 2149
        goto _L___8;
      } else
#line 2149
      if (pm->node.flags & (1 << 25)) {
        _L___8: /* CIL Label */ 
#line 2149
        if (asg___0->is_array) {
#line 2149
          goto _L___7;
        } else
#line 2149
        if ((unsigned long )asg___0->value.scalar != (unsigned long )((char *)0)) {
#line 2149
          goto _L___7;
        } else {
#line 2152
          on |= 1 << 25;
        }
      } else {
#line 2149
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 2153
    if (usepm) {
#line 2153
      if (pm->node.flags & (1 << 10)) {
#line 2153
        if (! (on & (1 << 10))) {
          {
#line 2155
          zerr("read-only variable: %s", pm->node.nam);
          }
#line 2156
          return ((Param )((void *)0));
        }
      }
    }
  }
#line 2173
  if (usepm) {
#line 2174
    if (asg___0->is_array) {
#line 2174
      tmp___7 = ! ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) & (1 | (1 << 4)));
    } else {
#line 2174
      if (asg___0->value.scalar) {
#line 2174
        if ((pm->node.flags & (1 | (1 << 4))) & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) {
#line 2174
          tmp___6 = 1;
        } else {
#line 2174
          tmp___6 = 0;
        }
      } else {
#line 2174
        tmp___6 = 0;
      }
#line 2174
      tmp___7 = tmp___6;
    }
#line 2174
    if (tmp___7) {
      {
#line 2178
      zerrnam((char const   *)cname, "%s: inconsistent type for assignment", pname);
      }
#line 2179
      return ((Param )((void *)0));
    }
#line 2181
    on &= ~ (1 << 21);
#line 2182
    if (! on) {
#line 2182
      if (! roff) {
#line 2182
        if (! asg___0->is_array) {
#line 2182
          if (! ((unsigned long )asg___0->value.scalar != (unsigned long )((char *)0))) {
#line 2183
            if ((int )ops->ind[112] != 0) {
              {
#line 2184
              (*(paramtab->printnode))(& pm->node, 1 << 5);
              }
            } else
#line 2185
            if (! ((int )ops->ind[103] != 0)) {
#line 2185
              if (! opts[171]) {
                {
#line 2187
                (*(paramtab->printnode))(& pm->node, 1 << 4);
                }
              } else
#line 2185
              if ((int )ops->ind[109] != 0) {
                {
#line 2187
                (*(paramtab->printnode))(& pm->node, 1 << 4);
                }
              }
            }
#line 2188
            return (pm);
          }
        }
      }
    }
#line 2190
    if (pm->node.flags & (1 << 24)) {
#line 2190
      if (opts[154]) {
        {
#line 2191
        zerrnam((char const   *)cname, "%s: restricted", pname);
        }
#line 2192
        return (pm);
      }
    }
#line 2194
    if (on & (1 << 13)) {
#line 2194
      if (! ((pm->node.flags & (1 << 10)) & ~ off)) {
#line 2197
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
          {
#line 2198
          x = (*((pm->gsu.a)->getfn))(pm);
#line 2199
          uniqarray(x);
          }
#line 2200
          if (pm->node.flags & (1 << 22)) {
            {
#line 2201
            tmp___8 = zheapptr((void *)x);
            }
#line 2201
            if (tmp___8) {
              {
#line 2202
              x = zarrdup(x);
              }
            }
            {
#line 2203
            (*((pm->gsu.a)->setfn))(pm, x);
            }
          } else
#line 2204
          if (pm->ename) {
#line 2204
            if (x) {
              {
#line 2205
              arrfixenv(pm->ename, x);
              }
            }
          }
        } else
#line 2206
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 2206
          if (pm->ename) {
            {
#line 2206
            tmp___9 = (*(paramtab->getnode))(paramtab, (char const   *)pm->ename);
#line 2206
            apm = (Param )tmp___9;
            }
#line 2206
            if (apm) {
              {
#line 2209
              x = (*((apm->gsu.a)->getfn))(apm);
#line 2210
              uniqarray(x);
              }
#line 2211
              if (x) {
                {
#line 2212
                arrfixenv(pm->node.nam, x);
                }
              }
            }
          }
        }
      }
    }
#line 2215
    if (usepm == 2) {
#line 2216
      pm->node.flags = (pm->node.flags | (on & ~ (1 << 10))) & ~ off;
    } else {
#line 2221
      if (! (on & (1 << 10))) {
#line 2222
        off |= 1 << 25;
      } else
#line 2221
      if (! opts[131]) {
#line 2222
        off |= 1 << 25;
      }
#line 2223
      pm->node.flags = (pm->node.flags | (on & ~ (1 << 10))) & ~ off;
    }
#line 2226
    if (on & (((1 << 5) | (1 << 6)) | (1 << 7))) {
      {
#line 2227
      tmp___10 = typeset_setwidth((char const   *)cname, pm, ops, on, 0);
      }
#line 2227
      if (tmp___10) {
#line 2228
        return ((Param )((void *)0));
      }
    }
#line 2230
    if (on & (((1 << 1) | (1 << 2)) | (1 << 3))) {
      {
#line 2231
      tmp___11 = typeset_setbase((char const   *)cname, pm, ops, on, 0);
      }
#line 2231
      if (tmp___11) {
#line 2232
        return ((Param )((void *)0));
      }
    }
#line 2234
    if (! (pm->node.flags & (1 | (1 << 4)))) {
#line 2235
      if (pm->node.flags & (1 << 12)) {
#line 2236
        if (! (pm->node.flags & (1 << 25))) {
#line 2236
          if (! pm->env) {
#line 2236
            if (! asg___0->is_array) {
#line 2236
              if (! ((unsigned long )asg___0->value.scalar != (unsigned long )((char *)0))) {
                {
#line 2237
                tmp___12 = getsparam(pname);
#line 2237
                addenv(pm, tmp___12);
                }
              }
            }
          }
        }
      } else
#line 2238
      if (pm->env) {
#line 2238
        if (! (pm->node.flags & (1 << 29))) {
          {
#line 2239
          delenv(pm);
          }
        }
      }
#line 2241
      if (asg___0->value.scalar) {
        {
#line 2241
        tmp___13 = ztrdup((char const   *)asg___0->value.scalar);
#line 2241
        pm = assignsparam(pname, tmp___13, 0);
        }
#line 2241
        if (! pm) {
#line 2243
          return ((Param )((void *)0));
        }
      }
    } else
#line 2244
    if (asg___0->is_array) {
#line 2245
      if (asg___0->value.array) {
        {
#line 2245
        tmp___14 = zlinklist2array(asg___0->value.array);
#line 2245
        tmp___16 = tmp___14;
        }
      } else {
        {
#line 2245
        tmp___15 = mkarray((char *)((void *)0));
#line 2245
        tmp___16 = tmp___15;
        }
      }
      {
#line 2245
      pm = assignaparam(pname, tmp___16, 0);
      }
#line 2245
      if (! pm) {
#line 2248
        return ((Param )((void *)0));
      }
    }
#line 2250
    if (errflag) {
#line 2251
      return ((Param )((void *)0));
    }
#line 2252
    pm->node.flags |= on & (1 << 10);
#line 2253
    if ((int )ops->ind[112] != 0) {
      {
#line 2254
      (*(paramtab->printnode))(& pm->node, 1 << 5);
      }
    }
#line 2255
    return (pm);
  }
#line 2258
  if (asg___0->is_array) {
#line 2258
    tmp___18 = ! (on & (1 | (1 << 4)));
  } else {
#line 2258
    if (asg___0->value.scalar) {
#line 2258
      if (on & (1 | (1 << 4))) {
#line 2258
        tmp___17 = 1;
      } else {
#line 2258
        tmp___17 = 0;
      }
    } else {
#line 2258
      tmp___17 = 0;
    }
#line 2258
    tmp___18 = tmp___17;
  }
#line 2258
  if (tmp___18) {
    {
#line 2261
    zerrnam((char const   *)cname, "%s: inconsistent type for assignment", pname);
    }
#line 2262
    return ((Param )((void *)0));
  }
#line 2271
  if (tc) {
#line 2273
    on |= (~ off & ((1 << 10) | (1 << 12))) & pm->node.flags;
#line 2275
    pm->node.flags &= ~ (1 << 10);
#line 2280
    keeplocal = pm->level;
#line 2288
    if (! asg___0->is_array) {
#line 2288
      if (! ((unsigned long )asg___0->value.scalar != (unsigned long )((char *)0))) {
#line 2288
        if (! ((pm->node.flags | on) & (1 | (1 << 4)))) {
          {
#line 2289
          tmp___19 = getsparam(pname);
#line 2289
          asg___0->value.scalar = dupstring((char const   *)tmp___19);
#line 2290
          asg___0->is_array = 0;
          }
        }
      }
    }
    {
#line 2293
    pname = dupstring((char const   *)pname);
#line 2294
    unsetparam_pm(pm, 0, 1);
    }
  }
#line 2297
  if (newspecial != 0) {
#line 2299
    if (pm->node.flags & (1 << 24)) {
#line 2299
      if (opts[154]) {
        {
#line 2300
        zerrnam((char const   *)cname, "%s: restricted", pname);
        }
#line 2301
        return (pm);
      }
    }
#line 2303
    if (pm->node.flags & (1 << 20)) {
      {
#line 2304
      zerrnam((char const   *)cname, "%s: can only have a single instance", pname);
      }
#line 2305
      return (pm);
    }
    {
#line 2312
    tmp___20 = zshcalloc(sizeof(*tpm));
#line 2312
    tpm = (Param )tmp___20;
#line 2314
    tpm->node.nam = pm->node.nam;
    }
#line 2315
    if (pm->ename) {
      {
#line 2315
      tmp___21 = (*(paramtab->getnode))(paramtab, (char const   *)pm->ename);
#line 2315
      pm2 = (Param )tmp___21;
      }
#line 2315
      if (pm2) {
#line 2315
        if (pm2->level == locallevel) {
#line 2329
          tpm->node.flags = pm->node.flags | (1 << 28);
        } else {
          {
#line 2331
          copyparam(tpm, pm, 1);
          }
        }
      } else {
        {
#line 2331
        copyparam(tpm, pm, 1);
        }
      }
    } else {
      {
#line 2331
      copyparam(tpm, pm, 1);
      }
    }
#line 2333
    tpm->old = pm->old;
#line 2334
    tpm->level = pm->level;
#line 2335
    tpm->base = pm->base;
#line 2336
    tpm->width = pm->width;
#line 2337
    if (pm->env) {
      {
#line 2338
      delenv(pm);
      }
    }
#line 2339
    tpm->env = (char *)((void *)0);
#line 2341
    pm->old = tpm;
#line 2346
    pm->node.flags = (((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) | on) | (1 << 22)) & ~ off;
#line 2350
    pm->node.flags |= tpm->node.flags & (1 << 10);
#line 2351
    if (newspecial == 2) {
      {
#line 2353
      tpm->u.dval = getrawseconds();
#line 2354
      setsecondstype(pm, on, off);
      }
    }
#line 2361
    if (on & (((1 << 5) | (1 << 6)) | (1 << 7))) {
      {
#line 2362
      tmp___22 = typeset_setwidth((char const   *)cname, pm, ops, on, 1);
      }
#line 2362
      if (tmp___22) {
#line 2363
        return ((Param )((void *)0));
      }
    }
#line 2365
    if (on & (((1 << 1) | (1 << 2)) | (1 << 3))) {
      {
#line 2366
      tmp___23 = typeset_setbase((char const   *)cname, pm, ops, on, 1);
      }
#line 2366
      if (tmp___23) {
#line 2367
        return ((Param )((void *)0));
      }
    }
  } else {
    {
#line 2369
    subscript = strchr((char const   *)pname, '[');
    }
#line 2369
    if (subscript) {
#line 2370
      if (on & (1 << 10)) {
        {
#line 2371
        zerrnam((char const   *)cname, "%s: can\'t create readonly array elements",
                pname);
        }
#line 2373
        return ((Param )((void *)0));
      } else
#line 2374
      if (on & (1 << 21)) {
#line 2374
        if (locallevel) {
#line 2375
          *subscript = (char)0;
#line 2376
          if ((unsigned long )paramtab == (unsigned long )realparamtab) {
            {
#line 2376
            tmp___24 = (*(paramtab->getnode2))(paramtab, (char const   *)pname);
#line 2376
            tmp___26 = tmp___24;
            }
          } else {
            {
#line 2376
            tmp___25 = (*(paramtab->getnode))(paramtab, (char const   *)pname);
#line 2376
            tmp___26 = tmp___25;
            }
          }
#line 2376
          pm = (Param )tmp___26;
#line 2380
          *subscript = (char )'[';
#line 2381
          if (! pm) {
            {
#line 2382
            zerrnam((char const   *)cname, "%s: can\'t create local array elements",
                    pname);
            }
#line 2384
            return ((Param )((void *)0));
          } else
#line 2381
          if (pm->level != locallevel) {
            {
#line 2382
            zerrnam((char const   *)cname, "%s: can\'t create local array elements",
                    pname);
            }
#line 2384
            return ((Param )((void *)0));
          }
        }
      }
#line 2387
      if ((on & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 2387
        if (! asg___0->is_array) {
#line 2394
          if (asg___0->value.scalar) {
#line 2394
            tmp___27 = (char const   *)asg___0->value.scalar;
          } else {
#line 2394
            tmp___27 = "";
          }
          {
#line 2394
          tmp___28 = ztrdup(tmp___27);
#line 2394
          pm = assignsparam(pname, tmp___28, 0);
          }
#line 2394
          if (! pm) {
#line 2397
            return ((Param )((void *)0));
          }
#line 2398
          dont_set = 1;
#line 2399
          asg___0->is_array = 0;
#line 2400
          keeplocal = 0;
#line 2401
          on = pm->node.flags;
        } else {
#line 2387
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 2402
      if ((on & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 2402
        if (asg___0->is_array) {
#line 2403
          if (asg___0->value.array) {
            {
#line 2403
            tmp___29 = zlinklist2array(asg___0->value.array);
#line 2403
            tmp___31 = tmp___29;
            }
          } else {
            {
#line 2403
            tmp___30 = mkarray((char *)((void *)0));
#line 2403
            tmp___31 = tmp___30;
            }
          }
          {
#line 2403
          pm = assignaparam(pname, tmp___31, 0);
          }
#line 2403
          if (! pm) {
#line 2406
            return ((Param )((void *)0));
          }
#line 2407
          dont_set = 1;
#line 2408
          keeplocal = 0;
#line 2409
          on = pm->node.flags;
        } else {
          {
#line 2411
          zerrnam((char const   *)cname, "%s: inconsistent array element or slice assignment",
                  pname);
          }
#line 2413
          return ((Param )((void *)0));
        }
      } else {
        {
#line 2411
        zerrnam((char const   *)cname, "%s: inconsistent array element or slice assignment",
                pname);
        }
#line 2413
        return ((Param )((void *)0));
      }
    } else {
      {
#line 2428
      tmp___34 = isident(pname);
      }
#line 2428
      if (tmp___34) {
#line 2428
        goto _L___12;
      } else {
        {
#line 2428
        tmp___35 = (*(paramtab->getnode))(paramtab, (char const   *)pname);
        }
#line 2428
        if (tmp___35) {
          _L___12: /* CIL Label */ 
#line 2428
          if (! ((int )typtab[(unsigned char )*pname] & 1)) {
#line 2428
            goto _L___11;
          } else {
            {
#line 2428
            tmp___36 = strcmp((char const   *)pname, "0");
            }
#line 2428
            if (tmp___36) {
#line 2428
              goto _L___10;
            } else {
              _L___11: /* CIL Label */ 
              {
#line 2434
              pm = createparam(pname, on & ~ (1 << 10));
              }
#line 2435
              if (! pm) {
#line 2436
                if (on & ((((((1 << 5) | (1 << 6)) | (1 << 7)) | (1 << 1)) | (1 << 2)) | (1 << 3))) {
                  {
#line 2438
                  zerrnam((char const   *)cname, "can\'t change variable attribute: %s",
                          pname);
                  }
                }
#line 2439
                return ((Param )((void *)0));
              }
#line 2441
              if (on & (((1 << 5) | (1 << 6)) | (1 << 7))) {
                {
#line 2442
                tmp___32 = typeset_setwidth((char const   *)cname, pm, ops, on, 0);
                }
#line 2442
                if (tmp___32) {
#line 2443
                  return ((Param )((void *)0));
                }
              }
#line 2445
              if (on & (((1 << 1) | (1 << 2)) | (1 << 3))) {
                {
#line 2446
                tmp___33 = typeset_setbase((char const   *)cname, pm, ops, on, 0);
                }
#line 2446
                if (tmp___33) {
#line 2447
                  return ((Param )((void *)0));
                }
              }
            }
          }
        } else {
          _L___10: /* CIL Label */ 
#line 2450
          if ((int )typtab[(unsigned char )*pname] & 1) {
            {
#line 2451
            zerrnam((char const   *)cname, "not an identifier: %s", pname);
            }
          } else {
            {
#line 2453
            zerrnam((char const   *)cname, "not valid in this context: %s", pname);
            }
          }
#line 2454
          return ((Param )((void *)0));
        }
      }
    }
  }
#line 2457
  if (altpm) {
#line 2457
    if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
      {
#line 2463
      tmp___37 = zalloc(sizeof(struct tieddata ));
#line 2463
      tdp = (struct tieddata *)tmp___37;
      }
#line 2465
      if (! tdp) {
#line 2466
        return ((Param )((void *)0));
      }
#line 2467
      tdp->joinchar = joinchar;
#line 2468
      tdp->arrptr = & altpm->u.arr;
#line 2470
      pm->gsu.s = & tiedarr_gsu;
#line 2471
      pm->u.data = (void *)tdp;
    }
  }
#line 2474
  if (keeplocal) {
#line 2475
    pm->level = keeplocal;
  } else
#line 2476
  if (on & (1 << 21)) {
#line 2477
    pm->level = locallevel;
  }
#line 2478
  if (asg___0->is_array) {
#line 2478
    goto _L___14;
  } else
#line 2478
  if ((unsigned long )asg___0->value.scalar != (unsigned long )((char *)0)) {
    _L___14: /* CIL Label */ 
#line 2478
    if (! dont_set) {
#line 2479
      ipm = pm;
#line 2480
      if (pm->node.flags & (1 | (1 << 4))) {
#line 2482
        if (! asg___0->is_array) {
#line 2489
          if (*(asg___0->value.scalar)) {
            {
#line 2491
            tmp___38 = ztrdup((char const   *)asg___0->value.scalar);
#line 2491
            arrayval = mkarray(tmp___38);
            }
          } else {
            {
#line 2494
            arrayval = mkarray((char *)((void *)0));
            }
          }
        } else
#line 2496
        if (asg___0->value.array) {
          {
#line 2497
          arrayval = zlinklist2array(asg___0->value.array);
          }
        } else {
          {
#line 2499
          arrayval = mkarray((char *)((void *)0));
          }
        }
        {
#line 2500
        pm = assignaparam(pname, arrayval, 0);
        }
#line 2500
        if (! pm) {
#line 2501
          return ((Param )((void *)0));
        }
      } else {
        {
#line 2504
        tmp___39 = ztrdup((char const   *)asg___0->value.scalar);
#line 2504
        pm = assignsparam(pname, tmp___39, 0);
        }
#line 2504
        if (! pm) {
#line 2505
          return ((Param )((void *)0));
        }
      }
#line 2507
      if ((unsigned long )pm != (unsigned long )ipm) {
        {
#line 2510
        unsetparam_pm(ipm, 0, 1);
        }
      }
    } else {
#line 2478
      goto _L___13;
    }
  } else
  _L___13: /* CIL Label */ 
#line 2512
  if (newspecial != 0) {
#line 2512
    if (! ((pm->old)->node.flags & ((1 << 28) | (1 << 10)))) {
      {
#line 2519
      if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 2519
        goto case_0;
      }
#line 2522
      if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 1) {
#line 2522
        goto case_exp;
      }
#line 2531
      if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 3) {
#line 2531
        goto case_exp___0;
      }
#line 2531
      if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 2) {
#line 2531
        goto case_exp___0;
      }
#line 2534
      if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 2534
        goto case_1;
      }
#line 2537
      if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
#line 2537
        goto case_exp___2;
      }
#line 2518
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 2520
      tmp___40 = ztrdup("");
#line 2520
      (*((pm->gsu.s)->setfn))(pm, tmp___40);
      }
#line 2521
      goto switch_break;
      case_exp: /* CIL Label */ 
#line 2527
      if (! ((pm->old)->node.flags & (1 << 24))) {
        {
#line 2528
        (*((pm->gsu.i)->setfn))(pm, (zlong )0);
        }
      }
#line 2529
      goto switch_break;
      case_exp___0: /* CIL Label */ 
      case_exp___1: /* CIL Label */ 
      {
#line 2532
      (*((pm->gsu.f)->setfn))(pm, 0.0);
      }
#line 2533
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 2535
      tmp___41 = mkarray((char *)((void *)0));
#line 2535
      (*((pm->gsu.a)->setfn))(pm, tmp___41);
      }
#line 2536
      goto switch_break;
      case_exp___2: /* CIL Label */ 
      {
#line 2538
      tmp___42 = newparamtable(17, (char const   *)pm->node.nam);
#line 2538
      (*((pm->gsu.h)->setfn))(pm, tmp___42);
      }
#line 2539
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 2542
  pm->node.flags |= on & (1 << 10);
#line 2544
  if ((int )ops->ind[112] != 0) {
    {
#line 2545
    (*(paramtab->printnode))(& pm->node, 1 << 5);
    }
  }
#line 2547
  return (pm);
}
}
#line 2560 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_typeset(char *name , char **argv , LinkList assigns , Options ops , int func ) 
{ 
  Param pm ;
  Asgment asg___0 ;
  Patprog pprog ;
  char *optstr ;
  int on ;
  int off ;
  int roff ;
  int bit ;
  int i ;
  int returnval ;
  int printflags ;
  int hasargs ;
  int tmp ;
  int optval ;
  int tmp___0 ;
  sigset_t oset ;
  Param apm ;
  struct asgment asg0 ;
  struct asgment asg2 ;
  char *oldval ;
  char *joinstr ;
  int joinchar ;
  int nargs ;
  sigset_t oset___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  sigset_t oset___1 ;
  sigset_t oset___2 ;
  sigset_t oset___3 ;
  sigset_t oset___4 ;
  sigset_t oset___5 ;
  sigset_t oset___6 ;
  sigset_t oset___7 ;
  int tmp___4 ;
  sigset_t oset___8 ;
  char *tmp___5 ;
  char *tmp___6 ;
  sigset_t oset___9 ;
  Asgment nextasg ;
  sigset_t oset___10 ;
  sigset_t oset___11 ;
  struct tieddata *tdp ;
  char *tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  HashNode tmp___11 ;
  sigset_t oset___12 ;
  HashNode tmp___12 ;
  sigset_t oset___13 ;
  HashNode tmp___13 ;
  char **tmp___14 ;
  sigset_t oset___14 ;
  sigset_t oset___15 ;
  LinkList pmlist ;
  LinkList tmp___15 ;
  LinkNode pmnode ;
  int tmp___16 ;
  Param tmp___17 ;
  sigset_t oset___16 ;
  HashNode hn ;
  HashNode tmp___18 ;
  HashNode tmp___19 ;
  HashNode tmp___20 ;
  Param tmp___21 ;
  sigset_t oset___17 ;

  {
#line 2566
  optstr = (char *)"aiEFALRZlurtxUhHTkz";
#line 2567
  on = 0;
#line 2567
  off = 0;
#line 2567
  bit = 1;
#line 2569
  returnval = 0;
#line 2569
  printflags = 0;
#line 2573
  if ((int )ops->ind[102] != 0) {
    {
#line 2574
    tmp = bin_functions(name, argv, ops, func);
    }
#line 2574
    return (tmp);
  }
#line 2577
  if (func == 22) {
#line 2577
    if (opts[131]) {
#line 2577
      if (! ((int )ops->ind[103] & 2)) {
#line 2578
        ops->ind['g'] = (unsigned char)1;
      }
    }
  }
  {
#line 2583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2583
    if (! *optstr) {
#line 2583
      goto while_break;
    }
#line 2585
    optval = (int )((unsigned char )*optstr);
#line 2586
    if ((int )ops->ind[optval] & 1) {
#line 2587
      on |= bit;
    } else
#line 2588
    if ((int )ops->ind[optval] & 2) {
#line 2589
      off |= bit;
    }
#line 2583
    optstr ++;
#line 2583
    bit <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 2591
  roff = off;
#line 2594
  if (on & (1 << 3)) {
#line 2595
    off |= ((((1 << 9) | 1) | (1 << 4)) | (1 << 1)) | (1 << 2);
#line 2597
    on &= ~ (1 << 2);
  }
#line 2599
  if (on & (1 << 2)) {
#line 2600
    off |= ((((1 << 9) | 1) | (1 << 4)) | (1 << 1)) | (1 << 3);
  }
#line 2601
  if (on & (1 << 1)) {
#line 2602
    off |= ((((1 << 9) | 1) | (1 << 4)) | (1 << 2)) | (1 << 3);
  }
#line 2607
  if (on & ((1 << 5) | (1 << 7))) {
#line 2608
    off |= 1 << 6;
  }
#line 2609
  if (on & (1 << 6)) {
#line 2610
    off |= (1 << 5) | (1 << 7);
  }
#line 2611
  if (on & (1 << 9)) {
#line 2612
    off |= 1 << 8;
  }
#line 2613
  if (on & (1 << 8)) {
#line 2614
    off |= 1 << 9;
  }
#line 2615
  if (on & (1 << 4)) {
#line 2616
    off |= 1;
  }
#line 2617
  if (on & (1 << 16)) {
#line 2618
    off |= ((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4);
  }
#line 2620
  on &= ~ off;
#line 2622
  queueing_enabled ++;
#line 2625
  if ((int )ops->ind[112] != 0) {
#line 2626
    printflags |= 1 << 5;
  }
#line 2627
  if ((unsigned long )*argv != (unsigned long )((void *)0)) {
#line 2627
    tmp___0 = 1;
  } else
#line 2627
  if (assigns) {
#line 2627
    if (assigns->list.first) {
#line 2627
      tmp___0 = 1;
    } else {
#line 2627
      tmp___0 = 0;
    }
  } else {
#line 2627
    tmp___0 = 0;
  }
#line 2627
  hasargs = tmp___0;
#line 2628
  if (! hasargs) {
#line 2629
    if (! ((int )ops->ind[112] != 0)) {
#line 2630
      if (! (on | roff)) {
#line 2631
        printflags |= 1 << 1;
      }
#line 2632
      if (roff) {
#line 2633
        printflags |= 1;
      } else
#line 2632
      if ((int )ops->ind[43] != 0) {
#line 2633
        printflags |= 1;
      }
    }
    {
#line 2635
    scanhashtable(paramtab, 1, on | roff, 0, paramtab->printnode, printflags);
    }
    {
#line 2636
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2636
      queueing_enabled --;
#line 2636
      if (! queueing_enabled) {
        {
#line 2636
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 2636
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2636
            if (! (queue_front != queue_rear)) {
#line 2636
              goto while_break___2;
            }
            {
#line 2636
            queue_front = (queue_front + 1) % 128;
#line 2636
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 2636
            zhandler(signal_queue[queue_front]);
#line 2636
            signal_setmask(oset);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2636
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 2636
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2637
    return (0);
  }
#line 2640
  if ((int )ops->ind[103] != 0) {
#line 2640
    goto _L;
  } else
#line 2640
  if ((int )ops->ind[120] != 0) {
#line 2640
    goto _L;
  } else
#line 2640
  if ((int )ops->ind[109] != 0) {
    _L: /* CIL Label */ 
#line 2640
    if ((int )ops->ind[103] & 2) {
#line 2643
      on |= 1 << 21;
    } else
#line 2640
    if ((int )*name == 108) {
#line 2643
      on |= 1 << 21;
    } else
#line 2640
    if (! opts[60]) {
#line 2640
      if (! ((int )ops->ind[103] != 0)) {
#line 2643
        on |= 1 << 21;
      }
    }
  } else {
#line 2643
    on |= 1 << 21;
  }
#line 2645
  if (on & (1 << 16)) {
#line 2648
    oldval = (char *)((void *)0);
#line 2651
    if ((int )ops->ind[109] != 0) {
      {
#line 2652
      zwarnnam((char const   *)name, "incompatible options for -T");
      }
      {
#line 2653
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2653
        queueing_enabled --;
#line 2653
        if (! queueing_enabled) {
          {
#line 2653
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 2653
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 2653
              if (! (queue_front != queue_rear)) {
#line 2653
                goto while_break___5;
              }
              {
#line 2653
              queue_front = (queue_front + 1) % 128;
#line 2653
              oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 2653
              zhandler(signal_queue[queue_front]);
#line 2653
              signal_setmask(oset___0);
              }
            }
            while_break___5: /* CIL Label */ ;
            }
#line 2653
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 2653
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2654
      return (1);
    }
    {
#line 2656
    on &= ~ off;
#line 2657
    tmp___1 = arrlen(argv);
    }
#line 2657
    if (assigns) {
      {
#line 2657
      tmp___2 = countlinknodes(assigns);
#line 2657
      tmp___3 = tmp___2;
      }
    } else {
#line 2657
      tmp___3 = 0;
    }
#line 2657
    nargs = tmp___1 + tmp___3;
#line 2658
    if (nargs < 2) {
      {
#line 2659
      zwarnnam((char const   *)name, "-T requires names of scalar and array");
      }
      {
#line 2660
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2660
        queueing_enabled --;
#line 2660
        if (! queueing_enabled) {
          {
#line 2660
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 2660
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 2660
              if (! (queue_front != queue_rear)) {
#line 2660
                goto while_break___8;
              }
              {
#line 2660
              queue_front = (queue_front + 1) % 128;
#line 2660
              oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 2660
              zhandler(signal_queue[queue_front]);
#line 2660
              signal_setmask(oset___1);
              }
            }
            while_break___8: /* CIL Label */ ;
            }
#line 2660
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
#line 2660
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2661
      return (1);
    }
#line 2663
    if (nargs > 3) {
      {
#line 2664
      zwarnnam((char const   *)name, "too many arguments for -T");
      }
      {
#line 2665
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 2665
        queueing_enabled --;
#line 2665
        if (! queueing_enabled) {
          {
#line 2665
          while (1) {
            while_continue___10: /* CIL Label */ ;
            {
#line 2665
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 2665
              if (! (queue_front != queue_rear)) {
#line 2665
                goto while_break___11;
              }
              {
#line 2665
              queue_front = (queue_front + 1) % 128;
#line 2665
              oset___2 = signal_setmask(signal_mask_queue[queue_front]);
#line 2665
              zhandler(signal_queue[queue_front]);
#line 2665
              signal_setmask(oset___2);
              }
            }
            while_break___11: /* CIL Label */ ;
            }
#line 2665
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
        }
#line 2665
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 2666
      return (1);
    }
    {
#line 2669
    asg___0 = getasg(& argv, assigns);
    }
#line 2669
    if (! asg___0) {
      {
#line 2670
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 2670
        queueing_enabled --;
#line 2670
        if (! queueing_enabled) {
          {
#line 2670
          while (1) {
            while_continue___13: /* CIL Label */ ;
            {
#line 2670
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 2670
              if (! (queue_front != queue_rear)) {
#line 2670
                goto while_break___14;
              }
              {
#line 2670
              queue_front = (queue_front + 1) % 128;
#line 2670
              oset___3 = signal_setmask(signal_mask_queue[queue_front]);
#line 2670
              zhandler(signal_queue[queue_front]);
#line 2670
              signal_setmask(oset___3);
              }
            }
            while_break___14: /* CIL Label */ ;
            }
#line 2670
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
#line 2670
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 2671
      return (1);
    }
#line 2673
    asg0 = *asg___0;
#line 2674
    if (asg0.is_array) {
      {
#line 2675
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 2675
        queueing_enabled --;
#line 2675
        if (! queueing_enabled) {
          {
#line 2675
          while (1) {
            while_continue___16: /* CIL Label */ ;
            {
#line 2675
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 2675
              if (! (queue_front != queue_rear)) {
#line 2675
                goto while_break___17;
              }
              {
#line 2675
              queue_front = (queue_front + 1) % 128;
#line 2675
              oset___4 = signal_setmask(signal_mask_queue[queue_front]);
#line 2675
              zhandler(signal_queue[queue_front]);
#line 2675
              signal_setmask(oset___4);
              }
            }
            while_break___17: /* CIL Label */ ;
            }
#line 2675
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
        }
#line 2675
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 2676
      zwarnnam((char const   *)name, "first argument of tie must be scalar: %s", asg0.name);
      }
#line 2678
      return (1);
    }
    {
#line 2681
    asg___0 = getasg(& argv, assigns);
    }
#line 2681
    if (! asg___0) {
      {
#line 2682
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 2682
        queueing_enabled --;
#line 2682
        if (! queueing_enabled) {
          {
#line 2682
          while (1) {
            while_continue___19: /* CIL Label */ ;
            {
#line 2682
            while (1) {
              while_continue___20: /* CIL Label */ ;
#line 2682
              if (! (queue_front != queue_rear)) {
#line 2682
                goto while_break___20;
              }
              {
#line 2682
              queue_front = (queue_front + 1) % 128;
#line 2682
              oset___5 = signal_setmask(signal_mask_queue[queue_front]);
#line 2682
              zhandler(signal_queue[queue_front]);
#line 2682
              signal_setmask(oset___5);
              }
            }
            while_break___20: /* CIL Label */ ;
            }
#line 2682
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
        }
#line 2682
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 2683
      return (1);
    }
#line 2685
    if (! asg___0->is_array) {
#line 2685
      if (asg___0->value.scalar) {
        {
#line 2686
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 2686
          queueing_enabled --;
#line 2686
          if (! queueing_enabled) {
            {
#line 2686
            while (1) {
              while_continue___22: /* CIL Label */ ;
              {
#line 2686
              while (1) {
                while_continue___23: /* CIL Label */ ;
#line 2686
                if (! (queue_front != queue_rear)) {
#line 2686
                  goto while_break___23;
                }
                {
#line 2686
                queue_front = (queue_front + 1) % 128;
#line 2686
                oset___6 = signal_setmask(signal_mask_queue[queue_front]);
#line 2686
                zhandler(signal_queue[queue_front]);
#line 2686
                signal_setmask(oset___6);
                }
              }
              while_break___23: /* CIL Label */ ;
              }
#line 2686
              goto while_break___22;
            }
            while_break___22: /* CIL Label */ ;
            }
          }
#line 2686
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
        {
#line 2687
        zwarnnam((char const   *)name, "second argument of tie must be array: %s",
                 asg___0->name);
        }
#line 2689
        return (1);
      }
    }
    {
#line 2692
    tmp___4 = strcmp((char const   *)asg0.name, (char const   *)asg___0->name);
    }
#line 2692
    if (! tmp___4) {
      {
#line 2693
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 2693
        queueing_enabled --;
#line 2693
        if (! queueing_enabled) {
          {
#line 2693
          while (1) {
            while_continue___25: /* CIL Label */ ;
            {
#line 2693
            while (1) {
              while_continue___26: /* CIL Label */ ;
#line 2693
              if (! (queue_front != queue_rear)) {
#line 2693
                goto while_break___26;
              }
              {
#line 2693
              queue_front = (queue_front + 1) % 128;
#line 2693
              oset___7 = signal_setmask(signal_mask_queue[queue_front]);
#line 2693
              zhandler(signal_queue[queue_front]);
#line 2693
              signal_setmask(oset___7);
              }
            }
            while_break___26: /* CIL Label */ ;
            }
#line 2693
            goto while_break___25;
          }
          while_break___25: /* CIL Label */ ;
          }
        }
#line 2693
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
      {
#line 2694
      zerrnam((char const   *)name, "can\'t tie a variable to itself: %s", asg0.name);
      }
#line 2695
      return (1);
    }
    {
#line 2697
    tmp___5 = strchr((char const   *)asg0.name, '[');
    }
#line 2697
    if (tmp___5) {
#line 2697
      goto _L___0;
    } else {
      {
#line 2697
      tmp___6 = strchr((char const   *)asg___0->name, '[');
      }
#line 2697
      if (tmp___6) {
        _L___0: /* CIL Label */ 
        {
#line 2698
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 2698
          queueing_enabled --;
#line 2698
          if (! queueing_enabled) {
            {
#line 2698
            while (1) {
              while_continue___28: /* CIL Label */ ;
              {
#line 2698
              while (1) {
                while_continue___29: /* CIL Label */ ;
#line 2698
                if (! (queue_front != queue_rear)) {
#line 2698
                  goto while_break___29;
                }
                {
#line 2698
                queue_front = (queue_front + 1) % 128;
#line 2698
                oset___8 = signal_setmask(signal_mask_queue[queue_front]);
#line 2698
                zhandler(signal_queue[queue_front]);
#line 2698
                signal_setmask(oset___8);
                }
              }
              while_break___29: /* CIL Label */ ;
              }
#line 2698
              goto while_break___28;
            }
            while_break___28: /* CIL Label */ ;
            }
          }
#line 2698
          goto while_break___27;
        }
        while_break___27: /* CIL Label */ ;
        }
        {
#line 2699
        zerrnam((char const   *)name, "can\'t tie array elements: %s", asg0.name);
        }
#line 2700
        return (1);
      }
    }
#line 2702
    if (asg___0->is_array) {
#line 2702
      goto _L___2;
    } else
#line 2702
    if ((unsigned long )asg___0->value.scalar != (unsigned long )((char *)0)) {
      _L___2: /* CIL Label */ 
#line 2702
      if (asg0.is_array) {
#line 2702
        goto _L___1;
      } else
#line 2702
      if ((unsigned long )asg0.value.scalar != (unsigned long )((char *)0)) {
        _L___1: /* CIL Label */ 
        {
#line 2703
        while (1) {
          while_continue___30: /* CIL Label */ ;
#line 2703
          queueing_enabled --;
#line 2703
          if (! queueing_enabled) {
            {
#line 2703
            while (1) {
              while_continue___31: /* CIL Label */ ;
              {
#line 2703
              while (1) {
                while_continue___32: /* CIL Label */ ;
#line 2703
                if (! (queue_front != queue_rear)) {
#line 2703
                  goto while_break___32;
                }
                {
#line 2703
                queue_front = (queue_front + 1) % 128;
#line 2703
                oset___9 = signal_setmask(signal_mask_queue[queue_front]);
#line 2703
                zhandler(signal_queue[queue_front]);
#line 2703
                signal_setmask(oset___9);
                }
              }
              while_break___32: /* CIL Label */ ;
              }
#line 2703
              goto while_break___31;
            }
            while_break___31: /* CIL Label */ ;
            }
          }
#line 2703
          goto while_break___30;
        }
        while_break___30: /* CIL Label */ ;
        }
        {
#line 2704
        zerrnam((char const   *)name, "only one tied parameter can have value: %s",
                asg0.name);
        }
#line 2705
        return (1);
      }
    }
#line 2712
    if (*argv) {
#line 2713
      joinstr = *argv;
    } else
#line 2714
    if (assigns) {
#line 2714
      if (assigns->list.first) {
#line 2715
        nextasg = (Asgment )assigns->list.first;
#line 2716
        if (nextasg->is_array) {
#line 2716
          goto _L___4;
        } else
#line 2716
        if (nextasg->is_array) {
#line 2716
          goto _L___4;
        } else
#line 2716
        if ((unsigned long )nextasg->value.scalar != (unsigned long )((char *)0)) {
          _L___4: /* CIL Label */ 
          {
#line 2717
          zwarnnam((char const   *)name, "third argument of tie must be join character");
          }
          {
#line 2718
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 2718
            queueing_enabled --;
#line 2718
            if (! queueing_enabled) {
              {
#line 2718
              while (1) {
                while_continue___34: /* CIL Label */ ;
                {
#line 2718
                while (1) {
                  while_continue___35: /* CIL Label */ ;
#line 2718
                  if (! (queue_front != queue_rear)) {
#line 2718
                    goto while_break___35;
                  }
                  {
#line 2718
                  queue_front = (queue_front + 1) % 128;
#line 2718
                  oset___10 = signal_setmask(signal_mask_queue[queue_front]);
#line 2718
                  zhandler(signal_queue[queue_front]);
#line 2718
                  signal_setmask(oset___10);
                  }
                }
                while_break___35: /* CIL Label */ ;
                }
#line 2718
                goto while_break___34;
              }
              while_break___34: /* CIL Label */ ;
              }
            }
#line 2718
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
#line 2719
          return (1);
        }
#line 2721
        joinstr = nextasg->name;
      } else {
#line 2723
        joinstr = (char *)((void *)0);
      }
    } else {
#line 2723
      joinstr = (char *)((void *)0);
    }
#line 2724
    if (! joinstr) {
#line 2725
      joinchar = ':';
    } else
#line 2726
    if (! *joinstr) {
#line 2727
      joinchar = 0;
    } else
#line 2728
    if ((int )*joinstr == -125) {
#line 2729
      joinchar = (int )*(joinstr + 1) ^ 32;
    } else {
#line 2731
      joinchar = (int )*joinstr;
    }
    {
#line 2741
    tmp___11 = (*(paramtab->getnode))(paramtab, (char const   *)asg0.name);
#line 2741
    pm = (Param )tmp___11;
    }
#line 2741
    if (pm) {
#line 2741
      if (! (pm->node.flags & (1 << 25))) {
#line 2741
        if (locallevel == pm->level) {
#line 2741
          goto _L___5;
        } else
#line 2741
        if (! (on & (1 << 21))) {
          _L___5: /* CIL Label */ 
#line 2744
          if (pm->node.flags & (1 << 16)) {
            {
#line 2745
            while (1) {
              while_continue___36: /* CIL Label */ ;
#line 2745
              queueing_enabled --;
#line 2745
              if (! queueing_enabled) {
                {
#line 2745
                while (1) {
                  while_continue___37: /* CIL Label */ ;
                  {
#line 2745
                  while (1) {
                    while_continue___38: /* CIL Label */ ;
#line 2745
                    if (! (queue_front != queue_rear)) {
#line 2745
                      goto while_break___38;
                    }
                    {
#line 2745
                    queue_front = (queue_front + 1) % 128;
#line 2745
                    oset___11 = signal_setmask(signal_mask_queue[queue_front]);
#line 2745
                    zhandler(signal_queue[queue_front]);
#line 2745
                    signal_setmask(oset___11);
                    }
                  }
                  while_break___38: /* CIL Label */ ;
                  }
#line 2745
                  goto while_break___37;
                }
                while_break___37: /* CIL Label */ ;
                }
              }
#line 2745
              goto while_break___36;
            }
            while_break___36: /* CIL Label */ ;
            }
#line 2746
            if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) != 0) {
              {
#line 2747
              zwarnnam((char const   *)name, "already tied as non-scalar: %s", asg0.name);
              }
            } else {
              {
#line 2748
              tmp___9 = strcmp((char const   *)asg___0->name, (char const   *)pm->ename);
              }
#line 2748
              if (tmp___9) {
                {
#line 2762
                zwarnnam((char const   *)name, "can\'t tie already tied scalar: %s",
                         asg0.name);
                }
              } else {
#line 2752
                tdp = (struct tieddata *)pm->u.data;
#line 2754
                tdp->joinchar = joinchar;
#line 2755
                if (asg0.value.scalar) {
                  {
#line 2756
                  tmp___7 = ztrdup((char const   *)asg0.value.scalar);
#line 2756
                  assignsparam(asg0.name, tmp___7, 0);
                  }
                } else
#line 2757
                if (asg___0->value.array) {
                  {
#line 2758
                  tmp___8 = zlinklist2array(asg___0->value.array);
#line 2758
                  assignaparam(asg___0->name, tmp___8, 0);
                  }
                }
#line 2760
                return (0);
              }
            }
#line 2765
            return (1);
          }
#line 2767
          if (! asg0.value.scalar) {
#line 2767
            if (! asg___0->value.array) {
#line 2767
              if (! ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) & (1 | (1 << 4)))) {
                {
#line 2769
                tmp___10 = getsparam(asg0.name);
#line 2769
                oldval = ztrdup((char const   *)tmp___10);
                }
              }
            }
          }
#line 2770
          on |= pm->node.flags & (1 << 12);
        }
      }
    }
    {
#line 2780
    asg2.name = asg___0->name;
#line 2781
    asg2.is_array = 0;
#line 2782
    asg2.value.array = (LinkList )0;
#line 2783
    tmp___12 = (*(paramtab->getnode))(paramtab, (char const   *)asg___0->name);
#line 2783
    apm = typeset_single(name, asg___0->name, (Param )tmp___12, func, (on | 1) & ~ (1 << 12),
                         off, roff, & asg2, (Param )((void *)0), ops, 0);
    }
#line 2783
    if (! apm) {
#line 2788
      if (oldval) {
        {
#line 2789
        zsfree(oldval);
        }
      }
      {
#line 2790
      while (1) {
        while_continue___39: /* CIL Label */ ;
#line 2790
        queueing_enabled --;
#line 2790
        if (! queueing_enabled) {
          {
#line 2790
          while (1) {
            while_continue___40: /* CIL Label */ ;
            {
#line 2790
            while (1) {
              while_continue___41: /* CIL Label */ ;
#line 2790
              if (! (queue_front != queue_rear)) {
#line 2790
                goto while_break___41;
              }
              {
#line 2790
              queue_front = (queue_front + 1) % 128;
#line 2790
              oset___12 = signal_setmask(signal_mask_queue[queue_front]);
#line 2790
              zhandler(signal_queue[queue_front]);
#line 2790
              signal_setmask(oset___12);
              }
            }
            while_break___41: /* CIL Label */ ;
            }
#line 2790
            goto while_break___40;
          }
          while_break___40: /* CIL Label */ ;
          }
        }
#line 2790
        goto while_break___39;
      }
      while_break___39: /* CIL Label */ ;
      }
#line 2791
      return (1);
    }
    {
#line 2797
    tmp___13 = (*(paramtab->getnode))(paramtab, (char const   *)asg0.name);
#line 2797
    pm = typeset_single(name, asg0.name, (Param )tmp___13, func, on, off, roff, & asg0,
                        apm, ops, joinchar);
    }
#line 2797
    if (! pm) {
#line 2802
      if (oldval) {
        {
#line 2803
        zsfree(oldval);
        }
      }
      {
#line 2804
      unsetparam_pm(apm, 1, 1);
      }
      {
#line 2805
      while (1) {
        while_continue___42: /* CIL Label */ ;
#line 2805
        queueing_enabled --;
#line 2805
        if (! queueing_enabled) {
          {
#line 2805
          while (1) {
            while_continue___43: /* CIL Label */ ;
            {
#line 2805
            while (1) {
              while_continue___44: /* CIL Label */ ;
#line 2805
              if (! (queue_front != queue_rear)) {
#line 2805
                goto while_break___44;
              }
              {
#line 2805
              queue_front = (queue_front + 1) % 128;
#line 2805
              oset___13 = signal_setmask(signal_mask_queue[queue_front]);
#line 2805
              zhandler(signal_queue[queue_front]);
#line 2805
              signal_setmask(oset___13);
              }
            }
            while_break___44: /* CIL Label */ ;
            }
#line 2805
            goto while_break___43;
          }
          while_break___43: /* CIL Label */ ;
          }
        }
#line 2805
        goto while_break___42;
      }
      while_break___42: /* CIL Label */ ;
      }
#line 2806
      return (1);
    }
#line 2813
    if (pm->ename) {
      {
#line 2814
      zsfree(pm->ename);
      }
    }
    {
#line 2815
    pm->ename = ztrdup((char const   *)asg___0->name);
    }
#line 2816
    if (apm->ename) {
      {
#line 2817
      zsfree(apm->ename);
      }
    }
    {
#line 2818
    apm->ename = ztrdup((char const   *)asg0.name);
    }
#line 2819
    if (asg___0->value.array) {
      {
#line 2820
      tmp___14 = zlinklist2array(asg___0->value.array);
#line 2820
      assignaparam(asg___0->name, tmp___14, 0);
      }
    } else
#line 2821
    if (oldval) {
      {
#line 2822
      assignsparam(asg0.name, oldval, 0);
      }
    }
    {
#line 2823
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 2823
      queueing_enabled --;
#line 2823
      if (! queueing_enabled) {
        {
#line 2823
        while (1) {
          while_continue___46: /* CIL Label */ ;
          {
#line 2823
          while (1) {
            while_continue___47: /* CIL Label */ ;
#line 2823
            if (! (queue_front != queue_rear)) {
#line 2823
              goto while_break___47;
            }
            {
#line 2823
            queue_front = (queue_front + 1) % 128;
#line 2823
            oset___14 = signal_setmask(signal_mask_queue[queue_front]);
#line 2823
            zhandler(signal_queue[queue_front]);
#line 2823
            signal_setmask(oset___14);
            }
          }
          while_break___47: /* CIL Label */ ;
          }
#line 2823
          goto while_break___46;
        }
        while_break___46: /* CIL Label */ ;
        }
      }
#line 2823
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
#line 2825
    return (0);
  }
#line 2827
  if (off & (1 << 16)) {
    {
#line 2828
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 2828
      queueing_enabled --;
#line 2828
      if (! queueing_enabled) {
        {
#line 2828
        while (1) {
          while_continue___49: /* CIL Label */ ;
          {
#line 2828
          while (1) {
            while_continue___50: /* CIL Label */ ;
#line 2828
            if (! (queue_front != queue_rear)) {
#line 2828
              goto while_break___50;
            }
            {
#line 2828
            queue_front = (queue_front + 1) % 128;
#line 2828
            oset___15 = signal_setmask(signal_mask_queue[queue_front]);
#line 2828
            zhandler(signal_queue[queue_front]);
#line 2828
            signal_setmask(oset___15);
            }
          }
          while_break___50: /* CIL Label */ ;
          }
#line 2828
          goto while_break___49;
        }
        while_break___49: /* CIL Label */ ;
        }
      }
#line 2828
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 2829
    zerrnam((char const   *)name, "use unset to remove tied variables");
    }
#line 2830
    return (1);
  }
#line 2834
  if ((int )ops->ind[109] != 0) {
#line 2835
    if (! ((int )ops->ind[112] != 0)) {
#line 2836
      if (! (on | roff)) {
#line 2837
        printflags |= 1 << 1;
      }
#line 2838
      if (! on) {
#line 2839
        printflags |= 1;
      }
    }
    {
#line 2842
    while (1) {
      while_continue___51: /* CIL Label */ ;
      {
#line 2842
      asg___0 = getasg(& argv, assigns);
      }
#line 2842
      if (! asg___0) {
#line 2842
        goto while_break___51;
      }
      {
#line 2843
      tmp___15 = newlinklist();
#line 2843
      pmlist = tmp___15;
#line 2846
      tokenize(asg___0->name);
#line 2847
      pprog = patcompile(asg___0->name, 0, (char **)((void *)0));
      }
#line 2847
      if (! pprog) {
        {
#line 2848
        untokenize(asg___0->name);
#line 2849
        zwarnnam((char const   *)name, "bad pattern : %s", asg___0->name);
#line 2850
        returnval = 1;
        }
#line 2851
        goto while_continue___51;
      }
#line 2853
      if ((int )ops->ind[109] & 2) {
#line 2853
        if (! asg___0->is_array) {
#line 2853
          if (! ((unsigned long )asg___0->value.scalar != (unsigned long )((char *)0))) {
            {
#line 2854
            scanmatchtable(paramtab, pprog, 1, on | roff, 0, paramtab->printnode,
                           printflags);
            }
#line 2856
            goto while_continue___51;
          }
        }
      }
#line 2866
      i = 0;
      {
#line 2866
      while (1) {
        while_continue___52: /* CIL Label */ ;
#line 2866
        if (! (i < paramtab->hsize)) {
#line 2866
          goto while_break___52;
        }
#line 2867
        pm = (Param )*(paramtab->nodes + i);
        {
#line 2867
        while (1) {
          while_continue___53: /* CIL Label */ ;
#line 2867
          if (! pm) {
#line 2867
            goto while_break___53;
          }
#line 2869
          if (pm->node.flags & (1 << 24)) {
#line 2869
            if (opts[154]) {
#line 2871
              goto __Cont;
            } else {
#line 2869
              goto _L___6;
            }
          } else
          _L___6: /* CIL Label */ 
#line 2869
          if (pm->node.flags & (1 << 25)) {
#line 2871
            goto __Cont;
          }
          {
#line 2872
          tmp___16 = pattry(pprog, pm->node.nam);
          }
#line 2872
          if (tmp___16) {
            {
#line 2873
            insertlinknode(pmlist, pmlist->list.last, (void *)pm);
            }
          }
          __Cont: /* CIL Label */ 
#line 2867
          pm = (Param )pm->node.next;
        }
        while_break___53: /* CIL Label */ ;
        }
#line 2866
        i ++;
      }
      while_break___52: /* CIL Label */ ;
      }
#line 2876
      pmnode = pmlist->list.first;
      {
#line 2876
      while (1) {
        while_continue___54: /* CIL Label */ ;
#line 2876
        if (! pmnode) {
#line 2876
          goto while_break___54;
        }
        {
#line 2877
        pm = (Param )pmnode->dat;
#line 2878
        tmp___17 = typeset_single(name, pm->node.nam, pm, func, on, off, roff, asg___0,
                                  (Param )((void *)0), ops, 0);
        }
#line 2878
        if (! tmp___17) {
#line 2880
          returnval = 1;
        }
#line 2876
        pmnode = pmnode->next;
      }
      while_break___54: /* CIL Label */ ;
      }
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 2883
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 2883
      queueing_enabled --;
#line 2883
      if (! queueing_enabled) {
        {
#line 2883
        while (1) {
          while_continue___56: /* CIL Label */ ;
          {
#line 2883
          while (1) {
            while_continue___57: /* CIL Label */ ;
#line 2883
            if (! (queue_front != queue_rear)) {
#line 2883
              goto while_break___57;
            }
            {
#line 2883
            queue_front = (queue_front + 1) % 128;
#line 2883
            oset___16 = signal_setmask(signal_mask_queue[queue_front]);
#line 2883
            zhandler(signal_queue[queue_front]);
#line 2883
            signal_setmask(oset___16);
            }
          }
          while_break___57: /* CIL Label */ ;
          }
#line 2883
          goto while_break___56;
        }
        while_break___56: /* CIL Label */ ;
        }
      }
#line 2883
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
#line 2884
    return (returnval);
  }
  {
#line 2888
  while (1) {
    while_continue___58: /* CIL Label */ ;
    {
#line 2888
    asg___0 = getasg(& argv, assigns);
    }
#line 2888
    if (! asg___0) {
#line 2888
      goto while_break___58;
    }
#line 2889
    if ((unsigned long )paramtab == (unsigned long )realparamtab) {
      {
#line 2889
      tmp___18 = (*(paramtab->getnode2))(paramtab, (char const   *)asg___0->name);
#line 2889
      tmp___20 = tmp___18;
      }
    } else {
      {
#line 2889
      tmp___19 = (*(paramtab->getnode))(paramtab, (char const   *)asg___0->name);
#line 2889
      tmp___20 = tmp___19;
      }
    }
#line 2889
    hn = tmp___20;
#line 2893
    if ((int )ops->ind[112] != 0) {
#line 2894
      if (hn) {
        {
#line 2895
        (*(paramtab->printnode))(hn, printflags);
        }
      } else {
        {
#line 2897
        zwarnnam((char const   *)name, "no such variable: %s", asg___0->name);
#line 2898
        returnval = 1;
        }
      }
#line 2900
      goto while_continue___58;
    }
    {
#line 2902
    tmp___21 = typeset_single(name, asg___0->name, (Param )hn, func, on, off, roff,
                              asg___0, (Param )((void *)0), ops, 0);
    }
#line 2902
    if (! tmp___21) {
#line 2905
      returnval = 1;
    }
  }
  while_break___58: /* CIL Label */ ;
  }
  {
#line 2907
  while (1) {
    while_continue___59: /* CIL Label */ ;
#line 2907
    queueing_enabled --;
#line 2907
    if (! queueing_enabled) {
      {
#line 2907
      while (1) {
        while_continue___60: /* CIL Label */ ;
        {
#line 2907
        while (1) {
          while_continue___61: /* CIL Label */ ;
#line 2907
          if (! (queue_front != queue_rear)) {
#line 2907
            goto while_break___61;
          }
          {
#line 2907
          queue_front = (queue_front + 1) % 128;
#line 2907
          oset___17 = signal_setmask(signal_mask_queue[queue_front]);
#line 2907
          zhandler(signal_queue[queue_front]);
#line 2907
          signal_setmask(oset___17);
          }
        }
        while_break___61: /* CIL Label */ ;
        }
#line 2907
        goto while_break___60;
      }
      while_break___60: /* CIL Label */ ;
      }
    }
#line 2907
    goto while_break___59;
  }
  while_break___59: /* CIL Label */ ;
  }
#line 2908
  return (returnval);
}
}
#line 2914 "/tmp/zsh-5.4.2/Src/builtin.c"
int eval_autoload(Shfunc shf , char *name , Options ops , int func ) 
{ 
  char *fargv[3] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Shfunc tmp___2 ;
  int tmp___3 ;

  {
#line 2917
  if (! (shf->node.flags & (1 << 9))) {
#line 2918
    return (1);
  }
#line 2920
  if (shf->funcdef) {
    {
#line 2921
    freeeprog(shf->funcdef);
#line 2922
    shf->funcdef = & dummy_eprog;
    }
  }
#line 2924
  if ((int )ops->ind[88] & 1) {
    {
#line 2926
    fargv[0] = name;
#line 2927
    fargv[1] = (char *)"\"$@\"";
#line 2928
    fargv[2] = (char *)0;
#line 2929
    shf->funcdef = mkautofn(shf);
#line 2930
    tmp = bin_eval(name, fargv, ops, func);
    }
#line 2930
    return (tmp);
  }
#line 2933
  if ((int )ops->ind[107] != 0) {
#line 2933
    tmp___1 = 2;
  } else {
#line 2933
    if ((int )ops->ind[122] != 0) {
#line 2933
      tmp___0 = 0;
    } else {
#line 2933
      tmp___0 = 1;
    }
#line 2933
    tmp___1 = tmp___0;
  }
  {
#line 2933
  tmp___2 = loadautofn(shf, tmp___1, 1, (int )ops->ind[100] != 0);
  }
#line 2933
  if (tmp___2) {
#line 2933
    tmp___3 = 0;
  } else {
#line 2933
    tmp___3 = 1;
  }
#line 2933
  return (tmp___3);
}
}
#line 2941 "/tmp/zsh-5.4.2/Src/builtin.c"
static int check_autoload(Shfunc shf , char *name , Options ops , int func ) 
{ 
  int tmp ;
  char *dir_path ;
  char *spec_path[2] ;
  Eprog tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  Eprog tmp___3 ;

  {
#line 2944
  if ((int )ops->ind[88] != 0) {
    {
#line 2946
    tmp = eval_autoload(shf, name, ops, func);
    }
#line 2946
    return (tmp);
  }
#line 2948
  if ((int )ops->ind[114] != 0) {
#line 2948
    goto _L;
  } else
#line 2948
  if ((int )ops->ind[82] != 0) {
    _L: /* CIL Label */ 
#line 2948
    if (shf->node.flags & (1 << 9)) {
#line 2952
      if (shf->filename) {
#line 2952
        if (shf->node.flags & (1 << 19)) {
          {
#line 2954
          spec_path[0] = shf->filename;
#line 2955
          spec_path[1] = (char *)((void *)0);
#line 2956
          tmp___0 = getfpfunc(shf->node.nam, (int *)((void *)0), & dir_path, spec_path,
                              1);
          }
#line 2956
          if (tmp___0) {
#line 2958
            return (0);
          }
#line 2960
          if (! ((int )ops->ind[100] != 0)) {
#line 2961
            if ((int )ops->ind[82] != 0) {
              {
#line 2962
              zerr("%s: function definition file not found", shf->node.nam);
              }
#line 2964
              return (1);
            }
#line 2966
            return (0);
          }
        }
      }
      {
#line 2969
      tmp___3 = getfpfunc(shf->node.nam, (int *)((void *)0), & dir_path, (char **)((void *)0),
                          1);
      }
#line 2969
      if (tmp___3) {
        {
#line 2970
        dircache_set(& shf->filename, (char *)((void *)0));
        }
#line 2971
        if ((int )*dir_path != 47) {
          {
#line 2972
          tmp___1 = zgetcwd();
#line 2972
          tmp___2 = metafy(tmp___1, -1, 6);
#line 2972
          dir_path = zhtricat((char const   *)tmp___2, "/", (char const   *)dir_path);
#line 2974
          dir_path = xsymlink(dir_path, 1);
          }
        }
        {
#line 2976
        dircache_set(& shf->filename, dir_path);
#line 2977
        shf->node.flags |= 1 << 19;
        }
#line 2978
        return (0);
      }
#line 2980
      if ((int )ops->ind[82] != 0) {
        {
#line 2981
        zerr("%s: function definition file not found", shf->node.nam);
        }
#line 2983
        return (1);
      }
    }
  }
#line 2987
  return (0);
}
}
#line 2991 "/tmp/zsh-5.4.2/Src/builtin.c"
static void listusermathfunc(MathFunc p ) 
{ 
  int showargs ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 2996
  if (p->module) {
#line 2997
    showargs = 3;
  } else {
#line 2998
    if (p->minargs) {
#line 2998
      tmp = p->minargs;
    } else {
#line 2998
      tmp = -1;
    }
#line 2998
    if (p->maxargs != tmp) {
#line 2999
      showargs = 2;
    } else
#line 3000
    if (p->minargs) {
#line 3001
      showargs = 1;
    } else {
#line 3003
      showargs = 0;
    }
  }
#line 3005
  if (p->flags & 1) {
#line 3005
    tmp___0 = "s";
  } else {
#line 3005
    tmp___0 = "";
  }
  {
#line 3005
  printf((char const   */* __restrict  */)"functions -M%s %s", tmp___0, p->name);
  }
#line 3006
  if (showargs) {
    {
#line 3007
    printf((char const   */* __restrict  */)" %d", p->minargs);
#line 3008
    showargs --;
    }
  }
#line 3010
  if (showargs) {
    {
#line 3011
    printf((char const   */* __restrict  */)" %d", p->maxargs);
#line 3012
    showargs --;
    }
  }
#line 3014
  if (showargs) {
    {
#line 3018
    putchar(' ');
#line 3019
    quotedzputs((char const   *)p->module, stdout);
#line 3020
    showargs --;
    }
  }
  {
#line 3022
  putchar('\n');
  }
#line 3023
  return;
}
}
#line 3026 "/tmp/zsh-5.4.2/Src/builtin.c"
static void add_autoload_function(Shfunc shf , char *funcname ) 
{ 
  char *nam ;
  char *dir ;
  char *tmp ;
  char *tmp___0 ;
  Shfunc shf2 ;
  Funcstack fs ;
  char const   *calling_f ;
  char buf___7[4097] ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  HashNode tmp___5 ;
  char *tmp___6 ;

  {
#line 3030
  if ((int )*funcname == 47) {
#line 3030
    if (*(funcname + 1)) {
      {
#line 3030
      nam = strrchr((char const   *)funcname, '/');
      }
#line 3030
      if (nam) {
#line 3030
        if (*(nam + 1)) {
#line 3030
          if (shf->node.flags & (1 << 9)) {
            {
#line 3034
            nam = strrchr((char const   *)funcname, '/');
            }
#line 3035
            if ((unsigned long )nam == (unsigned long )funcname) {
#line 3036
              dir = (char *)"/";
            } else {
#line 3038
              tmp = nam;
#line 3038
              nam ++;
#line 3038
              *tmp = (char )'\000';
#line 3039
              dir = funcname;
            }
            {
#line 3041
            dircache_set(& shf->filename, (char *)((void *)0));
#line 3042
            dircache_set(& shf->filename, dir);
#line 3043
            shf->node.flags |= 1 << 19;
#line 3044
            shf->node.flags |= 1 << 12;
#line 3045
            tmp___0 = ztrdup((char const   *)nam);
#line 3045
            (*(shfunctab->addnode))(shfunctab, tmp___0, (void *)shf);
            }
          } else {
#line 3030
            goto _L___2;
          }
        } else {
#line 3030
          goto _L___2;
        }
      } else {
#line 3030
        goto _L___2;
      }
    } else {
#line 3030
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 3049
    calling_f = (char const   *)((void *)0);
#line 3053
    fs = funcstack;
    {
#line 3053
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3053
      if (! fs) {
#line 3053
        goto while_break;
      }
#line 3054
      if (fs->tp == 1) {
#line 3054
        if (fs->name) {
#line 3054
          if (! shf->node.nam) {
#line 3055
            calling_f = (char const   *)fs->name;
#line 3056
            goto while_break;
          } else {
            {
#line 3054
            tmp___1 = strcmp((char const   *)fs->name, (char const   *)shf->node.nam);
            }
#line 3054
            if (0 != tmp___1) {
#line 3055
              calling_f = (char const   *)fs->name;
#line 3056
              goto while_break;
            }
          }
        }
      }
#line 3053
      fs = fs->prev;
    }
    while_break: /* CIL Label */ ;
    }
#line 3061
    if (calling_f) {
      {
#line 3063
      tmp___5 = (*(shfunctab->getnode2))(shfunctab, calling_f);
#line 3063
      shf2 = (Shfunc )tmp___5;
      }
#line 3063
      if (shf2) {
#line 3063
        if (shf2->node.flags & (1 << 19)) {
#line 3063
          if (shf2->node.flags & (1 << 12)) {
#line 3063
            if (shf2->filename) {
              {
#line 3067
              tmp___3 = strlen((char const   *)shf2->filename);
#line 3067
              tmp___4 = strlen((char const   *)funcname);
              }
#line 3067
              if ((tmp___3 + tmp___4) + 1UL < 4096UL) {
                {
#line 3069
                sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%s/%s",
                        shf2->filename, funcname);
#line 3072
                tmp___2 = access((char const   *)(buf___7), 4);
                }
#line 3072
                if (! tmp___2) {
                  {
#line 3073
                  dircache_set(& shf->filename, (char *)((void *)0));
#line 3074
                  dircache_set(& shf->filename, shf2->filename);
#line 3075
                  shf->node.flags |= 1 << 19;
#line 3076
                  shf->node.flags |= 1 << 12;
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 3082
    tmp___6 = ztrdup((char const   *)funcname);
#line 3082
    (*(shfunctab->addnode))(shfunctab, tmp___6, (void *)shf);
    }
  }
#line 3084
  return;
}
}
#line 3091 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_functions(char *name , char **argv , Options ops , int func ) 
{ 
  Patprog pprog ;
  Shfunc shf ;
  int i ;
  int returnval ;
  int on ;
  int off ;
  int pflags ;
  int roff ;
  int expand ;
  char *eptr ;
  zlong tmp ;
  MathFunc p ;
  MathFunc q ;
  sigset_t oset ;
  MathFunc next___0 ;
  int tmp___0 ;
  sigset_t oset___0 ;
  int tmp___1 ;
  sigset_t oset___1 ;
  int minargs ;
  int maxargs ;
  char *funcname ;
  char **tmp___2 ;
  char *modname ;
  char *ptr___0 ;
  zlong tmp___3 ;
  zlong tmp___4 ;
  char **tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  sigset_t oset___2 ;
  int tmp___8 ;
  sigset_t oset___3 ;
  Funcstack fs ;
  char *funcname___0 ;
  int ret ;
  void *tmp___9 ;
  char *tmp___10 ;
  HashNode tmp___11 ;
  sigset_t oset___4 ;
  int ret___0 ;
  sigset_t oset___5 ;
  int tmp___12 ;
  int tmp___13 ;
  sigset_t oset___6 ;
  int tmp___14 ;
  int signum ;
  int ok ;
  int tmp___15 ;
  char *base ;
  char *tmp___16 ;
  char *dir ;
  int tmp___17 ;
  HashNode tmp___18 ;
  void *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  HashNode tmp___22 ;
  sigset_t oset___7 ;

  {
#line 3096
  returnval = 0;
#line 3097
  on = 0;
#line 3097
  off = 0;
#line 3097
  pflags = 0;
#line 3097
  expand = 0;
#line 3100
  if ((int )ops->ind[117] & 2) {
#line 3101
    off |= 1 << 9;
  } else
#line 3102
  if ((int )ops->ind[117] & 1) {
#line 3103
    on |= 1 << 9;
  } else
#line 3102
  if ((int )ops->ind[88] != 0) {
#line 3103
    on |= 1 << 9;
  }
#line 3104
  if ((int )ops->ind[85] & 1) {
#line 3105
    on |= (1 << 13) | (1 << 9);
  } else
#line 3106
  if ((int )ops->ind[85] & 2) {
#line 3107
    off |= 1 << 13;
  }
#line 3108
  if ((int )ops->ind[116] & 1) {
#line 3109
    on |= 1 << 11;
  } else
#line 3110
  if ((int )ops->ind[116] & 2) {
#line 3111
    off |= 1 << 11;
  }
#line 3112
  if ((int )ops->ind[84] & 1) {
#line 3113
    on |= 1 << 16;
  } else
#line 3114
  if ((int )ops->ind[84] & 2) {
#line 3115
    off |= 1 << 16;
  }
#line 3116
  if ((int )ops->ind[87] & 1) {
#line 3117
    on |= 1 << 15;
  } else
#line 3118
  if ((int )ops->ind[87] & 2) {
#line 3119
    off |= 1 << 15;
  }
#line 3120
  roff = off;
#line 3121
  if ((int )ops->ind[122] & 1) {
#line 3122
    on |= 1 << 18;
#line 3123
    off |= 1 << 17;
  } else
#line 3124
  if ((int )ops->ind[122] & 2) {
#line 3125
    off |= 1 << 18;
#line 3126
    roff |= 1 << 18;
  }
#line 3128
  if ((int )ops->ind[107] & 1) {
#line 3129
    on |= 1 << 17;
#line 3130
    off |= 1 << 18;
  } else
#line 3131
  if ((int )ops->ind[107] & 2) {
#line 3132
    off |= 1 << 17;
#line 3133
    roff |= 1 << 17;
  }
#line 3135
  if ((int )ops->ind[100] & 1) {
#line 3136
    on |= 1 << 14;
#line 3137
    off |= 1 << 14;
  } else
#line 3138
  if ((int )ops->ind[100] & 2) {
#line 3139
    off |= 1 << 14;
#line 3140
    roff |= 1 << 14;
  }
#line 3143
  if (off & (1 << 9)) {
    {
#line 3146
    zwarnnam((char const   *)name, "invalid option(s)");
    }
#line 3147
    return (1);
  } else
#line 3143
  if ((int )ops->ind[107] != 0) {
#line 3143
    if ((int )ops->ind[122] != 0) {
      {
#line 3146
      zwarnnam((char const   *)name, "invalid option(s)");
      }
#line 3147
      return (1);
    } else {
#line 3143
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3143
  if ((int )ops->ind[120] != 0) {
#line 3143
    if (! ((int )ops->ind[120] > 3)) {
      {
#line 3146
      zwarnnam((char const   *)name, "invalid option(s)");
      }
#line 3147
      return (1);
    } else {
#line 3143
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3143
  if ((int )ops->ind[88] & 1) {
#line 3143
    if ((int )ops->ind[109] != 0) {
      {
#line 3146
      zwarnnam((char const   *)name, "invalid option(s)");
      }
#line 3147
      return (1);
    } else
#line 3143
    if (! scriptname) {
      {
#line 3146
      zwarnnam((char const   *)name, "invalid option(s)");
      }
#line 3147
      return (1);
    }
  }
#line 3150
  if ((int )ops->ind[120] != 0) {
    {
#line 3152
    tmp = zstrtol((char const   *)*(ops->args + (((int )ops->ind[120] >> 2) - 1)),
                  & eptr, 10);
#line 3152
    expand = (int )tmp;
    }
#line 3153
    if (*eptr) {
      {
#line 3154
      zwarnnam((char const   *)name, "number expected after -x");
      }
#line 3155
      return (1);
    }
#line 3157
    if (expand == 0) {
#line 3158
      expand = -1;
    }
  }
#line 3161
  if ((int )ops->ind[102] & 2) {
#line 3162
    pflags |= 1;
  } else
#line 3161
  if (roff) {
#line 3162
    pflags |= 1;
  } else
#line 3161
  if ((int )ops->ind[43] != 0) {
#line 3162
    pflags |= 1;
  }
#line 3164
  if ((int )ops->ind[77] & 1) {
#line 3164
    goto _L___2;
  } else
#line 3164
  if ((int )ops->ind[77] & 2) {
    _L___2: /* CIL Label */ 
#line 3169
    if (on) {
      {
#line 3171
      zwarnnam((char const   *)name, "invalid option(s)");
      }
#line 3172
      return (1);
    } else
#line 3169
    if (off) {
      {
#line 3171
      zwarnnam((char const   *)name, "invalid option(s)");
      }
#line 3172
      return (1);
    } else
#line 3169
    if (pflags) {
      {
#line 3171
      zwarnnam((char const   *)name, "invalid option(s)");
      }
#line 3172
      return (1);
    } else
#line 3169
    if ((int )ops->ind[88] != 0) {
      {
#line 3171
      zwarnnam((char const   *)name, "invalid option(s)");
      }
#line 3172
      return (1);
    } else
#line 3169
    if ((int )ops->ind[117] != 0) {
      {
#line 3171
      zwarnnam((char const   *)name, "invalid option(s)");
      }
#line 3172
      return (1);
    } else
#line 3169
    if ((int )ops->ind[85] != 0) {
      {
#line 3171
      zwarnnam((char const   *)name, "invalid option(s)");
      }
#line 3172
      return (1);
    } else
#line 3169
    if ((int )ops->ind[119] != 0) {
      {
#line 3171
      zwarnnam((char const   *)name, "invalid option(s)");
      }
#line 3172
      return (1);
    }
#line 3174
    if (! *argv) {
#line 3176
      queueing_enabled ++;
#line 3177
      p = mathfuncs;
      {
#line 3177
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3177
        if (! p) {
#line 3177
          goto while_break;
        }
#line 3178
        if (p->flags & 4) {
          {
#line 3179
          listusermathfunc(p);
          }
        }
#line 3177
        p = p->next;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 3180
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3180
        queueing_enabled --;
#line 3180
        if (! queueing_enabled) {
          {
#line 3180
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 3180
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 3180
              if (! (queue_front != queue_rear)) {
#line 3180
                goto while_break___2;
              }
              {
#line 3180
              queue_front = (queue_front + 1) % 128;
#line 3180
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3180
              zhandler(signal_queue[queue_front]);
#line 3180
              signal_setmask(oset);
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 3180
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 3180
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 3181
    if ((int )ops->ind[109] != 0) {
      {
#line 3183
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3183
        if (! *argv) {
#line 3183
          goto while_break___3;
        }
        {
#line 3184
        queueing_enabled ++;
#line 3185
        tokenize(*argv);
#line 3186
        pprog = patcompile(*argv, 64, (char **)0);
        }
#line 3186
        if (pprog) {
#line 3187
          p = mathfuncs;
#line 3187
          q = (MathFunc )((void *)0);
          {
#line 3187
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 3187
            if (! p) {
#line 3187
              goto while_break___4;
            }
            {
#line 3189
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 3190
              next___0 = (MathFunc )((void *)0);
#line 3191
              if (p->flags & 4) {
                {
#line 3191
                tmp___0 = pattry(pprog, p->name);
                }
#line 3191
                if (tmp___0) {
#line 3193
                  if ((int )ops->ind[77] & 2) {
                    {
#line 3194
                    next___0 = p->next;
#line 3195
                    removemathfunc(q, p);
#line 3196
                    p = next___0;
                    }
                  } else {
                    {
#line 3198
                    listusermathfunc(p);
                    }
                  }
                }
              }
#line 3189
              if (! next___0) {
#line 3189
                goto while_break___5;
              }
            }
            while_break___5: /* CIL Label */ ;
            }
#line 3202
            if (p) {
#line 3203
              p = p->next;
            }
#line 3187
            q = p;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
          {
#line 3206
          untokenize(*argv);
#line 3207
          zwarnnam((char const   *)name, "bad pattern : %s", *argv);
#line 3208
          returnval = 1;
          }
        }
        {
#line 3210
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 3210
          queueing_enabled --;
#line 3210
          if (! queueing_enabled) {
            {
#line 3210
            while (1) {
              while_continue___7: /* CIL Label */ ;
              {
#line 3210
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 3210
                if (! (queue_front != queue_rear)) {
#line 3210
                  goto while_break___8;
                }
                {
#line 3210
                queue_front = (queue_front + 1) % 128;
#line 3210
                oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 3210
                zhandler(signal_queue[queue_front]);
#line 3210
                signal_setmask(oset___0);
                }
              }
              while_break___8: /* CIL Label */ ;
              }
#line 3210
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
#line 3210
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 3183
        argv ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 3212
    if ((int )ops->ind[77] & 2) {
      {
#line 3214
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 3214
        if (! *argv) {
#line 3214
          goto while_break___9;
        }
#line 3215
        queueing_enabled ++;
#line 3216
        p = mathfuncs;
#line 3216
        q = (MathFunc )((void *)0);
        {
#line 3216
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 3216
          if (! p) {
#line 3216
            goto while_break___10;
          }
          {
#line 3217
          tmp___1 = strcmp((char const   *)p->name, (char const   *)*argv);
          }
#line 3217
          if (! tmp___1) {
#line 3218
            if (! (p->flags & 4)) {
              {
#line 3219
              zwarnnam((char const   *)name, "+M %s: is a library function", *argv);
#line 3221
              returnval = 1;
              }
#line 3222
              goto while_break___10;
            }
            {
#line 3224
            removemathfunc(q, p);
            }
#line 3225
            goto while_break___10;
          }
#line 3216
          q = p;
#line 3216
          p = p->next;
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 3228
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 3228
          queueing_enabled --;
#line 3228
          if (! queueing_enabled) {
            {
#line 3228
            while (1) {
              while_continue___12: /* CIL Label */ ;
              {
#line 3228
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 3228
                if (! (queue_front != queue_rear)) {
#line 3228
                  goto while_break___13;
                }
                {
#line 3228
                queue_front = (queue_front + 1) % 128;
#line 3228
                oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 3228
                zhandler(signal_queue[queue_front]);
#line 3228
                signal_setmask(oset___1);
                }
              }
              while_break___13: /* CIL Label */ ;
              }
#line 3228
              goto while_break___12;
            }
            while_break___12: /* CIL Label */ ;
            }
          }
#line 3228
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 3214
        argv ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    } else {
#line 3233
      tmp___2 = argv;
#line 3233
      argv ++;
#line 3233
      funcname = *tmp___2;
#line 3234
      modname = (char *)((void *)0);
#line 3237
      if ((int )ops->ind[115] != 0) {
#line 3238
        maxargs = 1;
#line 3238
        minargs = maxargs;
      } else {
#line 3240
        minargs = 0;
#line 3241
        maxargs = -1;
      }
      {
#line 3244
      ptr___0 = itype_end((char const   *)funcname, 1 << 7, 0);
      }
#line 3245
      if ((int )typtab[(unsigned char )*funcname] & 1) {
        {
#line 3246
        zwarnnam((char const   *)name, "-M %s: bad math function name", funcname);
        }
#line 3247
        return (1);
      } else
#line 3245
      if ((unsigned long )funcname == (unsigned long )ptr___0) {
        {
#line 3246
        zwarnnam((char const   *)name, "-M %s: bad math function name", funcname);
        }
#line 3247
        return (1);
      } else
#line 3245
      if (*ptr___0) {
        {
#line 3246
        zwarnnam((char const   *)name, "-M %s: bad math function name", funcname);
        }
#line 3247
        return (1);
      }
#line 3250
      if (*argv) {
        {
#line 3251
        tmp___3 = zstrtol((char const   *)*argv, & ptr___0, 0);
#line 3251
        minargs = (int )tmp___3;
        }
#line 3252
        if (minargs < 0) {
          {
#line 3253
          zwarnnam((char const   *)name, "-M: invalid min number of arguments: %s",
                   *argv);
          }
#line 3255
          return (1);
        } else
#line 3252
        if (*ptr___0) {
          {
#line 3253
          zwarnnam((char const   *)name, "-M: invalid min number of arguments: %s",
                   *argv);
          }
#line 3255
          return (1);
        }
#line 3257
        if ((int )ops->ind[115] != 0) {
#line 3257
          if (minargs != 1) {
            {
#line 3258
            zwarnnam((char const   *)name, "-Ms: must take a single string argument");
            }
#line 3259
            return (1);
          }
        }
#line 3261
        maxargs = minargs;
#line 3262
        argv ++;
      }
#line 3264
      if (*argv) {
        {
#line 3265
        tmp___4 = zstrtol((char const   *)*argv, & ptr___0, 0);
#line 3265
        maxargs = (int )tmp___4;
        }
#line 3266
        if (maxargs < -1) {
          {
#line 3269
          zwarnnam((char const   *)name, "-M: invalid max number of arguments: %s",
                   *argv);
          }
#line 3272
          return (1);
        } else
#line 3266
        if (maxargs != -1) {
#line 3266
          if (maxargs < minargs) {
            {
#line 3269
            zwarnnam((char const   *)name, "-M: invalid max number of arguments: %s",
                     *argv);
            }
#line 3272
            return (1);
          } else {
#line 3266
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 3266
        if (*ptr___0) {
          {
#line 3269
          zwarnnam((char const   *)name, "-M: invalid max number of arguments: %s",
                   *argv);
          }
#line 3272
          return (1);
        }
#line 3274
        if ((int )ops->ind[115] != 0) {
#line 3274
          if (maxargs != 1) {
            {
#line 3275
            zwarnnam((char const   *)name, "-Ms: must take a single string argument");
            }
#line 3276
            return (1);
          }
        }
#line 3278
        argv ++;
      }
#line 3280
      if (*argv) {
#line 3281
        tmp___5 = argv;
#line 3281
        argv ++;
#line 3281
        modname = *tmp___5;
      }
#line 3282
      if (*argv) {
        {
#line 3283
        zwarnnam((char const   *)name, "-M: too many arguments");
        }
#line 3284
        return (1);
      }
      {
#line 3287
      tmp___6 = zshcalloc(sizeof(struct mathfunc ));
#line 3287
      p = (MathFunc )tmp___6;
#line 3288
      p->name = ztrdup((char const   *)funcname);
#line 3289
      p->flags = 4;
      }
#line 3290
      if ((int )ops->ind[115] != 0) {
#line 3291
        p->flags |= 1;
      }
#line 3292
      if (modname) {
        {
#line 3292
        tmp___7 = ztrdup((char const   *)modname);
#line 3292
        p->module = tmp___7;
        }
      } else {
#line 3292
        p->module = (char *)((void *)0);
      }
#line 3293
      p->minargs = minargs;
#line 3294
      p->maxargs = maxargs;
#line 3296
      queueing_enabled ++;
#line 3297
      q = mathfuncs;
      {
#line 3297
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 3297
        if (! q) {
#line 3297
          goto while_break___14;
        }
        {
#line 3298
        tmp___8 = strcmp((char const   *)q->name, (char const   *)funcname);
        }
#line 3298
        if (! tmp___8) {
          {
#line 3299
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 3299
            queueing_enabled --;
#line 3299
            if (! queueing_enabled) {
              {
#line 3299
              while (1) {
                while_continue___16: /* CIL Label */ ;
                {
#line 3299
                while (1) {
                  while_continue___17: /* CIL Label */ ;
#line 3299
                  if (! (queue_front != queue_rear)) {
#line 3299
                    goto while_break___17;
                  }
                  {
#line 3299
                  queue_front = (queue_front + 1) % 128;
#line 3299
                  oset___2 = signal_setmask(signal_mask_queue[queue_front]);
#line 3299
                  zhandler(signal_queue[queue_front]);
#line 3299
                  signal_setmask(oset___2);
                  }
                }
                while_break___17: /* CIL Label */ ;
                }
#line 3299
                goto while_break___16;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
#line 3299
            goto while_break___15;
          }
          while_break___15: /* CIL Label */ ;
          }
          {
#line 3300
          zwarnnam((char const   *)name, "-M %s: function already exists", funcname);
#line 3302
          zsfree(p->name);
#line 3303
          zsfree(p->module);
#line 3304
          zfree((void *)p, (int )sizeof(struct mathfunc ));
          }
#line 3305
          return (1);
        }
#line 3297
        q = q->next;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 3309
      p->next = mathfuncs;
#line 3310
      mathfuncs = p;
      {
#line 3311
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 3311
        queueing_enabled --;
#line 3311
        if (! queueing_enabled) {
          {
#line 3311
          while (1) {
            while_continue___19: /* CIL Label */ ;
            {
#line 3311
            while (1) {
              while_continue___20: /* CIL Label */ ;
#line 3311
              if (! (queue_front != queue_rear)) {
#line 3311
                goto while_break___20;
              }
              {
#line 3311
              queue_front = (queue_front + 1) % 128;
#line 3311
              oset___3 = signal_setmask(signal_mask_queue[queue_front]);
#line 3311
              zhandler(signal_queue[queue_front]);
#line 3311
              signal_setmask(oset___3);
              }
            }
            while_break___20: /* CIL Label */ ;
            }
#line 3311
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
        }
#line 3311
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
    }
#line 3314
    return (returnval);
  }
#line 3317
  if ((int )ops->ind[88] & 1) {
#line 3319
    funcname___0 = (char *)((void *)0);
#line 3321
    if (*argv) {
#line 3321
      if (*(argv + 1)) {
        {
#line 3322
        zwarnnam((char const   *)name, "-X: too many arguments");
        }
#line 3323
        return (1);
      }
    }
#line 3325
    queueing_enabled ++;
#line 3326
    fs = funcstack;
    {
#line 3326
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 3326
      if (! fs) {
#line 3326
        goto while_break___21;
      }
#line 3327
      if (fs->tp == 1) {
        {
#line 3332
        funcname___0 = dupstring((char const   *)fs->name);
        }
#line 3333
        goto while_break___21;
      }
#line 3326
      fs = fs->prev;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 3336
    if (! funcname___0) {
      {
#line 3338
      zerrnam((char const   *)name, "bad autoload");
#line 3339
      ret = 1;
      }
    } else {
      {
#line 3341
      tmp___11 = (*(shfunctab->getnode))(shfunctab, (char const   *)funcname___0);
#line 3341
      shf = (Shfunc )tmp___11;
      }
#line 3341
      if (! shf) {
        {
#line 3345
        tmp___9 = zshcalloc(sizeof(*shf));
#line 3345
        shf = (Shfunc )tmp___9;
#line 3346
        tmp___10 = ztrdup((char const   *)funcname___0);
#line 3346
        (*(shfunctab->addnode))(shfunctab, tmp___10, (void *)shf);
        }
      }
#line 3348
      if (*argv) {
        {
#line 3349
        dircache_set(& shf->filename, (char *)((void *)0));
#line 3350
        dircache_set(& shf->filename, *argv);
#line 3351
        on |= 1 << 19;
        }
      }
      {
#line 3353
      shf->node.flags = on;
#line 3354
      ret = eval_autoload(shf, funcname___0, ops, func);
      }
    }
    {
#line 3356
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 3356
      queueing_enabled --;
#line 3356
      if (! queueing_enabled) {
        {
#line 3356
        while (1) {
          while_continue___23: /* CIL Label */ ;
          {
#line 3356
          while (1) {
            while_continue___24: /* CIL Label */ ;
#line 3356
            if (! (queue_front != queue_rear)) {
#line 3356
              goto while_break___24;
            }
            {
#line 3356
            queue_front = (queue_front + 1) % 128;
#line 3356
            oset___4 = signal_setmask(signal_mask_queue[queue_front]);
#line 3356
            zhandler(signal_queue[queue_front]);
#line 3356
            signal_setmask(oset___4);
            }
          }
          while_break___24: /* CIL Label */ ;
          }
#line 3356
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
#line 3356
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 3357
    return (ret);
  } else
#line 3358
  if (! *argv) {
#line 3362
    ret___0 = 0;
#line 3364
    queueing_enabled ++;
#line 3365
    if ((int )ops->ind[85] != 0) {
#line 3365
      if (! ((int )ops->ind[117] != 0)) {
#line 3366
        on &= ~ (1 << 9);
      }
    }
    {
#line 3367
    scanshfunc(1, on | off, 1, shfunctab->printnode, pflags, expand);
    }
    {
#line 3369
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 3369
      queueing_enabled --;
#line 3369
      if (! queueing_enabled) {
        {
#line 3369
        while (1) {
          while_continue___26: /* CIL Label */ ;
          {
#line 3369
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 3369
            if (! (queue_front != queue_rear)) {
#line 3369
              goto while_break___27;
            }
            {
#line 3369
            queue_front = (queue_front + 1) % 128;
#line 3369
            oset___5 = signal_setmask(signal_mask_queue[queue_front]);
#line 3369
            zhandler(signal_queue[queue_front]);
#line 3369
            signal_setmask(oset___5);
            }
          }
          while_break___27: /* CIL Label */ ;
          }
#line 3369
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
      }
#line 3369
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
#line 3370
    return (ret___0);
  }
#line 3374
  if ((int )ops->ind[109] != 0) {
#line 3375
    on &= ~ (1 << 9);
    {
#line 3376
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 3376
      if (! *argv) {
#line 3376
        goto while_break___28;
      }
      {
#line 3377
      queueing_enabled ++;
#line 3379
      tokenize(*argv);
#line 3380
      pprog = patcompile(*argv, 64, (char **)0);
      }
#line 3380
      if (pprog) {
#line 3382
        if (! (on | off)) {
#line 3382
          if (! ((int )ops->ind[88] != 0)) {
            {
#line 3383
            scanmatchshfunc(pprog, 1, 0, 1, shfunctab->printnode, pflags, expand);
            }
          } else {
#line 3382
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
#line 3387
          i = 0;
          {
#line 3387
          while (1) {
            while_continue___29: /* CIL Label */ ;
#line 3387
            if (! (i < shfunctab->hsize)) {
#line 3387
              goto while_break___29;
            }
#line 3388
            shf = (Shfunc )*(shfunctab->nodes + i);
            {
#line 3388
            while (1) {
              while_continue___30: /* CIL Label */ ;
#line 3388
              if (! shf) {
#line 3388
                goto while_break___30;
              }
              {
#line 3390
              tmp___13 = pattry(pprog, shf->node.nam);
              }
#line 3390
              if (tmp___13) {
#line 3390
                if (! (shf->node.flags & 1)) {
                  {
#line 3392
                  shf->node.flags = (shf->node.flags | (on & ~ (1 << 9))) & ~ off;
#line 3394
                  tmp___12 = check_autoload(shf, shf->node.nam, ops, func);
                  }
#line 3394
                  if (tmp___12) {
#line 3396
                    returnval = 1;
                  }
                }
              }
#line 3388
              shf = (Shfunc )shf->node.next;
            }
            while_break___30: /* CIL Label */ ;
            }
#line 3387
            i ++;
          }
          while_break___29: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 3402
        untokenize(*argv);
#line 3403
        zwarnnam((char const   *)name, "bad pattern : %s", *argv);
#line 3404
        returnval = 1;
        }
      }
      {
#line 3406
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 3406
        queueing_enabled --;
#line 3406
        if (! queueing_enabled) {
          {
#line 3406
          while (1) {
            while_continue___32: /* CIL Label */ ;
            {
#line 3406
            while (1) {
              while_continue___33: /* CIL Label */ ;
#line 3406
              if (! (queue_front != queue_rear)) {
#line 3406
                goto while_break___33;
              }
              {
#line 3406
              queue_front = (queue_front + 1) % 128;
#line 3406
              oset___6 = signal_setmask(signal_mask_queue[queue_front]);
#line 3406
              zhandler(signal_queue[queue_front]);
#line 3406
              signal_setmask(oset___6);
              }
            }
            while_break___33: /* CIL Label */ ;
            }
#line 3406
            goto while_break___32;
          }
          while_break___32: /* CIL Label */ ;
          }
        }
#line 3406
        goto while_break___31;
      }
      while_break___31: /* CIL Label */ ;
      }
#line 3376
      argv ++;
    }
    while_break___28: /* CIL Label */ ;
    }
#line 3408
    return (returnval);
  }
#line 3412
  queueing_enabled ++;
  {
#line 3413
  while (1) {
    while_continue___34: /* CIL Label */ ;
#line 3413
    if (! *argv) {
#line 3413
      goto while_break___34;
    }
#line 3414
    if ((int )ops->ind[119] != 0) {
      {
#line 3415
      returnval = dump_autoload(name, *argv, on, ops, func);
      }
    } else {
      {
#line 3416
      tmp___22 = (*(shfunctab->getnode))(shfunctab, (char const   *)*argv);
#line 3416
      shf = (Shfunc )tmp___22;
      }
#line 3416
      if (shf) {
#line 3418
        if (on | off) {
          {
#line 3420
          shf->node.flags = (shf->node.flags | (on & ~ (1 << 9))) & ~ off;
#line 3421
          tmp___14 = check_autoload(shf, shf->node.nam, ops, func);
          }
#line 3421
          if (tmp___14) {
#line 3422
            returnval = 1;
          }
        } else {
          {
#line 3425
          printshfuncexpand(& shf->node, pflags, expand);
          }
        }
      } else
#line 3426
      if (on & (1 << 9)) {
        {
#line 3427
        signum = -1;
#line 3427
        ok = 1;
#line 3429
        tmp___15 = strncmp((char const   *)*argv, "TRAP", (size_t )4);
        }
#line 3429
        if (! tmp___15) {
          {
#line 3429
          signum = getsignum((char const   *)(*argv + 4));
          }
#line 3429
          if (signum != -1) {
            {
#line 3435
            removetrapnode(signum);
            }
          }
        }
#line 3438
        if ((int )*(*argv) == 47) {
          {
#line 3439
          tmp___16 = strrchr((char const   *)*argv, '/');
#line 3439
          base = tmp___16 + 1;
          }
#line 3440
          if (*base) {
            {
#line 3440
            tmp___18 = (*(shfunctab->getnode))(shfunctab, (char const   *)base);
#line 3440
            shf = (Shfunc )tmp___18;
            }
#line 3440
            if (shf) {
#line 3444
              shf->node.flags = (shf->node.flags | (on & ~ (1 << 9))) & ~ off;
#line 3446
              if (shf->node.flags & (1 << 9)) {
#line 3448
                if ((unsigned long )base == (unsigned long )(*argv + 1)) {
#line 3449
                  dir = (char *)"/";
                } else {
#line 3451
                  dir = *argv;
#line 3452
                  *(base + -1) = (char )'\000';
                }
                {
#line 3454
                dircache_set(& shf->filename, (char *)((void *)0));
#line 3455
                dircache_set(& shf->filename, dir);
                }
              }
              {
#line 3457
              tmp___17 = check_autoload(shf, shf->node.nam, ops, func);
              }
#line 3457
              if (tmp___17) {
#line 3458
                returnval = 1;
              }
#line 3459
              goto __Cont;
            }
          }
        }
        {
#line 3465
        tmp___19 = zshcalloc(sizeof(*shf));
#line 3465
        shf = (Shfunc )tmp___19;
#line 3466
        shf->node.flags = on;
#line 3467
        shf->funcdef = mkautofn(shf);
#line 3468
        shfunc_set_sticky(shf);
#line 3469
        add_autoload_function(shf, *argv);
        }
#line 3471
        if (signum != -1) {
          {
#line 3472
          tmp___20 = settrap(signum, (Eprog )((void *)0), 1 << 2);
          }
#line 3472
          if (tmp___20) {
            {
#line 3473
            (*(shfunctab->removenode))(shfunctab, (char const   *)*argv);
#line 3474
            (*(shfunctab->freenode))(& shf->node);
#line 3475
            returnval = 1;
#line 3476
            ok = 0;
            }
          }
        }
#line 3480
        if (ok) {
          {
#line 3480
          tmp___21 = check_autoload(shf, shf->node.nam, ops, func);
          }
#line 3480
          if (tmp___21) {
#line 3481
            returnval = 1;
          }
        }
      } else {
#line 3483
        returnval = 1;
      }
    }
    __Cont: /* CIL Label */ 
#line 3413
    argv ++;
  }
  while_break___34: /* CIL Label */ ;
  }
  {
#line 3485
  while (1) {
    while_continue___35: /* CIL Label */ ;
#line 3485
    queueing_enabled --;
#line 3485
    if (! queueing_enabled) {
      {
#line 3485
      while (1) {
        while_continue___36: /* CIL Label */ ;
        {
#line 3485
        while (1) {
          while_continue___37: /* CIL Label */ ;
#line 3485
          if (! (queue_front != queue_rear)) {
#line 3485
            goto while_break___37;
          }
          {
#line 3485
          queue_front = (queue_front + 1) % 128;
#line 3485
          oset___7 = signal_setmask(signal_mask_queue[queue_front]);
#line 3485
          zhandler(signal_queue[queue_front]);
#line 3485
          signal_setmask(oset___7);
          }
        }
        while_break___37: /* CIL Label */ ;
        }
#line 3485
        goto while_break___36;
      }
      while_break___36: /* CIL Label */ ;
      }
    }
#line 3485
    goto while_break___35;
  }
  while_break___35: /* CIL Label */ ;
  }
#line 3486
  return (returnval);
}
}
#line 3490 "/tmp/zsh-5.4.2/Src/builtin.c"
Eprog mkautofn(Shfunc shf ) 
{ 
  Eprog p ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 3495
  tmp = zalloc(sizeof(*p));
#line 3495
  p = (Eprog )tmp;
#line 3496
  p->len = (int )(5UL * sizeof(wordcode ));
#line 3497
  tmp___0 = zalloc((size_t )p->len);
#line 3497
  p->prog = (Wordcode )tmp___0;
#line 3498
  p->strs = (char *)((void *)0);
#line 3499
  p->shf = shf;
#line 3500
  p->npats = 0;
#line 3501
  p->nref = 1;
#line 3502
  p->pats = (Patprog *)p->prog;
#line 3503
  p->flags = 1;
#line 3504
  p->dump = (FuncDump )((void *)0);
#line 3506
  *(p->prog + 0) = 1U | ((wordcode )((1 << 1) | (1 << 4)) << 5);
#line 3507
  *(p->prog + 1) = 2U | ((wordcode )(3 << 5) << 5);
#line 3508
  *(p->prog + 2) = 3U;
#line 3509
  *(p->prog + 3) = 20U;
#line 3510
  *(p->prog + 4) = 0U;
  }
#line 3512
  return (p);
}
}
#line 3518 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_unset(char *name , char **argv , Options ops , int func ) 
{ 
  Param pm ;
  Param next___0 ;
  Patprog pprog ;
  char *s ;
  int match ;
  int returnval ;
  int i ;
  int tmp ;
  int tmp___0 ;
  sigset_t oset ;
  char **tmp___1 ;
  char *ss ;
  char *tmp___2 ;
  char *subscript ;
  char *sse ;
  int tmp___3 ;
  HashNode tmp___4 ;
  HashNode tmp___5 ;
  HashNode tmp___6 ;
  HashTable tht ;
  struct value vbuf ;
  char *tmp___7 ;
  int start ;
  char *arr[2] ;
  char **tmp___8 ;
  char tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  sigset_t oset___0 ;

  {
#line 3524
  match = 0;
#line 3524
  returnval = 0;
#line 3528
  if ((int )ops->ind[102] != 0) {
    {
#line 3529
    tmp = bin_unhash(name, argv, ops, func);
    }
#line 3529
    return (tmp);
  }
#line 3532
  if ((int )ops->ind[109] != 0) {
    {
#line 3533
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3533
      tmp___1 = argv;
#line 3533
      argv ++;
#line 3533
      s = *tmp___1;
#line 3533
      if (! s) {
#line 3533
        goto while_break;
      }
      {
#line 3534
      queueing_enabled ++;
#line 3536
      tokenize(s);
#line 3537
      pprog = patcompile(s, 64, (char **)((void *)0));
      }
#line 3537
      if (pprog) {
#line 3539
        i = 0;
        {
#line 3539
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3539
          if (! (i < paramtab->hsize)) {
#line 3539
            goto while_break___0;
          }
#line 3540
          pm = (Param )*(paramtab->nodes + i);
          {
#line 3540
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3540
            if (! pm) {
#line 3540
              goto while_break___1;
            }
#line 3542
            next___0 = (Param )pm->node.next;
#line 3543
            if (! (pm->node.flags & (1 << 24))) {
#line 3543
              goto _L;
            } else
#line 3543
            if (! opts[154]) {
              _L: /* CIL Label */ 
              {
#line 3543
              tmp___0 = pattry(pprog, pm->node.nam);
              }
#line 3543
              if (tmp___0) {
                {
#line 3546
                unsetparam_pm(pm, 0, 1);
#line 3547
                match ++;
                }
              }
            }
#line 3540
            pm = next___0;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 3539
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 3552
        untokenize(s);
#line 3553
        zwarnnam((char const   *)name, "bad pattern : %s", s);
#line 3554
        returnval = 1;
        }
      }
      {
#line 3556
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3556
        queueing_enabled --;
#line 3556
        if (! queueing_enabled) {
          {
#line 3556
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 3556
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 3556
              if (! (queue_front != queue_rear)) {
#line 3556
                goto while_break___4;
              }
              {
#line 3556
              queue_front = (queue_front + 1) % 128;
#line 3556
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3556
              zhandler(signal_queue[queue_front]);
#line 3556
              signal_setmask(oset);
              }
            }
            while_break___4: /* CIL Label */ ;
            }
#line 3556
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 3556
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3559
    if (! match) {
#line 3560
      returnval = 1;
    }
#line 3561
    return (returnval);
  }
#line 3565
  queueing_enabled ++;
  {
#line 3566
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 3566
    tmp___12 = argv;
#line 3566
    argv ++;
#line 3566
    s = *tmp___12;
#line 3566
    if (! s) {
#line 3566
      goto while_break___5;
    }
    {
#line 3567
    tmp___2 = strchr((char const   *)s, '[');
#line 3567
    ss = tmp___2;
#line 3567
    subscript = (char *)0;
    }
#line 3568
    if (ss) {
      {
#line 3570
      *ss = (char)0;
#line 3571
      sse = parse_subscript(ss + 1, 1, ']');
      }
#line 3571
      if (sse) {
        {
#line 3572
        *sse = (char)0;
#line 3573
        subscript = dupstring((char const   *)(ss + 1));
#line 3574
        *sse = (char )']';
#line 3575
        remnulargs(subscript);
#line 3576
        untokenize(subscript);
        }
      }
    }
#line 3579
    if (ss) {
#line 3579
      if (! subscript) {
#line 3579
        goto _L___0;
      } else {
#line 3579
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 3579
      tmp___3 = isident(s);
      }
#line 3579
      if (! tmp___3) {
        _L___0: /* CIL Label */ 
#line 3580
        if (ss) {
#line 3581
          *ss = (char )'[';
        }
        {
#line 3582
        zerrnam((char const   *)name, "%s: invalid parameter name", s);
#line 3583
        returnval = 1;
        }
#line 3584
        goto while_continue___5;
      }
    }
#line 3586
    if ((unsigned long )paramtab == (unsigned long )realparamtab) {
      {
#line 3586
      tmp___4 = (*(paramtab->getnode2))(paramtab, (char const   *)s);
#line 3586
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 3586
      tmp___5 = (*(paramtab->getnode))(paramtab, (char const   *)s);
#line 3586
      tmp___6 = tmp___5;
      }
    }
#line 3586
    pm = (Param )tmp___6;
#line 3594
    if (! pm) {
#line 3595
      goto while_continue___5;
    } else
#line 3596
    if (pm->node.flags & (1 << 24)) {
#line 3596
      if (opts[154]) {
        {
#line 3597
        zerrnam((char const   *)name, "%s: restricted", pm->node.nam);
#line 3598
        returnval = 1;
        }
      } else {
#line 3596
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 3599
    if (ss) {
#line 3600
      if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1 << 4) {
        {
#line 3601
        tht = paramtab;
#line 3602
        paramtab = (*((pm->gsu.h)->getfn))(pm);
        }
#line 3602
        if (paramtab) {
          {
#line 3603
          unsetparam(subscript);
          }
        }
#line 3604
        paramtab = tht;
      } else
#line 3605
      if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
#line 3605
        goto _L___2;
      } else
#line 3605
      if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
        _L___2: /* CIL Label */ 
#line 3608
        if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 3608
          vbuf.isarr = 1 << 9;
        } else {
#line 3608
          vbuf.isarr = 0;
        }
        {
#line 3610
        vbuf.pm = pm;
#line 3611
        vbuf.flags = 0;
#line 3612
        vbuf.start = 0;
#line 3613
        vbuf.end = -1;
#line 3614
        vbuf.arr = (char **)0;
#line 3615
        *ss = (char )'[';
#line 3616
        tmp___10 = getindex(& ss, & vbuf, 1 << 6);
        }
#line 3616
        if (tmp___10 == 0) {
#line 3616
          if (vbuf.pm) {
#line 3616
            if (! ((vbuf.pm)->node.flags & (1 << 25))) {
#line 3618
              if ((pm->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 0) {
                {
#line 3619
                tmp___7 = ztrdup("");
#line 3619
                setstrvalue(& vbuf, tmp___7);
                }
              } else {
                {
#line 3622
                start = vbuf.start - ! (! (vbuf.flags & 1));
#line 3623
                tmp___9 = arrlen_gt((vbuf.pm)->u.arr, (unsigned int )start);
                }
#line 3623
                if (tmp___9) {
                  {
#line 3625
                  arr[0] = (char *)"";
#line 3626
                  arr[1] = (char *)0;
#line 3627
                  tmp___8 = zarrdup(arr);
#line 3627
                  setarrvalue(& vbuf, tmp___8);
                  }
                }
              }
            }
          }
        }
#line 3631
        returnval = errflag;
#line 3632
        errflag &= -2;
      } else {
        {
#line 3634
        zerrnam((char const   *)name, "%s: invalid element for unset", s);
#line 3635
        returnval = 1;
        }
      }
    } else {
      {
#line 3638
      tmp___11 = unsetparam_pm(pm, 0, 1);
      }
#line 3638
      if (tmp___11) {
#line 3639
        returnval = 1;
      }
    }
#line 3641
    if (ss) {
#line 3642
      *ss = (char )'[';
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 3644
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 3644
    queueing_enabled --;
#line 3644
    if (! queueing_enabled) {
      {
#line 3644
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 3644
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 3644
          if (! (queue_front != queue_rear)) {
#line 3644
            goto while_break___8;
          }
          {
#line 3644
          queue_front = (queue_front + 1) % 128;
#line 3644
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 3644
          zhandler(signal_queue[queue_front]);
#line 3644
          signal_setmask(oset___0);
          }
        }
        while_break___8: /* CIL Label */ ;
        }
#line 3644
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 3644
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 3645
  return (returnval);
}
}
#line 3650 "/tmp/zsh-5.4.2/Src/builtin.c"
static LinkList matchednodes  ;
#line 3652 "/tmp/zsh-5.4.2/Src/builtin.c"
static void fetchcmdnamnode(HashNode hn , int printflags  __attribute__((__unused__)) ) 
{ 
  Cmdnam cn ;

  {
  {
#line 3655
  cn = (Cmdnam )hn;
#line 3656
  insertlinknode(matchednodes, matchednodes->list.last, (void *)cn->node.nam);
  }
#line 3657
  return;
}
}
#line 3660 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_whence(char *nam , char **argv , Options ops , int func ) 
{ 
  HashNode hn ;
  Patprog pprog ;
  int returnval ;
  int printflags ;
  int aliasflags ;
  int csh ;
  int all ;
  int v ;
  int wd ;
  int informed ;
  int expand ;
  char *cnam ;
  char **allmatched ;
  char *eptr ;
  zlong tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void (*tmp___4)(HashNode hn , int printflags  __attribute__((__unused__)) ) ;
  int tmp___5 ;
  sigset_t oset ;
  sigset_t oset___0 ;
  int tmp___6 ;
  char *suf ;
  char **pp ;
  char *buf___7 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  sigset_t oset___1 ;
  int tmp___11 ;

  {
#line 3665
  returnval = 0;
#line 3666
  printflags = 0;
#line 3669
  informed = 0;
#line 3670
  expand = 0;
#line 3671
  allmatched = (char **)0;
#line 3674
  csh = (int )ops->ind[99] != 0;
#line 3675
  v = (int )ops->ind[118] != 0;
#line 3676
  all = (int )ops->ind[97] != 0;
#line 3677
  wd = (int )ops->ind[119] != 0;
#line 3679
  if ((int )ops->ind[120] != 0) {
    {
#line 3681
    tmp = zstrtol((char const   *)*(ops->args + (((int )ops->ind[120] >> 2) - 1)),
                  & eptr, 10);
#line 3681
    expand = (int )tmp;
    }
#line 3682
    if (*eptr) {
      {
#line 3683
      zwarnnam((char const   *)nam, "number expected after -x");
      }
#line 3684
      return (1);
    }
#line 3686
    if (expand == 0) {
#line 3687
      expand = -1;
    }
  }
#line 3690
  if ((int )ops->ind[119] != 0) {
#line 3691
    printflags |= 1 << 10;
  } else
#line 3692
  if ((int )ops->ind[99] != 0) {
#line 3693
    printflags |= 1 << 6;
  } else
#line 3694
  if ((int )ops->ind[118] != 0) {
#line 3695
    printflags |= 1 << 7;
  } else {
#line 3697
    printflags |= 1 << 8;
  }
#line 3698
  if ((int )ops->ind[102] != 0) {
#line 3699
    printflags |= 1 << 9;
  }
#line 3701
  if (func == 27) {
#line 3702
    if ((int )ops->ind[86] != 0) {
#line 3703
      aliasflags = 1 << 7;
#line 3703
      printflags = aliasflags;
#line 3704
      v = 1;
    } else {
#line 3706
      aliasflags = 1 << 2;
#line 3707
      printflags = 1 << 8;
#line 3708
      v = 0;
    }
  } else {
#line 3711
    aliasflags = printflags;
  }
#line 3714
  if ((int )ops->ind[109] != 0) {
    {
#line 3715
    (*(cmdnamtab->filltable))(cmdnamtab);
    }
#line 3716
    if (all) {
      {
#line 3717
      pushheap();
#line 3718
      matchednodes = newlinklist();
      }
    }
#line 3720
    queueing_enabled ++;
    {
#line 3721
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3721
      if (! *argv) {
#line 3721
        goto while_break;
      }
      {
#line 3723
      tokenize(*argv);
#line 3724
      pprog = patcompile(*argv, 64, (char **)((void *)0));
      }
#line 3724
      if (! pprog) {
        {
#line 3725
        untokenize(*argv);
#line 3726
        zwarnnam((char const   *)nam, "bad pattern : %s", *argv);
#line 3727
        returnval = 1;
        }
#line 3728
        goto __Cont;
      }
#line 3730
      if (! ((int )ops->ind[112] != 0)) {
        {
#line 3735
        tmp___0 = scanmatchtable(aliastab, pprog, 1, 0, 1, aliastab->printnode, printflags);
#line 3735
        informed += tmp___0;
#line 3740
        tmp___1 = scanmatchtable(reswdtab, pprog, 1, 0, 1, reswdtab->printnode, printflags);
#line 3740
        informed += tmp___1;
#line 3745
        tmp___2 = scanmatchshfunc(pprog, 1, 0, 1, shfunctab->printnode, printflags,
                                  expand);
#line 3745
        informed += tmp___2;
#line 3750
        tmp___3 = scanmatchtable(builtintab, pprog, 1, 0, 1, builtintab->printnode,
                                 printflags);
#line 3750
        informed += tmp___3;
        }
      }
#line 3756
      if (all) {
#line 3756
        tmp___4 = & fetchcmdnamnode;
      } else {
#line 3756
        tmp___4 = cmdnamtab->printnode;
      }
      {
#line 3756
      tmp___5 = scanmatchtable(cmdnamtab, pprog, 1, 0, 0, tmp___4, printflags);
#line 3756
      informed += tmp___5;
      }
      {
#line 3760
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 3760
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3760
          if (! (queue_front != queue_rear)) {
#line 3760
            goto while_break___1;
          }
          {
#line 3760
          queue_front = (queue_front + 1) % 128;
#line 3760
          oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3760
          zhandler(signal_queue[queue_front]);
#line 3760
          signal_setmask(oset);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3760
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 3721
      argv ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3762
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3762
      queueing_enabled --;
#line 3762
      if (! queueing_enabled) {
        {
#line 3762
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 3762
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 3762
            if (! (queue_front != queue_rear)) {
#line 3762
              goto while_break___4;
            }
            {
#line 3762
            queue_front = (queue_front + 1) % 128;
#line 3762
            oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 3762
            zhandler(signal_queue[queue_front]);
#line 3762
            signal_setmask(oset___0);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 3762
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 3762
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3763
    if (all) {
      {
#line 3764
      argv = zlinklist2array(matchednodes);
#line 3764
      allmatched = argv;
#line 3765
      matchednodes = (LinkList )((void *)0);
#line 3766
      popheap();
      }
    } else {
#line 3768
      if (returnval) {
#line 3768
        tmp___6 = 1;
      } else
#line 3768
      if (! informed) {
#line 3768
        tmp___6 = 1;
      } else {
#line 3768
        tmp___6 = 0;
      }
#line 3768
      return (tmp___6);
    }
  }
#line 3772
  queueing_enabled ++;
  {
#line 3773
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 3773
    if (! *argv) {
#line 3773
      goto while_break___5;
    }
#line 3774
    if (! ((int )ops->ind[112] != 0)) {
#line 3774
      if (! allmatched) {
        {
#line 3778
        hn = (*(aliastab->getnode))(aliastab, (char const   *)*argv);
        }
#line 3778
        if (hn) {
          {
#line 3779
          (*(aliastab->printnode))(hn, aliasflags);
#line 3780
          informed = 1;
          }
#line 3781
          if (! all) {
#line 3782
            goto __Cont___0;
          }
        }
        {
#line 3785
        suf = strrchr((char const   *)*argv, '.');
        }
#line 3785
        if (suf) {
#line 3785
          if (*(suf + 1)) {
#line 3785
            if ((unsigned long )suf > (unsigned long )*argv) {
#line 3785
              if ((int )*(suf + -1) != -125) {
                {
#line 3785
                hn = (*(sufaliastab->getnode))(sufaliastab, (char const   *)(suf + 1));
                }
#line 3785
                if (hn) {
                  {
#line 3788
                  (*(sufaliastab->printnode))(hn, printflags);
#line 3789
                  informed = 1;
                  }
#line 3790
                  if (! all) {
#line 3791
                    goto __Cont___0;
                  }
                }
              }
            }
          }
        }
        {
#line 3794
        hn = (*(reswdtab->getnode))(reswdtab, (char const   *)*argv);
        }
#line 3794
        if (hn) {
          {
#line 3795
          (*(reswdtab->printnode))(hn, printflags);
#line 3796
          informed = 1;
          }
#line 3797
          if (! all) {
#line 3798
            goto __Cont___0;
          }
        }
        {
#line 3801
        hn = (*(shfunctab->getnode))(shfunctab, (char const   *)*argv);
        }
#line 3801
        if (hn) {
          {
#line 3802
          printshfuncexpand(hn, printflags, expand);
#line 3803
          informed = 1;
          }
#line 3804
          if (! all) {
#line 3805
            goto __Cont___0;
          }
        }
        {
#line 3808
        hn = (*(builtintab->getnode))(builtintab, (char const   *)*argv);
        }
#line 3808
        if (hn) {
          {
#line 3809
          (*(builtintab->printnode))(hn, printflags);
#line 3810
          informed = 1;
          }
#line 3811
          if (! all) {
#line 3812
            goto __Cont___0;
          }
        }
        {
#line 3816
        hn = (*(cmdnamtab->getnode))(cmdnamtab, (char const   *)*argv);
        }
#line 3816
        if (hn) {
#line 3816
          if (hn->flags & (1 << 1)) {
            {
#line 3817
            (*(cmdnamtab->printnode))(hn, printflags);
#line 3818
            informed = 1;
            }
#line 3819
            if (! all) {
#line 3820
              goto __Cont___0;
            }
          }
        }
      }
    }
#line 3826
    if (all) {
#line 3826
      if ((int )*(*argv) != 47) {
        {
#line 3829
        pushheap();
#line 3830
        pp = path;
        }
        {
#line 3830
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 3830
          if (! *pp) {
#line 3830
            goto while_break___6;
          }
#line 3831
          if (*(*pp)) {
            {
#line 3832
            buf___7 = zhtricat((char const   *)*pp, "/", (char const   *)*argv);
            }
          } else {
            {
#line 3833
            buf___7 = dupstring((char const   *)*argv);
            }
          }
          {
#line 3835
          tmp___7 = iscom(buf___7);
          }
#line 3835
          if (tmp___7) {
#line 3836
            if (wd) {
              {
#line 3837
              printf((char const   */* __restrict  */)"%s: command\n", *argv);
              }
            } else {
#line 3839
              if (v) {
#line 3839
                if (! csh) {
                  {
#line 3840
                  zputs((char const   *)*argv, stdout);
#line 3840
                  fputs((char const   */* __restrict  */)" is ", (FILE */* __restrict  */)stdout);
#line 3841
                  quotedzputs((char const   *)buf___7, stdout);
                  }
                } else {
                  {
#line 3843
                  zputs((char const   *)buf___7, stdout);
                  }
                }
              } else {
                {
#line 3843
                zputs((char const   *)buf___7, stdout);
                }
              }
#line 3844
              if ((int )ops->ind[115] != 0) {
                {
#line 3845
                print_if_link(buf___7, (int )ops->ind[83] != 0);
                }
              } else
#line 3844
              if ((int )ops->ind[83] != 0) {
                {
#line 3845
                print_if_link(buf___7, (int )ops->ind[83] != 0);
                }
              }
              {
#line 3846
              fputc('\n', stdout);
              }
            }
#line 3848
            informed = 1;
          }
#line 3830
          pp ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 3851
        if (! informed) {
#line 3851
          if (wd) {
#line 3851
            goto _L;
          } else
#line 3851
          if (v) {
#line 3851
            goto _L;
          } else
#line 3851
          if (csh) {
            _L: /* CIL Label */ 
            {
#line 3853
            zputs((char const   *)*argv, stdout);
            }
#line 3854
            if (wd) {
#line 3854
              tmp___8 = ": none";
            } else {
#line 3854
              tmp___8 = " not found";
            }
            {
#line 3854
            puts(tmp___8);
#line 3855
            returnval = 1;
            }
          }
        }
        {
#line 3857
        popheap();
        }
      } else {
#line 3826
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 3858
    if (func == 27) {
#line 3858
      if ((int )ops->ind[112] != 0) {
        {
#line 3858
        hn = (*(builtintab->getnode))(builtintab, (char const   *)*argv);
        }
#line 3858
        if (hn) {
          {
#line 3864
          (*(builtintab->printnode))(hn, printflags);
#line 3865
          informed = 1;
          }
        } else {
#line 3858
          goto _L___2;
        }
      } else {
#line 3858
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 3866
      if (func == 27) {
#line 3866
        if ((int )ops->ind[112] != 0) {
#line 3866
          tmp___10 = 1;
        } else {
#line 3866
          tmp___10 = 0;
        }
      } else {
#line 3866
        tmp___10 = 0;
      }
      {
#line 3866
      cnam = findcmd(*argv, 1, tmp___10);
      }
#line 3866
      if (cnam) {
#line 3870
        if (wd) {
          {
#line 3871
          printf((char const   */* __restrict  */)"%s: command\n", *argv);
          }
        } else {
#line 3873
          if (v) {
#line 3873
            if (! csh) {
              {
#line 3874
              zputs((char const   *)*argv, stdout);
#line 3874
              fputs((char const   */* __restrict  */)" is ", (FILE */* __restrict  */)stdout);
#line 3875
              quotedzputs((char const   *)cnam, stdout);
              }
            } else {
              {
#line 3877
              zputs((char const   *)cnam, stdout);
              }
            }
          } else {
            {
#line 3877
            zputs((char const   *)cnam, stdout);
            }
          }
#line 3878
          if ((int )ops->ind[115] != 0) {
            {
#line 3879
            print_if_link(cnam, (int )ops->ind[83] != 0);
            }
          } else
#line 3878
          if ((int )ops->ind[83] != 0) {
            {
#line 3879
            print_if_link(cnam, (int )ops->ind[83] != 0);
            }
          }
          {
#line 3880
          fputc('\n', stdout);
          }
        }
#line 3882
        informed = 1;
      } else {
#line 3885
        if (v) {
#line 3885
          goto _L___0;
        } else
#line 3885
        if (csh) {
#line 3885
          goto _L___0;
        } else
#line 3885
        if (wd) {
          _L___0: /* CIL Label */ 
          {
#line 3886
          zputs((char const   *)*argv, stdout);
          }
#line 3886
          if (wd) {
#line 3886
            tmp___9 = ": none";
          } else {
#line 3886
            tmp___9 = " not found";
          }
          {
#line 3886
          puts(tmp___9);
          }
        }
#line 3887
        returnval = 1;
      }
    }
    __Cont___0: /* CIL Label */ 
#line 3773
    argv ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 3890
  if (allmatched) {
    {
#line 3891
    freearray(allmatched);
    }
  }
  {
#line 3893
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 3893
    queueing_enabled --;
#line 3893
    if (! queueing_enabled) {
      {
#line 3893
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 3893
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 3893
          if (! (queue_front != queue_rear)) {
#line 3893
            goto while_break___9;
          }
          {
#line 3893
          queue_front = (queue_front + 1) % 128;
#line 3893
          oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 3893
          zhandler(signal_queue[queue_front]);
#line 3893
          signal_setmask(oset___1);
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 3893
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 3893
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 3894
  if (returnval) {
#line 3894
    tmp___11 = 1;
  } else
#line 3894
  if (! informed) {
#line 3894
    tmp___11 = 1;
  } else {
#line 3894
    tmp___11 = 0;
  }
#line 3894
  return (tmp___11);
}
}
#line 3918 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_hash(char *name , char **argv , Options ops , int func  __attribute__((__unused__)) ) 
{ 
  HashTable ht ;
  Patprog pprog ;
  Asgment asg___0 ;
  int returnval ;
  int printflags ;
  sigset_t oset ;
  void *hn ;
  Nameddir nd ;
  char *tmp ;
  Cmdnam cn ;
  char *tmp___0 ;
  char *tmp___1 ;
  Cmdnam tmp___2 ;
  HashNode tmp___3 ;
  HashNode tmp___4 ;
  sigset_t oset___0 ;

  {
#line 3924
  returnval = 0;
#line 3925
  printflags = 0;
#line 3927
  if ((int )ops->ind[100] != 0) {
#line 3928
    ht = nameddirtab;
  } else {
#line 3930
    ht = cmdnamtab;
  }
#line 3932
  if ((int )ops->ind[114] != 0) {
#line 3932
    goto _L;
  } else
#line 3932
  if ((int )ops->ind[102] != 0) {
    _L: /* CIL Label */ 
#line 3934
    if (*argv) {
      {
#line 3935
      zwarnnam("hash", "too many arguments");
      }
#line 3936
      return (1);
    }
#line 3940
    if ((int )ops->ind[114] != 0) {
      {
#line 3941
      (*(ht->emptytable))(ht);
      }
    }
#line 3944
    if ((int )ops->ind[102] != 0) {
      {
#line 3945
      (*(ht->filltable))(ht);
      }
    }
#line 3947
    return (0);
  }
#line 3950
  if ((int )ops->ind[76] != 0) {
#line 3950
    printflags |= 1 << 2;
  }
#line 3953
  if (! *argv) {
    {
#line 3954
    queueing_enabled ++;
#line 3955
    scanhashtable(ht, 1, 0, 0, ht->printnode, printflags);
    }
    {
#line 3956
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3956
      queueing_enabled --;
#line 3956
      if (! queueing_enabled) {
        {
#line 3956
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 3956
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3956
            if (! (queue_front != queue_rear)) {
#line 3956
              goto while_break___1;
            }
            {
#line 3956
            queue_front = (queue_front + 1) % 128;
#line 3956
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 3956
            zhandler(signal_queue[queue_front]);
#line 3956
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 3956
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 3956
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 3957
    return (0);
  }
#line 3960
  queueing_enabled ++;
  {
#line 3961
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3961
    if (! *argv) {
#line 3961
      goto while_break___2;
    }
#line 3963
    if ((int )ops->ind[109] != 0) {
      {
#line 3965
      tokenize(*argv);
#line 3966
      pprog = patcompile(*argv, 64, (char **)((void *)0));
      }
#line 3966
      if (pprog) {
        {
#line 3968
        scanmatchtable(ht, pprog, 1, 0, 0, ht->printnode, printflags);
        }
      } else {
        {
#line 3970
        untokenize(*argv);
#line 3971
        zwarnnam((char const   *)name, "bad pattern : %s", *argv);
#line 3972
        returnval = 1;
        }
      }
#line 3974
      argv ++;
#line 3975
      goto while_continue___2;
    }
    {
#line 3977
    asg___0 = getasg(& argv, (LinkList )((void *)0));
    }
#line 3977
    if (asg___0) {
#line 3981
      if (asg___0->is_array) {
#line 3981
        goto _L___0;
      } else
#line 3981
      if ((unsigned long )asg___0->value.scalar != (unsigned long )((char *)0)) {
        _L___0: /* CIL Label */ 
#line 3982
        if (opts[154]) {
          {
#line 3983
          zwarnnam((char const   *)name, "restricted: %s", asg___0->value.scalar);
#line 3984
          returnval = 1;
          }
        } else {
#line 3988
          if ((int )ops->ind[100] != 0) {
            {
#line 3990
            tmp = itype_end((char const   *)asg___0->name, 1 << 8, 0);
            }
#line 3990
            if (*tmp) {
              {
#line 3991
              zwarnnam((char const   *)name, "invalid character in directory name: %s",
                       asg___0->name);
#line 3994
              returnval = 1;
              }
#line 3995
              goto while_continue___2;
            } else {
              {
#line 3997
              hn = zshcalloc(sizeof(*nd));
#line 3997
              nd = (Nameddir )hn;
#line 3998
              nd->node.flags = 0;
#line 3999
              nd->dir = ztrdup((char const   *)asg___0->value.scalar);
              }
            }
          } else {
            {
#line 4002
            hn = zshcalloc(sizeof(*cn));
#line 4002
            cn = (Cmdnam )hn;
#line 4003
            cn->node.flags = 1 << 1;
#line 4004
            cn->u.cmd = ztrdup((char const   *)asg___0->value.scalar);
            }
          }
          {
#line 4006
          tmp___0 = ztrdup((char const   *)asg___0->name);
#line 4006
          (*(ht->addnode))(ht, tmp___0, hn);
          }
#line 4007
          if ((int )ops->ind[118] != 0) {
            {
#line 4008
            (*(ht->printnode))((HashNode )hn, 0);
            }
          }
        }
      } else {
        {
#line 4010
        tmp___4 = (*(ht->getnode2))(ht, (char const   *)asg___0->name);
#line 4010
        hn = (void *)tmp___4;
        }
#line 4010
        if (hn) {
#line 4026
          if ((int )ops->ind[118] != 0) {
            {
#line 4027
            (*(ht->printnode))((HashNode )hn, 0);
            }
          }
        } else {
#line 4013
          if ((int )ops->ind[100] != 0) {
            {
#line 4014
            tmp___1 = getnameddir(asg___0->name);
            }
#line 4014
            if (! tmp___1) {
              {
#line 4015
              zwarnnam((char const   *)name, "no such directory name: %s", asg___0->name);
#line 4016
              returnval = 1;
              }
            }
          } else {
            {
#line 4019
            tmp___2 = hashcmd(asg___0->name, path);
            }
#line 4019
            if (! tmp___2) {
              {
#line 4020
              zwarnnam((char const   *)name, "no such command: %s", asg___0->name);
#line 4021
              returnval = 1;
              }
            }
          }
#line 4024
          if ((int )ops->ind[118] != 0) {
            {
#line 4024
            tmp___3 = (*(ht->getnode2))(ht, (char const   *)asg___0->name);
#line 4024
            hn = (void *)tmp___3;
            }
#line 4024
            if (hn) {
              {
#line 4025
              (*(ht->printnode))((HashNode )hn, 0);
              }
            }
          }
        }
      }
    } else {
      {
#line 3978
      zwarnnam((char const   *)name, "bad assignment");
#line 3979
      returnval = 1;
      }
#line 3980
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 4029
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 4029
    queueing_enabled --;
#line 4029
    if (! queueing_enabled) {
      {
#line 4029
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 4029
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 4029
          if (! (queue_front != queue_rear)) {
#line 4029
            goto while_break___5;
          }
          {
#line 4029
          queue_front = (queue_front + 1) % 128;
#line 4029
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 4029
          zhandler(signal_queue[queue_front]);
#line 4029
          signal_setmask(oset___0);
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 4029
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 4029
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 4030
  return (returnval);
}
}
#line 4036 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_unhash(char *name , char **argv , Options ops , int func ) 
{ 
  HashTable ht ;
  HashNode hn ;
  HashNode nhn ;
  Patprog pprog ;
  int match ;
  int returnval ;
  int all ;
  int i ;
  HashNode tmp ;
  sigset_t oset ;
  HashNode tmp___0 ;
  int tmp___1 ;
  sigset_t oset___0 ;
  sigset_t oset___1 ;

  {
#line 4042
  match = 0;
#line 4042
  returnval = 0;
#line 4042
  all = 0;
#line 4046
  if (func == 29) {
#line 4047
    if ((int )ops->ind[115] != 0) {
#line 4048
      ht = sufaliastab;
    } else {
#line 4050
      ht = aliastab;
    }
#line 4051
    if ((int )ops->ind[97] != 0) {
#line 4052
      if (*argv) {
        {
#line 4053
        zwarnnam((char const   *)name, "-a: too many arguments");
        }
#line 4054
        return (1);
      }
#line 4056
      all = 1;
    } else
#line 4057
    if (! *argv) {
      {
#line 4058
      zwarnnam((char const   *)name, "not enough arguments");
      }
#line 4059
      return (1);
    }
  } else
#line 4061
  if ((int )ops->ind[100] != 0) {
#line 4062
    ht = nameddirtab;
  } else
#line 4063
  if ((int )ops->ind[102] != 0) {
#line 4064
    ht = shfunctab;
  } else
#line 4065
  if ((int )ops->ind[115] != 0) {
#line 4066
    ht = sufaliastab;
  } else
#line 4067
  if (func == 28) {
#line 4067
    if ((int )ops->ind[97] != 0) {
#line 4068
      ht = aliastab;
    } else {
#line 4070
      ht = cmdnamtab;
    }
  } else {
#line 4070
    ht = cmdnamtab;
  }
#line 4072
  if (all) {
#line 4073
    queueing_enabled ++;
#line 4074
    i = 0;
    {
#line 4074
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4074
      if (! (i < ht->hsize)) {
#line 4074
        goto while_break;
      }
#line 4075
      hn = *(ht->nodes + i);
      {
#line 4075
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4075
        if (! hn) {
#line 4075
          goto while_break___0;
        }
        {
#line 4077
        nhn = hn->next;
#line 4078
        tmp = (*(ht->removenode))(ht, (char const   *)hn->nam);
#line 4078
        (*(ht->freenode))(tmp);
#line 4075
        hn = nhn;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 4074
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4081
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4081
      queueing_enabled --;
#line 4081
      if (! queueing_enabled) {
        {
#line 4081
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 4081
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 4081
            if (! (queue_front != queue_rear)) {
#line 4081
              goto while_break___3;
            }
            {
#line 4081
            queue_front = (queue_front + 1) % 128;
#line 4081
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 4081
            zhandler(signal_queue[queue_front]);
#line 4081
            signal_setmask(oset);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 4081
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 4081
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4082
    return (0);
  }
#line 4087
  if ((int )ops->ind[109] != 0) {
    {
#line 4088
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 4088
      if (! *argv) {
#line 4088
        goto while_break___4;
      }
      {
#line 4089
      queueing_enabled ++;
#line 4091
      tokenize(*argv);
#line 4092
      pprog = patcompile(*argv, 64, (char **)((void *)0));
      }
#line 4092
      if (pprog) {
#line 4094
        i = 0;
        {
#line 4094
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 4094
          if (! (i < ht->hsize)) {
#line 4094
            goto while_break___5;
          }
#line 4095
          hn = *(ht->nodes + i);
          {
#line 4095
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 4095
            if (! hn) {
#line 4095
              goto while_break___6;
            }
            {
#line 4097
            nhn = hn->next;
#line 4098
            tmp___1 = pattry(pprog, hn->nam);
            }
#line 4098
            if (tmp___1) {
              {
#line 4099
              tmp___0 = (*(ht->removenode))(ht, (char const   *)hn->nam);
#line 4099
              (*(ht->freenode))(tmp___0);
#line 4100
              match ++;
              }
            }
#line 4095
            hn = nhn;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 4094
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
#line 4105
        untokenize(*argv);
#line 4106
        zwarnnam((char const   *)name, "bad pattern : %s", *argv);
#line 4107
        returnval = 1;
        }
      }
      {
#line 4109
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 4109
        queueing_enabled --;
#line 4109
        if (! queueing_enabled) {
          {
#line 4109
          while (1) {
            while_continue___8: /* CIL Label */ ;
            {
#line 4109
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 4109
              if (! (queue_front != queue_rear)) {
#line 4109
                goto while_break___9;
              }
              {
#line 4109
              queue_front = (queue_front + 1) % 128;
#line 4109
              oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 4109
              zhandler(signal_queue[queue_front]);
#line 4109
              signal_setmask(oset___0);
              }
            }
            while_break___9: /* CIL Label */ ;
            }
#line 4109
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
#line 4109
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 4088
      argv ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 4112
    if (! match) {
#line 4113
      returnval = 1;
    }
#line 4114
    return (returnval);
  }
#line 4118
  queueing_enabled ++;
  {
#line 4119
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 4119
    if (! *argv) {
#line 4119
      goto while_break___10;
    }
    {
#line 4120
    hn = (*(ht->removenode))(ht, (char const   *)*argv);
    }
#line 4120
    if (hn) {
      {
#line 4121
      (*(ht->freenode))(hn);
      }
    } else {
      {
#line 4123
      zwarnnam((char const   *)name, "no such hash table element: %s", *argv);
#line 4124
      returnval = 1;
      }
    }
#line 4119
    argv ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 4127
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 4127
    queueing_enabled --;
#line 4127
    if (! queueing_enabled) {
      {
#line 4127
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 4127
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 4127
          if (! (queue_front != queue_rear)) {
#line 4127
            goto while_break___13;
          }
          {
#line 4127
          queue_front = (queue_front + 1) % 128;
#line 4127
          oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 4127
          zhandler(signal_queue[queue_front]);
#line 4127
          signal_setmask(oset___1);
          }
        }
        while_break___13: /* CIL Label */ ;
        }
#line 4127
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 4127
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 4128
  return (returnval);
}
}
#line 4136 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_alias(char *name , char **argv , Options ops , int func  __attribute__((__unused__)) ) 
{ 
  Alias a ;
  Patprog pprog ;
  Asgment asg___0 ;
  int returnval ;
  int flags1 ;
  int flags2 ;
  int printflags ;
  int type_opts ;
  HashTable ht ;
  sigset_t oset ;
  sigset_t oset___0 ;
  char *tmp ;
  Alias tmp___0 ;
  char *tmp___1 ;
  HashNode tmp___2 ;
  sigset_t oset___1 ;

  {
#line 4142
  returnval = 0;
#line 4143
  flags1 = 0;
#line 4143
  flags2 = 1;
#line 4144
  printflags = 0;
#line 4146
  ht = aliastab;
#line 4149
  type_opts = (((int )ops->ind[114] != 0) + ((int )ops->ind[103] != 0)) + ((int )ops->ind[115] != 0);
#line 4151
  if (type_opts) {
#line 4152
    if (type_opts > 1) {
      {
#line 4153
      zwarnnam((char const   *)name, "illegal combination of options");
      }
#line 4154
      return (1);
    }
#line 4156
    if ((int )ops->ind[103] != 0) {
#line 4157
      flags1 |= 1 << 1;
    } else {
#line 4159
      flags2 |= 1 << 1;
    }
#line 4160
    if ((int )ops->ind[115] != 0) {
#line 4167
      flags1 |= 1 << 2;
#line 4168
      ht = sufaliastab;
    } else {
#line 4170
      flags2 |= 1 << 2;
    }
  }
#line 4173
  if ((int )ops->ind[76] != 0) {
#line 4174
    printflags |= 1 << 2;
  } else
#line 4175
  if ((int )ops->ind[103] & 2) {
#line 4177
    printflags |= 1;
  } else
#line 4175
  if ((int )ops->ind[114] & 2) {
#line 4177
    printflags |= 1;
  } else
#line 4175
  if ((int )ops->ind[115] & 2) {
#line 4177
    printflags |= 1;
  } else
#line 4175
  if ((int )ops->ind[109] & 2) {
#line 4177
    printflags |= 1;
  } else
#line 4175
  if ((int )ops->ind[43] != 0) {
#line 4177
    printflags |= 1;
  }
#line 4181
  if (! *argv) {
    {
#line 4182
    queueing_enabled ++;
#line 4183
    scanhashtable(ht, 1, flags1, flags2, ht->printnode, printflags);
    }
    {
#line 4184
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4184
      queueing_enabled --;
#line 4184
      if (! queueing_enabled) {
        {
#line 4184
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 4184
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 4184
            if (! (queue_front != queue_rear)) {
#line 4184
              goto while_break___1;
            }
            {
#line 4184
            queue_front = (queue_front + 1) % 128;
#line 4184
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 4184
            zhandler(signal_queue[queue_front]);
#line 4184
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 4184
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 4184
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 4185
    return (0);
  }
#line 4190
  if ((int )ops->ind[109] != 0) {
    {
#line 4191
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4191
      if (! *argv) {
#line 4191
        goto while_break___2;
      }
      {
#line 4192
      queueing_enabled ++;
#line 4193
      tokenize(*argv);
#line 4194
      pprog = patcompile(*argv, 64, (char **)((void *)0));
      }
#line 4194
      if (pprog) {
        {
#line 4196
        scanmatchtable(ht, pprog, 1, flags1, flags2, ht->printnode, printflags);
        }
      } else {
        {
#line 4199
        untokenize(*argv);
#line 4200
        zwarnnam((char const   *)name, "bad pattern : %s", *argv);
#line 4201
        returnval = 1;
        }
      }
      {
#line 4203
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 4203
        queueing_enabled --;
#line 4203
        if (! queueing_enabled) {
          {
#line 4203
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 4203
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 4203
              if (! (queue_front != queue_rear)) {
#line 4203
                goto while_break___5;
              }
              {
#line 4203
              queue_front = (queue_front + 1) % 128;
#line 4203
              oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 4203
              zhandler(signal_queue[queue_front]);
#line 4203
              signal_setmask(oset___0);
              }
            }
            while_break___5: /* CIL Label */ ;
            }
#line 4203
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 4203
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 4191
      argv ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 4205
    return (returnval);
  }
#line 4209
  queueing_enabled ++;
  {
#line 4210
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 4210
    asg___0 = getasg(& argv, (LinkList )((void *)0));
    }
#line 4210
    if (! asg___0) {
#line 4210
      goto while_break___6;
    }
#line 4211
    if (asg___0->value.scalar) {
#line 4211
      if (! ((int )ops->ind[76] != 0)) {
        {
#line 4214
        tmp = ztrdup((char const   *)asg___0->value.scalar);
#line 4214
        tmp___0 = createaliasnode(tmp, flags1);
#line 4214
        tmp___1 = ztrdup((char const   *)asg___0->name);
#line 4214
        (*(ht->addnode))(ht, tmp___1, (void *)tmp___0);
        }
      } else {
#line 4211
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 4216
      tmp___2 = (*(ht->getnode))(ht, (char const   *)asg___0->name);
#line 4216
      a = (Alias )tmp___2;
      }
#line 4216
      if (a) {
#line 4218
        if (! type_opts) {
          {
#line 4222
          (*(ht->printnode))(& a->node, printflags);
          }
        } else
#line 4218
        if ((unsigned long )ht == (unsigned long )sufaliastab) {
          {
#line 4222
          (*(ht->printnode))(& a->node, printflags);
          }
        } else
#line 4218
        if ((int )ops->ind[114] != 0) {
#line 4218
          if (! (a->node.flags & ((1 << 1) | (1 << 2)))) {
            {
#line 4222
            (*(ht->printnode))(& a->node, printflags);
            }
          } else {
#line 4218
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 4218
        if ((int )ops->ind[103] != 0) {
#line 4218
          if (a->node.flags & (1 << 1)) {
            {
#line 4222
            (*(ht->printnode))(& a->node, printflags);
            }
          }
        }
      } else {
#line 4224
        returnval = 1;
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 4226
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 4226
    queueing_enabled --;
#line 4226
    if (! queueing_enabled) {
      {
#line 4226
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 4226
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 4226
          if (! (queue_front != queue_rear)) {
#line 4226
            goto while_break___9;
          }
          {
#line 4226
          queue_front = (queue_front + 1) % 128;
#line 4226
          oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 4226
          zhandler(signal_queue[queue_front]);
#line 4226
          signal_setmask(oset___1);
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 4226
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 4226
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 4227
  return (returnval);
}
}
#line 4236 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_true(char *name  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
             Options ops  __attribute__((__unused__)) , int func  __attribute__((__unused__)) ) 
{ 


  {
#line 4239
  return (0);
}
}
#line 4245 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_false(char *name  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
              Options ops  __attribute__((__unused__)) , int func  __attribute__((__unused__)) ) 
{ 


  {
#line 4248
  return (1);
}
}
#line 4273 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_print(char *name , char **args , Options ops , int func ) 
{ 
  int flen ;
  int width ;
  int prec___0 ;
  int type___0 ;
  int argc ;
  int n ;
  int narg ;
  int curlen ;
  int nnl ;
  int fmttrunc ;
  int ret ;
  int maxarg ;
  int nc ;
  int flags[6] ;
  int *len ;
  int visarr ;
  char *start ;
  char *endptr ;
  char *c ;
  char *d___0 ;
  char *flag ;
  char *buf___7 ;
  char spec[14] ;
  char *fmt ;
  char **first ;
  char **argp ;
  char *curarg ;
  char *flagch ;
  char save ;
  char nullstr ;
  size_t rcount ;
  size_t count ;
  size_t *cursplit ;
  size_t *splits ;
  FILE *fout ;
  size_t mcount ;
  Histent ent ;
  mnumber mnumval ;
  double doubleval ;
  int intval ;
  zlong zlongval ;
  zulong zulongval ;
  char *stringval ;
  char *eptr ;
  char *argptr ;
  zlong tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  int tmp___2 ;
  Patprog pprog ;
  char **t ;
  char **p ;
  sigset_t oset ;
  char **tmp___3 ;
  int tmp___4 ;
  sigset_t oset___0 ;
  void *tmp___5 ;
  int escape_how ;
  char *str ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  Nameddir d___1 ;
  int dirlen ;
  size_t tmp___9 ;
  char *arg ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  sigset_t oset___1 ;
  int flags___0 ;
  int fdarg ;
  int fd ;
  char *argptr___0 ;
  char *eptr___0 ;
  zlong tmp___13 ;
  int tmp___14 ;
  int l ;
  int nr ;
  int sc ;
  int n___0 ;
  int t___0 ;
  int i ;
  int *widths ;
  int *wptr ;
  void *tmp___15 ;
  int l___0 ;
  int width___0 ;
  char *aptr ;
  mbstate_t mbs ;
  wchar_t wc ;
  size_t cnt ;
  int wcw ;
  unsigned short const   **tmp___16 ;
  int ic ;
  int tmp___17 ;
  int tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  sigset_t oset___2 ;
  char *tmp___28 ;
  sigset_t oset___3 ;
  int nwords ;
  int nlen ;
  int iwords ;
  char **pargs ;
  char **tmp___29 ;
  int wordsize ;
  short *words ;
  sigset_t oset___4 ;
  void *tmp___30 ;
  void *tmp___31 ;
  int tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  time_t tmp___35 ;
  sigset_t oset___5 ;
  char *eptr___1 ;
  int expand ;
  int startpos ;
  int all ;
  char *xarg ;
  char *tmp___36 ;
  zlong tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___42 ;
  int *tmp___43 ;
  int tmp___44 ;
  int *tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;
  sigset_t oset___6 ;
  struct value vbuf ;
  char *s ;
  Value v ;
  Value tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  void *tmp___54 ;
  size_t *tmp___55 ;
  char *tmp___56 ;
  unsigned long tmp___57 ;
  char *tmp___58 ;
  unsigned long tmp___59 ;
  unsigned long tmp___60 ;
  char **tmp___61 ;
  zlong tmp___62 ;
  char *tmp___63 ;
  unsigned long tmp___64 ;
  char **tmp___65 ;
  zlong tmp___66 ;
  unsigned long tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char **tmp___70 ;
  char tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  char *b ;
  char *ptr___0 ;
  int lbytes ;
  int lchars ;
  int lleft ;
  mbstate_t mbs___0 ;
  int tmp___74 ;
  char *tmp___75 ;
  int chars ;
  size_t tmp___76 ;
  int tmp___77 ;
  size_t tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  int tmp___84 ;
  char *tmp___85 ;
  int tmp___86 ;
  int *tmp___87 ;
  int tmp___88 ;
  int *tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  convchar_t cc ;
  char *tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  zlong tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  char *eptr___2 ;
  int tmp___104 ;
  int tmp___105 ;
  char *tmp___106 ;
  char *tmp___107 ;
  zlong tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int *tmp___111 ;
  char **arrayval ;
  void *tmp___112 ;
  int start___0 ;
  size_t tmp___113 ;
  time_t tmp___114 ;
  int tmp___116 ;
  sigset_t oset___7 ;
  int *tmp___117 ;
  int tmp___118 ;
  int *tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;

  {
#line 4276
  curlen = 0;
#line 4277
  nnl = 0;
#line 4277
  fmttrunc = 0;
#line 4277
  ret = 0;
#line 4277
  maxarg = 0;
#line 4277
  nc = 0;
#line 4278
  visarr = 0;
#line 4279
  buf___7 = (char *)((void *)0);
#line 4279
  fmt = (char *)((void *)0);
#line 4280
  flagch = (char *)"\'0+- #";
#line 4280
  save = (char )'\000';
#line 4280
  nullstr = (char )'\000';
#line 4281
  rcount = (size_t )0;
#line 4281
  count = (size_t )0;
#line 4282
  cursplit = (size_t *)0;
#line 4282
  splits = (size_t *)0;
#line 4283
  fout = stdout;
#line 4348
  if (((((int )ops->ind[122] != 0) + ((int )ops->ind[115] != 0)) + ((int )ops->ind[83] != 0)) + ((int )ops->ind[118] != 0) > 1) {
    {
#line 4351
    zwarnnam((char const   *)name, "only one of -s, -S, -v, or -z allowed");
    }
#line 4352
    return (1);
  }
#line 4354
  if (((((int )ops->ind[122] != 0) | ((int )ops->ind[115] != 0)) | ((int )ops->ind[83] != 0)) + (((int )ops->ind[99] != 0) | ((int )ops->ind[67] != 0)) > 1) {
    {
#line 4356
    zwarnnam((char const   *)name, "-c or -C not allowed with -s, -S, or -z");
    }
#line 4357
    return (1);
  }
#line 4359
  if ((((((int )ops->ind[122] != 0) | ((int )ops->ind[118] != 0)) | ((int )ops->ind[115] != 0)) | ((int )ops->ind[83] != 0)) + (((int )ops->ind[112] != 0) | ((int )ops->ind[117] != 0)) > 1) {
    {
#line 4362
    zwarnnam((char const   *)name, "-p or -u not allowed with -s, -S, -v, or -z");
    }
#line 4363
    return (1);
  }
#line 4374
  if (! fmt) {
#line 4374
    if ((int )ops->ind[67] != 0) {
      {
#line 4375
      argptr = *(ops->args + (((int )ops->ind[67] >> 2) - 1));
#line 4376
      tmp = zstrtol((char const   *)argptr, & eptr, 10);
#line 4376
      nc = (int )tmp;
      }
#line 4377
      if (*eptr) {
        {
#line 4378
        zwarnnam((char const   *)name, "number expected after -%c: %s", 'C', argptr);
        }
#line 4379
        return (1);
      }
#line 4381
      if (nc <= 0) {
        {
#line 4382
        zwarnnam((char const   *)name, "invalid number of columns: %s", argptr);
        }
#line 4383
        return (1);
      }
    }
  }
#line 4387
  if (func == 26) {
    {
#line 4388
    tmp___0 = strcmp((char const   *)*args, "--");
    }
#line 4388
    if (! tmp___0) {
#line 4388
      args ++;
#line 4388
      if (! *args) {
        {
#line 4389
        zwarnnam((char const   *)name, "not enough arguments");
        }
#line 4390
        return (1);
      }
    }
#line 4392
    tmp___1 = args;
#line 4392
    args ++;
#line 4392
    fmt = *tmp___1;
  } else
#line 4393
  if (func == 23) {
#line 4393
    if (opts[25]) {
#line 4394
      ops->ind['E'] = (unsigned char)1;
    } else {
#line 4393
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 4395
  if ((int )ops->ind[102] > 3) {
#line 4396
    fmt = *(ops->args + (((int )ops->ind[102] >> 2) - 1));
  }
#line 4397
  if (fmt) {
#line 4398
    if ((int )ops->ind[98] != 0) {
#line 4398
      tmp___2 = 7;
    } else {
#line 4398
      tmp___2 = 265;
    }
    {
#line 4398
    fmt = getkeystring(fmt, & flen, tmp___2, & fmttrunc);
    }
  }
#line 4401
  first = args;
#line 4405
  if ((int )ops->ind[109] != 0) {
#line 4409
    if (! *args) {
      {
#line 4410
      zwarnnam((char const   *)name, "no pattern specified");
      }
#line 4411
      return (1);
    }
    {
#line 4413
    queueing_enabled ++;
#line 4414
    tokenize(*args);
#line 4415
    pprog = patcompile(*args, 64, (char **)((void *)0));
    }
#line 4415
    if (! pprog) {
      {
#line 4416
      untokenize(*args);
#line 4417
      zwarnnam((char const   *)name, "bad pattern: %s", *args);
      }
      {
#line 4418
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4418
        queueing_enabled --;
#line 4418
        if (! queueing_enabled) {
          {
#line 4418
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 4418
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 4418
              if (! (queue_front != queue_rear)) {
#line 4418
                goto while_break___1;
              }
              {
#line 4418
              queue_front = (queue_front + 1) % 128;
#line 4418
              oset = signal_setmask(signal_mask_queue[queue_front]);
#line 4418
              zhandler(signal_queue[queue_front]);
#line 4418
              signal_setmask(oset);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 4418
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 4418
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 4419
      return (1);
    }
#line 4421
    args ++;
#line 4421
    p = args;
#line 4421
    t = p;
    {
#line 4421
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4421
      if (! *p) {
#line 4421
        goto while_break___2;
      }
      {
#line 4422
      tmp___4 = pattry(pprog, *p);
      }
#line 4422
      if (tmp___4) {
#line 4423
        tmp___3 = t;
#line 4423
        t ++;
#line 4423
        *tmp___3 = *p;
      }
#line 4421
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 4424
    *t = (char *)((void *)0);
#line 4425
    first = args;
    {
#line 4426
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 4426
      queueing_enabled --;
#line 4426
      if (! queueing_enabled) {
        {
#line 4426
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 4426
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 4426
            if (! (queue_front != queue_rear)) {
#line 4426
              goto while_break___5;
            }
            {
#line 4426
            queue_front = (queue_front + 1) % 128;
#line 4426
            oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 4426
            zhandler(signal_queue[queue_front]);
#line 4426
            signal_setmask(oset___0);
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 4426
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 4426
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 4427
    if (fmt) {
#line 4427
      if (! *args) {
#line 4427
        return (0);
      }
    }
  }
  {
#line 4430
  argc = arrlen(args);
#line 4431
  tmp___5 = hcalloc((unsigned long )argc * sizeof(int ));
#line 4431
  len = (int *)tmp___5;
#line 4432
  n = 0;
  }
  {
#line 4432
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 4432
    if (! (n < argc)) {
#line 4432
      goto while_break___6;
    }
#line 4434
    if (fmt) {
      {
#line 4437
      unmetafy(*(args + n), len + n);
      }
    } else
#line 4434
    if (! ((int )ops->ind[101] != 0)) {
#line 4434
      if ((int )ops->ind[82] != 0) {
        {
#line 4437
        unmetafy(*(args + n), len + n);
        }
      } else
#line 4434
      if ((int )ops->ind[114] != 0) {
        {
#line 4437
        unmetafy(*(args + n), len + n);
        }
      } else
#line 4434
      if ((int )ops->ind[69] != 0) {
        {
#line 4437
        unmetafy(*(args + n), len + n);
        }
      } else {
#line 4434
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 4440
      if ((int )ops->ind[98] != 0) {
#line 4441
        escape_how = 7;
      } else
#line 4442
      if (func != 23) {
#line 4442
        if (! ((int )ops->ind[101] != 0)) {
#line 4443
          escape_how = 11;
        } else {
#line 4445
          escape_how = 8;
        }
      } else {
#line 4445
        escape_how = 8;
      }
      {
#line 4446
      *(args + n) = getkeystring(*(args + n), len + n, escape_how, & nnl);
      }
#line 4447
      if (nnl) {
#line 4449
        argc = n + 1;
#line 4450
        *(args + argc) = (char *)((void *)0);
      }
    }
#line 4454
    if ((int )ops->ind[80] != 0) {
      {
#line 4460
      tmp___6 = metafy(*(args + n), *(len + n), 5);
#line 4460
      tmp___7 = promptexpand(tmp___6, 0, (char *)((void *)0), (char *)((void *)0),
                             (unsigned int *)((void *)0));
#line 4460
      tmp___8 = unmetafy(tmp___7, len + n);
#line 4460
      str = tmp___8;
#line 4464
      *(args + n) = dupstrpfx((char const   *)str, *(len + n));
#line 4465
      free((void *)str);
      }
    }
#line 4468
    if ((int )ops->ind[68] != 0) {
      {
#line 4471
      queueing_enabled ++;
#line 4473
      d___1 = finddir(*(args + n));
      }
#line 4474
      if (d___1) {
        {
#line 4475
        tmp___9 = strlen((char const   *)d___1->dir);
#line 4475
        dirlen = (int )tmp___9;
#line 4476
        tmp___10 = strlen((char const   *)d___1->node.nam);
#line 4476
        tmp___11 = zhalloc(((size_t )(*(len + n) - dirlen) + tmp___10) + 2UL);
#line 4476
        arg = (char *)tmp___11;
#line 4477
        sprintf((char */* __restrict  */)arg, (char const   */* __restrict  */)"~%s%s",
                d___1->node.nam, *(args + n) + dirlen);
#line 4478
        *(args + n) = arg;
#line 4479
        tmp___12 = strlen((char const   *)*(args + n));
#line 4479
        *(len + n) = (int )tmp___12;
        }
      }
      {
#line 4481
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 4481
        queueing_enabled --;
#line 4481
        if (! queueing_enabled) {
          {
#line 4481
          while (1) {
            while_continue___8: /* CIL Label */ ;
            {
#line 4481
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 4481
              if (! (queue_front != queue_rear)) {
#line 4481
                goto while_break___9;
              }
              {
#line 4481
              queue_front = (queue_front + 1) % 128;
#line 4481
              oset___1 = signal_setmask(signal_mask_queue[queue_front]);
#line 4481
              zhandler(signal_queue[queue_front]);
#line 4481
              signal_setmask(oset___1);
              }
            }
            while_break___9: /* CIL Label */ ;
            }
#line 4481
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
#line 4481
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 4432
    n ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 4486
  if ((int )ops->ind[111] != 0) {
#line 4486
    goto _L___1;
  } else
#line 4486
  if ((int )ops->ind[79] != 0) {
    _L___1: /* CIL Label */ 
#line 4489
    if (fmt) {
#line 4489
      if (! *args) {
#line 4490
        return (0);
      }
    }
#line 4491
    if ((int )ops->ind[105] != 0) {
#line 4491
      flags___0 = 1;
    } else {
#line 4491
      flags___0 = 0;
    }
#line 4492
    if ((int )ops->ind[79] != 0) {
#line 4493
      flags___0 |= 4;
    }
    {
#line 4494
    strmetasort(args, flags___0, len);
    }
  }
#line 4498
  if ((int )ops->ind[117] > 3) {
#line 4498
    goto _L___4;
  } else
#line 4498
  if ((int )ops->ind[112] != 0) {
    _L___4: /* CIL Label */ 
#line 4498
    if (! fmt) {
#line 4498
      if ((int )ops->ind[99] != 0) {
#line 4498
        goto _L___2;
      } else
#line 4498
      if ((int )ops->ind[67] != 0) {
#line 4498
        goto _L___2;
      } else {
#line 4498
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 4498
    if (! ((int )ops->ind[122] != 0)) {
#line 4498
      if (! ((int )ops->ind[118] != 0)) {
#line 4498
        if (! ((int )ops->ind[115] != 0)) {
#line 4498
          if (! ((int )ops->ind[83] != 0)) {
            _L___2: /* CIL Label */ 
#line 4505
            if ((int )ops->ind[112] != 0) {
#line 4506
              fdarg = coprocout;
#line 4507
              if (fdarg < 0) {
                {
#line 4508
                zwarnnam((char const   *)name, "-p: no coprocess");
                }
#line 4509
                return (1);
              }
            } else {
              {
#line 4512
              argptr___0 = *(ops->args + (((int )ops->ind[117] >> 2) - 1));
#line 4514
              tmp___14 = strcmp((char const   *)argptr___0, "p");
              }
#line 4514
              if (tmp___14) {
                {
#line 4521
                tmp___13 = zstrtol((char const   *)argptr___0, & eptr___0, 10);
#line 4521
                fdarg = (int )tmp___13;
                }
#line 4522
                if (*eptr___0) {
                  {
#line 4523
                  zwarnnam((char const   *)name, "number expected after -u: %s", argptr___0);
                  }
#line 4524
                  return (1);
                }
              } else {
#line 4515
                fdarg = coprocout;
#line 4516
                if (fdarg < 0) {
                  {
#line 4517
                  zwarnnam((char const   *)name, "-p: no coprocess");
                  }
#line 4518
                  return (1);
                }
              }
            }
            {
#line 4529
            fd = dup(fdarg);
            }
#line 4529
            if (fd < 0) {
              {
#line 4530
              zwarnnam((char const   *)name, "bad file number: %d", fdarg);
              }
#line 4531
              return (1);
            }
            {
#line 4533
            fout = fdopen(fd, "w");
            }
#line 4533
            if ((unsigned long )fout == (unsigned long )((FILE *)0)) {
              {
#line 4534
              close(fd);
#line 4535
              zwarnnam((char const   *)name, "bad mode on fd %d", fd);
              }
#line 4536
              return (1);
            }
          }
        }
      }
    }
  }
#line 4540
  if ((int )ops->ind[118] != 0) {
#line 4540
    goto _L___6;
  } else
#line 4540
  if (fmt) {
#line 4540
    if ((int )ops->ind[122] != 0) {
#line 4540
      goto _L___6;
    } else
#line 4540
    if ((int )ops->ind[115] != 0) {
      _L___6: /* CIL Label */ 
      {
#line 4542
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 4542
        fout = open_memstream(& buf___7, & mcount);
        }
#line 4542
        if ((unsigned long )fout == (unsigned long )((void *)0)) {
          {
#line 4542
          zwarnnam((char const   *)name, "open_memstream failed");
          }
#line 4542
          return (1);
        }
#line 4542
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
  }
#line 4545
  if (! fmt) {
#line 4545
    if ((int )ops->ind[99] != 0) {
#line 4545
      goto _L___10;
    } else
#line 4545
    if ((int )ops->ind[67] != 0) {
      _L___10: /* CIL Label */ 
#line 4550
      if (opts[117]) {
        {
#line 4557
        tmp___15 = zhalloc((unsigned long )argc * sizeof(int ));
#line 4557
        widths = (int *)tmp___15;
#line 4557
        wptr = widths;
#line 4558
        i = 0;
        }
        {
#line 4558
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 4558
          if (i < argc) {
#line 4558
            if (! *(args + i)) {
#line 4558
              goto while_break___11;
            }
          } else {
#line 4558
            goto while_break___11;
          }
          {
#line 4559
          l___0 = *(len + i);
#line 4559
          width___0 = 0;
#line 4560
          aptr = *(args + i);
#line 4563
          memset((void *)(& mbs), 0, sizeof(mbstate_t ));
          }
          {
#line 4564
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 4564
            if (! (l___0 > 0)) {
#line 4564
              goto while_break___12;
            }
#line 4579
            if ((int )*aptr == 27) {
#line 4579
              goto _L___7;
            } else
#line 4579
            if ((int )*aptr == -101) {
              _L___7: /* CIL Label */ 
#line 4580
              aptr ++;
#line 4580
              l___0 --;
              {
#line 4580
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 4580
                if (l___0) {
                  {
#line 4580
                  tmp___16 = __ctype_b_loc();
                  }
#line 4580
                  if ((int const   )*(*tmp___16 + (int )((unsigned char )*aptr)) & 1024) {
#line 4580
                    goto while_break___13;
                  }
                } else {
#line 4580
                  goto while_break___13;
                }
#line 4580
                aptr ++;
#line 4580
                l___0 --;
              }
              while_break___13: /* CIL Label */ ;
              }
#line 4584
              aptr ++;
#line 4585
              l___0 --;
#line 4586
              goto while_continue___12;
            }
            {
#line 4589
            cnt = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)aptr,
                          (size_t )l___0, (mbstate_t */* __restrict  */)(& mbs));
            }
#line 4591
            if (cnt == 0xfffffffffffffffeUL) {
#line 4594
              width___0 += l___0;
#line 4595
              goto while_break___12;
            } else
#line 4591
            if (cnt == 0xffffffffffffffffUL) {
#line 4594
              width___0 += l___0;
#line 4595
              goto while_break___12;
            }
            {
#line 4597
            wcw = wcwidth(wc);
            }
#line 4599
            if (wcw > 0) {
#line 4600
              width___0 += wcw;
            }
#line 4602
            if (cnt == 0UL) {
#line 4603
              cnt = (size_t )1;
            }
#line 4604
            aptr += cnt;
#line 4605
            l___0 = (int )((size_t )l___0 - cnt);
          }
          while_break___12: /* CIL Label */ ;
          }
#line 4607
          *(widths + i) = width___0;
#line 4558
          i ++;
#line 4558
          wptr ++;
        }
        while_break___11: /* CIL Label */ ;
        }
      } else {
#line 4611
        widths = len;
      }
#line 4616
      if ((int )ops->ind[67] != 0) {
        {
#line 4622
        n___0 = arrlen(args);
#line 4623
        nr = ((n___0 + nc) - 1) / nc;
#line 4632
        l = 0;
#line 4632
        i = l;
        }
        {
#line 4632
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 4632
          if (! (i < argc)) {
#line 4632
            goto while_break___14;
          }
#line 4633
          if ((int )ops->ind[97] != 0) {
#line 4634
            if (i % nc == nc - 1) {
#line 4635
              goto __Cont;
            }
          } else
#line 4637
          if (i >= nr * (nc - 1)) {
#line 4638
            goto while_break___14;
          }
#line 4640
          if (l < *(widths + i)) {
#line 4641
            l = *(widths + i);
          }
          __Cont: /* CIL Label */ 
#line 4632
          i ++;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 4643
        sc = l + 2;
      } else {
#line 4651
        l = 0;
#line 4651
        n___0 = l;
        {
#line 4651
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 4651
          if (! (n___0 < argc)) {
#line 4651
            goto while_break___15;
          }
#line 4652
          if (l < *(widths + n___0)) {
#line 4653
            l = *(widths + n___0);
          }
#line 4651
          n___0 ++;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 4659
        sc = l + 2;
#line 4660
        nc = (int )((zterm_columns + 1L) / (zlong )sc);
#line 4661
        if (! nc) {
#line 4662
          nc = 1;
        }
#line 4663
        nr = ((n___0 + nc) - 1) / nc;
      }
#line 4666
      if ((int )ops->ind[97] != 0) {
#line 4667
        n___0 = 0;
      }
#line 4668
      i = 0;
      {
#line 4668
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 4668
        if (! (i < nr)) {
#line 4668
          goto while_break___16;
        }
#line 4669
        if ((int )ops->ind[97] != 0) {
#line 4672
          ic = 0;
          {
#line 4672
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 4672
            if (ic < nc) {
#line 4672
              if (! (n___0 < argc)) {
#line 4672
                goto while_break___17;
              }
            } else {
#line 4672
              goto while_break___17;
            }
            {
#line 4674
            fwrite((void const   */* __restrict  */)*(args + n___0), (size_t )*(len + n___0),
                   (size_t )1, (FILE */* __restrict  */)fout);
#line 4675
            l = *(widths + n___0);
            }
#line 4676
            if (n___0 < argc) {
              {
#line 4677
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 4677
                if (! (l < sc)) {
#line 4677
                  goto while_break___18;
                }
                {
#line 4678
                fputc(' ', fout);
#line 4677
                l ++;
                }
              }
              while_break___18: /* CIL Label */ ;
              }
            }
#line 4672
            ic ++;
#line 4672
            n___0 ++;
          }
          while_break___17: /* CIL Label */ ;
          }
        } else {
#line 4683
          n___0 = i;
          {
#line 4684
          while (1) {
            while_continue___19: /* CIL Label */ ;
            {
#line 4685
            fwrite((void const   */* __restrict  */)*(args + n___0), (size_t )*(len + n___0),
                   (size_t )1, (FILE */* __restrict  */)fout);
#line 4686
            l = *(widths + n___0);
#line 4687
            t___0 = nr;
            }
            {
#line 4687
            while (1) {
              while_continue___20: /* CIL Label */ ;
#line 4687
              if (t___0) {
#line 4687
                if (! (n___0 < argc)) {
#line 4687
                  goto while_break___20;
                }
              } else {
#line 4687
                goto while_break___20;
              }
#line 4687
              t___0 --;
#line 4687
              n___0 ++;
            }
            while_break___20: /* CIL Label */ ;
            }
#line 4688
            if (n___0 < argc) {
              {
#line 4689
              while (1) {
                while_continue___21: /* CIL Label */ ;
#line 4689
                if (! (l < sc)) {
#line 4689
                  goto while_break___21;
                }
                {
#line 4690
                fputc(' ', fout);
#line 4689
                l ++;
                }
              }
              while_break___21: /* CIL Label */ ;
              }
            }
#line 4684
            if (! (n___0 < argc)) {
#line 4684
              goto while_break___19;
            }
          }
          while_break___19: /* CIL Label */ ;
          }
        }
#line 4693
        if ((int )ops->ind[78] != 0) {
#line 4693
          tmp___17 = '\000';
        } else {
#line 4693
          tmp___17 = '\n';
        }
        {
#line 4693
        fputc(tmp___17, fout);
#line 4668
        i ++;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
#line 4695
      if ((unsigned long )fout != (unsigned long )stdout) {
#line 4695
        if ((int )ops->ind[122] != 0) {
#line 4695
          goto _L___8;
        } else
#line 4695
        if ((int )ops->ind[115] != 0) {
#line 4695
          goto _L___8;
        } else
#line 4695
        if ((int )ops->ind[118] != 0) {
          _L___8: /* CIL Label */ 
          {
#line 4695
          tmp___19 = fclose(fout);
          }
#line 4695
          if (tmp___19 == 0) {
#line 4695
            rcount = mcount;
          } else {
#line 4695
            rcount = (size_t )-1;
          }
#line 4695
          if (rcount == 0xffffffffffffffffUL) {
#line 4696
            ret = 1;
          }
        }
      }
#line 4697
      if ((unsigned long )fout != (unsigned long )stdout) {
#line 4697
        if ((int )ops->ind[122] != 0) {
#line 4697
          tmp___26 = 1;
        } else
#line 4697
        if ((int )ops->ind[115] != 0) {
#line 4697
          tmp___26 = 1;
        } else
#line 4697
        if ((int )ops->ind[118] != 0) {
#line 4697
          tmp___26 = 1;
        } else {
#line 4697
          goto _L___9;
        }
      } else {
        _L___9: /* CIL Label */ 
#line 4697
        if ((unsigned long )fout == (unsigned long )stdout) {
          {
#line 4697
          tmp___21 = fflush(fout);
          }
#line 4697
          if (tmp___21 == 0) {
#line 4697
            tmp___23 = 1;
          } else {
            {
#line 4697
            tmp___22 = __errno_location();
            }
#line 4697
            if (*tmp___22 == 9) {
#line 4697
              tmp___23 = 1;
            } else {
#line 4697
              tmp___23 = 0;
            }
          }
#line 4697
          tmp___25 = tmp___23;
        } else {
          {
#line 4697
          tmp___24 = fclose(fout);
#line 4697
          tmp___25 = tmp___24 == 0;
          }
        }
#line 4697
        tmp___26 = tmp___25;
      }
#line 4697
      if (tmp___26) {
#line 4697
        if (ret) {
          {
#line 4698
          tmp___20 = __errno_location();
#line 4698
          zwarnnam((char const   *)name, "write error: %e", *tmp___20);
#line 4699
          ret = 1;
          }
        }
      } else {
        {
#line 4698
        tmp___20 = __errno_location();
#line 4698
        zwarnnam((char const   *)name, "write error: %e", *tmp___20);
#line 4699
        ret = 1;
        }
      }
#line 4701
      if (buf___7) {
#line 4703
        queueing_enabled ++;
#line 4704
        if (ret) {
          {
#line 4705
          free((void *)buf___7);
          }
        } else {
          {
#line 4707
          tmp___27 = metafy(buf___7, (int )rcount, 0);
#line 4707
          setsparam(*(ops->args + (((int )ops->ind[118] >> 2) - 1)), tmp___27);
          }
        }
        {
#line 4709
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 4709
          queueing_enabled --;
#line 4709
          if (! queueing_enabled) {
            {
#line 4709
            while (1) {
              while_continue___23: /* CIL Label */ ;
              {
#line 4709
              while (1) {
                while_continue___24: /* CIL Label */ ;
#line 4709
                if (! (queue_front != queue_rear)) {
#line 4709
                  goto while_break___24;
                }
                {
#line 4709
                queue_front = (queue_front + 1) % 128;
#line 4709
                oset___2 = signal_setmask(signal_mask_queue[queue_front]);
#line 4709
                zhandler(signal_queue[queue_front]);
#line 4709
                signal_setmask(oset___2);
                }
              }
              while_break___24: /* CIL Label */ ;
              }
#line 4709
              goto while_break___23;
            }
            while_break___23: /* CIL Label */ ;
            }
          }
#line 4709
          goto while_break___22;
        }
        while_break___22: /* CIL Label */ ;
        }
      }
#line 4711
      return (ret);
    }
  }
#line 4715
  if (! fmt) {
#line 4716
    if ((int )ops->ind[122] != 0) {
#line 4716
      goto _L___11;
    } else
#line 4716
    if ((int )ops->ind[118] != 0) {
#line 4716
      goto _L___11;
    } else
#line 4716
    if ((int )ops->ind[115] != 0) {
#line 4716
      goto _L___11;
    } else
#line 4716
    if ((int )ops->ind[83] != 0) {
      _L___11: /* CIL Label */ 
#line 4721
      n = 0;
      {
#line 4721
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 4721
        if (! (n < argc)) {
#line 4721
          goto while_break___25;
        }
        {
#line 4722
        metafy(*(args + n), *(len + n), 5);
#line 4721
        n ++;
        }
      }
      while_break___25: /* CIL Label */ ;
      }
    }
#line 4726
    if ((int )ops->ind[122] != 0) {
      {
#line 4727
      queueing_enabled ++;
#line 4728
      tmp___28 = sepjoin(args, (char *)((void *)0), 0);
#line 4728
      zinsertlinknode(bufstack, & bufstack->node, (void *)tmp___28);
      }
      {
#line 4729
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 4729
        queueing_enabled --;
#line 4729
        if (! queueing_enabled) {
          {
#line 4729
          while (1) {
            while_continue___27: /* CIL Label */ ;
            {
#line 4729
            while (1) {
              while_continue___28: /* CIL Label */ ;
#line 4729
              if (! (queue_front != queue_rear)) {
#line 4729
                goto while_break___28;
              }
              {
#line 4729
              queue_front = (queue_front + 1) % 128;
#line 4729
              oset___3 = signal_setmask(signal_mask_queue[queue_front]);
#line 4729
              zhandler(signal_queue[queue_front]);
#line 4729
              signal_setmask(oset___3);
              }
            }
            while_break___28: /* CIL Label */ ;
            }
#line 4729
            goto while_break___27;
          }
          while_break___27: /* CIL Label */ ;
          }
        }
#line 4729
        goto while_break___26;
      }
      while_break___26: /* CIL Label */ ;
      }
#line 4730
      return (0);
    }
#line 4733
    if ((int )ops->ind[115] != 0) {
#line 4733
      goto _L___12;
    } else
#line 4733
    if ((int )ops->ind[83] != 0) {
      _L___12: /* CIL Label */ 
#line 4734
      nwords = 0;
#line 4735
      pargs = args;
#line 4737
      queueing_enabled ++;
      {
#line 4738
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 4738
        tmp___29 = pargs;
#line 4738
        pargs ++;
#line 4738
        if (! *tmp___29) {
#line 4738
          goto while_break___29;
        }
#line 4739
        nwords ++;
      }
      while_break___29: /* CIL Label */ ;
      }
#line 4740
      if (nwords) {
#line 4741
        if ((int )ops->ind[83] != 0) {
#line 4744
          if (nwords > 1) {
            {
#line 4745
            zwarnnam((char const   *)name, "option -S takes a single argument");
            }
            {
#line 4746
            while (1) {
              while_continue___30: /* CIL Label */ ;
#line 4746
              queueing_enabled --;
#line 4746
              if (! queueing_enabled) {
                {
#line 4746
                while (1) {
                  while_continue___31: /* CIL Label */ ;
                  {
#line 4746
                  while (1) {
                    while_continue___32: /* CIL Label */ ;
#line 4746
                    if (! (queue_front != queue_rear)) {
#line 4746
                      goto while_break___32;
                    }
                    {
#line 4746
                    queue_front = (queue_front + 1) % 128;
#line 4746
                    oset___4 = signal_setmask(signal_mask_queue[queue_front]);
#line 4746
                    zhandler(signal_queue[queue_front]);
#line 4746
                    signal_setmask(oset___4);
                    }
                  }
                  while_break___32: /* CIL Label */ ;
                  }
#line 4746
                  goto while_break___31;
                }
                while_break___31: /* CIL Label */ ;
                }
              }
#line 4746
              goto while_break___30;
            }
            while_break___30: /* CIL Label */ ;
            }
#line 4747
            return (1);
          }
          {
#line 4749
          words = (short *)((void *)0);
#line 4750
          wordsize = 0;
#line 4751
          histsplitwords(*args, & words, & wordsize, & nwords, 1);
#line 4752
          ent = prepnexthistent();
#line 4753
          tmp___30 = zalloc((unsigned long )nwords * sizeof(short ));
#line 4753
          ent->words = (short *)tmp___30;
#line 4754
          memcpy((void */* __restrict  */)ent->words, (void const   */* __restrict  */)words,
                 (unsigned long )nwords * sizeof(short ));
#line 4755
          free((void *)words);
#line 4756
          ent->nwords = nwords / 2;
          }
        } else {
          {
#line 4758
          ent = prepnexthistent();
#line 4759
          tmp___31 = zalloc((unsigned long )(nwords * 2) * sizeof(short ));
#line 4759
          ent->words = (short *)tmp___31;
#line 4760
          ent->nwords = nwords;
#line 4761
          iwords = 0;
#line 4761
          nlen = iwords;
#line 4762
          pargs = args;
          }
          {
#line 4762
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 4762
            if (! *pargs) {
#line 4762
              goto while_break___33;
            }
            {
#line 4763
            tmp___32 = iwords;
#line 4763
            iwords ++;
#line 4763
            *(ent->words + tmp___32) = (short )nlen;
#line 4764
            tmp___33 = strlen((char const   *)*pargs);
#line 4764
            nlen = (int )((size_t )nlen + tmp___33);
#line 4765
            tmp___34 = iwords;
#line 4765
            iwords ++;
#line 4765
            *(ent->words + tmp___34) = (short )nlen;
#line 4766
            nlen ++;
#line 4762
            pargs ++;
            }
          }
          while_break___33: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 4770
        ent = prepnexthistent();
#line 4771
        ent->words = (short *)((void *)0);
        }
      }
      {
#line 4773
      ent->node.nam = zjoin(args, ' ', 0);
#line 4774
      tmp___35 = time((time_t *)((void *)0));
#line 4774
      ent->ftim = tmp___35;
#line 4774
      ent->stim = tmp___35;
#line 4775
      ent->node.flags = 0;
#line 4776
      addhistnode(histtab, ent->node.nam, (void *)ent);
      }
      {
#line 4777
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 4777
        queueing_enabled --;
#line 4777
        if (! queueing_enabled) {
          {
#line 4777
          while (1) {
            while_continue___35: /* CIL Label */ ;
            {
#line 4777
            while (1) {
              while_continue___36: /* CIL Label */ ;
#line 4777
              if (! (queue_front != queue_rear)) {
#line 4777
                goto while_break___36;
              }
              {
#line 4777
              queue_front = (queue_front + 1) % 128;
#line 4777
              oset___5 = signal_setmask(signal_mask_queue[queue_front]);
#line 4777
              zhandler(signal_queue[queue_front]);
#line 4777
              signal_setmask(oset___5);
              }
            }
            while_break___36: /* CIL Label */ ;
            }
#line 4777
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
        }
#line 4777
        goto while_break___34;
      }
      while_break___34: /* CIL Label */ ;
      }
#line 4778
      return (0);
    }
#line 4781
    if ((int )ops->ind[120] > 3) {
#line 4781
      goto _L___13;
    } else
#line 4781
    if ((int )ops->ind[88] > 3) {
      _L___13: /* CIL Label */ 
#line 4783
      startpos = 0;
#line 4784
      all = (int )ops->ind[88] > 3;
#line 4785
      if (all) {
#line 4785
        tmp___36 = *(ops->args + (((int )ops->ind[88] >> 2) - 1));
      } else {
#line 4785
        tmp___36 = *(ops->args + (((int )ops->ind[120] >> 2) - 1));
      }
      {
#line 4785
      xarg = tmp___36;
#line 4787
      tmp___37 = zstrtol((char const   *)xarg, & eptr___1, 10);
#line 4787
      expand = (int )tmp___37;
      }
#line 4788
      if (*eptr___1) {
        {
#line 4789
        zwarnnam((char const   *)name, "positive integer expected after -%c: %s",
                 'x', xarg);
        }
#line 4791
        return (1);
      } else
#line 4788
      if (expand <= 0) {
        {
#line 4789
        zwarnnam((char const   *)name, "positive integer expected after -%c: %s",
                 'x', xarg);
        }
#line 4791
        return (1);
      }
      {
#line 4793
      while (1) {
        while_continue___37: /* CIL Label */ ;
#line 4793
        if (! *args) {
#line 4793
          goto while_break___37;
        }
        {
#line 4794
        startpos = zexpandtabs((char const   *)*args, *len, expand, startpos, fout,
                               all);
        }
#line 4796
        if (*(args + 1)) {
#line 4797
          if ((int )ops->ind[108] != 0) {
            {
#line 4798
            fputc('\n', fout);
#line 4799
            startpos = 0;
            }
          } else
#line 4800
          if ((int )ops->ind[78] != 0) {
            {
#line 4801
            fputc('\000', fout);
            }
          } else {
            {
#line 4803
            fputc(' ', fout);
#line 4804
            startpos ++;
            }
          }
        }
#line 4793
        args ++;
#line 4793
        len ++;
      }
      while_break___37: /* CIL Label */ ;
      }
    } else {
      {
#line 4809
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 4809
        if (! *args) {
#line 4809
          goto while_break___38;
        }
        {
#line 4810
        fwrite((void const   */* __restrict  */)*args, (size_t )*len, (size_t )1,
               (FILE */* __restrict  */)fout);
        }
#line 4811
        if (*(args + 1)) {
#line 4812
          if ((int )ops->ind[108] != 0) {
#line 4812
            tmp___39 = '\n';
          } else {
#line 4812
            if ((int )ops->ind[78] != 0) {
#line 4812
              tmp___38 = '\000';
            } else {
#line 4812
              tmp___38 = ' ';
            }
#line 4812
            tmp___39 = tmp___38;
          }
          {
#line 4812
          fputc(tmp___39, fout);
          }
        }
#line 4809
        args ++;
#line 4809
        len ++;
      }
      while_break___38: /* CIL Label */ ;
      }
    }
#line 4816
    if (! ((int )ops->ind[110] != 0)) {
#line 4816
      if (! nnl) {
#line 4816
        if ((int )ops->ind[118] != 0) {
#line 4816
          if (! (! ((int )ops->ind[108] != 0))) {
#line 4816
            goto _L___14;
          }
        } else {
          _L___14: /* CIL Label */ 
#line 4818
          if ((int )ops->ind[78] != 0) {
#line 4818
            tmp___40 = '\000';
          } else {
#line 4818
            tmp___40 = '\n';
          }
          {
#line 4818
          fputc(tmp___40, fout);
          }
        }
      }
    }
#line 4819
    if ((unsigned long )fout != (unsigned long )stdout) {
#line 4819
      if ((int )ops->ind[122] != 0) {
#line 4819
        goto _L___15;
      } else
#line 4819
      if ((int )ops->ind[115] != 0) {
#line 4819
        goto _L___15;
      } else
#line 4819
      if ((int )ops->ind[118] != 0) {
        _L___15: /* CIL Label */ 
        {
#line 4819
        tmp___42 = fclose(fout);
        }
#line 4819
        if (tmp___42 == 0) {
#line 4819
          rcount = mcount;
        } else {
#line 4819
          rcount = (size_t )-1;
        }
#line 4819
        if (rcount == 0xffffffffffffffffUL) {
#line 4820
          ret = 1;
        }
      }
    }
#line 4821
    if ((unsigned long )fout != (unsigned long )stdout) {
#line 4821
      if ((int )ops->ind[122] != 0) {
#line 4821
        tmp___49 = 1;
      } else
#line 4821
      if ((int )ops->ind[115] != 0) {
#line 4821
        tmp___49 = 1;
      } else
#line 4821
      if ((int )ops->ind[118] != 0) {
#line 4821
        tmp___49 = 1;
      } else {
#line 4821
        goto _L___16;
      }
    } else {
      _L___16: /* CIL Label */ 
#line 4821
      if ((unsigned long )fout == (unsigned long )stdout) {
        {
#line 4821
        tmp___44 = fflush(fout);
        }
#line 4821
        if (tmp___44 == 0) {
#line 4821
          tmp___46 = 1;
        } else {
          {
#line 4821
          tmp___45 = __errno_location();
          }
#line 4821
          if (*tmp___45 == 9) {
#line 4821
            tmp___46 = 1;
          } else {
#line 4821
            tmp___46 = 0;
          }
        }
#line 4821
        tmp___48 = tmp___46;
      } else {
        {
#line 4821
        tmp___47 = fclose(fout);
#line 4821
        tmp___48 = tmp___47 == 0;
        }
      }
#line 4821
      tmp___49 = tmp___48;
    }
#line 4821
    if (tmp___49) {
#line 4821
      if (ret) {
        {
#line 4822
        tmp___43 = __errno_location();
#line 4822
        zwarnnam((char const   *)name, "write error: %e", *tmp___43);
#line 4823
        ret = 1;
        }
      }
    } else {
      {
#line 4822
      tmp___43 = __errno_location();
#line 4822
      zwarnnam((char const   *)name, "write error: %e", *tmp___43);
#line 4823
      ret = 1;
      }
    }
#line 4825
    if (buf___7) {
#line 4827
      queueing_enabled ++;
#line 4828
      if (ret) {
        {
#line 4829
        free((void *)buf___7);
        }
      } else {
        {
#line 4831
        tmp___50 = metafy(buf___7, (int )rcount, 0);
#line 4831
        setsparam(*(ops->args + (((int )ops->ind[118] >> 2) - 1)), tmp___50);
        }
      }
      {
#line 4833
      while (1) {
        while_continue___39: /* CIL Label */ ;
#line 4833
        queueing_enabled --;
#line 4833
        if (! queueing_enabled) {
          {
#line 4833
          while (1) {
            while_continue___40: /* CIL Label */ ;
            {
#line 4833
            while (1) {
              while_continue___41: /* CIL Label */ ;
#line 4833
              if (! (queue_front != queue_rear)) {
#line 4833
                goto while_break___41;
              }
              {
#line 4833
              queue_front = (queue_front + 1) % 128;
#line 4833
              oset___6 = signal_setmask(signal_mask_queue[queue_front]);
#line 4833
              zhandler(signal_queue[queue_front]);
#line 4833
              signal_setmask(oset___6);
              }
            }
            while_break___41: /* CIL Label */ ;
            }
#line 4833
            goto while_break___40;
          }
          while_break___40: /* CIL Label */ ;
          }
        }
#line 4833
        goto while_break___39;
      }
      while_break___39: /* CIL Label */ ;
      }
    }
#line 4835
    return (ret);
  }
#line 4844
  if ((int )ops->ind[118] != 0) {
    {
#line 4846
    s = *(ops->args + (((int )ops->ind[118] >> 2) - 1));
#line 4847
    tmp___51 = getvalue(& vbuf, & s, 0);
#line 4847
    v = tmp___51;
    }
#line 4848
    if (v) {
#line 4848
      if (((v->pm)->node.flags & (((((1 << 1) | (1 << 2)) | (1 << 3)) | 1) | (1 << 4))) == 1) {
#line 4848
        tmp___52 = 1;
      } else {
#line 4848
        tmp___52 = 0;
      }
    } else {
#line 4848
      tmp___52 = 0;
    }
#line 4848
    visarr = tmp___52;
  }
#line 4851
  spec[0] = (char )'%';
#line 4852
  argp = args;
  {
#line 4853
  while (1) {
    while_continue___42: /* CIL Label */ ;
#line 4854
    rcount = count;
#line 4855
    if ((unsigned long )argp > (unsigned long )args) {
#line 4855
      if (visarr) {
#line 4856
        if (! splits) {
          {
#line 4857
          tmp___53 = arrlen(args);
#line 4857
          tmp___54 = zhalloc(sizeof(size_t ) * (unsigned long )((long )tmp___53 / (argp - args) + 1L));
#line 4857
          splits = (size_t *)tmp___54;
#line 4857
          cursplit = splits;
          }
        }
#line 4859
        tmp___55 = cursplit;
#line 4859
        cursplit ++;
#line 4859
        *tmp___55 = count;
      }
    }
#line 4861
    if (maxarg) {
#line 4862
      first += maxarg;
#line 4863
      argc -= maxarg;
#line 4864
      maxarg = 0;
    }
#line 4866
    c = fmt;
    {
#line 4866
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 4866
      if (! (c - fmt < (long )flen)) {
#line 4866
        goto while_break___43;
      }
#line 4867
      if ((int )*c != 37) {
        {
#line 4868
        _IO_putc((int )*c, fout);
#line 4869
        count ++;
        }
#line 4870
        goto __Cont___0;
      }
#line 4873
      tmp___56 = c;
#line 4873
      c ++;
#line 4873
      start = tmp___56;
#line 4874
      if ((int )*c == 37) {
        {
#line 4875
        _IO_putc('%', fout);
#line 4876
        count ++;
        }
#line 4877
        goto __Cont___0;
      }
#line 4880
      prec___0 = -1;
#line 4880
      type___0 = prec___0;
#line 4881
      width = 0;
#line 4882
      curarg = (char *)((void *)0);
#line 4883
      d___0 = spec + 1;
#line 4885
      if ((int )*c >= 49) {
#line 4885
        if ((int )*c <= 57) {
          {
#line 4886
          tmp___57 = strtoul((char const   */* __restrict  */)c, (char **/* __restrict  */)(& endptr),
                             0);
#line 4886
          narg = (int )tmp___57;
          }
#line 4887
          if ((int )*endptr == 36) {
#line 4888
            c = endptr + 1;
#line 4890
            if (narg > argc) {
              {
#line 4891
              zwarnnam((char const   *)name, "%d: argument specifier out of range",
                       narg);
              }
#line 4893
              if ((unsigned long )fout != (unsigned long )stdout) {
                {
#line 4894
                fclose(fout);
                }
              }
#line 4896
              if (buf___7) {
                {
#line 4897
                free((void *)buf___7);
                }
              }
#line 4899
              return (1);
            } else {
#line 4901
              if (narg > maxarg) {
#line 4901
                maxarg = narg;
              }
#line 4902
              curarg = *((first + narg) - 1);
#line 4903
              curlen = *(len + (((first - args) + (long )narg) - 1L));
            }
          }
        }
      }
      {
#line 4909
      memset((void *)(flags), 0, sizeof(flags));
      }
      {
#line 4910
      while (1) {
        while_continue___44: /* CIL Label */ ;
#line 4910
        if (*c) {
          {
#line 4910
          flag = strchr((char const   *)flagch, (int )*c);
          }
#line 4910
          if (! flag) {
#line 4910
            goto while_break___44;
          }
        } else {
#line 4910
          goto while_break___44;
        }
#line 4911
        if (! flags[flag - flagch]) {
#line 4912
          flags[flag - flagch] = 1;
#line 4913
          tmp___58 = d___0;
#line 4913
          d___0 ++;
#line 4913
          *tmp___58 = *c;
        }
#line 4915
        c ++;
      }
      while_break___44: /* CIL Label */ ;
      }
#line 4918
      if ((int )typtab[(unsigned char )*c] & 1) {
        {
#line 4919
        tmp___59 = strtoul((char const   */* __restrict  */)c, (char **/* __restrict  */)(& endptr),
                           0);
#line 4919
        width = (int )tmp___59;
#line 4920
        c = endptr;
        }
      } else
#line 4921
      if ((int )*c == 42) {
#line 4922
        c ++;
#line 4922
        if ((int )typtab[(unsigned char )*c] & 1) {
          {
#line 4923
          tmp___60 = strtoul((char const   */* __restrict  */)c, (char **/* __restrict  */)(& endptr),
                             0);
#line 4923
          narg = (int )tmp___60;
          }
#line 4924
          if ((int )*endptr == 36) {
#line 4925
            c = endptr + 1;
#line 4926
            if (narg > argc) {
#line 4926
              goto _L___17;
            } else
#line 4926
            if (narg <= 0) {
              _L___17: /* CIL Label */ 
              {
#line 4927
              zwarnnam((char const   *)name, "%d: argument specifier out of range",
                       narg);
              }
#line 4930
              if ((unsigned long )fout != (unsigned long )stdout) {
                {
#line 4931
                fclose(fout);
                }
              }
#line 4933
              if (buf___7) {
                {
#line 4934
                free((void *)buf___7);
                }
              }
#line 4936
              return (1);
            } else {
#line 4938
              if (narg > maxarg) {
#line 4938
                maxarg = narg;
              }
#line 4939
              argp = (first + narg) - 1;
            }
          }
        }
#line 4943
        if (*argp) {
          {
#line 4944
          tmp___61 = argp;
#line 4944
          argp ++;
#line 4944
          tmp___62 = mathevali(*tmp___61);
#line 4944
          width = (int )tmp___62;
          }
#line 4945
          if (errflag) {
#line 4946
            errflag &= -2;
#line 4947
            ret = 1;
          }
        }
      }
#line 4951
      tmp___63 = d___0;
#line 4951
      d___0 ++;
#line 4951
      *tmp___63 = (char )'*';
#line 4953
      if ((int )*c == 46) {
#line 4954
        c ++;
#line 4954
        if ((int )*c == 42) {
#line 4955
          c ++;
#line 4955
          if ((int )typtab[(unsigned char )*c] & 1) {
            {
#line 4956
            tmp___64 = strtoul((char const   */* __restrict  */)c, (char **/* __restrict  */)(& endptr),
                               0);
#line 4956
            narg = (int )tmp___64;
            }
#line 4957
            if ((int )*endptr == 36) {
#line 4958
              c = endptr + 1;
#line 4959
              if (narg > argc) {
#line 4959
                goto _L___18;
              } else
#line 4959
              if (narg <= 0) {
                _L___18: /* CIL Label */ 
                {
#line 4960
                zwarnnam((char const   *)name, "%d: argument specifier out of range",
                         narg);
                }
#line 4963
                if ((unsigned long )fout != (unsigned long )stdout) {
                  {
#line 4964
                  fclose(fout);
                  }
                }
#line 4966
                if (buf___7) {
                  {
#line 4967
                  free((void *)buf___7);
                  }
                }
#line 4969
                return (1);
              } else {
#line 4971
                if (narg > maxarg) {
#line 4971
                  maxarg = narg;
                }
#line 4972
                argp = (first + narg) - 1;
              }
            }
          }
#line 4977
          if (*argp) {
            {
#line 4978
            tmp___65 = argp;
#line 4978
            argp ++;
#line 4978
            tmp___66 = mathevali(*tmp___65);
#line 4978
            prec___0 = (int )tmp___66;
            }
#line 4979
            if (errflag) {
#line 4980
              errflag &= -2;
#line 4981
              ret = 1;
            }
          }
        } else
#line 4984
        if ((int )typtab[(unsigned char )*c] & 1) {
          {
#line 4985
          tmp___67 = strtoul((char const   */* __restrict  */)c, (char **/* __restrict  */)(& endptr),
                             0);
#line 4985
          prec___0 = (int )tmp___67;
#line 4986
          c = endptr;
          }
        } else {
#line 4988
          prec___0 = 0;
        }
#line 4989
        if (prec___0 >= 0) {
#line 4989
          tmp___68 = d___0;
#line 4989
          d___0 ++;
#line 4989
          *tmp___68 = (char )'.';
#line 4989
          tmp___69 = d___0;
#line 4989
          d___0 ++;
#line 4989
          *tmp___69 = (char )'*';
        }
      }
#line 4993
      if ((int )*c == 108) {
#line 4993
        c ++;
      } else
#line 4993
      if ((int )*c == 76) {
#line 4993
        c ++;
      } else
#line 4993
      if ((int )*c == 104) {
#line 4993
        c ++;
      }
#line 4995
      if (! curarg) {
#line 4995
        if (*argp) {
#line 4996
          curarg = *argp;
#line 4997
          tmp___70 = argp;
#line 4997
          argp ++;
#line 4997
          curlen = *(len + (tmp___70 - args));
        }
      }
#line 4999
      *(d___0 + 1) = (char )'\000';
#line 5000
      tmp___71 = *c;
#line 5000
      *d___0 = tmp___71;
      {
#line 5001
      if ((int )tmp___71 == 99) {
#line 5001
        goto case_99;
      }
#line 5009
      if ((int )tmp___71 == 98) {
#line 5009
        goto case_98;
      }
#line 5009
      if ((int )tmp___71 == 115) {
#line 5009
        goto case_98;
      }
#line 5087
      if ((int )tmp___71 == 113) {
#line 5087
        goto case_113;
      }
#line 5095
      if ((int )tmp___71 == 105) {
#line 5095
        goto case_105;
      }
#line 5095
      if ((int )tmp___71 == 100) {
#line 5095
        goto case_105;
      }
#line 5102
      if ((int )tmp___71 == 71) {
#line 5102
        goto case_71;
      }
#line 5102
      if ((int )tmp___71 == 103) {
#line 5102
        goto case_71;
      }
#line 5102
      if ((int )tmp___71 == 102) {
#line 5102
        goto case_71;
      }
#line 5102
      if ((int )tmp___71 == 69) {
#line 5102
        goto case_71;
      }
#line 5102
      if ((int )tmp___71 == 101) {
#line 5102
        goto case_71;
      }
#line 5108
      if ((int )tmp___71 == 88) {
#line 5108
        goto case_88;
      }
#line 5108
      if ((int )tmp___71 == 120) {
#line 5108
        goto case_88;
      }
#line 5108
      if ((int )tmp___71 == 117) {
#line 5108
        goto case_88;
      }
#line 5108
      if ((int )tmp___71 == 111) {
#line 5108
        goto case_88;
      }
#line 5111
      if ((int )tmp___71 == 110) {
#line 5111
        goto case_110;
      }
#line 5114
      goto switch_default;
      case_99: /* CIL Label */ 
#line 5002
      if (curarg) {
#line 5003
        intval = (int )*curarg;
      } else {
#line 5005
        intval = 0;
      }
#line 5006
      if (prec___0 >= 0) {
        {
#line 5006
        tmp___72 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                           width, prec___0, intval);
#line 5006
        count += (size_t )tmp___72;
        }
      } else {
        {
#line 5006
        tmp___73 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                           width, intval);
#line 5006
        count += (size_t )tmp___73;
        }
      }
#line 5007
      goto switch_break;
      case_98: /* CIL Label */ 
      case_115: /* CIL Label */ 
#line 5010
      if (curarg) {
#line 5017
        if ((int )*c == 98) {
#line 5018
          if ((int )ops->ind[98] != 0) {
#line 5018
            tmp___74 = 7;
          } else {
#line 5018
            tmp___74 = 8;
          }
          {
#line 5018
          tmp___75 = metafy(curarg, curlen, 1);
#line 5018
          b = getkeystring(tmp___75, & lbytes, tmp___74, & nnl);
          }
        } else {
#line 5023
          b = curarg;
#line 5024
          lbytes = curlen;
        }
        {
#line 5036
        ptr___0 = b;
#line 5038
        memset((void *)(& mbs___0), 0, sizeof(mbs___0));
#line 5041
        lchars = 0;
#line 5041
        lleft = lbytes;
        }
        {
#line 5041
        while (1) {
          while_continue___45: /* CIL Label */ ;
#line 5041
          if (! (lleft > 0)) {
#line 5041
            goto while_break___45;
          }
#line 5044
          if (lchars == prec___0) {
#line 5046
            lbytes = (int )(ptr___0 - b);
#line 5047
            goto while_break___45;
          }
#line 5050
          if (opts[117]) {
            {
#line 5051
            tmp___76 = mbrlen((char const   */* __restrict  */)ptr___0, (size_t )lleft,
                              (mbstate_t */* __restrict  */)(& mbs___0));
#line 5051
            chars = (int )tmp___76;
            }
#line 5052
            if (chars < 0) {
#line 5059
              lchars += lleft;
#line 5060
              lbytes = (int )((ptr___0 - b) + (long )lleft);
#line 5061
              goto while_break___45;
            } else
#line 5062
            if (chars == 0) {
#line 5064
              chars = 1;
            }
          } else {
#line 5069
            chars = 1;
          }
#line 5070
          lleft -= chars;
#line 5071
          ptr___0 += chars;
#line 5041
          lchars ++;
        }
        while_break___45: /* CIL Label */ ;
        }
#line 5073
        if (width > 0) {
#line 5073
          if (flags[3]) {
#line 5073
            width = - width;
          }
        }
#line 5074
        if (width > 0) {
#line 5074
          if (lchars < width) {
            {
#line 5075
            tmp___77 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%*c",
                               width - lchars, ' ');
#line 5075
            count += (size_t )tmp___77;
            }
          }
        }
        {
#line 5076
        tmp___78 = fwrite((void const   */* __restrict  */)b, (size_t )1, (size_t )lbytes,
                          (FILE */* __restrict  */)fout);
#line 5076
        count += tmp___78;
        }
#line 5077
        if (width < 0) {
#line 5077
          if (lchars < - width) {
            {
#line 5078
            tmp___79 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%*c",
                               - width - lchars, ' ');
#line 5078
            count += (size_t )tmp___79;
            }
          }
        }
#line 5079
        if (nnl) {
#line 5081
          flen = (int )((c - fmt) + 1L);
#line 5082
          fmttrunc = 1;
        }
      } else
#line 5084
      if (width) {
        {
#line 5085
        tmp___80 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%*c",
                           width, ' ');
#line 5085
        count += (size_t )tmp___80;
        }
      }
#line 5086
      goto switch_break;
      case_113: /* CIL Label */ 
#line 5088
      if (curarg) {
        {
#line 5088
        tmp___81 = metafy(curarg, curlen, 1);
#line 5088
        tmp___82 = quotestring((char const   *)tmp___81, 8);
#line 5088
        stringval = tmp___82;
        }
      } else {
#line 5088
        stringval = & nullstr;
      }
#line 5091
      *d___0 = (char )'s';
#line 5092
      if (prec___0 >= 0) {
        {
#line 5092
        tmp___83 = unmetafy(stringval, & curlen);
#line 5092
        tmp___84 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                           width, prec___0, tmp___83);
#line 5092
        count += (size_t )tmp___84;
        }
      } else {
        {
#line 5092
        tmp___85 = unmetafy(stringval, & curlen);
#line 5092
        tmp___86 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                           width, tmp___85);
#line 5092
        count += (size_t )tmp___86;
        }
      }
#line 5093
      goto switch_break;
      case_105: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 5096
      type___0 = 1;
#line 5097
      goto switch_break;
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_102: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
#line 5103
      type___0 = 2;
#line 5104
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 5109
      type___0 = 3;
#line 5110
      goto switch_break;
      case_110: /* CIL Label */ 
#line 5112
      if (curarg) {
        {
#line 5112
        setiparam(curarg, (zlong )(count - rcount));
        }
      }
#line 5113
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 5115
      if (*c) {
#line 5116
        save = *(c + 1);
#line 5117
        *(c + 1) = (char )'\000';
      }
      {
#line 5119
      zwarnnam((char const   *)name, "%s: invalid directive", start);
      }
#line 5120
      if (*c) {
#line 5120
        *(c + 1) = save;
      }
#line 5122
      if ((unsigned long )fout != (unsigned long )stdout) {
#line 5122
        if ((int )ops->ind[122] != 0) {
#line 5122
          tmp___93 = 1;
        } else
#line 5122
        if ((int )ops->ind[115] != 0) {
#line 5122
          tmp___93 = 1;
        } else
#line 5122
        if ((int )ops->ind[118] != 0) {
#line 5122
          tmp___93 = 1;
        } else {
#line 5122
          goto _L___19;
        }
      } else {
        _L___19: /* CIL Label */ 
#line 5122
        if ((unsigned long )fout == (unsigned long )stdout) {
          {
#line 5122
          tmp___88 = fflush(fout);
          }
#line 5122
          if (tmp___88 == 0) {
#line 5122
            tmp___90 = 1;
          } else {
            {
#line 5122
            tmp___89 = __errno_location();
            }
#line 5122
            if (*tmp___89 == 9) {
#line 5122
              tmp___90 = 1;
            } else {
#line 5122
              tmp___90 = 0;
            }
          }
#line 5122
          tmp___92 = tmp___90;
        } else {
          {
#line 5122
          tmp___91 = fclose(fout);
#line 5122
          tmp___92 = tmp___91 == 0;
          }
        }
#line 5122
        tmp___93 = tmp___92;
      }
#line 5122
      if (! tmp___93) {
        {
#line 5123
        tmp___87 = __errno_location();
#line 5123
        zwarnnam((char const   *)name, "write error: %e", *tmp___87);
        }
      }
#line 5125
      if (buf___7) {
        {
#line 5126
        free((void *)buf___7);
        }
      }
#line 5128
      return (1);
      switch_break: /* CIL Label */ ;
      }
#line 5131
      if (type___0 > 0) {
#line 5132
        if (curarg) {
#line 5132
          if ((int )*curarg == 39) {
#line 5132
            goto _L___21;
          } else
#line 5132
          if ((int )*curarg == 34) {
            _L___21: /* CIL Label */ 
#line 5135
            if (opts[117]) {
              {
#line 5136
              mb_charinit();
#line 5137
              tmp___94 = metafy(curarg + 1, curlen - 1, 1);
#line 5137
              mb_metacharlenconv((char const   *)tmp___94, & cc);
              }
            } else {
#line 5141
              cc = 4294967295U;
            }
#line 5142
            if (cc == 4294967295U) {
#line 5143
              if (curlen > 1) {
#line 5143
                cc = (convchar_t )((unsigned char )*(curarg + 1));
              } else {
#line 5143
                cc = (convchar_t )0;
              }
            }
#line 5147
            if (type___0 == 2) {
#line 5148
              doubleval = (double )cc;
#line 5149
              if (prec___0 >= 0) {
                {
#line 5149
                tmp___95 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                                   width, prec___0, doubleval);
#line 5149
                count += (size_t )tmp___95;
                }
              } else {
                {
#line 5149
                tmp___96 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                                   width, doubleval);
#line 5149
                count += (size_t )tmp___96;
                }
              }
            } else {
#line 5151
              intval = (int )cc;
#line 5152
              if (prec___0 >= 0) {
                {
#line 5152
                tmp___97 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                                   width, prec___0, intval);
#line 5152
                count += (size_t )tmp___97;
                }
              } else {
                {
#line 5152
                tmp___98 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                                   width, intval);
#line 5152
                count += (size_t )tmp___98;
                }
              }
            }
          } else {
#line 5132
            goto _L___20;
          }
        } else {
          _L___20: /* CIL Label */ 
          {
#line 5156
          if (type___0 == 1) {
#line 5156
            goto case_1;
          }
#line 5169
          if (type___0 == 2) {
#line 5169
            goto case_2;
          }
#line 5198
          if (type___0 == 3) {
#line 5198
            goto case_3;
          }
#line 5155
          goto switch_break___0;
          case_1: /* CIL Label */ 
#line 5160
          tmp___99 = d___0;
#line 5160
          d___0 ++;
#line 5160
          *tmp___99 = (char )'l';
#line 5160
          tmp___100 = d___0;
#line 5160
          d___0 ++;
#line 5160
          *tmp___100 = *c;
#line 5160
          *d___0 = (char )'\000';
#line 5161
          if (curarg) {
            {
#line 5161
            tmp___101 = mathevali(curarg);
#line 5161
            zlongval = tmp___101;
            }
          } else {
#line 5161
            zlongval = (zlong )0;
          }
#line 5162
          if (errflag) {
#line 5163
            zlongval = (zlong )0;
#line 5164
            errflag &= -2;
#line 5165
            ret = 1;
          }
#line 5167
          if (prec___0 >= 0) {
            {
#line 5167
            tmp___102 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                                width, prec___0, zlongval);
#line 5167
            count += (size_t )tmp___102;
            }
          } else {
            {
#line 5167
            tmp___103 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                                width, zlongval);
#line 5167
            count += (size_t )tmp___103;
            }
          }
#line 5168
          goto switch_break___0;
          case_2: /* CIL Label */ 
#line 5170
          if (curarg) {
            {
#line 5180
            doubleval = strtod((char const   */* __restrict  */)curarg, (char **/* __restrict  */)(& eptr___2));
            }
#line 5185
            if ((int )*eptr___2 != 0) {
              {
#line 5186
              mnumval = matheval(curarg);
              }
#line 5187
              if (mnumval.type & 2) {
#line 5187
                doubleval = mnumval.u.d;
              } else {
#line 5187
                doubleval = (double )mnumval.u.l;
              }
            }
          } else {
#line 5190
            doubleval = (double )0;
          }
#line 5191
          if (errflag) {
#line 5192
            doubleval = (double )0;
#line 5193
            errflag &= -2;
#line 5194
            ret = 1;
          }
#line 5196
          if (prec___0 >= 0) {
            {
#line 5196
            tmp___104 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                                width, prec___0, doubleval);
#line 5196
            count += (size_t )tmp___104;
            }
          } else {
            {
#line 5196
            tmp___105 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                                width, doubleval);
#line 5196
            count += (size_t )tmp___105;
            }
          }
#line 5197
          goto switch_break___0;
          case_3: /* CIL Label */ 
#line 5202
          tmp___106 = d___0;
#line 5202
          d___0 ++;
#line 5202
          *tmp___106 = (char )'l';
#line 5202
          tmp___107 = d___0;
#line 5202
          d___0 ++;
#line 5202
          *tmp___107 = *c;
#line 5202
          *d___0 = (char )'\000';
#line 5203
          if (curarg) {
            {
#line 5203
            tmp___108 = mathevali(curarg);
#line 5203
            zulongval = (zulong )tmp___108;
            }
          } else {
#line 5203
            zulongval = (zulong )0;
          }
#line 5204
          if (errflag) {
#line 5205
            zulongval = (zulong )0;
#line 5206
            errflag &= -2;
#line 5207
            ret = 1;
          }
#line 5209
          if (prec___0 >= 0) {
            {
#line 5209
            tmp___109 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                                width, prec___0, zulongval);
#line 5209
            count += (size_t )tmp___109;
            }
          } else {
            {
#line 5209
            tmp___110 = fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)(spec),
                                width, zulongval);
#line 5209
            count += (size_t )tmp___110;
            }
          }
          switch_break___0: /* CIL Label */ ;
          }
        }
      }
#line 5213
      if (maxarg) {
#line 5213
        if (argp - first > (long )maxarg) {
#line 5214
          maxarg = (int )(argp - first);
        }
      }
      __Cont___0: /* CIL Label */ 
#line 4866
      c ++;
    }
    while_break___43: /* CIL Label */ ;
    }
#line 5217
    if (maxarg) {
#line 5217
      argp = first + maxarg;
    }
#line 4853
    if (*argp) {
#line 4853
      if ((unsigned long )argp != (unsigned long )first) {
#line 4853
        if (! fmttrunc) {
#line 4853
          if (! (! ((int )ops->ind[114] != 0))) {
#line 4853
            goto while_break___42;
          }
        } else {
#line 4853
          goto while_break___42;
        }
      } else {
#line 4853
        goto while_break___42;
      }
    } else {
#line 4853
      goto while_break___42;
    }
  }
  while_break___42: /* CIL Label */ ;
  }
#line 5221
  if ((unsigned long )fout != (unsigned long )stdout) {
#line 5221
    if ((int )ops->ind[122] != 0) {
#line 5221
      goto _L___23;
    } else
#line 5221
    if ((int )ops->ind[115] != 0) {
#line 5221
      goto _L___23;
    } else
#line 5221
    if ((int )ops->ind[118] != 0) {
      _L___23: /* CIL Label */ 
      {
#line 5222
      queueing_enabled ++;
#line 5223
      tmp___116 = fclose(fout);
      }
#line 5223
      if (tmp___116 == 0) {
#line 5223
        rcount = mcount;
      } else {
#line 5223
        rcount = (size_t )-1;
      }
#line 5223
      if (rcount == 0xffffffffffffffffUL) {
        {
#line 5224
        tmp___111 = __errno_location();
#line 5224
        zwarnnam((char const   *)name, "i/o error: %e", *tmp___111);
        }
#line 5225
        if (buf___7) {
          {
#line 5226
          free((void *)buf___7);
          }
        }
      } else
#line 5228
      if (visarr) {
#line 5228
        if (splits) {
          {
#line 5229
          tmp___112 = zshcalloc((unsigned long )((cursplit - splits) + 2L) * sizeof(char *));
#line 5229
          arrayval = (char **)tmp___112;
          }
          {
#line 5230
          while (1) {
            while_continue___46: /* CIL Label */ ;
#line 5230
            if (! ((unsigned long )cursplit >= (unsigned long )splits)) {
#line 5230
              goto while_break___46;
            }
#line 5231
            if ((unsigned long )cursplit == (unsigned long )splits) {
#line 5231
              tmp___113 = (size_t )0;
            } else {
#line 5231
              tmp___113 = *(cursplit + -1);
            }
            {
#line 5231
            start___0 = (int )tmp___113;
#line 5232
            *(arrayval + (cursplit - splits)) = metafy(buf___7 + start___0, (int )(count - (size_t )start___0),
                                                       3);
#line 5234
            count = (size_t )start___0;
#line 5230
            cursplit --;
            }
          }
          while_break___46: /* CIL Label */ ;
          }
          {
#line 5236
          setaparam(*(ops->args + (((int )ops->ind[118] >> 2) - 1)), arrayval);
#line 5237
          free((void *)buf___7);
          }
        } else {
#line 5228
          goto _L___22;
        }
      } else {
        _L___22: /* CIL Label */ 
        {
#line 5239
        stringval = metafy(buf___7, (int )rcount, 0);
        }
#line 5240
        if ((int )ops->ind[122] != 0) {
          {
#line 5241
          zinsertlinknode(bufstack, & bufstack->node, (void *)stringval);
          }
        } else
#line 5242
        if ((int )ops->ind[118] != 0) {
          {
#line 5243
          setsparam(*(ops->args + (((int )ops->ind[118] >> 2) - 1)), stringval);
          }
        } else {
          {
#line 5245
          ent = prepnexthistent();
#line 5246
          ent->node.nam = stringval;
#line 5247
          tmp___114 = time((time_t *)((void *)0));
#line 5247
          ent->ftim = tmp___114;
#line 5247
          ent->stim = tmp___114;
#line 5248
          ent->node.flags = 0;
#line 5249
          ent->words = (short *)((void *)0);
#line 5250
          addhistnode(histtab, ent->node.nam, (void *)ent);
          }
        }
      }
      {
#line 5254
      while (1) {
        while_continue___47: /* CIL Label */ ;
#line 5254
        queueing_enabled --;
#line 5254
        if (! queueing_enabled) {
          {
#line 5254
          while (1) {
            while_continue___48: /* CIL Label */ ;
            {
#line 5254
            while (1) {
              while_continue___49: /* CIL Label */ ;
#line 5254
              if (! (queue_front != queue_rear)) {
#line 5254
                goto while_break___49;
              }
              {
#line 5254
              queue_front = (queue_front + 1) % 128;
#line 5254
              oset___7 = signal_setmask(signal_mask_queue[queue_front]);
#line 5254
              zhandler(signal_queue[queue_front]);
#line 5254
              signal_setmask(oset___7);
              }
            }
            while_break___49: /* CIL Label */ ;
            }
#line 5254
            goto while_break___48;
          }
          while_break___48: /* CIL Label */ ;
          }
        }
#line 5254
        goto while_break___47;
      }
      while_break___47: /* CIL Label */ ;
      }
    }
  }
#line 5257
  if ((unsigned long )fout != (unsigned long )stdout) {
#line 5257
    if ((int )ops->ind[122] != 0) {
#line 5257
      tmp___123 = 1;
    } else
#line 5257
    if ((int )ops->ind[115] != 0) {
#line 5257
      tmp___123 = 1;
    } else
#line 5257
    if ((int )ops->ind[118] != 0) {
#line 5257
      tmp___123 = 1;
    } else {
#line 5257
      goto _L___24;
    }
  } else {
    _L___24: /* CIL Label */ 
#line 5257
    if ((unsigned long )fout == (unsigned long )stdout) {
      {
#line 5257
      tmp___118 = fflush(fout);
      }
#line 5257
      if (tmp___118 == 0) {
#line 5257
        tmp___120 = 1;
      } else {
        {
#line 5257
        tmp___119 = __errno_location();
        }
#line 5257
        if (*tmp___119 == 9) {
#line 5257
          tmp___120 = 1;
        } else {
#line 5257
          tmp___120 = 0;
        }
      }
#line 5257
      tmp___122 = tmp___120;
    } else {
      {
#line 5257
      tmp___121 = fclose(fout);
#line 5257
      tmp___122 = tmp___121 == 0;
      }
    }
#line 5257
    tmp___123 = tmp___122;
  }
#line 5257
  if (! tmp___123) {
    {
#line 5259
    tmp___117 = __errno_location();
#line 5259
    zwarnnam((char const   *)name, "write error: %e", *tmp___117);
#line 5260
    ret = 1;
    }
  }
#line 5262
  return (ret);
}
}
#line 5268 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_shift(char *name , char **argv , Options ops , int func  __attribute__((__unused__)) ) 
{ 
  int num ;
  int l ;
  int ret ;
  char **s ;
  char **tmp ;
  zlong tmp___0 ;
  char **tmp___1 ;
  sigset_t oset ;
  char tmp___2 ;
  char **s2 ;
  char **src ;
  char **dst ;
  int count ;
  void *tmp___3 ;
  char **tmp___4 ;
  char **tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  sigset_t oset___0 ;

  {
#line 5271
  num = 1;
#line 5271
  ret = 0;
#line 5275
  queueing_enabled ++;
#line 5276
  if (*argv) {
    {
#line 5276
    tmp___1 = getaparam(*argv);
    }
#line 5276
    if (! tmp___1) {
      {
#line 5277
      tmp = argv;
#line 5277
      argv ++;
#line 5277
      tmp___0 = mathevali(*tmp);
#line 5277
      num = (int )tmp___0;
      }
    }
  }
#line 5279
  if (num < 0) {
    {
#line 5280
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5280
      queueing_enabled --;
#line 5280
      if (! queueing_enabled) {
        {
#line 5280
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 5280
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 5280
            if (! (queue_front != queue_rear)) {
#line 5280
              goto while_break___1;
            }
            {
#line 5280
            queue_front = (queue_front + 1) % 128;
#line 5280
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 5280
            zhandler(signal_queue[queue_front]);
#line 5280
            signal_setmask(oset);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 5280
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 5280
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 5281
    zwarnnam((char const   *)name, "argument to shift must be non-negative");
    }
#line 5282
    return (1);
  }
#line 5285
  if (*argv) {
    {
#line 5286
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 5286
      if (! *argv) {
#line 5286
        goto while_break___2;
      }
      {
#line 5287
      s = getaparam(*argv);
      }
#line 5287
      if (s) {
        {
#line 5288
        tmp___2 = arrlen_lt(s, (unsigned int )num);
        }
#line 5288
        if (tmp___2) {
          {
#line 5289
          zwarnnam((char const   *)name, "shift count must be <= $#");
#line 5290
          ret ++;
          }
#line 5291
          goto __Cont;
        }
#line 5293
        if ((int )ops->ind[112] != 0) {
          {
#line 5296
          l = arrlen(s);
#line 5297
          src = s;
#line 5298
          tmp___3 = zalloc((unsigned long )((l - num) + 1) * sizeof(char *));
#line 5298
          s2 = (char **)tmp___3;
#line 5298
          dst = s2;
#line 5299
          count = l - num;
          }
          {
#line 5299
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 5299
            if (! count) {
#line 5299
              goto while_break___3;
            }
            {
#line 5300
            tmp___4 = dst;
#line 5300
            dst ++;
#line 5300
            tmp___5 = src;
#line 5300
            src ++;
#line 5300
            *tmp___4 = ztrdup((char const   *)*tmp___5);
#line 5299
            count --;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 5301
          *dst = (char *)((void *)0);
#line 5302
          s = s2;
        } else {
          {
#line 5304
          s = zarrdup(s + num);
          }
        }
        {
#line 5306
        setaparam(*argv, s);
        }
      }
      __Cont: /* CIL Label */ 
#line 5286
      argv ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 5309
    l = arrlen(pparams);
    }
#line 5309
    if (num > l) {
      {
#line 5310
      zwarnnam((char const   *)name, "shift count must be <= $#");
#line 5311
      ret = 1;
      }
    } else {
      {
#line 5313
      tmp___6 = zalloc((unsigned long )((l - num) + 1) * sizeof(char *));
#line 5313
      s = (char **)tmp___6;
      }
#line 5314
      if ((int )ops->ind[112] != 0) {
        {
#line 5315
        memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)pparams,
               (unsigned long )(l - num) * sizeof(char *));
#line 5316
        *(s + (l - num)) = (char *)((void *)0);
        }
        {
#line 5317
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 5317
          tmp___7 = num;
#line 5317
          num --;
#line 5317
          if (! tmp___7) {
#line 5317
            goto while_break___4;
          }
          {
#line 5318
          zsfree(*(pparams + ((l - 1) - num)));
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
        {
#line 5320
        memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)(pparams + num),
               (unsigned long )((l - num) + 1) * sizeof(char *));
        }
        {
#line 5321
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 5321
          tmp___8 = num;
#line 5321
          num --;
#line 5321
          if (! tmp___8) {
#line 5321
            goto while_break___5;
          }
          {
#line 5322
          zsfree(*(pparams + num));
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      {
#line 5324
      zfree((void *)pparams, (int )((unsigned long )(l + 1) * sizeof(char *)));
#line 5325
      pparams = s;
      }
    }
  }
  {
#line 5328
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 5328
    queueing_enabled --;
#line 5328
    if (! queueing_enabled) {
      {
#line 5328
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 5328
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 5328
          if (! (queue_front != queue_rear)) {
#line 5328
            goto while_break___8;
          }
          {
#line 5328
          queue_front = (queue_front + 1) % 128;
#line 5328
          oset___0 = signal_setmask(signal_mask_queue[queue_front]);
#line 5328
          zhandler(signal_queue[queue_front]);
#line 5328
          signal_setmask(oset___0);
          }
        }
        while_break___8: /* CIL Label */ ;
        }
#line 5328
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 5328
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 5329
  return (ret);
}
}
#line 5342 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_getopts(char *name  __attribute__((__unused__)) , char **argv , Options ops  __attribute__((__unused__)) ,
                int func  __attribute__((__unused__)) ) 
{ 
  int lenstr ;
  int lenoptstr ;
  int quiet ;
  int lenoptbuf ;
  char *optstr ;
  char **tmp ;
  char *tmp___0 ;
  char *var ;
  char **tmp___1 ;
  char **args ;
  char **tmp___2 ;
  char *str ;
  char optbuf[2] ;
  char *p ;
  char opch ;
  char tmp___3 ;
  char *tmp___4 ;
  zlong tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  void *tmp___10 ;
  zlong tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 5346
  tmp = argv;
#line 5346
  argv ++;
#line 5346
  tmp___0 = unmetafy(*tmp, & lenoptstr);
#line 5346
  optstr = tmp___0;
#line 5346
  tmp___1 = argv;
#line 5346
  argv ++;
#line 5346
  var = *tmp___1;
  }
#line 5347
  if (*argv) {
#line 5347
    tmp___2 = argv;
  } else {
#line 5347
    tmp___2 = pparams;
  }
#line 5347
  args = tmp___2;
#line 5348
  optbuf[0] = (char )' ';
#line 5348
  optbuf[1] = (char )'\000';
#line 5352
  if (zoptind < 1L) {
#line 5354
    zoptind = (zlong )1;
#line 5355
    optcind = 0;
  }
  {
#line 5357
  tmp___3 = arrlen_lt(args, (unsigned int )zoptind);
  }
#line 5357
  if (tmp___3) {
#line 5359
    return (1);
  }
  {
#line 5362
  quiet = (int )*optstr == 58;
#line 5363
  optstr += quiet;
#line 5364
  lenoptstr -= quiet;
#line 5367
  tmp___4 = dupstring((char const   *)*(args + (zoptind - 1L)));
#line 5367
  str = unmetafy(tmp___4, & lenstr);
  }
#line 5368
  if (! lenstr) {
#line 5369
    return (1);
  }
#line 5370
  if (optcind >= lenstr) {
#line 5371
    optcind = 0;
#line 5372
    tmp___5 = zoptind;
#line 5372
    zoptind ++;
#line 5372
    if (! *(args + tmp___5)) {
#line 5373
      return (1);
    }
    {
#line 5374
    tmp___6 = dupstring((char const   *)*(args + (zoptind - 1L)));
#line 5374
    str = unmetafy(tmp___6, & lenstr);
    }
  }
#line 5376
  if (! optcind) {
#line 5377
    if (lenstr < 2) {
#line 5378
      return (1);
    } else
#line 5377
    if ((int )*str != 45) {
#line 5377
      if ((int )*str != 43) {
#line 5378
        return (1);
      }
    }
#line 5379
    if (lenstr == 2) {
#line 5379
      if ((int )*(str + 0) == 45) {
#line 5379
        if ((int )*(str + 1) == 45) {
#line 5380
          zoptind ++;
#line 5381
          return (1);
        }
      }
    }
#line 5383
    optcind ++;
  }
#line 5385
  tmp___7 = optcind;
#line 5385
  optcind ++;
#line 5385
  opch = *(str + tmp___7);
#line 5386
  if ((int )*(str + 0) == 43) {
#line 5387
    optbuf[0] = (char )'+';
#line 5388
    lenoptbuf = 2;
  } else {
#line 5390
    lenoptbuf = 1;
  }
#line 5391
  optbuf[lenoptbuf - 1] = opch;
#line 5394
  if ((int )opch == 58) {
#line 5394
    goto _L;
  } else {
    {
#line 5394
    tmp___10 = memchr((void const   *)optstr, (int )opch, (size_t )lenoptstr);
#line 5394
    p = (char *)tmp___10;
    }
#line 5394
    if (! p) {
      _L: /* CIL Label */ 
#line 5395
      p = (char *)"?";
      err: 
      {
#line 5397
      zsfree(zoptarg);
#line 5398
      tmp___8 = ztrdup((char const   *)p);
#line 5398
      setsparam(var, tmp___8);
      }
#line 5399
      if (quiet) {
        {
#line 5400
        zoptarg = metafy(optbuf, lenoptbuf, 3);
        }
      } else {
#line 5402
        if ((int )*p == 63) {
#line 5402
          tmp___9 = "bad option: -%c";
        } else {
#line 5402
          tmp___9 = "argument expected after -%c option";
        }
        {
#line 5402
        zwarn(tmp___9, (int )opch);
#line 5404
        zoptarg = ztrdup("");
        }
      }
#line 5406
      return (0);
    }
  }
#line 5410
  if ((int )*(p + 1) == 58) {
#line 5411
    if (optcind == lenstr) {
#line 5412
      if (! *(args + zoptind)) {
#line 5413
        p = (char *)":";
#line 5414
        goto err;
      }
      {
#line 5416
      tmp___11 = zoptind;
#line 5416
      zoptind ++;
#line 5416
      p = ztrdup((char const   *)*(args + tmp___11));
      }
    } else {
      {
#line 5418
      p = metafy(str + optcind, lenstr - optcind, 3);
      }
    }
    {
#line 5426
    optcind = 0;
#line 5427
    zoptind ++;
#line 5428
    zsfree(zoptarg);
#line 5429
    zoptarg = p;
    }
  } else {
    {
#line 5431
    zsfree(zoptarg);
#line 5432
    zoptarg = ztrdup("");
    }
  }
  {
#line 5435
  tmp___12 = metafy(optbuf, lenoptbuf, 3);
#line 5435
  setsparam(var, tmp___12);
  }
#line 5436
  return (0);
}
}
#line 5454 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_break(char *name , char **argv , Options ops  __attribute__((__unused__)) ,
              int func ) 
{ 
  int num ;
  int nump ;
  int implicit ;
  char **tmp ;
  zlong tmp___0 ;
  int tmp___1 ;

  {
#line 5457
  num = (int )lastval;
#line 5457
  nump = 0;
#line 5460
  implicit = ! *argv;
#line 5461
  if (*argv) {
    {
#line 5462
    tmp = argv;
#line 5462
    argv ++;
#line 5462
    tmp___0 = mathevali(*tmp);
#line 5462
    num = (int )tmp___0;
#line 5463
    nump = 1;
    }
  }
#line 5466
  if (nump > 0) {
#line 5466
    if (func == 7) {
#line 5466
      goto _L;
    } else
#line 5466
    if (func == 6) {
      _L: /* CIL Label */ 
#line 5466
      if (num <= 0) {
        {
#line 5467
        zerrnam((char const   *)name, "argument is not positive: %d", num);
        }
#line 5468
        return (1);
      }
    }
  }
  {
#line 5472
  if (func == 7) {
#line 5472
    goto case_7;
  }
#line 5478
  if (func == 6) {
#line 5478
    goto case_6;
  }
#line 5485
  if (func == 9) {
#line 5485
    goto case_9;
  }
#line 5505
  if (func == 19) {
#line 5505
    goto case_19;
  }
#line 5511
  if (func == 8) {
#line 5511
    goto case_8;
  }
#line 5471
  goto switch_break;
  case_7: /* CIL Label */ 
#line 5473
  if (! loops) {
    {
#line 5474
    zerrnam((char const   *)name, "not in while, until, select, or repeat loop");
    }
#line 5475
    return (1);
  }
#line 5477
  contflag = 1;
  case_6: /* CIL Label */ 
#line 5479
  if (! loops) {
    {
#line 5480
    zerrnam((char const   *)name, "not in while, until, select, or repeat loop");
    }
#line 5481
    return (1);
  }
#line 5483
  if (nump) {
#line 5483
    if (num < loops) {
#line 5483
      tmp___1 = num;
    } else {
#line 5483
      tmp___1 = loops;
    }
#line 5483
    breaks = tmp___1;
  } else {
#line 5483
    breaks = 1;
  }
#line 5484
  goto switch_break;
  case_9: /* CIL Label */ 
#line 5486
  if (opts[93]) {
#line 5486
    if (opts[160]) {
#line 5486
      goto _L___0;
    } else {
#line 5486
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 5486
  if (locallevel) {
#line 5486
    goto _L___0;
  } else
#line 5486
  if (sourcelevel) {
    _L___0: /* CIL Label */ 
#line 5488
    retflag = 1;
#line 5489
    breaks = loops;
#line 5490
    lastval = (zlong )num;
#line 5491
    if (trap_state == 1) {
#line 5491
      if (trap_return == -2) {
#line 5491
        if (opts[136]) {
#line 5491
          if (! implicit) {
#line 5498
            trap_state = 2;
#line 5499
            trap_return = (int )lastval;
          }
        } else {
#line 5498
          trap_state = 2;
#line 5499
          trap_return = (int )lastval;
        }
      }
    }
#line 5501
    return ((int )lastval);
  }
  {
#line 5503
  zexit(num, 0);
  }
#line 5504
  goto switch_break;
  case_19: /* CIL Label */ 
#line 5506
  if (! opts[110]) {
    {
#line 5507
    zerrnam((char const   *)name, "not login shell");
    }
#line 5508
    return (1);
  }
  case_8: /* CIL Label */ 
#line 5512
  if (locallevel > forklevel) {
#line 5512
    if (shell_exiting != -1) {
#line 5525
      if (stopmsg) {
#line 5526
        retflag = 1;
#line 5527
        breaks = loops;
#line 5528
        exit_pending = (num << 1) | 1;
#line 5529
        exit_level = locallevel;
      } else {
        {
#line 5525
        zexit(0, 2);
        }
#line 5525
        if (! stopmsg) {
#line 5526
          retflag = 1;
#line 5527
          breaks = loops;
#line 5528
          exit_pending = (num << 1) | 1;
#line 5529
          exit_level = locallevel;
        }
      }
    } else {
      {
#line 5532
      zexit(num, 0);
      }
    }
  } else {
    {
#line 5532
    zexit(num, 0);
    }
  }
#line 5533
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 5535
  return (0);
}
}
#line 5546 "/tmp/zsh-5.4.2/Src/builtin.c"
static void checkjobs(void) 
{ 
  int i ;

  {
#line 5551
  i = 1;
  {
#line 5551
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5551
    if (! (i <= maxjob)) {
#line 5551
      goto while_break;
    }
#line 5552
    if (i != thisjob) {
#line 5552
      if ((jobtab + i)->stat & 16) {
#line 5552
        if (! ((jobtab + i)->stat & 32)) {
#line 5554
          goto while_break;
        }
      }
    }
#line 5551
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5555
  if (i <= maxjob) {
#line 5556
    if ((jobtab + i)->stat & 2) {
      {
#line 5559
      zerr("you have suspended jobs.");
      }
    } else {
      {
#line 5565
      zerr("you have running jobs.");
      }
    }
#line 5566
    stopmsg = 1;
  }
#line 5568
  return;
}
}
#line 5586 "/tmp/zsh-5.4.2/Src/builtin.c"
void zexit(int val , int from_where ) 
{ 
  int tmp ;
  int writeflags ;
  __pid_t tmp___0 ;

  {
#line 5590
  if (shell_exiting == -1) {
#line 5591
    return;
  }
#line 5593
  if (opts[116]) {
#line 5593
    if (! stopmsg) {
#line 5593
      if (from_where != 1) {
        {
#line 5594
        scanjobs();
        }
#line 5595
        if (opts[32]) {
          {
#line 5596
          checkjobs();
          }
        }
#line 5597
        if (stopmsg) {
#line 5598
          stopmsg = 2;
#line 5599
          return;
        }
      }
    }
  }
#line 5603
  if (from_where == 2) {
#line 5604
    return;
  } else {
#line 5603
    tmp = shell_exiting;
#line 5603
    shell_exiting ++;
#line 5603
    if (tmp) {
#line 5603
      if (from_where) {
#line 5604
        return;
      }
    }
  }
#line 5610
  shell_exiting = -1;
#line 5615
  errflag = 0;
#line 5617
  if (opts[116]) {
    {
#line 5619
    killrunjobs(from_where == 1);
    }
  }
#line 5621
  if (opts[151]) {
#line 5621
    if (opts[93]) {
#line 5622
      if (! nohistsave) {
#line 5623
        writeflags = 32768;
#line 5624
        if (from_where == 1) {
#line 5625
          writeflags |= 32;
        }
        {
#line 5626
        saveandpophiststack(1, writeflags);
#line 5627
        savehistfile((char *)((void *)0), 1, writeflags);
        }
      }
#line 5629
      if (opts[110]) {
#line 5629
        if (! subsh) {
          {
#line 5630
          sourcehome((char *)".zlogout");
          }
#line 5632
          if (opts[151]) {
#line 5632
            if (opts[61]) {
              {
#line 5633
              source((char *)"/etc/zlogout");
              }
            }
          }
        }
      }
    }
  }
#line 5637
  lastval = (zlong )val;
#line 5642
  intrap = 0;
#line 5642
  errflag = intrap;
#line 5643
  if (sigtrapped[0]) {
    {
#line 5644
    dotrap(0);
    }
  }
  {
#line 5645
  callhookfunc((char *)"zshexit", (LinkList )((void *)0), 1, (int *)((void *)0));
#line 5646
  runhookdef(zshhooks + 0, (void *)0);
  }
#line 5647
  if (opts[116]) {
#line 5647
    if (opts[93]) {
#line 5647
      if (SHTTY != -1) {
        {
#line 5648
        release_pgrp();
        }
      }
    }
  }
  {
#line 5650
  tmp___0 = getpid();
  }
#line 5650
  if (mypid != (zlong )tmp___0) {
    {
#line 5651
    _exit(val);
    }
  } else {
    {
#line 5653
    exit(val);
    }
  }
}
}
#line 5659 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_dot(char *name , char **argv , Options ops  __attribute__((__unused__)) ,
            int func  __attribute__((__unused__)) ) 
{ 
  char **old ;
  char *old0 ;
  int diddot ;
  int dotdot ;
  char *s ;
  char **t ;
  char *enam ;
  char *arg0 ;
  char *buf___7 ;
  struct stat st___0 ;
  enum source_return ret ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  zlong tmp___6 ;

  {
#line 5662
  old0 = (char *)((void *)0);
#line 5663
  diddot = 0;
#line 5663
  dotdot = 0;
#line 5668
  if (! *argv) {
#line 5669
    return (0);
  }
#line 5670
  old = pparams;
#line 5672
  if (*(argv + 1)) {
    {
#line 5673
    pparams = zarrdup(argv + 1);
    }
  }
  {
#line 5675
  arg0 = ztrdup((char const   *)*argv);
#line 5675
  enam = arg0;
  }
#line 5676
  if (opts[58]) {
    {
#line 5677
    old0 = argzero;
#line 5678
    argzero = ztrdup((char const   *)arg0);
    }
  }
  {
#line 5680
  s = unmeta((char const   *)enam);
#line 5681
  tmp = __errno_location();
#line 5681
  *tmp = 2;
#line 5682
  ret = (enum source_return )1;
  }
#line 5684
  if ((int )*name != 46) {
    {
#line 5684
    tmp___0 = access((char const   *)s, 0);
    }
#line 5684
    if (tmp___0 == 0) {
      {
#line 5684
      tmp___1 = stat((char const   */* __restrict  */)s, (struct stat */* __restrict  */)(& st___0));
      }
#line 5684
      if (tmp___1 >= 0) {
#line 5684
        if (! ((st___0.st_mode & 61440U) == 16384U)) {
          {
#line 5686
          diddot = 1;
#line 5687
          ret = source(enam);
          }
        }
      }
    }
  }
#line 5689
  if ((unsigned int )ret == 1U) {
#line 5691
    s = arg0;
    {
#line 5691
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5691
      if (! *s) {
#line 5691
        goto while_break;
      }
#line 5692
      if ((int )*s == 47) {
#line 5693
        if ((int )*arg0 == 46) {
#line 5694
          if ((unsigned long )(arg0 + 1) == (unsigned long )s) {
#line 5695
            diddot ++;
          } else
#line 5696
          if ((int )*(arg0 + 1) == 46) {
#line 5696
            if ((unsigned long )(arg0 + 2) == (unsigned long )s) {
#line 5697
              dotdot ++;
            }
          }
        }
        {
#line 5699
        ret = source(arg0);
        }
#line 5700
        goto while_break;
      }
#line 5691
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 5702
    if (! *s) {
#line 5702
      goto _L___0;
    } else
#line 5702
    if ((unsigned int )ret == 1U) {
#line 5702
      if (opts[126]) {
#line 5702
        if (diddot < 2) {
#line 5702
          if (dotdot == 0) {
            _L___0: /* CIL Label */ 
            {
#line 5704
            pushheap();
#line 5706
            t = path;
            }
            {
#line 5706
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 5706
              if (! *t) {
#line 5706
                goto while_break___0;
              }
#line 5707
              if (! *(*t + 0)) {
#line 5707
                goto _L;
              } else
#line 5707
              if ((int )*(*t + 0) == 46) {
#line 5707
                if (! *(*t + 1)) {
                  _L: /* CIL Label */ 
#line 5708
                  if (diddot) {
#line 5709
                    goto __Cont;
                  }
                  {
#line 5710
                  diddot = 1;
#line 5711
                  buf___7 = dupstring((char const   *)arg0);
                  }
                } else {
                  {
#line 5713
                  buf___7 = zhtricat((char const   *)*t, "/", (char const   *)arg0);
                  }
                }
              } else {
                {
#line 5713
                buf___7 = zhtricat((char const   *)*t, "/", (char const   *)arg0);
                }
              }
              {
#line 5715
              s = unmeta((char const   *)buf___7);
#line 5716
              tmp___2 = access((char const   *)s, 0);
              }
#line 5716
              if (tmp___2 == 0) {
                {
#line 5716
                tmp___3 = stat((char const   */* __restrict  */)s, (struct stat */* __restrict  */)(& st___0));
                }
#line 5716
                if (tmp___3 >= 0) {
#line 5716
                  if (! ((st___0.st_mode & 61440U) == 16384U)) {
                    {
#line 5718
                    enam = buf___7;
#line 5718
                    ret = source(enam);
                    }
#line 5719
                    goto while_break___0;
                  }
                }
              }
              __Cont: /* CIL Label */ 
#line 5706
              t ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 5722
            popheap();
            }
          }
        }
      }
    }
  }
#line 5726
  if (*(argv + 1)) {
    {
#line 5727
    freearray(pparams);
#line 5728
    pparams = old;
    }
  }
#line 5730
  if ((unsigned int )ret == 1U) {
#line 5731
    if (opts[131]) {
      {
#line 5733
      tmp___4 = __errno_location();
#line 5733
      zerrnam((char const   *)name, "%e: %s", *tmp___4, enam);
      }
    } else {
      {
#line 5735
      tmp___5 = __errno_location();
#line 5735
      zwarnnam((char const   *)name, "%e: %s", *tmp___5, enam);
      }
    }
  }
  {
#line 5738
  zsfree(arg0);
  }
#line 5739
  if (old0) {
    {
#line 5740
    zsfree(argzero);
#line 5741
    argzero = old0;
    }
  }
#line 5743
  if ((unsigned int )ret == 0U) {
#line 5743
    tmp___6 = lastval;
  } else {
#line 5743
    tmp___6 = (zlong )(128U - (unsigned int )ret);
  }
#line 5743
  return ((int )tmp___6);
}
}
#line 5750 "/tmp/zsh-5.4.2/Src/builtin.c"
static int eval(char **argv ) 
{ 
  Eprog prog ;
  char *oscriptname ;
  int oineval ;
  int fpushed ;
  struct funcstack fstack ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 5754
  oscriptname = scriptname;
#line 5755
  oineval = ineval;
#line 5763
  ineval = ! opts[55];
#line 5764
  if (! ineval) {
#line 5765
    scriptname = (char *)"(eval)";
#line 5766
    fstack.prev = funcstack;
#line 5767
    fstack.name = scriptname;
#line 5768
    if (funcstack) {
#line 5768
      fstack.caller = funcstack->name;
    } else {
      {
#line 5768
      tmp = dupstring((char const   *)argzero);
#line 5768
      fstack.caller = tmp;
      }
    }
#line 5769
    fstack.lineno = lineno;
#line 5770
    fstack.tp = 2;
#line 5782
    if (! funcstack) {
#line 5783
      fstack.flineno = fstack.lineno;
#line 5784
      fstack.filename = fstack.caller;
    } else
#line 5782
    if (funcstack->tp == 0) {
#line 5783
      fstack.flineno = fstack.lineno;
#line 5784
      fstack.filename = fstack.caller;
    } else {
#line 5786
      fstack.flineno = funcstack->flineno + lineno;
#line 5791
      if (funcstack->tp == 2) {
#line 5792
        (fstack.flineno) --;
      }
#line 5793
      fstack.filename = funcstack->filename;
#line 5794
      if (! fstack.filename) {
#line 5795
        fstack.filename = (char *)"";
      }
    }
#line 5797
    funcstack = & fstack;
#line 5799
    fpushed = 1;
  } else {
#line 5801
    fpushed = 0;
  }
  {
#line 5803
  tmp___0 = zjoin(argv, ' ', 1);
#line 5803
  prog = parse_string(tmp___0, 1);
  }
#line 5804
  if (prog) {
#line 5805
    if ((*(prog->prog) & (wordcode )((1 << 5) - 1)) != 1U) {
#line 5807
      lastval = (zlong )0;
    } else {
      {
#line 5809
      execode(prog, 1, 0, (char *)"eval");
      }
#line 5811
      if (errflag) {
#line 5811
        if (! lastval) {
#line 5812
          lastval = (zlong )errflag;
        }
      }
    }
  } else {
#line 5815
    lastval = (zlong )1;
  }
#line 5818
  if (fpushed) {
#line 5819
    funcstack = funcstack->prev;
  }
#line 5821
  errflag &= -2;
#line 5822
  scriptname = oscriptname;
#line 5823
  ineval = oineval;
#line 5825
  return ((int )lastval);
}
}
#line 5831 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_emulate(char *nam , char **argv , Options ops , int func  __attribute__((__unused__)) ) 
{ 
  int opt_L ;
  int opt_R ;
  int opt_l ;
  int saveemulation ;
  int savehackchar ;
  int ret ;
  int new_emulation ;
  unsigned int savepatterns ;
  char saveopts[180] ;
  char new_opts[180] ;
  char *cmd ;
  char const   *shname ;
  LinkList optlist ;
  LinkNode optnode ;
  Emulation_options save_sticky ;
  OptIndex *on_ptr ;
  OptIndex *off_ptr ;
  char *cmdopts ;
  void *tmp ;
  char tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  char *optptr ;
  OptIndex *tmp___4 ;
  void *tmp___5 ;
  OptIndex *tmp___6 ;
  void *tmp___7 ;
  char *optptr___0 ;
  int optno ;
  OptIndex *tmp___8 ;
  OptIndex *tmp___9 ;

  {
#line 5834
  opt_L = (int )ops->ind[76] != 0;
#line 5835
  opt_R = (int )ops->ind[82] != 0;
#line 5836
  opt_l = (int )ops->ind[108] != 0;
#line 5838
  ret = 1;
#line 5841
  cmd = (char *)0;
#line 5842
  shname = (char const   *)*argv;
#line 5849
  if (! shname) {
#line 5850
    if (opt_L) {
      {
#line 5851
      zwarnnam((char const   *)nam, "not enough arguments");
      }
#line 5852
      return (1);
    } else
#line 5850
    if (opt_R) {
      {
#line 5851
      zwarnnam((char const   *)nam, "not enough arguments");
      }
#line 5852
      return (1);
    }
    {
#line 5856
    if ((emulation & ((1 << 5) - 1)) == 1 << 1) {
#line 5856
      goto case_exp;
    }
#line 5860
    if ((emulation & ((1 << 5) - 1)) == 1 << 2) {
#line 5860
      goto case_exp___0;
    }
#line 5864
    if ((emulation & ((1 << 5) - 1)) == 1 << 3) {
#line 5864
      goto case_exp___1;
    }
#line 5868
    goto switch_default;
    case_exp: /* CIL Label */ 
#line 5857
    shname = "csh";
#line 5858
    goto switch_break;
    case_exp___0: /* CIL Label */ 
#line 5861
    shname = "ksh";
#line 5862
    goto switch_break;
    case_exp___1: /* CIL Label */ 
#line 5865
    shname = "sh";
#line 5866
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 5869
    shname = "zsh";
#line 5870
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 5873
    printf((char const   */* __restrict  */)"%s\n", shname);
    }
#line 5874
    return (0);
  }
#line 5878
  if (! *(argv + 1)) {
#line 5880
    if (opt_l) {
      {
#line 5881
      tmp = zhalloc((size_t )180);
#line 5881
      cmdopts = (char *)tmp;
#line 5882
      memcpy((void */* __restrict  */)cmdopts, (void const   */* __restrict  */)(opts),
             (size_t )180);
      }
    } else {
#line 5884
      cmdopts = opts;
    }
    {
#line 5885
    emulate(shname, opt_R, & emulation, cmdopts);
    }
#line 5886
    if (opt_L) {
#line 5887
      tmp___1 = (char)1;
#line 5887
      *(cmdopts + 108) = tmp___1;
#line 5887
      tmp___0 = tmp___1;
#line 5887
      *(cmdopts + 109) = tmp___0;
#line 5887
      *(cmdopts + 107) = tmp___0;
    }
#line 5889
    if (opt_l) {
      {
#line 5890
      list_emulate_options(cmdopts, opt_R);
      }
#line 5891
      return (0);
    }
    {
#line 5893
    clearpatterndisables();
    }
#line 5894
    return (0);
  }
#line 5897
  if (opt_l) {
    {
#line 5898
    zwarnnam((char const   *)nam, "too many arguments for -l");
    }
#line 5899
    return (1);
  }
  {
#line 5902
  argv ++;
#line 5903
  memcpy((void */* __restrict  */)(saveopts), (void const   */* __restrict  */)(opts),
         sizeof(opts));
#line 5904
  memcpy((void */* __restrict  */)(new_opts), (void const   */* __restrict  */)(opts),
         sizeof(opts));
#line 5905
  savehackchar = (int )keyboardhackchar;
#line 5906
  emulate(shname, opt_R, & new_emulation, new_opts);
#line 5907
  optlist = newlinklist();
#line 5908
  tmp___2 = parseopts(nam, & argv, new_opts, & cmd, optlist);
  }
#line 5908
  if (tmp___2) {
#line 5909
    ret = 1;
#line 5910
    goto restore;
  }
#line 5914
  if (*argv) {
    {
#line 5915
    zwarnnam((char const   *)nam, "unknown argument %s", *argv);
    }
#line 5916
    goto restore;
  }
  {
#line 5919
  savepatterns = savepatterndisables();
#line 5924
  clearpatterndisables();
#line 5926
  saveemulation = emulation;
#line 5927
  emulation = new_emulation;
#line 5928
  memcpy((void */* __restrict  */)(opts), (void const   */* __restrict  */)(new_opts),
         sizeof(opts));
  }
#line 5932
  if (cmd) {
#line 5933
    if (opt_L) {
      {
#line 5934
      zwarnnam((char const   *)nam, "option -L incompatible with -c");
      }
#line 5935
      goto restore2;
    }
#line 5937
    argv --;
#line 5937
    *argv = cmd;
  } else {
#line 5939
    if (opt_L) {
#line 5940
      opts[108] = (char)1;
#line 5940
      opts[109] = opts[108];
#line 5940
      opts[107] = opts[109];
    }
#line 5941
    return (0);
  }
  {
#line 5944
  save_sticky = sticky;
#line 5945
  tmp___3 = hcalloc(sizeof(*sticky));
#line 5945
  sticky = (Emulation_options )tmp___3;
#line 5946
  sticky->emulation = emulation;
#line 5947
  optnode = optlist->list.first;
  }
  {
#line 5947
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5947
    if (! optnode) {
#line 5947
      goto while_break;
    }
#line 5949
    optptr = (char *)optnode->dat;
#line 5950
    if (*optptr) {
#line 5951
      (sticky->n_on_opts) ++;
    } else {
#line 5953
      (sticky->n_off_opts) ++;
    }
#line 5947
    optnode = optnode->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 5955
  if (sticky->n_on_opts) {
    {
#line 5956
    tmp___5 = zhalloc((unsigned long )sticky->n_on_opts * sizeof(*(sticky->on_opts)));
#line 5956
    tmp___4 = (OptIndex *)tmp___5;
#line 5956
    sticky->on_opts = tmp___4;
#line 5956
    on_ptr = tmp___4;
    }
  } else {
#line 5959
    on_ptr = (OptIndex *)((void *)0);
  }
#line 5960
  if (sticky->n_off_opts) {
    {
#line 5961
    tmp___7 = zhalloc((unsigned long )sticky->n_off_opts * sizeof(*(sticky->off_opts)));
#line 5961
    tmp___6 = (OptIndex *)tmp___7;
#line 5961
    sticky->off_opts = tmp___6;
#line 5961
    off_ptr = tmp___6;
    }
  } else {
#line 5964
    off_ptr = (OptIndex *)((void *)0);
  }
#line 5965
  optnode = optlist->list.first;
  {
#line 5965
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5965
    if (! optnode) {
#line 5965
      goto while_break___0;
    }
#line 5967
    optptr___0 = (char *)optnode->dat;
#line 5968
    optno = (int )(optptr___0 - new_opts);
#line 5969
    if (*optptr___0) {
#line 5970
      tmp___8 = on_ptr;
#line 5970
      on_ptr ++;
#line 5970
      *tmp___8 = (OptIndex )optno;
    } else {
#line 5972
      tmp___9 = off_ptr;
#line 5972
      off_ptr ++;
#line 5972
      *tmp___9 = (OptIndex )optno;
    }
#line 5965
    optnode = optnode->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5974
  ret = eval(argv);
#line 5975
  sticky = save_sticky;
  }
  restore2: 
  {
#line 5977
  emulation = saveemulation;
#line 5978
  memcpy((void */* __restrict  */)(opts), (void const   */* __restrict  */)(saveopts),
         sizeof(opts));
#line 5979
  restorepatterndisables(savepatterns);
  }
  restore: 
  {
#line 5981
  keyboardhackchar = (unsigned char )savehackchar;
#line 5982
  inittyptab();
  }
#line 5983
  return (ret);
}
}
#line 5992 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_eval(char *nam  __attribute__((__unused__)) , char **argv , Options ops  __attribute__((__unused__)) ,
             int func  __attribute__((__unused__)) ) 
{ 
  int tmp ;

  {
  {
#line 5995
  tmp = eval(argv);
  }
#line 5995
  return (tmp);
}
}
#line 5998 "/tmp/zsh-5.4.2/Src/builtin.c"
static char *zbuf  ;
#line 5999 "/tmp/zsh-5.4.2/Src/builtin.c"
static int readfd  ;
#line 6011 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_read(char *name , char **args , Options ops , int func  __attribute__((__unused__)) ) 
{ 
  char *reply ;
  char *readpmpt ;
  int bsiz ;
  int c ;
  int gotnl ;
  int al ;
  int first ;
  int nchars ;
  int bslash ;
  int keys ;
  int haso ;
  int isem ;
  int tmp ;
  int tmp___0 ;
  int izle ;
  char *buf___7 ;
  char *bptr ;
  char *firstarg ;
  char *zbuforig ;
  LinkList readll ;
  LinkList tmp___1 ;
  FILE *oshout ;
  int readchar ;
  int val ;
  int resettty ;
  struct ttyinfo saveti ;
  char d___0 ;
  long izle_timeout ;
  wchar_t delim ;
  wchar_t wc ;
  mbstate_t mbs ;
  char *laststart ;
  size_t ret ;
  char *eptr ;
  char *optarg___0 ;
  zlong tmp___2 ;
  char **tmp___3 ;
  char **tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char *eptr___0 ;
  char *argptr ;
  zlong tmp___7 ;
  int tmp___8 ;
  struct ttyinfo ti ;
  FILE *tmp___9 ;
  FILE *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *delimstr ;
  wint_t wi ;
  int tmp___13 ;
  struct ttyinfo ti___0 ;
  zlong timeout___0 ;
  mnumber mn ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int eof ;
  size_t tmp___17 ;
  void *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  ssize_t tmp___21 ;
  ssize_t tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  sigset_t s ;
  sigset_t tmp___28 ;
  void *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int blen ;
  int llen ;
  void *tmp___34 ;
  char **tmp___35 ;
  char **pp ;
  char **p ;
  LinkNode n ;
  void *tmp___36 ;
  char **tmp___37 ;
  char **tmp___38 ;
  void *tmp___39 ;
  sigset_t s___0 ;
  sigset_t tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int blen___0 ;
  int llen___0 ;
  void *tmp___43 ;
  char first___0 ;

  {
  {
#line 6015
  c = 0;
#line 6015
  gotnl = 0;
#line 6015
  al = 0;
#line 6015
  nchars = 1;
#line 6015
  keys = 0;
#line 6016
  haso = 0;
#line 6017
  tmp = strcmp((char const   *)term, "emacs");
  }
#line 6017
  if (tmp) {
#line 6017
    tmp___0 = 0;
  } else {
#line 6017
    tmp___0 = 1;
  }
  {
#line 6017
  isem = tmp___0;
#line 6017
  izle = zleactive;
#line 6019
  tmp___1 = newlinklist();
#line 6019
  readll = tmp___1;
#line 6020
  oshout = (FILE *)((void *)0);
#line 6021
  readchar = -1;
#line 6021
  resettty = 0;
#line 6024
  izle_timeout = 0L;
#line 6026
  delim = 10;
#line 6034
  c = 'k';
  }
#line 6034
  if ((int )ops->ind[c] > 3) {
    {
#line 6035
    optarg___0 = *(ops->args + (((int )ops->ind[c] >> 2) - 1));
#line 6036
    tmp___2 = zstrtol((char const   *)optarg___0, & eptr, 10);
#line 6036
    nchars = (int )tmp___2;
    }
#line 6037
    if (*eptr) {
      {
#line 6038
      zwarnnam((char const   *)name, "number expected after -%c: %s", c, optarg___0);
      }
#line 6039
      return (1);
    }
  }
#line 6044
  if (*args) {
#line 6044
    if ((int )*(*args) == 63) {
#line 6044
      tmp___3 = args;
#line 6044
      args ++;
#line 6044
      firstarg = *tmp___3;
    } else {
#line 6044
      firstarg = *args;
    }
  } else {
#line 6044
    firstarg = *args;
  }
#line 6045
  if (*args) {
#line 6045
    tmp___4 = args;
#line 6045
    args ++;
#line 6045
    reply = *tmp___4;
  } else {
#line 6045
    if ((int )ops->ind[65] != 0) {
#line 6045
      tmp___5 = "reply";
    } else {
#line 6045
      tmp___5 = "REPLY";
    }
#line 6045
    reply = (char *)tmp___5;
  }
#line 6047
  if ((int )ops->ind[65] != 0) {
#line 6047
    if (*args) {
      {
#line 6048
      zwarnnam((char const   *)name, "only one array argument allowed");
      }
#line 6049
      return (1);
    }
  }
#line 6053
  if ((int )ops->ind[108] != 0) {
    {
#line 6054
    tmp___6 = (*compctlreadptr)(name, args, ops, reply);
    }
#line 6054
    return (tmp___6);
  } else
#line 6053
  if ((int )ops->ind[99] != 0) {
    {
#line 6054
    tmp___6 = (*compctlreadptr)(name, args, ops, reply);
    }
#line 6054
    return (tmp___6);
  }
#line 6056
  if ((int )ops->ind[107] != 0) {
#line 6056
    goto _L___2;
  } else
#line 6056
  if ((int )ops->ind[113] != 0) {
    _L___2: /* CIL Label */ 
#line 6056
    if (! ((int )ops->ind[117] != 0)) {
#line 6056
      if (! ((int )ops->ind[112] != 0)) {
#line 6058
        if (! zleactive) {
#line 6059
          if (SHTTY == -1) {
            {
#line 6061
            SHTTY = open("/dev/tty", 258);
            }
#line 6061
            if (SHTTY != -1) {
              {
#line 6062
              haso = 1;
#line 6063
              oshout = shout;
#line 6064
              init_shout();
              }
            }
          } else
#line 6066
          if (! shout) {
            {
#line 6068
            init_shout();
            }
          }
#line 6071
          if (SHTTY == -1) {
            {
#line 6073
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not interactive and can\'t open terminal\n");
#line 6074
            fflush(stderr);
            }
#line 6075
            return (1);
          }
#line 6077
          if (! opts[93]) {
            {
#line 6078
            gettyinfo(& shttyinfo);
            }
          }
          {
#line 6080
          attachtty(mypgrp);
          }
#line 6081
          if (! isem) {
            {
#line 6082
            setcbreak();
            }
          }
#line 6083
          readfd = SHTTY;
        }
#line 6085
        keys = 1;
      } else {
#line 6056
        goto _L___1;
      }
    } else {
#line 6056
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 6086
  if ((int )ops->ind[117] > 3) {
#line 6086
    if (! ((int )ops->ind[112] != 0)) {
      {
#line 6088
      argptr = *(ops->args + (((int )ops->ind[117] >> 2) - 1));
#line 6090
      tmp___8 = strcmp((char const   *)argptr, "p");
      }
#line 6090
      if (tmp___8) {
        {
#line 6097
        tmp___7 = zstrtol((char const   *)argptr, & eptr___0, 10);
#line 6097
        readfd = (int )tmp___7;
        }
#line 6098
        if (*eptr___0) {
          {
#line 6099
          zwarnnam((char const   *)name, "number expected after -%c: %s", 'u', argptr);
          }
#line 6100
          return (1);
        }
      } else {
#line 6091
        readfd = coprocin;
#line 6092
        if (readfd < 0) {
          {
#line 6093
          zwarnnam((char const   *)name, "-p: no coprocess");
          }
#line 6094
          return (1);
        }
      }
#line 6107
      izle = 0;
    } else {
#line 6086
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 6108
  if ((int )ops->ind[112] != 0) {
#line 6109
    readfd = coprocin;
#line 6110
    if (readfd < 0) {
      {
#line 6111
      zwarnnam((char const   *)name, "-p: no coprocess");
      }
#line 6112
      return (1);
    }
#line 6114
    izle = 0;
  } else {
#line 6116
    izle = 0;
#line 6116
    readfd = izle;
  }
#line 6118
  if ((int )ops->ind[115] != 0) {
#line 6118
    if (SHTTY != -1) {
      {
#line 6120
      gettyinfo(& ti);
#line 6121
      saveti = ti;
#line 6122
      resettty = 1;
#line 6124
      ti.tio.c_lflag &= 4294967287U;
#line 6128
      settyinfo(& ti);
      }
    }
  }
#line 6132
  if (firstarg) {
#line 6133
    readpmpt = firstarg;
    {
#line 6133
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6133
      if (*readpmpt) {
#line 6133
        if (! ((int )*readpmpt != 63)) {
#line 6133
          goto while_break;
        }
      } else {
#line 6133
        goto while_break;
      }
#line 6133
      readpmpt ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 6135
    tmp___12 = readpmpt;
#line 6135
    readpmpt ++;
#line 6135
    if (*tmp___12) {
#line 6136
      if (keys) {
#line 6136
        goto _L___3;
      } else {
        {
#line 6136
        tmp___11 = isatty(0);
        }
#line 6136
        if (tmp___11) {
          _L___3: /* CIL Label */ 
#line 6137
          if (shout) {
#line 6137
            tmp___9 = shout;
          } else {
#line 6137
            tmp___9 = stderr;
          }
          {
#line 6137
          zputs((char const   *)readpmpt, tmp___9);
          }
#line 6138
          if (shout) {
#line 6138
            tmp___10 = shout;
          } else {
#line 6138
            tmp___10 = stderr;
          }
          {
#line 6138
          fflush(tmp___10);
          }
        }
      }
#line 6140
      *(readpmpt + -1) = (char )'\000';
    }
  }
#line 6144
  if ((int )ops->ind[100] != 0) {
#line 6145
    delimstr = *(ops->args + (((int )ops->ind[100] >> 2) - 1));
#line 6149
    if (opts[117]) {
      {
#line 6150
      mb_charinit();
#line 6151
      mb_metacharlenconv((char const   *)delimstr, & wi);
      }
    } else {
#line 6154
      wi = 4294967295U;
    }
#line 6155
    if (wi != 4294967295U) {
#line 6156
      delim = (wchar_t )wi;
    } else {
#line 6158
      if ((int )*(delimstr + 0) == -125) {
#line 6158
        tmp___13 = (int )*(delimstr + 1) ^ 32;
      } else {
#line 6158
        tmp___13 = (int )*(delimstr + 0);
      }
#line 6158
      delim = tmp___13;
    }
#line 6163
    if (SHTTY != -1) {
      {
#line 6165
      gettyinfo(& ti___0);
      }
#line 6166
      if (! resettty) {
#line 6167
        saveti = ti___0;
#line 6168
        resettty = 1;
      }
      {
#line 6171
      ti___0.tio.c_lflag &= 4294967293U;
#line 6172
      ti___0.tio.c_cc[6] = (cc_t )1;
#line 6173
      ti___0.tio.c_cc[5] = (cc_t )0;
#line 6177
      settyinfo(& ti___0);
      }
    }
  }
#line 6180
  if ((int )ops->ind[116] != 0) {
#line 6181
    timeout___0 = (zlong )0;
#line 6182
    if ((int )ops->ind[116] > 3) {
      {
#line 6183
      mn = zero_mnumber;
#line 6184
      mn = matheval(*(ops->args + (((int )ops->ind[116] >> 2) - 1)));
      }
#line 6185
      if (errflag) {
#line 6186
        return (1);
      }
#line 6187
      if (mn.type == 2) {
#line 6188
        mn.u.d *= 1e6;
#line 6189
        timeout___0 = (zlong )mn.u.d;
      } else {
#line 6191
        timeout___0 = mn.u.l * 1000000L;
      }
    }
#line 6194
    if (izle) {
#line 6199
      timeout___0 = - (timeout___0 / 10000L + 1L);
#line 6200
      izle_timeout = timeout___0;
#line 6203
      if (izle_timeout != timeout___0) {
#line 6204
        izle_timeout = 9223372036854775807L;
      }
    } else
#line 6207
    if (readfd == -1) {
#line 6207
      goto _L___6;
    } else {
#line 6207
      if (keys) {
#line 6207
        if (! zleactive) {
#line 6207
          tmp___15 = 1;
        } else {
#line 6207
          tmp___15 = 0;
        }
      } else {
#line 6207
        tmp___15 = 0;
      }
      {
#line 6207
      tmp___16 = read_poll(readfd, & readchar, tmp___15, timeout___0);
      }
#line 6207
      if (! tmp___16) {
        _L___6: /* CIL Label */ 
#line 6210
        if (keys) {
#line 6210
          if (! zleactive) {
#line 6210
            if (! isem) {
              {
#line 6211
              settyinfo(& shttyinfo);
              }
            } else {
#line 6210
              goto _L___5;
            }
          } else {
#line 6210
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 6212
        if (resettty) {
#line 6212
          if (SHTTY != -1) {
            {
#line 6213
            settyinfo(& saveti);
            }
          }
        }
#line 6214
        if (haso) {
          {
#line 6215
          fclose(shout);
#line 6216
          shout = oshout;
#line 6217
          SHTTY = -1;
          }
        }
#line 6219
        if ((int )ops->ind[113] != 0) {
#line 6219
          tmp___14 = 2;
        } else {
#line 6219
          tmp___14 = 1;
        }
#line 6219
        return (tmp___14);
      }
    }
  }
  {
#line 6225
  memset((void *)(& mbs), 0, sizeof(mbs));
  }
#line 6232
  if ((int )ops->ind[107] != 0) {
#line 6232
    goto _L___7;
  } else
#line 6232
  if ((int )ops->ind[113] != 0) {
    _L___7: /* CIL Label */ 
    {
#line 6233
    eof = 0;
#line 6236
    tmp___17 = __ctype_get_mb_cur_max();
#line 6236
    tmp___18 = zalloc((size_t )nchars * tmp___17 + 1UL);
#line 6236
    buf___7 = (char *)tmp___18;
#line 6236
    bptr = buf___7;
    }
    {
#line 6241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6242
      if (izle) {
        {
#line 6243
        zleentry(7, izle_timeout, (void *)0, & val);
        }
#line 6244
        if (val < 0) {
#line 6245
          eof = 1;
#line 6246
          goto while_break___0;
        }
#line 6248
        *bptr = (char )val;
#line 6250
        if (opts[117]) {
          {
#line 6251
          tmp___19 = bptr;
#line 6251
          bptr ++;
#line 6251
          ret = mbrlen((char const   */* __restrict  */)tmp___19, (size_t )1, (mbstate_t */* __restrict  */)(& mbs));
          }
#line 6252
          if (ret == 0xffffffffffffffffUL) {
            {
#line 6253
            memset((void *)(& mbs), 0, sizeof(mbs));
            }
          }
#line 6255
          if (ret != 0xfffffffffffffffeUL) {
#line 6256
            nchars --;
          }
#line 6257
          goto __Cont;
        } else {
#line 6259
          bptr ++;
#line 6260
          nchars --;
        }
      } else {
#line 6268
        if (readchar >= 0) {
#line 6269
          *bptr = (char )readchar;
#line 6270
          val = 1;
#line 6271
          readchar = -1;
        } else {
          {
#line 6273
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 6273
            tmp___21 = read(readfd, (void *)bptr, (size_t )nchars);
#line 6273
            val = (int )tmp___21;
            }
#line 6273
            if (! (val < 0)) {
#line 6273
              goto while_break___1;
            }
            {
#line 6274
            tmp___20 = __errno_location();
            }
#line 6274
            if (*tmp___20 != 4) {
#line 6276
              goto while_break___1;
            } else
#line 6274
            if (errflag) {
#line 6276
              goto while_break___1;
            } else
#line 6274
            if (retflag) {
#line 6276
              goto while_break___1;
            } else
#line 6274
            if (breaks) {
#line 6276
              goto while_break___1;
            } else
#line 6274
            if (contflag) {
#line 6276
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 6278
          if (val <= 0) {
#line 6279
            eof = 1;
#line 6280
            goto while_break___0;
          }
        }
#line 6285
        if (opts[117]) {
          {
#line 6286
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 6286
            if (! (val > 0)) {
#line 6286
              goto while_break___2;
            }
            {
#line 6287
            ret = mbrlen((char const   */* __restrict  */)bptr, (size_t )val, (mbstate_t */* __restrict  */)(& mbs));
            }
#line 6288
            if (ret == 0xfffffffffffffffeUL) {
#line 6289
              bptr += val;
#line 6290
              goto while_break___2;
            } else {
#line 6292
              if (ret == 0xffffffffffffffffUL) {
                {
#line 6293
                memset((void *)(& mbs), 0, sizeof(mbs));
#line 6295
                ret = (size_t )1;
                }
              } else
#line 6297
              if (ret == 0UL) {
#line 6298
                ret = (size_t )1;
              } else
#line 6299
              if (ret > (size_t )val) {
#line 6301
                ret = (size_t )val;
              }
#line 6303
              nchars --;
#line 6304
              val = (int )((size_t )val - ret);
#line 6305
              bptr += ret;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 6308
          goto __Cont;
        }
#line 6312
        nchars -= val;
#line 6315
        bptr += val;
      }
      __Cont: /* CIL Label */ 
#line 6241
      if (! (nchars > 0)) {
#line 6241
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6319
    if (! izle) {
#line 6319
      if (! ((int )ops->ind[117] != 0)) {
#line 6319
        if (! ((int )ops->ind[112] != 0)) {
#line 6321
          if (isem) {
            {
#line 6322
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 6322
              if (val > 0) {
                {
#line 6322
                tmp___22 = read(SHTTY, (void *)(& d___0), (size_t )1);
                }
#line 6322
                if (tmp___22 == 1L) {
#line 6322
                  if (! ((int )d___0 != 10)) {
#line 6322
                    goto while_break___3;
                  }
                } else {
#line 6322
                  goto while_break___3;
                }
              } else {
#line 6322
                goto while_break___3;
              }
            }
            while_break___3: /* CIL Label */ ;
            }
          } else {
            {
#line 6324
            settyinfo(& shttyinfo);
#line 6325
            resettty = 0;
            }
          }
#line 6327
          if (haso) {
            {
#line 6328
            fclose(shout);
#line 6329
            shout = oshout;
#line 6330
            SHTTY = -1;
            }
          }
        }
      }
    }
#line 6334
    if ((int )ops->ind[113] != 0) {
#line 6340
      if (eof) {
#line 6341
        eof = 2;
      } else {
#line 6343
        if (bptr - buf___7 != 1L) {
#line 6343
          tmp___23 = 1;
        } else
#line 6343
        if ((int )*(buf___7 + 0) != 121) {
#line 6343
          if ((int )*(buf___7 + 0) != 89) {
#line 6343
            tmp___23 = 1;
          } else {
#line 6343
            tmp___23 = 0;
          }
        } else {
#line 6343
          tmp___23 = 0;
        }
#line 6343
        eof = tmp___23;
      }
#line 6344
      if (eof) {
#line 6344
        *(buf___7 + 0) = (char )'n';
      } else {
#line 6344
        *(buf___7 + 0) = (char )'y';
      }
#line 6345
      bptr = buf___7 + 1;
    }
#line 6347
    if ((int )ops->ind[101] != 0) {
      {
#line 6348
      fwrite((void const   */* __restrict  */)buf___7, (size_t )(bptr - buf___7),
             (size_t )1, (FILE */* __restrict  */)stdout);
      }
    } else
#line 6347
    if ((int )ops->ind[69] != 0) {
      {
#line 6348
      fwrite((void const   */* __restrict  */)buf___7, (size_t )(bptr - buf___7),
             (size_t )1, (FILE */* __restrict  */)stdout);
      }
    }
#line 6349
    if (! ((int )ops->ind[101] != 0)) {
      {
#line 6350
      tmp___24 = metafy(buf___7, (int )(bptr - buf___7), 0);
#line 6350
      setsparam(reply, tmp___24);
      }
    } else {
      {
#line 6352
      zfree((void *)buf___7, (int )((bptr - buf___7) + 1L));
      }
    }
#line 6353
    if (resettty) {
#line 6353
      if (SHTTY != -1) {
        {
#line 6354
        settyinfo(& saveti);
        }
      }
    }
#line 6355
    return (eof);
  }
#line 6363
  if (! ((int )ops->ind[122] != 0)) {
#line 6363
    zbuf = (char *)((void *)0);
  } else {
#line 6363
    if ((unsigned long )bufstack->list.first != (unsigned long )((void *)0)) {
      {
#line 6363
      tmp___25 = getlinknode(bufstack);
#line 6363
      tmp___27 = (char *)tmp___25;
      }
    } else {
      {
#line 6363
      tmp___26 = ztrdup("");
#line 6363
      tmp___27 = tmp___26;
      }
    }
#line 6363
    zbuf = tmp___27;
  }
#line 6363
  zbuforig = zbuf;
#line 6365
  first = 1;
#line 6366
  bslash = 0;
  {
#line 6367
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 6367
    if (! *args) {
#line 6367
      if ((int )ops->ind[65] != 0) {
#line 6367
        if (! (! gotnl)) {
#line 6367
          goto while_break___4;
        }
      } else {
#line 6367
        goto while_break___4;
      }
    }
    {
#line 6368
    tmp___28 = signal_unblock(sigchld_mask);
#line 6368
    s = tmp___28;
#line 6369
    bsiz = 64;
#line 6369
    tmp___29 = zalloc((size_t )bsiz);
#line 6369
    bptr = (char *)tmp___29;
#line 6369
    buf___7 = bptr;
#line 6371
    laststart = buf___7;
#line 6372
    ret = (size_t )-2;
    }
    {
#line 6375
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 6375
      if (! (! gotnl)) {
#line 6375
        goto while_break___5;
      }
      {
#line 6376
      c = zread(izle, & readchar, izle_timeout);
      }
#line 6380
      if (c == -1) {
#line 6382
        ret = (size_t )0;
#line 6383
        goto while_break___5;
      }
#line 6385
      *bptr = (char )c;
#line 6386
      if (opts[117]) {
        {
#line 6387
        ret = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)bptr,
                      (size_t )1, (mbstate_t */* __restrict  */)(& mbs));
        }
#line 6388
        if (! ret) {
#line 6389
          ret = (size_t )1;
        }
      } else {
#line 6391
        ret = (size_t )1;
#line 6392
        wc = c;
      }
#line 6394
      if (ret != 0xfffffffffffffffeUL) {
#line 6395
        if (ret == 0xffffffffffffffffUL) {
          {
#line 6396
          memset((void *)(& mbs), 0, sizeof(mbs));
#line 6398
          wc = c;
#line 6399
          laststart = bptr;
          }
        }
#line 6401
        if (bslash) {
#line 6401
          if (wc == delim) {
#line 6402
            bslash = 0;
#line 6403
            goto while_continue___5;
          }
        }
#line 6405
        if (wc == delim) {
#line 6406
          goto while_break___5;
        }
#line 6416
        if (! bslash) {
          {
#line 6416
          tmp___32 = wcsitype(wc, 1 << 5);
          }
#line 6416
          if (tmp___32) {
#line 6417
            if ((unsigned long )bptr != (unsigned long )buf___7) {
#line 6417
              goto _L___8;
            } else
#line 6417
            if (c < 128) {
#line 6417
              if (! ((int )typtab[(unsigned char )c] & (1 << 13))) {
#line 6417
                goto _L___9;
              }
            } else
            _L___9: /* CIL Label */ 
#line 6417
            if (first) {
              _L___8: /* CIL Label */ 
#line 6419
              if (c < 128) {
#line 6419
                if ((int )typtab[(unsigned char )c] & (1 << 13)) {
#line 6419
                  tmp___30 = 0;
                } else {
#line 6419
                  tmp___30 = 1;
                }
              } else {
#line 6419
                tmp___30 = 1;
              }
#line 6419
              first |= tmp___30;
#line 6420
              goto while_break___5;
            }
#line 6422
            if (c < 128) {
#line 6422
              if ((int )typtab[(unsigned char )c] & (1 << 13)) {
#line 6422
                tmp___31 = 0;
              } else {
#line 6422
                tmp___31 = 1;
              }
            } else {
#line 6422
              tmp___31 = 1;
            }
#line 6422
            first |= tmp___31;
#line 6423
            goto while_continue___5;
          }
        }
#line 6425
        if (wc == 92) {
#line 6425
          if (! bslash) {
#line 6425
            if (! ((int )ops->ind[114] != 0)) {
#line 6425
              tmp___33 = 1;
            } else {
#line 6425
              tmp___33 = 0;
            }
          } else {
#line 6425
            tmp___33 = 0;
          }
        } else {
#line 6425
          tmp___33 = 0;
        }
#line 6425
        bslash = tmp___33;
#line 6426
        if (bslash) {
#line 6427
          goto while_continue___5;
        }
#line 6428
        first = 0;
      }
#line 6430
      if ((int )typtab[(unsigned char )*bptr] & (1 << 12)) {
#line 6431
        *(bptr + 1) = (char )((int )*(bptr + 0) ^ 32);
#line 6432
        *(bptr + 0) = (char)-125;
#line 6433
        bptr += 2;
      } else {
#line 6436
        bptr ++;
      }
#line 6437
      if (ret != 0xfffffffffffffffeUL) {
#line 6438
        laststart = bptr;
      }
#line 6476
      if ((unsigned long )bptr >= (unsigned long )((buf___7 + bsiz) - 1)) {
        {
#line 6477
        blen = (int )(bptr - buf___7);
#line 6479
        llen = (int )(laststart - buf___7);
#line 6482
        bsiz *= 2;
#line 6482
        tmp___34 = realloc((void *)buf___7, (size_t )bsiz);
#line 6482
        buf___7 = (char *)tmp___34;
#line 6483
        bptr = buf___7 + blen;
#line 6485
        laststart = buf___7 + llen;
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 6489
    signal_setmask(s);
    }
#line 6491
    if (c == -1) {
#line 6492
      gotnl = 1;
#line 6493
      *bptr = (char )'\000';
    } else
#line 6494
    if (ret == 0xfffffffffffffffeUL) {
#line 6500
      *bptr = (char )'\000';
    } else {
#line 6502
      if (wc == delim) {
#line 6503
        gotnl = 1;
      }
#line 6504
      *laststart = (char )'\000';
    }
#line 6512
    if ((int )ops->ind[101] != 0) {
      {
#line 6520
      zputs((char const   *)buf___7, stdout);
#line 6521
      putchar('\n');
      }
    } else
#line 6512
    if ((int )ops->ind[69] != 0) {
#line 6512
      if (! ((int )ops->ind[65] != 0)) {
        {
#line 6520
        zputs((char const   *)buf___7, stdout);
#line 6521
        putchar('\n');
        }
      }
    }
#line 6523
    if (! ((int )ops->ind[101] != 0)) {
#line 6523
      if (*buf___7) {
#line 6523
        goto _L___10;
      } else
#line 6523
      if (first) {
#line 6523
        goto _L___10;
      } else
#line 6523
      if (gotnl) {
        _L___10: /* CIL Label */ 
#line 6524
        if ((int )ops->ind[65] != 0) {
          {
#line 6525
          insertlinknode(readll, readll->list.last, (void *)buf___7);
#line 6526
          al ++;
          }
        } else {
          {
#line 6528
          setsparam(reply, buf___7);
          }
        }
      } else {
        {
#line 6530
        free((void *)buf___7);
        }
      }
    } else {
      {
#line 6530
      free((void *)buf___7);
      }
    }
#line 6531
    if (! ((int )ops->ind[65] != 0)) {
#line 6532
      tmp___35 = args;
#line 6532
      args ++;
#line 6532
      reply = *tmp___35;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 6535
  if (c == -1) {
#line 6536
    if (readfd == coprocin) {
      {
#line 6537
      close(coprocin);
#line 6538
      close(coprocout);
#line 6539
      coprocout = -1;
#line 6539
      coprocin = coprocout;
      }
    }
  }
#line 6543
  if ((int )ops->ind[65] != 0) {
#line 6544
    p = (char **)((void *)0);
#line 6547
    if ((int )ops->ind[101] != 0) {
#line 6547
      p = (char **)((void *)0);
    } else {
      {
#line 6547
      tmp___36 = zalloc((unsigned long )(al + 1) * sizeof(char *));
#line 6547
      p = (char **)tmp___36;
      }
    }
#line 6550
    pp = p;
#line 6550
    n = readll->list.first;
    {
#line 6550
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 6550
      if (! n) {
#line 6550
        goto while_break___6;
      }
#line 6551
      if ((int )ops->ind[69] != 0) {
        {
#line 6552
        zputs((char const   *)((char *)n->dat), stdout);
#line 6553
        putchar('\n');
        }
      }
#line 6555
      if (p) {
#line 6556
        tmp___37 = pp;
#line 6556
        pp ++;
#line 6556
        *tmp___37 = (char *)n->dat;
      } else {
        {
#line 6558
        zsfree((char *)n->dat);
        }
      }
#line 6550
      n = n->next;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 6560
    if (p) {
      {
#line 6561
      tmp___38 = pp;
#line 6561
      pp ++;
#line 6561
      *tmp___38 = (char *)((void *)0);
#line 6562
      setaparam(reply, p);
      }
    }
#line 6564
    if (resettty) {
#line 6564
      if (SHTTY != -1) {
        {
#line 6565
        settyinfo(& saveti);
        }
      }
    }
#line 6566
    return (c == -1);
  }
  {
#line 6568
  bsiz = 64;
#line 6568
  tmp___39 = zalloc((size_t )bsiz);
#line 6568
  bptr = (char *)tmp___39;
#line 6568
  buf___7 = bptr;
#line 6570
  laststart = buf___7;
#line 6571
  ret = (size_t )-2;
#line 6574
  bslash = 0;
  }
#line 6575
  if (! gotnl) {
    {
#line 6576
    tmp___40 = signal_unblock(sigchld_mask);
#line 6576
    s___0 = tmp___40;
    }
    {
#line 6577
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 6578
      c = zread(izle, & readchar, izle_timeout);
      }
#line 6580
      if (c == -1) {
#line 6582
        ret = (size_t )0;
#line 6583
        goto while_break___7;
      }
#line 6585
      *bptr = (char )c;
#line 6586
      if (opts[117]) {
        {
#line 6587
        ret = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)bptr,
                      (size_t )1, (mbstate_t */* __restrict  */)(& mbs));
        }
#line 6588
        if (! ret) {
#line 6589
          ret = (size_t )1;
        }
      } else {
#line 6591
        ret = (size_t )1;
#line 6592
        wc = c;
      }
#line 6594
      if (ret != 0xfffffffffffffffeUL) {
#line 6595
        if (ret == 0xffffffffffffffffUL) {
          {
#line 6596
          memset((void *)(& mbs), 0, sizeof(mbs));
#line 6598
          wc = c;
#line 6599
          laststart = bptr;
          }
        }
#line 6605
        if (bslash) {
#line 6605
          if (wc == delim) {
#line 6606
            bslash = 0;
#line 6607
            goto __Cont___0;
          }
        }
#line 6609
        if (wc == delim) {
#line 6609
          if (! zbuf) {
#line 6610
            goto while_break___7;
          }
        }
#line 6611
        if (! bslash) {
#line 6611
          if ((unsigned long )bptr == (unsigned long )buf___7) {
            {
#line 6611
            tmp___41 = wcsitype(wc, 1 << 5);
            }
#line 6611
            if (tmp___41) {
#line 6612
              if (c < 128) {
#line 6612
                if ((int )typtab[(unsigned char )c] & (1 << 13)) {
#line 6613
                  goto __Cont___0;
                } else {
#line 6612
                  goto _L___11;
                }
              } else
              _L___11: /* CIL Label */ 
#line 6614
              if (! first) {
#line 6615
                first = 1;
#line 6616
                goto __Cont___0;
              }
            }
          }
        }
#line 6619
        if (wc == 92) {
#line 6619
          if (! bslash) {
#line 6619
            if (! ((int )ops->ind[114] != 0)) {
#line 6619
              tmp___42 = 1;
            } else {
#line 6619
              tmp___42 = 0;
            }
          } else {
#line 6619
            tmp___42 = 0;
          }
        } else {
#line 6619
          tmp___42 = 0;
        }
#line 6619
        bslash = tmp___42;
#line 6620
        if (bslash) {
#line 6621
          goto __Cont___0;
        }
      }
#line 6623
      if ((int )typtab[(unsigned char )*bptr] & (1 << 12)) {
#line 6624
        *(bptr + 1) = (char )((int )*(bptr + 0) ^ 32);
#line 6625
        *(bptr + 0) = (char)-125;
#line 6626
        bptr += 2;
      } else {
#line 6629
        bptr ++;
      }
#line 6630
      if (ret != 0xfffffffffffffffeUL) {
#line 6631
        laststart = bptr;
      }
#line 6659
      if ((unsigned long )bptr >= (unsigned long )((buf___7 + bsiz) - 1)) {
        {
#line 6660
        blen___0 = (int )(bptr - buf___7);
#line 6662
        llen___0 = (int )(laststart - buf___7);
#line 6665
        bsiz *= 2;
#line 6665
        tmp___43 = realloc((void *)buf___7, (size_t )bsiz);
#line 6665
        buf___7 = (char *)tmp___43;
#line 6666
        bptr = buf___7 + blen___0;
#line 6668
        laststart = buf___7 + llen___0;
        }
      }
      __Cont___0: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 6672
    signal_setmask(s___0);
    }
  }
#line 6675
  if (ret != 0xfffffffffffffffeUL) {
#line 6676
    bptr = laststart;
  }
  {
#line 6683
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 6683
    if (! ((unsigned long )bptr > (unsigned long )buf___7)) {
#line 6683
      goto while_break___8;
    }
#line 6684
    if ((unsigned long )bptr > (unsigned long )(buf___7 + 1)) {
#line 6684
      if ((int )*(bptr + -2) == -125) {
#line 6686
        goto while_break___8;
      } else {
#line 6684
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
#line 6687
    if ((int )typtab[(unsigned char )*(bptr + -1)] & (1 << 13)) {
#line 6688
      bptr --;
    } else {
#line 6690
      goto while_break___8;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 6692
  *bptr = (char )'\000';
#line 6693
  if (resettty) {
#line 6693
    if (SHTTY != -1) {
      {
#line 6694
      settyinfo(& saveti);
      }
    }
  }
#line 6696
  if ((int )ops->ind[101] != 0) {
    {
#line 6697
    zputs((char const   *)buf___7, stdout);
#line 6698
    putchar('\n');
    }
  } else
#line 6696
  if ((int )ops->ind[69] != 0) {
    {
#line 6697
    zputs((char const   *)buf___7, stdout);
#line 6698
    putchar('\n');
    }
  }
#line 6700
  if (! ((int )ops->ind[101] != 0)) {
    {
#line 6701
    setsparam(reply, buf___7);
    }
  } else {
    {
#line 6703
    zsfree(buf___7);
    }
  }
#line 6704
  if (zbuforig) {
    {
#line 6705
    first___0 = *zbuforig;
#line 6707
    zsfree(zbuforig);
    }
#line 6708
    if (! first___0) {
#line 6709
      return (1);
    }
  } else
#line 6710
  if (c == -1) {
#line 6711
    if (readfd == coprocin) {
      {
#line 6712
      close(coprocin);
#line 6713
      close(coprocout);
#line 6714
      coprocout = -1;
#line 6714
      coprocin = coprocout;
      }
    }
#line 6716
    return (1);
  }
#line 6723
  return (errflag);
}
}
#line 6727 "/tmp/zsh-5.4.2/Src/builtin.c"
static int zread(int izle , int *readchar , long izle_timeout ) 
{ 
  char cc ;
  char retry ;
  int ret ;
  int c ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 6730
  retry = (char)0;
#line 6733
  if (izle) {
    {
#line 6735
    zleentry(7, izle_timeout, (void *)0, & c);
    }
#line 6737
    if (c < 0) {
#line 6737
      tmp = -1;
    } else {
#line 6737
      tmp = c;
    }
#line 6737
    return (tmp);
  }
#line 6740
  if (zbuf) {
#line 6744
    if ((int )*zbuf == -125) {
#line 6745
      zbuf ++;
#line 6745
      tmp___0 = zbuf;
#line 6745
      zbuf ++;
#line 6745
      return ((int )((unsigned char )((int )*tmp___0 ^ 32)));
    } else {
#line 6747
      if (*zbuf) {
#line 6747
        tmp___1 = zbuf;
#line 6747
        zbuf ++;
#line 6747
        tmp___2 = (int )((unsigned char )*tmp___1);
      } else {
#line 6747
        tmp___2 = -1;
      }
#line 6747
      return (tmp___2);
    }
  }
#line 6749
  if (*readchar >= 0) {
#line 6750
    cc = (char )*readchar;
#line 6751
    *readchar = -1;
#line 6752
    return ((int )((unsigned char )cc));
  }
  {
#line 6754
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 6756
    tmp___3 = read(readfd, (void *)(& cc), (size_t )1);
#line 6756
    ret = (int )tmp___3;
    }
    {
#line 6758
    if (ret == 1) {
#line 6758
      goto case_1;
    }
#line 6761
    if (ret == -1) {
#line 6761
      goto case_neg_1;
    }
#line 6757
    goto switch_break;
    case_1: /* CIL Label */ 
#line 6760
    return ((int )((unsigned char )cc));
    case_neg_1: /* CIL Label */ 
#line 6763
    if (! retry) {
#line 6763
      if (readfd == 0) {
        {
#line 6763
        tmp___5 = __errno_location();
        }
#line 6763
        if (*tmp___5 == 11) {
#line 6763
          goto _L___1;
        } else {
          {
#line 6763
          tmp___6 = __errno_location();
          }
#line 6763
          if (*tmp___6 == 11) {
            _L___1: /* CIL Label */ 
            {
#line 6763
            tmp___7 = setblock_stdin();
            }
#line 6763
            if (tmp___7) {
#line 6774
              retry = (char)1;
#line 6775
              goto __Cont;
            } else {
#line 6763
              goto _L___2;
            }
          } else {
#line 6763
            goto _L___2;
          }
        }
      } else {
#line 6763
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 6778
      tmp___4 = __errno_location();
      }
#line 6778
      if (*tmp___4 == 4) {
#line 6778
        if (! errflag) {
#line 6778
          if (! retflag) {
#line 6778
            if (! breaks) {
#line 6778
              if (! contflag) {
#line 6779
                goto __Cont;
              }
            }
          }
        }
      }
    }
#line 6780
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 6782
    return (-1);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 6793 "/tmp/zsh-5.4.2/Src/builtin.c"
void testlex(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 6796
  if ((unsigned int )tok == 38U) {
#line 6797
    return;
  }
#line 6799
  curtestarg = testargs;
#line 6799
  tokstr = *curtestarg;
#line 6800
  if (! *testargs) {
#line 6802
    if (tok) {
#line 6802
      tok = (enum lextok )0;
    } else {
#line 6802
      tok = (enum lextok )38;
    }
#line 6803
    return;
  } else {
    {
#line 6804
    tmp___3 = strcmp((char const   *)*testargs, "-o");
    }
#line 6804
    if (tmp___3) {
      {
#line 6806
      tmp___2 = strcmp((char const   *)*testargs, "-a");
      }
#line 6806
      if (tmp___2) {
        {
#line 6808
        tmp___1 = strcmp((char const   *)*testargs, "!");
        }
#line 6808
        if (tmp___1) {
          {
#line 6810
          tmp___0 = strcmp((char const   *)*testargs, "(");
          }
#line 6810
          if (tmp___0) {
            {
#line 6812
            tmp = strcmp((char const   *)*testargs, ")");
            }
#line 6812
            if (tmp) {
#line 6815
              tok = (enum lextok )34;
            } else {
#line 6813
              tok = (enum lextok )7;
            }
          } else {
#line 6811
            tok = (enum lextok )6;
          }
        } else {
#line 6809
          tok = (enum lextok )39;
        }
      } else {
#line 6807
        tok = (enum lextok )9;
      }
    } else {
#line 6805
      tok = (enum lextok )8;
    }
  }
#line 6816
  testargs ++;
#line 6817
  return;
}
}
#line 6820 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_test(char *name , char **argv , Options ops  __attribute__((__unused__)) ,
             int func ) 
{ 
  char **s ;
  Eprog prog ;
  struct estate state ;
  int nargs ;
  int sense ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
#line 6826
  sense = 0;
#line 6830
  if (func == 21) {
#line 6831
    s = argv;
    {
#line 6831
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6831
      if (! *s) {
#line 6831
        goto while_break;
      }
#line 6831
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 6832
    if ((unsigned long )s == (unsigned long )argv) {
      {
#line 6833
      zwarnnam((char const   *)name, "\']\' expected");
      }
#line 6834
      return (2);
    } else {
      {
#line 6832
      tmp = strcmp((char const   *)*(s + -1), "]");
      }
#line 6832
      if (tmp) {
        {
#line 6833
        zwarnnam((char const   *)name, "\']\' expected");
        }
#line 6834
        return (2);
      }
    }
#line 6836
    *(s + -1) = (char *)((void *)0);
  }
#line 6839
  if (! *argv) {
#line 6840
    return (1);
  }
  {
#line 6847
  nargs = arrlen(argv);
  }
#line 6848
  if (nargs == 3) {
#line 6848
    goto _L;
  } else
#line 6848
  if (nargs == 4) {
    _L: /* CIL Label */ 
    {
#line 6855
    tmp___0 = strcmp((char const   *)*(argv + 0), "(");
    }
#line 6855
    if (! tmp___0) {
      {
#line 6855
      tmp___1 = strcmp((char const   *)*(argv + (nargs - 1)), ")");
      }
#line 6855
      if (! tmp___1) {
#line 6855
        if (nargs != 3) {
#line 6857
          *(argv + (nargs - 1)) = (char *)((void *)0);
#line 6858
          argv ++;
        } else {
          {
#line 6855
          tmp___2 = is_cond_binary_op((char const   *)*(argv + 1));
          }
#line 6855
          if (! tmp___2) {
#line 6857
            *(argv + (nargs - 1)) = (char *)((void *)0);
#line 6858
            argv ++;
          }
        }
      }
    }
#line 6860
    if (nargs == 4) {
      {
#line 6860
      tmp___3 = strcmp("!", (char const   *)*(argv + 0));
      }
#line 6860
      if (! tmp___3) {
#line 6861
        sense = 1;
#line 6862
        argv ++;
      }
    }
  }
  {
#line 6866
  zcontext_save();
#line 6867
  testargs = argv;
#line 6868
  tok = (enum lextok )0;
#line 6869
  condlex = & testlex;
#line 6870
  testlex();
#line 6871
  prog = parse_cond();
#line 6872
  condlex = & zshlex;
  }
#line 6874
  if (errflag) {
    {
#line 6875
    errflag &= -2;
#line 6876
    zcontext_restore();
    }
#line 6877
    return (2);
  }
#line 6880
  if (! prog) {
#line 6880
    goto _L___0;
  } else
#line 6880
  if ((unsigned int )tok == 38U) {
    _L___0: /* CIL Label */ 
#line 6881
    if (tokstr) {
#line 6881
      tmp___4 = "parse error";
    } else {
#line 6881
      tmp___4 = "argument expected";
    }
    {
#line 6881
    zwarnnam((char const   *)name, tmp___4);
#line 6882
    zcontext_restore();
    }
#line 6883
    return (2);
  }
  {
#line 6885
  zcontext_restore();
  }
#line 6887
  if (*curtestarg) {
    {
#line 6888
    zwarnnam((char const   *)name, "too many arguments");
    }
#line 6889
    return (2);
  }
  {
#line 6894
  state.prog = prog;
#line 6895
  state.pc = prog->prog;
#line 6896
  state.strs = prog->strs;
#line 6898
  ret = evalcond(& state, name);
  }
#line 6899
  if (ret < 2) {
#line 6899
    if (sense) {
#line 6900
      ret = ! ret;
    }
  }
#line 6902
  return (ret);
}
}
#line 6913 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_times(char *name  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
              Options ops  __attribute__((__unused__)) , int func  __attribute__((__unused__)) ) 
{ 
  struct tms buf___7 ;
  long clktck___0 ;
  long tmp ;
  clock_t tmp___0 ;

  {
  {
#line 6917
  tmp = get_clktck();
#line 6917
  clktck___0 = tmp;
#line 6920
  tmp___0 = times(& buf___7);
  }
#line 6920
  if (tmp___0 == -1L) {
#line 6921
    return (1);
  }
  {
#line 6922
  printf((char const   */* __restrict  */)"%ldm%ld.%02lds", buf___7.tms_utime / (60L * clktck___0),
         (buf___7.tms_utime / clktck___0) % clktck___0, ((buf___7.tms_utime * 100L) / clktck___0) % 100L);
#line 6923
  putchar(' ');
#line 6924
  printf((char const   */* __restrict  */)"%ldm%ld.%02lds", buf___7.tms_stime / (60L * clktck___0),
         (buf___7.tms_stime / clktck___0) % clktck___0, ((buf___7.tms_stime * 100L) / clktck___0) % 100L);
#line 6925
  putchar('\n');
#line 6926
  printf((char const   */* __restrict  */)"%ldm%ld.%02lds", buf___7.tms_cutime / (60L * clktck___0),
         (buf___7.tms_cutime / clktck___0) % clktck___0, ((buf___7.tms_cutime * 100L) / clktck___0) % 100L);
#line 6927
  putchar(' ');
#line 6928
  printf((char const   */* __restrict  */)"%ldm%ld.%02lds", buf___7.tms_cstime / (60L * clktck___0),
         (buf___7.tms_cstime / clktck___0) % clktck___0, ((buf___7.tms_cstime * 100L) / clktck___0) % 100L);
#line 6929
  putchar('\n');
  }
#line 6930
  return (0);
}
}
#line 6936 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_trap(char *name , char **argv , Options ops  __attribute__((__unused__)) ,
             int func  __attribute__((__unused__)) ) 
{ 
  Eprog prog ;
  char *arg ;
  char *s ;
  int sig ;
  int tmp ;
  HashNode hn ;
  char const   *name___0 ;
  char const   *tmp___0 ;
  sigset_t oset ;
  int tmp___1 ;
  int tmp___2 ;
  char **tmp___3 ;
  char **tmp___4 ;
  Eprog t ;
  int flags ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 6943
  if (*argv) {
    {
#line 6943
    tmp = strcmp((char const   *)*argv, "--");
    }
#line 6943
    if (! tmp) {
#line 6944
      argv ++;
    }
  }
#line 6947
  if (! *argv) {
#line 6948
    queueing_enabled ++;
#line 6949
    sig = 0;
    {
#line 6949
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6949
      if (! (sig < 34)) {
#line 6949
        goto while_break;
      }
#line 6950
      if (sigtrapped[sig] & (1 << 2)) {
        {
#line 6953
        hn = gettrapnode(sig, 0);
        }
#line 6953
        if (hn) {
          {
#line 6954
          (*(shfunctab->printnode))(hn, 0);
          }
        }
      } else
#line 6956
      if (sigtrapped[sig]) {
        {
#line 6957
        tmp___0 = getsigname(sig);
#line 6957
        name___0 = tmp___0;
        }
#line 6958
        if (! siglists[sig]) {
          {
#line 6959
          printf((char const   */* __restrict  */)"trap -- \'\' %s\n", name___0);
          }
        } else {
          {
#line 6961
          s = getpermtext(siglists[sig], (Wordcode )((void *)0), 0);
#line 6962
          printf((char const   */* __restrict  */)"trap -- ");
#line 6963
          quotedzputs((char const   *)s, stdout);
#line 6964
          printf((char const   */* __restrict  */)" %s\n", name___0);
#line 6965
          zsfree(s);
          }
        }
      }
#line 6949
      sig ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 6969
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6969
      queueing_enabled --;
#line 6969
      if (! queueing_enabled) {
        {
#line 6969
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 6969
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 6969
            if (! (queue_front != queue_rear)) {
#line 6969
              goto while_break___2;
            }
            {
#line 6969
            queue_front = (queue_front + 1) % 128;
#line 6969
            oset = signal_setmask(signal_mask_queue[queue_front]);
#line 6969
            zhandler(signal_queue[queue_front]);
#line 6969
            signal_setmask(oset);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 6969
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 6969
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6970
    return (0);
  }
  {
#line 6975
  tmp___1 = getsignum((char const   *)*argv);
  }
#line 6975
  if (tmp___1 != -1) {
#line 6975
    goto _L;
  } else {
    {
#line 6975
    tmp___2 = strcmp((char const   *)*argv, "-");
    }
#line 6975
    if (! tmp___2) {
#line 6975
      tmp___3 = argv;
#line 6975
      argv ++;
#line 6975
      if (tmp___3) {
        _L: /* CIL Label */ 
#line 6976
        if (! *argv) {
#line 6977
          sig = 0;
          {
#line 6977
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 6977
            if (! (sig < 34)) {
#line 6977
              goto while_break___3;
            }
            {
#line 6978
            unsettrap(sig);
#line 6977
            sig ++;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
          {
#line 6980
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 6980
            if (! *argv) {
#line 6980
              goto while_break___4;
            }
            {
#line 6981
            sig = getsignum((char const   *)*argv);
            }
#line 6982
            if (sig == -1) {
              {
#line 6983
              zwarnnam((char const   *)name, "undefined signal: %s", *argv);
              }
#line 6984
              goto while_break___4;
            }
            {
#line 6986
            unsettrap(sig);
#line 6980
            argv ++;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 6989
        return ((unsigned long )*argv != (unsigned long )((void *)0));
      }
    }
  }
#line 6993
  tmp___4 = argv;
#line 6993
  argv ++;
#line 6993
  arg = *tmp___4;
#line 6994
  if (! *arg) {
#line 6995
    prog = & dummy_eprog;
  } else {
    {
#line 6996
    prog = parse_string(arg, 1);
    }
#line 6996
    if (! prog) {
      {
#line 6997
      zwarnnam((char const   *)name, "couldn\'t parse trap command");
      }
#line 6998
      return (1);
    }
  }
  {
#line 7002
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 7002
    if (! *argv) {
#line 7002
      goto while_break___5;
    }
    {
#line 7006
    sig = getsignum((char const   *)*argv);
    }
#line 7007
    if (sig == -1) {
      {
#line 7008
      zwarnnam((char const   *)name, "undefined signal: %s", *argv);
      }
#line 7009
      goto while_break___5;
    }
#line 7011
    if ((int )typtab[(unsigned char )*(*argv)] & 1) {
#line 7017
      flags = 0;
    } else {
      {
#line 7011
      tmp___5 = strcmp((char const   *)sigs[sig], (char const   *)*argv);
      }
#line 7011
      if (tmp___5) {
        {
#line 7011
        tmp___6 = strncmp("SIG", (char const   *)*argv, (size_t )3);
        }
#line 7011
        if (tmp___6) {
#line 7025
          flags = 1 << 3;
        } else {
          {
#line 7011
          tmp___7 = strcmp((char const   *)sigs[sig], (char const   *)(*argv + 3));
          }
#line 7011
          if (tmp___7) {
#line 7025
            flags = 1 << 3;
          } else {
#line 7017
            flags = 0;
          }
        }
      } else {
#line 7017
        flags = 0;
      }
    }
    {
#line 7027
    t = dupeprog(prog, 0);
#line 7028
    tmp___8 = settrap(sig, t, flags);
    }
#line 7028
    if (tmp___8) {
      {
#line 7029
      freeeprog(t);
      }
    }
#line 7002
    argv ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 7031
  return ((unsigned long )*argv != (unsigned long )((void *)0));
}
}
#line 7035 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_ttyctl(char *name  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
               Options ops , int func  __attribute__((__unused__)) ) 
{ 
  char const   *tmp ;

  {
#line 7038
  if ((int )ops->ind[102] != 0) {
#line 7039
    ttyfrozen = 1;
  } else
#line 7040
  if ((int )ops->ind[117] != 0) {
#line 7041
    ttyfrozen = 0;
  } else {
#line 7043
    if (ttyfrozen) {
#line 7043
      tmp = "";
    } else {
#line 7043
      tmp = "not ";
    }
    {
#line 7043
    printf((char const   */* __restrict  */)"tty is %sfrozen\n", tmp);
    }
  }
#line 7044
  return (0);
}
}
#line 7050 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_let(char *name  __attribute__((__unused__)) , char **argv , Options ops  __attribute__((__unused__)) ,
            int func  __attribute__((__unused__)) ) 
{ 
  mnumber val ;
  char **tmp ;
  int tmp___0 ;

  {
#line 7053
  val = zero_mnumber;
  {
#line 7055
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7055
    if (! *argv) {
#line 7055
      goto while_break;
    }
    {
#line 7056
    tmp = argv;
#line 7056
    argv ++;
#line 7056
    val = matheval(*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 7058
  errflag &= -2;
#line 7060
  if (val.type == 1) {
#line 7060
    tmp___0 = val.u.l == 0L;
  } else {
#line 7060
    tmp___0 = val.u.d == 0.0;
  }
#line 7060
  return (tmp___0);
}
}
#line 7069 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_umask(char *nam , char **args , Options ops , int func  __attribute__((__unused__)) ) 
{ 
  mode_t um ;
  char *s ;
  char *who ;
  char *what ;
  char *tmp ;
  int tmp___0 ;
  zlong tmp___1 ;
  int whomask ;
  int umaskop ;
  int mask ;

  {
  {
#line 7073
  s = *args;
#line 7076
  um = umask((__mode_t )0);
#line 7077
  umask(um);
  }
#line 7079
  if (! s) {
#line 7080
    if ((int )ops->ind[83] != 0) {
#line 7081
      who = (char *)"ugo";
      {
#line 7083
      while (1) {
        while_continue: /* CIL Label */ ;
#line 7083
        if (! *who) {
#line 7083
          goto while_break;
        }
        {
#line 7084
        what = (char *)"rwx";
#line 7085
        tmp = who;
#line 7085
        who ++;
#line 7085
        printf((char const   */* __restrict  */)"%c=", (int )*tmp);
        }
        {
#line 7086
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 7086
          if (! *what) {
#line 7086
            goto while_break___0;
          }
#line 7087
          if (! (um & 256U)) {
            {
#line 7088
            putchar((int )*what);
            }
          }
#line 7089
          um <<= 1;
#line 7090
          what ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 7092
        if (*who) {
#line 7092
          tmp___0 = ',';
        } else {
#line 7092
          tmp___0 = '\n';
        }
        {
#line 7092
        putchar(tmp___0);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 7095
      if (um & 448U) {
        {
#line 7096
        putchar('0');
        }
      }
      {
#line 7097
      printf((char const   */* __restrict  */)"%03o\n", um);
      }
    }
#line 7099
    return (0);
  }
#line 7102
  if ((int )typtab[(unsigned char )*s] & 1) {
    {
#line 7104
    tmp___1 = zstrtol((char const   *)s, & s, 8);
#line 7104
    um = (mode_t )tmp___1;
    }
#line 7105
    if (*s) {
      {
#line 7106
      zwarnnam((char const   *)nam, "bad umask");
      }
#line 7107
      return (1);
    }
  } else {
    {
#line 7115
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 7118
      whomask = 0;
      {
#line 7119
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 7119
        if (! ((int )*s == 117)) {
#line 7119
          if (! ((int )*s == 103)) {
#line 7119
            if (! ((int )*s == 111)) {
#line 7119
              if (! ((int )*s == 97)) {
#line 7119
                goto while_break___2;
              }
            }
          }
        }
#line 7120
        if ((int )*s == 117) {
#line 7121
          s ++;
#line 7121
          whomask |= 448;
        } else
#line 7122
        if ((int )*s == 103) {
#line 7123
          s ++;
#line 7123
          whomask |= 56;
        } else
#line 7124
        if ((int )*s == 111) {
#line 7125
          s ++;
#line 7125
          whomask |= 7;
        } else
#line 7126
        if ((int )*s == 97) {
#line 7127
          s ++;
#line 7127
          whomask |= 511;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 7129
      if (! whomask) {
#line 7130
        whomask = 511;
      }
#line 7132
      umaskop = (int )*s;
#line 7133
      if (! (umaskop == 43)) {
#line 7133
        if (! (umaskop == 45)) {
#line 7133
          if (! (umaskop == 61)) {
#line 7134
            if (umaskop) {
              {
#line 7135
              zwarnnam((char const   *)nam, "bad symbolic mode operator: %c", umaskop);
              }
            } else {
              {
#line 7137
              zwarnnam((char const   *)nam, "bad umask");
              }
            }
#line 7138
            return (1);
          }
        }
      }
#line 7141
      mask = 0;
      {
#line 7142
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 7142
        s ++;
#line 7142
        if (*s) {
#line 7142
          if (! ((int )*s != 44)) {
#line 7142
            goto while_break___3;
          }
        } else {
#line 7142
          goto while_break___3;
        }
#line 7143
        if ((int )*s == 114) {
#line 7144
          mask |= 292 & whomask;
        } else
#line 7145
        if ((int )*s == 119) {
#line 7146
          mask |= 146 & whomask;
        } else
#line 7147
        if ((int )*s == 120) {
#line 7148
          mask |= 73 & whomask;
        } else {
          {
#line 7150
          zwarnnam((char const   *)nam, "bad symbolic mode permission: %c", (int )*s);
          }
#line 7151
          return (1);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 7154
      if (umaskop == 43) {
#line 7155
        um &= (unsigned int )(~ mask);
      } else
#line 7156
      if (umaskop == 45) {
#line 7157
        um |= (unsigned int )mask;
      } else {
#line 7159
        um = (um | (unsigned int )whomask) & (unsigned int )(~ mask);
      }
#line 7160
      if ((int )*s == 44) {
#line 7161
        s ++;
      } else {
#line 7163
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 7165
    if (*s) {
      {
#line 7166
      zwarnnam((char const   *)nam, "bad character in symbolic mode: %c", (int )*s);
      }
#line 7167
      return (1);
    }
  }
  {
#line 7172
  umask(um);
  }
#line 7173
  return (0);
}
}
#line 7179 "/tmp/zsh-5.4.2/Src/builtin.c"
int bin_notavail(char *nam , char **argv  __attribute__((__unused__)) , Options ops  __attribute__((__unused__)) ,
                 int func  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 7182
  zwarnnam((char const   *)nam, "not available on this system");
  }
#line 7183
  return (1);
}
}
#line 90 "/tmp/zsh-5.4.2/Src/./main.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 93
  tmp = zsh_main(argc, argv);
  }
#line 93
  return (tmp);
}
}
