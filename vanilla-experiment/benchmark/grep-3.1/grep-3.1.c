/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 26 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.h"
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_OVERFLOW = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
    LONGINT_INVALID = 4
} ;
#line 39 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.h"
typedef enum strtol_error strtol_error;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 61 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 111 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 25 "./unitypes.h"
typedef uint32_t ucs4_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef long ptrdiff_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_1037559258 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_1037559258 __mbstate_t;
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 169 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
struct mbchar {
   char const   *ptr ;
   size_t bytes ;
   _Bool wc_valid ;
   wchar_t wc ;
   char buf[24] ;
};
#line 181 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
typedef struct mbchar mbchar_t;
#line 108 "/home/khheo/project/benchmark/grep-3.1/lib/mbiter.h"
struct mbiter_multi {
   char const   *limit ;
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 203 "/home/khheo/project/benchmark/grep-3.1/lib/mbiter.h"
typedef struct mbiter_multi mbi_iterator_t;
#line 63 "/home/khheo/project/benchmark/grep-3.1/lib/striconv.c"
union __anonunion_tmp_771759453 {
   unsigned int align ;
   char buf[4096] ;
};
#line 24 "/home/khheo/project/benchmark/grep-3.1/lib/save-cwd.h"
struct saved_cwd {
   int desc ;
   char *name ;
};
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 32 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    shell_escape_quoting_style = 3,
    shell_escape_always_quoting_style = 4,
    c_quoting_style = 5,
    c_maybe_quoting_style = 6,
    escape_quoting_style = 7,
    locale_quoting_style = 8,
    clocale_quoting_style = 9,
    custom_quoting_style = 10
} ;
#line 270
struct quoting_options ;
#line 65 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 834 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 117 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
struct mbuiter_multi {
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 210 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
typedef struct mbuiter_multi mbui_iterator_t;
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 167 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[] ;
};
#line 174 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.h"
union __anonunion_temp_355861816 {
   size_t i ;
   void *p ;
};
#line 174 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.h"
union __anonunion_chunkfun_5259977 {
   void *(*plain)(size_t  ) ;
   void *(*extra)(void * , size_t  ) ;
};
#line 174 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.h"
union __anonunion_freefun_5259978 {
   void (*plain)(void * ) ;
   void (*extra)(void * , void * ) ;
};
#line 174 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.h"
struct obstack {
   size_t chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_355861816 temp ;
   size_t alignment_mask ;
   union __anonunion_chunkfun_5259977 chunkfun ;
   union __anonunion_freefun_5259978 freefun ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 112 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 43 "/home/khheo/project/benchmark/grep-3.1/lib/memchr2.c"
typedef unsigned long longword;
#line 52 "/home/khheo/project/benchmark/grep-3.1/lib/malloca.c"
struct preliminary_header {
   void *next ;
   int magic ;
};
#line 56 "/home/khheo/project/benchmark/grep-3.1/lib/malloca.c"
struct __anonstruct_magic_951761807 {
   char room[(((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(int )] ;
   int word ;
};
#line 56 "/home/khheo/project/benchmark/grep-3.1/lib/malloca.c"
union header {
   void *next ;
   struct __anonstruct_magic_951761807 magic ;
};
#line 65 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 82 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 82 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_656928968 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_656928968 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlockattr_t_145707745 {
   char __size[8] ;
   long __align ;
};
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlockattr_t_145707745 pthread_rwlockattr_t;
#line 288 "./glthread/lock.h"
typedef pthread_mutex_t gl_recursive_lock_t;
#line 26 "./localeinfo.h"
struct localeinfo {
   _Bool multibyte ;
   _Bool using_utf8 ;
   signed char sbclen[256] ;
   wint_t sbctowc[256] ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/i-ring.h"
struct I_ring {
   int ir_data[4] ;
   int ir_default_val ;
   unsigned int ir_front ;
   unsigned int ir_back ;
   _Bool ir_empty ;
};
#line 39 "/home/khheo/project/benchmark/grep-3.1/lib/i-ring.h"
typedef struct I_ring I_ring;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 53 "/home/khheo/project/benchmark/grep-3.1/lib/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 65 "/home/khheo/project/benchmark/grep-3.1/lib/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 67
struct hash_table ;
#line 69 "/home/khheo/project/benchmark/grep-3.1/lib/hash.h"
typedef struct hash_table Hash_table;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 46 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 52 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 143 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_109580352 {
   int __val[2] ;
};
#line 143 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_109580352 __fsid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 75 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 80 "/home/khheo/project/benchmark/grep-3.1/lib/fts_.h"
struct _ftsent ;
#line 80
struct cycle_check_state ;
#line 80 "/home/khheo/project/benchmark/grep-3.1/lib/fts_.h"
union __anonunion_fts_cycle_698394876 {
   struct hash_table *ht ;
   struct cycle_check_state *state ;
};
#line 80 "/home/khheo/project/benchmark/grep-3.1/lib/fts_.h"
struct __anonstruct_FTS_380123464 {
   struct _ftsent *fts_cur ;
   struct _ftsent *fts_child ;
   struct _ftsent **fts_array ;
   dev_t fts_dev ;
   char *fts_path ;
   int fts_rfd ;
   int fts_cwd_fd ;
   size_t fts_pathlen ;
   size_t fts_nitems ;
   int (*fts_compar)(struct _ftsent  const  ** , struct _ftsent  const  ** ) ;
   int fts_options ;
   struct hash_table *fts_leaf_optimization_works_ht ;
   union __anonunion_fts_cycle_698394876 fts_cycle ;
   I_ring fts_fd_ring ;
};
#line 80 "/home/khheo/project/benchmark/grep-3.1/lib/fts_.h"
typedef struct __anonstruct_FTS_380123464 FTS;
#line 201 "/home/khheo/project/benchmark/grep-3.1/lib/fts_.h"
struct _ftsent {
   struct _ftsent *fts_cycle ;
   struct _ftsent *fts_parent ;
   struct _ftsent *fts_link ;
   DIR *fts_dirp ;
   long fts_number ;
   void *fts_pointer ;
   char *fts_accpath ;
   char *fts_path ;
   int fts_errno ;
   int fts_symfd ;
   size_t fts_pathlen ;
   FTS *fts_fts ;
   ptrdiff_t fts_level ;
   size_t fts_namelen ;
   nlink_t fts_n_dirs_remaining ;
   unsigned short fts_info ;
   unsigned short fts_flags ;
   unsigned short fts_instr ;
   struct stat fts_statp[1] ;
   char fts_name[] ;
};
#line 201 "/home/khheo/project/benchmark/grep-3.1/lib/fts_.h"
typedef struct _ftsent FTSENT;
#line 7 "/home/khheo/project/benchmark/grep-3.1/lib/dev-ino.h"
struct dev_ino {
   ino_t st_ino ;
   dev_t st_dev ;
};
#line 28 "/home/khheo/project/benchmark/grep-3.1/lib/cycle-check.h"
struct cycle_check_state {
   struct dev_ino dev_ino ;
   uintmax_t chdir_counter ;
   int magic ;
};
#line 24 "/home/khheo/project/benchmark/grep-3.1/lib/fts-cycle.c"
struct Active_dir {
   dev_t dev ;
   ino_t ino ;
   FTSENT *fts_ent ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 762 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
struct LCO_ent {
   dev_t st_dev ;
   _Bool opt_ok ;
};
#line 57 "./regex.h"
typedef unsigned long __re_long_size_t;
#line 73 "./regex.h"
typedef unsigned long reg_syntax_t;
#line 414
struct re_dfa_t ;
#line 414 "./regex.h"
struct re_pattern_buffer {
   struct re_dfa_t *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 479 "./regex.h"
typedef struct re_pattern_buffer regex_t;
#line 491 "./regex.h"
typedef int regoff_t;
#line 518 "./regex.h"
struct __anonstruct_regmatch_t_1035675074 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 518 "./regex.h"
typedef struct __anonstruct_regmatch_t_1035675074 regmatch_t;
#line 47 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.h"
struct exclude ;
#line 76 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
union __anonunion_v_827610566 {
   char const   *pattern ;
   regex_t re ;
};
#line 76 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
struct patopts {
   int options ;
   union __anonunion_v_827610566 v ;
};
#line 88 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
struct exclude_pattern {
   struct patopts *exclude ;
   size_t exclude_alloc ;
   size_t exclude_count ;
};
#line 95
enum exclude_type {
    exclude_hash = 0,
    exclude_pattern = 1
} ;
#line 101 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
union __anonunion_v_510793701 {
   Hash_table *table ;
   struct exclude_pattern pat ;
};
#line 101 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
struct exclude_segment {
   struct exclude_segment *next ;
   enum exclude_type type ;
   int options ;
   union __anonunion_v_510793701 v ;
};
#line 113 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
struct pattern_buffer {
   struct pattern_buffer *next ;
   char *base ;
};
#line 121 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
struct exclude {
   struct exclude_segment *head ;
   struct pattern_buffer *patbuf ;
};
#line 35 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.h"
struct dfamust {
   _Bool exact ;
   _Bool begline ;
   _Bool endline ;
   char *must ;
};
#line 44
struct dfa ;
#line 82 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
typedef unsigned long charclass_word;
#line 114 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct __anonstruct_charclass_425059741 {
   charclass_word w[4] ;
};
#line 114 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
typedef struct __anonstruct_charclass_425059741 charclass;
#line 216 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
typedef ptrdiff_t token;
#line 221 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
typedef ptrdiff_t state_num;
#line 316 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct __anonstruct_position_1023785459 {
   size_t index ;
   unsigned int constraint ;
};
#line 316 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
typedef struct __anonstruct_position_1023785459 position;
#line 323 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct __anonstruct_position_set_349475030 {
   position *elems ;
   ptrdiff_t nelem ;
   ptrdiff_t alloc ;
};
#line 323 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
typedef struct __anonstruct_position_set_349475030 position_set;
#line 331 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct __anonstruct_leaf_set_73278319 {
   size_t *elems ;
   size_t nelem ;
};
#line 331 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
typedef struct __anonstruct_leaf_set_73278319 leaf_set;
#line 340 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct __anonstruct_dfa_state_810101419 {
   size_t hash ;
   position_set elems ;
   unsigned char context ;
   unsigned short constraint ;
   token first_end ;
   position_set mbps ;
   state_num mb_trindex ;
};
#line 340 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
typedef struct __anonstruct_dfa_state_810101419 dfa_state;
#line 361 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct mb_char_classes {
   ptrdiff_t cset ;
   _Bool invert ;
   wchar_t *chars ;
   ptrdiff_t nchars ;
   ptrdiff_t nchars_alloc ;
};
#line 370 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct regex_syntax {
   reg_syntax_t syntax_bits ;
   _Bool syntax_bits_set ;
   _Bool case_fold ;
   _Bool anchor ;
   unsigned char eolbyte ;
   char sbit[256] ;
   _Bool never_trail[256] ;
   charclass letters ;
   charclass newline ;
};
#line 404 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct lexer_state {
   char const   *ptr ;
   size_t left ;
   token lasttok ;
   size_t parens ;
   int minrep ;
   int maxrep ;
   wint_t wctok ;
   int cur_mb_len ;
   struct mb_char_classes brack ;
   _Bool laststart ;
};
#line 429 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct parser_state {
   token tok ;
   size_t depth ;
};
#line 440 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct dfa {
   struct regex_syntax syntax ;
   charclass *charclasses ;
   ptrdiff_t cindex ;
   ptrdiff_t calloc ;
   size_t canychar ;
   struct lexer_state lex ;
   struct parser_state parse ;
   token *tokens ;
   size_t tindex ;
   size_t talloc ;
   size_t depth ;
   size_t nleaves ;
   size_t nregexps ;
   _Bool fast ;
   token utf8_anychar_classes[5] ;
   mbstate_t mbs ;
   char *multibyte_prop ;
   struct dfa *superset ;
   dfa_state *states ;
   state_num sindex ;
   ptrdiff_t salloc ;
   position_set *follows ;
   _Bool searchflag ;
   state_num tralloc ;
   int trcount ;
   int min_trcount ;
   state_num **trans ;
   state_num **fails ;
   char *success ;
   state_num *newlines ;
   state_num initstate_notbol ;
   position_set mb_follows ;
   state_num **mb_trans ;
   state_num mb_trcount ;
   char *(*dfaexec)(struct dfa * , char const   * , char * , _Bool  , size_t * , _Bool * ) ;
   _Bool simple_locale ;
   struct localeinfo localeinfo ;
};
#line 962 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
typedef int predicate(int  );
#line 968 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct dfa_ctype {
   char const   *name ;
   predicate *func ;
   _Bool single_byte_only ;
};
#line 1227 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct lexptr {
   char const   *ptr ;
   size_t left ;
};
#line 2371 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct __anonstruct_stkalloc_360611398 {
   _Bool nullable ;
   size_t nfirstpos ;
   size_t nlastpos ;
};
#line 3723
struct must ;
#line 3723 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
typedef struct must must;
#line 3725 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct must {
   char **in ;
   char *left ;
   char *right ;
   char *is ;
   _Bool begline ;
   _Bool endline ;
   must *prev ;
};
#line 41 "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c"
struct cd_buf {
   int fd ;
};
#line 63 "/home/khheo/project/benchmark/grep-3.1/lib/striconv.c"
union __anonunion_tmp_771759453___0 {
   unsigned int align ;
   char buf[4096] ;
};
#line 2371 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct __anonstruct_stkalloc_360611398___0 {
   _Bool nullable ;
   size_t nfirstpos ;
   size_t nlastpos ;
};
#line 34 "/home/khheo/project/benchmark/grep-3.1/src/kwset.h"
struct kwset ;
#line 35 "/home/khheo/project/benchmark/grep-3.1/src/kwset.h"
typedef struct kwset *kwset_t;
#line 324 "/usr/include/pcre.h"
struct real_pcre ;
#line 325 "/usr/include/pcre.h"
typedef struct real_pcre pcre;
#line 333
struct real_pcre_jit_stack ;
#line 334 "/usr/include/pcre.h"
typedef struct real_pcre_jit_stack pcre_jit_stack;
#line 376 "/usr/include/pcre.h"
struct pcre_extra {
   unsigned long flags ;
   void *study_data ;
   unsigned long match_limit ;
   void *callout_data ;
   unsigned char const   *tables ;
   unsigned long match_limit_recursion ;
   unsigned char **mark ;
   void *executable_jit ;
};
#line 376 "/usr/include/pcre.h"
typedef struct pcre_extra pcre_extra;
#line 36 "/home/khheo/project/benchmark/grep-3.1/src/pcresearch.c"
struct pcre_comp {
   pcre *cre ;
   pcre_extra *extra ;
   pcre_jit_stack *jit_stack ;
   int jit_stack_size ;
   int empty_match[2] ;
};
#line 25 "/home/khheo/project/benchmark/grep-3.1/src/kwset.h"
struct kwsmatch {
   ptrdiff_t index ;
   ptrdiff_t offset[1] ;
   ptrdiff_t size[1] ;
};
#line 61 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
struct trie ;
#line 61 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
struct tree {
   struct tree *llink ;
   struct tree *rlink ;
   struct trie *trie ;
   unsigned char label ;
   char balance ;
};
#line 71 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
struct trie {
   size_t accepting ;
   struct tree *links ;
   struct trie *parent ;
   struct trie *next ;
   struct trie *fail ;
   ptrdiff_t depth ;
   ptrdiff_t shift ;
   ptrdiff_t maxshift ;
};
#line 89 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
struct kwset {
   struct obstack obstack ;
   ptrdiff_t words ;
   struct trie *trie ;
   ptrdiff_t mind ;
   ptrdiff_t maxd ;
   unsigned char delta[256] ;
   struct trie *next[256] ;
   char *target ;
   ptrdiff_t *shift ;
   char const   *trans ;
   int gc1 ;
   int gc1help ;
   char gc2 ;
   ptrdiff_t (*kwsexec)(kwset_t  , char const   * , ptrdiff_t  , struct kwsmatch * ,
                        _Bool  ) ;
};
#line 195
enum __anonenum_dirs_744895363 {
    L = 0,
    R = 1
} ;
#line 26 "/home/khheo/project/benchmark/grep-3.1/src/kwsearch.c"
struct kwsearch {
   kwset_t kwset ;
   ptrdiff_t words ;
   char *pattern ;
   size_t size ;
   void *re ;
};
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 89 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
struct FL_pair {
   char const   *filename ;
   size_t lineno ;
};
#line 327 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
struct color_cap {
   char const   *name ;
   char const   **var ;
   void (*fct)(void) ;
};
#line 506
enum directories_type {
    READ_DIRECTORIES = 2,
    RECURSE_DIRECTORIES = 3,
    SKIP_DIRECTORIES = 4
} ;
#line 530
enum __anonenum_devices_473526324 {
    READ_COMMAND_LINE_DEVICES = 0,
    READ_DEVICES = 1,
    SKIP_DEVICES = 2
} ;
#line 623 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
typedef uintmax_t uword;
#line 989
enum __anonenum_binary_files_601436154 {
    BINARY_BINARY_FILES = 0,
    TEXT_BINARY_FILES = 1,
    WITHOUT_MATCH_BINARY_FILES = 2
} ;
#line 997
enum __anonenum_list_files_328606374 {
    LISTFILES_NONE = 0,
    LISTFILES_MATCHING = 1,
    LISTFILES_NONMATCHING = 2
} ;
#line 2006 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
struct __anonstruct_matchers_307522949 {
   char const   name[12] ;
   int syntax ;
   void *(*compile)(char * , size_t  , reg_syntax_t  ) ;
   size_t (*execute)(void * , char const   * , size_t  , size_t * , char const   * ) ;
};
#line 56 "../lib/regex.h"
typedef unsigned int __re_size_t;
#line 498 "../lib/regex.h"
struct re_registers {
   __re_size_t num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 27 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
struct dfa_comp {
   kwset_t kwset ;
   struct dfa *dfa ;
   struct re_pattern_buffer *patterns ;
   size_t pcount ;
   struct re_registers regs ;
   ptrdiff_t kwset_exact_matches ;
   _Bool begline ;
};
#line 45 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.h"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 225 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 59 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
static strtol_error bkm_scale(unsigned long *x , int scale_factor ) 
{ 


  {
#line 67
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 69
    *x = 0xffffffffffffffffUL;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (unsigned long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power(unsigned long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  unsigned long tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c",
                    96U, "xstrtoul");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c",
                  96U, "xstrtoul");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
  {
#line 100
  tmp___1 = __errno_location();
#line 100
  *tmp___1 = 0;
#line 104
  q = s;
#line 105
  ch = (unsigned char )*q;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    tmp___2 = __ctype_b_loc();
    }
#line 106
    if (! ((int const   )*(*tmp___2 + (int )ch) & 8192)) {
#line 106
      goto while_break;
    }
#line 107
    q ++;
#line 107
    ch = (unsigned char )*q;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if ((int )ch == 45) {
#line 109
    return ((strtol_error )4);
  }
  {
#line 112
  tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 114
  if ((unsigned long )*p == (unsigned long )s) {
#line 118
    if (valid_suffixes) {
#line 118
      if (*(*p)) {
        {
#line 118
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 118
        if (tmp___3) {
#line 119
          tmp = 1UL;
        } else {
#line 121
          return ((strtol_error )4);
        }
      } else {
#line 121
        return ((strtol_error )4);
      }
    } else {
#line 121
      return ((strtol_error )4);
    }
  } else {
    {
#line 123
    tmp___5 = __errno_location();
    }
#line 123
    if (*tmp___5 != 0) {
      {
#line 125
      tmp___4 = __errno_location();
      }
#line 125
      if (*tmp___4 != 34) {
#line 126
        return ((strtol_error )4);
      }
#line 127
      err = (strtol_error )1;
    }
  }
#line 133
  if (! valid_suffixes) {
#line 135
    *val = tmp;
#line 136
    return (err);
  }
#line 139
  if ((int )*(*p) != 0) {
    {
#line 141
    base = 1024;
#line 142
    suffixes = 1;
#line 145
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 145
    if (! tmp___6) {
#line 147
      *val = tmp;
#line 148
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 154
    if ((int )*(*p) == 90) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 89) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 116) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 84) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 80) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 109) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 77) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 75) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 107) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 103) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 71) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 69) {
#line 154
      goto case_90;
    }
#line 151
    goto switch_break;
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_69: /* CIL Label */ 
    {
#line 163
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 163
    if (tmp___7) {
      {
#line 166
      if ((int )*(*(p + 0) + 1) == 105) {
#line 166
        goto case_105;
      }
#line 172
      if ((int )*(*(p + 0) + 1) == 68) {
#line 172
        goto case_68;
      }
#line 172
      if ((int )*(*(p + 0) + 1) == 66) {
#line 172
        goto case_68;
      }
#line 164
      goto switch_break___0;
      case_105: /* CIL Label */ 
#line 167
      if ((int )*(*(p + 0) + 2) == 66) {
#line 168
        suffixes += 2;
      }
#line 169
      goto switch_break___0;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 173
      base = 1000;
#line 174
      suffixes ++;
#line 175
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 181
    if ((int )*(*p) == 98) {
#line 181
      goto case_98;
    }
#line 185
    if ((int )*(*p) == 66) {
#line 185
      goto case_66___0;
    }
#line 192
    if ((int )*(*p) == 99) {
#line 192
      goto case_99;
    }
#line 196
    if ((int )*(*p) == 69) {
#line 196
      goto case_69___0;
    }
#line 201
    if ((int )*(*p) == 103) {
#line 201
      goto case_103___0;
    }
#line 201
    if ((int )*(*p) == 71) {
#line 201
      goto case_103___0;
    }
#line 206
    if ((int )*(*p) == 75) {
#line 206
      goto case_75___0;
    }
#line 206
    if ((int )*(*p) == 107) {
#line 206
      goto case_75___0;
    }
#line 211
    if ((int )*(*p) == 109) {
#line 211
      goto case_109___0;
    }
#line 211
    if ((int )*(*p) == 77) {
#line 211
      goto case_109___0;
    }
#line 215
    if ((int )*(*p) == 80) {
#line 215
      goto case_80___0;
    }
#line 220
    if ((int )*(*p) == 116) {
#line 220
      goto case_116___0;
    }
#line 220
    if ((int )*(*p) == 84) {
#line 220
      goto case_116___0;
    }
#line 224
    if ((int )*(*p) == 119) {
#line 224
      goto case_119;
    }
#line 228
    if ((int )*(*p) == 89) {
#line 228
      goto case_89___0;
    }
#line 232
    if ((int )*(*p) == 90) {
#line 232
      goto case_90___0;
    }
#line 236
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 182
    overflow = bkm_scale(& tmp, 512);
    }
#line 183
    goto switch_break___1;
    case_66___0: /* CIL Label */ 
    {
#line 189
    overflow = bkm_scale(& tmp, 1024);
    }
#line 190
    goto switch_break___1;
    case_99: /* CIL Label */ 
#line 193
    overflow = (strtol_error )0;
#line 194
    goto switch_break___1;
    case_69___0: /* CIL Label */ 
    {
#line 197
    overflow = bkm_scale_by_power(& tmp, base, 6);
    }
#line 198
    goto switch_break___1;
    case_103___0: /* CIL Label */ 
    case_71___0: /* CIL Label */ 
    {
#line 202
    overflow = bkm_scale_by_power(& tmp, base, 3);
    }
#line 203
    goto switch_break___1;
    case_75___0: /* CIL Label */ 
    case_107___0: /* CIL Label */ 
    {
#line 207
    overflow = bkm_scale_by_power(& tmp, base, 1);
    }
#line 208
    goto switch_break___1;
    case_109___0: /* CIL Label */ 
    case_77___0: /* CIL Label */ 
    {
#line 212
    overflow = bkm_scale_by_power(& tmp, base, 2);
    }
#line 213
    goto switch_break___1;
    case_80___0: /* CIL Label */ 
    {
#line 216
    overflow = bkm_scale_by_power(& tmp, base, 5);
    }
#line 217
    goto switch_break___1;
    case_116___0: /* CIL Label */ 
    case_84___0: /* CIL Label */ 
    {
#line 221
    overflow = bkm_scale_by_power(& tmp, base, 4);
    }
#line 222
    goto switch_break___1;
    case_119: /* CIL Label */ 
    {
#line 225
    overflow = bkm_scale(& tmp, 2);
    }
#line 226
    goto switch_break___1;
    case_89___0: /* CIL Label */ 
    {
#line 229
    overflow = bkm_scale_by_power(& tmp, base, 8);
    }
#line 230
    goto switch_break___1;
    case_90___0: /* CIL Label */ 
    {
#line 233
    overflow = bkm_scale_by_power(& tmp, base, 7);
    }
#line 234
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 237
    *val = tmp;
#line 238
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___1: /* CIL Label */ ;
    }
#line 241
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 242
    *p += suffixes;
#line 243
    if (*(*p)) {
#line 244
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 247
  *val = tmp;
#line 248
  return (err);
}
}
#line 44 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.h"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) ;
#line 176 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 59 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
static strtol_error bkm_scale___0(long *x , int scale_factor ) 
{ 


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___0(long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___0(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  long tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c",
                    96U, "xstrtol");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c",
                  96U, "xstrtol");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
  {
#line 100
  tmp___1 = __errno_location();
#line 100
  *tmp___1 = 0;
#line 112
  tmp = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 114
  if ((unsigned long )*p == (unsigned long )s) {
#line 118
    if (valid_suffixes) {
#line 118
      if (*(*p)) {
        {
#line 118
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 118
        if (tmp___3) {
#line 119
          tmp = 1L;
        } else {
#line 121
          return ((strtol_error )4);
        }
      } else {
#line 121
        return ((strtol_error )4);
      }
    } else {
#line 121
      return ((strtol_error )4);
    }
  } else {
    {
#line 123
    tmp___5 = __errno_location();
    }
#line 123
    if (*tmp___5 != 0) {
      {
#line 125
      tmp___4 = __errno_location();
      }
#line 125
      if (*tmp___4 != 34) {
#line 126
        return ((strtol_error )4);
      }
#line 127
      err = (strtol_error )1;
    }
  }
#line 133
  if (! valid_suffixes) {
#line 135
    *val = tmp;
#line 136
    return (err);
  }
#line 139
  if ((int )*(*p) != 0) {
    {
#line 141
    base = 1024;
#line 142
    suffixes = 1;
#line 145
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 145
    if (! tmp___6) {
#line 147
      *val = tmp;
#line 148
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 154
    if ((int )*(*p) == 90) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 89) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 116) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 84) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 80) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 109) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 77) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 75) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 107) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 103) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 71) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 69) {
#line 154
      goto case_90;
    }
#line 151
    goto switch_break;
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_69: /* CIL Label */ 
    {
#line 163
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 163
    if (tmp___7) {
      {
#line 166
      if ((int )*(*(p + 0) + 1) == 105) {
#line 166
        goto case_105;
      }
#line 172
      if ((int )*(*(p + 0) + 1) == 68) {
#line 172
        goto case_68;
      }
#line 172
      if ((int )*(*(p + 0) + 1) == 66) {
#line 172
        goto case_68;
      }
#line 164
      goto switch_break___0;
      case_105: /* CIL Label */ 
#line 167
      if ((int )*(*(p + 0) + 2) == 66) {
#line 168
        suffixes += 2;
      }
#line 169
      goto switch_break___0;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 173
      base = 1000;
#line 174
      suffixes ++;
#line 175
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 181
    if ((int )*(*p) == 98) {
#line 181
      goto case_98;
    }
#line 185
    if ((int )*(*p) == 66) {
#line 185
      goto case_66___0;
    }
#line 192
    if ((int )*(*p) == 99) {
#line 192
      goto case_99;
    }
#line 196
    if ((int )*(*p) == 69) {
#line 196
      goto case_69___0;
    }
#line 201
    if ((int )*(*p) == 103) {
#line 201
      goto case_103___0;
    }
#line 201
    if ((int )*(*p) == 71) {
#line 201
      goto case_103___0;
    }
#line 206
    if ((int )*(*p) == 75) {
#line 206
      goto case_75___0;
    }
#line 206
    if ((int )*(*p) == 107) {
#line 206
      goto case_75___0;
    }
#line 211
    if ((int )*(*p) == 109) {
#line 211
      goto case_109___0;
    }
#line 211
    if ((int )*(*p) == 77) {
#line 211
      goto case_109___0;
    }
#line 215
    if ((int )*(*p) == 80) {
#line 215
      goto case_80___0;
    }
#line 220
    if ((int )*(*p) == 116) {
#line 220
      goto case_116___0;
    }
#line 220
    if ((int )*(*p) == 84) {
#line 220
      goto case_116___0;
    }
#line 224
    if ((int )*(*p) == 119) {
#line 224
      goto case_119;
    }
#line 228
    if ((int )*(*p) == 89) {
#line 228
      goto case_89___0;
    }
#line 232
    if ((int )*(*p) == 90) {
#line 232
      goto case_90___0;
    }
#line 236
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 182
    overflow = bkm_scale___0(& tmp, 512);
    }
#line 183
    goto switch_break___1;
    case_66___0: /* CIL Label */ 
    {
#line 189
    overflow = bkm_scale___0(& tmp, 1024);
    }
#line 190
    goto switch_break___1;
    case_99: /* CIL Label */ 
#line 193
    overflow = (strtol_error )0;
#line 194
    goto switch_break___1;
    case_69___0: /* CIL Label */ 
    {
#line 197
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
    }
#line 198
    goto switch_break___1;
    case_103___0: /* CIL Label */ 
    case_71___0: /* CIL Label */ 
    {
#line 202
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
    }
#line 203
    goto switch_break___1;
    case_75___0: /* CIL Label */ 
    case_107___0: /* CIL Label */ 
    {
#line 207
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
    }
#line 208
    goto switch_break___1;
    case_109___0: /* CIL Label */ 
    case_77___0: /* CIL Label */ 
    {
#line 212
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
    }
#line 213
    goto switch_break___1;
    case_80___0: /* CIL Label */ 
    {
#line 216
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
    }
#line 217
    goto switch_break___1;
    case_116___0: /* CIL Label */ 
    case_84___0: /* CIL Label */ 
    {
#line 221
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
    }
#line 222
    goto switch_break___1;
    case_119: /* CIL Label */ 
    {
#line 225
    overflow = bkm_scale___0(& tmp, 2);
    }
#line 226
    goto switch_break___1;
    case_89___0: /* CIL Label */ 
    {
#line 229
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
    }
#line 230
    goto switch_break___1;
    case_90___0: /* CIL Label */ 
    {
#line 233
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
    }
#line 234
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 237
    *val = tmp;
#line 238
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___1: /* CIL Label */ ;
    }
#line 241
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 242
    *p += suffixes;
#line 243
    if (*(*p)) {
#line 244
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 247
  *val = tmp;
#line 248
  return (err);
}
}
#line 69 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.h"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                   char const   *arg ) ;
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 52 "/home/khheo/project/benchmark/grep-3.1/lib/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 18 "/home/khheo/project/benchmark/grep-3.1/lib/exitfail.h"
int volatile   exit_failure ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 46 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol-error.c"
static void xstrtol_error(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                          char const   *arg , int exit_status ) 
{ 
  char const   *hyphens ;
  char const   *msgid ;
  char const   *option ;
  char option_buffer[2] ;
  char *tmp ;

  {
#line 52
  hyphens = "--";
  {
#line 62
  if ((unsigned int )err == 4U) {
#line 62
    goto case_4;
  }
#line 67
  if ((unsigned int )err == 3U) {
#line 67
    goto case_3;
  }
#line 67
  if ((unsigned int )err == 2U) {
#line 67
    goto case_3;
  }
#line 71
  if ((unsigned int )err == 1U) {
#line 71
    goto case_1;
  }
#line 59
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 60
  abort();
  }
  case_4: /* CIL Label */ 
#line 63
  msgid = "invalid %s%s argument \'%s\'";
#line 64
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 68
  msgid = "invalid suffix in %s%s argument \'%s\'";
#line 69
  goto switch_break;
  case_1: /* CIL Label */ 
#line 72
  msgid = "%s%s argument \'%s\' too large";
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    option = (char const   *)(option_buffer);
  } else {
#line 84
    option = (char const   *)(long_options___0 + opt_idx)->name;
  }
  {
#line 86
  tmp = gettext(msgid);
#line 86
  error(exit_status, 0, (char const   *)tmp, hyphens, option, arg);
  }
#line 87
  return;
}
}
#line 91 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol-error.c"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                   char const   *arg ) 
{ 


  {
  {
#line 96
  xstrtol_error(err, opt_idx, c, long_options___0, arg, (int )exit_failure);
#line 97
  abort();
  }
}
}
#line 297 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__leaf__)) strtoimax)(char const   * __restrict  __nptr ,
                                                                                     char ** __restrict  __endptr ,
                                                                                     int __base ) ;
#line 46 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.h"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) ;
#line 59 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
static strtol_error bkm_scale___1(intmax_t *x , int scale_factor ) 
{ 


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (intmax_t )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___1(intmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___1(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  intmax_t tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c",
                    96U, "xstrtoimax");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c",
                  96U, "xstrtoimax");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
  {
#line 100
  tmp___1 = __errno_location();
#line 100
  *tmp___1 = 0;
#line 112
  tmp = strtoimax((char const   */* __restrict  */)s, (char **/* __restrict  */)p,
                  strtol_base);
  }
#line 114
  if ((unsigned long )*p == (unsigned long )s) {
#line 118
    if (valid_suffixes) {
#line 118
      if (*(*p)) {
        {
#line 118
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 118
        if (tmp___3) {
#line 119
          tmp = (intmax_t )1;
        } else {
#line 121
          return ((strtol_error )4);
        }
      } else {
#line 121
        return ((strtol_error )4);
      }
    } else {
#line 121
      return ((strtol_error )4);
    }
  } else {
    {
#line 123
    tmp___5 = __errno_location();
    }
#line 123
    if (*tmp___5 != 0) {
      {
#line 125
      tmp___4 = __errno_location();
      }
#line 125
      if (*tmp___4 != 34) {
#line 126
        return ((strtol_error )4);
      }
#line 127
      err = (strtol_error )1;
    }
  }
#line 133
  if (! valid_suffixes) {
#line 135
    *val = tmp;
#line 136
    return (err);
  }
#line 139
  if ((int )*(*p) != 0) {
    {
#line 141
    base = 1024;
#line 142
    suffixes = 1;
#line 145
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 145
    if (! tmp___6) {
#line 147
      *val = tmp;
#line 148
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 154
    if ((int )*(*p) == 90) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 89) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 116) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 84) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 80) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 109) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 77) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 75) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 107) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 103) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 71) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 69) {
#line 154
      goto case_90;
    }
#line 151
    goto switch_break;
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_69: /* CIL Label */ 
    {
#line 163
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 163
    if (tmp___7) {
      {
#line 166
      if ((int )*(*(p + 0) + 1) == 105) {
#line 166
        goto case_105;
      }
#line 172
      if ((int )*(*(p + 0) + 1) == 68) {
#line 172
        goto case_68;
      }
#line 172
      if ((int )*(*(p + 0) + 1) == 66) {
#line 172
        goto case_68;
      }
#line 164
      goto switch_break___0;
      case_105: /* CIL Label */ 
#line 167
      if ((int )*(*(p + 0) + 2) == 66) {
#line 168
        suffixes += 2;
      }
#line 169
      goto switch_break___0;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 173
      base = 1000;
#line 174
      suffixes ++;
#line 175
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 181
    if ((int )*(*p) == 98) {
#line 181
      goto case_98;
    }
#line 185
    if ((int )*(*p) == 66) {
#line 185
      goto case_66___0;
    }
#line 192
    if ((int )*(*p) == 99) {
#line 192
      goto case_99;
    }
#line 196
    if ((int )*(*p) == 69) {
#line 196
      goto case_69___0;
    }
#line 201
    if ((int )*(*p) == 103) {
#line 201
      goto case_103___0;
    }
#line 201
    if ((int )*(*p) == 71) {
#line 201
      goto case_103___0;
    }
#line 206
    if ((int )*(*p) == 75) {
#line 206
      goto case_75___0;
    }
#line 206
    if ((int )*(*p) == 107) {
#line 206
      goto case_75___0;
    }
#line 211
    if ((int )*(*p) == 109) {
#line 211
      goto case_109___0;
    }
#line 211
    if ((int )*(*p) == 77) {
#line 211
      goto case_109___0;
    }
#line 215
    if ((int )*(*p) == 80) {
#line 215
      goto case_80___0;
    }
#line 220
    if ((int )*(*p) == 116) {
#line 220
      goto case_116___0;
    }
#line 220
    if ((int )*(*p) == 84) {
#line 220
      goto case_116___0;
    }
#line 224
    if ((int )*(*p) == 119) {
#line 224
      goto case_119;
    }
#line 228
    if ((int )*(*p) == 89) {
#line 228
      goto case_89___0;
    }
#line 232
    if ((int )*(*p) == 90) {
#line 232
      goto case_90___0;
    }
#line 236
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 182
    overflow = bkm_scale___1(& tmp, 512);
    }
#line 183
    goto switch_break___1;
    case_66___0: /* CIL Label */ 
    {
#line 189
    overflow = bkm_scale___1(& tmp, 1024);
    }
#line 190
    goto switch_break___1;
    case_99: /* CIL Label */ 
#line 193
    overflow = (strtol_error )0;
#line 194
    goto switch_break___1;
    case_69___0: /* CIL Label */ 
    {
#line 197
    overflow = bkm_scale_by_power___1(& tmp, base, 6);
    }
#line 198
    goto switch_break___1;
    case_103___0: /* CIL Label */ 
    case_71___0: /* CIL Label */ 
    {
#line 202
    overflow = bkm_scale_by_power___1(& tmp, base, 3);
    }
#line 203
    goto switch_break___1;
    case_75___0: /* CIL Label */ 
    case_107___0: /* CIL Label */ 
    {
#line 207
    overflow = bkm_scale_by_power___1(& tmp, base, 1);
    }
#line 208
    goto switch_break___1;
    case_109___0: /* CIL Label */ 
    case_77___0: /* CIL Label */ 
    {
#line 212
    overflow = bkm_scale_by_power___1(& tmp, base, 2);
    }
#line 213
    goto switch_break___1;
    case_80___0: /* CIL Label */ 
    {
#line 216
    overflow = bkm_scale_by_power___1(& tmp, base, 5);
    }
#line 217
    goto switch_break___1;
    case_116___0: /* CIL Label */ 
    case_84___0: /* CIL Label */ 
    {
#line 221
    overflow = bkm_scale_by_power___1(& tmp, base, 4);
    }
#line 222
    goto switch_break___1;
    case_119: /* CIL Label */ 
    {
#line 225
    overflow = bkm_scale___1(& tmp, 2);
    }
#line 226
    goto switch_break___1;
    case_89___0: /* CIL Label */ 
    {
#line 229
    overflow = bkm_scale_by_power___1(& tmp, base, 8);
    }
#line 230
    goto switch_break___1;
    case_90___0: /* CIL Label */ 
    {
#line 233
    overflow = bkm_scale_by_power___1(& tmp, base, 7);
    }
#line 234
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 237
    *val = tmp;
#line 238
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___1: /* CIL Label */ ;
    }
#line 241
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 242
    *p += suffixes;
#line 243
    if (*(*p)) {
#line 244
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 247
  *val = tmp;
#line 248
  return (err);
}
}
#line 45 "/home/khheo/project/benchmark/grep-3.1/lib/xstriconv.h"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) ;
#line 57
char *xstr_cd_iconv(char const   *src , iconv_t cd ) ;
#line 69
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 44 "/home/khheo/project/benchmark/grep-3.1/lib/striconv.h"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) ;
#line 55
char *str_cd_iconv(char const   *src , iconv_t cd ) ;
#line 66
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 57
void xalloc_die(void) ;
#line 59
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 65
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 102
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 104
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 104 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
__inline void *xnmalloc(size_t n , size_t s ) 
{ 
  void *tmp ;

  {
#line 107
  if (9223372036854775807UL / s < n) {
    {
#line 108
    xalloc_die();
    }
  }
  {
#line 109
  tmp = xmalloc(n * s);
  }
#line 109
  return (tmp);
}
}
#line 115
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 117
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 117 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
__inline void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  void *tmp ;

  {
#line 120
  if (9223372036854775807UL / s < n) {
    {
#line 121
    xalloc_die();
    }
  }
  {
#line 122
  tmp = xrealloc(p, n * s);
  }
#line 122
  return (tmp);
}
}
#line 179 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
__inline void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 182
  n = *pn;
#line 184
  if (! p) {
#line 186
    if (! n) {
#line 194
      n = 128UL / s;
#line 195
      n += (size_t )(! n);
    }
#line 197
    if (9223372036854775807UL / s < n) {
      {
#line 198
      xalloc_die();
      }
    }
  } else {
#line 206
    if (6148914691236517204UL / s <= n) {
      {
#line 208
      xalloc_die();
      }
    }
#line 209
    n += n / 2UL + 1UL;
  }
  {
#line 212
  *pn = n;
#line 213
  tmp = xrealloc(p, n * s);
  }
#line 213
  return (tmp);
}
}
#line 219
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 221
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 221 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
__inline char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 224
  if (sizeof(char ) == 1UL) {
    {
#line 224
    tmp = xmalloc(n);
#line 224
    tmp___1 = tmp;
    }
  } else {
    {
#line 224
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 224
    tmp___1 = tmp___0;
    }
  }
#line 224
  return ((char *)tmp___1);
}
}
#line 266
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/xstriconv.c"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) 
{ 
  int retval ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 35
  tmp = mem_cd_iconv(src, srclen, cd, resultp, lengthp);
#line 35
  retval = tmp;
  }
#line 37
  if (retval < 0) {
    {
#line 37
    tmp___0 = __errno_location();
    }
#line 37
    if (*tmp___0 == 12) {
      {
#line 38
      xalloc_die();
      }
    }
  }
#line 39
  return (retval);
}
}
#line 42 "/home/khheo/project/benchmark/grep-3.1/lib/xstriconv.c"
char *xstr_cd_iconv(char const   *src , iconv_t cd ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 45
  tmp = str_cd_iconv(src, cd);
#line 45
  result = tmp;
  }
#line 47
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 47
    tmp___0 = __errno_location();
    }
#line 47
    if (*tmp___0 == 12) {
      {
#line 48
      xalloc_die();
      }
    }
  }
#line 49
  return (result);
}
}
#line 54 "/home/khheo/project/benchmark/grep-3.1/lib/xstriconv.c"
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 57
  tmp = str_iconv(src, from_codeset, to_codeset);
#line 57
  result = tmp;
  }
#line 59
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 59
    tmp___0 = __errno_location();
    }
#line 59
    if (*tmp___0 == 12) {
      {
#line 60
      xalloc_die();
      }
    }
  }
#line 61
  return (result);
}
}
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 61
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 63
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 67
void *x2realloc(void *p , size_t *pn ) ;
#line 68
void *xmemdup(void const   *p , size_t s )  __attribute__((__alloc_size__(2))) ;
#line 70
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 266
#pragma GCC diagnostic pop
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 38 "/home/khheo/project/benchmark/grep-3.1/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 38 "/home/khheo/project/benchmark/grep-3.1/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc(n);
#line 41
  p = tmp;
  }
#line 42
  if (! p) {
#line 42
    if (n != 0UL) {
      {
#line 43
      xalloc_die();
      }
    }
  }
#line 44
  return (p);
}
}
#line 50
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 50 "/home/khheo/project/benchmark/grep-3.1/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 53
  if (! n) {
#line 53
    if (p) {
      {
#line 57
      free(p);
      }
#line 58
      return ((void *)0);
    }
  }
  {
#line 61
  p = realloc(p, n);
  }
#line 62
  if (! p) {
#line 62
    if (n) {
      {
#line 63
      xalloc_die();
      }
    }
  }
#line 64
  return (p);
}
}
#line 73 "/home/khheo/project/benchmark/grep-3.1/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 76
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 76
  return (tmp);
}
}
#line 83
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 83 "/home/khheo/project/benchmark/grep-3.1/lib/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 86
  tmp = xmalloc(s);
#line 86
  tmp___0 = memset(tmp, 0, s);
  }
#line 86
  return (tmp___0);
}
}
#line 92
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 92 "/home/khheo/project/benchmark/grep-3.1/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
#line 100
  if (9223372036854775807UL / s < n) {
    {
#line 102
    xalloc_die();
    }
  } else {
    {
#line 100
    p = calloc(n, s);
    }
#line 100
    if (! p) {
      {
#line 102
      xalloc_die();
      }
    }
  }
#line 103
  return (p);
}
}
#line 110
void *xmemdup(void const   *p , size_t s )  __attribute__((__alloc_size__(2))) ;
#line 110 "/home/khheo/project/benchmark/grep-3.1/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 113
  tmp = xmalloc(s);
#line 113
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 113
  return (tmp___0);
}
}
#line 118
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 118 "/home/khheo/project/benchmark/grep-3.1/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 121
  tmp = strlen(string);
#line 121
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  }
#line 121
  return ((char *)tmp___0);
}
}
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 49 "/home/khheo/project/benchmark/grep-3.1/lib/binary-io.h"
__inline int __gl_setmode(int fd , int mode ) 
{ 


  {
#line 54
  return (0);
}
}
#line 61 "/home/khheo/project/benchmark/grep-3.1/lib/binary-io.h"
__inline int __gl_setmode_check(int fd ) 
{ 


  {
#line 62
  return (0);
}
}
#line 71 "/home/khheo/project/benchmark/grep-3.1/lib/binary-io.h"
__inline int set_binary_mode(int fd , int mode ) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 74
  tmp = __gl_setmode_check(fd);
#line 74
  r = tmp;
  }
#line 75
  if (r != 0) {
#line 75
    tmp___1 = r;
  } else {
    {
#line 75
    tmp___0 = __gl_setmode(fd, mode);
#line 75
    tmp___1 = tmp___0;
    }
  }
#line 75
  return (tmp___1);
}
}
#line 81
#pragma GCC diagnostic pop
#line 25 "/home/khheo/project/benchmark/grep-3.1/lib/xbinary-io.h"
#pragma GCC diagnostic push
#line 25
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 25
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 33 "/home/khheo/project/benchmark/grep-3.1/lib/xbinary-io.h"
__inline void xset_binary_mode_error(void) 
{ 


  {
#line 33
  return;
}
}
#line 39 "/home/khheo/project/benchmark/grep-3.1/lib/xbinary-io.h"
__inline void xset_binary_mode(int fd , int mode ) 
{ 
  int tmp ;

  {
  {
#line 42
  tmp = set_binary_mode(fd, mode);
  }
#line 42
  if (tmp < 0) {
    {
#line 43
    xset_binary_mode_error();
    }
  }
#line 44
  return;
}
}
#line 46
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;

  {
  {
#line 34
  tmp = gettext("memory exhausted");
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
  }
}
}
#line 41 "./uniwidth.h"
int uc_width(ucs4_t uc , char const   *encoding )  __attribute__((__pure__)) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 20 "/home/khheo/project/benchmark/grep-3.1/lib/uniwidth/cjk.h"
static int is_cjk_encoding(char const   *encoding ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 23
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 23
  if (tmp == 0) {
#line 35
    return (1);
  } else {
    {
#line 23
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 23
    if (tmp___0 == 0) {
#line 35
      return (1);
    } else {
      {
#line 23
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 23
      if (tmp___1 == 0) {
#line 35
        return (1);
      } else {
        {
#line 23
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 23
        if (tmp___2 == 0) {
#line 35
          return (1);
        } else {
          {
#line 23
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 23
          if (tmp___3 == 0) {
#line 35
            return (1);
          } else {
            {
#line 23
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 23
            if (tmp___4 == 0) {
#line 35
              return (1);
            } else {
              {
#line 23
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 23
              if (tmp___5 == 0) {
#line 35
                return (1);
              } else {
                {
#line 23
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 23
                if (tmp___6 == 0) {
#line 35
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 36
  return (0);
}
}
#line 35 "/home/khheo/project/benchmark/grep-3.1/lib/uniwidth/width.c"
static unsigned char const   nonspacing_table_data[2304]  = 
#line 35 "/home/khheo/project/benchmark/grep-3.1/lib/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )23, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )191, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )251, 
        (unsigned char const   )239,      (unsigned char const   )62,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )20, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )254,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )224,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )9, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,      (unsigned char const   )127, 
        (unsigned char const   )229,      (unsigned char const   )31,      (unsigned char const   )248,      (unsigned char const   )159, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )60,      (unsigned char const   )59,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )64,      (unsigned char const   )163,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )247,      (unsigned char const   )255, 
        (unsigned char const   )253,      (unsigned char const   )33,      (unsigned char const   )16,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )63,      (unsigned char const   )240, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )223,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )247,      (unsigned char const   )63, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )157,      (unsigned char const   )193, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )38, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )239,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )8,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )211,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )248,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )31,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )133, 
        (unsigned char const   )13,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )176, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )167, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )40,      (unsigned char const   )191,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )188,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )127,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )96, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )248,      (unsigned char const   )255, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )127,      (unsigned char const   )248, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )31,      (unsigned char const   )32,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248, 
        (unsigned char const   )254,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )127,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 361 "/home/khheo/project/benchmark/grep-3.1/lib/uniwidth/width.c"
static signed char const   nonspacing_table_ind[248]  = 
#line 361
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21, 
        (signed char const   )22,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )24,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )29,      (signed char const   )-1,      (signed char const   )30, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )31,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )32,      (signed char const   )33,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )34,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )35,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 396
int uc_width(ucs4_t uc , char const   *encoding )  __attribute__((__pure__)) ;
#line 396 "/home/khheo/project/benchmark/grep-3.1/lib/uniwidth/width.c"
int uc_width(ucs4_t uc , char const   *encoding ) 
{ 
  int ind ;
  int tmp ;
  int tmp___0 ;

  {
#line 400
  if (uc >> 9 < 248U) {
#line 402
    ind = (int )nonspacing_table_ind[uc >> 9];
#line 403
    if (ind >= 0) {
#line 404
      if (((int const   )nonspacing_table_data[(unsigned int )(64 * ind) + ((uc >> 3) & 63U)] >> (uc & 7U)) & 1) {
#line 406
        if (uc > 0U) {
#line 406
          if (uc < 160U) {
#line 407
            return (-1);
          } else {
#line 409
            return (0);
          }
        } else {
#line 409
          return (0);
        }
      }
    }
  } else
#line 412
  if (uc >> 9 == (ucs4_t )(917504 >> 9)) {
#line 414
    if (uc >= 917760U) {
#line 416
      if (uc <= 917999U) {
#line 417
        return (0);
      }
    } else {
#line 421
      if (uc >= 917536U) {
#line 421
        tmp = uc <= 917631U;
      } else {
#line 421
        tmp = uc == 917505U;
      }
#line 421
      if (tmp) {
#line 422
        return (0);
      }
    }
  }
#line 429
  if (uc >= 4352U) {
#line 429
    if (uc < 4448U) {
#line 443
      return (2);
    } else
#line 429
    if (uc >= 9001U) {
#line 429
      if (uc < 9003U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 429
    if (uc >= 11904U) {
#line 429
      if (uc < 42192U) {
#line 429
        if (! (uc == 12351U)) {
#line 429
          if (uc >= 19904U) {
#line 429
            if (uc < 19968U) {
#line 429
              goto _L___8;
            } else {
#line 443
              return (2);
            }
          } else {
#line 443
            return (2);
          }
        } else {
#line 429
          goto _L___8;
        }
      } else {
#line 429
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 429
    if (uc >= 44032U) {
#line 429
      if (uc < 55204U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 429
    if (uc >= 63744U) {
#line 429
      if (uc < 64256U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 429
    if (uc >= 65040U) {
#line 429
      if (uc < 65056U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 429
    if (uc >= 65072U) {
#line 429
      if (uc < 65136U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 429
    if (uc >= 65280U) {
#line 429
      if (uc < 65377U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 429
    if (uc >= 65504U) {
#line 429
      if (uc < 65511U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 429
    if (uc >= 131072U) {
#line 429
      if (uc <= 196607U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 429
    if (uc >= 196608U) {
#line 429
      if (uc <= 262143U) {
#line 443
        return (2);
      }
    }
  }
#line 446
  if (uc >= 161U) {
#line 446
    if (uc < 65377U) {
#line 446
      if (uc != 8361U) {
        {
#line 446
        tmp___0 = is_cjk_encoding(encoding);
        }
#line 446
        if (tmp___0) {
#line 448
          return (2);
        }
      }
    }
  }
#line 449
  return (1);
}
}
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 662
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 34 "/home/khheo/project/benchmark/grep-3.1/lib/version-etc.h"
char const   version_etc_copyright[47] ;
#line 52
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 58
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 63
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 69
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 76
void emit_bug_reporting_address(void) ;
#line 61 "/home/khheo/project/benchmark/grep-3.1/lib/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 67
  if (command_name) {
    {
#line 68
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 70
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 84
  tmp = gettext("(C)");
#line 84
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp, 2017);
#line 86
  tmp___0 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 86
  fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
  }
  {
#line 97
  if (n_authors == 0UL) {
#line 97
    goto case_0;
  }
#line 100
  if (n_authors == 1UL) {
#line 100
    goto case_1;
  }
#line 104
  if (n_authors == 2UL) {
#line 104
    goto case_2;
  }
#line 108
  if (n_authors == 3UL) {
#line 108
    goto case_3;
  }
#line 113
  if (n_authors == 4UL) {
#line 113
    goto case_4;
  }
#line 120
  if (n_authors == 5UL) {
#line 120
    goto case_5;
  }
#line 127
  if (n_authors == 6UL) {
#line 127
    goto case_6;
  }
#line 135
  if (n_authors == 7UL) {
#line 135
    goto case_7;
  }
#line 143
  if (n_authors == 8UL) {
#line 143
    goto case_8;
  }
#line 152
  if (n_authors == 9UL) {
#line 152
    goto case_9;
  }
#line 161
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 99
  abort();
  }
  case_1: /* CIL Label */ 
  {
#line 102
  tmp___1 = gettext("Written by %s.\n");
#line 102
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          *(authors + 0));
  }
#line 103
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 106
  tmp___2 = gettext("Written by %s and %s.\n");
#line 106
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
          *(authors + 0), *(authors + 1));
  }
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 110
  tmp___3 = gettext("Written by %s, %s, and %s.\n");
#line 110
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3,
          *(authors + 0), *(authors + 1), *(authors + 2));
  }
#line 112
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 117
  tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
#line 117
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3));
  }
#line 119
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 124
  tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
#line 124
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___5,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  }
#line 126
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 131
  tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
#line 131
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___6,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5));
  }
#line 134
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 139
  tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
#line 139
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___7,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6));
  }
#line 142
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 147
  tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
#line 147
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___8,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7));
  }
#line 151
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 156
  tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
#line 156
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___9,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 160
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 167
  tmp___10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
#line 167
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___10,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 171
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 179 "/home/khheo/project/benchmark/grep-3.1/lib/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ 
  size_t n_authors ;

  {
#line 186
  n_authors = (size_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! *(authors + n_authors)) {
#line 186
      goto while_break;
    }
#line 186
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
#line 189
  return;
}
}
#line 195 "/home/khheo/project/benchmark/grep-3.1/lib/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ 
  size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 203
  n_authors = (size_t )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (n_authors < 10UL) {
      {
#line 203
      tmp___0 = __builtin_va_arg(authors, char const   *);
#line 203
      tmp = tmp___0;
#line 203
      authtab[n_authors] = tmp;
      }
#line 203
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 203
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
  }
#line 210
  return;
}
}
#line 226
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 226 "/home/khheo/project/benchmark/grep-3.1/lib/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list authors ;

  {
  {
#line 233
  __builtin_va_start(authors, version);
#line 234
  version_etc_va(stream, command_name, package, version, authors);
#line 235
  __builtin_va_end(authors);
  }
#line 236
  return;
}
}
#line 238 "/home/khheo/project/benchmark/grep-3.1/lib/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 245
  tmp = gettext("\nReport bugs to: %s\n");
#line 245
  printf((char const   */* __restrict  */)tmp, "bug-grep@gnu.org");
#line 251
  tmp___0 = gettext("%s home page: <%s>\n");
#line 251
  printf((char const   */* __restrict  */)tmp___0, "GNU grep", "http://www.gnu.org/software/grep/");
#line 256
  tmp___1 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 256
  fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
  }
#line 258
  return;
}
}
#line 26 "/home/khheo/project/benchmark/grep-3.1/lib/version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 26 "/home/khheo/project/benchmark/grep-3.1/lib/version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
#line 599 "/home/khheo/project/benchmark/grep-3.1/lib/unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 308 "./unistr.h"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) ;
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/unistr/u8-uctomb-aux.c"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) 
{ 
  int count ;

  {
#line 36
  if (uc < 128U) {
#line 38
    return (-2);
  } else
#line 39
  if (uc < 2048U) {
#line 40
    count = 2;
  } else
#line 41
  if (uc < 65536U) {
#line 43
    if (uc < 55296U) {
#line 44
      count = 3;
    } else
#line 43
    if (uc >= 57344U) {
#line 44
      count = 3;
    } else {
#line 46
      return (-1);
    }
  } else
#line 48
  if (uc < 1114112U) {
#line 49
    count = 4;
  } else {
#line 51
    return (-1);
  }
#line 53
  if (n < count) {
#line 54
    return (-2);
  }
  {
#line 58
  if (count == 4) {
#line 58
    goto case_4;
  }
#line 60
  if (count == 3) {
#line 60
    goto case_3;
  }
#line 62
  if (count == 2) {
#line 62
    goto case_2;
  }
#line 56
  goto switch_break;
  case_4: /* CIL Label */ 
#line 58
  *(s + 3) = (uint8_t )(128U | (uc & 63U));
#line 58
  uc >>= 6;
#line 58
  uc |= 65536U;
  case_3: /* CIL Label */ 
#line 60
  *(s + 2) = (uint8_t )(128U | (uc & 63U));
#line 60
  uc >>= 6;
#line 60
  uc |= 2048U;
  case_2: /* CIL Label */ 
#line 62
  *(s + 1) = (uint8_t )(128U | (uc & 63U));
#line 62
  uc >>= 6;
#line 62
  uc |= 192U;
#line 63
  *(s + 0) = (uint8_t )uc;
  switch_break: /* CIL Label */ ;
  }
#line 65
  return (count);
}
}
#line 286 "./unistr.h"
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n ) ;
#line 23 "/home/khheo/project/benchmark/grep-3.1/lib/unistr/u8-mbtoucr.c"
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n ) 
{ 
  uint8_t c ;

  {
#line 26
  c = (uint8_t )*s;
#line 28
  if ((int )c < 128) {
#line 30
    *puc = (ucs4_t )c;
#line 31
    return (1);
  } else
#line 33
  if ((int )c >= 194) {
#line 35
    if ((int )c < 224) {
#line 37
      if (n >= 2UL) {
#line 39
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 41
          *puc = ((unsigned int )((int )c & 31) << 6) | (unsigned int )((int const   )*(s + 1) ^ 128);
#line 43
          return (2);
        }
      } else {
#line 50
        *puc = (ucs4_t )65533;
#line 51
        return (-2);
      }
    } else
#line 54
    if ((int )c < 240) {
#line 56
      if (n >= 2UL) {
#line 58
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 58
          if ((int )c >= 225) {
#line 58
            goto _L___0;
          } else
#line 58
          if ((int const   )*(s + 1) >= 160) {
            _L___0: /* CIL Label */ 
#line 58
            if ((int )c != 237) {
#line 58
              goto _L;
            } else
#line 58
            if ((int const   )*(s + 1) < 160) {
              _L: /* CIL Label */ 
#line 62
              if (n >= 3UL) {
#line 64
                if (((int const   )*(s + 2) ^ 128) < 64) {
#line 66
                  *puc = (((unsigned int )((int )c & 15) << 12) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 2) ^ 128);
#line 69
                  return (3);
                }
              } else {
#line 76
                *puc = (ucs4_t )65533;
#line 77
                return (-2);
              }
            }
          }
        }
      } else {
#line 85
        *puc = (ucs4_t )65533;
#line 86
        return (-2);
      }
    } else
#line 89
    if ((int )c < 248) {
#line 91
      if (n >= 2UL) {
#line 93
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 93
          if ((int )c >= 241) {
#line 93
            goto _L___2;
          } else
#line 93
          if ((int const   )*(s + 1) >= 144) {
            _L___2: /* CIL Label */ 
#line 93
            if ((int )c < 244) {
#line 93
              goto _L___1;
            } else
#line 93
            if ((int )c == 244) {
#line 93
              if ((int const   )*(s + 1) < 144) {
                _L___1: /* CIL Label */ 
#line 97
                if (n >= 3UL) {
#line 99
                  if (((int const   )*(s + 2) ^ 128) < 64) {
#line 101
                    if (n >= 4UL) {
#line 103
                      if (((int const   )*(s + 3) ^ 128) < 64) {
#line 105
                        *puc = ((((unsigned int )((int )c & 7) << 18) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 12)) | ((unsigned int )((int const   )*(s + 2) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 3) ^ 128);
#line 109
                        return (4);
                      }
                    } else {
#line 116
                      *puc = (ucs4_t )65533;
#line 117
                      return (-2);
                    }
                  }
                } else {
#line 125
                  *puc = (ucs4_t )65533;
#line 126
                  return (-2);
                }
              }
            }
          }
        }
      } else {
#line 134
        *puc = (ucs4_t )65533;
#line 135
        return (-2);
      }
    }
  }
#line 140
  *puc = (ucs4_t )65533;
#line 141
  return (-1);
}
}
#line 33 "/home/khheo/project/benchmark/grep-3.1/lib/trim.h"
char *trim2(char const   *s , int how ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 166
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 292 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mbsinit)(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 367
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wcwidth)(wchar_t __c ) ;
#line 686 "./wchar.h"
size_t rpl_mbrtowc(wchar_t *pwc , char const   *s , size_t n , mbstate_t *ps ) ;
#line 104 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswcntrl)(wint_t __wc ) ;
#line 130
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswspace)(wint_t __wc ) ;
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 246 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
__inline int mb_width_aux(wint_t wc ) 
{ 
  int w ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 249
  tmp = wcwidth((wchar_t )wc);
#line 249
  w = tmp;
  }
#line 252
  if (w >= 0) {
#line 252
    tmp___3 = w;
  } else {
    {
#line 252
    tmp___2 = iswcntrl(wc);
    }
#line 252
    if (tmp___2) {
#line 252
      tmp___1 = 0;
    } else {
#line 252
      tmp___1 = 1;
    }
#line 252
    tmp___3 = tmp___1;
  }
#line 252
  return (tmp___3);
}
}
#line 267 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
__inline void mb_copy(mbchar_t *new_mbc , mbchar_t const   *old_mbc ) 
{ 
  _Bool tmp ;

  {
#line 270
  if ((unsigned long )old_mbc->ptr == (unsigned long )(& old_mbc->buf[0])) {
    {
#line 272
    memcpy((void */* __restrict  */)(& new_mbc->buf[0]), (void const   */* __restrict  */)(& old_mbc->buf[0]),
           (size_t )old_mbc->bytes);
#line 273
    new_mbc->ptr = (char const   *)(& new_mbc->buf[0]);
    }
  } else {
#line 276
    new_mbc->ptr = (char const   *)old_mbc->ptr;
  }
#line 277
  new_mbc->bytes = (size_t )old_mbc->bytes;
#line 278
  tmp = (_Bool )old_mbc->wc_valid;
#line 278
  new_mbc->wc_valid = tmp;
#line 278
  if (tmp) {
#line 279
    new_mbc->wc = (wchar_t )old_mbc->wc;
  }
#line 280
  return;
}
}
#line 313
unsigned int const   is_basic_table[8] ;
#line 315 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
__inline _Bool is_basic(char c ) 
{ 


  {
#line 318
  return ((_Bool )((is_basic_table[(int )((unsigned char )c) >> 5] >> ((int )((unsigned char )c) & 31)) & 1U));
}
}
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-3.1/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 123 "/home/khheo/project/benchmark/grep-3.1/lib/mbiter.h"
__inline void mbiter_multi_next(struct mbiter_multi *iter ) 
{ 
  int tmp___2 ;
  int tmp___5 ;
  _Bool tmp___6 ;

  {
#line 126
  if (iter->next_done) {
#line 127
    return;
  }
#line 128
  if (iter->in_shift) {
#line 129
    goto with_shift;
  }
  {
#line 131
  tmp___6 = is_basic((char )*(iter->cur.ptr));
  }
#line 131
  if (tmp___6) {
#line 136
    iter->cur.bytes = (size_t )1;
#line 137
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 138
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 142
    tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 142
    if (! tmp___2) {
      {
#line 142
      __assert_fail("mbsinit (&iter->state)", "/home/khheo/project/benchmark/grep-3.1/lib/mbiter.h",
                    142U, "mbiter_multi_next");
      }
    }
#line 143
    iter->in_shift = (_Bool)1;
    with_shift: 
    {
#line 145
    iter->cur.bytes = rpl_mbrtowc(& iter->cur.wc, iter->cur.ptr, (size_t )(iter->limit - iter->cur.ptr),
                                  & iter->state);
    }
#line 147
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 150
      iter->cur.bytes = (size_t )1;
#line 151
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 155
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
#line 158
      iter->cur.bytes = (size_t )(iter->limit - iter->cur.ptr);
#line 159
      iter->cur.wc_valid = (_Bool)0;
    } else {
#line 165
      if (iter->cur.bytes == 0UL) {
#line 168
        iter->cur.bytes = (size_t )1;
#line 169
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 169
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/khheo/project/benchmark/grep-3.1/lib/mbiter.h",
                        169U, "mbiter_multi_next");
          }
        }
#line 170
        if (! (iter->cur.wc == 0)) {
          {
#line 170
          __assert_fail("iter->cur.wc == 0", "/home/khheo/project/benchmark/grep-3.1/lib/mbiter.h",
                        170U, "mbiter_multi_next");
          }
        }
      }
      {
#line 172
      iter->cur.wc_valid = (_Bool)1;
#line 176
      tmp___5 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 176
      if (tmp___5) {
#line 177
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 180
  iter->next_done = (_Bool)1;
#line 181
  return;
}
}
#line 183 "/home/khheo/project/benchmark/grep-3.1/lib/mbiter.h"
__inline void mbiter_multi_reloc(struct mbiter_multi *iter , ptrdiff_t ptrdiff ) 
{ 


  {
#line 186
  iter->cur.ptr += ptrdiff;
#line 187
  iter->limit += ptrdiff;
#line 188
  return;
}
}
#line 190 "/home/khheo/project/benchmark/grep-3.1/lib/mbiter.h"
__inline void mbiter_multi_copy(struct mbiter_multi *new_iter , struct mbiter_multi  const  *old_iter ) 
{ 
  _Bool tmp ;

  {
#line 193
  new_iter->limit = (char const   *)old_iter->limit;
#line 194
  tmp = (_Bool )old_iter->in_shift;
#line 194
  new_iter->in_shift = tmp;
#line 194
  if (tmp) {
    {
#line 195
    memcpy((void */* __restrict  */)(& new_iter->state), (void const   */* __restrict  */)(& old_iter->state),
           sizeof(mbstate_t ));
    }
  } else {
    {
#line 197
    memset((void *)(& new_iter->state), 0, sizeof(mbstate_t ));
    }
  }
  {
#line 198
  new_iter->next_done = (_Bool )old_iter->next_done;
#line 199
  mb_copy(& new_iter->cur, & old_iter->cur);
  }
#line 200
  return;
}
}
#line 223
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 40 "/home/khheo/project/benchmark/grep-3.1/lib/trim.c"
char *trim2(char const   *s , int how ) 
{ 
  char *d ;
  mbi_iterator_t i ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned int state ;
  char *r ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *p ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 45
  d = strdup(s);
  }
#line 47
  if (! d) {
    {
#line 48
    xalloc_die();
    }
  }
  {
#line 50
  tmp___12 = __ctype_get_mb_cur_max();
  }
#line 50
  if (tmp___12 > 1UL) {
#line 55
    if (how != 0) {
      {
#line 57
      i.cur.ptr = (char const   *)d;
#line 57
      tmp = strlen((char const   *)d);
#line 57
      i.limit = i.cur.ptr + tmp;
#line 57
      i.in_shift = (_Bool)0;
#line 57
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 57
      i.next_done = (_Bool)0;
      }
      {
#line 59
      while (1) {
        while_continue: /* CIL Label */ ;
#line 59
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
#line 59
          mbiter_multi_next(& i);
          }
#line 59
          if (i.cur.wc_valid) {
            {
#line 59
            tmp___0 = iswspace((wint_t )i.cur.wc);
            }
#line 59
            if (! tmp___0) {
#line 59
              goto while_break;
            }
          } else {
#line 59
            goto while_break;
          }
        } else {
#line 59
          goto while_break;
        }
#line 59
        i.cur.ptr += i.cur.bytes;
#line 59
        i.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 62
      tmp___1 = strlen(i.cur.ptr);
#line 62
      memmove((void *)d, (void const   *)i.cur.ptr, tmp___1 + 1UL);
      }
    }
#line 66
    if (how != 1) {
      {
#line 68
      state = 0U;
#line 71
      i.cur.ptr = (char const   *)d;
#line 71
      tmp___2 = strlen((char const   *)d);
#line 71
      i.limit = i.cur.ptr + tmp___2;
#line 71
      i.in_shift = (_Bool)0;
#line 71
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 71
      i.next_done = (_Bool)0;
      }
      {
#line 73
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 73
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
#line 73
          mbiter_multi_next(& i);
          }
        } else {
#line 73
          goto while_break___0;
        }
#line 75
        if (state == 0U) {
#line 75
          if (i.cur.wc_valid) {
            {
#line 75
            tmp___3 = iswspace((wint_t )i.cur.wc);
            }
#line 75
            if (tmp___3) {
#line 76
              goto __Cont;
            }
          }
        }
#line 78
        if (state == 0U) {
#line 78
          if (i.cur.wc_valid) {
            {
#line 78
            tmp___4 = iswspace((wint_t )i.cur.wc);
            }
#line 78
            if (! tmp___4) {
#line 80
              state = 1U;
#line 81
              goto __Cont;
            }
          } else {
#line 80
            state = 1U;
#line 81
            goto __Cont;
          }
        }
#line 84
        if (state == 1U) {
#line 84
          if (i.cur.wc_valid) {
            {
#line 84
            tmp___5 = iswspace((wint_t )i.cur.wc);
            }
#line 84
            if (! tmp___5) {
#line 85
              goto __Cont;
            }
          } else {
#line 85
            goto __Cont;
          }
        }
#line 87
        if (state == 1U) {
#line 87
          if (i.cur.wc_valid) {
            {
#line 87
            tmp___7 = iswspace((wint_t )i.cur.wc);
            }
#line 87
            if (tmp___7) {
#line 89
              state = 2U;
#line 90
              r = (char *)i.cur.ptr;
            } else {
#line 87
              goto _L;
            }
          } else {
#line 87
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 92
        if (state == 2U) {
#line 92
          if (i.cur.wc_valid) {
            {
#line 92
            tmp___6 = iswspace((wint_t )i.cur.wc);
            }
#line 92
            if (! tmp___6) {
#line 98
              state = 1U;
            }
          } else {
#line 98
            state = 1U;
          }
        } else {
#line 98
          state = 1U;
        }
        __Cont: /* CIL Label */ 
#line 73
        i.cur.ptr += i.cur.bytes;
#line 73
        i.next_done = (_Bool)0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 102
      if (state == 2U) {
#line 103
        *r = (char )'\000';
      }
    }
  } else {
#line 111
    if (how != 0) {
#line 113
      p = d;
      {
#line 113
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 113
        if (*p) {
          {
#line 113
          tmp___8 = __ctype_b_loc();
          }
#line 113
          if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*p)) & 8192)) {
#line 113
            goto while_break___1;
          }
        } else {
#line 113
          goto while_break___1;
        }
#line 113
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 116
      tmp___9 = strlen((char const   *)p);
#line 116
      memmove((void *)d, (void const   *)p, tmp___9 + 1UL);
      }
    }
#line 120
    if (how != 1) {
      {
#line 122
      tmp___10 = strlen((char const   *)d);
#line 122
      p = (d + tmp___10) - 1;
      }
      {
#line 122
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 122
        if ((unsigned long )p >= (unsigned long )d) {
          {
#line 122
          tmp___11 = __ctype_b_loc();
          }
#line 122
          if (! ((int const   )*(*tmp___11 + (int )((unsigned char )*p)) & 8192)) {
#line 122
            goto while_break___2;
          }
        } else {
#line 122
          goto while_break___2;
        }
#line 124
        *p = (char )'\000';
#line 122
        p --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 128
  return (d);
}
}
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/strnlen1.h"
size_t strnlen1(char const   *string , size_t maxlen )  __attribute__((__pure__)) ;
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 27 "/home/khheo/project/benchmark/grep-3.1/lib/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen )  __attribute__((__pure__)) ;
#line 27 "/home/khheo/project/benchmark/grep-3.1/lib/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen ) 
{ 
  char const   *end ;
  void *tmp ;

  {
  {
#line 30
  tmp = memchr((void const   *)string, '\000', maxlen);
#line 30
  end = (char const   *)tmp;
  }
#line 31
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 32
    return ((size_t )((end - string) + 1L));
  } else {
#line 34
    return (maxlen);
  }
}
}
#line 44 "/home/khheo/project/benchmark/grep-3.1/lib/dirname.h"
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 46
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 48
_Bool strip_trailing_slashes(char *file ) ;
#line 30 "/home/khheo/project/benchmark/grep-3.1/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 33
  tmp = last_component((char const   *)file);
#line 33
  base = tmp;
  }
#line 39
  if (! *base) {
#line 40
    base = file;
  }
  {
#line 41
  tmp___0 = base_len((char const   *)base);
#line 41
  base_lim = base + tmp___0;
#line 42
  had_slash = (_Bool )((int )*base_lim != 0);
#line 43
  *base_lim = (char )'\000';
  }
#line 44
  return (had_slash);
}
}
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 42 "/home/khheo/project/benchmark/grep-3.1/lib/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 42 "/home/khheo/project/benchmark/grep-3.1/lib/striconv.c"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) 
{ 
  size_t length ;
  char *result ;
  size_t count ;
  union __anonunion_tmp_771759453 tmp ;
  char const   *inptr ;
  size_t insize ;
  char *outptr ;
  size_t outsize ;
  size_t res ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *outptr___0 ;
  size_t outsize___0 ;
  size_t res___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char const   *inptr___0 ;
  size_t insize___0 ;
  char *outptr___1 ;
  size_t outsize___1 ;
  size_t res___1 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  size_t res___2 ;
  size_t tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 55
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 60
  count = (size_t )0;
#line 65
  inptr = src;
#line 66
  insize = srclen;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (insize > 0UL)) {
#line 68
      goto while_break;
    }
    {
#line 70
    outptr = tmp.buf;
#line 71
    outsize = (size_t )4096;
#line 72
    tmp___0 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr)), (size_t */* __restrict  */)(& insize),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outsize));
#line 72
    res = tmp___0;
    }
#line 76
    if (res == 0xffffffffffffffffUL) {
      {
#line 78
      tmp___2 = __errno_location();
      }
#line 78
      if (! (*tmp___2 == 7)) {
        {
#line 80
        tmp___1 = __errno_location();
        }
#line 80
        if (*tmp___1 == 22) {
#line 81
          goto while_break;
        } else {
#line 83
          return (-1);
        }
      }
    }
#line 96
    count += (size_t )(outptr - tmp.buf);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  outptr___0 = tmp.buf;
#line 104
  outsize___0 = (size_t )4096;
#line 105
  tmp___3 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                  (char **/* __restrict  */)(& outptr___0), (size_t */* __restrict  */)(& outsize___0));
#line 105
  res___0 = tmp___3;
  }
#line 107
  if (res___0 == 0xffffffffffffffffUL) {
#line 108
    return (-1);
  }
#line 109
  count += (size_t )(outptr___0 - tmp.buf);
#line 112
  length = count;
#line 116
  if (length == 0UL) {
#line 118
    *lengthp = (size_t )0;
#line 119
    return (0);
  }
#line 121
  if ((unsigned long )*resultp != (unsigned long )((void *)0)) {
#line 121
    if (*lengthp >= length) {
#line 122
      result = *resultp;
    } else {
#line 121
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 125
    tmp___4 = malloc(length);
#line 125
    result = (char *)tmp___4;
    }
#line 126
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 128
      tmp___5 = __errno_location();
#line 128
      *tmp___5 = 12;
      }
#line 129
      return (-1);
    }
  }
  {
#line 138
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 143
  inptr___0 = src;
#line 144
  insize___0 = srclen;
#line 145
  outptr___1 = result;
#line 146
  outsize___1 = length;
  }
  {
#line 148
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 148
    if (! (insize___0 > 0UL)) {
#line 148
      goto while_break___0;
    }
    {
#line 150
    tmp___6 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr___0)), (size_t */* __restrict  */)(& insize___0),
                    (char **/* __restrict  */)(& outptr___1), (size_t */* __restrict  */)(& outsize___1));
#line 150
    res___1 = tmp___6;
    }
#line 154
    if (res___1 == 0xffffffffffffffffUL) {
      {
#line 156
      tmp___7 = __errno_location();
      }
#line 156
      if (*tmp___7 == 22) {
#line 157
        goto while_break___0;
      } else {
#line 159
        goto fail;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 178
  tmp___8 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                  (char **/* __restrict  */)(& outptr___1), (size_t */* __restrict  */)(& outsize___1));
#line 178
  res___2 = tmp___8;
  }
#line 180
  if (res___2 == 0xffffffffffffffffUL) {
#line 181
    goto fail;
  }
#line 184
  if (outsize___1 != 0UL) {
    {
#line 185
    abort();
    }
  }
#line 188
  *resultp = result;
#line 189
  *lengthp = length;
#line 191
  return (0);
  fail: 
#line 195
  if ((unsigned long )result != (unsigned long )*resultp) {
    {
#line 197
    tmp___9 = __errno_location();
#line 197
    saved_errno = *tmp___9;
#line 198
    free((void *)result);
#line 199
    tmp___10 = __errno_location();
#line 199
    *tmp___10 = saved_errno;
    }
  }
#line 201
  return (-1);
}
}
#line 206 "/home/khheo/project/benchmark/grep-3.1/lib/striconv.c"
char *str_cd_iconv(char const   *src , iconv_t cd ) 
{ 
  char *result ;
  size_t result_size ;
  size_t length ;
  char const   *inptr ;
  size_t inbytes_remaining ;
  size_t tmp ;
  size_t approx_sqrt_SIZE_MAX ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *outptr ;
  size_t outbytes_remaining ;
  size_t res ;
  size_t tmp___2 ;
  size_t used___0 ;
  size_t newsize ;
  char *newresult ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t res___0 ;
  size_t tmp___8 ;
  size_t used___1 ;
  size_t newsize___0 ;
  char *newresult___0 ;
  int *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *smaller_result ;
  void *tmp___14 ;
  int saved_errno ;
  int *tmp___15 ;
  int *tmp___16 ;

  {
  {
#line 255
  inptr = src;
#line 256
  tmp = strlen(src);
#line 256
  inbytes_remaining = tmp;
#line 261
  result_size = inbytes_remaining;
#line 263
  approx_sqrt_SIZE_MAX = 0xffffffffffffffffUL >> (sizeof(size_t ) * 8UL) / 2UL;
  }
#line 264
  if (result_size <= approx_sqrt_SIZE_MAX / 16UL) {
#line 265
    result_size *= 16UL;
  }
  {
#line 267
  result_size ++;
#line 269
  tmp___0 = malloc(result_size);
#line 269
  result = (char *)tmp___0;
  }
#line 270
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 272
    tmp___1 = __errno_location();
#line 272
    *tmp___1 = 12;
    }
#line 273
    return ((char *)((void *)0));
  }
  {
#line 281
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 286
  outptr = result;
#line 287
  outbytes_remaining = result_size - 1UL;
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 293
    tmp___2 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr)), (size_t */* __restrict  */)(& inbytes_remaining),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytes_remaining));
#line 293
    res = tmp___2;
    }
#line 297
    if (res == 0xffffffffffffffffUL) {
      {
#line 299
      tmp___7 = __errno_location();
      }
#line 299
      if (*tmp___7 == 22) {
#line 300
        goto while_break;
      } else {
        {
#line 301
        tmp___6 = __errno_location();
        }
#line 301
        if (*tmp___6 == 7) {
#line 303
          used___0 = (size_t )(outptr - result);
#line 304
          newsize = result_size * 2UL;
#line 307
          if (! (newsize > result_size)) {
            {
#line 309
            tmp___3 = __errno_location();
#line 309
            *tmp___3 = 12;
            }
#line 310
            goto failed;
          }
          {
#line 312
          tmp___4 = realloc((void *)result, newsize);
#line 312
          newresult = (char *)tmp___4;
          }
#line 313
          if ((unsigned long )newresult == (unsigned long )((void *)0)) {
            {
#line 315
            tmp___5 = __errno_location();
#line 315
            *tmp___5 = 12;
            }
#line 316
            goto failed;
          }
#line 318
          result = newresult;
#line 319
          result_size = newsize;
#line 320
          outptr = result + used___0;
#line 321
          outbytes_remaining = (result_size - 1UL) - used___0;
        } else {
#line 324
          goto failed;
        }
      }
    } else {
#line 327
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 336
    tmp___8 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytes_remaining));
#line 336
    res___0 = tmp___8;
    }
#line 338
    if (res___0 == 0xffffffffffffffffUL) {
      {
#line 340
      tmp___12 = __errno_location();
      }
#line 340
      if (*tmp___12 == 7) {
#line 342
        used___1 = (size_t )(outptr - result);
#line 343
        newsize___0 = result_size * 2UL;
#line 346
        if (! (newsize___0 > result_size)) {
          {
#line 348
          tmp___9 = __errno_location();
#line 348
          *tmp___9 = 12;
          }
#line 349
          goto failed;
        }
        {
#line 351
        tmp___10 = realloc((void *)result, newsize___0);
#line 351
        newresult___0 = (char *)tmp___10;
        }
#line 352
        if ((unsigned long )newresult___0 == (unsigned long )((void *)0)) {
          {
#line 354
          tmp___11 = __errno_location();
#line 354
          *tmp___11 = 12;
          }
#line 355
          goto failed;
        }
#line 357
        result = newresult___0;
#line 358
        result_size = newsize___0;
#line 359
        outptr = result + used___1;
#line 360
        outbytes_remaining = (result_size - 1UL) - used___1;
      } else {
#line 363
        goto failed;
      }
    } else {
#line 366
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 371
  tmp___13 = outptr;
#line 371
  outptr ++;
#line 371
  *tmp___13 = (char )'\000';
#line 373
  length = (size_t )(outptr - result);
#line 377
  if (length < result_size) {
    {
#line 379
    tmp___14 = realloc((void *)result, length);
#line 379
    smaller_result = (char *)tmp___14;
    }
#line 381
    if ((unsigned long )smaller_result != (unsigned long )((void *)0)) {
#line 382
      result = smaller_result;
    }
  }
#line 385
  return (result);
  failed: 
  {
#line 389
  tmp___15 = __errno_location();
#line 389
  saved_errno = *tmp___15;
#line 390
  free((void *)result);
#line 391
  tmp___16 = __errno_location();
#line 391
  *tmp___16 = saved_errno;
  }
#line 392
  return ((char *)((void *)0));
}
}
#line 400 "/home/khheo/project/benchmark/grep-3.1/lib/striconv.c"
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;
  iconv_t cd ;
  char *result___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int saved_errno___0 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 403
  if ((int const   )*src == 0) {
#line 403
    goto _L;
  } else {
    {
#line 403
    tmp___6 = c_strcasecmp(from_codeset, to_codeset);
    }
#line 403
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
      {
#line 405
      tmp = strdup(src);
#line 405
      result = tmp;
      }
#line 407
      if ((unsigned long )result == (unsigned long )((void *)0)) {
        {
#line 408
        tmp___0 = __errno_location();
#line 408
        *tmp___0 = 12;
        }
      }
#line 409
      return (result);
    } else {
      {
#line 427
      cd = iconv_open(to_codeset, from_codeset);
      }
#line 428
      if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 429
        return ((char *)((void *)0));
      }
      {
#line 431
      result___0 = str_cd_iconv(src, cd);
      }
#line 433
      if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
        {
#line 436
        tmp___1 = __errno_location();
#line 436
        saved_errno = *tmp___1;
#line 437
        iconv_close(cd);
#line 438
        tmp___2 = __errno_location();
#line 438
        *tmp___2 = saved_errno;
        }
      } else {
        {
#line 442
        tmp___5 = iconv_close(cd);
        }
#line 442
        if (tmp___5 < 0) {
          {
#line 446
          tmp___3 = __errno_location();
#line 446
          saved_errno___0 = *tmp___3;
#line 447
          free((void *)result___0);
#line 448
          tmp___4 = __errno_location();
#line 448
          *tmp___4 = saved_errno___0;
          }
#line 449
          return ((char *)((void *)0));
        }
      }
#line 452
      return (result___0);
    }
  }
}
}
#line 30 "/home/khheo/project/benchmark/grep-3.1/lib/save-cwd.h"
int save_cwd(struct saved_cwd *cwd ) ;
#line 31
int restore_cwd(struct saved_cwd  const  *cwd ) ;
#line 32
void free_cwd(struct saved_cwd *cwd ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 504
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
#line 514
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.h"
int chdir_long(char *dir ) ;
#line 32 "/home/khheo/project/benchmark/grep-3.1/lib/cloexec.h"
int set_cloexec_flag(int desc , _Bool value ) ;
#line 22 "/home/khheo/project/benchmark/grep-3.1/lib/fcntl-safer.h"
int open_safer(char const   *file , int flags  , ...) ;
#line 62 "/home/khheo/project/benchmark/grep-3.1/lib/save-cwd.c"
int save_cwd(struct saved_cwd *cwd ) 
{ 
  int tmp ;

  {
  {
#line 65
  cwd->name = (char *)((void *)0);
#line 67
  cwd->desc = open_safer(".", 0);
  }
#line 70
  if (cwd->desc < 0) {
    {
#line 72
    cwd->name = getcwd((char *)((void *)0), (size_t )0);
    }
#line 73
    if (cwd->name) {
#line 73
      tmp = 0;
    } else {
#line 73
      tmp = -1;
    }
#line 73
    return (tmp);
  }
  {
#line 76
  set_cloexec_flag(cwd->desc, (_Bool)1);
  }
#line 77
  return (0);
}
}
#line 84 "/home/khheo/project/benchmark/grep-3.1/lib/save-cwd.c"
int restore_cwd(struct saved_cwd  const  *cwd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 87
  if (0 <= (int )cwd->desc) {
    {
#line 88
    tmp = fchdir((int )cwd->desc);
    }
#line 88
    return (tmp);
  } else {
    {
#line 90
    tmp___0 = chdir_long((char *)cwd->name);
    }
#line 90
    return (tmp___0);
  }
}
}
#line 93 "/home/khheo/project/benchmark/grep-3.1/lib/save-cwd.c"
void free_cwd(struct saved_cwd *cwd ) 
{ 


  {
#line 96
  if (cwd->desc >= 0) {
    {
#line 97
    close(cwd->desc);
    }
  }
  {
#line 98
  free((void *)cwd->name);
  }
#line 99
  return;
}
}
#line 42 "/home/khheo/project/benchmark/grep-3.1/lib/safe-read.h"
size_t safe_read(int fd , void *buf , size_t count ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 55 "/home/khheo/project/benchmark/grep-3.1/lib/safe-read.c"
size_t safe_read(int fd , void *buf , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    tmp = read(fd, buf, count);
#line 66
    result = tmp;
    }
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
      {
#line 70
      tmp___1 = __errno_location();
      }
#line 70
      if (*tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
        {
#line 72
        tmp___0 = __errno_location();
        }
#line 72
        if (*tmp___0 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 24 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
#line 267 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.h"
char const   * const  quoting_style_args[11] ;
#line 268
enum quoting_style  const  quoting_style_vals[10] ;
#line 278
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 281
enum quoting_style get_quoting_style(struct quoting_options  const  *o ) ;
#line 285
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 294
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 300
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 311
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 326
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) ;
#line 333
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 342
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 352
char *quotearg_n(int n , char const   *arg ) ;
#line 355
char *quotearg(char const   *arg ) ;
#line 360
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 363
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 368
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 373
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 377
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 380
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 385
char *quotearg_char(char const   *arg , char ch ) ;
#line 388
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 391
char *quotearg_colon(char const   *arg ) ;
#line 394
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 397
char *quotearg_n_style_colon(int n , enum quoting_style s , char const   *arg ) ;
#line 403
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 408
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 413
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 418
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 423
void quotearg_free(void) ;
#line 25 "/home/khheo/project/benchmark/grep-3.1/lib/quote.h"
struct quoting_options quote_quoting_options ;
#line 31
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 36
char const   *quote_mem(char const   *arg , size_t argsize ) ;
#line 40
char const   *quote_n(int n , char const   *arg ) ;
#line 44
char const   *quote(char const   *arg ) ;
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 168 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline _Bool c_isalnum(int c ) 
{ 


  {
  {
#line 175
  if (c == 90) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 89) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 88) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 87) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 86) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 85) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 84) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 83) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 82) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 81) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 80) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 79) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 78) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 77) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 76) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 75) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 74) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 73) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 72) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 71) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 70) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 69) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 68) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 67) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 66) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 65) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 122) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 121) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 120) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 119) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 118) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 117) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 116) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 115) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 114) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 113) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 112) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 111) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 110) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 109) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 108) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 107) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 106) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 105) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 104) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 103) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 102) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 101) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 100) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 99) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 98) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 97) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 57) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 56) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 55) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 54) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 53) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 52) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 51) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 50) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 49) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 48) {
#line 175
    goto case_90;
  }
#line 177
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 176
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 178
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 182 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline _Bool c_isalpha(int c ) 
{ 


  {
  {
#line 188
  if (c == 90) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 89) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 88) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 87) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 86) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 85) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 84) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 83) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 82) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 81) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 80) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 79) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 78) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 77) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 76) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 75) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 74) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 73) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 72) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 71) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 70) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 69) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 68) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 67) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 66) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 65) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 122) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 121) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 120) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 119) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 118) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 117) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 116) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 115) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 114) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 113) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 112) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 111) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 110) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 109) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 108) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 107) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 106) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 105) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 104) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 103) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 102) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 101) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 100) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 99) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 98) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 97) {
#line 188
    goto case_90;
  }
#line 190
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 189
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 191
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 197 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline _Bool c_isascii(int c ) 
{ 


  {
  {
#line 207
  if (c == 90) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 89) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 88) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 87) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 86) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 85) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 84) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 83) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 82) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 81) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 80) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 79) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 78) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 77) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 76) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 75) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 74) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 73) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 72) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 71) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 70) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 69) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 68) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 67) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 66) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 65) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 126) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 125) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 124) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 123) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 96) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 95) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 94) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 93) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 92) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 91) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 64) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 63) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 62) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 61) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 60) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 59) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 58) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 47) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 46) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 45) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 44) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 43) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 42) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 41) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 40) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 39) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 38) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 37) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 36) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 35) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 34) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 33) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 122) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 121) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 120) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 119) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 118) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 117) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 116) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 115) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 114) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 113) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 112) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 111) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 110) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 109) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 108) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 107) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 106) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 105) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 104) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 103) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 102) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 101) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 100) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 99) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 98) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 97) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 57) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 56) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 55) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 54) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 53) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 52) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 51) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 50) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 49) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 48) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 127) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 31) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 30) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 29) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 28) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 27) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 26) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 25) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 24) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 23) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 22) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 21) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 20) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 19) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 18) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 17) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 16) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 15) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 14) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 6) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 5) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 4) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 3) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 2) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 1) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 0) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 11) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 9) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 13) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 10) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 12) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 8) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 7) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 32) {
#line 207
    goto case_90;
  }
#line 209
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_127: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 208
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 210
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 214 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline _Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 217
  if (c == 32) {
#line 217
    tmp = 1;
  } else
#line 217
  if (c == 9) {
#line 217
    tmp = 1;
  } else {
#line 217
    tmp = 0;
  }
#line 217
  return ((_Bool )tmp);
}
}
#line 220 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline _Bool c_iscntrl(int c ) 
{ 


  {
  {
#line 225
  if (c == 127) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 31) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 30) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 29) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 28) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 27) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 26) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 25) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 24) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 23) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 22) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 21) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 20) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 19) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 18) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 17) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 16) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 15) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 14) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 6) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 5) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 4) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 3) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 2) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 1) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 0) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 11) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 9) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 13) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 10) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 12) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 8) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 7) {
#line 225
    goto case_127;
  }
#line 227
  goto switch_default;
  case_127: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 226
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 228
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 232 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline _Bool c_isdigit(int c ) 
{ 


  {
  {
#line 237
  if (c == 57) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 56) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 55) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 54) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 53) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 52) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 51) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 50) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 49) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 48) {
#line 237
    goto case_57;
  }
#line 239
  goto switch_default;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 238
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 240
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 244 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline _Bool c_isgraph(int c ) 
{ 


  {
  {
#line 252
  if (c == 90) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 89) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 88) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 87) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 86) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 85) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 84) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 83) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 82) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 81) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 80) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 79) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 78) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 77) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 76) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 75) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 74) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 73) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 72) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 71) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 70) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 69) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 68) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 67) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 66) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 65) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 126) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 125) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 124) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 123) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 96) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 95) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 94) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 93) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 92) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 91) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 64) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 63) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 62) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 61) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 60) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 59) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 58) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 47) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 46) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 45) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 44) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 43) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 42) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 41) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 40) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 39) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 38) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 37) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 36) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 35) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 34) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 33) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 122) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 121) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 120) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 119) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 118) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 117) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 116) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 115) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 114) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 113) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 112) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 111) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 110) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 109) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 108) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 107) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 106) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 105) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 104) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 103) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 102) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 101) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 100) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 99) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 98) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 97) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 57) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 56) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 55) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 54) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 53) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 52) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 51) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 50) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 49) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 48) {
#line 252
    goto case_90;
  }
#line 254
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 253
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 255
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 259 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline _Bool c_islower(int c ) 
{ 


  {
  {
#line 264
  if (c == 122) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 121) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 120) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 119) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 118) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 117) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 116) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 115) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 114) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 113) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 112) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 111) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 110) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 109) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 108) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 107) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 106) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 105) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 104) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 103) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 102) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 101) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 100) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 99) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 98) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 97) {
#line 264
    goto case_122;
  }
#line 266
  goto switch_default;
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 265
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 267
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 271 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline _Bool c_isprint(int c ) 
{ 


  {
  {
#line 280
  if (c == 90) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 89) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 88) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 87) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 86) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 85) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 84) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 83) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 82) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 81) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 80) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 79) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 78) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 77) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 76) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 75) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 74) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 73) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 72) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 71) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 70) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 69) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 68) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 67) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 66) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 65) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 126) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 125) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 124) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 123) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 96) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 95) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 94) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 93) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 92) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 91) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 64) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 63) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 62) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 61) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 60) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 59) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 58) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 47) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 46) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 45) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 44) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 43) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 42) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 41) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 40) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 39) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 38) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 37) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 36) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 35) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 34) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 33) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 122) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 121) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 120) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 119) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 118) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 117) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 116) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 115) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 114) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 113) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 112) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 111) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 110) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 109) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 108) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 107) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 106) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 105) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 104) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 103) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 102) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 101) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 100) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 99) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 98) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 97) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 57) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 56) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 55) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 54) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 53) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 52) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 51) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 50) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 49) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 48) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 32) {
#line 280
    goto case_90;
  }
#line 282
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 281
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 283
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 287 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline _Bool c_ispunct(int c ) 
{ 


  {
  {
#line 292
  if (c == 126) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 125) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 124) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 123) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 96) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 95) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 94) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 93) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 92) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 91) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 64) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 63) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 62) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 61) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 60) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 59) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 58) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 47) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 46) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 45) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 44) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 43) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 42) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 41) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 40) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 39) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 38) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 37) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 36) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 35) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 34) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 33) {
#line 292
    goto case_126;
  }
#line 294
  goto switch_default;
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
#line 293
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 295
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 299 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline _Bool c_isspace(int c ) 
{ 


  {
  {
#line 304
  if (c == 13) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 12) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 11) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 10) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 9) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 32) {
#line 304
    goto case_13;
  }
#line 306
  goto switch_default;
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 305
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 307
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 311 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline _Bool c_isupper(int c ) 
{ 


  {
  {
#line 316
  if (c == 90) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 89) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 88) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 87) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 86) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 85) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 84) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 83) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 82) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 81) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 80) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 79) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 78) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 77) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 76) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 75) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 74) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 73) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 72) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 71) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 70) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 69) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 68) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 67) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 66) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 65) {
#line 316
    goto case_90;
  }
#line 318
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 317
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 319
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 323 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline _Bool c_isxdigit(int c ) 
{ 


  {
  {
#line 329
  if (c == 70) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 69) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 68) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 67) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 66) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 65) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 102) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 101) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 100) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 99) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 98) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 97) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 57) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 56) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 55) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 54) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 53) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 52) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 51) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 50) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 49) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 48) {
#line 329
    goto case_70;
  }
#line 331
  goto switch_default;
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 330
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 332
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 336 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline int c_tolower(int c ) 
{ 


  {
  {
#line 341
  if (c == 90) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 89) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 88) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 87) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 86) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 85) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 84) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 83) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 82) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 81) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 80) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 79) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 78) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 77) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 76) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 75) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 74) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 73) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 72) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 71) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 70) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 69) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 68) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 67) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 66) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 65) {
#line 341
    goto case_90;
  }
#line 343
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 342
  return ((c - 65) + 97);
  switch_default: /* CIL Label */ 
#line 344
  return (c);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 348 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
__inline int c_toupper(int c ) 
{ 


  {
  {
#line 353
  if (c == 122) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 121) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 120) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 119) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 118) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 117) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 116) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 115) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 114) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 113) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 112) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 111) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 110) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 109) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 108) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 107) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 106) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 105) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 104) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 103) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 102) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 101) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 100) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 99) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 98) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 97) {
#line 353
    goto case_122;
  }
#line 355
  goto switch_default;
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 354
  return ((c - 97) + 65);
  switch_default: /* CIL Label */ 
#line 356
  return (c);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 364
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-3.1/lib/localcharset.h"
char const   *locale_charset(void) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 120 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswprint)(wint_t __wc ) ;
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 85 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char const   * const  quoting_style_args[11]  = 
#line 85 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"shell-escape", 
        (char const   */* const  */)"shell-escape-always",      (char const   */* const  */)"c",      (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape", 
        (char const   */* const  */)"locale",      (char const   */* const  */)"clocale",      (char const   */* const  */)0};
#line 101 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[10]  = 
#line 101
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7, 
        (enum quoting_style  const  )8,      (enum quoting_style  const  )9};
#line 116 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 121 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 124
  tmp = __errno_location();
#line 124
  e = *tmp;
  }
#line 125
  if (o) {
#line 125
    tmp___0 = o;
  } else {
#line 125
    tmp___0 = & default_quoting_options;
  }
  {
#line 125
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 125
  p = (struct quoting_options *)tmp___1;
#line 127
  tmp___2 = __errno_location();
#line 127
  *tmp___2 = e;
  }
#line 128
  return (p);
}
}
#line 132 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *tmp ;

  {
#line 135
  if (o) {
#line 135
    tmp = o;
  } else {
#line 135
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
#line 135
  return ((enum quoting_style )tmp->style);
}
}
#line 140 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 143
  if (o) {
#line 143
    tmp = o;
  } else {
#line 143
    tmp = & default_quoting_options;
  }
#line 143
  tmp->style = s;
#line 144
  return;
}
}
#line 151 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 154
  uc = (unsigned char )c;
#line 155
  if (o) {
#line 155
    tmp = o;
  } else {
#line 155
    tmp = & default_quoting_options;
  }
#line 155
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 157
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 158
  r = (int )((*p >> shift) & 1U);
#line 159
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 160
  return (r);
}
}
#line 167 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 171
  if (! o) {
#line 172
    o = & default_quoting_options;
  }
#line 173
  r = o->flags;
#line 174
  o->flags = i;
#line 175
  return (r);
}
}
#line 178 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 182
  if (! o) {
#line 183
    o = & default_quoting_options;
  }
#line 184
  o->style = (enum quoting_style )10;
#line 185
  if (! left_quote) {
    {
#line 186
    abort();
    }
  } else
#line 185
  if (! right_quote) {
    {
#line 186
    abort();
    }
  }
#line 187
  o->left_quote = left_quote;
#line 188
  o->right_quote = right_quote;
#line 189
  return;
}
}
#line 192 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  unsigned int tmp ;

  {
#line 195
  o.style = (enum quoting_style )0;
#line 195
  o.flags = 0;
#line 195
  o.quote_these_too[0] = 0U;
#line 195
  tmp = 1U;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (tmp >= 8U) {
#line 195
      goto while_break;
    }
#line 195
    o.quote_these_too[tmp] = 0U;
#line 195
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  o.left_quote = (char const   *)((void *)0);
#line 195
  o.right_quote = (char const   *)((void *)0);
#line 196
  if ((unsigned int )style == 10U) {
    {
#line 197
    abort();
    }
  }
#line 198
  o.style = style;
#line 199
  return (o);
}
}
#line 206 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 209
  tmp = gettext(msgid);
#line 209
  translation = (char const   *)tmp;
  }
#line 212
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 213
    return (translation);
  }
  {
#line 233
  locale_code = locale_charset();
#line 234
  tmp___1 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 234
  if (tmp___1 == 0) {
#line 235
    if ((int const   )*(msgid + 0) == 96) {
#line 235
      tmp___0 = "\342\200\230";
    } else {
#line 235
      tmp___0 = "\342\200\231";
    }
#line 235
    return (tmp___0);
  }
  {
#line 236
  tmp___3 = c_strcasecmp(locale_code, "GB18030");
  }
#line 236
  if (tmp___3 == 0) {
#line 237
    if ((int const   )*(msgid + 0) == 96) {
#line 237
      tmp___2 = "\241\ae";
    } else {
#line 237
      tmp___2 = "\241\257";
    }
#line 237
    return (tmp___2);
  }
#line 239
  if ((unsigned int )s == 9U) {
#line 239
    tmp___4 = "\"";
  } else {
#line 239
    tmp___4 = "\'";
  }
#line 239
  return (tmp___4);
}
}
#line 255 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer___0 , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  size_t orig_buffersize ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  _Bool pending_shell_escape_end ;
  _Bool encountered_single_quote ;
  _Bool all_c_and_shell_quote_compat ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  _Bool escaping ;
  _Bool c_and_shell_quote_compat ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___3 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___4 ;
  size_t j ;
  int tmp___5 ;
  int tmp___6 ;
  size_t ilim ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 264
  len = (size_t )0;
#line 265
  orig_buffersize = (size_t )0;
#line 266
  quote_string = (char const   *)0;
#line 267
  quote_string_len = (size_t )0;
#line 268
  backslash_escapes = (_Bool)0;
#line 269
  tmp = __ctype_get_mb_cur_max();
#line 269
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 270
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
#line 271
  pending_shell_escape_end = (_Bool)0;
#line 272
  encountered_single_quote = (_Bool)0;
#line 273
  all_c_and_shell_quote_compat = (_Bool)1;
  }
  process_input: 
  {
#line 318
  if ((unsigned int )quoting_style == 6U) {
#line 318
    goto case_6;
  }
#line 322
  if ((unsigned int )quoting_style == 5U) {
#line 322
    goto case_5;
  }
#line 330
  if ((unsigned int )quoting_style == 7U) {
#line 330
    goto case_7;
  }
#line 337
  if ((unsigned int )quoting_style == 10U) {
#line 337
    goto case_10;
  }
#line 337
  if ((unsigned int )quoting_style == 9U) {
#line 337
    goto case_10;
  }
#line 337
  if ((unsigned int )quoting_style == 8U) {
#line 337
    goto case_10;
  }
#line 374
  if ((unsigned int )quoting_style == 3U) {
#line 374
    goto case_3;
  }
#line 377
  if ((unsigned int )quoting_style == 1U) {
#line 377
    goto case_1;
  }
#line 380
  if ((unsigned int )quoting_style == 4U) {
#line 380
    goto case_4;
  }
#line 384
  if ((unsigned int )quoting_style == 2U) {
#line 384
    goto case_2;
  }
#line 392
  if ((unsigned int )quoting_style == 0U) {
#line 392
    goto case_0;
  }
#line 396
  goto switch_default;
  case_6: /* CIL Label */ 
#line 319
  quoting_style = (enum quoting_style )5;
#line 320
  elide_outer_quotes = (_Bool)1;
  case_5: /* CIL Label */ 
#line 323
  if (! elide_outer_quotes) {
    {
#line 324
    while (1) {
      while_continue: /* CIL Label */ ;
#line 324
      if (len < buffersize) {
#line 324
        *(buffer___0 + len) = (char )'\"';
      }
#line 324
      len ++;
#line 324
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 325
  backslash_escapes = (_Bool)1;
#line 326
  quote_string = "\"";
#line 327
  quote_string_len = (size_t )1;
#line 328
  goto switch_break;
  case_7: /* CIL Label */ 
#line 331
  backslash_escapes = (_Bool)1;
#line 332
  elide_outer_quotes = (_Bool)0;
#line 333
  goto switch_break;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 339
  if ((unsigned int )quoting_style != 10U) {
    {
#line 362
    left_quote = gettext_quote("`", quoting_style);
#line 363
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 365
  if (! elide_outer_quotes) {
#line 366
    quote_string = left_quote;
    {
#line 366
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 366
      if (! *quote_string) {
#line 366
        goto while_break___0;
      }
      {
#line 367
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 367
        if (len < buffersize) {
#line 367
          *(buffer___0 + len) = (char )*quote_string;
        }
#line 367
        len ++;
#line 367
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 366
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 368
  backslash_escapes = (_Bool)1;
#line 369
  quote_string = right_quote;
#line 370
  quote_string_len = strlen(quote_string);
  }
#line 372
  goto switch_break;
  case_3: /* CIL Label */ 
#line 375
  backslash_escapes = (_Bool)1;
  case_1: /* CIL Label */ 
#line 378
  elide_outer_quotes = (_Bool)1;
  case_4: /* CIL Label */ 
#line 381
  if (! elide_outer_quotes) {
#line 382
    backslash_escapes = (_Bool)1;
  }
  case_2: /* CIL Label */ 
#line 385
  quoting_style = (enum quoting_style )2;
#line 386
  if (! elide_outer_quotes) {
    {
#line 387
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 387
      if (len < buffersize) {
#line 387
        *(buffer___0 + len) = (char )'\'';
      }
#line 387
      len ++;
#line 387
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 388
  quote_string = "\'";
#line 389
  quote_string_len = (size_t )1;
#line 390
  goto switch_break;
  case_0: /* CIL Label */ 
#line 393
  elide_outer_quotes = (_Bool)0;
#line 394
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 397
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 400
  i = (size_t )0;
  {
#line 400
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 400
    if (argsize == 0xffffffffffffffffUL) {
#line 400
      tmp___7 = (int const   )*(arg + i) == 0;
    } else {
#line 400
      tmp___7 = i == argsize;
    }
#line 400
    if (tmp___7) {
#line 400
      goto while_break___3;
    }
#line 404
    is_right_quote = (_Bool)0;
#line 405
    escaping = (_Bool)0;
#line 406
    c_and_shell_quote_compat = (_Bool)0;
#line 408
    if (backslash_escapes) {
#line 408
      if ((unsigned int )quoting_style != 2U) {
#line 408
        if (quote_string_len) {
#line 408
          if (argsize == 0xffffffffffffffffUL) {
#line 408
            if (1UL < quote_string_len) {
              {
#line 408
              argsize = strlen(arg);
#line 408
              tmp___0 = argsize;
              }
            } else {
#line 408
              tmp___0 = argsize;
            }
          } else {
#line 408
            tmp___0 = argsize;
          }
#line 408
          if (i + quote_string_len <= tmp___0) {
            {
#line 408
            tmp___1 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                             quote_string_len);
            }
#line 408
            if (tmp___1 == 0) {
#line 419
              if (elide_outer_quotes) {
#line 420
                goto force_outer_quoting_style;
              }
#line 421
              is_right_quote = (_Bool)1;
            }
          }
        }
      }
    }
#line 424
    c = (unsigned char )*(arg + i);
    {
#line 427
    if ((int )c == 0) {
#line 427
      goto case_0___0;
    }
#line 453
    if ((int )c == 63) {
#line 453
      goto case_63;
    }
#line 491
    if ((int )c == 7) {
#line 491
      goto case_7___0;
    }
#line 492
    if ((int )c == 8) {
#line 492
      goto case_8___0;
    }
#line 493
    if ((int )c == 12) {
#line 493
      goto case_12;
    }
#line 494
    if ((int )c == 10) {
#line 494
      goto case_10___0;
    }
#line 495
    if ((int )c == 13) {
#line 495
      goto case_13;
    }
#line 496
    if ((int )c == 9) {
#line 496
      goto case_9___0;
    }
#line 497
    if ((int )c == 11) {
#line 497
      goto case_11;
    }
#line 498
    if ((int )c == 92) {
#line 498
      goto case_92;
    }
#line 525
    if ((int )c == 125) {
#line 525
      goto case_125;
    }
#line 525
    if ((int )c == 123) {
#line 525
      goto case_125;
    }
#line 529
    if ((int )c == 126) {
#line 529
      goto case_126;
    }
#line 529
    if ((int )c == 35) {
#line 529
      goto case_126;
    }
#line 533
    if ((int )c == 32) {
#line 533
      goto case_32;
    }
#line 543
    if ((int )c == 124) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 96) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 94) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 91) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 62) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 61) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 60) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 59) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 42) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 41) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 40) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 38) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 36) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 34) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 33) {
#line 543
      goto case_124;
    }
#line 553
    if ((int )c == 39) {
#line 553
      goto case_39___0;
    }
#line 588
    if ((int )c == 122) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 121) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 120) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 119) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 118) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 117) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 116) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 115) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 114) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 113) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 112) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 111) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 110) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 109) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 108) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 107) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 106) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 105) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 104) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 103) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 102) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 101) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 100) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 99) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 98) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 97) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 95) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 93) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 90) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 89) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 88) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 87) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 86) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 85) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 84) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 83) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 82) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 81) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 80) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 79) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 78) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 77) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 76) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 75) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 74) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 73) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 72) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 71) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 70) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 69) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 68) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 67) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 66) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 65) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 58) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 57) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 56) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 55) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 54) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 53) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 52) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 51) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 50) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 49) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 48) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 47) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 46) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 45) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 44) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 43) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 37) {
#line 588
      goto case_122;
    }
#line 602
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 428
    if (backslash_escapes) {
      {
#line 430
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 430
        if (elide_outer_quotes) {
#line 430
          goto force_outer_quoting_style;
        }
#line 430
        escaping = (_Bool)1;
#line 430
        if ((unsigned int )quoting_style == 2U) {
#line 430
          if (! pending_shell_escape_end) {
            {
#line 430
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 430
              if (len < buffersize) {
#line 430
                *(buffer___0 + len) = (char )'\'';
              }
#line 430
              len ++;
#line 430
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 430
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 430
              if (len < buffersize) {
#line 430
                *(buffer___0 + len) = (char )'$';
              }
#line 430
              len ++;
#line 430
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 430
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 430
              if (len < buffersize) {
#line 430
                *(buffer___0 + len) = (char )'\'';
              }
#line 430
              len ++;
#line 430
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 430
            pending_shell_escape_end = (_Bool)1;
          }
        }
        {
#line 430
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 430
          if (len < buffersize) {
#line 430
            *(buffer___0 + len) = (char )'\\';
          }
#line 430
          len ++;
#line 430
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 430
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 437
      if ((unsigned int )quoting_style != 2U) {
#line 437
        if (i + 1UL < argsize) {
#line 437
          if (48 <= (int )*(arg + (i + 1UL))) {
#line 437
            if ((int const   )*(arg + (i + 1UL)) <= 57) {
              {
#line 440
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 440
                if (len < buffersize) {
#line 440
                  *(buffer___0 + len) = (char )'0';
                }
#line 440
                len ++;
#line 440
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
              {
#line 441
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 441
                if (len < buffersize) {
#line 441
                  *(buffer___0 + len) = (char )'0';
                }
#line 441
                len ++;
#line 441
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        }
      }
#line 443
      c = (unsigned char )'0';
    } else
#line 449
    if (flags & 1) {
#line 450
      goto __Cont;
    }
#line 451
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 456
    if ((unsigned int )quoting_style == 2U) {
#line 456
      goto case_2___0;
    }
#line 461
    if ((unsigned int )quoting_style == 5U) {
#line 461
      goto case_5___0;
    }
#line 486
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 457
    if (elide_outer_quotes) {
#line 458
      goto force_outer_quoting_style;
    }
#line 459
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 462
    if (flags & 4) {
#line 462
      if (i + 2UL < argsize) {
#line 462
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 468
            goto case_62;
          }
#line 481
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 471
          if (elide_outer_quotes) {
#line 472
            goto force_outer_quoting_style;
          }
#line 473
          c = (unsigned char )*(arg + (i + 2UL));
#line 474
          i += 2UL;
          {
#line 475
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 475
            if (len < buffersize) {
#line 475
              *(buffer___0 + len) = (char )'?';
            }
#line 475
            len ++;
#line 475
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 476
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 476
            if (len < buffersize) {
#line 476
              *(buffer___0 + len) = (char )'\"';
            }
#line 476
            len ++;
#line 476
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 477
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 477
            if (len < buffersize) {
#line 477
              *(buffer___0 + len) = (char )'\"';
            }
#line 477
            len ++;
#line 477
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
          {
#line 478
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 478
            if (len < buffersize) {
#line 478
              *(buffer___0 + len) = (char )'?';
            }
#line 478
            len ++;
#line 478
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 479
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 482
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 484
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 487
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 489
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 491
    esc = (unsigned char )'a';
#line 491
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 492
    esc = (unsigned char )'b';
#line 492
    goto c_escape;
    case_12: /* CIL Label */ 
#line 493
    esc = (unsigned char )'f';
#line 493
    goto c_escape;
    case_10___0: /* CIL Label */ 
#line 494
    esc = (unsigned char )'n';
#line 494
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 495
    esc = (unsigned char )'r';
#line 495
    goto c_and_shell_escape;
    case_9___0: /* CIL Label */ 
#line 496
    esc = (unsigned char )'t';
#line 496
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 497
    esc = (unsigned char )'v';
#line 497
    goto c_escape;
    case_92: /* CIL Label */ 
#line 498
    esc = c;
#line 500
    if ((unsigned int )quoting_style == 2U) {
#line 502
      if (elide_outer_quotes) {
#line 503
        goto force_outer_quoting_style;
      }
#line 504
      goto store_c;
    }
#line 509
    if (backslash_escapes) {
#line 509
      if (elide_outer_quotes) {
#line 509
        if (quote_string_len) {
#line 510
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 513
    if ((unsigned int )quoting_style == 2U) {
#line 513
      if (elide_outer_quotes) {
#line 515
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 518
    if (backslash_escapes) {
#line 520
      c = esc;
#line 521
      goto store_escape;
    }
#line 523
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 526
    if (argsize == 0xffffffffffffffffUL) {
#line 526
      tmp___2 = (int const   )*(arg + 1) == 0;
    } else {
#line 526
      tmp___2 = argsize == 1UL;
    }
#line 526
    if (! tmp___2) {
#line 527
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 530
    if (i != 0UL) {
#line 531
      goto switch_break___0;
    }
    case_32: /* CIL Label */ 
#line 534
    c_and_shell_quote_compat = (_Bool)1;
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
#line 548
    if ((unsigned int )quoting_style == 2U) {
#line 548
      if (elide_outer_quotes) {
#line 550
        goto force_outer_quoting_style;
      }
    }
#line 551
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 554
    encountered_single_quote = (_Bool)1;
#line 555
    c_and_shell_quote_compat = (_Bool)1;
#line 556
    if ((unsigned int )quoting_style == 2U) {
#line 558
      if (elide_outer_quotes) {
#line 559
        goto force_outer_quoting_style;
      }
#line 561
      if (buffersize) {
#line 561
        if (! orig_buffersize) {
#line 566
          orig_buffersize = buffersize;
#line 567
          buffersize = (size_t )0;
        }
      }
      {
#line 570
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 570
        if (len < buffersize) {
#line 570
          *(buffer___0 + len) = (char )'\'';
        }
#line 570
        len ++;
#line 570
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 571
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 571
        if (len < buffersize) {
#line 571
          *(buffer___0 + len) = (char )'\\';
        }
#line 571
        len ++;
#line 571
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 572
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 572
        if (len < buffersize) {
#line 572
          *(buffer___0 + len) = (char )'\'';
        }
#line 572
        len ++;
#line 572
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 573
      pending_shell_escape_end = (_Bool)0;
    }
#line 575
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 599
    c_and_shell_quote_compat = (_Bool)1;
#line 600
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 614
    if (unibyte_locale) {
      {
#line 616
      m = (size_t )1;
#line 617
      tmp___3 = __ctype_b_loc();
#line 617
      printable = (_Bool )(((int const   )*(*tmp___3 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 622
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 624
      m = (size_t )0;
#line 625
      printable = (_Bool)1;
      }
#line 626
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 627
        argsize = strlen(arg);
        }
      }
      {
#line 629
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 632
        tmp___4 = rpl_mbrtowc(& w, arg + (i + m), argsize - (i + m), & mbstate);
#line 632
        bytes = tmp___4;
        }
#line 634
        if (bytes == 0UL) {
#line 635
          goto while_break___18;
        } else
#line 636
        if (bytes == 0xffffffffffffffffUL) {
#line 638
          printable = (_Bool)0;
#line 639
          goto while_break___18;
        } else
#line 641
        if (bytes == 0xfffffffffffffffeUL) {
#line 643
          printable = (_Bool)0;
          {
#line 644
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 644
            if (i + m < argsize) {
#line 644
              if (! *(arg + (i + m))) {
#line 644
                goto while_break___19;
              }
            } else {
#line 644
              goto while_break___19;
            }
#line 645
            m ++;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 646
          goto while_break___18;
        } else {
#line 654
          if (elide_outer_quotes) {
#line 654
            if ((unsigned int )quoting_style == 2U) {
#line 658
              j = (size_t )1;
              {
#line 658
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 658
                if (! (j < bytes)) {
#line 658
                  goto while_break___20;
                }
                {
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 662
                  goto case_124___0;
                }
#line 665
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 663
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 666
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 658
                j ++;
              }
              while_break___20: /* CIL Label */ ;
              }
            }
          }
          {
#line 670
          tmp___5 = iswprint((wint_t )w);
          }
#line 670
          if (! tmp___5) {
#line 671
            printable = (_Bool)0;
          }
#line 672
          m += bytes;
        }
        {
#line 629
        tmp___6 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 629
        if (tmp___6) {
#line 629
          goto while_break___18;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
    }
#line 678
    c_and_shell_quote_compat = printable;
#line 680
    if (1UL < m) {
#line 680
      goto _L___0;
    } else
#line 680
    if (backslash_escapes) {
#line 680
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 684
        ilim = i + m;
        {
#line 686
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 688
          if (backslash_escapes) {
#line 688
            if (! printable) {
              {
#line 690
              while (1) {
                while_continue___22: /* CIL Label */ ;
#line 690
                if (elide_outer_quotes) {
#line 690
                  goto force_outer_quoting_style;
                }
#line 690
                escaping = (_Bool)1;
#line 690
                if ((unsigned int )quoting_style == 2U) {
#line 690
                  if (! pending_shell_escape_end) {
                    {
#line 690
                    while (1) {
                      while_continue___23: /* CIL Label */ ;
#line 690
                      if (len < buffersize) {
#line 690
                        *(buffer___0 + len) = (char )'\'';
                      }
#line 690
                      len ++;
#line 690
                      goto while_break___23;
                    }
                    while_break___23: /* CIL Label */ ;
                    }
                    {
#line 690
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 690
                      if (len < buffersize) {
#line 690
                        *(buffer___0 + len) = (char )'$';
                      }
#line 690
                      len ++;
#line 690
                      goto while_break___24;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                    {
#line 690
                    while (1) {
                      while_continue___25: /* CIL Label */ ;
#line 690
                      if (len < buffersize) {
#line 690
                        *(buffer___0 + len) = (char )'\'';
                      }
#line 690
                      len ++;
#line 690
                      goto while_break___25;
                    }
                    while_break___25: /* CIL Label */ ;
                    }
#line 690
                    pending_shell_escape_end = (_Bool)1;
                  }
                }
                {
#line 690
                while (1) {
                  while_continue___26: /* CIL Label */ ;
#line 690
                  if (len < buffersize) {
#line 690
                    *(buffer___0 + len) = (char )'\\';
                  }
#line 690
                  len ++;
#line 690
                  goto while_break___26;
                }
                while_break___26: /* CIL Label */ ;
                }
#line 690
                goto while_break___22;
              }
              while_break___22: /* CIL Label */ ;
              }
              {
#line 691
              while (1) {
                while_continue___27: /* CIL Label */ ;
#line 691
                if (len < buffersize) {
#line 691
                  *(buffer___0 + len) = (char )(48 + ((int )c >> 6));
                }
#line 691
                len ++;
#line 691
                goto while_break___27;
              }
              while_break___27: /* CIL Label */ ;
              }
              {
#line 692
              while (1) {
                while_continue___28: /* CIL Label */ ;
#line 692
                if (len < buffersize) {
#line 692
                  *(buffer___0 + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 692
                len ++;
#line 692
                goto while_break___28;
              }
              while_break___28: /* CIL Label */ ;
              }
#line 693
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 688
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 695
          if (is_right_quote) {
            {
#line 697
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 697
              if (len < buffersize) {
#line 697
                *(buffer___0 + len) = (char )'\\';
              }
#line 697
              len ++;
#line 697
              goto while_break___29;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 698
            is_right_quote = (_Bool)0;
          }
#line 700
          if (ilim <= i + 1UL) {
#line 701
            goto while_break___21;
          }
          {
#line 702
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 702
            if (pending_shell_escape_end) {
#line 702
              if (! escaping) {
                {
#line 702
                while (1) {
                  while_continue___31: /* CIL Label */ ;
#line 702
                  if (len < buffersize) {
#line 702
                    *(buffer___0 + len) = (char )'\'';
                  }
#line 702
                  len ++;
#line 702
                  goto while_break___31;
                }
                while_break___31: /* CIL Label */ ;
                }
                {
#line 702
                while (1) {
                  while_continue___32: /* CIL Label */ ;
#line 702
                  if (len < buffersize) {
#line 702
                    *(buffer___0 + len) = (char )'\'';
                  }
#line 702
                  len ++;
#line 702
                  goto while_break___32;
                }
                while_break___32: /* CIL Label */ ;
                }
#line 702
                pending_shell_escape_end = (_Bool)0;
              }
            }
#line 702
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
          {
#line 703
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 703
            if (len < buffersize) {
#line 703
              *(buffer___0 + len) = (char )c;
            }
#line 703
            len ++;
#line 703
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
#line 704
          i ++;
#line 704
          c = (unsigned char )*(arg + i);
        }
        while_break___21: /* CIL Label */ ;
        }
#line 707
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 712
    if (backslash_escapes) {
#line 712
      if ((unsigned int )quoting_style != 2U) {
#line 712
        goto _L___3;
      } else {
#line 712
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 712
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 712
      if (quote_these_too) {
#line 712
        if (! ((*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) >> (unsigned long )c % (sizeof(int ) * 8UL)) & 1U)) {
#line 712
          goto _L___2;
        }
      } else {
#line 712
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 712
    if (! is_right_quote) {
#line 717
      goto store_c;
    }
    store_escape: 
    {
#line 720
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 720
      if (elide_outer_quotes) {
#line 720
        goto force_outer_quoting_style;
      }
#line 720
      escaping = (_Bool)1;
#line 720
      if ((unsigned int )quoting_style == 2U) {
#line 720
        if (! pending_shell_escape_end) {
          {
#line 720
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 720
            if (len < buffersize) {
#line 720
              *(buffer___0 + len) = (char )'\'';
            }
#line 720
            len ++;
#line 720
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
          {
#line 720
          while (1) {
            while_continue___36: /* CIL Label */ ;
#line 720
            if (len < buffersize) {
#line 720
              *(buffer___0 + len) = (char )'$';
            }
#line 720
            len ++;
#line 720
            goto while_break___36;
          }
          while_break___36: /* CIL Label */ ;
          }
          {
#line 720
          while (1) {
            while_continue___37: /* CIL Label */ ;
#line 720
            if (len < buffersize) {
#line 720
              *(buffer___0 + len) = (char )'\'';
            }
#line 720
            len ++;
#line 720
            goto while_break___37;
          }
          while_break___37: /* CIL Label */ ;
          }
#line 720
          pending_shell_escape_end = (_Bool)1;
        }
      }
      {
#line 720
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 720
        if (len < buffersize) {
#line 720
          *(buffer___0 + len) = (char )'\\';
        }
#line 720
        len ++;
#line 720
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 720
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    store_c: 
    {
#line 723
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 723
      if (pending_shell_escape_end) {
#line 723
        if (! escaping) {
          {
#line 723
          while (1) {
            while_continue___40: /* CIL Label */ ;
#line 723
            if (len < buffersize) {
#line 723
              *(buffer___0 + len) = (char )'\'';
            }
#line 723
            len ++;
#line 723
            goto while_break___40;
          }
          while_break___40: /* CIL Label */ ;
          }
          {
#line 723
          while (1) {
            while_continue___41: /* CIL Label */ ;
#line 723
            if (len < buffersize) {
#line 723
              *(buffer___0 + len) = (char )'\'';
            }
#line 723
            len ++;
#line 723
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
#line 723
          pending_shell_escape_end = (_Bool)0;
        }
      }
#line 723
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 724
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 724
      if (len < buffersize) {
#line 724
        *(buffer___0 + len) = (char )c;
      }
#line 724
      len ++;
#line 724
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
#line 726
    if (! c_and_shell_quote_compat) {
#line 727
      all_c_and_shell_quote_compat = (_Bool)0;
    }
    __Cont: /* CIL Label */ 
#line 400
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 730
  if (len == 0UL) {
#line 730
    if ((unsigned int )quoting_style == 2U) {
#line 730
      if (elide_outer_quotes) {
#line 732
        goto force_outer_quoting_style;
      }
    }
  }
#line 738
  if ((unsigned int )quoting_style == 2U) {
#line 738
    if (! elide_outer_quotes) {
#line 738
      if (encountered_single_quote) {
#line 741
        if (all_c_and_shell_quote_compat) {
          {
#line 742
          tmp___8 = quotearg_buffer_restyled(buffer___0, orig_buffersize, arg, argsize,
                                             (enum quoting_style )5, flags, quote_these_too,
                                             left_quote, right_quote);
          }
#line 742
          return (tmp___8);
        } else
#line 746
        if (! buffersize) {
#line 746
          if (orig_buffersize) {
#line 749
            buffersize = orig_buffersize;
#line 750
            len = (size_t )0;
#line 751
            goto process_input;
          }
        }
      }
    }
  }
#line 755
  if (quote_string) {
#line 755
    if (! elide_outer_quotes) {
      {
#line 756
      while (1) {
        while_continue___43: /* CIL Label */ ;
#line 756
        if (! *quote_string) {
#line 756
          goto while_break___43;
        }
        {
#line 757
        while (1) {
          while_continue___44: /* CIL Label */ ;
#line 757
          if (len < buffersize) {
#line 757
            *(buffer___0 + len) = (char )*quote_string;
          }
#line 757
          len ++;
#line 757
          goto while_break___44;
        }
        while_break___44: /* CIL Label */ ;
        }
#line 756
        quote_string ++;
      }
      while_break___43: /* CIL Label */ ;
      }
    }
  }
#line 759
  if (len < buffersize) {
#line 760
    *(buffer___0 + len) = (char )'\000';
  }
#line 761
  return (len);
  force_outer_quoting_style: 
#line 766
  if ((unsigned int )quoting_style == 2U) {
#line 766
    if (backslash_escapes) {
#line 767
      quoting_style = (enum quoting_style )4;
    }
  }
  {
#line 768
  tmp___9 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 768
  return (tmp___9);
}
}
#line 783 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 788
  if (o) {
#line 788
    tmp = o;
  } else {
#line 788
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 788
  p = tmp;
#line 789
  tmp___0 = __errno_location();
#line 789
  e = *tmp___0;
#line 790
  tmp___1 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 790
  r = tmp___1;
#line 793
  tmp___2 = __errno_location();
#line 793
  *tmp___2 = e;
  }
#line 794
  return (r);
}
}
#line 798 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 802
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 802
  return (tmp);
}
}
#line 811 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *buf ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 815
  if (o) {
#line 815
    tmp = o;
  } else {
#line 815
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 815
  p = tmp;
#line 816
  tmp___0 = __errno_location();
#line 816
  e = *tmp___0;
  }
#line 818
  if (size) {
#line 818
    tmp___1 = 0;
  } else {
#line 818
    tmp___1 = 1;
  }
  {
#line 818
  flags = (int )(p->flags | (int const   )tmp___1);
#line 819
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 819
  bufsize = tmp___2 + 1UL;
#line 823
  tmp___3 = xcharalloc(bufsize);
#line 823
  buf = tmp___3;
#line 824
  quotearg_buffer_restyled(buf, bufsize, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 827
  tmp___4 = __errno_location();
#line 827
  *tmp___4 = e;
  }
#line 828
  if (size) {
#line 829
    *size = bufsize - 1UL;
  }
#line 830
  return (buf);
}
}
#line 842 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static char slot0[256]  ;
#line 843 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static int nslots  =    1;
#line 844 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 845 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 847 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  int i ;

  {
#line 850
  sv = slotvec;
#line 852
  i = 1;
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (! (i < nslots)) {
#line 852
      goto while_break;
    }
    {
#line 853
    free((void *)(sv + i)->val);
#line 852
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 856
    free((void *)(sv + 0)->val);
#line 857
    slotvec0.size = sizeof(slot0);
#line 858
    slotvec0.val = slot0;
    }
  }
#line 860
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 862
    free((void *)sv);
#line 863
    slotvec = & slotvec0;
    }
  }
#line 865
  nslots = 1;
#line 866
  return;
}
}
#line 876 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  struct slotvec *sv ;
  _Bool preallocated ;
  unsigned long tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 880
  tmp = __errno_location();
#line 880
  e = *tmp;
#line 882
  sv = slotvec;
  }
#line 884
  if (n < 0) {
    {
#line 885
    abort();
    }
  }
#line 887
  if (nslots <= n) {
#line 889
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 891
    if (2147483647UL < 9223372036854775807UL / sizeof(*sv)) {
#line 891
      tmp___0 = 2147483647UL;
    } else {
#line 891
      tmp___0 = 9223372036854775807UL / sizeof(*sv);
    }
#line 891
    if (tmp___0 <= (unsigned long )n) {
      {
#line 892
      xalloc_die();
      }
    }
#line 894
    if (preallocated) {
#line 894
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 894
      tmp___1 = sv;
    }
    {
#line 894
    tmp___2 = xrealloc((void *)tmp___1, (unsigned long )(n + 1) * sizeof(*sv));
#line 894
    sv = (struct slotvec *)tmp___2;
#line 894
    slotvec = sv;
    }
#line 895
    if (preallocated) {
#line 896
      *sv = slotvec0;
    }
    {
#line 897
    memset((void *)(sv + nslots), 0, (unsigned long )((n + 1) - nslots) * sizeof(*sv));
#line 898
    nslots = n + 1;
    }
  }
  {
#line 902
  size = (sv + n)->size;
#line 903
  val = (sv + n)->val;
#line 905
  flags = (int )(options->flags | 1);
#line 906
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 906
  qsize = tmp___3;
  }
#line 912
  if (size <= qsize) {
#line 914
    size = qsize + 1UL;
#line 914
    (sv + n)->size = size;
#line 915
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 916
      free((void *)val);
      }
    }
    {
#line 917
    val = xcharalloc(size);
#line 917
    (sv + n)->val = val;
#line 918
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 924
  tmp___4 = __errno_location();
#line 924
  *tmp___4 = e;
  }
#line 925
  return (val);
}
}
#line 929 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 932
  tmp = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 932
  return (tmp);
}
}
#line 935 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 938
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 938
  return (tmp);
}
}
#line 941 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 944
  tmp = quotearg_n(0, arg);
  }
#line 944
  return (tmp);
}
}
#line 947 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 950
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 950
  return (tmp);
}
}
#line 953 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 956
  tmp = quoting_options_from_style(s);
#line 956
  o = tmp;
#line 957
  tmp___0 = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& o));
  }
#line 957
  return (tmp___0);
}
}
#line 960 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 964
  tmp = quoting_options_from_style(s);
#line 964
  o = tmp;
#line 965
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 965
  return (tmp___0);
}
}
#line 968 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 971
  tmp = quotearg_n_style(0, s, arg);
  }
#line 971
  return (tmp);
}
}
#line 974 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 977
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 977
  return (tmp);
}
}
#line 980 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 984
  options = default_quoting_options;
#line 985
  set_char_quoting(& options, ch, 1);
#line 986
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 986
  return (tmp);
}
}
#line 989 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 992
  tmp = quotearg_char_mem(arg, 0xffffffffffffffffUL, ch);
  }
#line 992
  return (tmp);
}
}
#line 995 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 998
  tmp = quotearg_char(arg, (char )':');
  }
#line 998
  return (tmp);
}
}
#line 1001 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 1004
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 1004
  return (tmp);
}
}
#line 1007 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_n_style_colon(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 1011
  options = quoting_options_from_style(s);
#line 1012
  set_char_quoting(& options, (char )':', 1);
#line 1013
  tmp = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& options));
  }
#line 1013
  return (tmp);
}
}
#line 1016 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 1020
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, 0xffffffffffffffffUL);
  }
#line 1020
  return (tmp);
}
}
#line 1024 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *tmp ;

  {
  {
#line 1029
  o = default_quoting_options;
#line 1030
  set_custom_quoting(& o, left_quote, right_quote);
#line 1031
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 1031
  return (tmp);
}
}
#line 1034 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 1038
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
  }
#line 1038
  return (tmp);
}
}
#line 1041 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 1045
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  }
#line 1045
  return (tmp);
}
}
#line 1051 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
struct quoting_options quote_quoting_options  =    {(enum quoting_style )8, 0, {0U}, (char const   *)((void *)0), (char const   *)((void *)0)};
#line 1059 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 1062
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& quote_quoting_options));
  }
#line 1062
  return ((char const   *)tmp);
}
}
#line 1065 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char const   *quote_mem(char const   *arg , size_t argsize ) 
{ 
  char const   *tmp ;

  {
  {
#line 1068
  tmp = quote_n_mem(0, arg, argsize);
  }
#line 1068
  return (tmp);
}
}
#line 1071 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char const   *quote_n(int n , char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 1074
  tmp = quote_n_mem(n, arg, 0xffffffffffffffffUL);
  }
#line 1074
  return (tmp);
}
}
#line 1077 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
char const   *quote(char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 1080
  tmp = quote_n(0, arg);
  }
#line 1080
  return (tmp);
}
}
#line 21 "/home/khheo/project/benchmark/grep-3.1/lib/propername.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 92 "/home/khheo/project/benchmark/grep-3.1/lib/propername.h"
char const   *proper_name(char const   *name ) ;
#line 98
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) ;
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 1265 "./string.h"
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle )  __attribute__((__pure__)) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswalnum)(wint_t __wc ) ;
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 131 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
__inline void mbuiter_multi_next(struct mbuiter_multi *iter ) 
{ 
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___7 ;
  _Bool tmp___8 ;

  {
#line 134
  if (iter->next_done) {
#line 135
    return;
  }
#line 136
  if (iter->in_shift) {
#line 137
    goto with_shift;
  }
  {
#line 139
  tmp___8 = is_basic((char )*(iter->cur.ptr));
  }
#line 139
  if (tmp___8) {
#line 144
    iter->cur.bytes = (size_t )1;
#line 145
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 146
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 150
    tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 150
    if (! tmp___2) {
      {
#line 150
      __assert_fail("mbsinit (&iter->state)", "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h",
                    150U, "mbuiter_multi_next");
      }
    }
#line 151
    iter->in_shift = (_Bool)1;
    with_shift: 
    {
#line 153
    tmp___3 = __ctype_get_mb_cur_max();
#line 153
    tmp___4 = strnlen1(iter->cur.ptr, tmp___3);
#line 153
    iter->cur.bytes = rpl_mbrtowc(& iter->cur.wc, iter->cur.ptr, tmp___4, & iter->state);
    }
#line 156
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 159
      iter->cur.bytes = (size_t )1;
#line 160
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 164
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
      {
#line 167
      iter->cur.bytes = strlen(iter->cur.ptr);
#line 168
      iter->cur.wc_valid = (_Bool)0;
      }
    } else {
#line 174
      if (iter->cur.bytes == 0UL) {
#line 177
        iter->cur.bytes = (size_t )1;
#line 178
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 178
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h",
                        178U, "mbuiter_multi_next");
          }
        }
#line 179
        if (! (iter->cur.wc == 0)) {
          {
#line 179
          __assert_fail("iter->cur.wc == 0", "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h",
                        179U, "mbuiter_multi_next");
          }
        }
      }
      {
#line 181
      iter->cur.wc_valid = (_Bool)1;
#line 185
      tmp___7 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 185
      if (tmp___7) {
#line 186
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 189
  iter->next_done = (_Bool)1;
#line 190
  return;
}
}
#line 192 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
__inline void mbuiter_multi_reloc(struct mbuiter_multi *iter , ptrdiff_t ptrdiff ) 
{ 


  {
#line 195
  iter->cur.ptr += ptrdiff;
#line 196
  return;
}
}
#line 198 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
__inline void mbuiter_multi_copy(struct mbuiter_multi *new_iter , struct mbuiter_multi  const  *old_iter ) 
{ 
  _Bool tmp ;

  {
#line 201
  tmp = (_Bool )old_iter->in_shift;
#line 201
  new_iter->in_shift = tmp;
#line 201
  if (tmp) {
    {
#line 202
    memcpy((void */* __restrict  */)(& new_iter->state), (void const   */* __restrict  */)(& old_iter->state),
           sizeof(mbstate_t ));
    }
  } else {
    {
#line 204
    memset((void *)(& new_iter->state), 0, sizeof(mbstate_t ));
    }
  }
  {
#line 205
  new_iter->next_done = (_Bool )old_iter->next_done;
#line 206
  mb_copy(& new_iter->cur, & old_iter->cur);
  }
#line 207
  return;
}
}
#line 230
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 54 "/home/khheo/project/benchmark/grep-3.1/lib/propername.c"
static _Bool mbsstr_trimmed_wordbounded(char const   *string , char const   *sub ) 
{ 
  char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 57
  tmp = trim2(sub, 2);
#line 57
  tsub = tmp;
#line 58
  found = (_Bool)0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((int const   )*string != 0)) {
#line 60
      goto while_break;
    }
    {
#line 62
    tmp___0 = mbsstr(string, (char const   *)tsub);
#line 62
    tsub_in_string = (char const   *)tmp___0;
    }
#line 63
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
#line 64
      goto while_break;
    } else {
      {
#line 67
      tmp___11 = __ctype_get_mb_cur_max();
      }
#line 67
      if (tmp___11 > 1UL) {
        {
#line 73
        string_iter.cur.ptr = string;
#line 73
        string_iter.in_shift = (_Bool)0;
#line 73
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 73
        string_iter.next_done = (_Bool)0;
#line 74
        word_boundary_before = (_Bool)1;
        }
#line 75
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
          {
#line 78
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 80
            mbuiter_multi_next(& string_iter);
            }
#line 80
            if (string_iter.cur.wc_valid) {
#line 80
              if (string_iter.cur.wc == 0) {
#line 80
                tmp___1 = 0;
              } else {
#line 80
                tmp___1 = 1;
              }
            } else {
#line 80
              tmp___1 = 1;
            }
#line 80
            if (! tmp___1) {
              {
#line 81
              abort();
              }
            }
#line 82
            last_char_before_tsub = string_iter.cur;
#line 83
            string_iter.cur.ptr += string_iter.cur.bytes;
#line 83
            string_iter.next_done = (_Bool)0;
#line 78
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
#line 78
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 86
          if (last_char_before_tsub.wc_valid) {
            {
#line 86
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
            }
#line 86
            if (tmp___2) {
#line 87
              word_boundary_before = (_Bool)0;
            }
          }
        }
        {
#line 90
        string_iter.cur.ptr = tsub_in_string;
#line 90
        string_iter.in_shift = (_Bool)0;
#line 90
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 90
        string_iter.next_done = (_Bool)0;
#line 94
        tsub_iter.cur.ptr = (char const   *)tsub;
#line 94
        tsub_iter.in_shift = (_Bool)0;
#line 94
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
#line 94
        tsub_iter.next_done = (_Bool)0;
        }
        {
#line 94
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 94
          mbuiter_multi_next(& tsub_iter);
          }
#line 94
          if (tsub_iter.cur.wc_valid) {
#line 94
            if (tsub_iter.cur.wc == 0) {
#line 94
              tmp___4 = 0;
            } else {
#line 94
              tmp___4 = 1;
            }
          } else {
#line 94
            tmp___4 = 1;
          }
#line 94
          if (! tmp___4) {
#line 94
            goto while_break___1;
          }
          {
#line 98
          mbuiter_multi_next(& string_iter);
          }
#line 98
          if (string_iter.cur.wc_valid) {
#line 98
            if (string_iter.cur.wc == 0) {
#line 98
              tmp___3 = 0;
            } else {
#line 98
              tmp___3 = 1;
            }
          } else {
#line 98
            tmp___3 = 1;
          }
#line 98
          if (! tmp___3) {
            {
#line 99
            abort();
            }
          }
#line 100
          string_iter.cur.ptr += string_iter.cur.bytes;
#line 100
          string_iter.next_done = (_Bool)0;
#line 94
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
#line 94
          tsub_iter.next_done = (_Bool)0;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 103
        word_boundary_after = (_Bool)1;
#line 104
        mbuiter_multi_next(& string_iter);
        }
#line 104
        if (string_iter.cur.wc_valid) {
#line 104
          if (string_iter.cur.wc == 0) {
#line 104
            tmp___6 = 0;
          } else {
#line 104
            tmp___6 = 1;
          }
        } else {
#line 104
          tmp___6 = 1;
        }
#line 104
        if (tmp___6) {
#line 106
          first_char_after_tsub = string_iter.cur;
#line 107
          if (first_char_after_tsub.wc_valid) {
            {
#line 107
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
            }
#line 107
            if (tmp___5) {
#line 108
              word_boundary_after = (_Bool)0;
            }
          }
        }
#line 111
        if (word_boundary_before) {
#line 111
          if (word_boundary_after) {
#line 113
            found = (_Bool)1;
#line 114
            goto while_break;
          }
        }
        {
#line 117
        string_iter.cur.ptr = tsub_in_string;
#line 117
        string_iter.in_shift = (_Bool)0;
#line 117
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 117
        string_iter.next_done = (_Bool)0;
#line 118
        mbuiter_multi_next(& string_iter);
        }
#line 118
        if (string_iter.cur.wc_valid) {
#line 118
          if (string_iter.cur.wc == 0) {
#line 118
            tmp___7 = 0;
          } else {
#line 118
            tmp___7 = 1;
          }
        } else {
#line 118
          tmp___7 = 1;
        }
#line 118
        if (! tmp___7) {
#line 119
          goto while_break;
        }
#line 120
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
#line 128
        word_boundary_before___0 = (_Bool)1;
#line 129
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
          {
#line 130
          tmp___8 = __ctype_b_loc();
          }
#line 130
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
#line 131
            word_boundary_before___0 = (_Bool)0;
          }
        }
        {
#line 133
        tmp___9 = strlen((char const   *)tsub);
#line 133
        p = tsub_in_string + tmp___9;
#line 134
        word_boundary_after___0 = (_Bool)1;
        }
#line 135
        if ((int const   )*p != 0) {
          {
#line 136
          tmp___10 = __ctype_b_loc();
          }
#line 136
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
#line 137
            word_boundary_after___0 = (_Bool)0;
          }
        }
#line 139
        if (word_boundary_before___0) {
#line 139
          if (word_boundary_after___0) {
#line 141
            found = (_Bool)1;
#line 142
            goto while_break;
          }
        }
#line 145
        if ((int const   )*tsub_in_string == 0) {
#line 146
          goto while_break;
        }
#line 147
        string = tsub_in_string + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  free((void *)tsub);
  }
#line 152
  return (found);
}
}
#line 157 "/home/khheo/project/benchmark/grep-3.1/lib/propername.c"
char const   *proper_name(char const   *name ) 
{ 
  char const   *translation ;
  char *tmp ;
  char *result ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
  {
#line 161
  tmp = gettext(name);
#line 161
  translation = (char const   *)tmp;
  }
#line 163
  if ((unsigned long )translation != (unsigned long )name) {
    {
#line 166
    tmp___7 = mbsstr_trimmed_wordbounded(translation, name);
    }
#line 166
    if (tmp___7) {
#line 167
      return (translation);
    } else {
#line 171
      if (sizeof(char ) == 1UL) {
        {
#line 171
        tmp___0 = strlen(translation);
#line 171
        tmp___1 = strlen(name);
#line 171
        tmp___2 = xmalloc((((tmp___0 + 2UL) + tmp___1) + 1UL) + 1UL);
#line 171
        tmp___6 = tmp___2;
        }
      } else {
        {
#line 171
        tmp___3 = strlen(translation);
#line 171
        tmp___4 = strlen(name);
#line 171
        tmp___5 = xnmalloc((((tmp___3 + 2UL) + tmp___4) + 1UL) + 1UL, sizeof(char ));
#line 171
        tmp___6 = tmp___5;
        }
      }
      {
#line 171
      result = (char *)tmp___6;
#line 174
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s (%s)",
              translation, name);
      }
#line 175
      return ((char const   *)result);
    }
  } else {
#line 179
    return (name);
  }
}
}
#line 187 "/home/khheo/project/benchmark/grep-3.1/lib/propername.c"
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  char *alloc_name_converted ;
  char *alloc_name_converted_translit ;
  char const   *name_converted ;
  char const   *name_converted_translit ;
  char const   *name ;
  char *converted_translit ;
  size_t len ;
  size_t tmp___1 ;
  char *locale_code_translit ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *result ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;

  {
  {
#line 191
  tmp = gettext(name_ascii);
#line 191
  translation = (char const   *)tmp;
#line 194
  tmp___0 = locale_charset();
#line 194
  locale_code = tmp___0;
#line 195
  alloc_name_converted = (char *)((void *)0);
#line 196
  alloc_name_converted_translit = (char *)((void *)0);
#line 197
  name_converted = (char const   *)((void *)0);
#line 198
  name_converted_translit = (char const   *)((void *)0);
#line 201
  tmp___6 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 201
  if (tmp___6 != 0) {
    {
#line 204
    alloc_name_converted = xstr_iconv(name_utf8, "UTF-8", locale_code);
#line 204
    name_converted = (char const   *)alloc_name_converted;
#line 213
    tmp___1 = strlen(locale_code);
#line 213
    len = tmp___1;
    }
#line 214
    if (sizeof(char ) == 1UL) {
      {
#line 214
      tmp___2 = xmalloc((len + 10UL) + 1UL);
#line 214
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 214
      tmp___3 = xnmalloc((len + 10UL) + 1UL, sizeof(char ));
#line 214
      tmp___4 = tmp___3;
      }
    }
    {
#line 214
    locale_code_translit = (char *)tmp___4;
#line 215
    memcpy((void */* __restrict  */)locale_code_translit, (void const   */* __restrict  */)locale_code,
           len);
#line 216
    memcpy((void */* __restrict  */)(locale_code_translit + len), (void const   */* __restrict  */)"//TRANSLIT",
           (size_t )11);
#line 218
    converted_translit = xstr_iconv(name_utf8, "UTF-8", (char const   *)locale_code_translit);
#line 221
    free((void *)locale_code_translit);
    }
#line 223
    if ((unsigned long )converted_translit != (unsigned long )((void *)0)) {
      {
#line 230
      tmp___5 = strchr((char const   *)converted_translit, '?');
      }
#line 230
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
        {
#line 231
        free((void *)converted_translit);
        }
      } else {
#line 234
        alloc_name_converted_translit = converted_translit;
#line 234
        name_converted_translit = (char const   *)alloc_name_converted_translit;
      }
    }
  } else {
#line 243
    name_converted = name_utf8;
#line 244
    name_converted_translit = name_utf8;
  }
#line 248
  if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
#line 248
    name = name_converted;
  } else {
#line 248
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
#line 248
      tmp___7 = name_converted_translit;
    } else {
#line 248
      tmp___7 = name_ascii;
    }
#line 248
    name = tmp___7;
  }
  {
#line 255
  tmp___18 = strcmp(translation, name_ascii);
  }
#line 255
  if (tmp___18 != 0) {
    {
#line 258
    tmp___15 = mbsstr_trimmed_wordbounded(translation, name_ascii);
    }
#line 258
    if (tmp___15) {
#line 258
      goto _L;
    } else
#line 258
    if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
      {
#line 258
      tmp___16 = mbsstr_trimmed_wordbounded(translation, name_converted);
      }
#line 258
      if (tmp___16) {
#line 258
        goto _L;
      } else {
#line 258
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 258
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
      {
#line 258
      tmp___17 = mbsstr_trimmed_wordbounded(translation, name_converted_translit);
      }
#line 258
      if (tmp___17) {
        _L: /* CIL Label */ 
#line 264
        if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
          {
#line 265
          free((void *)alloc_name_converted);
          }
        }
#line 266
        if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
          {
#line 267
          free((void *)alloc_name_converted_translit);
          }
        }
#line 268
        return (translation);
      } else {
#line 258
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 273
      if (sizeof(char ) == 1UL) {
        {
#line 273
        tmp___8 = strlen(translation);
#line 273
        tmp___9 = strlen(name);
#line 273
        tmp___10 = xmalloc((((tmp___8 + 2UL) + tmp___9) + 1UL) + 1UL);
#line 273
        tmp___14 = tmp___10;
        }
      } else {
        {
#line 273
        tmp___11 = strlen(translation);
#line 273
        tmp___12 = strlen(name);
#line 273
        tmp___13 = xnmalloc((((tmp___11 + 2UL) + tmp___12) + 1UL) + 1UL, sizeof(char ));
#line 273
        tmp___14 = tmp___13;
        }
      }
      {
#line 273
      result = (char *)tmp___14;
#line 276
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s (%s)",
              translation, name);
      }
#line 278
      if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
        {
#line 279
        free((void *)alloc_name_converted);
        }
      }
#line 280
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
        {
#line 281
        free((void *)alloc_name_converted_translit);
        }
      }
#line 282
      return ((char const   *)result);
    }
  } else {
#line 287
    if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
#line 287
      if ((unsigned long )alloc_name_converted != (unsigned long )name) {
        {
#line 288
        free((void *)alloc_name_converted);
        }
      }
    }
#line 289
    if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
#line 289
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )name) {
        {
#line 291
        free((void *)alloc_name_converted_translit);
        }
      }
    }
#line 292
    return (name);
  }
}
}
#line 21 "/home/khheo/project/benchmark/grep-3.1/lib/unistd-safer.h"
int fd_safer(int fd ) ;
#line 22
int pipe_safer(int *fd ) ;
#line 420 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 30 "/home/khheo/project/benchmark/grep-3.1/lib/pipe-safer.c"
int pipe_safer(int *fd ) 
{ 
  int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 34
  tmp___1 = pipe(fd);
  }
#line 34
  if (tmp___1 == 0) {
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 37
      if (! (i < 2)) {
#line 37
        goto while_break;
      }
      {
#line 39
      *(fd + i) = fd_safer(*(fd + i));
      }
#line 40
      if (*(fd + i) < 0) {
        {
#line 42
        tmp = __errno_location();
#line 42
        e = *tmp;
#line 43
        close(*(fd + (1 - i)));
#line 44
        tmp___0 = __errno_location();
#line 44
        *tmp___0 = e;
        }
#line 45
        return (-1);
      }
#line 37
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 49
    return (0);
  }
#line 55
  return (-1);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 22 "/home/khheo/project/benchmark/grep-3.1/lib/dirent-safer.h"
DIR *opendir_safer(char const   *name ) ;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 20 "/home/khheo/project/benchmark/grep-3.1/lib/unistd-safer.h"
int dup_safer(int fd ) ;
#line 30 "/home/khheo/project/benchmark/grep-3.1/lib/opendir-safer.c"
DIR *opendir_safer(char const   *name ) 
{ 
  DIR *dp ;
  DIR *tmp ;
  int fd ;
  int tmp___0 ;
  DIR *newdp ;
  int e ;
  int f ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 33
  tmp = opendir(name);
#line 33
  dp = tmp;
  }
#line 35
  if (dp) {
    {
#line 37
    tmp___0 = dirfd(dp);
#line 37
    fd = tmp___0;
    }
#line 39
    if (0 <= fd) {
#line 39
      if (fd <= 2) {
        {
#line 52
        tmp___1 = dup_safer(fd);
#line 52
        f = tmp___1;
        }
#line 53
        if (f < 0) {
          {
#line 55
          tmp___2 = __errno_location();
#line 55
          e = *tmp___2;
#line 56
          newdp = (DIR *)((void *)0);
          }
        } else {
          {
#line 60
          newdp = fdopendir(f);
#line 61
          tmp___3 = __errno_location();
#line 61
          e = *tmp___3;
          }
#line 62
          if (! newdp) {
            {
#line 63
            close(f);
            }
          }
        }
        {
#line 69
        closedir(dp);
#line 70
        tmp___4 = __errno_location();
#line 70
        *tmp___4 = e;
#line 71
        dp = newdp;
        }
      }
    }
  }
#line 75
  return (dp);
}
}
#line 26 "/home/khheo/project/benchmark/grep-3.1/lib/fcntl-safer.h"
int openat_safer(int fd , char const   *file , int flags  , ...) ;
#line 181 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...) ;
#line 28 "/home/khheo/project/benchmark/grep-3.1/lib/openat-safer.c"
int openat_safer(int fd , char const   *file , int flags  , ...) 
{ 
  mode_t mode ;
  va_list ap ;
  mode_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 31
  mode = (mode_t )0;
#line 33
  if (flags & 64) {
    {
#line 36
    __builtin_va_start(ap, flags);
#line 40
    tmp = __builtin_va_arg(ap, mode_t );
#line 40
    mode = tmp;
#line 42
    __builtin_va_end(ap);
    }
  }
  {
#line 45
  tmp___0 = openat(fd, file, flags, mode);
#line 45
  tmp___1 = fd_safer(tmp___0);
  }
#line 45
  return (tmp___1);
}
}
#line 47 "/home/khheo/project/benchmark/grep-3.1/lib/openat-priv.h"
char *openat_proc_name(char *buf , int fd , char const   *file ) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 290 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 65 "/home/khheo/project/benchmark/grep-3.1/lib/openat-proc.c"
static int proc_status  =    0;
#line 43 "/home/khheo/project/benchmark/grep-3.1/lib/openat-proc.c"
char *openat_proc_name(char *buf , int fd , char const   *file ) 
{ 
  char *result ;
  int dirlen ;
  int proc_self_fd ;
  int tmp ;
  char dotdot_buf[(27UL + sizeof("../fd")) - 1UL] ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 46
  result = (char *)buf;
#line 50
  if (! *file) {
#line 52
    *(buf + 0) = (char )'\000';
#line 53
    return ((char *)buf);
  }
#line 66
  if (! proc_status) {
    {
#line 76
    tmp = open("/proc/self/fd", 67840);
#line 76
    proc_self_fd = tmp;
    }
#line 78
    if (proc_self_fd < 0) {
#line 79
      proc_status = -1;
    } else {
      {
#line 88
      sprintf((char */* __restrict  */)(dotdot_buf), (char const   */* __restrict  */)"/proc/self/fd/%d/../fd",
              proc_self_fd);
#line 89
      tmp___1 = access((char const   *)(dotdot_buf), 0);
      }
#line 89
      if (tmp___1) {
#line 89
        proc_status = -1;
      } else {
#line 89
        proc_status = 1;
      }
      {
#line 90
      close(proc_self_fd);
      }
    }
  }
#line 94
  if (proc_status < 0) {
#line 95
    return ((char *)((void *)0));
  } else {
    {
#line 98
    tmp___2 = strlen(file);
#line 98
    bufsize = 27UL + tmp___2;
    }
#line 99
    if (4032UL < bufsize) {
      {
#line 101
      tmp___3 = malloc(bufsize);
#line 101
      result = (char *)tmp___3;
      }
#line 102
      if (! result) {
#line 103
        return ((char *)((void *)0));
      }
    }
    {
#line 106
    dirlen = sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"/proc/self/fd/%d/",
                     fd);
    }
  }
  {
#line 132
  strcpy((char */* __restrict  */)(result + dirlen), (char const   */* __restrict  */)file);
  }
#line 133
  return (result);
}
}
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-3.1/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 48
void openat_restore_fail(int errnum ) ;
#line 49
void openat_save_fail(int errnum ) ;
#line 121
#pragma GCC diagnostic pop
#line 33 "/home/khheo/project/benchmark/grep-3.1/lib/openat-die.c"
void openat_save_fail(int errnum ) 
{ 
  char *tmp ;

  {
  {
#line 37
  tmp = gettext("unable to record current working directory");
#line 37
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 44
  abort();
  }
}
}
#line 52 "/home/khheo/project/benchmark/grep-3.1/lib/openat-die.c"
void openat_restore_fail(int errnum ) 
{ 
  char *tmp ;

  {
  {
#line 56
  tmp = gettext("failed to return to initial working directory");
#line 56
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 61
  abort();
  }
}
}
#line 28 "/home/khheo/project/benchmark/grep-3.1/lib/open-safer.c"
int open_safer(char const   *file , int flags  , ...) 
{ 
  mode_t mode ;
  va_list ap ;
  mode_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 31
  mode = (mode_t )0;
#line 33
  if (flags & 64) {
    {
#line 36
    __builtin_va_start(ap, flags);
#line 40
    tmp = __builtin_va_arg(ap, mode_t );
#line 40
    mode = tmp;
#line 42
    __builtin_va_end(ap);
    }
  }
  {
#line 45
  tmp___0 = open(file, flags, mode);
#line 45
  tmp___1 = fd_safer(tmp___0);
  }
#line 45
  return (tmp___1);
}
}
#line 213 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.h"
void _obstack_newchunk(struct obstack *h , size_t length ) ;
#line 214
void _obstack_free(struct obstack *h , void *obj ) ;
#line 215
int _obstack_begin(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(size_t  ) ,
                   void (*freefun)(void * ) ) ;
#line 218
int _obstack_begin_1(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(void * ,
                                                                                            size_t  ) ,
                     void (*freefun)(void * , void * ) , void *arg ) ;
#line 222
size_t _obstack_memory_used(struct obstack *h )  __attribute__((__pure__)) ;
#line 230
 __attribute__((__noreturn__)) void (*obstack_alloc_failed_handler)(void) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 83 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
static void *call_chunkfun(struct obstack *h , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 86
  if (h->use_extra_arg) {
    {
#line 87
    tmp = (*(h->chunkfun.extra))(h->extra_arg, size);
    }
#line 87
    return (tmp);
  } else {
    {
#line 89
    tmp___0 = (*(h->chunkfun.plain))(size);
    }
#line 89
    return (tmp___0);
  }
}
}
#line 92 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
static void call_freefun(struct obstack *h , void *old_chunk ) 
{ 


  {
#line 95
  if (h->use_extra_arg) {
    {
#line 96
    (*(h->freefun.extra))(h->extra_arg, old_chunk);
    }
  } else {
    {
#line 98
    (*(h->freefun.plain))(old_chunk);
    }
  }
#line 99
  return;
}
}
#line 108 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
static int _obstack_begin_worker(struct obstack *h , size_t size , size_t alignment ) 
{ 
  struct _obstack_chunk *chunk ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int extra ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  struct _obstack_chunk *tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;

  {
#line 114
  if (alignment == 0UL) {
#line 115
    if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
      tmp___1 = __alignof__(uintmax_t );
    } else {
#line 115
      tmp___1 = __alignof__(void *);
    }
#line 115
    if (__alignof__(long double ) > tmp___1) {
#line 115
      alignment = __alignof__(long double );
    } else {
#line 115
      if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
        tmp___0 = __alignof__(uintmax_t );
      } else {
#line 115
        tmp___0 = __alignof__(void *);
      }
#line 115
      alignment = tmp___0;
    }
  }
#line 116
  if (size == 0UL) {
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___5 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___5 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___5) {
#line 127
      tmp___4 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___3 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___3 = sizeof(void *);
      }
#line 127
      tmp___4 = tmp___3;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___9 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___9 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___9) {
#line 127
      tmp___8 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___7 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___7 = sizeof(void *);
      }
#line 127
      tmp___8 = tmp___7;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___13 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___13 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___13) {
#line 127
      tmp___12 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___11 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___11 = sizeof(void *);
      }
#line 127
      tmp___12 = tmp___11;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___17 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___17 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___17) {
#line 127
      tmp___16 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___15 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___15 = sizeof(void *);
      }
#line 127
      tmp___16 = tmp___15;
    }
#line 127
    extra = (int )(((((((12UL + tmp___4) - 1UL) & ~ (tmp___8 - 1UL)) + 4UL) + tmp___12) - 1UL) & ~ (tmp___16 - 1UL));
#line 130
    size = (size_t )(4096 - extra);
  }
  {
#line 133
  h->chunk_size = size;
#line 134
  h->alignment_mask = alignment - 1UL;
#line 136
  tmp___19 = call_chunkfun(h, h->chunk_size);
#line 136
  tmp___18 = (struct _obstack_chunk *)tmp___19;
#line 136
  h->chunk = tmp___18;
#line 136
  chunk = tmp___18;
  }
#line 137
  if (! chunk) {
    {
#line 138
    (*obstack_alloc_failed_handler)();
    }
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___21 = (char *)chunk;
  } else {
#line 139
    tmp___21 = (char *)0;
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___22 = (char *)chunk;
  } else {
#line 139
    tmp___22 = (char *)0;
  }
#line 139
  tmp___20 = tmp___21 + (((size_t )(chunk->contents - tmp___22) + (alignment - 1UL)) & ~ (alignment - 1UL));
#line 139
  h->object_base = tmp___20;
#line 139
  h->next_free = tmp___20;
#line 141
  tmp___23 = (char *)chunk + h->chunk_size;
#line 141
  chunk->limit = tmp___23;
#line 141
  h->chunk_limit = tmp___23;
#line 142
  chunk->prev = (struct _obstack_chunk *)0;
#line 144
  h->maybe_empty_object = 0U;
#line 145
  h->alloc_failed = 0U;
#line 146
  return (1);
}
}
#line 149 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
int _obstack_begin(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(size_t  ) ,
                   void (*freefun)(void * ) ) 
{ 
  int tmp ;

  {
  {
#line 155
  h->chunkfun.plain = chunkfun;
#line 156
  h->freefun.plain = freefun;
#line 157
  h->use_extra_arg = 0U;
#line 158
  tmp = _obstack_begin_worker(h, size, alignment);
  }
#line 158
  return (tmp);
}
}
#line 161 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
int _obstack_begin_1(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(void * ,
                                                                                            size_t  ) ,
                     void (*freefun)(void * , void * ) , void *arg ) 
{ 
  int tmp ;

  {
  {
#line 168
  h->chunkfun.extra = chunkfun;
#line 169
  h->freefun.extra = freefun;
#line 170
  h->extra_arg = arg;
#line 171
  h->use_extra_arg = 1U;
#line 172
  tmp = _obstack_begin_worker(h, size, alignment);
  }
#line 172
  return (tmp);
}
}
#line 181 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
void _obstack_newchunk(struct obstack *h , size_t length ) 
{ 
  struct _obstack_chunk *old_chunk ;
  struct _obstack_chunk *new_chunk ;
  size_t obj_size ;
  char *object_base ;
  size_t sum1 ;
  size_t sum2 ;
  size_t new_size ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 184
  old_chunk = h->chunk;
#line 185
  new_chunk = (struct _obstack_chunk *)0;
#line 186
  obj_size = (size_t )(h->next_free - h->object_base);
#line 190
  sum1 = obj_size + length;
#line 191
  sum2 = sum1 + h->alignment_mask;
#line 192
  new_size = (sum2 + (obj_size >> 3)) + 100UL;
#line 193
  if (new_size < sum2) {
#line 194
    new_size = sum2;
  }
#line 195
  if (new_size < h->chunk_size) {
#line 196
    new_size = h->chunk_size;
  }
#line 199
  if (obj_size <= sum1) {
#line 199
    if (sum1 <= sum2) {
      {
#line 200
      tmp = call_chunkfun(h, new_size);
#line 200
      new_chunk = (struct _obstack_chunk *)tmp;
      }
    }
  }
#line 201
  if (! new_chunk) {
    {
#line 202
    (*obstack_alloc_failed_handler)();
    }
  }
#line 203
  h->chunk = new_chunk;
#line 204
  new_chunk->prev = old_chunk;
#line 205
  tmp___0 = (char *)new_chunk + new_size;
#line 205
  h->chunk_limit = tmp___0;
#line 205
  new_chunk->limit = tmp___0;
#line 208
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 208
    tmp___1 = (char *)new_chunk;
  } else {
#line 208
    tmp___1 = (char *)0;
  }
#line 208
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 208
    tmp___2 = (char *)new_chunk;
  } else {
#line 208
    tmp___2 = (char *)0;
  }
  {
#line 208
  object_base = tmp___1 + (((size_t )(new_chunk->contents - tmp___2) + h->alignment_mask) & ~ h->alignment_mask);
#line 212
  memcpy((void */* __restrict  */)object_base, (void const   */* __restrict  */)h->object_base,
         obj_size);
  }
#line 217
  if (! h->maybe_empty_object) {
#line 217
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
      tmp___3 = (char *)old_chunk;
    } else {
#line 217
      tmp___3 = (char *)0;
    }
#line 217
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
      tmp___4 = (char *)old_chunk;
    } else {
#line 217
      tmp___4 = (char *)0;
    }
#line 217
    if ((unsigned long )h->object_base == (unsigned long )(tmp___3 + (((size_t )(old_chunk->contents - tmp___4) + h->alignment_mask) & ~ h->alignment_mask))) {
      {
#line 222
      new_chunk->prev = old_chunk->prev;
#line 223
      call_freefun(h, (void *)old_chunk);
      }
    }
  }
#line 226
  h->object_base = object_base;
#line 227
  h->next_free = h->object_base + obj_size;
#line 229
  h->maybe_empty_object = 0U;
#line 230
  return;
}
}
#line 238
int _obstack_allocated_p(struct obstack *h , void *obj )  __attribute__((__pure__)) ;
#line 240
int _obstack_allocated_p(struct obstack *h , void *obj )  __attribute__((__pure__)) ;
#line 240 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
int _obstack_allocated_p(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;

  {
#line 246
  lp = h->chunk;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 250
      if (! ((unsigned long )((void *)lp) >= (unsigned long )obj)) {
#line 250
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 250
          goto while_break;
        }
      }
    } else {
#line 250
      goto while_break;
    }
#line 252
    plp = lp->prev;
#line 253
    lp = plp;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0));
}
}
#line 261 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
void _obstack_free(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;
  char *tmp ;

  {
#line 267
  lp = h->chunk;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 271
      if (! ((unsigned long )((void *)lp) >= (unsigned long )obj)) {
#line 271
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 271
          goto while_break;
        }
      }
    } else {
#line 271
      goto while_break;
    }
    {
#line 273
    plp = lp->prev;
#line 274
    call_freefun(h, (void *)lp);
#line 275
    lp = plp;
#line 278
    h->maybe_empty_object = 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if (lp) {
#line 282
    tmp = (char *)obj;
#line 282
    h->next_free = tmp;
#line 282
    h->object_base = tmp;
#line 283
    h->chunk_limit = lp->limit;
#line 284
    h->chunk = lp;
  } else
#line 286
  if ((unsigned long )obj != (unsigned long )((void *)0)) {
    {
#line 288
    abort();
    }
  }
#line 289
  return;
}
}
#line 291
size_t _obstack_memory_used(struct obstack *h )  __attribute__((__pure__)) ;
#line 291 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
size_t _obstack_memory_used(struct obstack *h ) 
{ 
  struct _obstack_chunk *lp ;
  size_t nbytes ;

  {
#line 295
  nbytes = (size_t )0;
#line 297
  lp = h->chunk;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0))) {
#line 297
      goto while_break;
    }
#line 299
    nbytes += (size_t )(lp->limit - (char *)lp);
#line 297
    lp = lp->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return (nbytes);
}
}
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 329 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
static void print_and_abort(void) 
{ 
  char *tmp ;

  {
  {
#line 340
  tmp = gettext("memory exhausted");
#line 340
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          tmp);
#line 342
  exit((int )exit_failure);
  }
}
}
#line 351 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
 __attribute__((__noreturn__)) void (*obstack_alloc_failed_handler)(void)  =    & print_and_abort;
#line 27 "/home/khheo/project/benchmark/grep-3.1/lib/memchr2.h"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n )  __attribute__((__pure__)) ;
#line 35 "/home/khheo/project/benchmark/grep-3.1/lib/memchr2.c"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n )  __attribute__((__pure__)) ;
#line 35 "/home/khheo/project/benchmark/grep-3.1/lib/memchr2.c"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n ) 
{ 
  unsigned char const   *char_ptr ;
  void const   *void_ptr ;
  longword const   *longword_ptr ;
  longword repeated_one ;
  longword repeated_c1 ;
  longword repeated_c2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  void *tmp ;
  size_t i ;
  longword longword1 ;
  longword longword2 ;

  {
#line 54
  c1 = (unsigned char )c1_in;
#line 55
  c2 = (unsigned char )c2_in;
#line 57
  if ((int )c1 == (int )c2) {
    {
#line 58
    tmp = memchr(s, (int )c1, n);
    }
#line 58
    return (tmp);
  }
#line 62
  void_ptr = s;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (n > 0UL) {
#line 62
      if (! ((uintptr_t )void_ptr % sizeof(longword ) != 0UL)) {
#line 62
        goto while_break;
      }
    } else {
#line 62
      goto while_break;
    }
#line 66
    char_ptr = (unsigned char const   *)void_ptr;
#line 67
    if ((int const   )*char_ptr == (int const   )c1) {
#line 68
      return ((void *)void_ptr);
    } else
#line 67
    if ((int const   )*char_ptr == (int const   )c2) {
#line 68
      return ((void *)void_ptr);
    }
#line 69
    void_ptr = (void const   *)(char_ptr + 1);
#line 62
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  longword_ptr = (longword const   *)void_ptr;
#line 81
  repeated_one = (longword )16843009;
#line 82
  repeated_c1 = (longword )((int )c1 | ((int )c1 << 8));
#line 83
  repeated_c2 = (longword )((int )c2 | ((int )c2 << 8));
#line 84
  repeated_c1 |= repeated_c1 << 16;
#line 85
  repeated_c2 |= repeated_c2 << 16;
#line 88
  repeated_one |= (repeated_one << 31) << 1;
#line 89
  repeated_c1 |= (repeated_c1 << 31) << 1;
#line 90
  repeated_c2 |= (repeated_c2 << 31) << 1;
#line 91
  if (8UL < sizeof(longword )) {
#line 95
    i = (size_t )64;
    {
#line 95
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 95
      if (! (i < sizeof(longword ) * 8UL)) {
#line 95
        goto while_break___0;
      }
#line 97
      repeated_one |= repeated_one << i;
#line 98
      repeated_c1 |= repeated_c1 << i;
#line 99
      repeated_c2 |= repeated_c2 << i;
#line 95
      i *= 2UL;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 140
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 140
    if (! (n >= sizeof(longword ))) {
#line 140
      goto while_break___1;
    }
#line 142
    longword1 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c1);
#line 143
    longword2 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c2);
#line 145
    if (((((longword1 - repeated_one) & ~ longword1) | ((longword2 - repeated_one) & ~ longword2)) & (repeated_one << 7)) != 0UL) {
#line 148
      goto while_break___1;
    }
#line 149
    longword_ptr ++;
#line 150
    n -= sizeof(longword );
  }
  while_break___1: /* CIL Label */ ;
  }
#line 153
  char_ptr = (unsigned char const   *)longword_ptr;
  {
#line 162
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 162
    if (! (n > 0UL)) {
#line 162
      goto while_break___2;
    }
#line 164
    if ((int const   )*char_ptr == (int const   )c1) {
#line 165
      return ((void *)char_ptr);
    } else
#line 164
    if ((int const   )*char_ptr == (int const   )c2) {
#line 165
      return ((void *)char_ptr);
    }
#line 162
    n --;
#line 162
    char_ptr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 168
  return ((void *)0);
}
}
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 390 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                                                 size_t __maxlen )  __attribute__((__pure__)) ;
#line 1200 "./string.h"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string )  __attribute__((__pure__)) ;
#line 66 "/home/khheo/project/benchmark/grep-3.1/lib/malloca.h"
void *mmalloca(size_t n ) ;
#line 70
void freea(void *p ) ;
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 34 "/home/khheo/project/benchmark/grep-3.1/lib/str-kmp.h"
static _Bool knuth_morris_pratt(unsigned char const   *haystack , unsigned char const   *needle ,
                                size_t needle_len , unsigned char const   **resultp ) 
{ 
  size_t m ;
  size_t *table ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  unsigned char const   *rhaystack ;
  unsigned char const   *phaystack ;

  {
#line 39
  m = needle_len;
#line 42
  if (9223372036854775807UL / sizeof(size_t ) < m) {
#line 42
    tmp___2 = (void *)0;
  } else {
#line 42
    if (m * sizeof(size_t ) < 4016UL) {
      {
#line 42
      tmp = __builtin_alloca(m * sizeof(size_t ) + 16UL);
#line 42
      tmp___1 = (void *)((char *)tmp + 16);
      }
    } else {
      {
#line 42
      tmp___0 = mmalloca(m * sizeof(size_t ));
#line 42
      tmp___1 = tmp___0;
      }
    }
#line 42
    tmp___2 = tmp___1;
  }
#line 42
  table = (size_t *)tmp___2;
#line 43
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 44
    return ((_Bool)0);
  }
#line 64
  *(table + 1) = (size_t )1;
#line 65
  j = (size_t )0;
#line 67
  i = (size_t )2;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < m)) {
#line 67
      goto while_break;
    }
#line 73
    b = (unsigned char )*(needle + (i - 1UL));
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if ((int )b == (int )*(needle + j)) {
#line 83
        j ++;
#line 83
        *(table + i) = i - j;
#line 84
        goto while_break___0;
      }
#line 89
      if (j == 0UL) {
#line 92
        *(table + i) = i;
#line 93
        goto while_break___0;
      }
#line 106
      j -= *(table + j);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  *resultp = (unsigned char const   *)((void *)0);
#line 119
  j___0 = (size_t )0;
#line 120
  rhaystack = haystack;
#line 121
  phaystack = haystack;
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (! ((int const   )*phaystack != 0)) {
#line 123
      goto while_break___1;
    }
#line 124
    if ((int const   )*(needle + j___0) == (int const   )*phaystack) {
#line 126
      j___0 ++;
#line 127
      phaystack ++;
#line 128
      if (j___0 == m) {
#line 131
        *resultp = rhaystack;
#line 132
        goto while_break___1;
      }
    } else
#line 135
    if (j___0 > 0UL) {
#line 138
      rhaystack += *(table + j___0);
#line 139
      j___0 -= *(table + j___0);
    } else {
#line 144
      rhaystack ++;
#line 145
      phaystack ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 149
  freea((void *)table);
  }
#line 150
  return ((_Bool)1);
}
}
#line 39 "/home/khheo/project/benchmark/grep-3.1/lib/mbsstr.c"
static _Bool knuth_morris_pratt_multibyte(char const   *haystack , char const   *needle ,
                                          char const   **resultp ) 
{ 
  size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table ;
  void *memory ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *table_memory ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___4 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 43
  tmp = mbslen(needle);
#line 43
  m = tmp;
  }
#line 48
  if (9223372036854775807UL / (sizeof(mbchar_t ) + sizeof(size_t )) < m) {
#line 48
    tmp___3 = (void *)0;
  } else {
#line 48
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
      {
#line 48
      tmp___0 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
#line 48
      tmp___2 = (void *)((char *)tmp___0 + 16);
      }
    } else {
      {
#line 48
      tmp___1 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
#line 48
      tmp___2 = tmp___1;
      }
    }
#line 48
    tmp___3 = tmp___2;
  }
#line 48
  memory = tmp___3;
#line 50
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 51
    return ((_Bool)0);
  }
  {
#line 52
  needle_mbchars = (mbchar_t *)memory;
#line 53
  table_memory = (void *)(needle_mbchars + m);
#line 54
  table = (size_t *)table_memory;
#line 61
  j = (size_t )0;
#line 62
  iter.cur.ptr = needle;
#line 62
  iter.in_shift = (_Bool)0;
#line 62
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 62
  iter.next_done = (_Bool)0;
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 62
    mbuiter_multi_next(& iter);
    }
#line 62
    if (iter.cur.wc_valid) {
#line 62
      if (iter.cur.wc == 0) {
#line 62
        tmp___4 = 0;
      } else {
#line 62
        tmp___4 = 1;
      }
    } else {
#line 62
      tmp___4 = 1;
    }
#line 62
    if (! tmp___4) {
#line 62
      goto while_break;
    }
    {
#line 63
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
#line 62
    iter.cur.ptr += iter.cur.bytes;
#line 62
    iter.next_done = (_Bool)0;
#line 62
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  *(table + 1) = (size_t )1;
#line 86
  j___0 = (size_t )0;
#line 88
  i = (size_t )2;
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! (i < m)) {
#line 88
      goto while_break___0;
    }
#line 94
    b = needle_mbchars + (i - 1UL);
    {
#line 96
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 101
      if (b->wc_valid) {
#line 101
        if ((needle_mbchars + j___0)->wc_valid) {
#line 101
          tmp___7 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
#line 101
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 101
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
          {
#line 101
          tmp___5 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
          }
#line 101
          if (tmp___5 == 0) {
#line 101
            tmp___6 = 1;
          } else {
#line 101
            tmp___6 = 0;
          }
        } else {
#line 101
          tmp___6 = 0;
        }
#line 101
        tmp___7 = tmp___6;
      }
#line 101
      if (tmp___7) {
#line 104
        j___0 ++;
#line 104
        *(table + i) = i - j___0;
#line 105
        goto while_break___1;
      }
#line 110
      if (j___0 == 0UL) {
#line 113
        *(table + i) = i;
#line 114
        goto while_break___1;
      }
#line 127
      j___0 -= *(table + j___0);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 88
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  *resultp = (char const   *)((void *)0);
#line 140
  j___1 = (size_t )0;
#line 141
  rhaystack.cur.ptr = haystack;
#line 141
  rhaystack.in_shift = (_Bool)0;
#line 141
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
#line 141
  rhaystack.next_done = (_Bool)0;
#line 142
  phaystack.cur.ptr = haystack;
#line 142
  phaystack.in_shift = (_Bool)0;
#line 142
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
#line 142
  phaystack.next_done = (_Bool)0;
  }
  {
#line 144
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 144
    mbuiter_multi_next(& phaystack);
    }
#line 144
    if (phaystack.cur.wc_valid) {
#line 144
      if (phaystack.cur.wc == 0) {
#line 144
        tmp___13 = 0;
      } else {
#line 144
        tmp___13 = 1;
      }
    } else {
#line 144
      tmp___13 = 1;
    }
#line 144
    if (! tmp___13) {
#line 144
      goto while_break___2;
    }
#line 145
    if ((needle_mbchars + j___1)->wc_valid) {
#line 145
      if (phaystack.cur.wc_valid) {
#line 145
        tmp___12 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
#line 145
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 145
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
        {
#line 145
        tmp___10 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
        }
#line 145
        if (tmp___10 == 0) {
#line 145
          tmp___11 = 1;
        } else {
#line 145
          tmp___11 = 0;
        }
      } else {
#line 145
        tmp___11 = 0;
      }
#line 145
      tmp___12 = tmp___11;
    }
#line 145
    if (tmp___12) {
#line 147
      j___1 ++;
#line 148
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 148
      phaystack.next_done = (_Bool)0;
#line 149
      if (j___1 == m) {
#line 152
        *resultp = rhaystack.cur.ptr;
#line 153
        goto while_break___2;
      }
    } else
#line 156
    if (j___1 > 0UL) {
#line 159
      count = *(table + j___1);
#line 160
      j___1 -= count;
      {
#line 161
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 161
        if (! (count > 0UL)) {
#line 161
          goto while_break___3;
        }
        {
#line 163
        mbuiter_multi_next(& rhaystack);
        }
#line 163
        if (rhaystack.cur.wc_valid) {
#line 163
          if (rhaystack.cur.wc == 0) {
#line 163
            tmp___8 = 0;
          } else {
#line 163
            tmp___8 = 1;
          }
        } else {
#line 163
          tmp___8 = 1;
        }
#line 163
        if (! tmp___8) {
          {
#line 164
          abort();
          }
        }
#line 165
        rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 165
        rhaystack.next_done = (_Bool)0;
#line 161
        count --;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 171
      mbuiter_multi_next(& rhaystack);
      }
#line 171
      if (rhaystack.cur.wc_valid) {
#line 171
        if (rhaystack.cur.wc == 0) {
#line 171
          tmp___9 = 0;
        } else {
#line 171
          tmp___9 = 1;
        }
      } else {
#line 171
        tmp___9 = 1;
      }
#line 171
      if (! tmp___9) {
        {
#line 172
        abort();
        }
      }
#line 173
      rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 173
      rhaystack.next_done = (_Bool)0;
#line 174
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 174
      phaystack.next_done = (_Bool)0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 178
  freea(memory);
  }
#line 179
  return ((_Bool)1);
}
}
#line 184
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle )  __attribute__((__pure__)) ;
#line 184 "/home/khheo/project/benchmark/grep-3.1/lib/mbsstr.c"
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle ) 
{ 
  mbui_iterator_t iter_needle ;
  _Bool try_kmp ;
  size_t outer_loop_count ;
  size_t comparison_count ;
  size_t last_ccount ;
  mbui_iterator_t iter_needle_last_ccount ;
  mbui_iterator_t iter_haystack ;
  int tmp ;
  size_t count ;
  int tmp___0 ;
  char const   *result ;
  _Bool success ;
  _Bool tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t rneedle ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool try_kmp___0 ;
  size_t outer_loop_count___0 ;
  size_t comparison_count___0 ;
  size_t last_ccount___0 ;
  char const   *needle_last_ccount ;
  char b ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  unsigned char const   *result___0 ;
  _Bool success___0 ;
  size_t tmp___15 ;
  _Bool tmp___16 ;
  char const   *rhaystack___0 ;
  char const   *rneedle___0 ;
  size_t tmp___17 ;

  {
  {
#line 192
  tmp___17 = __ctype_get_mb_cur_max();
  }
#line 192
  if (tmp___17 > 1UL) {
    {
#line 196
    iter_needle.cur.ptr = needle;
#line 196
    iter_needle.in_shift = (_Bool)0;
#line 196
    memset((void *)(& iter_needle.state), '\000', sizeof(mbstate_t ));
#line 196
    iter_needle.next_done = (_Bool)0;
#line 197
    mbuiter_multi_next(& iter_needle);
    }
#line 197
    if (iter_needle.cur.wc_valid) {
#line 197
      if (iter_needle.cur.wc == 0) {
#line 197
        tmp___12 = 0;
      } else {
#line 197
        tmp___12 = 1;
      }
    } else {
#line 197
      tmp___12 = 1;
    }
#line 197
    if (tmp___12) {
      {
#line 213
      try_kmp = (_Bool)1;
#line 214
      outer_loop_count = (size_t )0;
#line 215
      comparison_count = (size_t )0;
#line 216
      last_ccount = (size_t )0;
#line 221
      iter_needle_last_ccount.cur.ptr = needle;
#line 221
      iter_needle_last_ccount.in_shift = (_Bool)0;
#line 221
      memset((void *)(& iter_needle_last_ccount.state), '\000', sizeof(mbstate_t ));
#line 221
      iter_needle_last_ccount.next_done = (_Bool)0;
#line 222
      iter_haystack.cur.ptr = haystack;
#line 222
      iter_haystack.in_shift = (_Bool)0;
#line 222
      memset((void *)(& iter_haystack.state), '\000', sizeof(mbstate_t ));
#line 222
      iter_haystack.next_done = (_Bool)0;
      }
      {
#line 223
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 225
        mbuiter_multi_next(& iter_haystack);
        }
#line 225
        if (iter_haystack.cur.wc_valid) {
#line 225
          if (iter_haystack.cur.wc == 0) {
#line 225
            tmp = 0;
          } else {
#line 225
            tmp = 1;
          }
        } else {
#line 225
          tmp = 1;
        }
#line 225
        if (! tmp) {
#line 227
          return ((char *)((void *)0));
        }
#line 231
        if (try_kmp) {
#line 231
          if (outer_loop_count >= 10UL) {
#line 231
            if (comparison_count >= 5UL * outer_loop_count) {
#line 237
              count = comparison_count - last_ccount;
              {
#line 238
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 238
                if (count > 0UL) {
                  {
#line 238
                  mbuiter_multi_next(& iter_needle_last_ccount);
                  }
#line 238
                  if (iter_needle_last_ccount.cur.wc_valid) {
#line 238
                    if (iter_needle_last_ccount.cur.wc == 0) {
#line 238
                      tmp___0 = 0;
                    } else {
#line 238
                      tmp___0 = 1;
                    }
                  } else {
#line 238
                    tmp___0 = 1;
                  }
#line 238
                  if (! tmp___0) {
#line 238
                    goto while_break___0;
                  }
                } else {
#line 238
                  goto while_break___0;
                }
#line 241
                iter_needle_last_ccount.cur.ptr += iter_needle_last_ccount.cur.bytes;
#line 241
                iter_needle_last_ccount.next_done = (_Bool)0;
#line 238
                count --;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 242
              last_ccount = comparison_count;
#line 243
              mbuiter_multi_next(& iter_needle_last_ccount);
              }
#line 243
              if (iter_needle_last_ccount.cur.wc_valid) {
#line 243
                if (iter_needle_last_ccount.cur.wc == 0) {
#line 243
                  tmp___2 = 0;
                } else {
#line 243
                  tmp___2 = 1;
                }
              } else {
#line 243
                tmp___2 = 1;
              }
#line 243
              if (! tmp___2) {
                {
#line 247
                tmp___1 = knuth_morris_pratt_multibyte(haystack, needle, & result);
#line 247
                success = tmp___1;
                }
#line 250
                if (success) {
#line 251
                  return ((char *)result);
                }
#line 252
                try_kmp = (_Bool)0;
              }
            }
          }
        }
#line 256
        outer_loop_count ++;
#line 257
        comparison_count ++;
#line 258
        if (iter_haystack.cur.wc_valid) {
#line 258
          if (iter_needle.cur.wc_valid) {
#line 258
            tmp___11 = iter_haystack.cur.wc == iter_needle.cur.wc;
          } else {
#line 258
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 258
          if (iter_haystack.cur.bytes == iter_needle.cur.bytes) {
            {
#line 258
            tmp___9 = memcmp((void const   *)iter_haystack.cur.ptr, (void const   *)iter_needle.cur.ptr,
                             iter_haystack.cur.bytes);
            }
#line 258
            if (tmp___9 == 0) {
#line 258
              tmp___10 = 1;
            } else {
#line 258
              tmp___10 = 0;
            }
          } else {
#line 258
            tmp___10 = 0;
          }
#line 258
          tmp___11 = tmp___10;
        }
#line 258
        if (tmp___11) {
          {
#line 264
          memcpy((void */* __restrict  */)(& rhaystack), (void const   */* __restrict  */)(& iter_haystack),
                 sizeof(mbui_iterator_t ));
#line 265
          rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 265
          rhaystack.next_done = (_Bool)0;
#line 267
          rneedle.cur.ptr = needle;
#line 267
          rneedle.in_shift = (_Bool)0;
#line 267
          memset((void *)(& rneedle.state), '\000', sizeof(mbstate_t ));
#line 267
          rneedle.next_done = (_Bool)0;
#line 268
          mbuiter_multi_next(& rneedle);
          }
#line 268
          if (rneedle.cur.wc_valid) {
#line 268
            if (rneedle.cur.wc == 0) {
#line 268
              tmp___3 = 0;
            } else {
#line 268
              tmp___3 = 1;
            }
          } else {
#line 268
            tmp___3 = 1;
          }
#line 268
          if (! tmp___3) {
            {
#line 269
            abort();
            }
          }
#line 270
          rneedle.cur.ptr += rneedle.cur.bytes;
#line 270
          rneedle.next_done = (_Bool)0;
          {
#line 272
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 274
            mbuiter_multi_next(& rneedle);
            }
#line 274
            if (rneedle.cur.wc_valid) {
#line 274
              if (rneedle.cur.wc == 0) {
#line 274
                tmp___4 = 0;
              } else {
#line 274
                tmp___4 = 1;
              }
            } else {
#line 274
              tmp___4 = 1;
            }
#line 274
            if (! tmp___4) {
#line 276
              return ((char *)iter_haystack.cur.ptr);
            }
            {
#line 277
            mbuiter_multi_next(& rhaystack);
            }
#line 277
            if (rhaystack.cur.wc_valid) {
#line 277
              if (rhaystack.cur.wc == 0) {
#line 277
                tmp___5 = 0;
              } else {
#line 277
                tmp___5 = 1;
              }
            } else {
#line 277
              tmp___5 = 1;
            }
#line 277
            if (! tmp___5) {
#line 279
              return ((char *)((void *)0));
            }
#line 280
            comparison_count ++;
#line 281
            if (rhaystack.cur.wc_valid) {
#line 281
              if (rneedle.cur.wc_valid) {
#line 281
                tmp___8 = rhaystack.cur.wc == rneedle.cur.wc;
              } else {
#line 281
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 281
              if (rhaystack.cur.bytes == rneedle.cur.bytes) {
                {
#line 281
                tmp___6 = memcmp((void const   *)rhaystack.cur.ptr, (void const   *)rneedle.cur.ptr,
                                 rhaystack.cur.bytes);
                }
#line 281
                if (tmp___6 == 0) {
#line 281
                  tmp___7 = 1;
                } else {
#line 281
                  tmp___7 = 0;
                }
              } else {
#line 281
                tmp___7 = 0;
              }
#line 281
              tmp___8 = tmp___7;
            }
#line 281
            if (! tmp___8) {
#line 283
              goto while_break___1;
            }
#line 272
            rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 272
            rhaystack.next_done = (_Bool)0;
#line 272
            rneedle.cur.ptr += rneedle.cur.bytes;
#line 272
            rneedle.next_done = (_Bool)0;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 223
        iter_haystack.cur.ptr += iter_haystack.cur.bytes;
#line 223
        iter_haystack.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 289
      return ((char *)haystack);
    }
  } else
#line 293
  if ((int const   )*needle != 0) {
#line 309
    try_kmp___0 = (_Bool)1;
#line 310
    outer_loop_count___0 = (size_t )0;
#line 311
    comparison_count___0 = (size_t )0;
#line 312
    last_ccount___0 = (size_t )0;
#line 313
    needle_last_ccount = needle;
#line 317
    tmp___13 = needle;
#line 317
    needle ++;
#line 317
    b = (char )*tmp___13;
    {
#line 319
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 321
      if ((int const   )*haystack == 0) {
#line 323
        return ((char *)((void *)0));
      }
#line 327
      if (try_kmp___0) {
#line 327
        if (outer_loop_count___0 >= 10UL) {
#line 327
          if (comparison_count___0 >= 5UL * outer_loop_count___0) {
#line 333
            if ((unsigned long )needle_last_ccount != (unsigned long )((void *)0)) {
              {
#line 335
              tmp___14 = strnlen(needle_last_ccount, comparison_count___0 - last_ccount___0);
#line 335
              needle_last_ccount += tmp___14;
              }
#line 338
              if ((int const   )*needle_last_ccount == 0) {
#line 339
                needle_last_ccount = (char const   *)((void *)0);
              }
#line 340
              last_ccount___0 = comparison_count___0;
            }
#line 342
            if ((unsigned long )needle_last_ccount == (unsigned long )((void *)0)) {
              {
#line 346
              tmp___15 = strlen(needle - 1);
#line 346
              tmp___16 = knuth_morris_pratt((unsigned char const   *)haystack, (unsigned char const   *)(needle - 1),
                                            tmp___15, & result___0);
#line 346
              success___0 = tmp___16;
              }
#line 351
              if (success___0) {
#line 352
                return ((char *)result___0);
              }
#line 353
              try_kmp___0 = (_Bool)0;
            }
          }
        }
      }
#line 357
      outer_loop_count___0 ++;
#line 358
      comparison_count___0 ++;
#line 359
      if ((int const   )*haystack == (int const   )b) {
#line 362
        rhaystack___0 = haystack + 1;
#line 363
        rneedle___0 = needle;
        {
#line 365
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 367
          if ((int const   )*rneedle___0 == 0) {
#line 369
            return ((char *)haystack);
          }
#line 370
          if ((int const   )*rhaystack___0 == 0) {
#line 372
            return ((char *)((void *)0));
          }
#line 373
          comparison_count___0 ++;
#line 374
          if ((int const   )*rhaystack___0 != (int const   )*rneedle___0) {
#line 376
            goto while_break___3;
          }
#line 365
          rhaystack___0 ++;
#line 365
          rneedle___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 319
      haystack ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 382
    return ((char *)haystack);
  }
}
}
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-3.1/lib/mbslen.c"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string )  __attribute__((__pure__)) ;
#line 28 "/home/khheo/project/benchmark/grep-3.1/lib/mbslen.c"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string ) 
{ 
  size_t count ;
  mbui_iterator_t iter ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 31
  tmp___1 = __ctype_get_mb_cur_max();
  }
#line 31
  if (tmp___1 > 1UL) {
    {
#line 36
    count = (size_t )0;
#line 37
    iter.cur.ptr = string;
#line 37
    iter.in_shift = (_Bool)0;
#line 37
    memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 37
    iter.next_done = (_Bool)0;
    }
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 37
      mbuiter_multi_next(& iter);
      }
#line 37
      if (iter.cur.wc_valid) {
#line 37
        if (iter.cur.wc == 0) {
#line 37
          tmp = 0;
        } else {
#line 37
          tmp = 1;
        }
      } else {
#line 37
        tmp = 1;
      }
#line 37
      if (! tmp) {
#line 37
        goto while_break;
      }
#line 38
      count ++;
#line 37
      iter.cur.ptr += iter.cur.bytes;
#line 37
      iter.next_done = (_Bool)0;
    }
    while_break: /* CIL Label */ ;
    }
#line 40
    return (count);
  } else {
    {
#line 43
    tmp___0 = strlen(string);
    }
#line 43
    return (tmp___0);
  }
}
}
#line 1277 "./string.h"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 166 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towlower)(wint_t __wc ) ;
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-3.1/lib/mbscasecmp.c"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/grep-3.1/lib/mbscasecmp.c"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 ) 
{ 
  mbui_iterator_t iter1 ;
  mbui_iterator_t iter2 ;
  int cmp ;
  wint_t tmp ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  size_t tmp___25 ;

  {
#line 39
  if ((unsigned long )s1 == (unsigned long )s2) {
#line 40
    return (0);
  }
  {
#line 45
  tmp___25 = __ctype_get_mb_cur_max();
  }
#line 45
  if (tmp___25 > 1UL) {
    {
#line 50
    iter1.cur.ptr = s1;
#line 50
    iter1.in_shift = (_Bool)0;
#line 50
    memset((void *)(& iter1.state), '\000', sizeof(mbstate_t ));
#line 50
    iter1.next_done = (_Bool)0;
#line 51
    iter2.cur.ptr = s2;
#line 51
    iter2.in_shift = (_Bool)0;
#line 51
    memset((void *)(& iter2.state), '\000', sizeof(mbstate_t ));
#line 51
    iter2.next_done = (_Bool)0;
    }
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 53
      mbuiter_multi_next(& iter1);
      }
#line 53
      if (iter1.cur.wc_valid) {
#line 53
        if (iter1.cur.wc == 0) {
#line 53
          tmp___13 = 0;
        } else {
#line 53
          tmp___13 = 1;
        }
      } else {
#line 53
        tmp___13 = 1;
      }
#line 53
      if (tmp___13) {
        {
#line 53
        mbuiter_multi_next(& iter2);
        }
#line 53
        if (iter2.cur.wc_valid) {
#line 53
          if (iter2.cur.wc == 0) {
#line 53
            tmp___14 = 0;
          } else {
#line 53
            tmp___14 = 1;
          }
        } else {
#line 53
          tmp___14 = 1;
        }
#line 53
        if (! tmp___14) {
#line 53
          goto while_break;
        }
      } else {
#line 53
        goto while_break;
      }
#line 55
      if (iter1.cur.wc_valid) {
#line 55
        if (iter2.cur.wc_valid) {
          {
#line 55
          tmp = towlower((wint_t )iter1.cur.wc);
#line 55
          tmp___0 = towlower((wint_t )iter2.cur.wc);
#line 55
          tmp___1 = (int )tmp - (int )tmp___0;
          }
        } else {
#line 55
          tmp___1 = -1;
        }
#line 55
        tmp___12 = tmp___1;
      } else {
#line 55
        if (iter2.cur.wc_valid) {
#line 55
          tmp___11 = 1;
        } else {
#line 55
          if (iter1.cur.bytes == iter2.cur.bytes) {
            {
#line 55
            tmp___2 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                             iter1.cur.bytes);
#line 55
            tmp___10 = tmp___2;
            }
          } else {
#line 55
            if (iter1.cur.bytes < iter2.cur.bytes) {
              {
#line 55
              tmp___5 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter1.cur.bytes);
              }
#line 55
              if (tmp___5 > 0) {
#line 55
                tmp___4 = 1;
              } else {
#line 55
                tmp___4 = -1;
              }
#line 55
              tmp___9 = tmp___4;
            } else {
              {
#line 55
              tmp___8 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter2.cur.bytes);
              }
#line 55
              if (tmp___8 >= 0) {
#line 55
                tmp___7 = 1;
              } else {
#line 55
                tmp___7 = -1;
              }
#line 55
              tmp___9 = tmp___7;
            }
#line 55
            tmp___10 = tmp___9;
          }
#line 55
          tmp___11 = tmp___10;
        }
#line 55
        tmp___12 = tmp___11;
      }
#line 55
      cmp = tmp___12;
#line 57
      if (cmp != 0) {
#line 58
        return (cmp);
      }
#line 60
      iter1.cur.ptr += iter1.cur.bytes;
#line 60
      iter1.next_done = (_Bool)0;
#line 61
      iter2.cur.ptr += iter2.cur.bytes;
#line 61
      iter2.next_done = (_Bool)0;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 63
    mbuiter_multi_next(& iter1);
    }
#line 63
    if (iter1.cur.wc_valid) {
#line 63
      if (iter1.cur.wc == 0) {
#line 63
        tmp___15 = 0;
      } else {
#line 63
        tmp___15 = 1;
      }
    } else {
#line 63
      tmp___15 = 1;
    }
#line 63
    if (tmp___15) {
#line 65
      return (1);
    }
    {
#line 66
    mbuiter_multi_next(& iter2);
    }
#line 66
    if (iter2.cur.wc_valid) {
#line 66
      if (iter2.cur.wc == 0) {
#line 66
        tmp___16 = 0;
      } else {
#line 66
        tmp___16 = 1;
      }
    } else {
#line 66
      tmp___16 = 1;
    }
#line 66
    if (tmp___16) {
#line 68
      return (-1);
    }
#line 69
    return (0);
  } else {
#line 73
    p1 = (unsigned char const   *)s1;
#line 74
    p2 = (unsigned char const   *)s2;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 79
      tmp___19 = __ctype_b_loc();
      }
#line 79
      if ((int const   )*(*tmp___19 + (int )*p1) & 256) {
        {
#line 79
        tmp___18 = tolower((int )*p1);
#line 79
        c1 = (unsigned char )tmp___18;
        }
      } else {
#line 79
        c1 = (unsigned char )*p1;
      }
      {
#line 80
      tmp___22 = __ctype_b_loc();
      }
#line 80
      if ((int const   )*(*tmp___22 + (int )*p2) & 256) {
        {
#line 80
        tmp___21 = tolower((int )*p2);
#line 80
        c2 = (unsigned char )tmp___21;
        }
      } else {
#line 80
        c2 = (unsigned char )*p2;
      }
#line 82
      if ((int )c1 == 0) {
#line 83
        goto while_break___0;
      }
#line 85
      p1 ++;
#line 86
      p2 ++;
#line 77
      if (! ((int )c1 == (int )c2)) {
#line 77
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 91
    return ((int )c1 - (int )c2);
  }
}
}
#line 296 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrtowc)(wchar_t * __restrict  __pwc ,
                                                                                 char const   * __restrict  __s ,
                                                                                 size_t __n ,
                                                                                 mbstate_t * __restrict  __p ) ;
#line 23 "/home/khheo/project/benchmark/grep-3.1/lib/hard-locale.h"
_Bool hard_locale(int category ) ;
#line 340 "/home/khheo/project/benchmark/grep-3.1/lib/mbrtowc.c"
size_t rpl_mbrtowc(wchar_t *pwc , char const   *s , size_t n , mbstate_t *ps ) 
{ 
  size_t ret ;
  wchar_t wc ;
  unsigned char uc ;
  _Bool tmp ;

  {
#line 360
  if (! pwc) {
#line 361
    pwc = & wc;
  }
  {
#line 395
  ret = mbrtowc((wchar_t */* __restrict  */)pwc, (char const   */* __restrict  */)s,
                n, (mbstate_t */* __restrict  */)ps);
  }
#line 403
  if (0xfffffffffffffffeUL <= ret) {
#line 403
    if (n != 0UL) {
      {
#line 403
      tmp = hard_locale(0);
      }
#line 403
      if (! tmp) {
#line 405
        uc = (unsigned char )*s;
#line 406
        *pwc = (wchar_t )uc;
#line 407
        return ((size_t )1);
      }
    }
  }
#line 411
  return (ret);
}
}
#line 715 "./wchar.h"
size_t rpl_mbrlen(char const   *s , size_t n , mbstate_t *ps ) ;
#line 24 "/home/khheo/project/benchmark/grep-3.1/lib/mbrlen.c"
static mbstate_t internal_state  ;
#line 26 "/home/khheo/project/benchmark/grep-3.1/lib/mbrlen.c"
size_t rpl_mbrlen(char const   *s , size_t n , mbstate_t *ps ) 
{ 
  size_t tmp ;

  {
#line 29
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
#line 30
    ps = & internal_state;
  }
  {
#line 31
  tmp = rpl_mbrtowc((wchar_t *)((void *)0), s, n, ps);
  }
#line 31
  return (tmp);
}
}
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-3.1/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 223
#pragma GCC diagnostic pop
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.c"
unsigned int const   is_basic_table[8]  = {      (unsigned int const   )6656,      (unsigned int const   )4294967279U,      (unsigned int const   )4294967294U,      (unsigned int const   )2147483646};
#line 69 "/home/khheo/project/benchmark/grep-3.1/lib/malloca.c"
static void *mmalloca_results[257]  ;
#line 73 "/home/khheo/project/benchmark/grep-3.1/lib/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  void *p ;
  void *tmp ;
  size_t slot ;
  union header *h ;

  {
#line 79
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 81
  if (nplus >= n) {
    {
#line 83
    tmp = malloc(nplus);
#line 83
    p = tmp;
    }
#line 85
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 88
      h = (union header *)p;
#line 90
      p = (void *)(h + 1);
#line 93
      h->magic.word = 336984906;
#line 96
      slot = (uintptr_t )p % 257UL;
#line 97
      h->next = mmalloca_results[slot];
#line 98
      mmalloca_results[slot] = p;
#line 100
      return (p);
    }
  }
#line 104
  return ((void *)0);
}
}
#line 115 "/home/khheo/project/benchmark/grep-3.1/lib/malloca.c"
void freea(void *p ) 
{ 
  size_t slot ;
  void **chain ;
  union header *h ;
  union header *p_begin ;

  {
#line 119
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 125
    if (*((int *)p + -1) == 336984906) {
#line 129
      slot = (uintptr_t )p % 257UL;
#line 130
      chain = & mmalloca_results[slot];
      {
#line 131
      while (1) {
        while_continue: /* CIL Label */ ;
#line 131
        if (! ((unsigned long )*chain != (unsigned long )((void *)0))) {
#line 131
          goto while_break;
        }
#line 133
        h = (union header *)p;
#line 134
        if ((unsigned long )*chain == (unsigned long )p) {
          {
#line 137
          p_begin = h - 1;
#line 138
          *chain = p_begin->next;
#line 139
          free((void *)p_begin);
          }
#line 140
          return;
        }
#line 142
        h = (union header *)*chain;
#line 143
        chain = & (h + -1)->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 148
  return;
}
}
#line 750 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 807
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_init)(pthread_mutexattr_t *__attr ) ;
#line 811
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr ) ;
#line 834
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_settype)(pthread_mutexattr_t *__attr ,
                                                                                                                int __kind ) ;
#line 889
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_init)(pthread_rwlock_t * __restrict  __rwlock ,
                                                                                                          pthread_rwlockattr_t const   * __restrict  __attr ) ;
#line 935
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_init)(pthread_rwlockattr_t *__attr ) ;
#line 939
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_destroy)(pthread_rwlockattr_t *__attr ) ;
#line 960
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_setkind_np)(pthread_rwlockattr_t *__attr ,
                                                                                                                    int __pref ) ;
#line 124 "./glthread/lock.h"
#pragma weak pthread_mutex_init
#line 125
#pragma weak pthread_mutex_lock
#line 126
#pragma weak pthread_mutex_unlock
#line 127
#pragma weak pthread_mutex_destroy
#line 128
#pragma weak pthread_rwlock_init
#line 129
#pragma weak pthread_rwlock_rdlock
#line 130
#pragma weak pthread_rwlock_wrlock
#line 131
#pragma weak pthread_rwlock_unlock
#line 132
#pragma weak pthread_rwlock_destroy
#line 133
#pragma weak pthread_once
#line 134
#pragma weak pthread_cond_init
#line 135
#pragma weak pthread_cond_wait
#line 136
#pragma weak pthread_cond_signal
#line 137
#pragma weak pthread_cond_broadcast
#line 138
#pragma weak pthread_cond_destroy
#line 139
#pragma weak pthread_mutexattr_init
#line 140
#pragma weak pthread_mutexattr_settype
#line 141
#pragma weak pthread_mutexattr_destroy
#line 142
#pragma weak pthread_rwlockattr_init
#line 144
#pragma weak pthread_rwlockattr_setkind_np
#line 146
#pragma weak pthread_rwlockattr_destroy
#line 148
#pragma weak pthread_self
#line 152
#pragma weak pthread_cancel
#line 203
int glthread_rwlock_init_for_glibc(pthread_rwlock_t *lock ) ;
#line 308
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) ;
#line 382
int glthread_once_singlethreaded(pthread_once_t *once_control ) ;
#line 40 "/home/khheo/project/benchmark/grep-3.1/lib/glthread/lock.c"
int glthread_rwlock_init_for_glibc(pthread_rwlock_t *lock ) 
{ 
  pthread_rwlockattr_t attributes ;
  int err ;

  {
  {
#line 46
  err = pthread_rwlockattr_init(& attributes);
  }
#line 47
  if (err != 0) {
#line 48
    return (err);
  }
  {
#line 53
  err = pthread_rwlockattr_setkind_np(& attributes, 2);
  }
#line 55
  if (err == 0) {
    {
#line 56
    err = pthread_rwlock_init((pthread_rwlock_t */* __restrict  */)lock, (pthread_rwlockattr_t const   */* __restrict  */)(& attributes));
    }
  }
  {
#line 59
  pthread_rwlockattr_destroy(& attributes);
  }
#line 60
  return (err);
}
}
#line 310 "/home/khheo/project/benchmark/grep-3.1/lib/glthread/lock.c"
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) 
{ 
  pthread_mutexattr_t attributes ;
  int err ;

  {
  {
#line 316
  err = pthread_mutexattr_init(& attributes);
  }
#line 317
  if (err != 0) {
#line 318
    return (err);
  }
  {
#line 319
  err = pthread_mutexattr_settype(& attributes, 1);
  }
#line 320
  if (err != 0) {
    {
#line 322
    pthread_mutexattr_destroy(& attributes);
    }
#line 323
    return (err);
  }
  {
#line 325
  err = pthread_mutex_init(lock, (pthread_mutexattr_t const   *)(& attributes));
  }
#line 326
  if (err != 0) {
    {
#line 328
    pthread_mutexattr_destroy(& attributes);
    }
#line 329
    return (err);
  }
  {
#line 331
  err = pthread_mutexattr_destroy(& attributes);
  }
#line 332
  if (err != 0) {
#line 333
    return (err);
  }
#line 334
  return (0);
}
}
#line 481 "/home/khheo/project/benchmark/grep-3.1/lib/glthread/lock.c"
static int const   fresh_once  =    (pthread_once_t const   )0;
#line 483 "/home/khheo/project/benchmark/grep-3.1/lib/glthread/lock.c"
int glthread_once_singlethreaded(pthread_once_t *once_control ) 
{ 
  char *firstbyte ;

  {
#line 488
  firstbyte = (char *)once_control;
#line 489
  if ((int )*firstbyte == (int )*((char const   *)(& fresh_once))) {
#line 492
    *firstbyte = (char )(~ ((int const   )*((char const   *)(& fresh_once))));
#line 493
    return (1);
  } else {
#line 496
    return (0);
  }
}
}
#line 47 "./localeinfo.h"
void init_localeinfo(struct localeinfo *localeinfo___0 ) ;
#line 54
int case_folded_counterparts(wint_t c , wchar_t *folded ) ;
#line 169 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towupper)(wint_t __wc ) ;
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 39 "/home/khheo/project/benchmark/grep-3.1/lib/localeinfo.c"
static _Bool is_using_utf8(void) 
{ 
  wchar_t wc ;
  mbstate_t mbs ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 43
  mbs.__count = 0;
#line 43
  mbs.__value.__wch = 0U;
#line 44
  tmp = rpl_mbrtowc(& wc, "\304\200", (size_t )2, & mbs);
  }
#line 44
  if (tmp == 2UL) {
#line 44
    if (wc == 256) {
#line 44
      tmp___0 = 1;
    } else {
#line 44
      tmp___0 = 0;
    }
  } else {
#line 44
    tmp___0 = 0;
  }
#line 44
  return ((_Bool )tmp___0);
}
}
#line 49 "/home/khheo/project/benchmark/grep-3.1/lib/localeinfo.c"
void init_localeinfo(struct localeinfo *localeinfo___0 ) 
{ 
  int i ;
  size_t tmp ;
  char c ;
  unsigned char uc ;
  mbstate_t s ;
  wchar_t wc ;
  size_t len ;
  size_t tmp___0 ;

  {
  {
#line 54
  tmp = __ctype_get_mb_cur_max();
#line 54
  localeinfo___0->multibyte = (_Bool )(tmp > 1UL);
#line 55
  localeinfo___0->using_utf8 = is_using_utf8();
#line 57
  i = -128;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i <= 127)) {
#line 57
      goto while_break;
    }
    {
#line 59
    c = (char )i;
#line 60
    uc = (unsigned char )i;
#line 61
    s.__count = 0;
#line 61
    s.__value.__wch = 0U;
#line 63
    tmp___0 = rpl_mbrtowc(& wc, (char const   *)(& c), (size_t )1, & s);
#line 63
    len = tmp___0;
    }
#line 64
    if (len <= 1UL) {
#line 64
      localeinfo___0->sbclen[uc] = (signed char)1;
    } else {
#line 64
      localeinfo___0->sbclen[uc] = (signed char )(- ((int )(- len)));
    }
#line 65
    if (len <= 1UL) {
#line 65
      localeinfo___0->sbctowc[uc] = (wint_t )wc;
    } else {
#line 65
      localeinfo___0->sbctowc[uc] = 4294967295U;
    }
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return;
}
}
#line 74 "/home/khheo/project/benchmark/grep-3.1/lib/localeinfo.c"
static short const   lonesome_lower[19]  = 
#line 74
  {      (short const   )181,      (short const   )305,      (short const   )383,      (short const   )453, 
        (short const   )456,      (short const   )459,      (short const   )498,      (short const   )837, 
        (short const   )962,      (short const   )976,      (short const   )977,      (short const   )981, 
        (short const   )982,      (short const   )1008,      (short const   )1009,      (short const   )1010, 
        (short const   )1013,      (short const   )7835,      (short const   )8126};
#line 95 "/home/khheo/project/benchmark/grep-3.1/lib/localeinfo.c"
int case_folded_counterparts(wint_t c , wchar_t *folded ) 
{ 
  int i ;
  int n ;
  wint_t uc ;
  wint_t tmp ;
  wint_t lc ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  wint_t tmp___3 ;
  wint_t li ;
  int tmp___4 ;
  wint_t tmp___5 ;

  {
  {
#line 99
  n = 0;
#line 100
  tmp = towupper(c);
#line 100
  uc = tmp;
#line 101
  tmp___0 = towlower(uc);
#line 101
  lc = tmp___0;
  }
#line 102
  if (uc != c) {
#line 103
    tmp___1 = n;
#line 103
    n ++;
#line 103
    *(folded + tmp___1) = (wchar_t )uc;
  }
#line 104
  if (lc != uc) {
#line 104
    if (lc != c) {
      {
#line 104
      tmp___3 = towupper(lc);
      }
#line 104
      if (tmp___3 == uc) {
#line 105
        tmp___2 = n;
#line 105
        n ++;
#line 105
        *(folded + tmp___2) = (wchar_t )lc;
      }
    }
  }
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! ((unsigned long )i < sizeof(lonesome_lower) / sizeof(lonesome_lower[0]))) {
#line 106
      goto while_break;
    }
#line 108
    li = (wint_t )lonesome_lower[i];
#line 109
    if (li != lc) {
#line 109
      if (li != uc) {
#line 109
        if (li != c) {
          {
#line 109
          tmp___5 = towupper(li);
          }
#line 109
          if (tmp___5 == uc) {
#line 110
            tmp___4 = n;
#line 110
            n ++;
#line 110
            *(folded + tmp___4) = (wchar_t )li;
          }
        }
      }
    }
#line 106
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (n);
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 377
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 495
extern int getc_unlocked(FILE *__stream ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 661 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 121 "/home/khheo/project/benchmark/grep-3.1/lib/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 124 "/home/khheo/project/benchmark/grep-3.1/lib/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char *malloc_dir ;
  char const   *dir ;
  char const   *base ;
  char *file_name___1 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 129
  cp = (char const   *)charset_aliases;
#line 130
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 133
    malloc_dir = (char *)((void *)0);
#line 135
    base = "charset.alias";
#line 140
    tmp = getenv("CHARSETALIASDIR");
#line 140
    dir = (char const   *)tmp;
    }
#line 141
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 142
      malloc_dir = (char *)((void *)0);
#line 142
      dir = "/usr/local/lib";
    } else
#line 141
    if ((int const   )*(dir + 0) == 0) {
#line 142
      malloc_dir = (char *)((void *)0);
#line 142
      dir = "/usr/local/lib";
    }
    {
#line 146
    tmp___0 = strlen(dir);
#line 146
    dir_len___0 = tmp___0;
#line 147
    tmp___1 = strlen(base);
#line 147
    base_len___0 = tmp___1;
    }
#line 148
    if (dir_len___0 > 0UL) {
#line 148
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 148
        tmp___2 = 1;
      } else {
#line 148
        tmp___2 = 0;
      }
    } else {
#line 148
      tmp___2 = 0;
    }
    {
#line 148
    add_slash = tmp___2;
#line 149
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 149
    file_name___1 = (char *)tmp___3;
    }
#line 150
    if ((unsigned long )file_name___1 != (unsigned long )((void *)0)) {
      {
#line 152
      memcpy((void */* __restrict  */)file_name___1, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 153
      if (add_slash) {
#line 154
        *(file_name___1 + dir_len___0) = (char )'/';
      }
      {
#line 155
      memcpy((void */* __restrict  */)((file_name___1 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
    {
#line 159
    free((void *)malloc_dir);
    }
#line 161
    if ((unsigned long )file_name___1 == (unsigned long )((void *)0)) {
#line 163
      cp = "";
    } else {
      {
#line 175
      fd = open((char const   *)file_name___1, 131072);
      }
#line 177
      if (fd < 0) {
#line 179
        cp = "";
      } else {
        {
#line 184
        fp = fdopen(fd, "r");
        }
#line 185
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 188
          close(fd);
#line 189
          cp = "";
          }
        } else {
#line 194
          res_ptr = (char *)((void *)0);
#line 195
          res_size = (size_t )0;
          {
#line 197
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 205
            c = getc_unlocked(fp);
            }
#line 206
            if (c == -1) {
#line 207
              goto while_break;
            }
#line 208
            if (c == 10) {
#line 209
              goto __Cont;
            } else
#line 208
            if (c == 32) {
#line 209
              goto __Cont;
            } else
#line 208
            if (c == 9) {
#line 209
              goto __Cont;
            }
#line 210
            if (c == 35) {
              {
#line 213
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 214
                c = getc_unlocked(fp);
                }
#line 213
                if (c == -1) {
#line 213
                  goto while_break___0;
                } else
#line 213
                if (c == 10) {
#line 213
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 216
              if (c == -1) {
#line 217
                goto while_break;
              }
#line 218
              goto __Cont;
            }
            {
#line 220
            ungetc(c, fp);
#line 221
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 221
            if (tmp___4 < 2) {
#line 222
              goto while_break;
            }
            {
#line 223
            l1 = strlen((char const   *)(buf1));
#line 224
            l2 = strlen((char const   *)(buf2));
#line 225
            old_res_ptr = res_ptr;
            }
#line 226
            if (res_size == 0UL) {
              {
#line 228
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 229
              tmp___5 = malloc(res_size + 1UL);
#line 229
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 233
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 234
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 234
              res_ptr = (char *)tmp___6;
              }
            }
#line 236
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 239
              res_size = (size_t )0;
#line 240
              free((void *)old_res_ptr);
              }
#line 241
              goto while_break;
            }
            {
#line 243
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1));
#line 244
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 246
          fclose(fp);
          }
#line 247
          if (res_size == 0UL) {
#line 248
            cp = "";
          } else {
#line 251
            *(res_ptr + res_size) = (char )'\000';
#line 252
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 257
      free((void *)file_name___1);
      }
    }
#line 381
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 384
  return (cp);
}
}
#line 396 "/home/khheo/project/benchmark/grep-3.1/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 407
  tmp = nl_langinfo(14);
#line 407
  codeset = (char const   *)tmp;
  }
#line 588
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 590
    codeset = "";
  }
  {
#line 593
  aliases = get_charset_aliases();
  }
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 593
    if (! ((int const   )*aliases != 0)) {
#line 593
      goto while_break;
    }
    {
#line 596
    tmp___3 = strcmp(codeset, aliases);
    }
#line 596
    if (tmp___3 == 0) {
      {
#line 599
      tmp___2 = strlen(aliases);
#line 599
      codeset = (aliases + tmp___2) + 1;
      }
#line 600
      goto while_break;
    } else
#line 596
    if ((int const   )*(aliases + 0) == 42) {
#line 596
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 599
        tmp___2 = strlen(aliases);
#line 599
        codeset = (aliases + tmp___2) + 1;
        }
#line 600
        goto while_break;
      }
    }
    {
#line 593
    tmp___0 = strlen(aliases);
#line 593
    aliases += tmp___0 + 1UL;
#line 593
    tmp___1 = strlen(aliases);
#line 593
    aliases += tmp___1 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 606
  if ((int const   )*(codeset + 0) == 0) {
#line 607
    codeset = "ASCII";
  }
#line 616
  return (codeset);
}
}
#line 41 "/home/khheo/project/benchmark/grep-3.1/lib/i-ring.h"
void i_ring_init(I_ring *ir , int default_val ) ;
#line 42
int i_ring_push(I_ring *ir , int val ) ;
#line 43
int i_ring_pop(I_ring *ir ) ;
#line 44
_Bool i_ring_empty(I_ring const   *ir )  __attribute__((__pure__)) ;
#line 24 "/home/khheo/project/benchmark/grep-3.1/lib/i-ring.c"
void i_ring_init(I_ring *ir , int default_val ) 
{ 
  int i ;

  {
#line 28
  ir->ir_empty = (_Bool)1;
#line 29
  ir->ir_front = 0U;
#line 30
  ir->ir_back = 0U;
#line 31
  i = 0;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i < 4)) {
#line 31
      goto while_break;
    }
#line 32
    ir->ir_data[i] = default_val;
#line 31
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 33
  ir->ir_default_val = default_val;
#line 34
  return;
}
}
#line 36
_Bool i_ring_empty(I_ring const   *ir )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/grep-3.1/lib/i-ring.c"
_Bool i_ring_empty(I_ring const   *ir ) 
{ 


  {
#line 39
  return ((_Bool )ir->ir_empty);
}
}
#line 42 "/home/khheo/project/benchmark/grep-3.1/lib/i-ring.c"
int i_ring_push(I_ring *ir , int val ) 
{ 
  unsigned int dest_idx ;
  int old_val ;

  {
#line 45
  dest_idx = (ir->ir_front + (unsigned int )(! ir->ir_empty)) % 4U;
#line 46
  old_val = ir->ir_data[dest_idx];
#line 47
  ir->ir_data[dest_idx] = val;
#line 48
  ir->ir_front = dest_idx;
#line 49
  if (dest_idx == ir->ir_back) {
#line 50
    ir->ir_back = (ir->ir_back + (unsigned int )(! ir->ir_empty)) % 4U;
  }
#line 51
  ir->ir_empty = (_Bool)0;
#line 52
  return (old_val);
}
}
#line 55 "/home/khheo/project/benchmark/grep-3.1/lib/i-ring.c"
int i_ring_pop(I_ring *ir ) 
{ 
  int top_val ;
  _Bool tmp ;

  {
  {
#line 59
  tmp = i_ring_empty((I_ring const   *)ir);
  }
#line 59
  if (tmp) {
    {
#line 60
    abort();
    }
  }
#line 61
  top_val = ir->ir_data[ir->ir_front];
#line 62
  ir->ir_data[ir->ir_front] = ir->ir_default_val;
#line 63
  if (ir->ir_front == ir->ir_back) {
#line 64
    ir->ir_empty = (_Bool)1;
  } else {
#line 66
    ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
  }
#line 67
  return (top_val);
}
}
#line 72 "/home/khheo/project/benchmark/grep-3.1/lib/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 73
size_t hash_get_n_buckets_used(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 74
size_t hash_get_n_entries(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 75
size_t hash_get_max_bucket_length(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 76
_Bool hash_table_ok(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 77
void hash_print_statistics(Hash_table const   *table , FILE *stream ) ;
#line 78
void *hash_lookup(Hash_table const   *table , void const   *entry ) ;
#line 81
void *hash_get_first(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 82
void *hash_get_next(Hash_table const   *table , void const   *entry ) ;
#line 83
size_t hash_get_entries(Hash_table const   *table , void **buffer___0 , size_t buffer_size ) ;
#line 84
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) ;
#line 87
size_t hash_string(char const   *string , size_t n_buckets )  __attribute__((__pure__)) ;
#line 88
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 89
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) ;
#line 92
void hash_clear(Hash_table *table ) ;
#line 93
void hash_free(Hash_table *table ) ;
#line 96
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) ;
#line 97
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) ;
#line 99
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent ) ;
#line 101
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 38 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
__inline uint64_t rotl64(uint64_t x , int n ) 
{ 


  {
#line 41
  return (((x << n) | (x >> (64 - n))) & 0xffffffffffffffffUL);
}
}
#line 47 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
__inline uint64_t rotr64(uint64_t x , int n ) 
{ 


  {
#line 50
  return (((x >> n) | (x << (64 - n))) & 0xffffffffffffffffUL);
}
}
#line 57 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
__inline uint32_t rotl32(uint32_t x , int n ) 
{ 


  {
#line 60
  return (((x << n) | (x >> (32 - n))) & 4294967295U);
}
}
#line 66 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
__inline uint32_t rotr32(uint32_t x , int n ) 
{ 


  {
#line 69
  return (((x >> n) | (x << (32 - n))) & 4294967295U);
}
}
#line 75 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
__inline size_t rotl_sz(size_t x , int n ) 
{ 


  {
#line 78
  return (((x << n) | (x >> (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 84 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
__inline size_t rotr_sz(size_t x , int n ) 
{ 


  {
#line 87
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 95 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
__inline uint16_t rotl16(uint16_t x , int n ) 
{ 


  {
#line 98
  return ((uint16_t )((((int )x << n) | ((int )x >> (16 - n))) & 65535));
}
}
#line 106 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
__inline uint16_t rotr16(uint16_t x , int n ) 
{ 


  {
#line 109
  return ((uint16_t )((((int )x >> n) | ((int )x << (16 - n))) & 65535));
}
}
#line 117 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
__inline uint8_t rotl8(uint8_t x , int n ) 
{ 


  {
#line 120
  return ((uint8_t )((((int )x << n) | ((int )x >> (8 - n))) & 255));
}
}
#line 128 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
__inline uint8_t rotr8(uint8_t x , int n ) 
{ 


  {
#line 131
  return ((uint8_t )((((int )x >> n) | ((int )x << (8 - n))) & 255));
}
}
#line 134
#pragma GCC diagnostic pop
#line 130 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static struct hash_tuning  const  default_tuning  =    {0.0f, 1.0f, 0.8f, 1.414f, (_Bool)0};
#line 149
size_t hash_get_n_buckets(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 149 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table ) 
{ 


  {
#line 152
  return ((size_t )table->n_buckets);
}
}
#line 157
size_t hash_get_n_buckets_used(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 157 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table ) 
{ 


  {
#line 160
  return ((size_t )table->n_buckets_used);
}
}
#line 165
size_t hash_get_n_entries(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 165 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
size_t hash_get_n_entries(Hash_table const   *table ) 
{ 


  {
#line 168
  return ((size_t )table->n_entries);
}
}
#line 173
size_t hash_get_max_bucket_length(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 173 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 177
  max_bucket_length = (size_t )0;
#line 179
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 179
      goto while_break;
    }
#line 181
    if (bucket->data) {
#line 183
      cursor = bucket;
#line 184
      bucket_length = (size_t )1;
      {
#line 186
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 186
        cursor = (struct hash_entry  const  *)cursor->next;
#line 186
        if (! cursor) {
#line 186
          goto while_break___0;
        }
#line 187
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 189
      if (bucket_length > max_bucket_length) {
#line 190
        max_bucket_length = bucket_length;
      }
    }
#line 179
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (max_bucket_length);
}
}
#line 200
_Bool hash_table_ok(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 200 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
_Bool hash_table_ok(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 204
  n_buckets_used = (size_t )0;
#line 205
  n_entries = (size_t )0;
#line 207
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 207
      goto while_break;
    }
#line 209
    if (bucket->data) {
#line 211
      cursor = bucket;
#line 214
      n_buckets_used ++;
#line 215
      n_entries ++;
      {
#line 218
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 218
        cursor = (struct hash_entry  const  *)cursor->next;
#line 218
        if (! cursor) {
#line 218
          goto while_break___0;
        }
#line 219
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 207
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (n_buckets_used == (size_t )table->n_buckets_used) {
#line 223
    if (n_entries == (size_t )table->n_entries) {
#line 224
      return ((_Bool)1);
    }
  }
#line 226
  return ((_Bool)0);
}
}
#line 229 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
void hash_print_statistics(Hash_table const   *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;

  {
  {
#line 232
  tmp = hash_get_n_entries(table);
#line 232
  n_entries = tmp;
#line 233
  tmp___0 = hash_get_n_buckets(table);
#line 233
  n_buckets = tmp___0;
#line 234
  tmp___1 = hash_get_n_buckets_used(table);
#line 234
  n_buckets_used = tmp___1;
#line 235
  tmp___2 = hash_get_max_bucket_length(table);
#line 235
  max_bucket_length = tmp___2;
#line 237
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# entries:         %lu\n",
          n_entries);
#line 238
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets:         %lu\n",
          n_buckets);
#line 239
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets used:    %lu (%.2f%%)\n",
          n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 242
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"max bucket length: %lu\n",
          max_bucket_length);
  }
#line 244
  return;
}
}
#line 248 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static struct hash_entry *safe_hasher(Hash_table const   *table , void const   *key ) 
{ 
  size_t n ;
  size_t tmp ;

  {
  {
#line 251
  tmp = (*(table->hasher))(key, (size_t )table->n_buckets);
#line 251
  n = tmp;
  }
#line 252
  if (! (n < (size_t )table->n_buckets)) {
    {
#line 253
    abort();
    }
  }
#line 254
  return ((struct hash_entry *)(table->bucket + n));
}
}
#line 260 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
void *hash_lookup(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 263
  tmp = safe_hasher(table, entry);
#line 263
  bucket = (struct hash_entry  const  *)tmp;
  }
#line 266
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 267
    return ((void *)0);
  }
#line 269
  cursor = bucket;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! cursor) {
#line 269
      goto while_break;
    }
#line 270
    if ((unsigned long )entry == (unsigned long )cursor->data) {
#line 271
      return ((void *)cursor->data);
    } else {
      {
#line 270
      tmp___0 = (*(table->comparator))(entry, (void const   *)cursor->data);
      }
#line 270
      if (tmp___0) {
#line 271
        return ((void *)cursor->data);
      }
    }
#line 269
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return ((void *)0);
}
}
#line 287
void *hash_get_first(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 287 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
void *hash_get_first(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 292
  if (table->n_entries == 0UL) {
#line 293
    return ((void *)0);
  }
#line 295
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
      {
#line 297
      abort();
      }
    } else
#line 298
    if (bucket->data) {
#line 299
      return ((void *)bucket->data);
    }
#line 295
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 306 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
void *hash_get_next(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 309
  tmp = safe_hasher(table, entry);
#line 309
  bucket = (struct hash_entry  const  *)tmp;
#line 313
  cursor = bucket;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 316
      if (cursor->next) {
#line 317
        return ((cursor->next)->data);
      }
    }
#line 318
    cursor = (struct hash_entry  const  *)cursor->next;
#line 314
    if (! ((unsigned long )cursor != (unsigned long )((void *)0))) {
#line 314
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    bucket ++;
#line 323
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 323
      goto while_break___0;
    }
#line 324
    if (bucket->data) {
#line 325
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return ((void *)0);
}
}
#line 335 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
size_t hash_get_entries(Hash_table const   *table , void **buffer___0 , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 339
  counter = (size_t )0;
#line 343
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 343
      goto while_break;
    }
#line 345
    if (bucket->data) {
#line 347
      cursor = bucket;
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 347
        if (! cursor) {
#line 347
          goto while_break___0;
        }
#line 349
        if (counter >= buffer_size) {
#line 350
          return (counter);
        }
#line 351
        tmp = counter;
#line 351
        counter ++;
#line 351
        *(buffer___0 + tmp) = (void *)cursor->data;
#line 347
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 343
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (counter);
}
}
#line 367 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 371
  counter = (size_t )0;
#line 375
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 375
      goto while_break;
    }
#line 377
    if (bucket->data) {
#line 379
      cursor = bucket;
      {
#line 379
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 379
        if (! cursor) {
#line 379
          goto while_break___0;
        }
        {
#line 381
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 381
        if (! tmp) {
#line 382
          return (counter);
        }
#line 383
        counter ++;
#line 379
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 375
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return (counter);
}
}
#line 427
size_t hash_string(char const   *string , size_t n_buckets )  __attribute__((__pure__)) ;
#line 427 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;

  {
#line 430
  value = (size_t )0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    ch = (unsigned char )*string;
#line 433
    if (! ch) {
#line 433
      goto while_break;
    }
#line 434
    value = (value * 31UL + (size_t )ch) % n_buckets;
#line 433
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (value);
}
}
#line 443
static _Bool is_prime(size_t candidate )  __attribute__((__const__)) ;
#line 443 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 446
  divisor = (size_t )3;
#line 447
  square = divisor * divisor;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (square < candidate) {
#line 449
      if (! (candidate % divisor)) {
#line 449
        goto while_break;
      }
    } else {
#line 449
      goto while_break;
    }
#line 451
    divisor ++;
#line 452
    square += 4UL * divisor;
#line 453
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (candidate % divisor) {
#line 456
    tmp = 1;
  } else {
#line 456
    tmp = 0;
  }
#line 456
  return ((_Bool )tmp);
}
}
#line 462
static size_t next_prime(size_t candidate )  __attribute__((__const__)) ;
#line 462 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 466
  if (candidate < 10UL) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= 1UL;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (0xffffffffffffffffUL != candidate) {
      {
#line 472
      tmp = is_prime(candidate);
      }
#line 472
      if (tmp) {
#line 472
        goto while_break;
      }
    } else {
#line 472
      goto while_break;
    }
#line 473
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (candidate);
}
}
#line 478 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 481
  *tuning = (Hash_tuning )default_tuning;
#line 482
  return;
}
}
#line 485 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static size_t raw_hasher(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t tmp ;

  {
  {
#line 493
  tmp = rotr_sz((size_t )data, 3);
#line 493
  val = tmp;
  }
#line 494
  return (val % n);
}
}
#line 498 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static _Bool raw_comparator(void const   *a , void const   *b ) 
{ 


  {
#line 501
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 511 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static _Bool check_tuning(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table->tuning;
#line 516
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
#line 517
    return ((_Bool)1);
  }
#line 524
  epsilon = 0.1f;
#line 526
  if (epsilon < (float )tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 526
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 526
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float const   )1) {
#line 526
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 533
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table->tuning = & default_tuning;
#line 536
  return ((_Bool)0);
}
}
#line 543 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static size_t __attribute__((__pure__))  compute_bucket_size(size_t candidate , Hash_tuning const   *tuning ) 
{ 
  float new_candidate ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 549
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 550
      return ((size_t __attribute__((__pure__))  )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
  {
#line 553
  candidate = next_prime(candidate);
  }
#line 554
  if (9223372036854775807UL / sizeof(struct hash_entry *) < candidate) {
#line 555
    return ((size_t __attribute__((__pure__))  )0);
  }
#line 556
  return ((size_t __attribute__((__pure__))  )candidate);
}
}
#line 593 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) 
{ 
  Hash_table *table ;
  void *tmp ;
  _Bool tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  void *tmp___2 ;

  {
#line 600
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 601
    hasher = & raw_hasher;
  }
#line 602
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 603
    comparator = & raw_comparator;
  }
  {
#line 605
  tmp = malloc(sizeof(*table));
#line 605
  table = (Hash_table *)tmp;
  }
#line 606
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 607
    return ((Hash_table *)((void *)0));
  }
#line 609
  if (! tuning) {
#line 610
    tuning = & default_tuning;
  }
  {
#line 611
  table->tuning = tuning;
#line 612
  tmp___0 = check_tuning(table);
  }
#line 612
  if (! tmp___0) {
#line 619
    goto fail;
  }
  {
#line 622
  tmp___1 = compute_bucket_size(candidate, tuning);
#line 622
  table->n_buckets = (size_t )tmp___1;
  }
#line 623
  if (! table->n_buckets) {
#line 624
    goto fail;
  }
  {
#line 626
  tmp___2 = calloc(table->n_buckets, sizeof(*(table->bucket)));
#line 626
  table->bucket = (struct hash_entry *)tmp___2;
  }
#line 627
  if ((unsigned long )table->bucket == (unsigned long )((void *)0)) {
#line 628
    goto fail;
  }
#line 629
  table->bucket_limit = (struct hash_entry  const  *)(table->bucket + table->n_buckets);
#line 630
  table->n_buckets_used = (size_t )0;
#line 631
  table->n_entries = (size_t )0;
#line 633
  table->hasher = hasher;
#line 634
  table->comparator = comparator;
#line 635
  table->data_freer = data_freer;
#line 637
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 641
  return (table);
  fail: 
  {
#line 644
  free((void *)table);
  }
#line 645
  return ((Hash_table *)((void *)0));
}
}
#line 652 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 657
  bucket = table->bucket;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 657
      goto while_break;
    }
#line 659
    if (bucket->data) {
#line 665
      cursor = bucket->next;
      {
#line 665
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 665
        if (! cursor) {
#line 665
          goto while_break___0;
        }
#line 667
        if (table->data_freer) {
          {
#line 668
          (*(table->data_freer))(cursor->data);
          }
        }
#line 669
        cursor->data = (void *)0;
#line 671
        next = cursor->next;
#line 674
        cursor->next = table->free_entry_list;
#line 675
        table->free_entry_list = cursor;
#line 665
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 679
      if (table->data_freer) {
        {
#line 680
        (*(table->data_freer))(bucket->data);
        }
      }
#line 681
      bucket->data = (void *)0;
#line 682
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 657
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  table->n_buckets_used = (size_t )0;
#line 687
  table->n_entries = (size_t )0;
#line 688
  return;
}
}
#line 695 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 703
  if (table->data_freer) {
#line 703
    if (table->n_entries) {
#line 705
      bucket = table->bucket;
      {
#line 705
      while (1) {
        while_continue: /* CIL Label */ ;
#line 705
        if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 705
          goto while_break;
        }
#line 707
        if (bucket->data) {
#line 709
          cursor = bucket;
          {
#line 709
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 709
            if (! cursor) {
#line 709
              goto while_break___0;
            }
            {
#line 710
            (*(table->data_freer))(cursor->data);
#line 709
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 705
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 722
  bucket = table->bucket;
  {
#line 722
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 722
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 722
      goto while_break___1;
    }
#line 724
    cursor = bucket->next;
    {
#line 724
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 724
      if (! cursor) {
#line 724
        goto while_break___2;
      }
      {
#line 726
      next = cursor->next;
#line 727
      free((void *)cursor);
#line 724
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 722
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 732
  cursor = table->free_entry_list;
  {
#line 732
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 732
    if (! cursor) {
#line 732
      goto while_break___3;
    }
    {
#line 734
    next = cursor->next;
#line 735
    free((void *)cursor);
#line 732
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 741
  free((void *)table->bucket);
#line 742
  free((void *)table);
  }
#line 743
  return;
}
}
#line 750 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 755
  if (table->free_entry_list) {
#line 757
    new = table->free_entry_list;
#line 758
    table->free_entry_list = new->next;
  } else {
    {
#line 765
    tmp = malloc(sizeof(*new));
#line 765
    new = (struct hash_entry *)tmp;
    }
  }
#line 769
  return (new);
}
}
#line 775 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 778
  entry->data = (void *)0;
#line 779
  entry->next = table->free_entry_list;
#line 780
  table->free_entry_list = entry;
#line 781
  return;
}
}
#line 789 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete___1 ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 793
  tmp = safe_hasher((Hash_table const   *)table, entry);
#line 793
  bucket = tmp;
#line 796
  *bucket_head = bucket;
  }
#line 799
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 800
    return ((void *)0);
  }
#line 803
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 803
    goto _L;
  } else {
    {
#line 803
    tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
    }
#line 803
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 805
      data = bucket->data;
#line 807
      if (delete___1) {
#line 809
        if (bucket->next) {
          {
#line 811
          next = bucket->next;
#line 815
          *bucket = *next;
#line 816
          free_entry(table, next);
          }
        } else {
#line 820
          bucket->data = (void *)0;
        }
      }
#line 824
      return (data);
    }
  }
#line 828
  cursor = bucket;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cursor->next) {
#line 828
      goto while_break;
    }
#line 830
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 830
      goto _L___0;
    } else {
      {
#line 830
      tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
      }
#line 830
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 833
        data___0 = (cursor->next)->data;
#line 835
        if (delete___1) {
          {
#line 837
          next___0 = cursor->next;
#line 841
          cursor->next = next___0->next;
#line 842
          free_entry(table, next___0);
          }
        }
#line 845
        return (data___0);
      }
    }
#line 828
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return ((void *)0);
}
}
#line 859 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
#line 865
  bucket = src->bucket;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 865
      goto while_break;
    }
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
      {
#line 877
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 877
        if (! cursor) {
#line 877
          goto while_break___0;
        }
        {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
#line 882
        next = cursor->next;
        }
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
          {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry(dst, cursor);
          }
        }
#line 877
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
      {
#line 907
      new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
      }
#line 909
      if (new_bucket->data) {
        {
#line 913
        tmp = allocate_entry(dst);
#line 913
        new_entry = tmp;
        }
#line 915
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 916
          return ((_Bool)0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */ 
#line 865
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return ((_Bool)1);
}
}
#line 942 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) 
{ 
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t __attribute__((__pure__))  tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 947
  tmp = compute_bucket_size(candidate, table->tuning);
#line 947
  new_size = (size_t )tmp;
  }
#line 949
  if (! new_size) {
#line 950
    return ((_Bool)0);
  }
#line 951
  if (new_size == table->n_buckets) {
#line 952
    return ((_Bool)1);
  }
  {
#line 953
  new_table = & storage;
#line 954
  tmp___0 = calloc(new_size, sizeof(*(new_table->bucket)));
#line 954
  new_table->bucket = (struct hash_entry *)tmp___0;
  }
#line 955
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
#line 956
    return ((_Bool)0);
  }
  {
#line 957
  new_table->n_buckets = new_size;
#line 958
  new_table->bucket_limit = (struct hash_entry  const  *)(new_table->bucket + new_size);
#line 959
  new_table->n_buckets_used = (size_t )0;
#line 960
  new_table->n_entries = (size_t )0;
#line 961
  new_table->tuning = table->tuning;
#line 962
  new_table->hasher = table->hasher;
#line 963
  new_table->comparator = table->comparator;
#line 964
  new_table->data_freer = table->data_freer;
#line 984
  new_table->free_entry_list = table->free_entry_list;
#line 986
  tmp___1 = transfer_entries(new_table, table, (_Bool)0);
  }
#line 986
  if (tmp___1) {
    {
#line 989
    free((void *)table->bucket);
#line 990
    table->bucket = new_table->bucket;
#line 991
    table->bucket_limit = new_table->bucket_limit;
#line 992
    table->n_buckets = new_table->n_buckets;
#line 993
    table->n_buckets_used = new_table->n_buckets_used;
#line 994
    table->free_entry_list = new_table->free_entry_list;
    }
#line 996
    return ((_Bool)1);
  }
  {
#line 1012
  table->free_entry_list = new_table->free_entry_list;
#line 1013
  tmp___2 = transfer_entries(table, new_table, (_Bool)1);
  }
#line 1013
  if (tmp___2) {
    {
#line 1013
    tmp___3 = transfer_entries(table, new_table, (_Bool)0);
    }
#line 1013
    if (! tmp___3) {
      {
#line 1015
      abort();
      }
    }
  } else {
    {
#line 1015
    abort();
    }
  }
  {
#line 1017
  free((void *)new_table->bucket);
  }
#line 1018
  return ((_Bool)0);
}
}
#line 1037 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;

  {
#line 1047
  if (! entry) {
    {
#line 1048
    abort();
    }
  }
  {
#line 1051
  data = hash_find_entry(table, entry, & bucket, (_Bool)0);
  }
#line 1051
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 1053
    if (matched_ent) {
#line 1054
      *matched_ent = (void const   *)data;
    }
#line 1055
    return (0);
  }
#line 1063
  if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
    {
#line 1068
    check_tuning(table);
    }
#line 1069
    if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 1072
      tuning = table->tuning;
#line 1073
      if (tuning->is_n_buckets) {
#line 1073
        tmp = (float const   )table->n_buckets * tuning->growth_factor;
      } else {
#line 1073
        tmp = ((float const   )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 1073
      candidate = (float )tmp;
#line 1079
      if ((float )0xffffffffffffffffUL <= candidate) {
#line 1080
        return (-1);
      }
      {
#line 1083
      tmp___0 = hash_rehash(table, (size_t )candidate);
      }
#line 1083
      if (! tmp___0) {
#line 1084
        return (-1);
      }
      {
#line 1087
      tmp___1 = hash_find_entry(table, entry, & bucket, (_Bool)0);
      }
#line 1087
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
#line 1088
        abort();
        }
      }
    }
  }
#line 1094
  if (bucket->data) {
    {
#line 1096
    tmp___2 = allocate_entry(table);
#line 1096
    new_entry = tmp___2;
    }
#line 1098
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 1099
      return (-1);
    }
#line 1103
    new_entry->data = (void *)entry;
#line 1104
    new_entry->next = bucket->next;
#line 1105
    bucket->next = new_entry;
#line 1106
    (table->n_entries) ++;
#line 1107
    return (1);
  }
#line 1112
  bucket->data = (void *)entry;
#line 1113
  (table->n_entries) ++;
#line 1114
  (table->n_buckets_used) ++;
#line 1116
  return (1);
}
}
#line 1125 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) 
{ 
  void const   *matched_ent ;
  int err ;
  int tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1129
  tmp = hash_insert_if_absent(table, entry, & matched_ent);
#line 1129
  err = tmp;
  }
#line 1130
  if (err == -1) {
#line 1130
    tmp___1 = (void *)0;
  } else {
#line 1130
    if (err == 0) {
#line 1130
      tmp___0 = matched_ent;
    } else {
#line 1130
      tmp___0 = entry;
    }
#line 1130
    tmp___1 = (void *)tmp___0;
  }
#line 1130
  return (tmp___1);
}
}
#line 1139 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
void *hash_delete(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;

  {
  {
#line 1145
  data = hash_find_entry(table, entry, & bucket, (_Bool)1);
  }
#line 1146
  if (! data) {
#line 1147
    return ((void *)0);
  }
#line 1149
  (table->n_entries) --;
#line 1150
  if (! bucket->data) {
#line 1152
    (table->n_buckets_used) --;
#line 1157
    if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
      {
#line 1162
      check_tuning(table);
      }
#line 1163
      if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1166
        tuning = table->tuning;
#line 1167
        if (tuning->is_n_buckets) {
#line 1167
          tmp = (float const   )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1167
          tmp = ((float const   )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1167
        candidate = (size_t )tmp;
#line 1173
        tmp___0 = hash_rehash(table, candidate);
        }
#line 1173
        if (! tmp___0) {
#line 1181
          cursor = table->free_entry_list;
          {
#line 1183
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1183
            if (! cursor) {
#line 1183
              goto while_break;
            }
            {
#line 1185
            next = cursor->next;
#line 1186
            free((void *)cursor);
#line 1187
            cursor = next;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1189
          table->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1196
  return (data);
}
}
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 37 "/home/khheo/project/benchmark/grep-3.1/lib/hard-locale.c"
_Bool hard_locale(int category ) 
{ 
  _Bool hard ;
  char const   *p ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *locale ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 40
  hard = (_Bool)1;
#line 41
  tmp = setlocale(category, (char const   *)((void *)0));
#line 41
  p = (char const   *)tmp;
  }
#line 43
  if (p) {
#line 45
    if (1) {
      {
#line 47
      tmp___0 = strcmp(p, "C");
      }
#line 47
      if (tmp___0 == 0) {
#line 48
        hard = (_Bool)0;
      } else {
        {
#line 47
        tmp___1 = strcmp(p, "POSIX");
        }
#line 47
        if (tmp___1 == 0) {
#line 48
          hard = (_Bool)0;
        }
      }
    } else {
      {
#line 52
      tmp___2 = strdup(p);
#line 52
      locale = tmp___2;
      }
#line 53
      if (locale) {
        {
#line 58
        tmp___3 = setlocale(category, "C");
#line 58
        p = (char const   *)tmp___3;
        }
#line 58
        if (p) {
          {
#line 58
          tmp___4 = strcmp(p, (char const   *)locale);
          }
#line 58
          if (tmp___4 == 0) {
#line 62
            hard = (_Bool)0;
          } else {
#line 58
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 58
          tmp___5 = setlocale(category, "POSIX");
#line 58
          p = (char const   *)tmp___5;
          }
#line 58
          if (p) {
            {
#line 58
            tmp___6 = strcmp(p, (char const   *)locale);
            }
#line 58
            if (tmp___6 == 0) {
#line 62
              hard = (_Bool)0;
            }
          }
        }
        {
#line 65
        setlocale(category, (char const   *)locale);
#line 66
        free((void *)locale);
        }
      }
    }
  }
#line 71
  return (hard);
}
}
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/getprogname.h"
char const   *getprogname(void)  __attribute__((__pure__)) ;
#line 46 "/usr/include/errno.h"
extern char *program_invocation_short_name ;
#line 57 "/home/khheo/project/benchmark/grep-3.1/lib/getprogname.c"
char const   *getprogname(void)  __attribute__((__pure__)) ;
#line 57 "/home/khheo/project/benchmark/grep-3.1/lib/getprogname.c"
char const   *getprogname(void) 
{ 


  {
#line 62
  return ((char const   *)program_invocation_short_name);
}
}
#line 162 "/usr/include/dirent.h"
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 210
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 234
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd ,
                                                                                                char const   * __restrict  __file ,
                                                                                                struct stat * __restrict  __buf ,
                                                                                                int __flag ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 273 "/home/khheo/project/benchmark/grep-3.1/lib/fts_.h"
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                                                        int instr ) ;
#line 274
 __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) ;
#line 275
 __attribute__((__nothrow__)) FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                                                 int options ,
                                                                                                 int (*compar)(FTSENT const   ** ,
                                                                                                               FTSENT const   ** ) ) ;
#line 278
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) ;
#line 279
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) ,
                                                                       FTSENT *p ,
                                                                       int instr ) ;
#line 827 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 252 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-3.1/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 214 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) ;
#line 215
static FTSENT *fts_build(FTS *sp , int type ) ;
#line 216
static void fts_lfree(FTSENT *head ) ;
#line 217
static void fts_load(FTS *sp , FTSENT *p ) ;
#line 218
static size_t __attribute__((__pure__))  fts_maxarglen(char * const  *argv ) ;
#line 219
static void fts_padjust(FTS *sp , FTSENT *head ) ;
#line 220
static _Bool fts_palloc(FTS *sp , size_t more ) ;
#line 221
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) ;
#line 222
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) ;
#line 223
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
#line 35 "/home/khheo/project/benchmark/grep-3.1/lib/cycle-check.h"
void cycle_check_init(struct cycle_check_state *state ) ;
#line 36
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) ;
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/fts-cycle.c"
static _Bool AD_compare(void const   *x , void const   *y ) 
{ 
  struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;
  int tmp ;

  {
#line 34
  ax = (struct Active_dir  const  *)x;
#line 35
  ay = (struct Active_dir  const  *)y;
#line 36
  if (ax->ino == ay->ino) {
#line 36
    if (ax->dev == ay->dev) {
#line 36
      tmp = 1;
    } else {
#line 36
      tmp = 0;
    }
  } else {
#line 36
    tmp = 0;
  }
#line 36
  return ((_Bool )tmp);
}
}
#line 40 "/home/khheo/project/benchmark/grep-3.1/lib/fts-cycle.c"
static size_t AD_hash(void const   *x , size_t table_size ) 
{ 
  struct Active_dir  const  *ax ;

  {
#line 43
  ax = (struct Active_dir  const  *)x;
#line 44
  return ((uintmax_t )ax->ino % table_size);
}
}
#line 49 "/home/khheo/project/benchmark/grep-3.1/lib/fts-cycle.c"
static _Bool setup_dir(FTS *fts ) 
{ 
  void *tmp ;

  {
#line 52
  if (fts->fts_options & 258) {
    {
#line 55
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const   *)((void *)0),
                                        & AD_hash, & AD_compare, (void (*)(void * ))(& free));
    }
#line 57
    if (! fts->fts_cycle.ht) {
#line 58
      return ((_Bool)0);
    }
  } else {
    {
#line 62
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
#line 62
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
    }
#line 63
    if (! fts->fts_cycle.state) {
#line 64
      return ((_Bool)0);
    }
    {
#line 65
    cycle_check_init(fts->fts_cycle.state);
    }
  }
#line 68
  return ((_Bool)1);
}
}
#line 73 "/home/khheo/project/benchmark/grep-3.1/lib/fts-cycle.c"
static _Bool enter_dir(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 76
  if (fts->fts_options & 258) {
    {
#line 78
    st = (struct stat  const  *)(ent->fts_statp);
#line 79
    tmp = malloc(sizeof(*ad));
#line 79
    ad = (struct Active_dir *)tmp;
    }
#line 82
    if (! ad) {
#line 83
      return ((_Bool)0);
    }
    {
#line 85
    ad->dev = (dev_t )st->st_dev;
#line 86
    ad->ino = (ino_t )st->st_ino;
#line 87
    ad->fts_ent = ent;
#line 92
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
#line 92
    ad_from_table = (struct Active_dir *)tmp___0;
    }
#line 94
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
      {
#line 96
      free((void *)ad);
      }
#line 97
      if (! ad_from_table) {
#line 98
        return ((_Bool)0);
      }
#line 102
      ent->fts_cycle = ad_from_table->fts_ent;
#line 103
      ent->fts_info = (unsigned short)2;
    }
  } else {
    {
#line 108
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
    }
#line 108
    if (tmp___1) {
#line 114
      ent->fts_cycle = ent;
#line 115
      ent->fts_info = (unsigned short)2;
    }
  }
#line 119
  return ((_Bool)1);
}
}
#line 124 "/home/khheo/project/benchmark/grep-3.1/lib/fts-cycle.c"
static void leave_dir(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
#line 127
  st = (struct stat  const  *)(ent->fts_statp);
#line 128
  if (fts->fts_options & 258) {
    {
#line 132
    obj.dev = (dev_t )st->st_dev;
#line 133
    obj.ino = (ino_t )st->st_ino;
#line 134
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
    }
#line 135
    if (! found) {
      {
#line 136
      abort();
      }
    }
    {
#line 137
    free(found);
    }
  } else {
#line 141
    parent = ent->fts_parent;
#line 142
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 142
      if (0L <= parent->fts_level) {
        {
#line 143
        while (1) {
          while_continue: /* CIL Label */ ;
#line 143
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
            {
#line 143
            abort();
            }
          }
#line 143
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
#line 143
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
#line 143
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
#line 143
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
            }
          }
#line 143
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 146
  return;
}
}
#line 150 "/home/khheo/project/benchmark/grep-3.1/lib/fts-cycle.c"
static void free_dir(FTS *sp ) 
{ 


  {
#line 153
  if (sp->fts_options & 258) {
#line 155
    if (sp->fts_cycle.ht) {
      {
#line 156
      hash_free(sp->fts_cycle.ht);
      }
    }
  } else {
    {
#line 159
    free((void *)sp->fts_cycle.state);
    }
  }
#line 160
  return;
}
}
#line 279 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void fd_ring_clear(I_ring *fd_ring ) 
{ 
  int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 282
    tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
    }
#line 282
    if (tmp___0) {
#line 282
      goto while_break;
    }
    {
#line 284
    tmp = i_ring_pop(fd_ring);
#line 284
    fd = tmp;
    }
#line 285
    if (0 <= fd) {
      {
#line 286
      close(fd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 293 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void fts_set_stat_required(FTSENT *p , _Bool required ) 
{ 


  {
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! ((int )p->fts_info == 11)) {
      {
#line 296
      abort();
      }
    }
#line 296
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  if (required) {
#line 297
    p->fts_statp[0].st_size = (__off_t )2;
  } else {
#line 297
    p->fts_statp[0].st_size = (__off_t )1;
  }
#line 300
  return;
}
}
#line 304 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static DIR *opendirat(int fd , char const   *dir , int extra_flags , int *pdir_fd ) 
{ 
  int new_fd ;
  int tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 308
  tmp = openat_safer(fd, dir, 67840 | extra_flags);
#line 308
  new_fd = tmp;
  }
#line 313
  if (new_fd < 0) {
#line 314
    return ((DIR *)((void *)0));
  }
  {
#line 315
  set_cloexec_flag(new_fd, (_Bool)1);
#line 316
  dirp = fdopendir(new_fd);
  }
#line 317
  if (dirp) {
#line 318
    *pdir_fd = new_fd;
  } else {
    {
#line 321
    tmp___0 = __errno_location();
#line 321
    saved_errno = *tmp___0;
#line 322
    close(new_fd);
#line 323
    tmp___1 = __errno_location();
#line 323
    *tmp___1 = saved_errno;
    }
  }
#line 325
  return (dirp);
}
}
#line 333 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void cwd_advance_fd(FTS *sp , int fd , _Bool chdir_down_one ) 
{ 
  int old ;
  int prev_fd_in_slot ;
  int tmp ;

  {
#line 337
  old = sp->fts_cwd_fd;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (old != fd)) {
#line 338
      if (! (old == -100)) {
        {
#line 338
        abort();
        }
      }
    }
#line 338
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  if (chdir_down_one) {
    {
#line 344
    tmp = i_ring_push(& sp->fts_fd_ring, old);
#line 344
    prev_fd_in_slot = tmp;
    }
#line 346
    if (0 <= prev_fd_in_slot) {
      {
#line 347
      close(prev_fd_in_slot);
      }
    }
  } else
#line 349
  if (! (sp->fts_options & 4)) {
#line 351
    if (0 <= old) {
      {
#line 352
      close(old);
      }
    }
  }
#line 355
  sp->fts_cwd_fd = fd;
#line 356
  return;
}
}
#line 362 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static int restore_initial_cwd(FTS *sp ) 
{ 
  int fail ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 365
  if (! (sp->fts_options & 4)) {
#line 365
    if (sp->fts_options & 512) {
#line 365
      if (sp->fts_options & 512) {
#line 365
        tmp = -100;
      } else {
#line 365
        tmp = sp->fts_rfd;
      }
      {
#line 365
      cwd_advance_fd(sp, tmp, (_Bool)1);
#line 365
      tmp___2 = 0;
      }
    } else {
#line 365
      if (sp->fts_options & 512) {
#line 365
        tmp___0 = -100;
      } else {
#line 365
        tmp___0 = sp->fts_rfd;
      }
      {
#line 365
      tmp___1 = fchdir(tmp___0);
#line 365
      tmp___2 = tmp___1;
      }
    }
#line 365
    if (tmp___2) {
#line 365
      tmp___3 = 1;
    } else {
#line 365
      tmp___3 = 0;
    }
  } else {
#line 365
    tmp___3 = 0;
  }
  {
#line 365
  fail = tmp___3;
#line 366
  fd_ring_clear(& sp->fts_fd_ring);
  }
#line 367
  return (fail);
}
}
#line 374 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static int diropen(FTS const   *sp , char const   *dir ) 
{ 
  int open_flags ;
  int tmp ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 378
  if (sp->fts_options & 16) {
#line 378
    tmp = 131072;
  } else {
#line 378
    tmp = 0;
  }
#line 378
  if (sp->fts_options & 2048) {
#line 378
    tmp___0 = 262144;
  } else {
#line 378
    tmp___0 = 0;
  }
#line 378
  open_flags = (67840 | tmp) | tmp___0;
#line 382
  if (sp->fts_options & 512) {
    {
#line 382
    tmp___1 = openat_safer((int )sp->fts_cwd_fd, dir, open_flags);
#line 382
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 382
    tmp___2 = open_safer(dir, open_flags);
#line 382
    tmp___3 = tmp___2;
    }
  }
#line 382
  fd = tmp___3;
#line 385
  if (0 <= fd) {
    {
#line 386
    set_cloexec_flag(fd, (_Bool)1);
    }
  }
#line 387
  return (fd);
}
}
#line 390
 __attribute__((__nothrow__)) FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                                                 int options ,
                                                                                                 int (*compar)(FTSENT const   ** ,
                                                                                                               FTSENT const   ** ) ) ;
#line 390 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                   int options , int (*compar)(FTSENT const   ** ,
                                                                                               FTSENT const   ** ) ) 
{ 
  register FTS *sp ;
  register FTSENT *p ;
  register FTSENT *root ;
  register size_t nitems ;
  FTSENT *parent ;
  FTSENT *tmp ;
  _Bool defer_stat ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  size_t maxarglen ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  size_t len ;
  size_t tmp___10 ;
  char const   *v ;
  struct _ftsent *tmp___11 ;
  _Bool tmp___12 ;
  int tmp___13 ;

  {
#line 398
  parent = (FTSENT *)((void *)0);
#line 399
  tmp = (FTSENT *)((void *)0);
#line 403
  if (options & -8192) {
    {
#line 404
    tmp___0 = __errno_location();
#line 404
    *tmp___0 = 22;
    }
#line 405
    return ((FTS *)((void *)0));
  }
#line 407
  if (options & 4) {
#line 407
    if (options & 512) {
      {
#line 408
      tmp___1 = __errno_location();
#line 408
      *tmp___1 = 22;
      }
#line 409
      return ((FTS *)((void *)0));
    }
  }
#line 411
  if (! (options & 18)) {
    {
#line 412
    tmp___2 = __errno_location();
#line 412
    *tmp___2 = 22;
    }
#line 413
    return ((FTS *)((void *)0));
  }
  {
#line 417
  tmp___3 = malloc(sizeof(FTS ));
#line 417
  sp = (FTS *)tmp___3;
  }
#line 417
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 418
    return ((FTS *)((void *)0));
  }
  {
#line 419
  memset((void *)sp, 0, sizeof(FTS ));
#line 420
  sp->fts_compar = compar;
#line 421
  sp->fts_options = options;
  }
#line 424
  if (sp->fts_options & 2) {
#line 425
    sp->fts_options |= 4;
#line 426
    sp->fts_options &= -513;
  }
#line 430
  sp->fts_cwd_fd = -100;
#line 431
  if (sp->fts_options & 512) {

  }
  {
#line 472
  tmp___6 = (size_t )fts_maxarglen(argv);
#line 472
  maxarglen = tmp___6;
  }
#line 473
  if (maxarglen > 4096UL) {
#line 473
    tmp___7 = maxarglen;
  } else {
#line 473
    tmp___7 = (size_t )4096;
  }
  {
#line 473
  tmp___8 = fts_palloc(sp, tmp___7);
  }
#line 473
  if (! tmp___8) {
#line 474
    goto mem1;
  }
#line 478
  if ((unsigned long )*argv != (unsigned long )((void *)0)) {
    {
#line 479
    parent = fts_alloc(sp, "", (size_t )0);
    }
#line 479
    if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 480
      goto mem2;
    }
#line 481
    parent->fts_level = (ptrdiff_t )-1;
  }
#line 495
  if ((unsigned long )compar == (unsigned long )((void *)0)) {
#line 495
    tmp___9 = 1;
  } else
#line 495
  if (sp->fts_options & 1024) {
#line 495
    tmp___9 = 1;
  } else {
#line 495
    tmp___9 = 0;
  }
#line 495
  defer_stat = (_Bool )tmp___9;
#line 498
  root = (FTSENT *)((void *)0);
#line 498
  nitems = (size_t )0;
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! ((unsigned long )*argv != (unsigned long )((void *)0))) {
#line 498
      goto while_break;
    }
    {
#line 500
    tmp___10 = strlen((char const   *)*argv);
#line 500
    len = tmp___10;
    }
#line 502
    if (! (options & 4096)) {
#line 506
      v = (char const   *)*argv;
#line 507
      if (2UL < len) {
#line 507
        if ((int const   )*(v + (len - 1UL)) == 47) {
          {
#line 508
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 508
            if (1UL < len) {
#line 508
              if (! ((int const   )*(v + (len - 2UL)) == 47)) {
#line 508
                goto while_break___0;
              }
            } else {
#line 508
              goto while_break___0;
            }
#line 509
            len --;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 512
    p = fts_alloc(sp, (char const   *)*argv, len);
    }
#line 512
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 513
      goto mem3;
    }
#line 514
    p->fts_level = (ptrdiff_t )0;
#line 515
    p->fts_parent = parent;
#line 516
    p->fts_accpath = p->fts_name;
#line 520
    if (defer_stat) {
#line 520
      if ((unsigned long )root != (unsigned long )((void *)0)) {
        {
#line 521
        p->fts_info = (unsigned short)11;
#line 522
        fts_set_stat_required(p, (_Bool)1);
        }
      } else {
        {
#line 524
        p->fts_info = fts_stat(sp, p, (_Bool)0);
        }
      }
    } else {
      {
#line 524
      p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
    }
#line 531
    if (compar) {
#line 532
      p->fts_link = root;
#line 533
      root = p;
    } else {
#line 535
      p->fts_link = (struct _ftsent *)((void *)0);
#line 536
      if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 537
        root = p;
#line 537
        tmp = root;
      } else {
#line 539
        tmp->fts_link = p;
#line 540
        tmp = p;
      }
    }
#line 498
    argv ++;
#line 498
    nitems ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  if (compar) {
#line 544
    if (nitems > 1UL) {
      {
#line 545
      root = fts_sort(sp, root, nitems);
      }
    }
  }
  {
#line 552
  tmp___11 = fts_alloc(sp, "", (size_t )0);
#line 552
  sp->fts_cur = tmp___11;
  }
#line 552
  if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
#line 553
    goto mem3;
  }
  {
#line 554
  (sp->fts_cur)->fts_link = root;
#line 555
  (sp->fts_cur)->fts_info = (unsigned short)9;
#line 556
  tmp___12 = setup_dir(sp);
  }
#line 556
  if (! tmp___12) {
#line 557
    goto mem3;
  }
#line 566
  if (! (sp->fts_options & 4)) {
#line 566
    if (! (sp->fts_options & 512)) {
      {
#line 566
      tmp___13 = diropen((FTS const   *)sp, ".");
#line 566
      sp->fts_rfd = tmp___13;
      }
#line 566
      if (tmp___13 < 0) {
#line 568
        sp->fts_options |= 4;
      }
    }
  }
  {
#line 570
  i_ring_init(& sp->fts_fd_ring, -1);
  }
#line 571
  return (sp);
  mem3: 
  {
#line 573
  fts_lfree(root);
#line 574
  free((void *)parent);
  }
  mem2: 
  {
#line 575
  free((void *)sp->fts_path);
  }
  mem1: 
  {
#line 576
  free((void *)sp);
  }
#line 577
  return ((FTS *)((void *)0));
}
}
#line 580 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void fts_load(FTS *sp , FTSENT *p ) 
{ 
  register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 594
  tmp = p->fts_namelen;
#line 594
  p->fts_pathlen = tmp;
#line 594
  len = tmp;
#line 595
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1UL);
#line 596
  cp = strrchr((char const   *)(p->fts_name), '/');
  }
#line 596
  if (cp) {
#line 596
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
      {
#line 597
      cp ++;
#line 597
      len = strlen((char const   *)cp);
#line 598
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 599
      p->fts_namelen = len;
      }
    } else
#line 596
    if (*(cp + 1)) {
      {
#line 597
      cp ++;
#line 597
      len = strlen((char const   *)cp);
#line 598
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 599
      p->fts_namelen = len;
      }
    }
  }
#line 601
  tmp___0 = sp->fts_path;
#line 601
  p->fts_path = tmp___0;
#line 601
  p->fts_accpath = tmp___0;
#line 602
  return;
}
}
#line 604
 __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) ;
#line 604 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) 
{ 
  register FTSENT *freep ;
  register FTSENT *p ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
#line 608
  saved_errno = 0;
#line 615
  if (sp->fts_cur) {
#line 616
    p = sp->fts_cur;
    {
#line 616
    while (1) {
      while_continue: /* CIL Label */ ;
#line 616
      if (! (p->fts_level >= 0L)) {
#line 616
        goto while_break;
      }
#line 617
      freep = p;
#line 618
      if ((unsigned long )p->fts_link != (unsigned long )((void *)0)) {
#line 618
        p = p->fts_link;
      } else {
#line 618
        p = p->fts_parent;
      }
      {
#line 619
      free((void *)freep);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 621
    free((void *)p);
    }
  }
#line 625
  if (sp->fts_child) {
    {
#line 626
    fts_lfree(sp->fts_child);
    }
  }
  {
#line 627
  free((void *)sp->fts_array);
#line 628
  free((void *)sp->fts_path);
  }
#line 630
  if (sp->fts_options & 512) {
#line 632
    if (0 <= sp->fts_cwd_fd) {
      {
#line 633
      tmp___0 = close(sp->fts_cwd_fd);
      }
#line 633
      if (tmp___0) {
        {
#line 634
        tmp = __errno_location();
#line 634
        saved_errno = *tmp;
        }
      }
    }
  } else
#line 636
  if (! (sp->fts_options & 4)) {
    {
#line 639
    tmp___2 = fchdir(sp->fts_rfd);
    }
#line 639
    if (tmp___2) {
      {
#line 640
      tmp___1 = __errno_location();
#line 640
      saved_errno = *tmp___1;
      }
    }
    {
#line 644
    tmp___4 = close(sp->fts_rfd);
    }
#line 644
    if (tmp___4) {
#line 645
      if (saved_errno == 0) {
        {
#line 646
        tmp___3 = __errno_location();
#line 646
        saved_errno = *tmp___3;
        }
      }
    }
  }
  {
#line 649
  fd_ring_clear(& sp->fts_fd_ring);
  }
#line 651
  if (sp->fts_leaf_optimization_works_ht) {
    {
#line 652
    hash_free(sp->fts_leaf_optimization_works_ht);
    }
  }
  {
#line 654
  free_dir(sp);
#line 657
  free((void *)sp);
  }
#line 660
  if (saved_errno) {
    {
#line 661
    tmp___5 = __errno_location();
#line 661
    *tmp___5 = saved_errno;
    }
#line 662
    return (-1);
  }
#line 665
  return (0);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstatfs)(int __fildes ,
                                                                                              struct statfs *__buf ) ;
#line 684 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static _Bool dirent_inode_sort_may_be_useful(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 695
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 695
  if (tmp != 0) {
#line 696
    return ((_Bool)1);
  }
  {
#line 703
  if (fs_buf.f_type == 26985L) {
#line 703
    goto case_26985;
  }
#line 703
  if (fs_buf.f_type == 16914836L) {
#line 703
    goto case_26985;
  }
#line 708
  goto switch_default;
  case_26985: /* CIL Label */ 
  case_16914836: /* CIL Label */ 
#line 706
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 709
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 716 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static _Bool leaf_optimization_applies(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 722
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 722
  if (tmp != 0) {
#line 723
    return ((_Bool)0);
  }
  {
#line 733
  if (fs_buf.f_type == 1481003842L) {
#line 733
    goto case_1481003842;
  }
#line 733
  if (fs_buf.f_type == 1382369651L) {
#line 733
    goto case_1481003842;
  }
#line 738
  if (fs_buf.f_type == 26985L) {
#line 738
    goto case_26985;
  }
#line 744
  if (fs_buf.f_type == 40864L) {
#line 744
    goto case_40864;
  }
#line 748
  goto switch_default;
  case_1481003842: /* CIL Label */ 
  case_1382369651: /* CIL Label */ 
#line 734
  return ((_Bool)1);
  case_26985: /* CIL Label */ ;
  case_40864: /* CIL Label */ ;
  switch_default: /* CIL Label */ 
#line 749
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 773 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static size_t LCO_hash(void const   *x , size_t table_size ) 
{ 
  struct LCO_ent  const  *ax ;

  {
#line 776
  ax = (struct LCO_ent  const  *)x;
#line 777
  return ((uintmax_t )ax->st_dev % table_size);
}
}
#line 780 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static _Bool LCO_compare(void const   *x , void const   *y ) 
{ 
  struct LCO_ent  const  *ax ;
  struct LCO_ent  const  *ay ;

  {
#line 783
  ax = (struct LCO_ent  const  *)x;
#line 784
  ay = (struct LCO_ent  const  *)y;
#line 785
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
#line 791 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static _Bool link_count_optimize_ok(FTSENT const   *p ) 
{ 
  FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 794
  sp = (FTS *)p->fts_fts;
#line 795
  h = sp->fts_leaf_optimization_works_ht;
#line 803
  if (! (sp->fts_options & 512)) {
#line 804
    return ((_Bool)0);
  }
#line 807
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 809
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const   *)((void *)0), & LCO_hash,
                              & LCO_compare, (void (*)(void * ))(& free));
#line 809
    sp->fts_leaf_optimization_works_ht = tmp___0;
#line 809
    h = tmp___0;
    }
#line 812
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 813
      return ((_Bool)0);
    }
  }
  {
#line 815
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 816
  tmp___1 = hash_lookup((Hash_table const   *)h, (void const   *)(& tmp));
#line 816
  ent = (struct LCO_ent *)tmp___1;
  }
#line 817
  if (ent) {
#line 818
    return (ent->opt_ok);
  }
  {
#line 821
  tmp___2 = malloc(sizeof(*t2));
#line 821
  t2 = (struct LCO_ent *)tmp___2;
  }
#line 822
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
#line 823
    return ((_Bool)0);
  }
  {
#line 826
  opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
#line 827
  t2->opt_ok = opt_ok;
#line 828
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 830
  tmp___3 = hash_insert(h, (void const   *)t2);
#line 830
  ent = (struct LCO_ent *)tmp___3;
  }
#line 831
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
    {
#line 834
    free((void *)t2);
    }
#line 835
    return ((_Bool)0);
  }
  {
#line 837
  while (1) {
    while_continue: /* CIL Label */ ;
#line 837
    if (! ((unsigned long )ent == (unsigned long )t2)) {
      {
#line 837
      abort();
      }
    }
#line 837
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  return (opt_ok);
}
}
#line 850
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) ;
#line 850 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) 
{ 
  register FTSENT *p ;
  register FTSENT *tmp ;
  register unsigned short instr ;
  register char *t ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  struct _ftsent *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  FTSENT *parent ;
  _Bool tmp___10 ;
  int *tmp___11 ;
  _Bool tmp___12 ;
  int *tmp___13 ;
  struct _ftsent *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  FTSENT *tmp___22 ;

  {
#line 858
  if ((unsigned long )sp->fts_cur == (unsigned long )((void *)0)) {
#line 859
    return ((FTSENT *)((void *)0));
  } else
#line 858
  if (sp->fts_options & 16384) {
#line 859
    return ((FTSENT *)((void *)0));
  }
#line 862
  p = sp->fts_cur;
#line 865
  instr = p->fts_instr;
#line 866
  p->fts_instr = (unsigned short)3;
#line 869
  if ((int )instr == 1) {
    {
#line 870
    p->fts_info = fts_stat(sp, p, (_Bool)0);
    }
#line 871
    return (p);
  }
#line 882
  if ((int )instr == 2) {
#line 882
    if ((int )p->fts_info == 12) {
#line 882
      goto _L;
    } else
#line 882
    if ((int )p->fts_info == 13) {
      _L: /* CIL Label */ 
      {
#line 884
      p->fts_info = fts_stat(sp, p, (_Bool)1);
      }
#line 885
      if ((int )p->fts_info == 1) {
#line 885
        if (! (sp->fts_options & 4)) {
          {
#line 886
          tmp___1 = diropen((FTS const   *)sp, ".");
#line 886
          p->fts_symfd = tmp___1;
          }
#line 886
          if (tmp___1 < 0) {
            {
#line 887
            tmp___0 = __errno_location();
#line 887
            p->fts_errno = *tmp___0;
#line 888
            p->fts_info = (unsigned short)7;
            }
          } else {
#line 890
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 892
      goto check_for_dir;
    }
  }
#line 896
  if ((int )p->fts_info == 1) {
#line 898
    if ((int )instr == 4) {
#line 898
      goto _L___0;
    } else
#line 898
    if (sp->fts_options & 64) {
#line 898
      if (p->fts_statp[0].st_dev != sp->fts_dev) {
        _L___0: /* CIL Label */ 
#line 900
        if ((int )p->fts_flags & 2) {
          {
#line 901
          close(p->fts_symfd);
          }
        }
#line 902
        if (sp->fts_child) {
          {
#line 903
          fts_lfree(sp->fts_child);
#line 904
          sp->fts_child = (struct _ftsent *)((void *)0);
          }
        }
#line 906
        p->fts_info = (unsigned short)6;
        {
#line 907
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 907
          leave_dir(sp, p);
          }
#line 907
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 908
        return (p);
      }
    }
#line 912
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
#line 912
      if (sp->fts_options & 8192) {
        {
#line 913
        sp->fts_options &= -8193;
#line 914
        fts_lfree(sp->fts_child);
#line 915
        sp->fts_child = (struct _ftsent *)((void *)0);
        }
      }
    }
#line 930
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
      {
#line 931
      tmp___3 = fts_safe_changedir(sp, p, -1, (char const   *)p->fts_accpath);
      }
#line 931
      if (tmp___3) {
        {
#line 932
        tmp___2 = __errno_location();
#line 932
        p->fts_errno = *tmp___2;
#line 933
        p->fts_flags = (unsigned short )((int )p->fts_flags | 1);
#line 934
        p = sp->fts_child;
        }
        {
#line 934
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 934
          if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 934
            goto while_break___0;
          }
#line 936
          p->fts_accpath = (p->fts_parent)->fts_accpath;
#line 934
          p = p->fts_link;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 939
      tmp___4 = fts_build(sp, 3);
#line 939
      sp->fts_child = tmp___4;
      }
#line 939
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 940
        if (sp->fts_options & 16384) {
#line 941
          return ((FTSENT *)((void *)0));
        }
#line 945
        if (p->fts_errno) {
#line 945
          if ((int )p->fts_info != 4) {
#line 946
            p->fts_info = (unsigned short)7;
          }
        }
        {
#line 947
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 947
          leave_dir(sp, p);
          }
#line 947
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 948
        return (p);
      }
    }
#line 950
    p = sp->fts_child;
#line 951
    sp->fts_child = (struct _ftsent *)((void *)0);
#line 952
    goto name;
  }
  next: 
#line 956
  tmp = p;
#line 961
  if ((unsigned long )p->fts_link == (unsigned long )((void *)0)) {
#line 961
    if ((p->fts_parent)->fts_dirp) {
      {
#line 963
      p = tmp->fts_parent;
#line 964
      sp->fts_cur = p;
#line 965
      *(sp->fts_path + p->fts_pathlen) = (char )'\000';
#line 967
      p = fts_build(sp, 3);
      }
#line 967
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 969
        if (sp->fts_options & 16384) {
#line 970
          return ((FTSENT *)((void *)0));
        }
#line 971
        goto cd_dot_dot;
      }
      {
#line 974
      free((void *)tmp);
      }
#line 975
      goto name;
    }
  }
#line 978
  p = p->fts_link;
#line 978
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 979
    sp->fts_cur = p;
#line 980
    free((void *)tmp);
    }
#line 987
    if (p->fts_level == 0L) {
      {
#line 988
      tmp___5 = restore_initial_cwd(sp);
      }
#line 988
      if (tmp___5) {
#line 989
        sp->fts_options |= 16384;
#line 990
        return ((FTSENT *)((void *)0));
      }
      {
#line 992
      free_dir(sp);
#line 993
      fts_load(sp, p);
#line 994
      setup_dir(sp);
      }
#line 995
      goto check_for_dir;
    }
#line 1003
    if ((int )p->fts_instr == 4) {
#line 1004
      goto next;
    }
#line 1005
    if ((int )p->fts_instr == 2) {
      {
#line 1006
      p->fts_info = fts_stat(sp, p, (_Bool)1);
      }
#line 1007
      if ((int )p->fts_info == 1) {
#line 1007
        if (! (sp->fts_options & 4)) {
          {
#line 1008
          tmp___7 = diropen((FTS const   *)sp, ".");
#line 1008
          p->fts_symfd = tmp___7;
          }
#line 1008
          if (tmp___7 < 0) {
            {
#line 1009
            tmp___6 = __errno_location();
#line 1009
            p->fts_errno = *tmp___6;
#line 1010
            p->fts_info = (unsigned short)7;
            }
          } else {
#line 1012
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 1014
      p->fts_instr = (unsigned short)3;
    }
    name: 
#line 1017
    if ((int )*((p->fts_parent)->fts_path + ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
#line 1017
      tmp___8 = (p->fts_parent)->fts_pathlen - 1UL;
    } else {
#line 1017
      tmp___8 = (p->fts_parent)->fts_pathlen;
    }
    {
#line 1017
    t = sp->fts_path + tmp___8;
#line 1018
    tmp___9 = t;
#line 1018
    t ++;
#line 1018
    *tmp___9 = (char )'/';
#line 1019
    memmove((void *)t, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
    }
    check_for_dir: 
#line 1021
    sp->fts_cur = p;
#line 1022
    if ((int )p->fts_info == 11) {
#line 1024
      if (p->fts_statp[0].st_size == 2L) {
#line 1026
        parent = p->fts_parent;
#line 1027
        if (0L < p->fts_level) {
#line 1027
          if (parent->fts_n_dirs_remaining == 0UL) {
#line 1027
            if (sp->fts_options & 8) {
#line 1027
              if (sp->fts_options & 16) {
                {
#line 1027
                tmp___10 = link_count_optimize_ok((FTSENT const   *)parent);
                }
#line 1027
                if (! tmp___10) {
#line 1027
                  goto _L___4;
                }
              } else {
#line 1027
                goto _L___4;
              }
            } else {
#line 1027
              goto _L___4;
            }
          } else {
#line 1027
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
          {
#line 1039
          p->fts_info = fts_stat(sp, p, (_Bool)0);
          }
#line 1040
          if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
#line 1040
            if (p->fts_level != 0L) {
#line 1040
              if (parent->fts_n_dirs_remaining) {
#line 1043
                (parent->fts_n_dirs_remaining) --;
              }
            }
          }
        }
      } else {
        {
#line 1047
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1047
          if (! (p->fts_statp[0].st_size == 1L)) {
            {
#line 1047
            abort();
            }
          }
#line 1047
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 1050
    if ((int )p->fts_info == 1) {
#line 1055
      if (p->fts_level == 0L) {
#line 1056
        sp->fts_dev = p->fts_statp[0].st_dev;
      }
      {
#line 1058
      tmp___12 = enter_dir(sp, p);
      }
#line 1058
      if (! tmp___12) {
        {
#line 1060
        tmp___11 = __errno_location();
#line 1060
        *tmp___11 = 12;
        }
#line 1061
        return ((FTSENT *)((void *)0));
      }
    }
#line 1064
    return (p);
  }
  cd_dot_dot: 
  {
#line 1069
  p = tmp->fts_parent;
#line 1070
  sp->fts_cur = p;
#line 1071
  free((void *)tmp);
  }
#line 1073
  if (p->fts_level == -1L) {
    {
#line 1078
    free((void *)p);
#line 1079
    tmp___13 = __errno_location();
#line 1079
    *tmp___13 = 0;
#line 1080
    tmp___14 = (struct _ftsent *)((void *)0);
#line 1080
    sp->fts_cur = tmp___14;
    }
#line 1080
    return (tmp___14);
  }
  {
#line 1083
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1083
    if (! ((int )p->fts_info != 11)) {
      {
#line 1083
      abort();
      }
    }
#line 1083
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1086
  *(sp->fts_path + p->fts_pathlen) = (char )'\000';
#line 1094
  if (p->fts_level == 0L) {
    {
#line 1095
    tmp___16 = restore_initial_cwd(sp);
    }
#line 1095
    if (tmp___16) {
      {
#line 1096
      tmp___15 = __errno_location();
#line 1096
      p->fts_errno = *tmp___15;
#line 1097
      sp->fts_options |= 16384;
      }
    }
  } else
#line 1099
  if ((int )p->fts_flags & 2) {
#line 1100
    if (! (sp->fts_options & 4)) {
#line 1100
      if (sp->fts_options & 512) {
        {
#line 1100
        cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
#line 1100
        tmp___19 = 0;
        }
      } else {
        {
#line 1100
        tmp___18 = fchdir(p->fts_symfd);
#line 1100
        tmp___19 = tmp___18;
        }
      }
#line 1100
      if (tmp___19) {
        {
#line 1101
        tmp___17 = __errno_location();
#line 1101
        p->fts_errno = *tmp___17;
#line 1102
        sp->fts_options |= 16384;
        }
      }
    }
    {
#line 1104
    close(p->fts_symfd);
    }
  } else
#line 1105
  if (! ((int )p->fts_flags & 1)) {
    {
#line 1105
    tmp___21 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
    }
#line 1105
    if (tmp___21) {
      {
#line 1107
      tmp___20 = __errno_location();
#line 1107
      p->fts_errno = *tmp___20;
#line 1108
      sp->fts_options |= 16384;
      }
    }
  }
#line 1114
  if ((int )p->fts_info != 2) {
#line 1115
    if (p->fts_errno) {
#line 1115
      p->fts_info = (unsigned short)7;
    } else {
#line 1115
      p->fts_info = (unsigned short)6;
    }
#line 1116
    if (p->fts_errno == 0) {
      {
#line 1117
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1117
        leave_dir(sp, p);
        }
#line 1117
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 1119
  if (sp->fts_options & 16384) {
#line 1119
    tmp___22 = (FTSENT *)((void *)0);
  } else {
#line 1119
    tmp___22 = p;
  }
#line 1119
  return (tmp___22);
}
}
#line 1129
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) ,
                                                                       FTSENT *p ,
                                                                       int instr ) ;
#line 1129 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) , FTSENT *p ,
                                         int instr ) 
{ 
  int *tmp ;

  {
#line 1132
  if (instr != 0) {
#line 1132
    if (instr != 1) {
#line 1132
      if (instr != 2) {
#line 1132
        if (instr != 3) {
#line 1132
          if (instr != 4) {
            {
#line 1134
            tmp = __errno_location();
#line 1134
            *tmp = 22;
            }
#line 1135
            return (1);
          }
        }
      }
    }
  }
#line 1137
  p->fts_instr = (unsigned short )instr;
#line 1138
  return (0);
}
}
#line 1141
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                                                        int instr ) ;
#line 1141 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                          int instr ) 
{ 
  register FTSENT *p ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  struct _ftsent *tmp___1 ;
  struct _ftsent *tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 1147
  if (instr != 0) {
#line 1147
    if (instr != 8192) {
      {
#line 1148
      tmp = __errno_location();
#line 1148
      *tmp = 22;
      }
#line 1149
      return ((FTSENT *)((void *)0));
    }
  }
  {
#line 1153
  p = sp->fts_cur;
#line 1159
  tmp___0 = __errno_location();
#line 1159
  *tmp___0 = 0;
  }
#line 1162
  if (sp->fts_options & 16384) {
#line 1163
    return ((FTSENT *)((void *)0));
  }
#line 1166
  if ((int )p->fts_info == 9) {
#line 1167
    return (p->fts_link);
  }
#line 1174
  if ((int )p->fts_info != 1) {
#line 1175
    return ((FTSENT *)((void *)0));
  }
#line 1178
  if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
    {
#line 1179
    fts_lfree(sp->fts_child);
    }
  }
#line 1181
  if (instr == 8192) {
#line 1182
    sp->fts_options |= 8192;
#line 1183
    instr = 2;
  } else {
#line 1185
    instr = 1;
  }
#line 1194
  if (p->fts_level != 0L) {
    {
#line 1196
    tmp___1 = fts_build(sp, instr);
#line 1196
    sp->fts_child = tmp___1;
    }
#line 1196
    return (tmp___1);
  } else
#line 1194
  if ((int )*(p->fts_accpath + 0) == 47) {
    {
#line 1196
    tmp___1 = fts_build(sp, instr);
#line 1196
    sp->fts_child = tmp___1;
    }
#line 1196
    return (tmp___1);
  } else
#line 1194
  if (sp->fts_options & 4) {
    {
#line 1196
    tmp___1 = fts_build(sp, instr);
#line 1196
    sp->fts_child = tmp___1;
    }
#line 1196
    return (tmp___1);
  }
  {
#line 1198
  fd = diropen((FTS const   *)sp, ".");
  }
#line 1198
  if (fd < 0) {
#line 1199
    tmp___2 = (struct _ftsent *)((void *)0);
#line 1199
    sp->fts_child = tmp___2;
#line 1199
    return (tmp___2);
  }
  {
#line 1200
  sp->fts_child = fts_build(sp, instr);
  }
#line 1201
  if (sp->fts_options & 512) {
    {
#line 1203
    cwd_advance_fd(sp, fd, (_Bool)1);
    }
  } else {
    {
#line 1207
    tmp___5 = fchdir(fd);
    }
#line 1207
    if (tmp___5) {
      {
#line 1209
      tmp___3 = __errno_location();
#line 1209
      saved_errno = *tmp___3;
#line 1210
      close(fd);
#line 1211
      tmp___4 = __errno_location();
#line 1211
      *tmp___4 = saved_errno;
      }
#line 1212
      return ((FTSENT *)((void *)0));
    }
    {
#line 1214
    close(fd);
    }
  }
#line 1216
  return (sp->fts_child);
}
}
#line 1224 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static int fts_compare_ino(struct _ftsent  const  **a , struct _ftsent  const  **b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1227
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
#line 1227
    tmp___0 = -1;
  } else {
#line 1227
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
#line 1227
      tmp = 1;
    } else {
#line 1227
      tmp = 0;
    }
#line 1227
    tmp___0 = tmp;
  }
#line 1227
  return (tmp___0);
}
}
#line 1233 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void set_stat_type(struct stat *st , unsigned int dtype ) 
{ 
  mode_t type ;

  {
  {
#line 1239
  if (dtype == 6U) {
#line 1239
    goto case_6;
  }
#line 1242
  if (dtype == 2U) {
#line 1242
    goto case_2;
  }
#line 1245
  if (dtype == 4U) {
#line 1245
    goto case_4;
  }
#line 1248
  if (dtype == 1U) {
#line 1248
    goto case_1;
  }
#line 1251
  if (dtype == 10U) {
#line 1251
    goto case_10;
  }
#line 1254
  if (dtype == 8U) {
#line 1254
    goto case_8;
  }
#line 1257
  if (dtype == 12U) {
#line 1257
    goto case_12;
  }
#line 1260
  goto switch_default;
  case_6: /* CIL Label */ 
#line 1240
  type = (mode_t )24576;
#line 1241
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1243
  type = (mode_t )8192;
#line 1244
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1246
  type = (mode_t )16384;
#line 1247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1249
  type = (mode_t )4096;
#line 1250
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1252
  type = (mode_t )40960;
#line 1253
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1255
  type = (mode_t )32768;
#line 1256
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1258
  type = (mode_t )49152;
#line 1259
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1261
  type = (mode_t )0;
  switch_break: /* CIL Label */ ;
  }
#line 1263
  st->st_mode = type;
#line 1264
  return;
}
}
#line 1299 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static FTSENT *fts_build(FTS *sp , int type ) 
{ 
  register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *tail ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int dir_fd ;
  FTSENT *cur ;
  _Bool continue_readdir ;
  size_t max_entries ;
  DIR *dp ;
  int *tmp ;
  int *tmp___0 ;
  DIR *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  _Bool is_dir ;
  size_t d_namelen ;
  int *tmp___11 ;
  struct dirent *dp___0 ;
  struct dirent *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  _Bool tmp___17 ;
  int *tmp___18 ;
  _Bool skip_stat ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  _Bool tmp___25 ;

  {
#line 1316
  cur = sp->fts_cur;
#line 1317
  continue_readdir = (_Bool )(! (! cur->fts_dirp));
#line 1323
  if (continue_readdir) {
    {
#line 1325
    dp = cur->fts_dirp;
#line 1326
    dir_fd = dirfd(dp);
    }
#line 1327
    if (dir_fd < 0) {
      {
#line 1329
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1329
        closedir(cur->fts_dirp);
#line 1329
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1329
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1330
      if (type == 3) {
        {
#line 1332
        cur->fts_info = (unsigned short)4;
#line 1333
        tmp = __errno_location();
#line 1333
        cur->fts_errno = *tmp;
        }
      }
#line 1335
      return ((FTSENT *)((void *)0));
    }
  } else {
#line 1342
    if (sp->fts_options & 16) {
#line 1342
      if (sp->fts_options & 1) {
#line 1342
        if (cur->fts_level == 0L) {
#line 1342
          tmp___2 = 0;
        } else {
#line 1342
          tmp___2 = 131072;
        }
      } else {
#line 1342
        tmp___2 = 131072;
      }
    } else {
#line 1342
      tmp___2 = 0;
    }
#line 1342
    if (sp->fts_options & 2048) {
#line 1342
      tmp___3 = 262144;
    } else {
#line 1342
      tmp___3 = 0;
    }
#line 1342
    if (! (sp->fts_options & 4)) {
#line 1342
      if (sp->fts_options & 512) {
#line 1342
        tmp___4 = sp->fts_cwd_fd;
      } else {
#line 1342
        tmp___4 = -100;
      }
    } else {
#line 1342
      tmp___4 = -100;
    }
    {
#line 1342
    tmp___1 = opendirat(tmp___4, (char const   *)cur->fts_accpath, tmp___2 | tmp___3,
                        & dir_fd);
#line 1342
    cur->fts_dirp = tmp___1;
    }
#line 1342
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1344
      if (type == 3) {
        {
#line 1346
        cur->fts_info = (unsigned short)4;
#line 1347
        tmp___0 = __errno_location();
#line 1347
        cur->fts_errno = *tmp___0;
        }
      }
#line 1349
      return ((FTSENT *)((void *)0));
    }
#line 1354
    if ((int )cur->fts_info == 11) {
      {
#line 1355
      cur->fts_info = fts_stat(sp, cur, (_Bool)0);
      }
    } else
#line 1356
    if (sp->fts_options & 256) {
      {
#line 1363
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1363
        leave_dir(sp, cur);
        }
#line 1363
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1364
      fts_stat(sp, cur, (_Bool)0);
#line 1365
      tmp___6 = enter_dir(sp, cur);
      }
#line 1365
      if (! tmp___6) {
        {
#line 1367
        tmp___5 = __errno_location();
#line 1367
        *tmp___5 = 12;
        }
#line 1368
        return ((FTSENT *)((void *)0));
      }
    }
  }
#line 1380
  if (sp->fts_compar) {
#line 1380
    max_entries = 0xffffffffffffffffUL;
  } else {
#line 1380
    max_entries = (size_t )100000;
  }
#line 1387
  if (type == 2) {
#line 1388
    nlinks = (nlink_t )0;
#line 1390
    nostat = (_Bool)0;
  } else
#line 1391
  if (sp->fts_options & 8) {
#line 1391
    if (sp->fts_options & 16) {
#line 1392
      if (sp->fts_options & 32) {
#line 1392
        tmp___7 = 0;
      } else {
#line 1392
        tmp___7 = 2;
      }
#line 1392
      nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___7;
#line 1394
      nostat = (_Bool)1;
    } else {
#line 1396
      nlinks = (nlink_t )-1;
#line 1397
      nostat = (_Bool)0;
    }
  } else {
#line 1396
    nlinks = (nlink_t )-1;
#line 1397
    nostat = (_Bool)0;
  }
#line 1415
  if (continue_readdir) {
#line 1419
    descend = (_Bool)1;
  } else
#line 1421
  if (nlinks) {
#line 1421
    goto _L___0;
  } else
#line 1421
  if (type == 3) {
    _L___0: /* CIL Label */ 
#line 1422
    if (sp->fts_options & 512) {
      {
#line 1424
      dir_fd = dup_safer(dir_fd);
      }
#line 1425
      if (0 <= dir_fd) {
        {
#line 1426
        set_cloexec_flag(dir_fd, (_Bool)1);
        }
      }
    }
#line 1428
    if (dir_fd < 0) {
#line 1428
      goto _L;
    } else {
      {
#line 1428
      tmp___9 = fts_safe_changedir(sp, cur, dir_fd, (char const   *)((void *)0));
      }
#line 1428
      if (tmp___9) {
        _L: /* CIL Label */ 
#line 1429
        if (nlinks) {
#line 1429
          if (type == 3) {
            {
#line 1430
            tmp___8 = __errno_location();
#line 1430
            cur->fts_errno = *tmp___8;
            }
          }
        }
#line 1431
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
#line 1432
        descend = (_Bool)0;
        {
#line 1433
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1433
          closedir(cur->fts_dirp);
#line 1433
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1433
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1434
        if (sp->fts_options & 512) {
#line 1434
          if (0 <= dir_fd) {
            {
#line 1435
            close(dir_fd);
            }
          }
        }
#line 1436
        cur->fts_dirp = (DIR *)((void *)0);
      } else {
#line 1438
        descend = (_Bool)1;
      }
    }
  } else {
#line 1440
    descend = (_Bool)0;
  }
#line 1452
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
#line 1452
    len = cur->fts_pathlen - 1UL;
  } else {
#line 1452
    len = cur->fts_pathlen;
  }
#line 1453
  if (sp->fts_options & 4) {
#line 1454
    cp = sp->fts_path + len;
#line 1455
    tmp___10 = cp;
#line 1455
    cp ++;
#line 1455
    *tmp___10 = (char )'/';
  } else {
#line 1458
    cp = (char *)((void *)0);
  }
#line 1460
  len ++;
#line 1461
  maxlen = sp->fts_pathlen - len;
#line 1463
  level = cur->fts_level + 1L;
#line 1466
  doadjust = (_Bool)0;
#line 1467
  head = (FTSENT *)((void *)0);
#line 1468
  tail = (FTSENT *)((void *)0);
#line 1469
  nitems = (size_t )0;
  {
#line 1470
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1470
    if (! cur->fts_dirp) {
#line 1470
      goto while_break___2;
    }
    {
#line 1473
    tmp___11 = __errno_location();
#line 1473
    *tmp___11 = 0;
#line 1474
    tmp___12 = readdir(cur->fts_dirp);
#line 1474
    dp___0 = tmp___12;
    }
#line 1475
    if ((unsigned long )dp___0 == (unsigned long )((void *)0)) {
      {
#line 1476
      tmp___14 = __errno_location();
      }
#line 1476
      if (*tmp___14) {
        {
#line 1477
        tmp___13 = __errno_location();
#line 1477
        cur->fts_errno = *tmp___13;
        }
#line 1480
        if (continue_readdir) {
#line 1480
          cur->fts_info = (unsigned short)7;
        } else
#line 1480
        if (nitems) {
#line 1480
          cur->fts_info = (unsigned short)7;
        } else {
#line 1480
          cur->fts_info = (unsigned short)4;
        }
      }
#line 1483
      goto while_break___2;
    }
#line 1485
    if (! (sp->fts_options & 32)) {
#line 1485
      if ((int )dp___0->d_name[0] == 46) {
#line 1485
        if (! dp___0->d_name[1]) {
#line 1486
          goto while_continue___2;
        } else
#line 1485
        if ((int )dp___0->d_name[1] == 46) {
#line 1485
          if (! dp___0->d_name[2]) {
#line 1486
            goto while_continue___2;
          }
        }
      }
    }
    {
#line 1488
    d_namelen = strlen((char const   *)(dp___0->d_name));
#line 1489
    p = fts_alloc(sp, (char const   *)(dp___0->d_name), d_namelen);
    }
#line 1490
    if (! p) {
#line 1491
      goto mem1;
    }
#line 1492
    if (d_namelen >= maxlen) {
      {
#line 1494
      oldaddr = (void *)sp->fts_path;
#line 1495
      tmp___17 = fts_palloc(sp, (d_namelen + len) + 1UL);
      }
#line 1495
      if (! tmp___17) {
        mem1: 
        {
#line 1501
        tmp___15 = __errno_location();
#line 1501
        saved_errno = *tmp___15;
#line 1502
        free((void *)p);
#line 1503
        fts_lfree(head);
        }
        {
#line 1504
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1504
          closedir(cur->fts_dirp);
#line 1504
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1504
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1505
        cur->fts_info = (unsigned short)7;
#line 1506
        sp->fts_options |= 16384;
#line 1507
        tmp___16 = __errno_location();
#line 1507
        *tmp___16 = saved_errno;
        }
#line 1508
        return ((FTSENT *)((void *)0));
      }
#line 1511
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
#line 1512
        doadjust = (_Bool)1;
#line 1513
        if (sp->fts_options & 4) {
#line 1514
          cp = sp->fts_path + len;
        }
      }
#line 1516
      maxlen = sp->fts_pathlen - len;
    }
#line 1519
    new_len = len + d_namelen;
#line 1520
    if (new_len < len) {
      {
#line 1527
      free((void *)p);
#line 1528
      fts_lfree(head);
      }
      {
#line 1529
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1529
        closedir(cur->fts_dirp);
#line 1529
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1529
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1530
      cur->fts_info = (unsigned short)7;
#line 1531
      sp->fts_options |= 16384;
#line 1532
      tmp___18 = __errno_location();
#line 1532
      *tmp___18 = 36;
      }
#line 1533
      return ((FTSENT *)((void *)0));
    }
#line 1535
    p->fts_level = level;
#line 1536
    p->fts_parent = sp->fts_cur;
#line 1537
    p->fts_pathlen = new_len;
#line 1541
    p->fts_statp[0].st_ino = dp___0->d_ino;
#line 1544
    if (sp->fts_options & 4) {
      {
#line 1545
      p->fts_accpath = p->fts_path;
#line 1546
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
      }
    } else {
#line 1548
      p->fts_accpath = p->fts_name;
    }
#line 1550
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1550
      goto _L___1;
    } else
#line 1550
    if (sp->fts_options & 1024) {
      _L___1: /* CIL Label */ 
#line 1563
      if (sp->fts_options & 16) {
#line 1563
        if (sp->fts_options & 8) {
#line 1563
          if ((int )dp___0->d_type != 0) {
#line 1563
            if (! ((int )dp___0->d_type == 4)) {
#line 1563
              tmp___19 = 1;
            } else {
#line 1563
              tmp___19 = 0;
            }
          } else {
#line 1563
            tmp___19 = 0;
          }
        } else {
#line 1563
          tmp___19 = 0;
        }
      } else {
#line 1563
        tmp___19 = 0;
      }
      {
#line 1563
      skip_stat = (_Bool )tmp___19;
#line 1567
      p->fts_info = (unsigned short)11;
#line 1570
      set_stat_type(p->fts_statp, (unsigned int )dp___0->d_type);
#line 1571
      fts_set_stat_required(p, (_Bool )(! skip_stat));
      }
#line 1572
      if (sp->fts_options & 16) {
#line 1572
        if ((int )dp___0->d_type == 4) {
#line 1572
          tmp___20 = 1;
        } else {
#line 1572
          tmp___20 = 0;
        }
      } else {
#line 1572
        tmp___20 = 0;
      }
#line 1572
      is_dir = (_Bool )tmp___20;
    } else {
      {
#line 1575
      p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
#line 1576
      if ((int )p->fts_info == 1) {
#line 1576
        tmp___21 = 1;
      } else
#line 1576
      if ((int )p->fts_info == 2) {
#line 1576
        tmp___21 = 1;
      } else
#line 1576
      if ((int )p->fts_info == 5) {
#line 1576
        tmp___21 = 1;
      } else {
#line 1576
        tmp___21 = 0;
      }
#line 1576
      is_dir = (_Bool )tmp___21;
    }
#line 1582
    if (nlinks > 0UL) {
#line 1582
      if (is_dir) {
#line 1583
        nlinks -= (nlink_t )nostat;
      }
    }
#line 1586
    p->fts_link = (struct _ftsent *)((void *)0);
#line 1587
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 1588
      tail = p;
#line 1588
      head = tail;
    } else {
#line 1590
      tail->fts_link = p;
#line 1591
      tail = p;
    }
#line 1593
    nitems ++;
#line 1594
    if (max_entries <= nitems) {
#line 1598
      goto break_without_closedir;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1602
  if (cur->fts_dirp) {
    {
#line 1603
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1603
      closedir(cur->fts_dirp);
#line 1603
      cur->fts_dirp = (DIR *)((void *)0);
      }
#line 1603
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  break_without_closedir: 
#line 1611
  if (doadjust) {
    {
#line 1612
    fts_padjust(sp, head);
    }
  }
#line 1618
  if (sp->fts_options & 4) {
#line 1619
    if (len == sp->fts_pathlen) {
#line 1620
      cp --;
    } else
#line 1619
    if (nitems == 0UL) {
#line 1620
      cp --;
    }
#line 1621
    *cp = (char )'\000';
  }
#line 1631
  if (! continue_readdir) {
#line 1631
    if (descend) {
#line 1631
      if (type == 1) {
#line 1631
        goto _L___2;
      } else
#line 1631
      if (! nitems) {
        _L___2: /* CIL Label */ 
#line 1631
        if (cur->fts_level == 0L) {
          {
#line 1631
          tmp___22 = restore_initial_cwd(sp);
#line 1631
          tmp___24 = tmp___22;
          }
        } else {
          {
#line 1631
          tmp___23 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
#line 1631
          tmp___24 = tmp___23;
          }
        }
#line 1631
        if (tmp___24) {
          {
#line 1635
          cur->fts_info = (unsigned short)7;
#line 1636
          sp->fts_options |= 16384;
#line 1637
          fts_lfree(head);
          }
#line 1638
          return ((FTSENT *)((void *)0));
        }
      }
    }
  }
#line 1642
  if (! nitems) {
#line 1643
    if (type == 3) {
#line 1643
      if ((int )cur->fts_info != 4) {
#line 1643
        if ((int )cur->fts_info != 7) {
#line 1645
          cur->fts_info = (unsigned short)6;
        }
      }
    }
    {
#line 1646
    fts_lfree(head);
    }
#line 1647
    return ((FTSENT *)((void *)0));
  }
#line 1654
  if (nitems > 10000UL) {
#line 1654
    if (! sp->fts_compar) {
#line 1654
      if (sp->fts_options & 512) {
        {
#line 1654
        tmp___25 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
        }
#line 1654
        if (tmp___25) {
          {
#line 1658
          sp->fts_compar = & fts_compare_ino;
#line 1659
          head = fts_sort(sp, head, nitems);
#line 1660
          sp->fts_compar = (int (*)(struct _ftsent  const  ** , struct _ftsent  const  ** ))((void *)0);
          }
        }
      }
    }
  }
#line 1664
  if (sp->fts_compar) {
#line 1664
    if (nitems > 1UL) {
      {
#line 1665
      head = fts_sort(sp, head, nitems);
      }
    }
  }
#line 1666
  return (head);
}
}
#line 1813 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) 
{ 
  struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1817
  sbp = p->fts_statp;
#line 1820
  if (p->fts_level == 0L) {
#line 1820
    if (sp->fts_options & 1) {
#line 1821
      follow = (_Bool)1;
    }
  }
#line 1828
  if (sp->fts_options & 2) {
#line 1828
    goto _L;
  } else
#line 1828
  if (follow) {
    _L: /* CIL Label */ 
    {
#line 1829
    tmp___3 = stat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
    }
#line 1829
    if (tmp___3) {
      {
#line 1830
      tmp = __errno_location();
#line 1830
      saved_errno = *tmp;
#line 1831
      tmp___1 = __errno_location();
      }
#line 1831
      if (*tmp___1 == 2) {
        {
#line 1831
        tmp___2 = lstat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
        }
#line 1831
        if (tmp___2 == 0) {
          {
#line 1833
          tmp___0 = __errno_location();
#line 1833
          *tmp___0 = 0;
          }
#line 1834
          return ((unsigned short)13);
        }
      }
#line 1836
      p->fts_errno = saved_errno;
#line 1837
      goto err;
    }
  } else {
    {
#line 1839
    tmp___5 = fstatat(sp->fts_cwd_fd, (char const   */* __restrict  */)p->fts_accpath,
                      (struct stat */* __restrict  */)sbp, 256);
    }
#line 1839
    if (tmp___5) {
      {
#line 1841
      tmp___4 = __errno_location();
#line 1841
      p->fts_errno = *tmp___4;
      }
      err: 
      {
#line 1842
      memset((void *)sbp, 0, sizeof(struct stat ));
      }
#line 1843
      return ((unsigned short)10);
    }
  }
#line 1846
  if ((sbp->st_mode & 61440U) == 16384U) {
#line 1847
    if (sp->fts_options & 32) {
#line 1847
      tmp___6 = 0;
    } else {
#line 1847
      tmp___6 = 2;
    }
#line 1847
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
#line 1849
    if ((int )p->fts_name[0] == 46) {
#line 1849
      if (! p->fts_name[1]) {
#line 1849
        goto _L___0;
      } else
#line 1849
      if ((int )p->fts_name[1] == 46) {
#line 1849
        if (! p->fts_name[2]) {
          _L___0: /* CIL Label */ 
#line 1851
          if (p->fts_level == 0L) {
#line 1851
            tmp___7 = 1;
          } else {
#line 1851
            tmp___7 = 5;
          }
#line 1851
          return ((unsigned short )tmp___7);
        }
      }
    }
#line 1854
    return ((unsigned short)1);
  }
#line 1856
  if ((sbp->st_mode & 61440U) == 40960U) {
#line 1857
    return ((unsigned short)12);
  }
#line 1858
  if ((sbp->st_mode & 61440U) == 32768U) {
#line 1859
    return ((unsigned short)8);
  }
#line 1860
  return ((unsigned short)3);
}
}
#line 1863 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static int fts_compar(void const   *a , void const   *b ) 
{ 
  FTSENT const   **pa ;
  FTSENT const   **pb ;
  int tmp ;

  {
  {
#line 1871
  pa = (FTSENT const   **)a;
#line 1872
  pb = (FTSENT const   **)b;
#line 1873
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
  }
#line 1873
  return (tmp);
}
}
#line 1876 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) 
{ 
  register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare)(void const   * , void const   * ) ;
  int (*tmp)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;

  {
#line 1890
  if (sizeof(& dummy) == sizeof(void *)) {
#line 1890
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
#line 1890
      tmp = (int (*)(void const   * , void const   * ))sp->fts_compar;
    } else {
#line 1890
      tmp = & fts_compar;
    }
  } else {
#line 1890
    tmp = & fts_compar;
  }
#line 1890
  compare = tmp;
#line 1903
  if (nitems > sp->fts_nitems) {
#line 1906
    sp->fts_nitems = nitems + 40UL;
#line 1907
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
      {
#line 1910
      free((void *)sp->fts_array);
#line 1911
      sp->fts_array = (struct _ftsent **)((void *)0);
#line 1912
      sp->fts_nitems = (size_t )0;
      }
#line 1913
      return (head);
    } else {
      {
#line 1907
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
#line 1907
      a = (FTSENT **)tmp___0;
      }
#line 1907
      if (! a) {
        {
#line 1910
        free((void *)sp->fts_array);
#line 1911
        sp->fts_array = (struct _ftsent **)((void *)0);
#line 1912
        sp->fts_nitems = (size_t )0;
        }
#line 1913
        return (head);
      }
    }
#line 1915
    sp->fts_array = a;
  }
#line 1917
  ap = sp->fts_array;
#line 1917
  p = head;
  {
#line 1917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1917
    if (! p) {
#line 1917
      goto while_break;
    }
#line 1918
    tmp___1 = ap;
#line 1918
    ap ++;
#line 1918
    *tmp___1 = p;
#line 1917
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1919
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
#line 1920
  ap = sp->fts_array;
#line 1920
  head = *ap;
  }
  {
#line 1920
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1920
    nitems --;
#line 1920
    if (! nitems) {
#line 1920
      goto while_break___0;
    }
#line 1921
    (*(ap + 0))->fts_link = *(ap + 1);
#line 1920
    ap ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1922
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
#line 1923
  return (head);
}
}
#line 1926 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) 
{ 
  register FTSENT *p ;
  size_t len ;
  void *tmp ;

  {
  {
#line 1937
  len = ((((unsigned long )(& ((FTSENT *)0)->fts_name) + __alignof__(FTSENT )) - 1UL) + (namelen + 1UL)) & ~ (__alignof__(FTSENT ) - 1UL);
#line 1938
  tmp = malloc(len);
#line 1938
  p = (FTSENT *)tmp;
  }
#line 1938
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1939
    return ((FTSENT *)((void *)0));
  }
  {
#line 1942
  memcpy((void */* __restrict  */)(p->fts_name), (void const   */* __restrict  */)name,
         namelen);
#line 1943
  p->fts_name[namelen] = (char )'\000';
#line 1945
  p->fts_namelen = namelen;
#line 1946
  p->fts_fts = sp;
#line 1947
  p->fts_path = sp->fts_path;
#line 1948
  p->fts_errno = 0;
#line 1949
  p->fts_dirp = (DIR *)((void *)0);
#line 1950
  p->fts_flags = (unsigned short)0;
#line 1951
  p->fts_instr = (unsigned short)3;
#line 1952
  p->fts_number = 0L;
#line 1953
  p->fts_pointer = (void *)0;
  }
#line 1954
  return (p);
}
}
#line 1957 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void fts_lfree(FTSENT *head ) 
{ 
  register FTSENT *p ;

  {
  {
#line 1964
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1964
    p = head;
#line 1964
    if (! p) {
#line 1964
      goto while_break;
    }
#line 1965
    head = head->fts_link;
#line 1966
    if (p->fts_dirp) {
      {
#line 1967
      closedir(p->fts_dirp);
      }
    }
    {
#line 1968
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1970
  return;
}
}
#line 1979 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static _Bool fts_palloc(FTS *sp , size_t more ) 
{ 
  char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 1984
  new_len = (sp->fts_pathlen + more) + 256UL;
#line 1989
  if (new_len < sp->fts_pathlen) {
    {
#line 1990
    free((void *)sp->fts_path);
#line 1991
    sp->fts_path = (char *)((void *)0);
#line 1992
    tmp = __errno_location();
#line 1992
    *tmp = 36;
    }
#line 1993
    return ((_Bool)0);
  }
  {
#line 1995
  sp->fts_pathlen = new_len;
#line 1996
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
#line 1996
  p = (char *)tmp___0;
  }
#line 1997
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1998
    free((void *)sp->fts_path);
#line 1999
    sp->fts_path = (char *)((void *)0);
    }
#line 2000
    return ((_Bool)0);
  }
#line 2002
  sp->fts_path = p;
#line 2003
  return ((_Bool)1);
}
}
#line 2010 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void fts_padjust(FTS *sp , FTSENT *head ) 
{ 
  FTSENT *p ;
  char *addr ;

  {
#line 2015
  addr = sp->fts_path;
#line 2025
  p = sp->fts_child;
  {
#line 2025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2025
    if (! p) {
#line 2025
      goto while_break;
    }
    {
#line 2026
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2026
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 2026
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 2026
      p->fts_path = addr;
#line 2026
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2025
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 2029
  p = head;
  {
#line 2029
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2029
    if (! (p->fts_level >= 0L)) {
#line 2029
      goto while_break___1;
    }
    {
#line 2030
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2030
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 2030
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 2030
      p->fts_path = addr;
#line 2030
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2031
    if (p->fts_link) {
#line 2031
      p = p->fts_link;
    } else {
#line 2031
      p = p->fts_parent;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2033
  return;
}
}
#line 2035 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static size_t __attribute__((__pure__))  fts_maxarglen(char * const  *argv ) 
{ 
  size_t len ;
  size_t max ;

  {
#line 2041
  max = (size_t )0;
  {
#line 2041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2041
    if (! *argv) {
#line 2041
      goto while_break;
    }
    {
#line 2042
    len = strlen((char const   *)*argv);
    }
#line 2042
    if (len > max) {
#line 2043
      max = len;
    }
#line 2041
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2044
  return ((size_t __attribute__((__pure__))  )(max + 1UL));
}
}
#line 2056 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) 
{ 
  int ret ;
  _Bool is_dotdot ;
  int tmp ;
  int tmp___0 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___1 ;
  struct stat sb ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int oerrno ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 2061
  if (dir) {
    {
#line 2061
    tmp = strcmp(dir, "..");
    }
#line 2061
    if (tmp == 0) {
#line 2061
      tmp___0 = 1;
    } else {
#line 2061
      tmp___0 = 0;
    }
  } else {
#line 2061
    tmp___0 = 0;
  }
#line 2061
  is_dotdot = (_Bool )tmp___0;
#line 2068
  if (sp->fts_options & 4) {
#line 2070
    if (sp->fts_options & 512) {
#line 2070
      if (0 <= fd) {
        {
#line 2071
        close(fd);
        }
      }
    }
#line 2072
    return (0);
  }
#line 2075
  if (fd < 0) {
#line 2075
    if (is_dotdot) {
#line 2075
      if (sp->fts_options & 512) {
        {
#line 2082
        tmp___1 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
        }
#line 2082
        if (! tmp___1) {
          {
#line 2086
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
#line 2087
          is_dotdot = (_Bool)1;
          }
#line 2088
          if (0 <= parent_fd) {
#line 2090
            fd = parent_fd;
#line 2091
            dir = (char const   *)((void *)0);
          }
        }
      }
    }
  }
#line 2096
  newfd = fd;
#line 2097
  if (fd < 0) {
    {
#line 2097
    newfd = diropen((FTS const   *)sp, dir);
    }
#line 2097
    if (newfd < 0) {
#line 2098
      return (-1);
    }
  }
#line 2107
  if (sp->fts_options & 2) {
#line 2107
    goto _L;
  } else
#line 2107
  if (dir) {
    {
#line 2107
    tmp___4 = strcmp(dir, "..");
    }
#line 2107
    if (tmp___4 == 0) {
      _L: /* CIL Label */ 
      {
#line 2111
      tmp___2 = fstat(newfd, & sb);
      }
#line 2111
      if (tmp___2) {
#line 2113
        ret = -1;
#line 2114
        goto bail;
      }
#line 2116
      if (p->fts_statp[0].st_dev != sb.st_dev) {
        {
#line 2119
        tmp___3 = __errno_location();
#line 2119
        *tmp___3 = 2;
#line 2120
        ret = -1;
        }
#line 2121
        goto bail;
      } else
#line 2116
      if (p->fts_statp[0].st_ino != sb.st_ino) {
        {
#line 2119
        tmp___3 = __errno_location();
#line 2119
        *tmp___3 = 2;
#line 2120
        ret = -1;
        }
#line 2121
        goto bail;
      }
    }
  }
#line 2125
  if (sp->fts_options & 512) {
    {
#line 2127
    cwd_advance_fd(sp, newfd, (_Bool )(! is_dotdot));
    }
#line 2128
    return (0);
  }
  {
#line 2131
  ret = fchdir(newfd);
  }
  bail: 
#line 2133
  if (fd < 0) {
    {
#line 2135
    tmp___5 = __errno_location();
#line 2135
    oerrno = *tmp___5;
#line 2136
    close(newfd);
#line 2137
    tmp___6 = __errno_location();
#line 2137
    *tmp___6 = oerrno;
    }
  }
#line 2139
  return (ret);
}
}
#line 26 "/home/khheo/project/benchmark/grep-3.1/lib/filenamecat.h"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 377 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) mempcpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 37 "/home/khheo/project/benchmark/grep-3.1/lib/filenamecat-lgpl.c"
static char const   * __attribute__((__pure__)) longest_relative_suffix(char const   *f ) 
{ 


  {
#line 40
  f += 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! ((int const   )*f == 47)) {
#line 40
      goto while_break;
    }
#line 41
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 40
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((char const   */* __attribute__((__pure__)) */)f);
}
}
#line 60 "/home/khheo/project/benchmark/grep-3.1/lib/filenamecat-lgpl.c"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ 
  char const   *dirbase ;
  char *tmp ;
  size_t dirbaselen ;
  size_t tmp___0 ;
  size_t dirlen ;
  size_t needs_separator ;
  int tmp___1 ;
  char const   *base ;
  char const   * __attribute__((__pure__)) tmp___2 ;
  size_t baselen ;
  size_t tmp___3 ;
  char *p_concat ;
  void *tmp___4 ;
  char *p ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 63
  tmp = last_component(dir);
#line 63
  dirbase = (char const   *)tmp;
#line 64
  tmp___0 = base_len(dirbase);
#line 64
  dirbaselen = tmp___0;
#line 65
  dirlen = (size_t )(dirbase - dir) + dirbaselen;
  }
#line 66
  if (dirbaselen) {
#line 66
    if (! ((int const   )*(dirbase + (dirbaselen - 1UL)) == 47)) {
#line 66
      tmp___1 = 1;
    } else {
#line 66
      tmp___1 = 0;
    }
  } else {
#line 66
    tmp___1 = 0;
  }
  {
#line 66
  needs_separator = (size_t )tmp___1;
#line 68
  tmp___2 = longest_relative_suffix(abase);
#line 68
  base = (char const   *)tmp___2;
#line 69
  tmp___3 = strlen(base);
#line 69
  baselen = tmp___3;
#line 71
  tmp___4 = malloc(((dirlen + needs_separator) + baselen) + 1UL);
#line 71
  p_concat = (char *)tmp___4;
  }
#line 74
  if ((unsigned long )p_concat == (unsigned long )((void *)0)) {
#line 75
    return ((char *)((void *)0));
  }
  {
#line 77
  tmp___5 = mempcpy((void */* __restrict  */)p_concat, (void const   */* __restrict  */)dir,
                    dirlen);
#line 77
  p = (char *)tmp___5;
#line 78
  *p = (char )'/';
#line 79
  p += needs_separator;
  }
#line 81
  if (base_in_result) {
#line 82
    if ((int const   )*(abase + 0) == 47) {
#line 82
      tmp___6 = 1;
    } else {
#line 82
      tmp___6 = 0;
    }
#line 82
    *base_in_result = p - tmp___6;
  }
  {
#line 84
  tmp___7 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)base,
                    baselen);
#line 84
  p = (char *)tmp___7;
#line 85
  *p = (char )'\000';
  }
#line 87
  return (p_concat);
}
}
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-3.1/lib/fd-safer.c"
int fd_safer(int fd ) 
{ 
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 39
  if (0 <= fd) {
#line 39
    if (fd <= 2) {
      {
#line 41
      tmp = dup_safer(fd);
#line 41
      f = tmp;
#line 42
      tmp___0 = __errno_location();
#line 42
      e = *tmp___0;
#line 43
      close(fd);
#line 44
      tmp___1 = __errno_location();
#line 44
      *tmp___1 = e;
#line 45
      fd = f;
      }
    }
  }
#line 48
  return (fd);
}
}
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 543 "./fcntl.h"
int rpl_fcntl(int fd , int action  , ...) ;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 339 "/home/khheo/project/benchmark/grep-3.1/lib/fcntl.c"
static int have_dupfd_cloexec  =    0;
#line 275 "/home/khheo/project/benchmark/grep-3.1/lib/fcntl.c"
int rpl_fcntl(int fd , int action  , ...) 
{ 
  va_list arg ;
  int result ;
  int target ;
  int tmp___0 ;
  int *tmp___1 ;
  int flags ;
  int tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *p ;
  void *tmp___7 ;

  {
  {
#line 279
  result = -1;
#line 280
  __builtin_va_start(arg, action);
  }
  {
#line 324
  if (action == 1030) {
#line 324
    goto case_1030;
  }
#line 405
  goto switch_default;
  case_1030: /* CIL Label */ 
  {
#line 326
  tmp___0 = __builtin_va_arg(arg, int );
#line 326
  target = tmp___0;
  }
#line 340
  if (0 <= have_dupfd_cloexec) {
    {
#line 342
    result = fcntl(fd, action, target);
    }
#line 343
    if (0 <= result) {
#line 345
      have_dupfd_cloexec = 1;
    } else {
      {
#line 343
      tmp___1 = __errno_location();
      }
#line 343
      if (*tmp___1 != 22) {
#line 345
        have_dupfd_cloexec = 1;
      } else {
        {
#line 353
        result = rpl_fcntl(fd, 0, target);
        }
#line 354
        if (result < 0) {
#line 355
          goto switch_break;
        }
#line 356
        have_dupfd_cloexec = -1;
      }
    }
  } else {
    {
#line 360
    result = rpl_fcntl(fd, 0, target);
    }
  }
#line 361
  if (0 <= result) {
#line 361
    if (have_dupfd_cloexec == -1) {
      {
#line 363
      tmp___2 = fcntl(result, 1);
#line 363
      flags = tmp___2;
      }
#line 364
      if (flags < 0) {
#line 364
        goto _L;
      } else {
        {
#line 364
        tmp___5 = fcntl(result, 2, flags | 1);
        }
#line 364
        if (tmp___5 == -1) {
          _L: /* CIL Label */ 
          {
#line 366
          tmp___3 = __errno_location();
#line 366
          saved_errno = *tmp___3;
#line 367
          close(result);
#line 368
          tmp___4 = __errno_location();
#line 368
          *tmp___4 = saved_errno;
#line 369
          result = -1;
          }
        }
      }
    }
  }
#line 372
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 408
  tmp___7 = __builtin_va_arg(arg, void *);
#line 408
  p = tmp___7;
#line 409
  result = fcntl(fd, action, p);
  }
#line 413
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 416
  __builtin_va_end(arg);
  }
#line 417
  return (result);
}
}
#line 24 "/home/khheo/project/benchmark/grep-3.1/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 767
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 640 "./regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 644
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __String ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 652
extern void regfree(regex_t *__preg ) ;
#line 49 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.h"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options )  __attribute__((__pure__)) ;
#line 51
struct exclude *new_exclude(void) ;
#line 52
void free_exclude(struct exclude *ex ) ;
#line 53
void add_exclude(struct exclude *ex , char const   *pattern , int options ) ;
#line 54
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) ;
#line 56
int add_exclude_fp(void (*add_func)(struct exclude * , char const   * , int  , void * ) ,
                   struct exclude *ex , FILE *fp , int options , char line_end , void *data ) ;
#line 58
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) ;
#line 59
void exclude_add_pattern_buffer(struct exclude *ex , char *buf ) ;
#line 60
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) ;
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 131 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
void exclude_add_pattern_buffer(struct exclude *ex , char *buf ) 
{ 
  struct pattern_buffer *pbuf ;
  void *tmp ;

  {
  {
#line 134
  tmp = xmalloc(sizeof(*pbuf));
#line 134
  pbuf = (struct pattern_buffer *)tmp;
#line 135
  pbuf->base = buf;
#line 136
  pbuf->next = ex->patbuf;
#line 137
  ex->patbuf = pbuf;
  }
#line 138
  return;
}
}
#line 142
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options )  __attribute__((__pure__)) ;
#line 142 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    tmp = str;
#line 147
    str ++;
    {
#line 153
    if ((int const   )*tmp == 41) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 40) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 125) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 123) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 46) {
#line 153
      goto case_41;
    }
#line 158
    if ((int const   )*tmp == 92) {
#line 158
      goto case_92;
    }
#line 165
    if ((int const   )*tmp == 33) {
#line 165
      goto case_33;
    }
#line 165
    if ((int const   )*tmp == 64) {
#line 165
      goto case_33;
    }
#line 165
    if ((int const   )*tmp == 43) {
#line 165
      goto case_33;
    }
#line 170
    if ((int const   )*tmp == 91) {
#line 170
      goto case_91;
    }
#line 170
    if ((int const   )*tmp == 42) {
#line 170
      goto case_91;
    }
#line 170
    if ((int const   )*tmp == 63) {
#line 170
      goto case_91;
    }
#line 173
    if ((int const   )*tmp == 0) {
#line 173
      goto case_0;
    }
#line 147
    goto switch_break;
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 154
    if (options & (1 << 27)) {
#line 155
      return ((_Bool)1);
    }
#line 156
    goto switch_break;
    case_92: /* CIL Label */ 
#line 159
    if (options & (1 << 27)) {
#line 160
      goto while_continue;
    } else {
#line 162
      if (! (options & (1 << 1))) {
#line 162
        if (*str) {
#line 162
          tmp___0 = 1;
        } else {
#line 162
          tmp___0 = 0;
        }
      } else {
#line 162
        tmp___0 = 0;
      }
#line 162
      str += tmp___0;
    }
#line 163
    goto switch_break;
    case_33: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_43: /* CIL Label */ 
#line 166
    if (options & (1 << 5)) {
#line 166
      if ((int const   )*str == 40) {
#line 167
        return ((_Bool)1);
      }
    }
#line 168
    goto switch_break;
    case_91: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_63: /* CIL Label */ 
#line 171
    return ((_Bool)1);
    case_0: /* CIL Label */ 
#line 174
    return ((_Bool)0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 179 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static void unescape_pattern(char *str ) 
{ 
  char const   *q ;
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 182
  q = (char const   *)str;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if ((int const   )*q == 92) {
#line 184
      if (*(q + 1)) {
#line 184
        tmp = 1;
      } else {
#line 184
        tmp = 0;
      }
    } else {
#line 184
      tmp = 0;
    }
#line 184
    q += tmp;
#line 183
    tmp___0 = str;
#line 183
    str ++;
#line 183
    tmp___2 = q;
#line 183
    q ++;
#line 183
    tmp___1 = (char )*tmp___2;
#line 183
    *tmp___0 = tmp___1;
#line 183
    if (! tmp___1) {
#line 183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 190 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
struct exclude *new_exclude(void) 
{ 
  struct exclude *tmp ;
  void *tmp___0 ;

  {
  {
#line 193
  tmp___0 = xzalloc(sizeof(*tmp));
  }
#line 193
  return ((struct exclude *)tmp___0);
}
}
#line 197 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static size_t string_hasher(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  size_t tmp ;

  {
  {
#line 200
  p = (char const   *)data;
#line 201
  tmp = hash_string(p, n_buckets);
  }
#line 201
  return (tmp);
}
}
#line 205 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static size_t string_hasher_ci(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  mbui_iterator_t iter ;
  size_t value ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;

  {
  {
#line 208
  p = (char const   *)data;
#line 210
  value = (size_t )0;
#line 212
  iter.cur.ptr = p;
#line 212
  iter.in_shift = (_Bool)0;
#line 212
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 212
  iter.next_done = (_Bool)0;
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    mbuiter_multi_next(& iter);
    }
#line 212
    if (iter.cur.wc_valid) {
#line 212
      if (iter.cur.wc == 0) {
#line 212
        tmp___0 = 0;
      } else {
#line 212
        tmp___0 = 1;
      }
    } else {
#line 212
      tmp___0 = 1;
    }
#line 212
    if (! tmp___0) {
#line 212
      goto while_break;
    }
#line 214
    m = iter.cur;
#line 217
    if (m.wc_valid) {
      {
#line 218
      tmp = towlower((wint_t )m.wc);
#line 218
      wc = (wchar_t )tmp;
      }
    } else {
#line 220
      wc = (wchar_t )*(m.ptr);
    }
#line 222
    value = (value * 31UL + (size_t )wc) % n_buckets;
#line 212
    iter.cur.ptr += iter.cur.bytes;
#line 212
    iter.next_done = (_Bool)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return (value);
}
}
#line 229 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static _Bool string_compare(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 232
  p1 = (char const   *)data1;
#line 233
  p2 = (char const   *)data2;
#line 234
  tmp = strcmp(p1, p2);
  }
#line 234
  return ((_Bool )(tmp == 0));
}
}
#line 238 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static _Bool string_compare_ci(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 241
  p1 = (char const   *)data1;
#line 242
  p2 = (char const   *)data2;
#line 243
  tmp = mbscasecmp(p1, p2);
  }
#line 243
  return ((_Bool )(tmp == 0));
}
}
#line 246 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static void string_free(void *data ) 
{ 


  {
  {
#line 249
  free(data);
  }
#line 250
  return;
}
}
#line 254 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static void new_exclude_segment(struct exclude *ex , enum exclude_type type , int options ) 
{ 
  struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const   *data1 , void const   *data2 ) ;
  size_t (*tmp___1)(void const   *data , size_t n_buckets ) ;

  {
  {
#line 257
  tmp = xzalloc(sizeof(struct exclude_segment ));
#line 257
  sp = (struct exclude_segment *)tmp;
#line 258
  sp->type = type;
#line 259
  sp->options = options;
  }
  {
#line 262
  if ((unsigned int )type == 1U) {
#line 262
    goto case_1;
  }
#line 265
  if ((unsigned int )type == 0U) {
#line 265
    goto case_0;
  }
#line 260
  goto switch_break;
  case_1: /* CIL Label */ 
#line 263
  goto switch_break;
  case_0: /* CIL Label */ 
#line 266
  if (options & (1 << 4)) {
#line 266
    tmp___0 = & string_compare_ci;
  } else {
#line 266
    tmp___0 = & string_compare;
  }
#line 266
  if (options & (1 << 4)) {
#line 266
    tmp___1 = & string_hasher_ci;
  } else {
#line 266
    tmp___1 = & string_hasher;
  }
  {
#line 266
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0), tmp___1,
                                tmp___0, & string_free);
  }
#line 274
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 276
  sp->next = ex->head;
#line 277
  ex->head = sp;
#line 278
  return;
}
}
#line 281 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static void free_exclude_segment(struct exclude_segment *seg ) 
{ 
  size_t i ;

  {
  {
#line 288
  if ((unsigned int )seg->type == 1U) {
#line 288
    goto case_1;
  }
#line 297
  if ((unsigned int )seg->type == 0U) {
#line 297
    goto case_0;
  }
#line 286
  goto switch_break;
  case_1: /* CIL Label */ 
#line 289
  i = (size_t )0;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (i < seg->v.pat.exclude_count)) {
#line 289
      goto while_break;
    }
#line 291
    if ((seg->v.pat.exclude + i)->options & (1 << 27)) {
      {
#line 292
      regfree(& (seg->v.pat.exclude + i)->v.re);
      }
    }
#line 289
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  free((void *)seg->v.pat.exclude);
  }
#line 295
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 298
  hash_free(seg->v.table);
  }
#line 299
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 301
  free((void *)seg);
  }
#line 302
  return;
}
}
#line 305 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
void free_exclude(struct exclude *ex ) 
{ 
  struct exclude_segment *seg ;
  struct pattern_buffer *pbuf ;
  struct exclude_segment *next ;
  struct pattern_buffer *next___0 ;

  {
#line 311
  seg = ex->head;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! seg) {
#line 311
      goto while_break;
    }
    {
#line 313
    next = seg->next;
#line 314
    free_exclude_segment(seg);
#line 315
    seg = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  pbuf = ex->patbuf;
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    if (! pbuf) {
#line 318
      goto while_break___0;
    }
    {
#line 320
    next___0 = pbuf->next;
#line 321
    free((void *)pbuf->base);
#line 322
    free((void *)pbuf);
#line 323
    pbuf = next___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 326
  free((void *)ex);
  }
#line 327
  return;
}
}
#line 332 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static int fnmatch_no_wildcards(char const   *pattern , char const   *f , int options ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t patlen ;
  size_t tmp___2 ;
  int r ;
  int tmp___3 ;
  char *fcopy ;
  char *tmp___4 ;
  char *p ;
  int r___0 ;
  char *tmp___5 ;

  {
#line 335
  if (! (options & (1 << 3))) {
#line 336
    if (options & (1 << 4)) {
      {
#line 336
      tmp = mbscasecmp(pattern, f);
#line 336
      tmp___1 = tmp;
      }
    } else {
      {
#line 336
      tmp___0 = strcmp(pattern, f);
#line 336
      tmp___1 = tmp___0;
      }
    }
#line 336
    return (tmp___1);
  } else
#line 339
  if (! (options & (1 << 4))) {
    {
#line 341
    tmp___2 = strlen(pattern);
#line 341
    patlen = tmp___2;
#line 342
    tmp___3 = strncmp(pattern, f, patlen);
#line 342
    r = tmp___3;
    }
#line 343
    if (! r) {
#line 345
      r = (int )*(f + patlen);
#line 346
      if (r == 47) {
#line 347
        r = 0;
      }
    }
#line 349
    return (r);
  } else {
    {
#line 360
    tmp___4 = xstrdup(f);
#line 360
    fcopy = tmp___4;
#line 363
    p = fcopy;
    }
    {
#line 363
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 365
      p = strchr((char const   *)p, '/');
      }
#line 366
      if (p) {
#line 367
        *p = (char )'\000';
      }
      {
#line 368
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
      }
#line 369
      if (! p) {
#line 370
        goto while_break;
      } else
#line 369
      if (r___0 <= 0) {
#line 370
        goto while_break;
      }
#line 363
      tmp___5 = p;
#line 363
      p ++;
#line 363
      *tmp___5 = (char )'/';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 372
    free((void *)fcopy);
    }
#line 373
    return (r___0);
  }
}
}
#line 377 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) 
{ 
  int (*matcher)(char const   * , char const   * , int  ) ;
  int (*tmp)(char const   *__pattern , char const   *__name , int __flags ) ;
  _Bool matched ;
  int tmp___0 ;
  char const   *p ;
  int tmp___1 ;

  {
#line 380
  if (options & (1 << 28)) {
#line 380
    tmp = & fnmatch;
  } else {
#line 380
    tmp = & fnmatch_no_wildcards;
  }
  {
#line 380
  matcher = tmp;
#line 384
  tmp___0 = (*matcher)(pattern, f, options);
#line 384
  matched = (_Bool )(tmp___0 == 0);
  }
#line 387
  if (! (options & (1 << 30))) {
#line 388
    p = f;
    {
#line 388
    while (1) {
      while_continue: /* CIL Label */ ;
#line 388
      if (*p) {
#line 388
        if (! (! matched)) {
#line 388
          goto while_break;
        }
      } else {
#line 388
        goto while_break;
      }
#line 389
      if ((int const   )*p == 47) {
#line 389
        if ((int const   )*(p + 1) != 47) {
          {
#line 390
          tmp___1 = (*matcher)(pattern, p + 1, options);
#line 390
          matched = (_Bool )(tmp___1 == 0);
          }
        }
      }
#line 388
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 392
  return (matched);
}
}
#line 395 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static _Bool exclude_patopts(struct patopts  const  *opts , char const   *f ) 
{ 
  int options ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
#line 398
  options = (int )opts->options;
#line 400
  if (options & (1 << 27)) {
    {
#line 400
    tmp = regexec((regex_t const   */* __restrict  */)(& opts->v.re), (char const   */* __restrict  */)f,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
#line 400
    tmp___1 = tmp == 0;
    }
  } else {
    {
#line 400
    tmp___0 = exclude_fnmatch((char const   *)opts->v.pattern, f, options);
#line 400
    tmp___1 = (int )tmp___0;
    }
  }
#line 400
  return ((_Bool )tmp___1);
}
}
#line 407 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static _Bool file_pattern_matches(struct exclude_segment  const  *seg , char const   *f ) 
{ 
  size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  _Bool tmp ;

  {
#line 410
  exclude_count = (size_t )seg->v.pat.exclude_count;
#line 411
  exclude = (struct patopts  const  *)seg->v.pat.exclude;
#line 414
  i = (size_t )0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i < exclude_count)) {
#line 414
      goto while_break;
    }
    {
#line 416
    tmp = exclude_patopts(exclude + i, f);
    }
#line 416
    if (tmp) {
#line 417
      return ((_Bool)1);
    }
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return ((_Bool)0);
}
}
#line 425 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static _Bool file_name_matches(struct exclude_segment  const  *seg , char const   *f ,
                               char *buffer___0 ) 
{ 
  int options ;
  Hash_table *table ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 429
  options = (int )seg->options;
#line 430
  table = (Hash_table *)seg->v.table;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 435
    strcpy((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)f);
    }
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 439
      tmp = hash_lookup((Hash_table const   *)table, (void const   *)buffer___0);
      }
#line 439
      if (tmp) {
#line 440
        return ((_Bool)1);
      }
#line 441
      if (options & (1 << 3)) {
        {
#line 443
        tmp___0 = strrchr((char const   *)buffer___0, '/');
#line 443
        p = tmp___0;
        }
#line 444
        if (p) {
#line 446
          *p = (char)0;
#line 447
          goto while_continue___0;
        }
      }
#line 450
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 453
    if (! (options & (1 << 30))) {
      {
#line 455
      tmp___1 = strchr(f, '/');
#line 455
      f = (char const   *)tmp___1;
      }
#line 456
      if (f) {
#line 457
        f ++;
      }
    } else {
#line 460
      goto while_break;
    }
#line 432
    if (! f) {
#line 432
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  return ((_Bool)0);
}
}
#line 469 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) 
{ 
  struct exclude_segment *seg ;
  _Bool invert ;
  char *filename___0 ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
#line 473
  invert = (_Bool)0;
#line 474
  filename___0 = (char *)((void *)0);
#line 477
  if (! ex->head) {
#line 478
    return ((_Bool)0);
  }
#line 483
  seg = (struct exclude_segment *)ex->head;
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if ((unsigned int )seg->type == 0U) {
#line 487
      if (! filename___0) {
        {
#line 488
        tmp = strlen(f);
#line 488
        tmp___0 = xmalloc(tmp + 1UL);
#line 488
        filename___0 = (char *)tmp___0;
        }
      }
      {
#line 489
      tmp___1 = file_name_matches((struct exclude_segment  const  *)seg, f, filename___0);
      }
#line 489
      if (tmp___1) {
#line 490
        goto while_break;
      }
    } else {
      {
#line 494
      tmp___2 = file_pattern_matches((struct exclude_segment  const  *)seg, f);
      }
#line 494
      if (tmp___2) {
#line 495
        goto while_break;
      }
    }
#line 498
    if (! seg->next) {
#line 506
      invert = (_Bool)1;
#line 507
      goto while_break;
    }
#line 483
    seg = seg->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 511
  free((void *)filename___0);
  }
#line 512
  return ((_Bool )((int )invert ^ ! (seg->options & (1 << 29))));
}
}
#line 517 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
void add_exclude(struct exclude *ex , char const   *pattern , int options ) 
{ 
  struct exclude_segment *seg ;
  struct exclude_pattern *pat ;
  struct patopts *patopts ;
  void *tmp ;
  size_t tmp___0 ;
  int rc ;
  int cflags ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t len ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *str ;
  char *p ;
  int exclude_hash_flags ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
#line 524
  if (options & ((1 << 27) | (1 << 28))) {
    {
#line 524
    tmp___7 = fnmatch_pattern_has_wildcards(pattern, options);
    }
#line 524
    if (tmp___7) {
#line 527
      if (ex->head) {
#line 527
        if ((unsigned int )(ex->head)->type == 1U) {
#line 527
          if (! (((ex->head)->options & (1 << 29)) == (options & (1 << 29)))) {
            {
#line 530
            new_exclude_segment(ex, (enum exclude_type )1, options);
            }
          }
        } else {
          {
#line 530
          new_exclude_segment(ex, (enum exclude_type )1, options);
          }
        }
      } else {
        {
#line 530
        new_exclude_segment(ex, (enum exclude_type )1, options);
        }
      }
#line 532
      seg = ex->head;
#line 534
      pat = & seg->v.pat;
#line 535
      if (pat->exclude_count == pat->exclude_alloc) {
        {
#line 536
        tmp = x2nrealloc((void *)pat->exclude, & pat->exclude_alloc, sizeof(*(pat->exclude)));
#line 536
        pat->exclude = (struct patopts *)tmp;
        }
      }
#line 538
      tmp___0 = pat->exclude_count;
#line 538
      (pat->exclude_count) ++;
#line 538
      patopts = pat->exclude + tmp___0;
#line 540
      patopts->options = options;
#line 541
      if (options & (1 << 27)) {
#line 544
        if (options & (1 << 4)) {
#line 544
          tmp___1 = 1 << 1;
        } else {
#line 544
          tmp___1 = 0;
        }
#line 544
        cflags = ((1 << 3) | 1) | tmp___1;
#line 547
        if (options & (1 << 3)) {
          {
#line 550
          tmp___3 = strlen(pattern);
#line 550
          len = tmp___3;
          }
          {
#line 552
          while (1) {
            while_continue: /* CIL Label */ ;
#line 552
            if (len > 0UL) {
#line 552
              if (! ((int const   )*(pattern + (len - 1UL)) == 47)) {
#line 552
                goto while_break;
              }
            } else {
#line 552
              goto while_break;
            }
#line 553
            len --;
          }
          while_break: /* CIL Label */ ;
          }
#line 555
          if (len == 0UL) {
#line 556
            rc = 1;
          } else {
            {
#line 559
            tmp___4 = xmalloc(len + 7UL);
#line 559
            tmp___2 = (char *)tmp___4;
#line 560
            memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)pattern,
                   len);
#line 561
            strcpy((char */* __restrict  */)(tmp___2 + len), (char const   */* __restrict  */)"(/.*)?");
#line 562
            rc = regcomp((regex_t */* __restrict  */)(& patopts->v.re), (char const   */* __restrict  */)tmp___2,
                         cflags);
#line 563
            free((void *)tmp___2);
            }
          }
        } else {
          {
#line 567
          rc = regcomp((regex_t */* __restrict  */)(& patopts->v.re), (char const   */* __restrict  */)pattern,
                       cflags);
          }
        }
#line 569
        if (rc) {
#line 571
          (pat->exclude_count) --;
#line 572
          return;
        }
      } else {
#line 577
        if (options & (1 << 26)) {
          {
#line 579
          tmp___5 = xstrdup(pattern);
#line 579
          pattern = (char const   *)tmp___5;
#line 580
          exclude_add_pattern_buffer(ex, (char *)pattern);
          }
        }
#line 582
        patopts->v.pattern = pattern;
      }
    } else {
#line 524
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 588
    exclude_hash_flags = (((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4);
#line 590
    if (ex->head) {
#line 590
      if ((unsigned int )(ex->head)->type == 0U) {
#line 590
        if (! (((ex->head)->options & exclude_hash_flags) == (options & exclude_hash_flags))) {
          {
#line 593
          new_exclude_segment(ex, (enum exclude_type )0, options);
          }
        }
      } else {
        {
#line 593
        new_exclude_segment(ex, (enum exclude_type )0, options);
        }
      }
    } else {
      {
#line 593
      new_exclude_segment(ex, (enum exclude_type )0, options);
      }
    }
    {
#line 594
    seg = ex->head;
#line 596
    str = xstrdup(pattern);
    }
#line 597
    if ((options & ((1 << 28) | (1 << 1))) == 1 << 28) {
      {
#line 598
      unescape_pattern(str);
      }
    }
    {
#line 599
    tmp___6 = hash_insert(seg->v.table, (void const   *)str);
#line 599
    p = (char *)tmp___6;
    }
#line 600
    if ((unsigned long )p != (unsigned long )str) {
      {
#line 601
      free((void *)str);
      }
    }
  }
#line 603
  return;
}
}
#line 610 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
int add_exclude_fp(void (*add_func)(struct exclude * , char const   * , int  , void * ) ,
                   struct exclude *ex , FILE *fp , int options , char line_end , void *data ) 
{ 
  char *buf ;
  char *p ;
  char *pattern ;
  char const   *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *pattern_end ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
#line 616
  buf = (char *)((void *)0);
#line 620
  buf_alloc = (size_t )0;
#line 621
  buf_count = (size_t )0;
#line 623
  e = 0;
  {
#line 625
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 625
    c = getc_unlocked(fp);
    }
#line 625
    if (! (c != -1)) {
#line 625
      goto while_break;
    }
#line 627
    if (buf_count == buf_alloc) {
      {
#line 628
      tmp = x2realloc((void *)buf, & buf_alloc);
#line 628
      buf = (char *)tmp;
      }
    }
#line 629
    tmp___0 = buf_count;
#line 629
    buf_count ++;
#line 629
    *(buf + tmp___0) = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 632
  tmp___2 = ferror_unlocked(fp);
  }
#line 632
  if (tmp___2) {
    {
#line 633
    tmp___1 = __errno_location();
#line 633
    e = *tmp___1;
    }
  }
  {
#line 635
  tmp___3 = xrealloc((void *)buf, buf_count + 1UL);
#line 635
  buf = (char *)tmp___3;
#line 636
  *(buf + buf_count) = line_end;
  }
#line 637
  if (buf_count == 0UL) {
#line 637
    tmp___4 = 0;
  } else
#line 637
  if ((int )*(buf + (buf_count - 1UL)) == (int )line_end) {
#line 637
    tmp___4 = 0;
  } else {
#line 637
    tmp___4 = 1;
  }
  {
#line 637
  lim = (char const   *)((buf + buf_count) + tmp___4);
#line 639
  exclude_add_pattern_buffer(ex, buf);
#line 641
  pattern = buf;
#line 643
  p = buf;
  }
  {
#line 643
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 643
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 643
      goto while_break___0;
    }
#line 644
    if ((int )*p == (int )line_end) {
      {
#line 646
      pattern_end = p;
#line 648
      tmp___6 = __ctype_b_loc();
      }
#line 648
      if ((int const   )*(*tmp___6 + (int )((unsigned char )line_end)) & 8192) {
        {
#line 650
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 651
          if ((unsigned long )pattern_end == (unsigned long )pattern) {
#line 652
            goto next_pattern;
          } else {
            {
#line 653
            tmp___5 = __ctype_b_loc();
            }
#line 653
            if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*(pattern_end + -1))) & 8192)) {
#line 654
              goto while_break___1;
            }
          }
#line 650
          pattern_end --;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 657
      *pattern_end = (char )'\000';
#line 658
      (*add_func)(ex, (char const   *)pattern, options, data);
      }
      next_pattern: 
#line 661
      pattern = p + 1;
    }
#line 643
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 664
  tmp___7 = __errno_location();
#line 664
  *tmp___7 = e;
  }
#line 665
  if (e) {
#line 665
    tmp___8 = -1;
  } else {
#line 665
    tmp___8 = 0;
  }
#line 665
  return (tmp___8);
}
}
#line 668 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static void call_addfn(struct exclude *ex , char const   *pattern , int options ,
                       void *data ) 
{ 
  void (**addfnptr)(struct exclude * , char const   * , int  ) ;

  {
  {
#line 671
  addfnptr = (void (**)(struct exclude * , char const   * , int  ))data;
#line 672
  (*(*addfnptr))(ex, pattern, options);
  }
#line 673
  return;
}
}
#line 675 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) 
{ 
  _Bool use_stdin ;
  int tmp ;
  FILE *in ;
  int rc ;
  int tmp___0 ;

  {
#line 680
  if ((int const   )*(file_name___1 + 0) == 45) {
#line 680
    if (! *(file_name___1 + 1)) {
#line 680
      tmp = 1;
    } else {
#line 680
      tmp = 0;
    }
  } else {
#line 680
    tmp = 0;
  }
#line 680
  use_stdin = (_Bool )tmp;
#line 682
  rc = 0;
#line 684
  if (use_stdin) {
#line 685
    in = stdin;
  } else {
    {
#line 686
    in = fopen((char const   */* __restrict  */)file_name___1, (char const   */* __restrict  */)"r");
    }
#line 686
    if (! in) {
#line 687
      return (-1);
    }
  }
  {
#line 689
  rc = add_exclude_fp(& call_addfn, ex, in, options, line_end, (void *)(& add_func));
  }
#line 691
  if (! use_stdin) {
    {
#line 691
    tmp___0 = fclose(in);
    }
#line 691
    if (tmp___0 != 0) {
#line 692
      rc = -1;
    }
  }
#line 694
  return (rc);
}
}
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 30 "/home/khheo/project/benchmark/grep-3.1/lib/dup-safer.c"
int dup_safer(int fd ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = rpl_fcntl(fd, 0, 3);
  }
#line 33
  return (tmp);
}
}
#line 43 "/home/khheo/project/benchmark/grep-3.1/lib/dirname.h"
char *mdir_name(char const   *file ) ;
#line 45
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/dirname-lgpl.c"
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/home/khheo/project/benchmark/grep-3.1/lib/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
  }
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
  {
#line 81
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 51 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.h"
struct dfa *dfaalloc(void)  __attribute__((__malloc__)) ;
#line 71
void dfasyntax(struct dfa *dfa , struct localeinfo  const  *linfo , reg_syntax_t bits ,
               int dfaopts ) ;
#line 75
struct dfamust *dfamust(struct dfa  const  *d ) ;
#line 78
void dfamustfree(struct dfamust *dm ) ;
#line 83
void dfacomp(char const   *s , size_t len , struct dfa *d , _Bool searchflag ) ;
#line 97
char *dfaexec(struct dfa *d , char const   *begin , char *end , _Bool allow_nl , size_t *count ,
              _Bool *backref ) ;
#line 104
struct dfa *dfasuperset(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 107
_Bool dfaisfast(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 110
void dfafree(struct dfa *d ) ;
#line 118
void dfawarn(char const   *mesg ) ;
#line 123
void dfaerror(char const   *mesg ) ;
#line 108 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isalnum)(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isalpha)(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iscntrl)(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isdigit)(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) islower)(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isgraph)(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isprint)(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ispunct)(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isspace)(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isupper)(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isxdigit)(int  ) ;
#line 125
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 130
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isblank)(int  ) ;
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool streq(char const   *a , char const   *b ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = strcmp(a, b);
  }
#line 39
  return ((_Bool )(tmp == 0));
}
}
#line 42 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool isasciidigit(char c ) 
{ 
  int tmp ;

  {
#line 45
  if (48 <= (int )c) {
#line 45
    if ((int )c <= 57) {
#line 45
      tmp = 1;
    } else {
#line 45
      tmp = 0;
    }
  } else {
#line 45
    tmp = 0;
  }
#line 45
  return ((_Bool )tmp);
}
}
#line 288 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wctob)(wint_t __c ) ;
#line 301
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcrtomb)(char * __restrict  __s ,
                                                                                 wchar_t __wc ,
                                                                                 mbstate_t * __restrict  __ps ) ;
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 104 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static unsigned long const   CHARCLASS_WORD_MASK  =    (charclass_word const   )(((1UL << 63) << 1) - 1UL);
#line 119 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static unsigned char to_uchar___0(char ch ) 
{ 


  {
#line 122
  return ((unsigned char )ch);
}
}
#line 160 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int newline_constraint(int constraint ) 
{ 


  {
#line 163
  return ((constraint >> 6) & 7);
}
}
#line 165 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int letter_constraint(int constraint ) 
{ 


  {
#line 168
  return ((constraint >> 3) & 7);
}
}
#line 170 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int other_constraint(int constraint ) 
{ 


  {
#line 173
  return (constraint & 7);
}
}
#line 176 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool succeeds_in_context(int constraint , int prev , int curr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 179
  if (curr & 1) {
    {
#line 179
    tmp = other_constraint(constraint);
#line 179
    tmp___0 = tmp;
    }
  } else {
#line 179
    tmp___0 = 0;
  }
#line 179
  if (curr & 2) {
    {
#line 179
    tmp___1 = letter_constraint(constraint);
#line 179
    tmp___2 = tmp___1;
    }
  } else {
#line 179
    tmp___2 = 0;
  }
#line 179
  if (curr & 4) {
    {
#line 179
    tmp___3 = newline_constraint(constraint);
#line 179
    tmp___4 = tmp___3;
    }
  } else {
#line 179
    tmp___4 = 0;
  }
#line 179
  if (((tmp___0 | tmp___2) | tmp___4) & prev) {
#line 179
    tmp___5 = 1;
  } else {
#line 179
    tmp___5 = 0;
  }
#line 179
  return ((_Bool )tmp___5);
}
}
#line 186 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool prev_newline_dependent(int constraint ) 
{ 


  {
#line 189
  return ((_Bool )(((constraint ^ (constraint >> 2)) & 73) != 0));
}
}
#line 191 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool prev_letter_dependent(int constraint ) 
{ 


  {
#line 194
  return ((_Bool )(((constraint ^ (constraint >> 1)) & 73) != 0));
}
}
#line 217 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static long const   TOKEN_MAX  =    (ptrdiff_t const   )9223372036854775807L;
#line 574 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool accepting(state_num s , struct dfa  const  *r ) 
{ 


  {
#line 577
  return ((_Bool )((int )(r->states + s)->constraint != 0));
}
}
#line 581 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool accepts_in_context(int prev , int curr , state_num state , struct dfa  const  *dfa ) 
{ 
  _Bool tmp ;

  {
  {
#line 584
  tmp = succeeds_in_context((int )(dfa->states + state)->constraint, prev, curr);
  }
#line 584
  return (tmp);
}
}
#line 587
static void regexp(struct dfa *dfa ) ;
#line 606 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static size_t mbs_to_wchar(wint_t *pwc , char const   *s , size_t n , struct dfa *d ) 
{ 
  unsigned char uc ;
  wint_t wc ;
  wchar_t wch ;
  size_t nbytes ;
  size_t tmp ;

  {
#line 609
  uc = (unsigned char )*(s + 0);
#line 610
  wc = d->localeinfo.sbctowc[uc];
#line 612
  if (wc == 4294967295U) {
    {
#line 615
    tmp = rpl_mbrtowc(& wch, s, n, & d->mbs);
#line 615
    nbytes = tmp;
    }
#line 616
    if (0UL < nbytes) {
#line 616
      if (nbytes < 0xfffffffffffffffeUL) {
#line 618
        *pwc = (wint_t )wch;
#line 619
        return (nbytes);
      }
    }
    {
#line 621
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
  }
#line 624
  *pwc = wc;
#line 625
  return ((size_t )1);
}
}
#line 707 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool tstbit(unsigned int b , charclass const   *c ) 
{ 


  {
#line 710
  return ((_Bool )((c->w[b / 64U] >> b % 64U) & 1UL));
}
}
#line 713 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void setbit(unsigned int b , charclass *c ) 
{ 
  charclass_word one ;

  {
#line 716
  one = (charclass_word )1;
#line 717
  c->w[b / 64U] |= one << b % 64U;
#line 718
  return;
}
}
#line 720 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void clrbit(unsigned int b , charclass *c ) 
{ 
  charclass_word one ;

  {
#line 723
  one = (charclass_word )1;
#line 724
  c->w[b / 64U] &= ~ (one << b % 64U);
#line 725
  return;
}
}
#line 727 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void zeroset(charclass *s ) 
{ 


  {
  {
#line 730
  memset((void *)s, 0, sizeof(*s));
  }
#line 731
  return;
}
}
#line 733 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void fillset(charclass *s ) 
{ 
  int i ;

  {
#line 736
  i = 0;
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (! (i < 4)) {
#line 736
      goto while_break;
    }
#line 737
    s->w[i] = (charclass_word )CHARCLASS_WORD_MASK;
#line 736
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 738
  return;
}
}
#line 740 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void notset(charclass *s ) 
{ 
  int i ;

  {
#line 743
  i = 0;
  {
#line 743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 743
    if (! (i < 4)) {
#line 743
      goto while_break;
    }
#line 744
    s->w[i] = (charclass_word )(CHARCLASS_WORD_MASK & (unsigned long const   )(~ s->w[i]));
#line 743
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 745
  return;
}
}
#line 747 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool equal(charclass const   *s1 , charclass const   *s2 ) 
{ 
  charclass_word w ;
  int i ;

  {
#line 750
  w = (charclass_word )0;
#line 751
  i = 0;
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 751
    if (! (i < 4)) {
#line 751
      goto while_break;
    }
#line 752
    w |= s1->w[i] ^ s2->w[i];
#line 751
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 753
  return ((_Bool )(w == 0UL));
}
}
#line 756 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool emptyset(charclass const   *s ) 
{ 
  charclass_word w ;
  int i ;

  {
#line 759
  w = (charclass_word )0;
#line 760
  i = 0;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! (i < 4)) {
#line 760
      goto while_break;
    }
#line 761
    w |= s->w[i];
#line 760
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 762
  return ((_Bool )(w == 0UL));
}
}
#line 781 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void *xpalloc(void *pa , ptrdiff_t *nitems , ptrdiff_t nitems_incr_min , ptrdiff_t nitems_max ,
                     ptrdiff_t item_size ) 
{ 
  ptrdiff_t n0 ;
  ptrdiff_t n ;
  ptrdiff_t nbytes ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  ptrdiff_t adjusted_nbytes ;
  int tmp___217 ;
  unsigned long tmp___218 ;
  int tmp___224 ;
  int tmp___225 ;
  int tmp___226 ;
  int tmp___227 ;
  int tmp___228 ;
  int tmp___229 ;
  int tmp___235 ;
  int tmp___236 ;
  int tmp___237 ;
  int tmp___238 ;
  int tmp___239 ;
  int tmp___240 ;
  int tmp___241 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  int tmp___251 ;
  int tmp___252 ;
  int tmp___258 ;
  int tmp___259 ;
  int tmp___260 ;
  int tmp___261 ;
  int tmp___262 ;
  int tmp___263 ;
  int tmp___264 ;
  int tmp___270 ;
  int tmp___271 ;
  int tmp___272 ;
  int tmp___273 ;
  int tmp___274 ;
  int tmp___275 ;
  int tmp___281 ;
  int tmp___282 ;
  int tmp___283 ;
  int tmp___284 ;
  int tmp___285 ;
  int tmp___286 ;
  int tmp___287 ;
  int tmp___293 ;
  int tmp___294 ;
  int tmp___295 ;
  int tmp___296 ;
  int tmp___297 ;
  int tmp___298 ;
  int tmp___304 ;
  int tmp___305 ;
  int tmp___306 ;
  int tmp___307 ;
  int tmp___308 ;
  int tmp___309 ;
  int tmp___310 ;
  int tmp___316 ;
  int tmp___317 ;
  int tmp___318 ;
  int tmp___319 ;
  int tmp___320 ;
  int tmp___321 ;
  int tmp___327 ;
  int tmp___328 ;
  int tmp___329 ;
  int tmp___330 ;
  int tmp___331 ;
  int tmp___332 ;
  int tmp___333 ;
  int tmp___334 ;
  int tmp___335 ;
  int tmp___336 ;
  int tmp___337 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___344 ;
  int tmp___345 ;
  int tmp___346 ;
  int tmp___351 ;
  int tmp___352 ;
  int tmp___353 ;
  int tmp___354 ;
  int tmp___355 ;
  int tmp___356 ;
  int tmp___361 ;
  int tmp___362 ;
  int tmp___363 ;
  int tmp___364 ;
  int tmp___365 ;
  int tmp___370 ;
  int tmp___371 ;
  int tmp___372 ;
  int tmp___373 ;
  int tmp___374 ;
  int tmp___375 ;
  int tmp___380 ;
  int tmp___381 ;
  int tmp___382 ;
  int tmp___383 ;
  int tmp___384 ;
  int tmp___389 ;
  int tmp___390 ;
  int tmp___391 ;
  int tmp___392 ;
  int tmp___393 ;
  int tmp___394 ;
  int tmp___399 ;
  int tmp___400 ;
  int tmp___401 ;
  int tmp___402 ;
  int tmp___403 ;
  int tmp___408 ;
  int tmp___409 ;
  int tmp___410 ;
  int tmp___411 ;
  int tmp___412 ;
  int tmp___413 ;
  int tmp___418 ;
  int tmp___419 ;
  int tmp___420 ;
  int tmp___421 ;
  int tmp___422 ;
  int tmp___427 ;
  int tmp___428 ;
  int tmp___429 ;
  int tmp___430 ;
  int tmp___431 ;
  int tmp___432 ;
  int tmp___433 ;
  int tmp___434 ;
  int tmp___435 ;
  int tmp___436 ;
  int tmp___442 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___445 ;
  int tmp___446 ;
  int tmp___447 ;
  int tmp___453 ;
  int tmp___454 ;
  int tmp___455 ;
  int tmp___456 ;
  int tmp___457 ;
  int tmp___458 ;
  int tmp___459 ;
  int tmp___465 ;
  int tmp___466 ;
  int tmp___467 ;
  int tmp___468 ;
  int tmp___469 ;
  int tmp___470 ;
  int tmp___476 ;
  int tmp___477 ;
  int tmp___478 ;
  int tmp___479 ;
  int tmp___480 ;
  int tmp___481 ;
  int tmp___482 ;
  int tmp___488 ;
  int tmp___489 ;
  int tmp___490 ;
  int tmp___491 ;
  int tmp___492 ;
  int tmp___493 ;
  int tmp___499 ;
  int tmp___500 ;
  int tmp___501 ;
  int tmp___502 ;
  int tmp___503 ;
  int tmp___504 ;
  int tmp___505 ;
  int tmp___511 ;
  int tmp___512 ;
  int tmp___513 ;
  int tmp___514 ;
  int tmp___515 ;
  int tmp___516 ;
  int tmp___522 ;
  int tmp___523 ;
  int tmp___524 ;
  int tmp___525 ;
  int tmp___526 ;
  int tmp___527 ;
  int tmp___528 ;
  int tmp___534 ;
  int tmp___535 ;
  int tmp___536 ;
  int tmp___537 ;
  int tmp___538 ;
  int tmp___539 ;
  int tmp___545 ;
  int tmp___546 ;
  int tmp___547 ;
  int tmp___548 ;
  int tmp___549 ;
  int tmp___550 ;
  int tmp___551 ;
  int tmp___552 ;
  int tmp___553 ;
  int tmp___554 ;
  int tmp___555 ;

  {
#line 785
  n0 = *nitems;
#line 798
  if (sizeof(n) == sizeof(signed char )) {
#line 798
    if (sizeof(n0 + (n0 >> 1)) < sizeof(signed char )) {
#line 798
      if (~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 798
        if ((int )((signed char )(n0 >> 1)) < 0) {
#line 798
          tmp___4 = (int )((signed char )n0) < ~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )(n0 >> 1));
        } else {
#line 798
          tmp___4 = (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )(n0 >> 1)) < (int )((signed char )n0);
        }
#line 798
        tmp___7 = tmp___4;
      } else {
#line 798
        if ((int )((signed char )n0) < 0) {
#line 798
          tmp___6 = (int )((signed char )(n0 >> 1)) <= (int )((signed char )n0) + (int )((signed char )(n0 >> 1));
        } else {
#line 798
          if ((int )((signed char )(n0 >> 1)) < 0) {
#line 798
            tmp___5 = (int )((signed char )n0) <= (int )((signed char )n0) + (int )((signed char )(n0 >> 1));
          } else {
#line 798
            tmp___5 = (int )((signed char )n0) + (int )((signed char )(n0 >> 1)) < (int )((signed char )(n0 >> 1));
          }
#line 798
          tmp___6 = tmp___5;
        }
#line 798
        tmp___7 = tmp___6;
      }
#line 798
      if (tmp___7) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )(n0 >> 1))));
#line 798
        tmp___3 = 1;
      } else
#line 798
      if ((int )((signed char )n0) + (int )((signed char )(n0 >> 1)) < -128) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )(n0 >> 1))));
#line 798
        tmp___3 = 1;
      } else
#line 798
      if (127 < (int )((signed char )n0) + (int )((signed char )(n0 >> 1))) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )(n0 >> 1))));
#line 798
        tmp___3 = 1;
      } else {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )(n0 >> 1))));
#line 798
        tmp___3 = 0;
      }
#line 798
      tmp___17 = tmp___3;
    } else {
#line 798
      if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
        if (n0 >> 1 < 0L) {
#line 798
          tmp___13 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
        } else {
#line 798
          tmp___13 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
        }
#line 798
        tmp___16 = tmp___13;
      } else {
#line 798
        if (n0 < 0L) {
#line 798
          tmp___15 = n0 >> 1 <= n0 + (n0 >> 1);
        } else {
#line 798
          if (n0 >> 1 < 0L) {
#line 798
            tmp___14 = n0 <= n0 + (n0 >> 1);
          } else {
#line 798
            tmp___14 = n0 + (n0 >> 1) < n0 >> 1;
          }
#line 798
          tmp___15 = tmp___14;
        }
#line 798
        tmp___16 = tmp___15;
      }
#line 798
      if (tmp___16) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
        tmp___12 = 1;
      } else
#line 798
      if (n0 + (n0 >> 1) < -128L) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
        tmp___12 = 1;
      } else
#line 798
      if (127L < n0 + (n0 >> 1)) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
        tmp___12 = 1;
      } else {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
        tmp___12 = 0;
      }
#line 798
      tmp___17 = tmp___12;
    }
#line 798
    tmp___97 = tmp___17;
  } else {
#line 798
    if (sizeof(n) == sizeof(short )) {
#line 798
      if (sizeof(n0 + (n0 >> 1)) < sizeof(short )) {
#line 798
        if (~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 798
          if ((int )((short )(n0 >> 1)) < 0) {
#line 798
            tmp___23 = (int )((short )n0) < ~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )(n0 >> 1));
          } else {
#line 798
            tmp___23 = (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )(n0 >> 1)) < (int )((short )n0);
          }
#line 798
          tmp___26 = tmp___23;
        } else {
#line 798
          if ((int )((short )n0) < 0) {
#line 798
            tmp___25 = (int )((short )(n0 >> 1)) <= (int )((short )n0) + (int )((short )(n0 >> 1));
          } else {
#line 798
            if ((int )((short )(n0 >> 1)) < 0) {
#line 798
              tmp___24 = (int )((short )n0) <= (int )((short )n0) + (int )((short )(n0 >> 1));
            } else {
#line 798
              tmp___24 = (int )((short )n0) + (int )((short )(n0 >> 1)) < (int )((short )(n0 >> 1));
            }
#line 798
            tmp___25 = tmp___24;
          }
#line 798
          tmp___26 = tmp___25;
        }
#line 798
        if (tmp___26) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )(n0 >> 1))));
#line 798
          tmp___22 = 1;
        } else
#line 798
        if ((int )((short )n0) + (int )((short )(n0 >> 1)) < -32768) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )(n0 >> 1))));
#line 798
          tmp___22 = 1;
        } else
#line 798
        if (32767 < (int )((short )n0) + (int )((short )(n0 >> 1))) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )(n0 >> 1))));
#line 798
          tmp___22 = 1;
        } else {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )(n0 >> 1))));
#line 798
          tmp___22 = 0;
        }
#line 798
        tmp___36 = tmp___22;
      } else {
#line 798
        if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
          if (n0 >> 1 < 0L) {
#line 798
            tmp___32 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
          } else {
#line 798
            tmp___32 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
          }
#line 798
          tmp___35 = tmp___32;
        } else {
#line 798
          if (n0 < 0L) {
#line 798
            tmp___34 = n0 >> 1 <= n0 + (n0 >> 1);
          } else {
#line 798
            if (n0 >> 1 < 0L) {
#line 798
              tmp___33 = n0 <= n0 + (n0 >> 1);
            } else {
#line 798
              tmp___33 = n0 + (n0 >> 1) < n0 >> 1;
            }
#line 798
            tmp___34 = tmp___33;
          }
#line 798
          tmp___35 = tmp___34;
        }
#line 798
        if (tmp___35) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
          tmp___31 = 1;
        } else
#line 798
        if (n0 + (n0 >> 1) < -32768L) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
          tmp___31 = 1;
        } else
#line 798
        if (32767L < n0 + (n0 >> 1)) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
          tmp___31 = 1;
        } else {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
          tmp___31 = 0;
        }
#line 798
        tmp___36 = tmp___31;
      }
#line 798
      tmp___96 = tmp___36;
    } else {
#line 798
      if (sizeof(n) == sizeof(int )) {
#line 798
        if (sizeof(n0 + (n0 >> 1)) < sizeof(int )) {
#line 798
          if (~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 798
            if ((int )(n0 >> 1) < 0) {
#line 798
              tmp___42 = (int )n0 < ~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )(n0 >> 1);
            } else {
#line 798
              tmp___42 = (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )(n0 >> 1) < (int )n0;
            }
#line 798
            tmp___45 = tmp___42;
          } else {
#line 798
            if ((int )n0 < 0) {
#line 798
              tmp___44 = (int )(n0 >> 1) <= (int )n0 + (int )(n0 >> 1);
            } else {
#line 798
              if ((int )(n0 >> 1) < 0) {
#line 798
                tmp___43 = (int )n0 <= (int )n0 + (int )(n0 >> 1);
              } else {
#line 798
                tmp___43 = (int )n0 + (int )(n0 >> 1) < (int )(n0 >> 1);
              }
#line 798
              tmp___44 = tmp___43;
            }
#line 798
            tmp___45 = tmp___44;
          }
#line 798
          if (tmp___45) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
#line 798
            tmp___41 = 1;
          } else
#line 798
          if ((int )n0 + (int )(n0 >> 1) < (-0x7FFFFFFF-1)) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
#line 798
            tmp___41 = 1;
          } else
#line 798
          if (2147483647 < (int )n0 + (int )(n0 >> 1)) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
#line 798
            tmp___41 = 1;
          } else {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
#line 798
            tmp___41 = 0;
          }
#line 798
          tmp___55 = tmp___41;
        } else {
#line 798
          if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
            if (n0 >> 1 < 0L) {
#line 798
              tmp___51 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
            } else {
#line 798
              tmp___51 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
            }
#line 798
            tmp___54 = tmp___51;
          } else {
#line 798
            if (n0 < 0L) {
#line 798
              tmp___53 = n0 >> 1 <= n0 + (n0 >> 1);
            } else {
#line 798
              if (n0 >> 1 < 0L) {
#line 798
                tmp___52 = n0 <= n0 + (n0 >> 1);
              } else {
#line 798
                tmp___52 = n0 + (n0 >> 1) < n0 >> 1;
              }
#line 798
              tmp___53 = tmp___52;
            }
#line 798
            tmp___54 = tmp___53;
          }
#line 798
          if (tmp___54) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
            tmp___50 = 1;
          } else
#line 798
          if (n0 + (n0 >> 1) < (-0x7FFFFFFF-1)) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
            tmp___50 = 1;
          } else
#line 798
          if (2147483647L < n0 + (n0 >> 1)) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
            tmp___50 = 1;
          } else {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
            tmp___50 = 0;
          }
#line 798
          tmp___55 = tmp___50;
        }
#line 798
        tmp___95 = tmp___55;
      } else {
#line 798
        if (sizeof(n) == sizeof(long )) {
#line 798
          if (sizeof(n0 + (n0 >> 1)) < sizeof(long )) {
#line 798
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
              if (n0 >> 1 < 0L) {
#line 798
                tmp___61 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 798
                tmp___61 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 798
              tmp___64 = tmp___61;
            } else {
#line 798
              if (n0 < 0L) {
#line 798
                tmp___63 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 798
                if (n0 >> 1 < 0L) {
#line 798
                  tmp___62 = n0 <= n0 + (n0 >> 1);
                } else {
#line 798
                  tmp___62 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 798
                tmp___63 = tmp___62;
              }
#line 798
              tmp___64 = tmp___63;
            }
#line 798
            if (tmp___64) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___60 = 1;
            } else
#line 798
            if (n0 + (n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___60 = 1;
            } else
#line 798
            if (9223372036854775807L < n0 + (n0 >> 1)) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___60 = 1;
            } else {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___60 = 0;
            }
#line 798
            tmp___74 = tmp___60;
          } else {
#line 798
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
              if (n0 >> 1 < 0L) {
#line 798
                tmp___70 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 798
                tmp___70 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 798
              tmp___73 = tmp___70;
            } else {
#line 798
              if (n0 < 0L) {
#line 798
                tmp___72 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 798
                if (n0 >> 1 < 0L) {
#line 798
                  tmp___71 = n0 <= n0 + (n0 >> 1);
                } else {
#line 798
                  tmp___71 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 798
                tmp___72 = tmp___71;
              }
#line 798
              tmp___73 = tmp___72;
            }
#line 798
            if (tmp___73) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___69 = 1;
            } else
#line 798
            if (n0 + (n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___69 = 1;
            } else
#line 798
            if (9223372036854775807L < n0 + (n0 >> 1)) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___69 = 1;
            } else {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___69 = 0;
            }
#line 798
            tmp___74 = tmp___69;
          }
#line 798
          tmp___94 = tmp___74;
        } else {
#line 798
          if (sizeof(n0 + (n0 >> 1)) < sizeof(long long )) {
#line 798
            if (~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 798
              if ((long long )(n0 >> 1) < 0LL) {
#line 798
                tmp___80 = (long long )n0 < ~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )(n0 >> 1);
              } else {
#line 798
                tmp___80 = (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )(n0 >> 1) < (long long )n0;
              }
#line 798
              tmp___83 = tmp___80;
            } else {
#line 798
              if ((long long )n0 < 0LL) {
#line 798
                tmp___82 = (long long )(n0 >> 1) <= (long long )n0 + (long long )(n0 >> 1);
              } else {
#line 798
                if ((long long )(n0 >> 1) < 0LL) {
#line 798
                  tmp___81 = (long long )n0 <= (long long )n0 + (long long )(n0 >> 1);
                } else {
#line 798
                  tmp___81 = (long long )n0 + (long long )(n0 >> 1) < (long long )(n0 >> 1);
                }
#line 798
                tmp___82 = tmp___81;
              }
#line 798
              tmp___83 = tmp___82;
            }
#line 798
            if (tmp___83) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
#line 798
              tmp___79 = 1;
            } else
#line 798
            if ((long long )n0 + (long long )(n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
#line 798
              tmp___79 = 1;
            } else
#line 798
            if (9223372036854775807LL < (long long )n0 + (long long )(n0 >> 1)) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
#line 798
              tmp___79 = 1;
            } else {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
#line 798
              tmp___79 = 0;
            }
#line 798
            tmp___93 = tmp___79;
          } else {
#line 798
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
              if (n0 >> 1 < 0L) {
#line 798
                tmp___89 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 798
                tmp___89 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 798
              tmp___92 = tmp___89;
            } else {
#line 798
              if (n0 < 0L) {
#line 798
                tmp___91 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 798
                if (n0 >> 1 < 0L) {
#line 798
                  tmp___90 = n0 <= n0 + (n0 >> 1);
                } else {
#line 798
                  tmp___90 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 798
                tmp___91 = tmp___90;
              }
#line 798
              tmp___92 = tmp___91;
            }
#line 798
            if (tmp___92) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
#line 798
              tmp___88 = 1;
            } else
#line 798
            if ((long long )(n0 + (n0 >> 1)) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
#line 798
              tmp___88 = 1;
            } else
#line 798
            if (9223372036854775807LL < (long long )(n0 + (n0 >> 1))) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
#line 798
              tmp___88 = 1;
            } else {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
#line 798
              tmp___88 = 0;
            }
#line 798
            tmp___93 = tmp___88;
          }
#line 798
          tmp___94 = tmp___93;
        }
#line 798
        tmp___95 = tmp___94;
      }
#line 798
      tmp___96 = tmp___95;
    }
#line 798
    tmp___97 = tmp___96;
  }
#line 798
  if (tmp___97) {
#line 799
    n = 9223372036854775807L;
  }
#line 800
  if (0L <= nitems_max) {
#line 800
    if (nitems_max < n) {
#line 801
      n = nitems_max;
    }
  }
#line 803
  if (sizeof(nbytes) == sizeof(signed char )) {
#line 803
    if (sizeof(n * item_size) < sizeof(signed char )) {
#line 803
      if (~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 803
        if ((int )((signed char )n) < 0) {
#line 803
          if (0 < (int )((signed char )item_size)) {
#line 803
            nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
            tmp___224 = 1;
          } else {
#line 803
            goto _L___20;
          }
        } else
        _L___20: /* CIL Label */ 
#line 803
        if ((int )((signed char )item_size) < 0) {
#line 803
          if (0 < (int )((signed char )n)) {
#line 803
            nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
            tmp___224 = 1;
          } else {
#line 803
            goto _L___19;
          }
        } else {
#line 803
          goto _L___19;
        }
      } else {
        _L___19: /* CIL Label */ 
#line 803
        if ((int )((signed char )item_size) < 0) {
#line 803
          if ((int )((signed char )n) < 0) {
#line 803
            tmp___226 = (int )((signed char )n) < (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
          } else {
#line 803
            if ((int )((signed char )item_size) == -1) {
#line 803
              tmp___225 = 0;
            } else {
#line 803
              tmp___225 = ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
            }
#line 803
            tmp___226 = tmp___225;
          }
#line 803
          tmp___229 = tmp___226;
        } else {
#line 803
          if ((int )((signed char )item_size) == 0) {
#line 803
            tmp___228 = 0;
          } else {
#line 803
            if ((int )((signed char )n) < 0) {
#line 803
              tmp___227 = (int )((signed char )n) < ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
            } else {
#line 803
              tmp___227 = (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
            }
#line 803
            tmp___228 = tmp___227;
          }
#line 803
          tmp___229 = tmp___228;
        }
#line 803
        if (tmp___229) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
          tmp___224 = 1;
        } else
#line 803
        if ((int )((signed char )n) * (int )((signed char )item_size) < -128) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
          tmp___224 = 1;
        } else
#line 803
        if (127 < (int )((signed char )n) * (int )((signed char )item_size)) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
          tmp___224 = 1;
        } else {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
          tmp___224 = 0;
        }
      }
#line 803
      tmp___241 = tmp___224;
    } else {
#line 803
      if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
        if (n < 0L) {
#line 803
          if (0L < item_size) {
#line 803
            nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___235 = 1;
          } else {
#line 803
            goto _L___22;
          }
        } else
        _L___22: /* CIL Label */ 
#line 803
        if (item_size < 0L) {
#line 803
          if (0L < n) {
#line 803
            nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___235 = 1;
          } else {
#line 803
            goto _L___21;
          }
        } else {
#line 803
          goto _L___21;
        }
      } else {
        _L___21: /* CIL Label */ 
#line 803
        if (item_size < 0L) {
#line 803
          if (n < 0L) {
#line 803
            tmp___237 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
          } else {
#line 803
            if (item_size == -1L) {
#line 803
              tmp___236 = 0;
            } else {
#line 803
              tmp___236 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
            }
#line 803
            tmp___237 = tmp___236;
          }
#line 803
          tmp___240 = tmp___237;
        } else {
#line 803
          if (item_size == 0L) {
#line 803
            tmp___239 = 0;
          } else {
#line 803
            if (n < 0L) {
#line 803
              tmp___238 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
            } else {
#line 803
              tmp___238 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
            }
#line 803
            tmp___239 = tmp___238;
          }
#line 803
          tmp___240 = tmp___239;
        }
#line 803
        if (tmp___240) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
          tmp___235 = 1;
        } else
#line 803
        if (n * item_size < -128L) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
          tmp___235 = 1;
        } else
#line 803
        if (127L < n * item_size) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
          tmp___235 = 1;
        } else {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
          tmp___235 = 0;
        }
      }
#line 803
      tmp___241 = tmp___235;
    }
#line 803
    tmp___337 = tmp___241;
  } else {
#line 803
    if (sizeof(nbytes) == sizeof(short )) {
#line 803
      if (sizeof(n * item_size) < sizeof(short )) {
#line 803
        if (~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 803
          if ((int )((short )n) < 0) {
#line 803
            if (0 < (int )((short )item_size)) {
#line 803
              nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
              tmp___247 = 1;
            } else {
#line 803
              goto _L___24;
            }
          } else
          _L___24: /* CIL Label */ 
#line 803
          if ((int )((short )item_size) < 0) {
#line 803
            if (0 < (int )((short )n)) {
#line 803
              nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
              tmp___247 = 1;
            } else {
#line 803
              goto _L___23;
            }
          } else {
#line 803
            goto _L___23;
          }
        } else {
          _L___23: /* CIL Label */ 
#line 803
          if ((int )((short )item_size) < 0) {
#line 803
            if ((int )((short )n) < 0) {
#line 803
              tmp___249 = (int )((short )n) < (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
            } else {
#line 803
              if ((int )((short )item_size) == -1) {
#line 803
                tmp___248 = 0;
              } else {
#line 803
                tmp___248 = ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
              }
#line 803
              tmp___249 = tmp___248;
            }
#line 803
            tmp___252 = tmp___249;
          } else {
#line 803
            if ((int )((short )item_size) == 0) {
#line 803
              tmp___251 = 0;
            } else {
#line 803
              if ((int )((short )n) < 0) {
#line 803
                tmp___250 = (int )((short )n) < ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
              } else {
#line 803
                tmp___250 = (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
              }
#line 803
              tmp___251 = tmp___250;
            }
#line 803
            tmp___252 = tmp___251;
          }
#line 803
          if (tmp___252) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
            tmp___247 = 1;
          } else
#line 803
          if ((int )((short )n) * (int )((short )item_size) < -32768) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
            tmp___247 = 1;
          } else
#line 803
          if (32767 < (int )((short )n) * (int )((short )item_size)) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
            tmp___247 = 1;
          } else {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
            tmp___247 = 0;
          }
        }
#line 803
        tmp___264 = tmp___247;
      } else {
#line 803
        if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
          if (n < 0L) {
#line 803
            if (0L < item_size) {
#line 803
              nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___258 = 1;
            } else {
#line 803
              goto _L___26;
            }
          } else
          _L___26: /* CIL Label */ 
#line 803
          if (item_size < 0L) {
#line 803
            if (0L < n) {
#line 803
              nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___258 = 1;
            } else {
#line 803
              goto _L___25;
            }
          } else {
#line 803
            goto _L___25;
          }
        } else {
          _L___25: /* CIL Label */ 
#line 803
          if (item_size < 0L) {
#line 803
            if (n < 0L) {
#line 803
              tmp___260 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
            } else {
#line 803
              if (item_size == -1L) {
#line 803
                tmp___259 = 0;
              } else {
#line 803
                tmp___259 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
              }
#line 803
              tmp___260 = tmp___259;
            }
#line 803
            tmp___263 = tmp___260;
          } else {
#line 803
            if (item_size == 0L) {
#line 803
              tmp___262 = 0;
            } else {
#line 803
              if (n < 0L) {
#line 803
                tmp___261 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 803
                tmp___261 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
              }
#line 803
              tmp___262 = tmp___261;
            }
#line 803
            tmp___263 = tmp___262;
          }
#line 803
          if (tmp___263) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___258 = 1;
          } else
#line 803
          if (n * item_size < -32768L) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___258 = 1;
          } else
#line 803
          if (32767L < n * item_size) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___258 = 1;
          } else {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___258 = 0;
          }
        }
#line 803
        tmp___264 = tmp___258;
      }
#line 803
      tmp___336 = tmp___264;
    } else {
#line 803
      if (sizeof(nbytes) == sizeof(int )) {
#line 803
        if (sizeof(n * item_size) < sizeof(int )) {
#line 803
          if (~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 803
            if ((int )n < 0) {
#line 803
              if (0 < (int )item_size) {
#line 803
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
                tmp___270 = 1;
              } else {
#line 803
                goto _L___28;
              }
            } else
            _L___28: /* CIL Label */ 
#line 803
            if ((int )item_size < 0) {
#line 803
              if (0 < (int )n) {
#line 803
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
                tmp___270 = 1;
              } else {
#line 803
                goto _L___27;
              }
            } else {
#line 803
              goto _L___27;
            }
          } else {
            _L___27: /* CIL Label */ 
#line 803
            if ((int )item_size < 0) {
#line 803
              if ((int )n < 0) {
#line 803
                tmp___272 = (int )n < (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
              } else {
#line 803
                if ((int )item_size == -1) {
#line 803
                  tmp___271 = 0;
                } else {
#line 803
                  tmp___271 = ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                }
#line 803
                tmp___272 = tmp___271;
              }
#line 803
              tmp___275 = tmp___272;
            } else {
#line 803
              if ((int )item_size == 0) {
#line 803
                tmp___274 = 0;
              } else {
#line 803
                if ((int )n < 0) {
#line 803
                  tmp___273 = (int )n < ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                } else {
#line 803
                  tmp___273 = (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                }
#line 803
                tmp___274 = tmp___273;
              }
#line 803
              tmp___275 = tmp___274;
            }
#line 803
            if (tmp___275) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
              tmp___270 = 1;
            } else
#line 803
            if ((int )n * (int )item_size < (-0x7FFFFFFF-1)) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
              tmp___270 = 1;
            } else
#line 803
            if (2147483647 < (int )n * (int )item_size) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
              tmp___270 = 1;
            } else {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
              tmp___270 = 0;
            }
          }
#line 803
          tmp___287 = tmp___270;
        } else {
#line 803
          if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
            if (n < 0L) {
#line 803
              if (0L < item_size) {
#line 803
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
                tmp___281 = 1;
              } else {
#line 803
                goto _L___30;
              }
            } else
            _L___30: /* CIL Label */ 
#line 803
            if (item_size < 0L) {
#line 803
              if (0L < n) {
#line 803
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
                tmp___281 = 1;
              } else {
#line 803
                goto _L___29;
              }
            } else {
#line 803
              goto _L___29;
            }
          } else {
            _L___29: /* CIL Label */ 
#line 803
            if (item_size < 0L) {
#line 803
              if (n < 0L) {
#line 803
                tmp___283 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 803
                if (item_size == -1L) {
#line 803
                  tmp___282 = 0;
                } else {
#line 803
                  tmp___282 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 803
                tmp___283 = tmp___282;
              }
#line 803
              tmp___286 = tmp___283;
            } else {
#line 803
              if (item_size == 0L) {
#line 803
                tmp___285 = 0;
              } else {
#line 803
                if (n < 0L) {
#line 803
                  tmp___284 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 803
                  tmp___284 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 803
                tmp___285 = tmp___284;
              }
#line 803
              tmp___286 = tmp___285;
            }
#line 803
            if (tmp___286) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___281 = 1;
            } else
#line 803
            if (n * item_size < (-0x7FFFFFFF-1)) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___281 = 1;
            } else
#line 803
            if (2147483647L < n * item_size) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___281 = 1;
            } else {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___281 = 0;
            }
          }
#line 803
          tmp___287 = tmp___281;
        }
#line 803
        tmp___335 = tmp___287;
      } else {
#line 803
        if (sizeof(nbytes) == sizeof(long )) {
#line 803
          if (sizeof(n * item_size) < sizeof(long )) {
#line 803
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
              if (n < 0L) {
#line 803
                if (0L < item_size) {
#line 803
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                  tmp___293 = 1;
                } else {
#line 803
                  goto _L___32;
                }
              } else
              _L___32: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (0L < n) {
#line 803
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                  tmp___293 = 1;
                } else {
#line 803
                  goto _L___31;
                }
              } else {
#line 803
                goto _L___31;
              }
            } else {
              _L___31: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (n < 0L) {
#line 803
                  tmp___295 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 803
                  if (item_size == -1L) {
#line 803
                    tmp___294 = 0;
                  } else {
#line 803
                    tmp___294 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___295 = tmp___294;
                }
#line 803
                tmp___298 = tmp___295;
              } else {
#line 803
                if (item_size == 0L) {
#line 803
                  tmp___297 = 0;
                } else {
#line 803
                  if (n < 0L) {
#line 803
                    tmp___296 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 803
                    tmp___296 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___297 = tmp___296;
                }
#line 803
                tmp___298 = tmp___297;
              }
#line 803
              if (tmp___298) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___293 = 1;
              } else
#line 803
              if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___293 = 1;
              } else
#line 803
              if (9223372036854775807L < n * item_size) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___293 = 1;
              } else {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___293 = 0;
              }
            }
#line 803
            tmp___310 = tmp___293;
          } else {
#line 803
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
              if (n < 0L) {
#line 803
                if (0L < item_size) {
#line 803
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                  tmp___304 = 1;
                } else {
#line 803
                  goto _L___34;
                }
              } else
              _L___34: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (0L < n) {
#line 803
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                  tmp___304 = 1;
                } else {
#line 803
                  goto _L___33;
                }
              } else {
#line 803
                goto _L___33;
              }
            } else {
              _L___33: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (n < 0L) {
#line 803
                  tmp___306 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 803
                  if (item_size == -1L) {
#line 803
                    tmp___305 = 0;
                  } else {
#line 803
                    tmp___305 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___306 = tmp___305;
                }
#line 803
                tmp___309 = tmp___306;
              } else {
#line 803
                if (item_size == 0L) {
#line 803
                  tmp___308 = 0;
                } else {
#line 803
                  if (n < 0L) {
#line 803
                    tmp___307 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 803
                    tmp___307 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___308 = tmp___307;
                }
#line 803
                tmp___309 = tmp___308;
              }
#line 803
              if (tmp___309) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___304 = 1;
              } else
#line 803
              if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___304 = 1;
              } else
#line 803
              if (9223372036854775807L < n * item_size) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___304 = 1;
              } else {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___304 = 0;
              }
            }
#line 803
            tmp___310 = tmp___304;
          }
#line 803
          tmp___334 = tmp___310;
        } else {
#line 803
          if (sizeof(n * item_size) < sizeof(long long )) {
#line 803
            if (~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 803
              if ((long long )n < 0LL) {
#line 803
                if (0LL < (long long )item_size) {
#line 803
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                  tmp___316 = 1;
                } else {
#line 803
                  goto _L___36;
                }
              } else
              _L___36: /* CIL Label */ 
#line 803
              if ((long long )item_size < 0LL) {
#line 803
                if (0LL < (long long )n) {
#line 803
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                  tmp___316 = 1;
                } else {
#line 803
                  goto _L___35;
                }
              } else {
#line 803
                goto _L___35;
              }
            } else {
              _L___35: /* CIL Label */ 
#line 803
              if ((long long )item_size < 0LL) {
#line 803
                if ((long long )n < 0LL) {
#line 803
                  tmp___318 = (long long )n < (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                } else {
#line 803
                  if ((long long )item_size == -1LL) {
#line 803
                    tmp___317 = 0;
                  } else {
#line 803
                    tmp___317 = ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                  }
#line 803
                  tmp___318 = tmp___317;
                }
#line 803
                tmp___321 = tmp___318;
              } else {
#line 803
                if ((long long )item_size == 0LL) {
#line 803
                  tmp___320 = 0;
                } else {
#line 803
                  if ((long long )n < 0LL) {
#line 803
                    tmp___319 = (long long )n < ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                  } else {
#line 803
                    tmp___319 = (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                  }
#line 803
                  tmp___320 = tmp___319;
                }
#line 803
                tmp___321 = tmp___320;
              }
#line 803
              if (tmp___321) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                tmp___316 = 1;
              } else
#line 803
              if ((long long )n * (long long )item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                tmp___316 = 1;
              } else
#line 803
              if (9223372036854775807LL < (long long )n * (long long )item_size) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                tmp___316 = 1;
              } else {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                tmp___316 = 0;
              }
            }
#line 803
            tmp___333 = tmp___316;
          } else {
#line 803
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
              if (n < 0L) {
#line 803
                if (0L < item_size) {
#line 803
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                  tmp___327 = 1;
                } else {
#line 803
                  goto _L___38;
                }
              } else
              _L___38: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (0L < n) {
#line 803
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                  tmp___327 = 1;
                } else {
#line 803
                  goto _L___37;
                }
              } else {
#line 803
                goto _L___37;
              }
            } else {
              _L___37: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (n < 0L) {
#line 803
                  tmp___329 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 803
                  if (item_size == -1L) {
#line 803
                    tmp___328 = 0;
                  } else {
#line 803
                    tmp___328 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___329 = tmp___328;
                }
#line 803
                tmp___332 = tmp___329;
              } else {
#line 803
                if (item_size == 0L) {
#line 803
                  tmp___331 = 0;
                } else {
#line 803
                  if (n < 0L) {
#line 803
                    tmp___330 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 803
                    tmp___330 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___331 = tmp___330;
                }
#line 803
                tmp___332 = tmp___331;
              }
#line 803
              if (tmp___332) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                tmp___327 = 1;
              } else
#line 803
              if ((long long )(n * item_size) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                tmp___327 = 1;
              } else
#line 803
              if (9223372036854775807LL < (long long )(n * item_size)) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                tmp___327 = 1;
              } else {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                tmp___327 = 0;
              }
            }
#line 803
            tmp___333 = tmp___327;
          }
#line 803
          tmp___334 = tmp___333;
        }
#line 803
        tmp___335 = tmp___334;
      }
#line 803
      tmp___336 = tmp___335;
    }
#line 803
    tmp___337 = tmp___336;
  }
#line 803
  if (tmp___337) {
#line 803
    tmp___218 = 9223372036854775807UL;
  } else
#line 803
  if (0xffffffffffffffffUL < (unsigned long )nbytes) {
#line 803
    tmp___218 = 9223372036854775807UL;
  } else {
#line 803
    if (nbytes < 128L) {
#line 803
      tmp___217 = 128;
    } else {
#line 803
      tmp___217 = 0;
    }
#line 803
    tmp___218 = (unsigned long )tmp___217;
  }
#line 803
  adjusted_nbytes = (ptrdiff_t )tmp___218;
#line 807
  if (adjusted_nbytes) {
#line 809
    n = adjusted_nbytes / item_size;
#line 810
    nbytes = adjusted_nbytes - adjusted_nbytes % item_size;
  }
#line 813
  if (! pa) {
#line 814
    *nitems = (ptrdiff_t )0;
  }
#line 815
  if (n - n0 < nitems_incr_min) {
#line 815
    if (sizeof(n) == sizeof(signed char )) {
#line 815
      if (sizeof(n0 + nitems_incr_min) < sizeof(signed char )) {
#line 815
        if (~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 815
          if ((int )((signed char )nitems_incr_min) < 0) {
#line 815
            tmp___343 = (int )((signed char )n0) < ~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )nitems_incr_min);
          } else {
#line 815
            tmp___343 = (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )nitems_incr_min) < (int )((signed char )n0);
          }
#line 815
          tmp___346 = tmp___343;
        } else {
#line 815
          if ((int )((signed char )n0) < 0) {
#line 815
            tmp___345 = (int )((signed char )nitems_incr_min) <= (int )((signed char )n0) + (int )((signed char )nitems_incr_min);
          } else {
#line 815
            if ((int )((signed char )nitems_incr_min) < 0) {
#line 815
              tmp___344 = (int )((signed char )n0) <= (int )((signed char )n0) + (int )((signed char )nitems_incr_min);
            } else {
#line 815
              tmp___344 = (int )((signed char )n0) + (int )((signed char )nitems_incr_min) < (int )((signed char )nitems_incr_min);
            }
#line 815
            tmp___345 = tmp___344;
          }
#line 815
          tmp___346 = tmp___345;
        }
#line 815
        if (tmp___346) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )nitems_incr_min)));
#line 815
          tmp___342 = 1;
        } else
#line 815
        if ((int )((signed char )n0) + (int )((signed char )nitems_incr_min) < -128) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )nitems_incr_min)));
#line 815
          tmp___342 = 1;
        } else
#line 815
        if (127 < (int )((signed char )n0) + (int )((signed char )nitems_incr_min)) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )nitems_incr_min)));
#line 815
          tmp___342 = 1;
        } else {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )nitems_incr_min)));
#line 815
          tmp___342 = 0;
        }
#line 815
        tmp___356 = tmp___342;
      } else {
#line 815
        if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
          if (nitems_incr_min < 0L) {
#line 815
            tmp___352 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
          } else {
#line 815
            tmp___352 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
          }
#line 815
          tmp___355 = tmp___352;
        } else {
#line 815
          if (n0 < 0L) {
#line 815
            tmp___354 = nitems_incr_min <= n0 + nitems_incr_min;
          } else {
#line 815
            if (nitems_incr_min < 0L) {
#line 815
              tmp___353 = n0 <= n0 + nitems_incr_min;
            } else {
#line 815
              tmp___353 = n0 + nitems_incr_min < nitems_incr_min;
            }
#line 815
            tmp___354 = tmp___353;
          }
#line 815
          tmp___355 = tmp___354;
        }
#line 815
        if (tmp___355) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
          tmp___351 = 1;
        } else
#line 815
        if (n0 + nitems_incr_min < -128L) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
          tmp___351 = 1;
        } else
#line 815
        if (127L < n0 + nitems_incr_min) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
          tmp___351 = 1;
        } else {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
          tmp___351 = 0;
        }
#line 815
        tmp___356 = tmp___351;
      }
#line 815
      tmp___436 = tmp___356;
    } else {
#line 815
      if (sizeof(n) == sizeof(short )) {
#line 815
        if (sizeof(n0 + nitems_incr_min) < sizeof(short )) {
#line 815
          if (~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 815
            if ((int )((short )nitems_incr_min) < 0) {
#line 815
              tmp___362 = (int )((short )n0) < ~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )nitems_incr_min);
            } else {
#line 815
              tmp___362 = (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )nitems_incr_min) < (int )((short )n0);
            }
#line 815
            tmp___365 = tmp___362;
          } else {
#line 815
            if ((int )((short )n0) < 0) {
#line 815
              tmp___364 = (int )((short )nitems_incr_min) <= (int )((short )n0) + (int )((short )nitems_incr_min);
            } else {
#line 815
              if ((int )((short )nitems_incr_min) < 0) {
#line 815
                tmp___363 = (int )((short )n0) <= (int )((short )n0) + (int )((short )nitems_incr_min);
              } else {
#line 815
                tmp___363 = (int )((short )n0) + (int )((short )nitems_incr_min) < (int )((short )nitems_incr_min);
              }
#line 815
              tmp___364 = tmp___363;
            }
#line 815
            tmp___365 = tmp___364;
          }
#line 815
          if (tmp___365) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )nitems_incr_min)));
#line 815
            tmp___361 = 1;
          } else
#line 815
          if ((int )((short )n0) + (int )((short )nitems_incr_min) < -32768) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )nitems_incr_min)));
#line 815
            tmp___361 = 1;
          } else
#line 815
          if (32767 < (int )((short )n0) + (int )((short )nitems_incr_min)) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )nitems_incr_min)));
#line 815
            tmp___361 = 1;
          } else {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )nitems_incr_min)));
#line 815
            tmp___361 = 0;
          }
#line 815
          tmp___375 = tmp___361;
        } else {
#line 815
          if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
            if (nitems_incr_min < 0L) {
#line 815
              tmp___371 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
            } else {
#line 815
              tmp___371 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
            }
#line 815
            tmp___374 = tmp___371;
          } else {
#line 815
            if (n0 < 0L) {
#line 815
              tmp___373 = nitems_incr_min <= n0 + nitems_incr_min;
            } else {
#line 815
              if (nitems_incr_min < 0L) {
#line 815
                tmp___372 = n0 <= n0 + nitems_incr_min;
              } else {
#line 815
                tmp___372 = n0 + nitems_incr_min < nitems_incr_min;
              }
#line 815
              tmp___373 = tmp___372;
            }
#line 815
            tmp___374 = tmp___373;
          }
#line 815
          if (tmp___374) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
            tmp___370 = 1;
          } else
#line 815
          if (n0 + nitems_incr_min < -32768L) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
            tmp___370 = 1;
          } else
#line 815
          if (32767L < n0 + nitems_incr_min) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
            tmp___370 = 1;
          } else {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
            tmp___370 = 0;
          }
#line 815
          tmp___375 = tmp___370;
        }
#line 815
        tmp___435 = tmp___375;
      } else {
#line 815
        if (sizeof(n) == sizeof(int )) {
#line 815
          if (sizeof(n0 + nitems_incr_min) < sizeof(int )) {
#line 815
            if (~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 815
              if ((int )nitems_incr_min < 0) {
#line 815
                tmp___381 = (int )n0 < ~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )nitems_incr_min;
              } else {
#line 815
                tmp___381 = (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )nitems_incr_min < (int )n0;
              }
#line 815
              tmp___384 = tmp___381;
            } else {
#line 815
              if ((int )n0 < 0) {
#line 815
                tmp___383 = (int )nitems_incr_min <= (int )n0 + (int )nitems_incr_min;
              } else {
#line 815
                if ((int )nitems_incr_min < 0) {
#line 815
                  tmp___382 = (int )n0 <= (int )n0 + (int )nitems_incr_min;
                } else {
#line 815
                  tmp___382 = (int )n0 + (int )nitems_incr_min < (int )nitems_incr_min;
                }
#line 815
                tmp___383 = tmp___382;
              }
#line 815
              tmp___384 = tmp___383;
            }
#line 815
            if (tmp___384) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
#line 815
              tmp___380 = 1;
            } else
#line 815
            if ((int )n0 + (int )nitems_incr_min < (-0x7FFFFFFF-1)) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
#line 815
              tmp___380 = 1;
            } else
#line 815
            if (2147483647 < (int )n0 + (int )nitems_incr_min) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
#line 815
              tmp___380 = 1;
            } else {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
#line 815
              tmp___380 = 0;
            }
#line 815
            tmp___394 = tmp___380;
          } else {
#line 815
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
              if (nitems_incr_min < 0L) {
#line 815
                tmp___390 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
              } else {
#line 815
                tmp___390 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
              }
#line 815
              tmp___393 = tmp___390;
            } else {
#line 815
              if (n0 < 0L) {
#line 815
                tmp___392 = nitems_incr_min <= n0 + nitems_incr_min;
              } else {
#line 815
                if (nitems_incr_min < 0L) {
#line 815
                  tmp___391 = n0 <= n0 + nitems_incr_min;
                } else {
#line 815
                  tmp___391 = n0 + nitems_incr_min < nitems_incr_min;
                }
#line 815
                tmp___392 = tmp___391;
              }
#line 815
              tmp___393 = tmp___392;
            }
#line 815
            if (tmp___393) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
              tmp___389 = 1;
            } else
#line 815
            if (n0 + nitems_incr_min < (-0x7FFFFFFF-1)) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
              tmp___389 = 1;
            } else
#line 815
            if (2147483647L < n0 + nitems_incr_min) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
              tmp___389 = 1;
            } else {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
              tmp___389 = 0;
            }
#line 815
            tmp___394 = tmp___389;
          }
#line 815
          tmp___434 = tmp___394;
        } else {
#line 815
          if (sizeof(n) == sizeof(long )) {
#line 815
            if (sizeof(n0 + nitems_incr_min) < sizeof(long )) {
#line 815
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
                if (nitems_incr_min < 0L) {
#line 815
                  tmp___400 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 815
                  tmp___400 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 815
                tmp___403 = tmp___400;
              } else {
#line 815
                if (n0 < 0L) {
#line 815
                  tmp___402 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 815
                  if (nitems_incr_min < 0L) {
#line 815
                    tmp___401 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 815
                    tmp___401 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 815
                  tmp___402 = tmp___401;
                }
#line 815
                tmp___403 = tmp___402;
              }
#line 815
              if (tmp___403) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___399 = 1;
              } else
#line 815
              if (n0 + nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___399 = 1;
              } else
#line 815
              if (9223372036854775807L < n0 + nitems_incr_min) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___399 = 1;
              } else {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___399 = 0;
              }
#line 815
              tmp___413 = tmp___399;
            } else {
#line 815
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
                if (nitems_incr_min < 0L) {
#line 815
                  tmp___409 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 815
                  tmp___409 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 815
                tmp___412 = tmp___409;
              } else {
#line 815
                if (n0 < 0L) {
#line 815
                  tmp___411 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 815
                  if (nitems_incr_min < 0L) {
#line 815
                    tmp___410 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 815
                    tmp___410 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 815
                  tmp___411 = tmp___410;
                }
#line 815
                tmp___412 = tmp___411;
              }
#line 815
              if (tmp___412) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___408 = 1;
              } else
#line 815
              if (n0 + nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___408 = 1;
              } else
#line 815
              if (9223372036854775807L < n0 + nitems_incr_min) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___408 = 1;
              } else {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___408 = 0;
              }
#line 815
              tmp___413 = tmp___408;
            }
#line 815
            tmp___433 = tmp___413;
          } else {
#line 815
            if (sizeof(n0 + nitems_incr_min) < sizeof(long long )) {
#line 815
              if (~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 815
                if ((long long )nitems_incr_min < 0LL) {
#line 815
                  tmp___419 = (long long )n0 < ~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )nitems_incr_min;
                } else {
#line 815
                  tmp___419 = (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )nitems_incr_min < (long long )n0;
                }
#line 815
                tmp___422 = tmp___419;
              } else {
#line 815
                if ((long long )n0 < 0LL) {
#line 815
                  tmp___421 = (long long )nitems_incr_min <= (long long )n0 + (long long )nitems_incr_min;
                } else {
#line 815
                  if ((long long )nitems_incr_min < 0LL) {
#line 815
                    tmp___420 = (long long )n0 <= (long long )n0 + (long long )nitems_incr_min;
                  } else {
#line 815
                    tmp___420 = (long long )n0 + (long long )nitems_incr_min < (long long )nitems_incr_min;
                  }
#line 815
                  tmp___421 = tmp___420;
                }
#line 815
                tmp___422 = tmp___421;
              }
#line 815
              if (tmp___422) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
#line 815
                tmp___418 = 1;
              } else
#line 815
              if ((long long )n0 + (long long )nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
#line 815
                tmp___418 = 1;
              } else
#line 815
              if (9223372036854775807LL < (long long )n0 + (long long )nitems_incr_min) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
#line 815
                tmp___418 = 1;
              } else {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
#line 815
                tmp___418 = 0;
              }
#line 815
              tmp___432 = tmp___418;
            } else {
#line 815
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
                if (nitems_incr_min < 0L) {
#line 815
                  tmp___428 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 815
                  tmp___428 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 815
                tmp___431 = tmp___428;
              } else {
#line 815
                if (n0 < 0L) {
#line 815
                  tmp___430 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 815
                  if (nitems_incr_min < 0L) {
#line 815
                    tmp___429 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 815
                    tmp___429 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 815
                  tmp___430 = tmp___429;
                }
#line 815
                tmp___431 = tmp___430;
              }
#line 815
              if (tmp___431) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
#line 815
                tmp___427 = 1;
              } else
#line 815
              if ((long long )(n0 + nitems_incr_min) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
#line 815
                tmp___427 = 1;
              } else
#line 815
              if (9223372036854775807LL < (long long )(n0 + nitems_incr_min)) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
#line 815
                tmp___427 = 1;
              } else {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
#line 815
                tmp___427 = 0;
              }
#line 815
              tmp___432 = tmp___427;
            }
#line 815
            tmp___433 = tmp___432;
          }
#line 815
          tmp___434 = tmp___433;
        }
#line 815
        tmp___435 = tmp___434;
      }
#line 815
      tmp___436 = tmp___435;
    }
#line 815
    if (tmp___436) {
      {
#line 819
      xalloc_die();
      }
    } else
#line 815
    if (0L <= nitems_max) {
#line 815
      if (nitems_max < n) {
        {
#line 819
        xalloc_die();
        }
      } else {
#line 815
        goto _L___59;
      }
    } else {
      _L___59: /* CIL Label */ 
#line 815
      if (sizeof(nbytes) == sizeof(signed char )) {
#line 815
        if (sizeof(n * item_size) < sizeof(signed char )) {
#line 815
          if (~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 815
            if ((int )((signed char )n) < 0) {
#line 815
              if (0 < (int )((signed char )item_size)) {
#line 815
                nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
                tmp___442 = 1;
              } else {
#line 815
                goto _L___40;
              }
            } else
            _L___40: /* CIL Label */ 
#line 815
            if ((int )((signed char )item_size) < 0) {
#line 815
              if (0 < (int )((signed char )n)) {
#line 815
                nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
                tmp___442 = 1;
              } else {
#line 815
                goto _L___39;
              }
            } else {
#line 815
              goto _L___39;
            }
          } else {
            _L___39: /* CIL Label */ 
#line 815
            if ((int )((signed char )item_size) < 0) {
#line 815
              if ((int )((signed char )n) < 0) {
#line 815
                tmp___444 = (int )((signed char )n) < (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
              } else {
#line 815
                if ((int )((signed char )item_size) == -1) {
#line 815
                  tmp___443 = 0;
                } else {
#line 815
                  tmp___443 = ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
                }
#line 815
                tmp___444 = tmp___443;
              }
#line 815
              tmp___447 = tmp___444;
            } else {
#line 815
              if ((int )((signed char )item_size) == 0) {
#line 815
                tmp___446 = 0;
              } else {
#line 815
                if ((int )((signed char )n) < 0) {
#line 815
                  tmp___445 = (int )((signed char )n) < ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
                } else {
#line 815
                  tmp___445 = (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
                }
#line 815
                tmp___446 = tmp___445;
              }
#line 815
              tmp___447 = tmp___446;
            }
#line 815
            if (tmp___447) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
              tmp___442 = 1;
            } else
#line 815
            if ((int )((signed char )n) * (int )((signed char )item_size) < -128) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
              tmp___442 = 1;
            } else
#line 815
            if (127 < (int )((signed char )n) * (int )((signed char )item_size)) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
              tmp___442 = 1;
            } else {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
              tmp___442 = 0;
            }
          }
#line 815
          tmp___459 = tmp___442;
        } else {
#line 815
          if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
            if (n < 0L) {
#line 815
              if (0L < item_size) {
#line 815
                nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___453 = 1;
              } else {
#line 815
                goto _L___42;
              }
            } else
            _L___42: /* CIL Label */ 
#line 815
            if (item_size < 0L) {
#line 815
              if (0L < n) {
#line 815
                nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___453 = 1;
              } else {
#line 815
                goto _L___41;
              }
            } else {
#line 815
              goto _L___41;
            }
          } else {
            _L___41: /* CIL Label */ 
#line 815
            if (item_size < 0L) {
#line 815
              if (n < 0L) {
#line 815
                tmp___455 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 815
                if (item_size == -1L) {
#line 815
                  tmp___454 = 0;
                } else {
#line 815
                  tmp___454 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 815
                tmp___455 = tmp___454;
              }
#line 815
              tmp___458 = tmp___455;
            } else {
#line 815
              if (item_size == 0L) {
#line 815
                tmp___457 = 0;
              } else {
#line 815
                if (n < 0L) {
#line 815
                  tmp___456 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 815
                  tmp___456 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 815
                tmp___457 = tmp___456;
              }
#line 815
              tmp___458 = tmp___457;
            }
#line 815
            if (tmp___458) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
              tmp___453 = 1;
            } else
#line 815
            if (n * item_size < -128L) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
              tmp___453 = 1;
            } else
#line 815
            if (127L < n * item_size) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
              tmp___453 = 1;
            } else {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
              tmp___453 = 0;
            }
          }
#line 815
          tmp___459 = tmp___453;
        }
#line 815
        tmp___555 = tmp___459;
      } else {
#line 815
        if (sizeof(nbytes) == sizeof(short )) {
#line 815
          if (sizeof(n * item_size) < sizeof(short )) {
#line 815
            if (~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 815
              if ((int )((short )n) < 0) {
#line 815
                if (0 < (int )((short )item_size)) {
#line 815
                  nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                  tmp___465 = 1;
                } else {
#line 815
                  goto _L___44;
                }
              } else
              _L___44: /* CIL Label */ 
#line 815
              if ((int )((short )item_size) < 0) {
#line 815
                if (0 < (int )((short )n)) {
#line 815
                  nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                  tmp___465 = 1;
                } else {
#line 815
                  goto _L___43;
                }
              } else {
#line 815
                goto _L___43;
              }
            } else {
              _L___43: /* CIL Label */ 
#line 815
              if ((int )((short )item_size) < 0) {
#line 815
                if ((int )((short )n) < 0) {
#line 815
                  tmp___467 = (int )((short )n) < (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
                } else {
#line 815
                  if ((int )((short )item_size) == -1) {
#line 815
                    tmp___466 = 0;
                  } else {
#line 815
                    tmp___466 = ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
                  }
#line 815
                  tmp___467 = tmp___466;
                }
#line 815
                tmp___470 = tmp___467;
              } else {
#line 815
                if ((int )((short )item_size) == 0) {
#line 815
                  tmp___469 = 0;
                } else {
#line 815
                  if ((int )((short )n) < 0) {
#line 815
                    tmp___468 = (int )((short )n) < ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
                  } else {
#line 815
                    tmp___468 = (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
                  }
#line 815
                  tmp___469 = tmp___468;
                }
#line 815
                tmp___470 = tmp___469;
              }
#line 815
              if (tmp___470) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                tmp___465 = 1;
              } else
#line 815
              if ((int )((short )n) * (int )((short )item_size) < -32768) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                tmp___465 = 1;
              } else
#line 815
              if (32767 < (int )((short )n) * (int )((short )item_size)) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                tmp___465 = 1;
              } else {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                tmp___465 = 0;
              }
            }
#line 815
            tmp___482 = tmp___465;
          } else {
#line 815
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
              if (n < 0L) {
#line 815
                if (0L < item_size) {
#line 815
                  nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___476 = 1;
                } else {
#line 815
                  goto _L___46;
                }
              } else
              _L___46: /* CIL Label */ 
#line 815
              if (item_size < 0L) {
#line 815
                if (0L < n) {
#line 815
                  nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___476 = 1;
                } else {
#line 815
                  goto _L___45;
                }
              } else {
#line 815
                goto _L___45;
              }
            } else {
              _L___45: /* CIL Label */ 
#line 815
              if (item_size < 0L) {
#line 815
                if (n < 0L) {
#line 815
                  tmp___478 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 815
                  if (item_size == -1L) {
#line 815
                    tmp___477 = 0;
                  } else {
#line 815
                    tmp___477 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 815
                  tmp___478 = tmp___477;
                }
#line 815
                tmp___481 = tmp___478;
              } else {
#line 815
                if (item_size == 0L) {
#line 815
                  tmp___480 = 0;
                } else {
#line 815
                  if (n < 0L) {
#line 815
                    tmp___479 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 815
                    tmp___479 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 815
                  tmp___480 = tmp___479;
                }
#line 815
                tmp___481 = tmp___480;
              }
#line 815
              if (tmp___481) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___476 = 1;
              } else
#line 815
              if (n * item_size < -32768L) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___476 = 1;
              } else
#line 815
              if (32767L < n * item_size) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___476 = 1;
              } else {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___476 = 0;
              }
            }
#line 815
            tmp___482 = tmp___476;
          }
#line 815
          tmp___554 = tmp___482;
        } else {
#line 815
          if (sizeof(nbytes) == sizeof(int )) {
#line 815
            if (sizeof(n * item_size) < sizeof(int )) {
#line 815
              if (~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 815
                if ((int )n < 0) {
#line 815
                  if (0 < (int )item_size) {
#line 815
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                    tmp___488 = 1;
                  } else {
#line 815
                    goto _L___48;
                  }
                } else
                _L___48: /* CIL Label */ 
#line 815
                if ((int )item_size < 0) {
#line 815
                  if (0 < (int )n) {
#line 815
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                    tmp___488 = 1;
                  } else {
#line 815
                    goto _L___47;
                  }
                } else {
#line 815
                  goto _L___47;
                }
              } else {
                _L___47: /* CIL Label */ 
#line 815
                if ((int )item_size < 0) {
#line 815
                  if ((int )n < 0) {
#line 815
                    tmp___490 = (int )n < (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                  } else {
#line 815
                    if ((int )item_size == -1) {
#line 815
                      tmp___489 = 0;
                    } else {
#line 815
                      tmp___489 = ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                    }
#line 815
                    tmp___490 = tmp___489;
                  }
#line 815
                  tmp___493 = tmp___490;
                } else {
#line 815
                  if ((int )item_size == 0) {
#line 815
                    tmp___492 = 0;
                  } else {
#line 815
                    if ((int )n < 0) {
#line 815
                      tmp___491 = (int )n < ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                    } else {
#line 815
                      tmp___491 = (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                    }
#line 815
                    tmp___492 = tmp___491;
                  }
#line 815
                  tmp___493 = tmp___492;
                }
#line 815
                if (tmp___493) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                  tmp___488 = 1;
                } else
#line 815
                if ((int )n * (int )item_size < (-0x7FFFFFFF-1)) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                  tmp___488 = 1;
                } else
#line 815
                if (2147483647 < (int )n * (int )item_size) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                  tmp___488 = 1;
                } else {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                  tmp___488 = 0;
                }
              }
#line 815
              tmp___505 = tmp___488;
            } else {
#line 815
              if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
                if (n < 0L) {
#line 815
                  if (0L < item_size) {
#line 815
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                    tmp___499 = 1;
                  } else {
#line 815
                    goto _L___50;
                  }
                } else
                _L___50: /* CIL Label */ 
#line 815
                if (item_size < 0L) {
#line 815
                  if (0L < n) {
#line 815
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                    tmp___499 = 1;
                  } else {
#line 815
                    goto _L___49;
                  }
                } else {
#line 815
                  goto _L___49;
                }
              } else {
                _L___49: /* CIL Label */ 
#line 815
                if (item_size < 0L) {
#line 815
                  if (n < 0L) {
#line 815
                    tmp___501 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 815
                    if (item_size == -1L) {
#line 815
                      tmp___500 = 0;
                    } else {
#line 815
                      tmp___500 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                    }
#line 815
                    tmp___501 = tmp___500;
                  }
#line 815
                  tmp___504 = tmp___501;
                } else {
#line 815
                  if (item_size == 0L) {
#line 815
                    tmp___503 = 0;
                  } else {
#line 815
                    if (n < 0L) {
#line 815
                      tmp___502 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 815
                      tmp___502 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                    }
#line 815
                    tmp___503 = tmp___502;
                  }
#line 815
                  tmp___504 = tmp___503;
                }
#line 815
                if (tmp___504) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___499 = 1;
                } else
#line 815
                if (n * item_size < (-0x7FFFFFFF-1)) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___499 = 1;
                } else
#line 815
                if (2147483647L < n * item_size) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___499 = 1;
                } else {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___499 = 0;
                }
              }
#line 815
              tmp___505 = tmp___499;
            }
#line 815
            tmp___553 = tmp___505;
          } else {
#line 815
            if (sizeof(nbytes) == sizeof(long )) {
#line 815
              if (sizeof(n * item_size) < sizeof(long )) {
#line 815
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
                  if (n < 0L) {
#line 815
                    if (0L < item_size) {
#line 815
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                      tmp___511 = 1;
                    } else {
#line 815
                      goto _L___52;
                    }
                  } else
                  _L___52: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (0L < n) {
#line 815
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                      tmp___511 = 1;
                    } else {
#line 815
                      goto _L___51;
                    }
                  } else {
#line 815
                    goto _L___51;
                  }
                } else {
                  _L___51: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (n < 0L) {
#line 815
                      tmp___513 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 815
                      if (item_size == -1L) {
#line 815
                        tmp___512 = 0;
                      } else {
#line 815
                        tmp___512 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___513 = tmp___512;
                    }
#line 815
                    tmp___516 = tmp___513;
                  } else {
#line 815
                    if (item_size == 0L) {
#line 815
                      tmp___515 = 0;
                    } else {
#line 815
                      if (n < 0L) {
#line 815
                        tmp___514 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 815
                        tmp___514 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___515 = tmp___514;
                    }
#line 815
                    tmp___516 = tmp___515;
                  }
#line 815
                  if (tmp___516) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___511 = 1;
                  } else
#line 815
                  if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___511 = 1;
                  } else
#line 815
                  if (9223372036854775807L < n * item_size) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___511 = 1;
                  } else {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___511 = 0;
                  }
                }
#line 815
                tmp___528 = tmp___511;
              } else {
#line 815
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
                  if (n < 0L) {
#line 815
                    if (0L < item_size) {
#line 815
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                      tmp___522 = 1;
                    } else {
#line 815
                      goto _L___54;
                    }
                  } else
                  _L___54: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (0L < n) {
#line 815
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                      tmp___522 = 1;
                    } else {
#line 815
                      goto _L___53;
                    }
                  } else {
#line 815
                    goto _L___53;
                  }
                } else {
                  _L___53: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (n < 0L) {
#line 815
                      tmp___524 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 815
                      if (item_size == -1L) {
#line 815
                        tmp___523 = 0;
                      } else {
#line 815
                        tmp___523 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___524 = tmp___523;
                    }
#line 815
                    tmp___527 = tmp___524;
                  } else {
#line 815
                    if (item_size == 0L) {
#line 815
                      tmp___526 = 0;
                    } else {
#line 815
                      if (n < 0L) {
#line 815
                        tmp___525 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 815
                        tmp___525 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___526 = tmp___525;
                    }
#line 815
                    tmp___527 = tmp___526;
                  }
#line 815
                  if (tmp___527) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___522 = 1;
                  } else
#line 815
                  if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___522 = 1;
                  } else
#line 815
                  if (9223372036854775807L < n * item_size) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___522 = 1;
                  } else {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___522 = 0;
                  }
                }
#line 815
                tmp___528 = tmp___522;
              }
#line 815
              tmp___552 = tmp___528;
            } else {
#line 815
              if (sizeof(n * item_size) < sizeof(long long )) {
#line 815
                if (~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 815
                  if ((long long )n < 0LL) {
#line 815
                    if (0LL < (long long )item_size) {
#line 815
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                      tmp___534 = 1;
                    } else {
#line 815
                      goto _L___56;
                    }
                  } else
                  _L___56: /* CIL Label */ 
#line 815
                  if ((long long )item_size < 0LL) {
#line 815
                    if (0LL < (long long )n) {
#line 815
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                      tmp___534 = 1;
                    } else {
#line 815
                      goto _L___55;
                    }
                  } else {
#line 815
                    goto _L___55;
                  }
                } else {
                  _L___55: /* CIL Label */ 
#line 815
                  if ((long long )item_size < 0LL) {
#line 815
                    if ((long long )n < 0LL) {
#line 815
                      tmp___536 = (long long )n < (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                    } else {
#line 815
                      if ((long long )item_size == -1LL) {
#line 815
                        tmp___535 = 0;
                      } else {
#line 815
                        tmp___535 = ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                      }
#line 815
                      tmp___536 = tmp___535;
                    }
#line 815
                    tmp___539 = tmp___536;
                  } else {
#line 815
                    if ((long long )item_size == 0LL) {
#line 815
                      tmp___538 = 0;
                    } else {
#line 815
                      if ((long long )n < 0LL) {
#line 815
                        tmp___537 = (long long )n < ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                      } else {
#line 815
                        tmp___537 = (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                      }
#line 815
                      tmp___538 = tmp___537;
                    }
#line 815
                    tmp___539 = tmp___538;
                  }
#line 815
                  if (tmp___539) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                    tmp___534 = 1;
                  } else
#line 815
                  if ((long long )n * (long long )item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                    tmp___534 = 1;
                  } else
#line 815
                  if (9223372036854775807LL < (long long )n * (long long )item_size) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                    tmp___534 = 1;
                  } else {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                    tmp___534 = 0;
                  }
                }
#line 815
                tmp___551 = tmp___534;
              } else {
#line 815
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
                  if (n < 0L) {
#line 815
                    if (0L < item_size) {
#line 815
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                      tmp___545 = 1;
                    } else {
#line 815
                      goto _L___58;
                    }
                  } else
                  _L___58: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (0L < n) {
#line 815
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                      tmp___545 = 1;
                    } else {
#line 815
                      goto _L___57;
                    }
                  } else {
#line 815
                    goto _L___57;
                  }
                } else {
                  _L___57: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (n < 0L) {
#line 815
                      tmp___547 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 815
                      if (item_size == -1L) {
#line 815
                        tmp___546 = 0;
                      } else {
#line 815
                        tmp___546 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___547 = tmp___546;
                    }
#line 815
                    tmp___550 = tmp___547;
                  } else {
#line 815
                    if (item_size == 0L) {
#line 815
                      tmp___549 = 0;
                    } else {
#line 815
                      if (n < 0L) {
#line 815
                        tmp___548 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 815
                        tmp___548 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___549 = tmp___548;
                    }
#line 815
                    tmp___550 = tmp___549;
                  }
#line 815
                  if (tmp___550) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                    tmp___545 = 1;
                  } else
#line 815
                  if ((long long )(n * item_size) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                    tmp___545 = 1;
                  } else
#line 815
                  if (9223372036854775807LL < (long long )(n * item_size)) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                    tmp___545 = 1;
                  } else {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                    tmp___545 = 0;
                  }
                }
#line 815
                tmp___551 = tmp___545;
              }
#line 815
              tmp___552 = tmp___551;
            }
#line 815
            tmp___553 = tmp___552;
          }
#line 815
          tmp___554 = tmp___553;
        }
#line 815
        tmp___555 = tmp___554;
      }
#line 815
      if (tmp___555) {
        {
#line 819
        xalloc_die();
        }
      }
    }
  }
  {
#line 820
  pa = xrealloc(pa, (size_t )nbytes);
#line 821
  *nitems = n;
  }
#line 822
  return (pa);
}
}
#line 834 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void *maybe_realloc(void *pa , ptrdiff_t i , ptrdiff_t *nitems , ptrdiff_t nitems_max ,
                           ptrdiff_t item_size ) 
{ 
  void *tmp ;

  {
#line 838
  if (i < *nitems) {
#line 839
    return (pa);
  }
  {
#line 840
  tmp = xpalloc(pa, nitems, (ptrdiff_t )1, nitems_max, item_size);
  }
#line 840
  return (tmp);
}
}
#line 844 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static ptrdiff_t charclass_index(struct dfa *d , charclass *s ) 
{ 
  ptrdiff_t i ;
  _Bool tmp ;
  void *tmp___0 ;

  {
#line 849
  i = (ptrdiff_t )0;
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    if (! (i < d->cindex)) {
#line 849
      goto while_break;
    }
    {
#line 850
    tmp = equal((charclass const   *)s, (charclass const   *)(d->charclasses + i));
    }
#line 850
    if (tmp) {
#line 851
      return (i);
    }
#line 849
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 852
  tmp___0 = maybe_realloc((void *)d->charclasses, d->cindex, & d->calloc, (ptrdiff_t )(TOKEN_MAX - 275L),
                          (ptrdiff_t )sizeof(*(d->charclasses)));
#line 852
  d->charclasses = (charclass *)tmp___0;
#line 854
  (d->cindex) ++;
#line 855
  *(d->charclasses + i) = *s;
  }
#line 856
  return (i);
}
}
#line 859 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool unibyte_word_constituent(struct dfa  const  *dfa , unsigned char c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 862
  if (dfa->localeinfo.sbctowc[c] != 4294967295U) {
    {
#line 862
    tmp = __ctype_b_loc();
    }
#line 862
    if ((int const   )*(*tmp + (int )c) & 8) {
#line 862
      tmp___0 = 1;
    } else
#line 862
    if ((int )c == 95) {
#line 862
      tmp___0 = 1;
    } else {
#line 862
      tmp___0 = 0;
    }
  } else {
#line 862
    tmp___0 = 0;
  }
#line 862
  return ((_Bool )tmp___0);
}
}
#line 865 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int char_context(struct dfa  const  *dfa , unsigned char c ) 
{ 
  _Bool tmp ;

  {
#line 868
  if ((int )c == (int )dfa->syntax.eolbyte) {
#line 868
    if (! dfa->syntax.anchor) {
#line 869
      return (4);
    }
  }
  {
#line 870
  tmp = unibyte_word_constituent(dfa, c);
  }
#line 870
  if (tmp) {
#line 871
    return (2);
  }
#line 872
  return (1);
}
}
#line 880 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool setbit_wc(wint_t wc , charclass *c ) 
{ 
  int b ;
  int tmp ;

  {
  {
#line 883
  tmp = wctob(wc);
#line 883
  b = tmp;
  }
#line 884
  if (b < 0) {
#line 885
    return ((_Bool)0);
  }
  {
#line 887
  setbit((unsigned int )b, c);
  }
#line 888
  return ((_Bool)1);
}
}
#line 893 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void setbit_case_fold_c(int b , charclass *c ) 
{ 
  int ub ;
  int tmp ;
  int i ;
  int tmp___0 ;

  {
  {
#line 896
  tmp = toupper(b);
#line 896
  ub = tmp;
#line 897
  i = 0;
  }
  {
#line 897
  while (1) {
    while_continue: /* CIL Label */ ;
#line 897
    if (! (i < 256)) {
#line 897
      goto while_break;
    }
    {
#line 898
    tmp___0 = toupper(i);
    }
#line 898
    if (tmp___0 == ub) {
      {
#line 899
      setbit((unsigned int )i, c);
      }
    }
#line 897
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  return;
}
}
#line 904 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool using_simple_locale(_Bool multibyte ) 
{ 
  char const   *loc ;
  char *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
#line 923
  if (multibyte) {
#line 924
    return ((_Bool)0);
  } else {
    {
#line 929
    tmp = setlocale(6, (char const   *)((void *)0));
#line 929
    loc = (char const   *)tmp;
    }
#line 930
    if (! loc) {
#line 930
      tmp___2 = 1;
    } else {
      {
#line 930
      tmp___0 = streq(loc, "C");
      }
#line 930
      if (tmp___0) {
#line 930
        tmp___2 = 1;
      } else {
        {
#line 930
        tmp___1 = streq(loc, "POSIX");
        }
#line 930
        if (tmp___1) {
#line 930
          tmp___2 = 1;
        } else {
#line 930
          tmp___2 = 0;
        }
      }
    }
#line 930
    return ((_Bool )tmp___2);
  }
}
}
#line 940 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int fetch_wc(struct dfa *dfa ) 
{ 
  size_t nbytes ;
  size_t tmp ;
  int c ;
  unsigned char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 943
  tmp = mbs_to_wchar(& dfa->lex.wctok, dfa->lex.ptr, dfa->lex.left, dfa);
#line 943
  nbytes = tmp;
#line 945
  dfa->lex.cur_mb_len = (int )nbytes;
  }
#line 946
  if (nbytes == 1UL) {
    {
#line 946
    tmp___0 = to_uchar___0((char )*(dfa->lex.ptr + 0));
#line 946
    tmp___1 = (int )tmp___0;
    }
  } else {
#line 946
    tmp___1 = -1;
  }
#line 946
  c = tmp___1;
#line 947
  dfa->lex.ptr += nbytes;
#line 948
  dfa->lex.left -= nbytes;
#line 949
  return (c);
}
}
#line 954 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int bracket_fetch_wc(struct dfa *dfa ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 957
  if (! dfa->lex.left) {
    {
#line 958
    tmp = gettext("unbalanced [");
#line 958
    dfaerror((char const   *)tmp);
    }
  }
  {
#line 959
  tmp___0 = fetch_wc(dfa);
  }
#line 959
  return (tmp___0);
}
}
#line 975 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static struct dfa_ctype  const  prednames[13]  = 
#line 975
  {      {"alpha", (predicate *)(& isalpha), (_Bool)0}, 
        {"upper", (predicate *)(& isupper), (_Bool)0}, 
        {"lower", (predicate *)(& islower), (_Bool)0}, 
        {"digit", (predicate *)(& isdigit), (_Bool)1}, 
        {"xdigit", (predicate *)(& isxdigit), (_Bool)0}, 
        {"space", (predicate *)(& isspace), (_Bool)0}, 
        {"punct", (predicate *)(& ispunct), (_Bool)0}, 
        {"alnum", (predicate *)(& isalnum), (_Bool)0}, 
        {"print", (predicate *)(& isprint), (_Bool)0}, 
        {"graph", (predicate *)(& isgraph), (_Bool)0}, 
        {"cntrl", (predicate *)(& iscntrl), (_Bool)0}, 
        {"blank", (predicate *)(& isblank), (_Bool)0}, 
        {(char const   *)((void *)0), (predicate *)((void *)0), (_Bool)0}};
#line 991 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static struct dfa_ctype  const  * __attribute__((__pure__)) find_pred(char const   *str ) 
{ 
  unsigned int i ;
  _Bool tmp ;

  {
#line 994
  i = 0U;
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 994
    if (! prednames[i].name) {
#line 994
      goto while_break;
    }
    {
#line 995
    tmp = streq(str, (char const   *)prednames[i].name);
    }
#line 995
    if (tmp) {
#line 996
      return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)(& prednames[i]));
    }
#line 994
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 997
  return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)((void *)0));
}
}
#line 1002 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static token parse_bracket_exp(struct dfa *dfa ) 
{ 
  _Bool known_bracket_exp ;
  int colon_warning_state ;
  charclass ccl ;
  int c ;
  int tmp ;
  _Bool invert ;
  wint_t wc ;
  int c1 ;
  wint_t wc1 ;
  char str[33] ;
  size_t len ;
  size_t tmp___0 ;
  char const   *class ;
  char const   *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  struct dfa_ctype  const  *pred ;
  struct dfa_ctype  const  * __attribute__((__pure__)) tmp___6 ;
  char *tmp___7 ;
  int c2 ;
  int tmp___8 ;
  int c2___0 ;
  int tmp___9 ;
  wint_t wc2 ;
  int ci ;
  unsigned short const   **tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;
  wchar_t folded[33] ;
  unsigned int n ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned int i ;
  void *tmp___17 ;
  ptrdiff_t tmp___18 ;
  _Bool tmp___19 ;
  char *tmp___20 ;
  ptrdiff_t tmp___22 ;
  _Bool tmp___23 ;
  ptrdiff_t tmp___24 ;

  {
  {
#line 1007
  known_bracket_exp = (_Bool)1;
#line 1016
  dfa->lex.brack.nchars = (ptrdiff_t )0;
#line 1018
  zeroset(& ccl);
#line 1019
  tmp = bracket_fetch_wc(dfa);
#line 1019
  c = tmp;
#line 1020
  invert = (_Bool )(c == 94);
  }
#line 1021
  if (invert) {
    {
#line 1023
    c = bracket_fetch_wc(dfa);
#line 1024
    known_bracket_exp = dfa->simple_locale;
    }
  }
#line 1026
  wc = dfa->lex.wctok;
#line 1029
  colon_warning_state = c == 58;
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1032
    c1 = 256;
#line 1033
    colon_warning_state &= -3;
#line 1039
    if (c == 91) {
      {
#line 1041
      c1 = bracket_fetch_wc(dfa);
#line 1042
      wc1 = dfa->lex.wctok;
      }
#line 1044
      if (c1 == 58) {
#line 1044
        if (dfa->syntax.syntax_bits & ((1UL << 1) << 1)) {
#line 1044
          goto _L___0;
        } else {
#line 1044
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1044
      if (c1 == 46) {
#line 1044
        goto _L___0;
      } else
#line 1044
      if (c1 == 61) {
        _L___0: /* CIL Label */ 
#line 1049
        len = (size_t )0;
        {
#line 1050
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1052
          c = bracket_fetch_wc(dfa);
          }
#line 1053
          if (dfa->lex.left == 0UL) {
#line 1055
            goto while_break___0;
          } else
#line 1053
          if (c == c1) {
#line 1053
            if ((int const   )*(dfa->lex.ptr + 0) == 93) {
#line 1055
              goto while_break___0;
            }
          }
#line 1056
          if (len < 32UL) {
#line 1057
            tmp___0 = len;
#line 1057
            len ++;
#line 1057
            str[tmp___0] = (char )c;
          } else {
#line 1060
            str[0] = (char )'\000';
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1062
        str[len] = (char )'\000';
#line 1065
        c = bracket_fetch_wc(dfa);
#line 1066
        wc = dfa->lex.wctok;
        }
#line 1067
        if (c1 == 58) {
#line 1073
          if (dfa->syntax.case_fold) {
            {
#line 1073
            tmp___4 = streq((char const   *)(str), "upper");
            }
#line 1073
            if (tmp___4) {
#line 1073
              tmp___3 = "alpha";
            } else {
              {
#line 1073
              tmp___5 = streq((char const   *)(str), "lower");
              }
#line 1073
              if (tmp___5) {
#line 1073
                tmp___3 = "alpha";
              } else {
#line 1073
                tmp___3 = (char const   *)(str);
              }
            }
          } else {
#line 1073
            tmp___3 = (char const   *)(str);
          }
          {
#line 1073
          class = tmp___3;
#line 1077
          tmp___6 = find_pred(class);
#line 1077
          pred = (struct dfa_ctype  const  *)tmp___6;
          }
#line 1078
          if (! pred) {
            {
#line 1079
            tmp___7 = gettext("invalid character class");
#line 1079
            dfaerror((char const   *)tmp___7);
            }
          }
#line 1081
          if (dfa->localeinfo.multibyte) {
#line 1081
            if (! pred->single_byte_only) {
#line 1082
              known_bracket_exp = (_Bool)0;
            } else {
#line 1081
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 1084
            c2 = 0;
            {
#line 1084
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1084
              if (! (c2 < 256)) {
#line 1084
                goto while_break___1;
              }
              {
#line 1085
              tmp___8 = (*(pred->func))(c2);
              }
#line 1085
              if (tmp___8) {
                {
#line 1086
                setbit((unsigned int )c2, & ccl);
                }
              }
#line 1084
              c2 ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        } else {
#line 1089
          known_bracket_exp = (_Bool)0;
        }
        {
#line 1091
        colon_warning_state |= 8;
#line 1094
        c1 = bracket_fetch_wc(dfa);
#line 1095
        wc1 = dfa->lex.wctok;
        }
#line 1096
        goto __Cont;
      }
    }
#line 1103
    if (c == 92) {
#line 1103
      if (dfa->syntax.syntax_bits & 1UL) {
        {
#line 1106
        c = bracket_fetch_wc(dfa);
#line 1107
        wc = dfa->lex.wctok;
        }
      }
    }
#line 1110
    if (c1 == 256) {
      {
#line 1112
      c1 = bracket_fetch_wc(dfa);
#line 1113
      wc1 = dfa->lex.wctok;
      }
    }
#line 1116
    if (c1 == 45) {
      {
#line 1119
      tmp___9 = bracket_fetch_wc(dfa);
#line 1119
      c2___0 = tmp___9;
#line 1120
      wc2 = dfa->lex.wctok;
      }
#line 1125
      if (c2___0 == 91) {
#line 1125
        if ((int const   )*(dfa->lex.ptr + 0) == 46) {
#line 1127
          known_bracket_exp = (_Bool)0;
#line 1128
          c2___0 = ']';
        }
      }
#line 1131
      if (c2___0 == 93) {
#line 1135
        dfa->lex.ptr -= dfa->lex.cur_mb_len;
#line 1136
        dfa->lex.left += (size_t )dfa->lex.cur_mb_len;
      } else {
#line 1140
        if (c2___0 == 92) {
#line 1140
          if (dfa->syntax.syntax_bits & 1UL) {
            {
#line 1143
            c2___0 = bracket_fetch_wc(dfa);
#line 1144
            wc2 = dfa->lex.wctok;
            }
          }
        }
        {
#line 1147
        colon_warning_state |= 8;
#line 1148
        c1 = bracket_fetch_wc(dfa);
#line 1149
        wc1 = dfa->lex.wctok;
        }
#line 1152
        if (wc != wc2) {
#line 1152
          goto _L___3;
        } else
#line 1152
        if (wc == 4294967295U) {
          _L___3: /* CIL Label */ 
#line 1154
          if (dfa->simple_locale) {
#line 1154
            goto _L___2;
          } else {
            {
#line 1154
            tmp___11 = isasciidigit((char )c);
#line 1154
            tmp___12 = isasciidigit((char )c2___0);
            }
#line 1154
            if ((int )tmp___11 & (int )tmp___12) {
              _L___2: /* CIL Label */ 
#line 1157
              ci = c;
              {
#line 1157
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 1157
                if (! (ci <= c2___0)) {
#line 1157
                  goto while_break___2;
                }
#line 1158
                if (dfa->syntax.case_fold) {
                  {
#line 1158
                  tmp___10 = __ctype_b_loc();
                  }
#line 1158
                  if ((int const   )*(*tmp___10 + ci) & 1024) {
                    {
#line 1159
                    setbit_case_fold_c(ci, & ccl);
                    }
                  } else {
                    {
#line 1161
                    setbit((unsigned int )ci, & ccl);
                    }
                  }
                } else {
                  {
#line 1161
                  setbit((unsigned int )ci, & ccl);
                  }
                }
#line 1157
                ci ++;
              }
              while_break___2: /* CIL Label */ ;
              }
            } else {
#line 1164
              known_bracket_exp = (_Bool)0;
            }
          }
#line 1166
          goto __Cont;
        }
      }
    }
#line 1171
    if (c == 58) {
#line 1171
      tmp___13 = 2;
    } else {
#line 1171
      tmp___13 = 4;
    }
#line 1171
    colon_warning_state |= tmp___13;
#line 1173
    if (! dfa->localeinfo.multibyte) {
#line 1175
      if (dfa->syntax.case_fold) {
        {
#line 1175
        tmp___14 = __ctype_b_loc();
        }
#line 1175
        if ((int const   )*(*tmp___14 + c) & 1024) {
          {
#line 1176
          setbit_case_fold_c(c, & ccl);
          }
        } else {
          {
#line 1178
          setbit((unsigned int )c, & ccl);
          }
        }
      } else {
        {
#line 1178
        setbit((unsigned int )c, & ccl);
        }
      }
#line 1179
      goto __Cont;
    }
#line 1182
    if (wc == 4294967295U) {
#line 1183
      known_bracket_exp = (_Bool)0;
    } else {
#line 1187
      if (dfa->syntax.case_fold) {
        {
#line 1187
        tmp___15 = case_folded_counterparts(wc, (wchar_t *)(folded + 1));
#line 1187
        tmp___16 = tmp___15 + 1;
        }
      } else {
#line 1187
        tmp___16 = 1;
      }
#line 1187
      n = (unsigned int )tmp___16;
#line 1190
      folded[0] = (wchar_t )wc;
#line 1191
      i = 0U;
      {
#line 1191
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1191
        if (! (i < n)) {
#line 1191
          goto while_break___3;
        }
        {
#line 1192
        tmp___19 = setbit_wc((wint_t )folded[i], & ccl);
        }
#line 1192
        if (! tmp___19) {
          {
#line 1194
          tmp___17 = maybe_realloc((void *)dfa->lex.brack.chars, dfa->lex.brack.nchars,
                                   & dfa->lex.brack.nchars_alloc, (ptrdiff_t )-1,
                                   (ptrdiff_t )sizeof(*(dfa->lex.brack.chars)));
#line 1194
          dfa->lex.brack.chars = (wchar_t *)tmp___17;
#line 1198
          tmp___18 = dfa->lex.brack.nchars;
#line 1198
          (dfa->lex.brack.nchars) ++;
#line 1198
          *(dfa->lex.brack.chars + tmp___18) = folded[i];
          }
        }
#line 1191
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1030
    wc = wc1;
#line 1030
    c = c1;
#line 1030
    if (! (c != 93)) {
#line 1030
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1204
  if (colon_warning_state == 7) {
    {
#line 1205
    tmp___20 = gettext("character class syntax is [[:space:]], not [:space:]");
#line 1205
    dfawarn((char const   *)tmp___20);
    }
  }
#line 1207
  if (! known_bracket_exp) {
#line 1208
    return ((token )257);
  }
#line 1210
  if (dfa->localeinfo.multibyte) {
#line 1210
    if (invert) {
#line 1210
      goto _L___4;
    } else
#line 1210
    if (dfa->lex.brack.nchars != 0L) {
      _L___4: /* CIL Label */ 
      {
#line 1212
      dfa->lex.brack.invert = invert;
#line 1213
      tmp___23 = emptyset((charclass const   *)(& ccl));
      }
#line 1213
      if (tmp___23) {
#line 1213
        dfa->lex.brack.cset = (ptrdiff_t )-1;
      } else {
        {
#line 1213
        tmp___22 = charclass_index(dfa, & ccl);
#line 1213
        dfa->lex.brack.cset = tmp___22;
        }
      }
#line 1214
      return ((token )273);
    }
  }
#line 1217
  if (invert) {
    {
#line 1219
    notset(& ccl);
    }
#line 1220
    if (dfa->syntax.syntax_bits & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 1221
      clrbit((unsigned int )'\n', & ccl);
      }
    }
  }
  {
#line 1224
  tmp___24 = charclass_index(dfa, & ccl);
  }
#line 1224
  return (275L + tmp___24);
}
}
#line 1233 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void push_lex_state(struct dfa *dfa , struct lexptr *ls , char const   *s ) 
{ 


  {
  {
#line 1236
  ls->ptr = dfa->lex.ptr;
#line 1237
  ls->left = dfa->lex.left;
#line 1238
  dfa->lex.ptr = s;
#line 1239
  dfa->lex.left = strlen(s);
  }
#line 1240
  return;
}
}
#line 1242 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void pop_lex_state(struct dfa *dfa , struct lexptr  const  *ls ) 
{ 


  {
#line 1245
  dfa->lex.ptr = (char const   *)ls->ptr;
#line 1246
  dfa->lex.left = (size_t )ls->left;
#line 1247
  return;
}
}
#line 1249 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static token lex(struct dfa *dfa ) 
{ 
  _Bool backslash ;
  int i ;
  token tmp ;
  int c ;
  int tmp___0 ;
  char *tmp___1 ;
  token tmp___2 ;
  token tmp___3 ;
  token tmp___4 ;
  token tmp___5 ;
  token tmp___6 ;
  token tmp___7 ;
  token tmp___8 ;
  token tmp___9 ;
  token tmp___10 ;
  token tmp___11 ;
  token tmp___12 ;
  token tmp___13 ;
  char const   *p ;
  char const   *lim ;
  int tmp___14 ;
  int tmp___15 ;
  _Bool tmp___16 ;
  int tmp___17 ;
  _Bool tmp___18 ;
  char *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  token tmp___23 ;
  token tmp___24 ;
  token tmp___25 ;
  token tmp___26 ;
  token tmp___27 ;
  charclass ccl ;
  int c2 ;
  ptrdiff_t tmp___28 ;
  token tmp___29 ;
  charclass ccl___0 ;
  int c2___0 ;
  unsigned short const   **tmp___30 ;
  token tmp___31 ;
  ptrdiff_t tmp___32 ;
  struct lexptr ls ;
  charclass ccl___1 ;
  int c2___1 ;
  token tmp___33 ;
  ptrdiff_t tmp___34 ;
  struct lexptr ls___0 ;
  token tmp___35 ;
  token tmp___36 ;
  charclass ccl___2 ;
  token tmp___37 ;
  ptrdiff_t tmp___38 ;
  unsigned short const   **tmp___39 ;
  token tmp___40 ;

  {
#line 1252
  backslash = (_Bool)0;
#line 1260
  i = 0;
  {
#line 1260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1260
    if (! (i < 2)) {
#line 1260
      goto while_break;
    }
#line 1262
    if (! dfa->lex.left) {
#line 1263
      tmp = (token )-1;
#line 1263
      dfa->lex.lasttok = tmp;
#line 1263
      return (tmp);
    }
    {
#line 1264
    tmp___0 = fetch_wc(dfa);
#line 1264
    c = tmp___0;
    }
    {
#line 1268
    if (c == 92) {
#line 1268
      goto case_92;
    }
#line 1276
    if (c == 94) {
#line 1276
      goto case_94;
    }
#line 1285
    if (c == 36) {
#line 1285
      goto case_36;
    }
#line 1313
    if (c == 57) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 56) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 55) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 54) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 53) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 52) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 51) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 50) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 49) {
#line 1313
      goto case_57;
    }
#line 1321
    if (c == 96) {
#line 1321
      goto case_96;
    }
#line 1329
    if (c == 39) {
#line 1329
      goto case_39;
    }
#line 1337
    if (c == 60) {
#line 1337
      goto case_60;
    }
#line 1342
    if (c == 62) {
#line 1342
      goto case_62;
    }
#line 1347
    if (c == 98) {
#line 1347
      goto case_98;
    }
#line 1352
    if (c == 66) {
#line 1352
      goto case_66;
    }
#line 1357
    if (c == 63) {
#line 1357
      goto case_63;
    }
#line 1367
    if (c == 42) {
#line 1367
      goto case_42;
    }
#line 1375
    if (c == 43) {
#line 1375
      goto case_43;
    }
#line 1385
    if (c == 123) {
#line 1385
      goto case_123;
    }
#line 1443
    if (c == 124) {
#line 1443
      goto case_124;
    }
#line 1451
    if (c == 10) {
#line 1451
      goto case_10;
    }
#line 1458
    if (c == 40) {
#line 1458
      goto case_40;
    }
#line 1465
    if (c == 41) {
#line 1465
      goto case_41;
    }
#line 1475
    if (c == 46) {
#line 1475
      goto case_46;
    }
#line 1498
    if (c == 83) {
#line 1498
      goto case_83;
    }
#line 1498
    if (c == 115) {
#line 1498
      goto case_83;
    }
#line 1531
    if (c == 87) {
#line 1531
      goto case_87;
    }
#line 1531
    if (c == 119) {
#line 1531
      goto case_87;
    }
#line 1564
    if (c == 91) {
#line 1564
      goto case_91;
    }
#line 1570
    goto normal_char;
    case_92: /* CIL Label */ 
#line 1269
    if (backslash) {
#line 1270
      goto normal_char;
    }
#line 1271
    if (dfa->lex.left == 0UL) {
      {
#line 1272
      tmp___1 = gettext("unfinished \\ escape");
#line 1272
      dfaerror((char const   *)tmp___1);
      }
    }
#line 1273
    backslash = (_Bool)1;
#line 1274
    goto switch_break;
    case_94: /* CIL Label */ 
#line 1277
    if (backslash) {
#line 1278
      goto normal_char;
    }
#line 1279
    if (dfa->syntax.syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1282
      tmp___2 = (token )258;
#line 1282
      dfa->lex.lasttok = tmp___2;
#line 1282
      return (tmp___2);
    } else
#line 1279
    if (dfa->lex.lasttok == -1L) {
#line 1282
      tmp___2 = (token )258;
#line 1282
      dfa->lex.lasttok = tmp___2;
#line 1282
      return (tmp___2);
    } else
#line 1279
    if (dfa->lex.lasttok == 270L) {
#line 1282
      tmp___2 = (token )258;
#line 1282
      dfa->lex.lasttok = tmp___2;
#line 1282
      return (tmp___2);
    } else
#line 1279
    if (dfa->lex.lasttok == 269L) {
#line 1282
      tmp___2 = (token )258;
#line 1282
      dfa->lex.lasttok = tmp___2;
#line 1282
      return (tmp___2);
    }
#line 1283
    goto normal_char;
    case_36: /* CIL Label */ 
#line 1286
    if (backslash) {
#line 1287
      goto normal_char;
    }
#line 1288
    if (dfa->syntax.syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1302
      tmp___3 = (token )259;
#line 1302
      dfa->lex.lasttok = tmp___3;
#line 1302
      return (tmp___3);
    } else
#line 1288
    if (dfa->lex.left == 0UL) {
#line 1302
      tmp___3 = (token )259;
#line 1302
      dfa->lex.lasttok = tmp___3;
#line 1302
      return (tmp___3);
    } else
#line 1288
    if (dfa->lex.left > (size_t )(! (dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1288
      if ((int const   )*(dfa->lex.ptr + (! (dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ((int const   )*(dfa->lex.ptr + 0) == 92))) == 41) {
#line 1302
        tmp___3 = (token )259;
#line 1302
        dfa->lex.lasttok = tmp___3;
#line 1302
        return (tmp___3);
      } else {
#line 1288
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1288
    if (dfa->lex.left > (size_t )(! (dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1288
      if ((int const   )*(dfa->lex.ptr + (! (dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ((int const   )*(dfa->lex.ptr + 0) == 92))) == 124) {
#line 1302
        tmp___3 = (token )259;
#line 1302
        dfa->lex.lasttok = tmp___3;
#line 1302
        return (tmp___3);
      } else {
#line 1288
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1288
    if (dfa->syntax.syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1288
      if (dfa->lex.left > 0UL) {
#line 1288
        if ((int const   )*(dfa->lex.ptr + 0) == 10) {
#line 1302
          tmp___3 = (token )259;
#line 1302
          dfa->lex.lasttok = tmp___3;
#line 1302
          return (tmp___3);
        }
      }
    }
#line 1303
    goto normal_char;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1314
    if (backslash) {
#line 1314
      if (! (dfa->syntax.syntax_bits & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1316
        dfa->lex.laststart = (_Bool)0;
#line 1317
        tmp___4 = (token )257;
#line 1317
        dfa->lex.lasttok = tmp___4;
#line 1317
        return (tmp___4);
      }
    }
#line 1319
    goto normal_char;
    case_96: /* CIL Label */ 
#line 1322
    if (backslash) {
#line 1322
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1325
        tmp___5 = (token )258;
#line 1325
        dfa->lex.lasttok = tmp___5;
#line 1325
        return (tmp___5);
      }
    }
#line 1327
    goto normal_char;
    case_39: /* CIL Label */ 
#line 1330
    if (backslash) {
#line 1330
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1333
        tmp___6 = (token )259;
#line 1333
        dfa->lex.lasttok = tmp___6;
#line 1333
        return (tmp___6);
      }
    }
#line 1335
    goto normal_char;
    case_60: /* CIL Label */ 
#line 1338
    if (backslash) {
#line 1338
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1339
        tmp___7 = (token )260;
#line 1339
        dfa->lex.lasttok = tmp___7;
#line 1339
        return (tmp___7);
      }
    }
#line 1340
    goto normal_char;
    case_62: /* CIL Label */ 
#line 1343
    if (backslash) {
#line 1343
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1344
        tmp___8 = (token )261;
#line 1344
        dfa->lex.lasttok = tmp___8;
#line 1344
        return (tmp___8);
      }
    }
#line 1345
    goto normal_char;
    case_98: /* CIL Label */ 
#line 1348
    if (backslash) {
#line 1348
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1349
        tmp___9 = (token )262;
#line 1349
        dfa->lex.lasttok = tmp___9;
#line 1349
        return (tmp___9);
      }
    }
#line 1350
    goto normal_char;
    case_66: /* CIL Label */ 
#line 1353
    if (backslash) {
#line 1353
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1354
        tmp___10 = (token )263;
#line 1354
        dfa->lex.lasttok = tmp___10;
#line 1354
        return (tmp___10);
      }
    }
#line 1355
    goto normal_char;
    case_63: /* CIL Label */ 
#line 1358
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1359
      goto normal_char;
    }
#line 1360
    if ((int )backslash != ((dfa->syntax.syntax_bits & (1UL << 1)) != 0UL)) {
#line 1361
      goto normal_char;
    }
#line 1362
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1362
      if (dfa->lex.laststart) {
#line 1364
        goto normal_char;
      }
    }
#line 1365
    tmp___11 = (token )264;
#line 1365
    dfa->lex.lasttok = tmp___11;
#line 1365
    return (tmp___11);
    case_42: /* CIL Label */ 
#line 1368
    if (backslash) {
#line 1369
      goto normal_char;
    }
#line 1370
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1370
      if (dfa->lex.laststart) {
#line 1372
        goto normal_char;
      }
    }
#line 1373
    tmp___12 = (token )265;
#line 1373
    dfa->lex.lasttok = tmp___12;
#line 1373
    return (tmp___12);
    case_43: /* CIL Label */ 
#line 1376
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1377
      goto normal_char;
    }
#line 1378
    if ((int )backslash != ((dfa->syntax.syntax_bits & (1UL << 1)) != 0UL)) {
#line 1379
      goto normal_char;
    }
#line 1380
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1380
      if (dfa->lex.laststart) {
#line 1382
        goto normal_char;
      }
    }
#line 1383
    tmp___13 = (token )266;
#line 1383
    dfa->lex.lasttok = tmp___13;
#line 1383
    return (tmp___13);
    case_123: /* CIL Label */ 
#line 1386
    if (! (dfa->syntax.syntax_bits & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1387
      goto normal_char;
    }
#line 1388
    if ((int )backslash != ((dfa->syntax.syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1389
      goto normal_char;
    }
#line 1390
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1390
      if (dfa->lex.laststart) {
#line 1392
        goto normal_char;
      }
    }
#line 1401
    p = dfa->lex.ptr;
#line 1402
    lim = p + dfa->lex.left;
#line 1403
    tmp___14 = -1;
#line 1403
    dfa->lex.maxrep = tmp___14;
#line 1403
    dfa->lex.minrep = tmp___14;
    {
#line 1404
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1404
      if ((unsigned long )p != (unsigned long )lim) {
        {
#line 1404
        tmp___16 = isasciidigit((char )*p);
        }
#line 1404
        if (! tmp___16) {
#line 1404
          goto while_break___0;
        }
      } else {
#line 1404
        goto while_break___0;
      }
#line 1405
      if (dfa->lex.minrep < 0) {
#line 1405
        dfa->lex.minrep = (int )((int const   )*p - 48);
      } else {
#line 1405
        if (32768 < (dfa->lex.minrep * 10 + (int )*p) - 48) {
#line 1405
          tmp___15 = 32768;
        } else {
#line 1405
          tmp___15 = (dfa->lex.minrep * 10 + (int )*p) - 48;
        }
#line 1405
        dfa->lex.minrep = tmp___15;
      }
#line 1404
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1409
    if ((unsigned long )p != (unsigned long )lim) {
#line 1411
      if ((int const   )*p != 44) {
#line 1412
        dfa->lex.maxrep = dfa->lex.minrep;
      } else {
#line 1415
        if (dfa->lex.minrep < 0) {
#line 1416
          dfa->lex.minrep = 0;
        }
        {
#line 1417
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1417
          p ++;
#line 1417
          if ((unsigned long )p != (unsigned long )lim) {
            {
#line 1417
            tmp___18 = isasciidigit((char )*p);
            }
#line 1417
            if (! tmp___18) {
#line 1417
              goto while_break___1;
            }
          } else {
#line 1417
            goto while_break___1;
          }
#line 1418
          if (dfa->lex.maxrep < 0) {
#line 1418
            dfa->lex.maxrep = (int )((int const   )*p - 48);
          } else {
#line 1418
            if (32768 < (dfa->lex.maxrep * 10 + (int )*p) - 48) {
#line 1418
              tmp___17 = 32768;
            } else {
#line 1418
              tmp___17 = (dfa->lex.maxrep * 10 + (int )*p) - 48;
            }
#line 1418
            dfa->lex.maxrep = tmp___17;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 1425
    if (! backslash) {
#line 1425
      goto _L___5;
    } else
#line 1425
    if ((unsigned long )p != (unsigned long )lim) {
#line 1425
      tmp___20 = p;
#line 1425
      p ++;
#line 1425
      if ((int const   )*tmp___20 == 92) {
        _L___5: /* CIL Label */ 
#line 1425
        if ((unsigned long )p != (unsigned long )lim) {
#line 1425
          tmp___21 = p;
#line 1425
          p ++;
#line 1425
          if ((int const   )*tmp___21 == 125) {
#line 1425
            if (0 <= dfa->lex.minrep) {
#line 1425
              if (! (dfa->lex.maxrep < 0)) {
#line 1425
                if (! (dfa->lex.minrep <= dfa->lex.maxrep)) {
#line 1425
                  goto _L___6;
                }
              }
            } else {
#line 1425
              goto _L___6;
            }
          } else {
#line 1425
            goto _L___6;
          }
        } else {
#line 1425
          goto _L___6;
        }
      } else {
#line 1425
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
#line 1431
      if (dfa->syntax.syntax_bits & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1432
        goto normal_char;
      }
      {
#line 1433
      tmp___19 = gettext("invalid content of \\{\\}");
#line 1433
      dfaerror((char const   *)tmp___19);
      }
    }
#line 1435
    if (32767 < dfa->lex.maxrep) {
      {
#line 1436
      tmp___22 = gettext("regular expression too big");
#line 1436
      dfaerror((char const   *)tmp___22);
      }
    }
#line 1437
    dfa->lex.ptr = p;
#line 1438
    dfa->lex.left = (size_t )(lim - p);
#line 1440
    dfa->lex.laststart = (_Bool)0;
#line 1441
    tmp___23 = (token )267;
#line 1441
    dfa->lex.lasttok = tmp___23;
#line 1441
    return (tmp___23);
    case_124: /* CIL Label */ 
#line 1444
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1445
      goto normal_char;
    }
#line 1446
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1447
      goto normal_char;
    }
#line 1448
    dfa->lex.laststart = (_Bool)1;
#line 1449
    tmp___24 = (token )269;
#line 1449
    dfa->lex.lasttok = tmp___24;
#line 1449
    return (tmp___24);
    case_10: /* CIL Label */ 
#line 1452
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1454
      goto normal_char;
    } else
#line 1452
    if (backslash) {
#line 1454
      goto normal_char;
    } else
#line 1452
    if (! (dfa->syntax.syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1454
      goto normal_char;
    }
#line 1455
    dfa->lex.laststart = (_Bool)1;
#line 1456
    tmp___25 = (token )269;
#line 1456
    dfa->lex.lasttok = tmp___25;
#line 1456
    return (tmp___25);
    case_40: /* CIL Label */ 
#line 1459
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1460
      goto normal_char;
    }
#line 1461
    (dfa->lex.parens) ++;
#line 1462
    dfa->lex.laststart = (_Bool)1;
#line 1463
    tmp___26 = (token )270;
#line 1463
    dfa->lex.lasttok = tmp___26;
#line 1463
    return (tmp___26);
    case_41: /* CIL Label */ 
#line 1466
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1467
      goto normal_char;
    }
#line 1468
    if (dfa->lex.parens == 0UL) {
#line 1468
      if (dfa->syntax.syntax_bits & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1470
        goto normal_char;
      }
    }
#line 1471
    (dfa->lex.parens) --;
#line 1472
    dfa->lex.laststart = (_Bool)0;
#line 1473
    tmp___27 = (token )271;
#line 1473
    dfa->lex.lasttok = tmp___27;
#line 1473
    return (tmp___27);
    case_46: /* CIL Label */ 
#line 1476
    if (backslash) {
#line 1477
      goto normal_char;
    }
#line 1478
    if (dfa->canychar == 0xffffffffffffffffUL) {
      {
#line 1481
      fillset(& ccl);
      }
#line 1482
      if (! (dfa->syntax.syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
        {
#line 1483
        clrbit((unsigned int )'\n', & ccl);
        }
      }
#line 1484
      if (dfa->syntax.syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
#line 1485
        clrbit((unsigned int )'\000', & ccl);
        }
      }
#line 1486
      if (dfa->localeinfo.multibyte) {
#line 1487
        c2 = 0;
        {
#line 1487
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1487
          if (! (c2 < 256)) {
#line 1487
            goto while_break___2;
          }
#line 1488
          if (dfa->localeinfo.sbctowc[c2] == 4294967295U) {
            {
#line 1489
            clrbit((unsigned int )c2, & ccl);
            }
          }
#line 1487
          c2 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 1490
      tmp___28 = charclass_index(dfa, & ccl);
#line 1490
      dfa->canychar = (size_t )tmp___28;
      }
    }
#line 1492
    dfa->lex.laststart = (_Bool)0;
#line 1493
    if (dfa->localeinfo.multibyte) {
#line 1493
      tmp___29 = (token )272;
    } else {
#line 1493
      tmp___29 = (token )(275UL + dfa->canychar);
    }
#line 1493
    dfa->lex.lasttok = tmp___29;
#line 1493
    return (tmp___29);
    case_83: /* CIL Label */ 
    case_115: /* CIL Label */ 
#line 1499
    if (! backslash) {
#line 1500
      goto normal_char;
    } else
#line 1499
    if (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1500
      goto normal_char;
    }
#line 1501
    if (! dfa->localeinfo.multibyte) {
      {
#line 1504
      zeroset(& ccl___0);
#line 1505
      c2___0 = 0;
      }
      {
#line 1505
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1505
        if (! (c2___0 < 256)) {
#line 1505
          goto while_break___3;
        }
        {
#line 1506
        tmp___30 = __ctype_b_loc();
        }
#line 1506
        if ((int const   )*(*tmp___30 + c2___0) & 8192) {
          {
#line 1507
          setbit((unsigned int )c2___0, & ccl___0);
          }
        }
#line 1505
        c2___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1508
      if (c == 83) {
        {
#line 1509
        notset(& ccl___0);
        }
      }
      {
#line 1510
      dfa->lex.laststart = (_Bool)0;
#line 1511
      tmp___32 = charclass_index(dfa, & ccl___0);
#line 1511
      tmp___31 = 275L + tmp___32;
#line 1511
      dfa->lex.lasttok = tmp___31;
      }
#line 1511
      return (tmp___31);
    }
    {
#line 1522
    push_lex_state(dfa, & ls, "^[:space:]]" + (c == 115));
#line 1523
    dfa->lex.lasttok = parse_bracket_exp(dfa);
#line 1524
    pop_lex_state(dfa, (struct lexptr  const  *)(& ls));
#line 1527
    dfa->lex.laststart = (_Bool)0;
    }
#line 1528
    return (dfa->lex.lasttok);
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
#line 1532
    if (! backslash) {
#line 1533
      goto normal_char;
    } else
#line 1532
    if (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1533
      goto normal_char;
    }
#line 1535
    if (! dfa->localeinfo.multibyte) {
      {
#line 1538
      zeroset(& ccl___1);
#line 1539
      c2___1 = 0;
      }
      {
#line 1539
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1539
        if (! (c2___1 < 256)) {
#line 1539
          goto while_break___4;
        }
#line 1540
        if ((int )dfa->syntax.sbit[c2___1] == 2) {
          {
#line 1541
          setbit((unsigned int )c2___1, & ccl___1);
          }
        }
#line 1539
        c2___1 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1542
      if (c == 87) {
        {
#line 1543
        notset(& ccl___1);
        }
      }
      {
#line 1544
      dfa->lex.laststart = (_Bool)0;
#line 1545
      tmp___34 = charclass_index(dfa, & ccl___1);
#line 1545
      tmp___33 = 275L + tmp___34;
#line 1545
      dfa->lex.lasttok = tmp___33;
      }
#line 1545
      return (tmp___33);
    }
    {
#line 1556
    push_lex_state(dfa, & ls___0, "^_[:alnum:]]" + (c == 119));
#line 1557
    dfa->lex.lasttok = parse_bracket_exp(dfa);
#line 1558
    pop_lex_state(dfa, (struct lexptr  const  *)(& ls___0));
#line 1561
    dfa->lex.laststart = (_Bool)0;
    }
#line 1562
    return (dfa->lex.lasttok);
    case_91: /* CIL Label */ 
#line 1565
    if (backslash) {
#line 1566
      goto normal_char;
    }
    {
#line 1567
    dfa->lex.laststart = (_Bool)0;
#line 1568
    tmp___35 = parse_bracket_exp(dfa);
#line 1568
    dfa->lex.lasttok = tmp___35;
    }
#line 1568
    return (tmp___35);
    normal_char: 
    switch_default: /* CIL Label */ 
#line 1572
    dfa->lex.laststart = (_Bool)0;
#line 1575
    if (dfa->localeinfo.multibyte) {
#line 1576
      tmp___36 = (token )274;
#line 1576
      dfa->lex.lasttok = tmp___36;
#line 1576
      return (tmp___36);
    }
#line 1578
    if (dfa->syntax.case_fold) {
      {
#line 1578
      tmp___39 = __ctype_b_loc();
      }
#line 1578
      if ((int const   )*(*tmp___39 + c) & 1024) {
        {
#line 1581
        zeroset(& ccl___2);
#line 1582
        setbit_case_fold_c(c, & ccl___2);
#line 1583
        tmp___38 = charclass_index(dfa, & ccl___2);
#line 1583
        tmp___37 = 275L + tmp___38;
#line 1583
        dfa->lex.lasttok = tmp___37;
        }
#line 1583
        return (tmp___37);
      }
    }
#line 1586
    tmp___40 = (token )c;
#line 1586
    dfa->lex.lasttok = tmp___40;
#line 1586
    return (tmp___40);
    switch_break: /* CIL Label */ ;
    }
#line 1260
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1592
  abort();
  }
#line 1593
  return ((token )-1);
}
}
#line 1596 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void addtok_mb(struct dfa *dfa , token t , char mbprop ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1599
  if (dfa->talloc == dfa->tindex) {
    {
#line 1601
    tmp = x2nrealloc((void *)dfa->tokens, & dfa->talloc, sizeof(*(dfa->tokens)));
#line 1601
    dfa->tokens = (token *)tmp;
    }
#line 1603
    if (dfa->localeinfo.multibyte) {
      {
#line 1604
      tmp___0 = xnrealloc((void *)dfa->multibyte_prop, dfa->talloc, sizeof(*(dfa->multibyte_prop)));
#line 1604
      dfa->multibyte_prop = (char *)tmp___0;
      }
    }
  }
#line 1607
  if (dfa->localeinfo.multibyte) {
#line 1608
    *(dfa->multibyte_prop + dfa->tindex) = mbprop;
  }
#line 1609
  tmp___1 = dfa->tindex;
#line 1609
  (dfa->tindex) ++;
#line 1609
  *(dfa->tokens + tmp___1) = t;
  {
#line 1615
  if (t == 266L) {
#line 1615
    goto case_266;
  }
#line 1615
  if (t == 265L) {
#line 1615
    goto case_266;
  }
#line 1615
  if (t == 264L) {
#line 1615
    goto case_266;
  }
#line 1619
  if (t == 269L) {
#line 1619
    goto case_269;
  }
#line 1619
  if (t == 268L) {
#line 1619
    goto case_269;
  }
#line 1623
  if (t == 257L) {
#line 1623
    goto case_257;
  }
#line 1629
  if (t == 256L) {
#line 1629
    goto case_256;
  }
#line 1626
  goto switch_default;
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
#line 1616
  goto switch_break;
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
#line 1620
  (dfa->parse.depth) --;
#line 1621
  goto switch_break;
  case_257: /* CIL Label */ 
#line 1624
  dfa->fast = (_Bool)0;
  switch_default: /* CIL Label */ 
#line 1627
  (dfa->nleaves) ++;
  case_256: /* CIL Label */ 
#line 1630
  (dfa->parse.depth) ++;
#line 1631
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1633
  if (dfa->parse.depth > dfa->depth) {
#line 1634
    dfa->depth = dfa->parse.depth;
  }
#line 1635
  return;
}
}
#line 1637
static void addtok_wc(struct dfa *dfa , wint_t wc ) ;
#line 1641 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void addtok(struct dfa *dfa , token t ) 
{ 
  _Bool need_or ;
  ptrdiff_t i ;

  {
#line 1644
  if (dfa->localeinfo.multibyte) {
#line 1644
    if (t == 273L) {
#line 1646
      need_or = (_Bool)0;
#line 1650
      i = (ptrdiff_t )0;
      {
#line 1650
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1650
        if (! (i < dfa->lex.brack.nchars)) {
#line 1650
          goto while_break;
        }
        {
#line 1652
        addtok_wc(dfa, (wint_t )*(dfa->lex.brack.chars + i));
        }
#line 1653
        if (need_or) {
          {
#line 1654
          addtok(dfa, (token )269);
          }
        }
#line 1655
        need_or = (_Bool)1;
#line 1650
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1657
      dfa->lex.brack.nchars = (ptrdiff_t )0;
#line 1661
      if (dfa->lex.brack.cset != -1L) {
        {
#line 1663
        addtok(dfa, 275L + dfa->lex.brack.cset);
        }
#line 1664
        if (need_or) {
          {
#line 1665
          addtok(dfa, (token )269);
          }
        }
      }
    } else {
      {
#line 1670
      addtok_mb(dfa, t, (char)3);
      }
    }
  } else {
    {
#line 1670
    addtok_mb(dfa, t, (char)3);
    }
  }
#line 1672
  return;
}
}
#line 1680 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void addtok_wc(struct dfa *dfa , wint_t wc ) 
{ 
  unsigned char buf[16] ;
  mbstate_t s ;
  size_t stored_bytes ;
  size_t tmp ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 1684
  s.__count = 0;
#line 1684
  s.__value.__wch = 0U;
#line 1685
  tmp = wcrtomb((char */* __restrict  */)((char *)(buf)), (wchar_t )wc, (mbstate_t */* __restrict  */)(& s));
#line 1685
  stored_bytes = tmp;
  }
#line 1687
  if (stored_bytes != 0xffffffffffffffffUL) {
#line 1688
    dfa->lex.cur_mb_len = (int )stored_bytes;
  } else {
#line 1693
    dfa->lex.cur_mb_len = 1;
#line 1694
    buf[0] = (unsigned char)0;
  }
#line 1697
  if (dfa->lex.cur_mb_len == 1) {
#line 1697
    tmp___0 = 3;
  } else {
#line 1697
    tmp___0 = 1;
  }
  {
#line 1697
  addtok_mb(dfa, (token )buf[0], (char )tmp___0);
#line 1698
  i = 1;
  }
  {
#line 1698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1698
    if (! (i < dfa->lex.cur_mb_len)) {
#line 1698
      goto while_break;
    }
#line 1700
    if (i == dfa->lex.cur_mb_len - 1) {
#line 1700
      tmp___1 = 2;
    } else {
#line 1700
      tmp___1 = 0;
    }
    {
#line 1700
    addtok_mb(dfa, (token )buf[i], (char )tmp___1);
#line 1701
    addtok(dfa, (token )268);
#line 1698
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1703
  return;
}
}
#line 1708
static void add_utf8_anychar(struct dfa *dfa ) ;
#line 1708 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static charclass const   utf8_classes[5]  = {      {{0UL, 0UL, (4294967295UL << 32) + 4294967295UL, 0UL}}, 
        {{(4294967295UL << 32) + 4294967295UL, (4294967295UL << 32) + 4294967295UL, 0UL,
       0UL}}, 
        {{0UL, 0UL, 0UL, 4294967292UL}}, 
        {{0UL, 0UL, 0UL, 65535UL << 32}}, 
        {{0UL, 0UL, 0UL, 16711680UL << 32}}};
#line 1705 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void add_utf8_anychar(struct dfa *dfa ) 
{ 
  unsigned int n ;
  unsigned int i ;
  charclass c ;
  ptrdiff_t tmp ;
  unsigned int i___0 ;

  {
#line 1724
  n = (unsigned int )(sizeof(utf8_classes) / sizeof(utf8_classes[0]));
#line 1727
  if (dfa->utf8_anychar_classes[0] == 0L) {
#line 1728
    i = 0U;
    {
#line 1728
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1728
      if (! (i < n)) {
#line 1728
        goto while_break;
      }
#line 1730
      c = utf8_classes[i];
#line 1731
      if (i == 1U) {
#line 1733
        if (! (dfa->syntax.syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
          {
#line 1734
          clrbit((unsigned int )'\n', & c);
          }
        }
#line 1735
        if (dfa->syntax.syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          {
#line 1736
          clrbit((unsigned int )'\000', & c);
          }
        }
      }
      {
#line 1738
      tmp = charclass_index(dfa, & c);
#line 1738
      dfa->utf8_anychar_classes[i] = 275L + tmp;
#line 1728
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1752
  i___0 = 1U;
  {
#line 1752
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1752
    if (! (i___0 < n)) {
#line 1752
      goto while_break___0;
    }
    {
#line 1753
    addtok(dfa, dfa->utf8_anychar_classes[i___0]);
#line 1752
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1754
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1754
    i___0 --;
#line 1754
    if (! (i___0 > 1U)) {
#line 1754
      goto while_break___1;
    }
    {
#line 1756
    addtok(dfa, dfa->utf8_anychar_classes[0]);
#line 1757
    addtok(dfa, (token )268);
#line 1758
    addtok(dfa, (token )269);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1760
  return;
}
}
#line 1797 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void atom(struct dfa *dfa ) 
{ 
  wchar_t folded[32] ;
  unsigned int n ;
  int tmp ;
  unsigned int i ;
  char *tmp___0 ;

  {
#line 1800
  if (dfa->parse.tok == 274L) {
#line 1802
    if (dfa->lex.wctok == 4294967295U) {
      {
#line 1803
      addtok(dfa, (token )257);
      }
    } else {
      {
#line 1806
      addtok_wc(dfa, dfa->lex.wctok);
      }
#line 1808
      if (dfa->syntax.case_fold) {
        {
#line 1811
        tmp = case_folded_counterparts(dfa->lex.wctok, (wchar_t *)(folded));
#line 1811
        n = (unsigned int )tmp;
#line 1813
        i = 0U;
        }
        {
#line 1813
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1813
          if (! (i < n)) {
#line 1813
            goto while_break;
          }
          {
#line 1815
          addtok_wc(dfa, (wint_t )folded[i]);
#line 1816
          addtok(dfa, (token )269);
#line 1813
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 1821
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1823
  if (dfa->parse.tok == 272L) {
#line 1823
    if (dfa->localeinfo.using_utf8) {
      {
#line 1832
      add_utf8_anychar(dfa);
#line 1833
      dfa->parse.tok = lex(dfa);
      }
    } else {
#line 1823
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1835
  if (0L <= dfa->parse.tok) {
#line 1835
    if (dfa->parse.tok < 256L) {
      {
#line 1842
      addtok(dfa, dfa->parse.tok);
#line 1843
      dfa->parse.tok = lex(dfa);
      }
    } else {
#line 1835
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1835
  if (dfa->parse.tok >= 275L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 257L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 258L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 259L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 260L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 272L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 273L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 261L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 262L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 263L) {
    {
#line 1842
    addtok(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1845
  if (dfa->parse.tok == 270L) {
    {
#line 1847
    dfa->parse.tok = lex(dfa);
#line 1848
    regexp(dfa);
    }
#line 1849
    if (dfa->parse.tok != 271L) {
      {
#line 1850
      tmp___0 = gettext("unbalanced (");
#line 1850
      dfaerror((char const   *)tmp___0);
      }
    }
    {
#line 1851
    dfa->parse.tok = lex(dfa);
    }
  } else {
    {
#line 1854
    addtok(dfa, (token )256);
    }
  }
#line 1855
  return;
}
}
#line 1858 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static size_t __attribute__((__pure__))  nsubtoks(struct dfa  const  *dfa , size_t tindex ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t ntoks1 ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 1867
  if (*(dfa->tokens + (tindex - 1UL)) == 266L) {
#line 1867
    goto case_266;
  }
#line 1867
  if (*(dfa->tokens + (tindex - 1UL)) == 265L) {
#line 1867
    goto case_266;
  }
#line 1867
  if (*(dfa->tokens + (tindex - 1UL)) == 264L) {
#line 1867
    goto case_266;
  }
#line 1870
  if (*(dfa->tokens + (tindex - 1UL)) == 269L) {
#line 1870
    goto case_269;
  }
#line 1870
  if (*(dfa->tokens + (tindex - 1UL)) == 268L) {
#line 1870
    goto case_269;
  }
#line 1863
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1864
  return ((size_t __attribute__((__pure__))  )1);
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
  {
#line 1868
  tmp = nsubtoks(dfa, tindex - 1UL);
  }
#line 1868
  return ((size_t __attribute__((__pure__))  )1 + tmp);
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
  {
#line 1872
  tmp___0 = nsubtoks(dfa, tindex - 1UL);
#line 1872
  ntoks1 = (size_t )tmp___0;
#line 1873
  tmp___1 = nsubtoks(dfa, (tindex - 1UL) - ntoks1);
  }
#line 1873
  return ((size_t __attribute__((__pure__))  )((1UL + ntoks1) + (size_t )tmp___1));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1879 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void copytoks(struct dfa *dfa , size_t tindex , size_t ntokens ) 
{ 
  size_t i ;
  size_t i___0 ;

  {
#line 1882
  if (dfa->localeinfo.multibyte) {
#line 1883
    i = (size_t )0;
    {
#line 1883
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1883
      if (! (i < ntokens)) {
#line 1883
        goto while_break;
      }
      {
#line 1884
      addtok_mb(dfa, *(dfa->tokens + (tindex + i)), *(dfa->multibyte_prop + (tindex + i)));
#line 1883
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1887
    i___0 = (size_t )0;
    {
#line 1887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1887
      if (! (i___0 < ntokens)) {
#line 1887
        goto while_break___0;
      }
      {
#line 1888
      addtok_mb(dfa, *(dfa->tokens + (tindex + i___0)), (char)3);
#line 1887
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1889
  return;
}
}
#line 1891 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void closure(struct dfa *dfa ) 
{ 
  size_t ntokens ;
  size_t __attribute__((__pure__))  tmp ;
  size_t tindex ;
  int i ;
  size_t __attribute__((__pure__))  tmp___0 ;

  {
  {
#line 1894
  atom(dfa);
  }
  {
#line 1895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1895
    if (! (dfa->parse.tok == 264L)) {
#line 1895
      if (! (dfa->parse.tok == 265L)) {
#line 1895
        if (! (dfa->parse.tok == 266L)) {
#line 1895
          if (! (dfa->parse.tok == 267L)) {
#line 1895
            goto while_break;
          }
        }
      }
    }
#line 1897
    if (dfa->parse.tok == 267L) {
#line 1897
      if (dfa->lex.minrep) {
#line 1897
        goto _L___0;
      } else
#line 1897
      if (dfa->lex.maxrep) {
        _L___0: /* CIL Label */ 
        {
#line 1899
        tmp = nsubtoks((struct dfa  const  *)dfa, dfa->tindex);
#line 1899
        ntokens = (size_t )tmp;
#line 1900
        tindex = dfa->tindex - ntokens;
        }
#line 1901
        if (dfa->lex.maxrep < 0) {
          {
#line 1902
          addtok(dfa, (token )266);
          }
        }
#line 1903
        if (dfa->lex.minrep == 0) {
          {
#line 1904
          addtok(dfa, (token )264);
          }
        }
#line 1906
        i = 1;
        {
#line 1906
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1906
          if (! (i < dfa->lex.minrep)) {
#line 1906
            goto while_break___0;
          }
          {
#line 1908
          copytoks(dfa, tindex, ntokens);
#line 1909
          addtok(dfa, (token )268);
#line 1906
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1911
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1911
          if (! (i < dfa->lex.maxrep)) {
#line 1911
            goto while_break___1;
          }
          {
#line 1913
          copytoks(dfa, tindex, ntokens);
#line 1914
          addtok(dfa, (token )264);
#line 1915
          addtok(dfa, (token )268);
#line 1911
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1917
        dfa->parse.tok = lex(dfa);
        }
      } else {
#line 1897
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1919
    if (dfa->parse.tok == 267L) {
      {
#line 1921
      tmp___0 = nsubtoks((struct dfa  const  *)dfa, dfa->tindex);
#line 1921
      dfa->tindex -= (size_t )tmp___0;
#line 1922
      dfa->parse.tok = lex(dfa);
#line 1923
      closure(dfa);
      }
    } else {
      {
#line 1927
      addtok(dfa, dfa->parse.tok);
#line 1928
      dfa->parse.tok = lex(dfa);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1930
  return;
}
}
#line 1932 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void branch(struct dfa *dfa ) 
{ 


  {
  {
#line 1935
  closure(dfa);
  }
  {
#line 1936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1936
    if (dfa->parse.tok != 271L) {
#line 1936
      if (dfa->parse.tok != 269L) {
#line 1936
        if (! (dfa->parse.tok >= 0L)) {
#line 1936
          goto while_break;
        }
      } else {
#line 1936
        goto while_break;
      }
    } else {
#line 1936
      goto while_break;
    }
    {
#line 1939
    closure(dfa);
#line 1940
    addtok(dfa, (token )268);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1942
  return;
}
}
#line 1944 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void regexp(struct dfa *dfa ) 
{ 


  {
  {
#line 1947
  branch(dfa);
  }
  {
#line 1948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1948
    if (! (dfa->parse.tok == 269L)) {
#line 1948
      goto while_break;
    }
    {
#line 1950
    dfa->parse.tok = lex(dfa);
#line 1951
    branch(dfa);
#line 1952
    addtok(dfa, (token )269);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1954
  return;
}
}
#line 1959 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void dfaparse(char const   *s , size_t len , struct dfa *d ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 1962
  d->lex.ptr = s;
#line 1963
  d->lex.left = len;
#line 1964
  d->lex.lasttok = (token )-1;
#line 1965
  d->lex.laststart = (_Bool)1;
#line 1967
  if (! d->syntax.syntax_bits_set) {
    {
#line 1968
    tmp = gettext("no syntax specified");
#line 1968
    dfaerror((char const   *)tmp);
    }
  }
  {
#line 1970
  d->parse.tok = lex(d);
#line 1971
  d->parse.depth = d->depth;
#line 1973
  regexp(d);
  }
#line 1975
  if (d->parse.tok != -1L) {
    {
#line 1976
    tmp___0 = gettext("unbalanced )");
#line 1976
    dfaerror((char const   *)tmp___0);
    }
  }
  {
#line 1978
  addtok(d, (token )(0xffffffffffffffffUL - d->nregexps));
#line 1979
  addtok(d, (token )268);
  }
#line 1981
  if (d->nregexps) {
    {
#line 1982
    addtok(d, (token )269);
    }
  }
#line 1984
  (d->nregexps) ++;
#line 1985
  return;
}
}
#line 1990 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void copy(position_set const   *src , position_set *dst ) 
{ 
  void *tmp ;

  {
#line 1993
  if (dst->alloc < (ptrdiff_t )src->nelem) {
    {
#line 1995
    free((void *)dst->elems);
#line 1996
    tmp = xpalloc((void *)0, & dst->alloc, (ptrdiff_t )(src->nelem - (ptrdiff_t const   )dst->alloc),
                  (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(dst->elems)));
#line 1996
    dst->elems = (position *)tmp;
    }
  }
#line 1999
  dst->nelem = (ptrdiff_t )src->nelem;
#line 2000
  if (src->nelem != 0L) {
    {
#line 2001
    memcpy((void */* __restrict  */)dst->elems, (void const   */* __restrict  */)src->elems,
           (unsigned long )src->nelem * sizeof(*(dst->elems)));
    }
  }
#line 2002
  return;
}
}
#line 2004 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void alloc_position_set(position_set *s , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2007
  tmp = xnmalloc(size, sizeof(*(s->elems)));
#line 2007
  s->elems = (position *)tmp;
#line 2008
  s->alloc = (ptrdiff_t )size;
#line 2009
  s->nelem = (ptrdiff_t )0;
  }
#line 2010
  return;
}
}
#line 2016 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void insert(position p , position_set *s ) 
{ 
  ptrdiff_t count ;
  ptrdiff_t lo ;
  ptrdiff_t hi ;
  ptrdiff_t mid ;
  void *tmp ;
  ptrdiff_t i ;

  {
#line 2019
  count = s->nelem;
#line 2020
  lo = (ptrdiff_t )0;
#line 2020
  hi = count;
  {
#line 2021
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2021
    if (! (lo < hi)) {
#line 2021
      goto while_break;
    }
#line 2023
    mid = (lo + hi) >> 1;
#line 2024
    if ((s->elems + mid)->index > p.index) {
#line 2025
      lo = mid + 1L;
    } else
#line 2026
    if ((s->elems + mid)->index == p.index) {
#line 2028
      (s->elems + mid)->constraint |= p.constraint;
#line 2029
      return;
    } else {
#line 2032
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2035
  tmp = maybe_realloc((void *)s->elems, count, & s->alloc, (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(s->elems)));
#line 2035
  s->elems = (position *)tmp;
#line 2036
  i = count;
  }
  {
#line 2036
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2036
    if (! (i > lo)) {
#line 2036
      goto while_break___0;
    }
#line 2037
    *(s->elems + i) = *(s->elems + (i - 1L));
#line 2036
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2038
  *(s->elems + lo) = p;
#line 2039
  (s->nelem) ++;
#line 2040
  return;
}
}
#line 2045 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void merge_constrained(position_set const   *s1 , position_set const   *s2 ,
                              unsigned int c2 , position_set *m ) 
{ 
  ptrdiff_t i ;
  ptrdiff_t j ;
  void *tmp ;
  unsigned int c ;
  ptrdiff_t tmp___0 ;
  unsigned int tmp___1 ;
  ptrdiff_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  ptrdiff_t tmp___4 ;

  {
#line 2049
  i = (ptrdiff_t )0;
#line 2049
  j = (ptrdiff_t )0;
#line 2051
  if (m->alloc - (ptrdiff_t )s1->nelem < (ptrdiff_t )s2->nelem) {
    {
#line 2053
    free((void *)m->elems);
#line 2054
    m->alloc = (ptrdiff_t )s1->nelem;
#line 2055
    tmp = xpalloc((void *)0, & m->alloc, (ptrdiff_t )s2->nelem, (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(m->elems)));
#line 2055
    m->elems = (position *)tmp;
    }
  }
#line 2057
  m->nelem = (ptrdiff_t )0;
  {
#line 2058
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2058
    if (! (i < (ptrdiff_t )s1->nelem)) {
#line 2058
      if (! (j < (ptrdiff_t )s2->nelem)) {
#line 2058
        goto while_break;
      }
    }
#line 2059
    if (! (j < (ptrdiff_t )s2->nelem)) {
#line 2059
      goto _L;
    } else
#line 2059
    if (i < (ptrdiff_t )s1->nelem) {
#line 2059
      if ((s1->elems + i)->index >= (s2->elems + j)->index) {
        _L: /* CIL Label */ 
#line 2062
        if (i < (ptrdiff_t )s1->nelem) {
#line 2062
          if (j < (ptrdiff_t )s2->nelem) {
#line 2062
            if ((s1->elems + i)->index == (s2->elems + j)->index) {
#line 2062
              tmp___0 = j;
#line 2062
              j ++;
#line 2062
              tmp___1 = (s2->elems + tmp___0)->constraint & c2;
            } else {
#line 2062
              tmp___1 = 0U;
            }
          } else {
#line 2062
            tmp___1 = 0U;
          }
        } else {
#line 2062
          tmp___1 = 0U;
        }
#line 2062
        c = tmp___1;
#line 2066
        (m->elems + m->nelem)->index = (s1->elems + i)->index;
#line 2067
        tmp___2 = m->nelem;
#line 2067
        (m->nelem) ++;
#line 2067
        tmp___3 = i;
#line 2067
        i ++;
#line 2067
        (m->elems + tmp___2)->constraint = (s1->elems + tmp___3)->constraint | c;
      } else {
#line 2059
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2071
      if ((s2->elems + j)->constraint & c2) {
#line 2073
        (m->elems + m->nelem)->index = (s2->elems + j)->index;
#line 2074
        tmp___4 = m->nelem;
#line 2074
        (m->nelem) ++;
#line 2074
        (m->elems + tmp___4)->constraint = (s2->elems + j)->constraint & c2;
      }
#line 2076
      j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2078
  return;
}
}
#line 2082 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void merge(position_set const   *s1 , position_set const   *s2 , position_set *m ) 
{ 


  {
  {
#line 2085
  merge_constrained(s1, s2, 4294967295U, m);
  }
#line 2086
  return;
}
}
#line 2090 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static unsigned int delete(size_t del , position_set *s ) 
{ 
  size_t count ;
  size_t lo ;
  size_t hi ;
  size_t mid ;
  unsigned int c ;
  size_t i ;

  {
#line 2093
  count = (size_t )s->nelem;
#line 2094
  lo = (size_t )0;
#line 2094
  hi = count;
  {
#line 2095
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2095
    if (! (lo < hi)) {
#line 2095
      goto while_break;
    }
#line 2097
    mid = (lo + hi) >> 1;
#line 2098
    if ((s->elems + mid)->index > del) {
#line 2099
      lo = mid + 1UL;
    } else
#line 2100
    if ((s->elems + mid)->index == del) {
#line 2102
      c = (s->elems + mid)->constraint;
#line 2104
      i = mid;
      {
#line 2104
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2104
        if (! (i + 1UL < count)) {
#line 2104
          goto while_break___0;
        }
#line 2105
        *(s->elems + i) = *(s->elems + (i + 1UL));
#line 2104
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2106
      s->nelem = (ptrdiff_t )i;
#line 2107
      return (c);
    } else {
#line 2110
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2112
  return (0U);
}
}
#line 2116 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void replace(position_set *dst , size_t del , position_set *add , unsigned int constraint ,
                    position_set *tmp ) 
{ 
  unsigned int c ;
  unsigned int tmp___0 ;

  {
  {
#line 2120
  tmp___0 = delete(del, dst);
#line 2120
  c = tmp___0 & constraint;
  }
#line 2122
  if (c) {
    {
#line 2124
    copy((position_set const   *)dst, tmp);
#line 2125
    merge_constrained((position_set const   *)tmp, (position_set const   *)add, c,
                      dst);
    }
  }
#line 2127
  return;
}
}
#line 2132 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static state_num state_index(struct dfa *d , position_set const   *s , int context ) 
{ 
  size_t hash ;
  int constraint ;
  state_num i ;
  token first_end ;
  state_num j ;
  state_num j___0 ;
  int c ;
  _Bool tmp ;
  void *tmp___0 ;

  {
#line 2135
  hash = (size_t )0;
#line 2136
  constraint = 0;
#line 2138
  first_end = (token )0;
#line 2140
  i = (state_num )0;
  {
#line 2140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2140
    if (! (i < (state_num )s->nelem)) {
#line 2140
      goto while_break;
    }
#line 2141
    hash ^= (s->elems + i)->index + (size_t )(s->elems + i)->constraint;
#line 2140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2144
  i = (state_num )0;
  {
#line 2144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2144
    if (! (i < d->sindex)) {
#line 2144
      goto while_break___0;
    }
#line 2146
    if (hash != (d->states + i)->hash) {
#line 2148
      goto __Cont;
    } else
#line 2146
    if (s->nelem != (ptrdiff_t const   )(d->states + i)->elems.nelem) {
#line 2148
      goto __Cont;
    } else
#line 2146
    if (context != (int )(d->states + i)->context) {
#line 2148
      goto __Cont;
    }
#line 2150
    j = (state_num )0;
    {
#line 2150
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2150
      if (! (j < (state_num )s->nelem)) {
#line 2150
        goto while_break___1;
      }
#line 2151
      if ((s->elems + j)->constraint != ((d->states + i)->elems.elems + j)->constraint) {
#line 2153
        goto while_break___1;
      } else
#line 2151
      if ((s->elems + j)->index != ((d->states + i)->elems.elems + j)->index) {
#line 2153
        goto while_break___1;
      }
#line 2150
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2154
    if (j == (state_num )s->nelem) {
#line 2155
      return (i);
    }
    __Cont: /* CIL Label */ 
#line 2144
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2180
  j___0 = (state_num )0;
  {
#line 2180
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2180
    if (! (j___0 < (state_num )s->nelem)) {
#line 2180
      goto while_break___2;
    }
#line 2182
    c = (int )(s->elems + j___0)->constraint;
#line 2183
    if (*(d->tokens + (s->elems + j___0)->index) < 0L) {
      {
#line 2185
      tmp = succeeds_in_context(c, context, 7);
      }
#line 2185
      if (tmp) {
#line 2186
        constraint |= c;
      }
#line 2187
      if (! first_end) {
#line 2188
        first_end = *(d->tokens + (s->elems + j___0)->index);
      }
    } else
#line 2190
    if (*(d->tokens + (s->elems + j___0)->index) == 257L) {
#line 2191
      constraint = 511;
    }
#line 2180
    j___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2196
  tmp___0 = maybe_realloc((void *)d->states, d->sindex, & d->salloc, (ptrdiff_t )-1,
                          (ptrdiff_t )sizeof(*(d->states)));
#line 2196
  d->states = (dfa_state *)tmp___0;
#line 2198
  (d->states + i)->hash = hash;
#line 2199
  alloc_position_set(& (d->states + i)->elems, (size_t )s->nelem);
#line 2200
  copy(s, & (d->states + i)->elems);
#line 2201
  (d->states + i)->context = (unsigned char )context;
#line 2202
  (d->states + i)->constraint = (unsigned short )constraint;
#line 2203
  (d->states + i)->first_end = first_end;
#line 2204
  (d->states + i)->mbps.nelem = (ptrdiff_t )0;
#line 2205
  (d->states + i)->mbps.elems = (position *)((void *)0);
#line 2206
  (d->states + i)->mb_trindex = (state_num )-1;
#line 2208
  (d->sindex) ++;
  }
#line 2210
  return (i);
}
}
#line 2218 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void epsclosure(position_set *initial , struct dfa  const  *d ) 
{ 
  position_set tmp ;
  size_t i ;
  unsigned int constraint ;
  size_t j ;

  {
  {
#line 2222
  alloc_position_set(& tmp, (size_t )d->nleaves);
#line 2223
  i = (size_t )0;
  }
  {
#line 2223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2223
    if (! (i < (size_t )d->tindex)) {
#line 2223
      goto while_break;
    }
#line 2224
    if ((d->follows + i)->nelem > 0L) {
#line 2224
      if (*(d->tokens + i) >= 256L) {
#line 2224
        if (*(d->tokens + i) != 257L) {
#line 2224
          if (*(d->tokens + i) != 272L) {
#line 2224
            if (*(d->tokens + i) != 273L) {
#line 2224
              if (*(d->tokens + i) < 275L) {
                {
#line 2231
                if (*(d->tokens + i) == 258L) {
#line 2231
                  goto case_258;
                }
#line 2234
                if (*(d->tokens + i) == 259L) {
#line 2234
                  goto case_259;
                }
#line 2237
                if (*(d->tokens + i) == 260L) {
#line 2237
                  goto case_260;
                }
#line 2240
                if (*(d->tokens + i) == 261L) {
#line 2240
                  goto case_261;
                }
#line 2243
                if (*(d->tokens + i) == 262L) {
#line 2243
                  goto case_262;
                }
#line 2246
                if (*(d->tokens + i) == 263L) {
#line 2246
                  goto case_263;
                }
#line 2249
                goto switch_default;
                case_258: /* CIL Label */ 
#line 2232
                constraint = 292U;
#line 2233
                goto switch_break;
                case_259: /* CIL Label */ 
#line 2235
                constraint = 448U;
#line 2236
                goto switch_break;
                case_260: /* CIL Label */ 
#line 2238
                constraint = 40U;
#line 2239
                goto switch_break;
                case_261: /* CIL Label */ 
#line 2241
                constraint = 130U;
#line 2242
                goto switch_break;
                case_262: /* CIL Label */ 
#line 2244
                constraint = 170U;
#line 2245
                goto switch_break;
                case_263: /* CIL Label */ 
#line 2247
                constraint = 341U;
#line 2248
                goto switch_break;
                switch_default: /* CIL Label */ 
#line 2250
                constraint = 511U;
#line 2251
                goto switch_break;
                switch_break: /* CIL Label */ ;
                }
                {
#line 2254
                delete(i, d->follows + i);
#line 2256
                j = (size_t )0;
                }
                {
#line 2256
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 2256
                  if (! (j < (size_t )d->tindex)) {
#line 2256
                    goto while_break___0;
                  }
#line 2257
                  if (i != j) {
#line 2257
                    if ((d->follows + j)->nelem > 0L) {
                      {
#line 2258
                      replace(d->follows + j, i, d->follows + i, constraint, & tmp);
                      }
                    }
                  }
#line 2256
                  j ++;
                }
                while_break___0: /* CIL Label */ ;
                }
                {
#line 2260
                replace(initial, i, d->follows + i, constraint, & tmp);
                }
              }
            }
          }
        }
      }
    }
#line 2223
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2262
  free((void *)tmp.elems);
  }
#line 2263
  return;
}
}
#line 2268 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int charclass_context(struct dfa  const  *dfa , charclass const   *c ) 
{ 
  int context ;
  unsigned int j ;

  {
#line 2271
  context = 0;
#line 2273
  j = 0U;
  {
#line 2273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2273
    if (! (j < 4U)) {
#line 2273
      goto while_break;
    }
#line 2275
    if (c->w[j] & dfa->syntax.newline.w[j]) {
#line 2276
      context |= 4;
    }
#line 2277
    if (c->w[j] & dfa->syntax.letters.w[j]) {
#line 2278
      context |= 2;
    }
#line 2279
    if (c->w[j] & ~ (dfa->syntax.letters.w[j] | dfa->syntax.newline.w[j])) {
#line 2280
      context |= 1;
    }
#line 2273
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2283
  return (context);
}
}
#line 2292 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int __attribute__((__pure__))  state_separate_contexts(position_set const   *s ) 
{ 
  int separate_contexts ;
  size_t j ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 2295
  separate_contexts = 0;
#line 2297
  j = (size_t )0;
  {
#line 2297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2297
    if (! (j < (size_t )s->nelem)) {
#line 2297
      goto while_break;
    }
    {
#line 2299
    tmp = prev_newline_dependent((int )(s->elems + j)->constraint);
    }
#line 2299
    if (tmp) {
#line 2300
      separate_contexts |= 4;
    }
    {
#line 2301
    tmp___0 = prev_letter_dependent((int )(s->elems + j)->constraint);
    }
#line 2301
    if (tmp___0) {
#line 2302
      separate_contexts |= 2;
    }
#line 2297
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2305
  return ((int __attribute__((__pure__))  )separate_contexts);
}
}
#line 2361 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void dfaanalyze(struct dfa *d , _Bool searchflag ) 
{ 
  position *posalloc ;
  void *tmp ;
  position *firstpos ;
  position *lastpos ;
  struct __anonstruct_stkalloc_360611398 *stkalloc ;
  void *tmp___0 ;
  struct __anonstruct_stkalloc_360611398 *stk ;
  position_set merged ;
  void *tmp___1 ;
  size_t i ;
  size_t tmp___2 ;
  position_set tmp___3 ;
  position *pos ;
  size_t j ;
  position_set tmp___4 ;
  position *pos___0 ;
  size_t j___0 ;
  position *pos___1 ;
  size_t j___1 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  unsigned int tmp___8 ;
  size_t i___0 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___9 ;
  int tmp___10 ;
  state_num tmp___11 ;
  state_num tmp___12 ;

  {
  {
#line 2365
  tmp = xnmalloc(d->nleaves, 2UL * sizeof(*posalloc));
#line 2365
  posalloc = (position *)tmp;
#line 2367
  firstpos = posalloc + d->nleaves;
#line 2368
  lastpos = firstpos + d->nleaves;
#line 2371
  tmp___0 = xnmalloc(d->depth, sizeof(*stkalloc));
#line 2371
  stkalloc = (struct __anonstruct_stkalloc_360611398 *)tmp___0;
#line 2371
  stk = stkalloc;
#line 2393
  d->searchflag = searchflag;
#line 2394
  alloc_position_set(& merged, d->nleaves);
#line 2395
  tmp___1 = xcalloc(d->tindex, sizeof(*(d->follows)));
#line 2395
  d->follows = (position_set *)tmp___1;
#line 2397
  i = (size_t )0;
  }
  {
#line 2397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2397
    if (! (i < d->tindex)) {
#line 2397
      goto while_break;
    }
    {
#line 2401
    if (*(d->tokens + i) == 256L) {
#line 2401
      goto case_256;
    }
#line 2411
    if (*(d->tokens + i) == 266L) {
#line 2411
      goto case_266;
    }
#line 2411
    if (*(d->tokens + i) == 265L) {
#line 2411
      goto case_266;
    }
#line 2426
    if (*(d->tokens + i) == 264L) {
#line 2426
      goto case_264;
    }
#line 2432
    if (*(d->tokens + i) == 268L) {
#line 2432
      goto case_268;
    }
#line 2472
    if (*(d->tokens + i) == 269L) {
#line 2472
      goto case_269;
    }
#line 2484
    goto switch_default;
    case_256: /* CIL Label */ 
#line 2403
    stk->nullable = (_Bool)1;
#line 2406
    tmp___2 = (size_t )0;
#line 2406
    stk->nlastpos = tmp___2;
#line 2406
    stk->nfirstpos = tmp___2;
#line 2407
    stk ++;
#line 2408
    goto switch_break;
    case_266: /* CIL Label */ 
    case_265: /* CIL Label */ 
#line 2416
    tmp___3.nelem = (ptrdiff_t )(stk + -1)->nfirstpos;
#line 2417
    tmp___3.elems = firstpos;
#line 2418
    pos = lastpos;
#line 2419
    j = (size_t )0;
    {
#line 2419
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2419
      if (! (j < (stk + -1)->nlastpos)) {
#line 2419
        goto while_break___0;
      }
      {
#line 2421
      merge((position_set const   *)(& tmp___3), (position_set const   *)(d->follows + (pos + j)->index),
            & merged);
#line 2422
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2419
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_264: /* CIL Label */ 
#line 2428
    if (*(d->tokens + i) != 266L) {
#line 2429
      (stk + -1)->nullable = (_Bool)1;
    }
#line 2430
    goto switch_break;
    case_268: /* CIL Label */ 
#line 2437
    tmp___4.nelem = (ptrdiff_t )(stk + -1)->nfirstpos;
#line 2438
    tmp___4.elems = firstpos;
#line 2439
    pos___0 = lastpos + (stk + -1)->nlastpos;
#line 2440
    j___0 = (size_t )0;
    {
#line 2440
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2440
      if (! (j___0 < (stk + -2)->nlastpos)) {
#line 2440
        goto while_break___1;
      }
      {
#line 2442
      merge((position_set const   *)(& tmp___4), (position_set const   *)(d->follows + (pos___0 + j___0)->index),
            & merged);
#line 2443
      copy((position_set const   *)(& merged), d->follows + (pos___0 + j___0)->index);
#line 2440
      j___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2449
    if ((stk + -2)->nullable) {
#line 2450
      (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
    } else {
#line 2452
      firstpos += (stk + -1)->nfirstpos;
    }
#line 2456
    if ((stk + -1)->nullable) {
#line 2457
      (stk + -2)->nlastpos += (stk + -1)->nlastpos;
    } else {
#line 2460
      pos___1 = lastpos + (stk + -2)->nlastpos;
#line 2461
      j___1 = (stk + -1)->nlastpos;
      {
#line 2461
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2461
        tmp___5 = j___1;
#line 2461
        j___1 --;
#line 2461
        if (! (tmp___5 > 0UL)) {
#line 2461
          goto while_break___2;
        }
#line 2462
        *(pos___1 + j___1) = *(lastpos + j___1);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2463
      lastpos += (stk + -2)->nlastpos;
#line 2464
      (stk + -2)->nlastpos = (stk + -1)->nlastpos;
    }
#line 2468
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable & (int )(stk + -1)->nullable);
#line 2469
    stk --;
#line 2470
    goto switch_break;
    case_269: /* CIL Label */ 
#line 2474
    (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
#line 2477
    (stk + -2)->nlastpos += (stk + -1)->nlastpos;
#line 2480
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable | (int )(stk + -1)->nullable);
#line 2481
    stk --;
#line 2482
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2490
    stk->nullable = (_Bool )(*(d->tokens + i) == 257L);
#line 2493
    tmp___6 = (size_t )1;
#line 2493
    stk->nlastpos = tmp___6;
#line 2493
    stk->nfirstpos = tmp___6;
#line 2494
    stk ++;
#line 2496
    firstpos --;
#line 2496
    lastpos --;
#line 2497
    tmp___7 = i;
#line 2497
    lastpos->index = tmp___7;
#line 2497
    firstpos->index = tmp___7;
#line 2498
    tmp___8 = 511U;
#line 2498
    lastpos->constraint = tmp___8;
#line 2498
    firstpos->constraint = tmp___8;
#line 2500
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2397
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2545
  merged.nelem = (ptrdiff_t )0;
#line 2546
  i___0 = (size_t )0;
  {
#line 2546
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2546
    if (! (i___0 < (stk + -1)->nfirstpos)) {
#line 2546
      goto while_break___3;
    }
    {
#line 2547
    insert(*(firstpos + i___0), & merged);
#line 2546
    i___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2551
  epsclosure(& merged, (struct dfa  const  *)d);
#line 2554
  tmp___9 = state_separate_contexts((position_set const   *)(& merged));
#line 2554
  separate_contexts = (int )tmp___9;
  }
#line 2557
  if (separate_contexts & 4) {
    {
#line 2558
    state_index(d, (position_set const   *)(& merged), 4);
    }
  }
  {
#line 2559
  tmp___11 = state_index(d, (position_set const   *)(& merged), separate_contexts ^ 7);
#line 2559
  tmp___10 = (int )tmp___11;
#line 2559
  d->min_trcount = tmp___10;
#line 2559
  d->initstate_notbol = (state_num )tmp___10;
  }
#line 2561
  if (separate_contexts & 2) {
    {
#line 2562
    tmp___12 = state_index(d, (position_set const   *)(& merged), 2);
#line 2562
    d->min_trcount = (int )tmp___12;
    }
  }
  {
#line 2563
  (d->min_trcount) ++;
#line 2564
  d->trcount = 0;
#line 2566
  free((void *)posalloc);
#line 2567
  free((void *)stkalloc);
#line 2568
  free((void *)merged.elems);
  }
#line 2569
  return;
}
}
#line 2572 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void realloc_trans_if_necessary(struct dfa *d ) 
{ 
  state_num oldalloc ;
  state_num **realtrans ;
  state_num **tmp ;
  ptrdiff_t newalloc1 ;
  state_num tmp___0 ;
  void *tmp___1 ;
  state_num *tmp___2 ;
  ptrdiff_t newalloc ;
  state_num tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  state_num *tmp___8 ;

  {
#line 2575
  oldalloc = d->tralloc;
#line 2576
  if (oldalloc < d->sindex) {
#line 2578
    if (d->trans) {
#line 2578
      tmp = d->trans - 2;
    } else {
#line 2578
      tmp = (state_num **)((void *)0);
    }
#line 2578
    realtrans = tmp;
#line 2579
    if (realtrans) {
#line 2579
      tmp___0 = d->tralloc + 2L;
    } else {
#line 2579
      tmp___0 = (state_num )0;
    }
    {
#line 2579
    newalloc1 = tmp___0;
#line 2580
    tmp___1 = xpalloc((void *)realtrans, & newalloc1, d->sindex - oldalloc, (ptrdiff_t )-1,
                      (ptrdiff_t )sizeof(*realtrans));
#line 2580
    realtrans = (state_num **)tmp___1;
#line 2582
    tmp___2 = (state_num *)((void *)0);
#line 2582
    *(realtrans + 1) = tmp___2;
#line 2582
    *(realtrans + 0) = tmp___2;
#line 2583
    d->trans = realtrans + 2;
#line 2584
    tmp___3 = newalloc1 - 2L;
#line 2584
    d->tralloc = tmp___3;
#line 2584
    newalloc = tmp___3;
#line 2585
    tmp___4 = xnrealloc((void *)d->fails, (size_t )newalloc, sizeof(*(d->fails)));
#line 2585
    d->fails = (state_num **)tmp___4;
#line 2586
    tmp___5 = xnrealloc((void *)d->success, (size_t )newalloc, sizeof(*(d->success)));
#line 2586
    d->success = (char *)tmp___5;
#line 2587
    tmp___6 = xnrealloc((void *)d->newlines, (size_t )newalloc, sizeof(*(d->newlines)));
#line 2587
    d->newlines = (state_num *)tmp___6;
    }
#line 2588
    if (d->localeinfo.multibyte) {
#line 2590
      if (d->mb_trans) {
#line 2590
        realtrans = d->mb_trans - 2;
      } else {
#line 2590
        realtrans = (state_num **)((void *)0);
      }
      {
#line 2591
      tmp___7 = xnrealloc((void *)realtrans, (size_t )newalloc1, sizeof(*realtrans));
#line 2591
      realtrans = (state_num **)tmp___7;
      }
#line 2592
      if (oldalloc == 0L) {
#line 2593
        tmp___8 = (state_num *)((void *)0);
#line 2593
        *(realtrans + 1) = tmp___8;
#line 2593
        *(realtrans + 0) = tmp___8;
      }
#line 2594
      d->mb_trans = realtrans + 2;
    }
    {
#line 2596
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2596
      if (! (oldalloc < newalloc)) {
#line 2596
        goto while_break;
      }
#line 2598
      *(d->trans + oldalloc) = (state_num *)((void *)0);
#line 2599
      *(d->fails + oldalloc) = (state_num *)((void *)0);
#line 2600
      if (d->localeinfo.multibyte) {
#line 2601
        *(d->mb_trans + oldalloc) = (state_num *)((void *)0);
      }
#line 2596
      oldalloc ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2604
  return;
}
}
#line 2639 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static state_num build_state(state_num s , struct dfa *d , unsigned char uc ) 
{ 
  position_set follows ;
  position_set tmp ;
  state_num state ;
  state_num state_newline ;
  state_num state_letter ;
  state_num **ptrans ;
  state_num **tmp___1 ;
  _Bool tmp___2 ;
  state_num *trans ;
  state_num i ;
  state_num *tmp___3 ;
  void *tmp___4 ;
  int i___0 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  leaf_set group ;
  void *tmp___8 ;
  charclass label___0 ;
  size_t i___1 ;
  charclass matches ;
  position pos ;
  _Bool matched ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  size_t j ;
  _Bool tmp___11 ;
  size_t j___0 ;
  _Bool tmp___12 ;
  size_t j___1 ;
  _Bool tmp___13 ;
  size_t j___2 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  size_t k ;
  size_t tmp___17 ;
  size_t k___0 ;
  size_t j___3 ;
  size_t k___1 ;
  _Bool mergeit ;
  size_t j___4 ;
  int possible_contexts ;
  int tmp___18 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___19 ;
  size_t i___2 ;
  _Bool tmp___20 ;
  _Bool tmp___21 ;

  {
  {
#line 2653
  tmp___2 = accepting(s, (struct dfa  const  *)d);
  }
#line 2653
  if (tmp___2) {
#line 2653
    tmp___1 = d->fails;
  } else {
#line 2653
    tmp___1 = d->trans;
  }
#line 2653
  ptrans = tmp___1 + s;
#line 2654
  trans = *ptrans;
#line 2656
  if (! trans) {
#line 2662
    if (1024 <= d->trcount) {
#line 2664
      i = (state_num )d->min_trcount;
      {
#line 2664
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2664
        if (! (i < d->tralloc)) {
#line 2664
          goto while_break;
        }
        {
#line 2666
        free((void *)*(d->trans + i));
#line 2667
        free((void *)*(d->fails + i));
#line 2668
        tmp___3 = (state_num *)((void *)0);
#line 2668
        *(d->fails + i) = tmp___3;
#line 2668
        *(d->trans + i) = tmp___3;
#line 2664
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 2670
      d->trcount = 0;
    }
    {
#line 2673
    (d->trcount) ++;
#line 2674
    tmp___4 = xmalloc(256UL * sizeof(*trans));
#line 2674
    trans = (state_num *)tmp___4;
#line 2674
    *ptrans = trans;
#line 2678
    i___0 = 0;
    }
    {
#line 2678
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2678
      if (! (i___0 < 256)) {
#line 2678
        goto while_break___0;
      }
#line 2679
      *(trans + i___0) = (state_num )-2;
#line 2678
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2683
  *(d->success + s) = (char)0;
#line 2684
  tmp___5 = accepts_in_context((int )(d->states + s)->context, 4, s, (struct dfa  const  *)d);
  }
#line 2684
  if (tmp___5) {
#line 2685
    *(d->success + s) = (char )((int )*(d->success + s) | 4);
  }
  {
#line 2686
  tmp___6 = accepts_in_context((int )(d->states + s)->context, 2, s, (struct dfa  const  *)d);
  }
#line 2686
  if (tmp___6) {
#line 2687
    *(d->success + s) = (char )((int )*(d->success + s) | 2);
  }
  {
#line 2688
  tmp___7 = accepts_in_context((int )(d->states + s)->context, 1, s, (struct dfa  const  *)d);
  }
#line 2688
  if (tmp___7) {
#line 2689
    *(d->success + s) = (char )((int )*(d->success + s) | 1);
  }
  {
#line 2693
  tmp___8 = xnmalloc(d->nleaves, sizeof(*(group.elems)));
#line 2693
  group.elems = (size_t *)tmp___8;
#line 2694
  group.nelem = (size_t )0;
#line 2698
  fillset(& label___0);
#line 2700
  i___1 = (size_t )0;
  }
  {
#line 2700
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2700
    if (! (i___1 < (size_t )(d->states + s)->elems.nelem)) {
#line 2700
      goto while_break___1;
    }
#line 2703
    pos = *((d->states + s)->elems.elems + i___1);
#line 2704
    matched = (_Bool)0;
#line 2705
    if (*(d->tokens + pos.index) >= 0L) {
#line 2705
      if (*(d->tokens + pos.index) < 256L) {
        {
#line 2707
        zeroset(& matches);
#line 2708
        setbit((unsigned int )*(d->tokens + pos.index), & matches);
        }
#line 2709
        if (*(d->tokens + pos.index) == (token )uc) {
#line 2710
          matched = (_Bool)1;
        }
      } else {
#line 2705
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2712
    if (*(d->tokens + pos.index) >= 275L) {
      {
#line 2714
      matches = *(d->charclasses + (*(d->tokens + pos.index) - 275L));
#line 2715
      tmp___9 = tstbit((unsigned int )uc, (charclass const   *)(& matches));
      }
#line 2715
      if (tmp___9) {
#line 2716
        matched = (_Bool)1;
      }
    } else
#line 2718
    if (*(d->tokens + pos.index) == 272L) {
      {
#line 2720
      matches = *(d->charclasses + d->canychar);
#line 2721
      tmp___10 = tstbit((unsigned int )uc, (charclass const   *)(& matches));
      }
#line 2721
      if (tmp___10) {
#line 2722
        matched = (_Bool)1;
      }
      {
#line 2730
      tmp___11 = succeeds_in_context((int )pos.constraint, (int )(d->states + s)->context,
                                     1);
      }
#line 2730
      if (tmp___11) {
#line 2733
        if ((d->states + s)->mbps.nelem == 0L) {
          {
#line 2734
          alloc_position_set(& (d->states + s)->mbps, (size_t )(d->follows + pos.index)->nelem);
          }
        }
#line 2736
        j = (size_t )0;
        {
#line 2736
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2736
          if (! (j < (size_t )(d->follows + pos.index)->nelem)) {
#line 2736
            goto while_break___2;
          }
          {
#line 2737
          insert(*((d->follows + pos.index)->elems + j), & (d->states + s)->mbps);
#line 2736
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
#line 2741
      goto __Cont;
    }
#line 2745
    if (pos.constraint != 511U) {
      {
#line 2747
      tmp___12 = succeeds_in_context((int )pos.constraint, (int )(d->states + s)->context,
                                     4);
      }
#line 2747
      if (! tmp___12) {
#line 2749
        j___0 = (size_t )0;
        {
#line 2749
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2749
          if (! (j___0 < 4UL)) {
#line 2749
            goto while_break___3;
          }
#line 2750
          matches.w[j___0] &= ~ d->syntax.newline.w[j___0];
#line 2749
          j___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 2751
      tmp___13 = succeeds_in_context((int )pos.constraint, (int )(d->states + s)->context,
                                     2);
      }
#line 2751
      if (! tmp___13) {
#line 2753
        j___1 = (size_t )0;
        {
#line 2753
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2753
          if (! (j___1 < 4UL)) {
#line 2753
            goto while_break___4;
          }
#line 2754
          matches.w[j___1] &= ~ d->syntax.letters.w[j___1];
#line 2753
          j___1 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 2755
      tmp___14 = succeeds_in_context((int )pos.constraint, (int )(d->states + s)->context,
                                     1);
      }
#line 2755
      if (! tmp___14) {
#line 2757
        j___2 = (size_t )0;
        {
#line 2757
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2757
          if (! (j___2 < 4UL)) {
#line 2757
            goto while_break___5;
          }
#line 2758
          matches.w[j___2] &= d->syntax.letters.w[j___2] | d->syntax.newline.w[j___2];
#line 2757
          j___2 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      {
#line 2761
      tmp___15 = emptyset((charclass const   *)(& matches));
      }
#line 2761
      if (tmp___15) {
#line 2762
        goto __Cont;
      }
      {
#line 2767
      tmp___16 = tstbit((unsigned int )uc, (charclass const   *)(& matches));
      }
#line 2767
      if (! tmp___16) {
#line 2768
        matched = (_Bool)0;
      }
    }
#line 2781
    if (matched) {
#line 2783
      k = (size_t )0;
      {
#line 2783
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2783
        if (! (k < 4UL)) {
#line 2783
          goto while_break___6;
        }
#line 2784
        label___0.w[k] &= matches.w[k];
#line 2783
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2785
      tmp___17 = group.nelem;
#line 2785
      (group.nelem) ++;
#line 2785
      *(group.elems + tmp___17) = pos.index;
    } else {
#line 2789
      k___0 = (size_t )0;
      {
#line 2789
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2789
        if (! (k___0 < 4UL)) {
#line 2789
          goto while_break___7;
        }
#line 2790
        label___0.w[k___0] &= ~ matches.w[k___0];
#line 2789
        k___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 2700
    i___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2794
  alloc_position_set(& follows, d->nleaves);
#line 2795
  alloc_position_set(& tmp, d->nleaves);
  }
#line 2797
  if (group.nelem > 0UL) {
#line 2799
    follows.nelem = (ptrdiff_t )0;
#line 2803
    j___3 = (size_t )0;
    {
#line 2803
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2803
      if (! (j___3 < group.nelem)) {
#line 2803
        goto while_break___8;
      }
#line 2804
      k___1 = (size_t )0;
      {
#line 2804
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 2804
        if (! (k___1 < (size_t )(d->follows + *(group.elems + j___3))->nelem)) {
#line 2804
          goto while_break___9;
        }
        {
#line 2805
        insert(*((d->follows + *(group.elems + j___3))->elems + k___1), & follows);
#line 2804
        k___1 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 2803
      j___3 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 2809
    if (d->searchflag) {
#line 2828
      mergeit = (_Bool )(! d->localeinfo.multibyte);
#line 2829
      if (! mergeit) {
#line 2831
        mergeit = (_Bool)1;
#line 2832
        j___4 = (size_t )0;
        {
#line 2832
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 2832
          if (mergeit) {
#line 2832
            if (! (j___4 < (size_t )follows.nelem)) {
#line 2832
              goto while_break___10;
            }
          } else {
#line 2832
            goto while_break___10;
          }
#line 2833
          mergeit = (_Bool )((int )mergeit & (int )*(d->multibyte_prop + (follows.elems + j___4)->index));
#line 2832
          j___4 ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 2835
      if (mergeit) {
        {
#line 2837
        merge((position_set const   *)(& (d->states + 0)->elems), (position_set const   *)(& follows),
              & tmp);
#line 2838
        copy((position_set const   *)(& tmp), & follows);
        }
      }
    }
    {
#line 2845
    tmp___18 = charclass_context((struct dfa  const  *)d, (charclass const   *)(& label___0));
#line 2845
    possible_contexts = tmp___18;
#line 2846
    tmp___19 = state_separate_contexts((position_set const   *)(& follows));
#line 2846
    separate_contexts = (int )tmp___19;
    }
#line 2849
    if (possible_contexts & ~ separate_contexts) {
      {
#line 2850
      state = state_index(d, (position_set const   *)(& follows), separate_contexts ^ 7);
      }
    } else {
#line 2852
      state = (state_num )-1;
    }
#line 2853
    if ((separate_contexts & possible_contexts) & 4) {
      {
#line 2854
      state_newline = state_index(d, (position_set const   *)(& follows), 4);
      }
    } else {
#line 2856
      state_newline = state;
    }
#line 2857
    if ((separate_contexts & possible_contexts) & 2) {
      {
#line 2858
      state_letter = state_index(d, (position_set const   *)(& follows), 2);
      }
    } else {
#line 2860
      state_letter = state;
    }
    {
#line 2863
    realloc_trans_if_necessary(d);
    }
  } else
#line 2869
  if (d->searchflag) {
#line 2871
    state_newline = (state_num )0;
#line 2872
    state_letter = (state_num )(d->min_trcount - 1);
#line 2873
    state = d->initstate_notbol;
  } else {
#line 2877
    state_newline = (state_num )-1;
#line 2878
    state_letter = (state_num )-1;
#line 2879
    state = (state_num )-1;
  }
#line 2883
  i___2 = (size_t )0;
  {
#line 2883
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 2883
    if (! (i___2 < 256UL)) {
#line 2883
      goto while_break___11;
    }
    {
#line 2884
    tmp___20 = tstbit((unsigned int )i___2, (charclass const   *)(& label___0));
    }
#line 2884
    if (tmp___20) {
      {
#line 2887
      if ((int )d->syntax.sbit[i___2] == 4) {
#line 2887
        goto case_4;
      }
#line 2890
      if ((int )d->syntax.sbit[i___2] == 2) {
#line 2890
        goto case_2;
      }
#line 2893
      goto switch_default;
      case_4: /* CIL Label */ 
#line 2888
      *(trans + i___2) = state_newline;
#line 2889
      goto switch_break;
      case_2: /* CIL Label */ 
#line 2891
      *(trans + i___2) = state_letter;
#line 2892
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2894
      *(trans + i___2) = state;
#line 2895
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 2883
    i___2 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 2909
  free((void *)group.elems);
#line 2910
  free((void *)follows.elems);
#line 2911
  free((void *)tmp.elems);
#line 2915
  tmp___21 = tstbit((unsigned int )d->syntax.eolbyte, (charclass const   *)(& label___0));
  }
#line 2915
  if (tmp___21) {
#line 2917
    *(d->newlines + s) = *(trans + d->syntax.eolbyte);
#line 2918
    *(trans + d->syntax.eolbyte) = (state_num )-1;
  }
#line 2921
  return (*(trans + uc));
}
}
#line 2930 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static state_num transit_state_singlebyte(struct dfa *d , state_num s , unsigned char const   **pp ) 
{ 
  state_num *t ;
  unsigned char const   *tmp___0 ;

  {
#line 2935
  if (*(d->trans + s)) {
#line 2936
    t = *(d->trans + s);
  } else
#line 2937
  if (*(d->fails + s)) {
#line 2938
    t = *(d->fails + s);
  } else {
    {
#line 2941
    build_state(s, d, (unsigned char )*(*pp));
    }
#line 2942
    if (*(d->trans + s)) {
#line 2943
      t = *(d->trans + s);
    } else {
#line 2946
      t = *(d->fails + s);
#line 2947
      if (! t) {
        {
#line 2947
        __assert_fail("t", "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c", 2947U,
                      "transit_state_singlebyte");
        }
      }
    }
  }
#line 2951
  if (*(t + *(*pp)) == -2L) {
    {
#line 2952
    build_state(s, d, (unsigned char )*(*pp));
    }
  }
#line 2954
  tmp___0 = *pp;
#line 2954
  (*pp) ++;
#line 2954
  return (*(t + *tmp___0));
}
}
#line 2960 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static state_num transit_state(struct dfa *d , state_num s , unsigned char const   **pp ,
                               unsigned char const   *end ) 
{ 
  wint_t wc ;
  int mbclen ;
  size_t tmp ;
  state_num s1 ;
  int mbci ;
  state_num s3 ;
  state_num i ;
  state_num tmp___0 ;
  void *tmp___1 ;
  int i___0 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___2 ;
  state_num s2 ;
  state_num tmp___3 ;

  {
  {
#line 2966
  tmp = mbs_to_wchar(& wc, (char const   *)*pp, (size_t )(end - *pp), d);
#line 2966
  mbclen = (int )tmp;
#line 2969
  d->mb_follows.nelem = (ptrdiff_t )0;
#line 2973
  s1 = s;
#line 2975
  mbci = 0;
  }
  {
#line 2975
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2975
    if (mbci < mbclen) {
#line 2975
      if (! (mbci == 0)) {
#line 2975
        if (! ((state_num )d->min_trcount <= s)) {
#line 2975
          goto while_break;
        }
      }
    } else {
#line 2975
      goto while_break;
    }
    {
#line 2976
    s = transit_state_singlebyte(d, s, pp);
#line 2975
    mbci ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2977
  *pp += mbclen - mbci;
#line 2979
  if (wc == 4294967295U) {
#line 2982
    return (s);
  }
#line 2988
  if ((d->states + s1)->mb_trindex < 0L) {
#line 2990
    if (1024L <= d->mb_trcount) {
#line 2993
      s3 = (state_num )-1;
      {
#line 2993
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2993
        if (! (s3 < d->tralloc)) {
#line 2993
          goto while_break___0;
        }
        {
#line 2995
        free((void *)*(d->mb_trans + s3));
#line 2996
        *(d->mb_trans + s3) = (state_num *)((void *)0);
#line 2993
        s3 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2999
      i = (state_num )0;
      {
#line 2999
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2999
        if (! (i < d->sindex)) {
#line 2999
          goto while_break___1;
        }
#line 3000
        (d->states + i)->mb_trindex = (state_num )-1;
#line 2999
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3001
      d->mb_trcount = (state_num )0;
    }
#line 3003
    tmp___0 = d->mb_trcount;
#line 3003
    (d->mb_trcount) ++;
#line 3003
    (d->states + s1)->mb_trindex = tmp___0;
  }
#line 3006
  if (! *(d->mb_trans + s)) {
    {
#line 3010
    tmp___1 = xmalloc((size_t )8192);
#line 3010
    *(d->mb_trans + s) = (state_num *)tmp___1;
#line 3011
    i___0 = 0;
    }
    {
#line 3011
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3011
      if (! (i___0 < 1024)) {
#line 3011
        goto while_break___2;
      }
#line 3012
      *(*(d->mb_trans + s) + i___0) = (state_num )-1;
#line 3011
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 3014
  if (*(*(d->mb_trans + s) + (d->states + s1)->mb_trindex) >= 0L) {
#line 3015
    return (*(*(d->mb_trans + s) + (d->states + s1)->mb_trindex));
  }
#line 3017
  if (s == -1L) {
    {
#line 3018
    copy((position_set const   *)(& (d->states + s1)->mbps), & d->mb_follows);
    }
  } else {
    {
#line 3020
    merge((position_set const   *)(& (d->states + s1)->mbps), (position_set const   *)(& (d->states + s)->elems),
          & d->mb_follows);
    }
  }
  {
#line 3022
  tmp___2 = state_separate_contexts((position_set const   *)(& d->mb_follows));
#line 3022
  separate_contexts = (int )tmp___2;
#line 3023
  tmp___3 = state_index(d, (position_set const   *)(& d->mb_follows), separate_contexts ^ 7);
#line 3023
  s2 = tmp___3;
#line 3024
  realloc_trans_if_necessary(d);
#line 3026
  *(*(d->mb_trans + s) + (d->states + s1)->mb_trindex) = s2;
  }
#line 3028
  return (s2);
}
}
#line 3046 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static unsigned char const   *skip_remains_mb(struct dfa *d , unsigned char const   *p ,
                                              unsigned char const   *mbp , char const   *end ) 
{ 
  wint_t wc ;
  size_t tmp ;

  {
#line 3050
  if (d->syntax.never_trail[*p]) {
#line 3051
    return (p);
  }
  {
#line 3052
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3052
    if (! ((unsigned long )mbp < (unsigned long )p)) {
#line 3052
      goto while_break;
    }
    {
#line 3055
    tmp = mbs_to_wchar(& wc, (char const   *)mbp, (size_t )(end - (char const   *)mbp),
                       d);
#line 3055
    mbp += tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3058
  return (mbp);
}
}
#line 3081 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
__inline static char *dfaexec_main(struct dfa *d , char const   *begin , char *end ,
                                   _Bool allow_nl , size_t *count , _Bool multibyte ) 
{ 
  state_num s ;
  state_num s___0 ;
  state_num *tmp ;
  state_num s___1 ;
  state_num s___2 ;
  state_num s___3 ;
  state_num s1 ;
  unsigned char const   *p ;
  unsigned char const   *mbp ;
  state_num **trans ;
  unsigned char eol ;
  unsigned char saved_end ;
  size_t nlcount ;
  state_num *t ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  state_num tmp___2 ;
  unsigned char const   *tmp___3 ;
  state_num tmp___4 ;
  state_num tmp___5 ;
  _Bool tmp___6 ;
  unsigned char const   *tmp___7 ;

  {
#line 3085
  if (1024L <= d->sindex) {
#line 3087
    s = (state_num )d->min_trcount;
    {
#line 3087
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3087
      if (! (s < d->sindex)) {
#line 3087
        goto while_break;
      }
      {
#line 3089
      free((void *)(d->states + s)->elems.elems);
#line 3090
      free((void *)(d->states + s)->mbps.elems);
#line 3087
      s ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3092
    d->sindex = (state_num )d->min_trcount;
#line 3094
    if (d->trans) {
#line 3096
      s___0 = (state_num )0;
      {
#line 3096
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3096
        if (! (s___0 < d->tralloc)) {
#line 3096
          goto while_break___0;
        }
        {
#line 3098
        free((void *)*(d->trans + s___0));
#line 3099
        free((void *)*(d->fails + s___0));
#line 3100
        tmp = (state_num *)((void *)0);
#line 3100
        *(d->fails + s___0) = tmp;
#line 3100
        *(d->trans + s___0) = tmp;
#line 3096
        s___0 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3102
      d->trcount = 0;
    }
#line 3105
    if (d->localeinfo.multibyte) {
#line 3105
      if (d->mb_trans) {
#line 3107
        s___1 = (state_num )-1;
        {
#line 3107
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3107
          if (! (s___1 < d->tralloc)) {
#line 3107
            goto while_break___1;
          }
          {
#line 3109
          free((void *)*(d->mb_trans + s___1));
#line 3110
          *(d->mb_trans + s___1) = (state_num *)((void *)0);
#line 3107
          s___1 ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3112
        s___2 = (state_num )0;
        {
#line 3112
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3112
          if (! (s___2 < (state_num )d->min_trcount)) {
#line 3112
            goto while_break___2;
          }
#line 3113
          (d->states + s___2)->mb_trindex = (state_num )-1;
#line 3112
          s___2 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3114
        d->mb_trcount = (state_num )0;
      }
    }
  }
#line 3118
  if (! d->tralloc) {
    {
#line 3119
    realloc_trans_if_necessary(d);
    }
  }
#line 3122
  s___3 = (state_num )0;
#line 3122
  s1 = (state_num )0;
#line 3125
  p = (unsigned char const   *)begin;
#line 3126
  mbp = p;
#line 3129
  trans = d->trans;
#line 3130
  eol = d->syntax.eolbyte;
#line 3131
  saved_end = *((unsigned char *)end);
#line 3132
  *end = (char )eol;
#line 3134
  if (multibyte) {
    {
#line 3136
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
#line 3137
    if (d->mb_follows.alloc == 0L) {
      {
#line 3138
      alloc_position_set(& d->mb_follows, d->nleaves);
      }
    }
  }
#line 3141
  nlcount = (size_t )0;
  {
#line 3142
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 3145
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3145
      t = *(trans + s___3);
#line 3145
      if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 3145
        goto while_break___4;
      }
#line 3147
      if (s___3 < (state_num )d->min_trcount) {
#line 3149
        if (! multibyte) {
#line 3149
          goto _L;
        } else
#line 3149
        if ((d->states + s___3)->mbps.nelem == 0L) {
          _L: /* CIL Label */ 
          {
#line 3151
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 3151
            if (! (*(t + *p) == s___3)) {
#line 3151
              goto while_break___5;
            }
#line 3152
            p ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 3154
        if (multibyte) {
          {
#line 3155
          mbp = skip_remains_mb(d, p, mbp, (char const   *)end);
#line 3155
          p = mbp;
          }
        }
      }
#line 3158
      if (multibyte) {
#line 3160
        s1 = s___3;
#line 3162
        if ((d->states + s___3)->mbps.nelem == 0L) {
#line 3167
          tmp___0 = p;
#line 3167
          p ++;
#line 3167
          s___3 = *(t + *tmp___0);
        } else
#line 3162
        if (d->localeinfo.sbctowc[*p] != 4294967295U) {
#line 3167
          tmp___0 = p;
#line 3167
          p ++;
#line 3167
          s___3 = *(t + *tmp___0);
        } else
#line 3162
        if ((unsigned long )((char *)p) >= (unsigned long )end) {
#line 3167
          tmp___0 = p;
#line 3167
          p ++;
#line 3167
          s___3 = *(t + *tmp___0);
        } else {
          {
#line 3171
          s___3 = transit_state(d, s___3, & p, (unsigned char const   *)((unsigned char *)end));
#line 3172
          mbp = p;
#line 3173
          trans = d->trans;
          }
        }
      } else {
#line 3178
        tmp___1 = p;
#line 3178
        p ++;
#line 3178
        s1 = *(t + *tmp___1);
#line 3179
        t = *(trans + s1);
#line 3180
        if (! t) {
#line 3182
          tmp___2 = s___3;
#line 3183
          s___3 = s1;
#line 3184
          s1 = tmp___2;
#line 3185
          goto while_break___4;
        }
#line 3187
        if (s___3 < (state_num )d->min_trcount) {
          {
#line 3189
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 3189
            if (! (*(t + *p) == s1)) {
#line 3189
              goto while_break___6;
            }
#line 3190
            p ++;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 3192
        tmp___3 = p;
#line 3192
        p ++;
#line 3192
        s___3 = *(t + *tmp___3);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3196
    if (s___3 < 0L) {
#line 3198
      if (s___3 == -2L) {
        {
#line 3200
        s___3 = build_state(s1, d, (unsigned char )*(p + -1));
#line 3201
        trans = d->trans;
        }
      } else
#line 3203
      if ((unsigned long )((char *)p) <= (unsigned long )end) {
#line 3203
        if ((int const   )*(p + -1) == (int const   )eol) {
#line 3203
          if (0L <= *(d->newlines + s1)) {
#line 3207
            nlcount ++;
#line 3208
            mbp = p;
#line 3210
            if (allow_nl) {
#line 3210
              s___3 = *(d->newlines + s1);
            } else {
#line 3210
              if ((int )d->syntax.sbit[eol] == 4) {
#line 3210
                tmp___5 = (state_num )0;
              } else {
#line 3210
                if ((int )d->syntax.sbit[eol] == 2) {
#line 3210
                  tmp___4 = (state_num )(d->min_trcount - 1);
                } else {
#line 3210
                  tmp___4 = d->initstate_notbol;
                }
#line 3210
                tmp___5 = tmp___4;
              }
#line 3210
              s___3 = tmp___5;
            }
          } else {
#line 3217
            p = (unsigned char const   *)((void *)0);
#line 3218
            goto done;
          }
        } else {
#line 3217
          p = (unsigned char const   *)((void *)0);
#line 3218
          goto done;
        }
      } else {
#line 3217
        p = (unsigned char const   *)((void *)0);
#line 3218
        goto done;
      }
    } else
#line 3221
    if (*(d->fails + s___3)) {
#line 3223
      if ((int )*(d->success + s___3) & (int )d->syntax.sbit[*p]) {
#line 3227
        goto done;
      } else
#line 3223
      if ((unsigned long )((char *)p) == (unsigned long )end) {
        {
#line 3223
        tmp___6 = accepts_in_context((int )(d->states + s___3)->context, 4, s___3,
                                     (struct dfa  const  *)d);
        }
#line 3223
        if (tmp___6) {
#line 3227
          goto done;
        }
      }
#line 3229
      if (multibyte) {
#line 3229
        if (s___3 < (state_num )d->min_trcount) {
          {
#line 3230
          mbp = skip_remains_mb(d, p, mbp, (char const   *)end);
#line 3230
          p = mbp;
          }
        }
      }
#line 3232
      s1 = s___3;
#line 3233
      if (! multibyte) {
#line 3238
        tmp___7 = p;
#line 3238
        p ++;
#line 3238
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3233
      if ((d->states + s___3)->mbps.nelem == 0L) {
#line 3238
        tmp___7 = p;
#line 3238
        p ++;
#line 3238
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3233
      if (d->localeinfo.sbctowc[*p] != 4294967295U) {
#line 3238
        tmp___7 = p;
#line 3238
        p ++;
#line 3238
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3233
      if ((unsigned long )((char *)p) >= (unsigned long )end) {
#line 3238
        tmp___7 = p;
#line 3238
        p ++;
#line 3238
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else {
        {
#line 3242
        s___3 = transit_state(d, s___3, & p, (unsigned char const   *)((unsigned char *)end));
#line 3243
        mbp = p;
#line 3244
        trans = d->trans;
        }
      }
    } else {
      {
#line 3249
      build_state(s___3, d, (unsigned char )*(p + 0));
#line 3250
      trans = d->trans;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  done: 
#line 3255
  if (count) {
#line 3256
    *count += nlcount;
  }
#line 3257
  *end = (char )saved_end;
#line 3258
  return ((char *)p);
}
}
#line 3264 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char *dfaexec_mb(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                        size_t *count , _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3268
  tmp = dfaexec_main(d, begin, end, allow_nl, count, (_Bool)1);
  }
#line 3268
  return (tmp);
}
}
#line 3271 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char *dfaexec_sb(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                        size_t *count , _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3275
  tmp = dfaexec_main(d, begin, end, allow_nl, count, (_Bool)0);
  }
#line 3275
  return (tmp);
}
}
#line 3280 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char *dfaexec_noop(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                          size_t *count , _Bool *backref ) 
{ 


  {
#line 3284
  *backref = (_Bool)1;
#line 3285
  return ((char *)begin);
}
}
#line 3292 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
char *dfaexec(struct dfa *d , char const   *begin , char *end , _Bool allow_nl , size_t *count ,
              _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3296
  tmp = (*(d->dfaexec))(d, begin, end, allow_nl, count, backref);
  }
#line 3296
  return (tmp);
}
}
#line 3299
struct dfa *dfasuperset(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 3299 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct dfa *dfasuperset(struct dfa  const  *d ) 
{ 


  {
#line 3302
  return ((struct dfa *)d->superset);
}
}
#line 3305
_Bool dfaisfast(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 3305 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
_Bool dfaisfast(struct dfa  const  *d ) 
{ 


  {
#line 3308
  return ((_Bool )d->fast);
}
}
#line 3311 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void free_mbdata(struct dfa *d ) 
{ 
  state_num s ;

  {
  {
#line 3314
  free((void *)d->multibyte_prop);
#line 3315
  free((void *)d->lex.brack.chars);
#line 3316
  free((void *)d->mb_follows.elems);
  }
#line 3318
  if (d->mb_trans) {
#line 3321
    s = (state_num )-1;
    {
#line 3321
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3321
      if (! (s < d->tralloc)) {
#line 3321
        goto while_break;
      }
      {
#line 3322
      free((void *)*(d->mb_trans + s));
#line 3321
      s ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3323
    free((void *)(d->mb_trans - 2));
    }
  }
#line 3325
  return;
}
}
#line 3328 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool __attribute__((__pure__))  dfa_supported(struct dfa  const  *d ) 
{ 
  size_t i ;

  {
#line 3331
  i = (size_t )0;
  {
#line 3331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3331
    if (! (i < (size_t )d->tindex)) {
#line 3331
      goto while_break;
    }
    {
#line 3338
    if (*(d->tokens + i) == 263L) {
#line 3338
      goto case_263;
    }
#line 3338
    if (*(d->tokens + i) == 262L) {
#line 3338
      goto case_263;
    }
#line 3338
    if (*(d->tokens + i) == 261L) {
#line 3338
      goto case_263;
    }
#line 3338
    if (*(d->tokens + i) == 260L) {
#line 3338
      goto case_263;
    }
#line 3343
    if (*(d->tokens + i) == 273L) {
#line 3343
      goto case_273;
    }
#line 3343
    if (*(d->tokens + i) == 257L) {
#line 3343
      goto case_273;
    }
#line 3333
    goto switch_break;
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 3339
    if (! d->localeinfo.multibyte) {
#line 3340
      goto __Cont;
    }
    case_273: /* CIL Label */ 
    case_257: /* CIL Label */ 
#line 3344
    return ((_Bool __attribute__((__pure__))  )0);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 3331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3347
  return ((_Bool __attribute__((__pure__))  )1);
}
}
#line 3350 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void dfaoptimize(struct dfa *d ) 
{ 
  _Bool have_backref ;
  size_t i ;

  {
#line 3353
  if (! d->localeinfo.using_utf8) {
#line 3354
    return;
  }
#line 3356
  have_backref = (_Bool)0;
#line 3357
  i = (size_t )0;
  {
#line 3357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3357
    if (! (i < d->tindex)) {
#line 3357
      goto while_break;
    }
    {
#line 3361
    if (*(d->tokens + i) == 272L) {
#line 3361
      goto case_272;
    }
#line 3364
    if (*(d->tokens + i) == 257L) {
#line 3364
      goto case_257;
    }
#line 3367
    if (*(d->tokens + i) == 273L) {
#line 3367
      goto case_273;
    }
#line 3370
    goto switch_default;
    case_272: /* CIL Label */ 
    {
#line 3363
    abort();
    }
    case_257: /* CIL Label */ 
#line 3365
    have_backref = (_Bool)1;
#line 3366
    goto switch_break;
    case_273: /* CIL Label */ 
#line 3369
    return;
    switch_default: /* CIL Label */ 
#line 3371
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3357
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3375
  if (! have_backref) {
#line 3375
    if (d->superset) {
      {
#line 3378
      dfafree(d->superset);
#line 3379
      free((void *)d->superset);
#line 3380
      d->superset = (struct dfa *)((void *)0);
      }
    }
  }
  {
#line 3383
  free_mbdata(d);
#line 3384
  d->localeinfo.multibyte = (_Bool)0;
#line 3385
  d->dfaexec = & dfaexec_sb;
#line 3386
  d->fast = (_Bool)1;
  }
#line 3387
  return;
}
}
#line 3389 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void dfassbuild(struct dfa *d ) 
{ 
  struct dfa *sup ;
  struct dfa *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  _Bool have_achar ;
  _Bool have_nchar ;
  size_t j ;
  size_t i ;
  charclass ccl ;
  size_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 3392
  tmp = dfaalloc();
#line 3392
  sup = tmp;
#line 3394
  *sup = *d;
#line 3395
  sup->localeinfo.multibyte = (_Bool)0;
#line 3396
  sup->dfaexec = & dfaexec_sb;
#line 3397
  sup->multibyte_prop = (char *)((void *)0);
#line 3398
  sup->superset = (struct dfa *)((void *)0);
#line 3399
  sup->states = (dfa_state *)((void *)0);
#line 3400
  sup->sindex = (state_num )0;
#line 3401
  sup->follows = (position_set *)((void *)0);
#line 3402
  sup->tralloc = (state_num )0;
#line 3403
  sup->trans = (state_num **)((void *)0);
#line 3404
  sup->fails = (state_num **)((void *)0);
#line 3405
  sup->success = (char *)((void *)0);
#line 3406
  sup->newlines = (state_num *)((void *)0);
#line 3408
  tmp___0 = xnmalloc((size_t )sup->calloc, sizeof(*(sup->charclasses)));
#line 3408
  sup->charclasses = (charclass *)tmp___0;
  }
#line 3409
  if (d->cindex) {
    {
#line 3411
    memcpy((void */* __restrict  */)sup->charclasses, (void const   */* __restrict  */)d->charclasses,
           (unsigned long )d->cindex * sizeof(*(sup->charclasses)));
    }
  }
  {
#line 3415
  tmp___1 = xnmalloc(d->tindex, 2UL * sizeof(*(sup->tokens)));
#line 3415
  sup->tokens = (token *)tmp___1;
#line 3416
  sup->talloc = d->tindex * 2UL;
#line 3418
  have_achar = (_Bool)0;
#line 3419
  have_nchar = (_Bool)0;
#line 3421
  j = (size_t )0;
#line 3421
  i = j;
  }
  {
#line 3421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3421
    if (! (i < d->tindex)) {
#line 3421
      goto while_break;
    }
    {
#line 3427
    if (*(d->tokens + i) == 257L) {
#line 3427
      goto case_257;
    }
#line 3427
    if (*(d->tokens + i) == 273L) {
#line 3427
      goto case_257;
    }
#line 3427
    if (*(d->tokens + i) == 272L) {
#line 3427
      goto case_257;
    }
#line 3442
    if (*(d->tokens + i) == 263L) {
#line 3442
      goto case_263;
    }
#line 3442
    if (*(d->tokens + i) == 262L) {
#line 3442
      goto case_263;
    }
#line 3442
    if (*(d->tokens + i) == 261L) {
#line 3442
      goto case_263;
    }
#line 3442
    if (*(d->tokens + i) == 260L) {
#line 3442
      goto case_263;
    }
#line 3451
    goto switch_default;
    case_257: /* CIL Label */ 
    case_273: /* CIL Label */ 
    case_272: /* CIL Label */ 
    {
#line 3430
    fillset(& ccl);
#line 3431
    tmp___2 = j;
#line 3431
    j ++;
#line 3431
    tmp___3 = charclass_index(sup, & ccl);
#line 3431
    *(sup->tokens + tmp___2) = 275L + tmp___3;
#line 3432
    tmp___4 = j;
#line 3432
    j ++;
#line 3432
    *(sup->tokens + tmp___4) = (token )265;
    }
#line 3433
    if (*(d->tokens + (i + 1UL)) == 264L) {
#line 3435
      i ++;
    } else
#line 3433
    if (*(d->tokens + (i + 1UL)) == 265L) {
#line 3435
      i ++;
    } else
#line 3433
    if (*(d->tokens + (i + 1UL)) == 266L) {
#line 3435
      i ++;
    }
#line 3436
    have_achar = (_Bool)1;
#line 3438
    goto switch_break;
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 3443
    if (d->localeinfo.multibyte) {
#line 3447
      tmp___5 = j;
#line 3447
      j ++;
#line 3447
      *(sup->tokens + tmp___5) = (token )256;
#line 3448
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 3452
    tmp___6 = j;
#line 3452
    j ++;
#line 3452
    *(sup->tokens + tmp___6) = *(d->tokens + i);
#line 3453
    if (0L <= *(d->tokens + i)) {
#line 3453
      if (*(d->tokens + i) < 256L) {
#line 3455
        have_nchar = (_Bool)1;
      } else {
#line 3453
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3453
    if (*(d->tokens + i) >= 275L) {
#line 3455
      have_nchar = (_Bool)1;
    }
#line 3456
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3421
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3459
  sup->tindex = j;
#line 3461
  if (have_nchar) {
#line 3461
    if (have_achar) {
#line 3462
      d->superset = sup;
    } else
#line 3461
    if (d->localeinfo.multibyte) {
#line 3462
      d->superset = sup;
    } else {
      {
#line 3465
      dfafree(sup);
#line 3466
      free((void *)sup);
      }
    }
  } else {
    {
#line 3465
    dfafree(sup);
#line 3466
    free((void *)sup);
    }
  }
#line 3468
  return;
}
}
#line 3471 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
void dfacomp(char const   *s , size_t len , struct dfa *d , _Bool searchflag ) 
{ 
  _Bool __attribute__((__pure__))  tmp ;

  {
  {
#line 3474
  dfaparse(s, len, d);
#line 3475
  dfassbuild(d);
#line 3477
  tmp = dfa_supported((struct dfa  const  *)d);
  }
#line 3477
  if (tmp) {
    {
#line 3479
    dfaoptimize(d);
#line 3480
    dfaanalyze(d, searchflag);
    }
  } else {
#line 3484
    d->dfaexec = & dfaexec_noop;
  }
#line 3487
  if (d->superset) {
    {
#line 3489
    d->fast = (_Bool)1;
#line 3490
    dfaanalyze(d->superset, searchflag);
    }
  }
#line 3492
  return;
}
}
#line 3495 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
void dfafree(struct dfa *d ) 
{ 
  size_t i ;
  size_t i___0 ;
  size_t i___1 ;

  {
  {
#line 3498
  free((void *)d->charclasses);
#line 3499
  free((void *)d->tokens);
  }
#line 3501
  if (d->localeinfo.multibyte) {
    {
#line 3502
    free_mbdata(d);
    }
  }
#line 3504
  i = (size_t )0;
  {
#line 3504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3504
    if (! (i < (size_t )d->sindex)) {
#line 3504
      goto while_break;
    }
    {
#line 3506
    free((void *)(d->states + i)->elems.elems);
#line 3507
    free((void *)(d->states + i)->mbps.elems);
#line 3504
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3509
  free((void *)d->states);
  }
#line 3511
  if (d->follows) {
#line 3513
    i___0 = (size_t )0;
    {
#line 3513
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3513
      if (! (i___0 < d->tindex)) {
#line 3513
        goto while_break___0;
      }
      {
#line 3514
      free((void *)(d->follows + i___0)->elems);
#line 3513
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3515
    free((void *)d->follows);
    }
  }
#line 3518
  if (d->trans) {
#line 3520
    i___1 = (size_t )0;
    {
#line 3520
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3520
      if (! (i___1 < (size_t )d->tralloc)) {
#line 3520
        goto while_break___1;
      }
      {
#line 3522
      free((void *)*(d->trans + i___1));
#line 3523
      free((void *)*(d->fails + i___1));
#line 3520
      i___1 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3526
    free((void *)(d->trans - 2));
#line 3527
    free((void *)d->fails);
#line 3528
    free((void *)d->newlines);
#line 3529
    free((void *)d->success);
    }
  }
#line 3532
  if (d->superset) {
    {
#line 3533
    dfafree(d->superset);
    }
  }
#line 3534
  return;
}
}
#line 3618 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char *icatalloc(char *old , char const   *new ) 
{ 
  size_t newsize ;
  size_t tmp ;
  size_t oldsize ;
  size_t tmp___0 ;
  char *result ;
  void *tmp___1 ;

  {
  {
#line 3621
  tmp = strlen(new);
#line 3621
  newsize = tmp;
  }
#line 3622
  if (newsize == 0UL) {
#line 3623
    return (old);
  }
  {
#line 3624
  tmp___0 = strlen((char const   *)old);
#line 3624
  oldsize = tmp___0;
#line 3625
  tmp___1 = xrealloc((void *)old, (oldsize + newsize) + 1UL);
#line 3625
  result = (char *)tmp___1;
#line 3626
  memcpy((void */* __restrict  */)(result + oldsize), (void const   */* __restrict  */)new,
         newsize + 1UL);
  }
#line 3627
  return (result);
}
}
#line 3630 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void freelist(char **cpp ) 
{ 
  char **tmp ;

  {
  {
#line 3633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3633
    if (! *cpp) {
#line 3633
      goto while_break;
    }
    {
#line 3634
    tmp = cpp;
#line 3634
    cpp ++;
#line 3634
    free((void *)*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3635
  return;
}
}
#line 3637 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char **enlist(char **cpp , char *new , size_t len ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  size_t i ;
  char *tmp___1 ;
  size_t j ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3640
  tmp = xmalloc(len + 1UL);
#line 3640
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)new,
                   len);
#line 3640
  new = (char *)tmp___0;
#line 3641
  *(new + len) = (char )'\000';
#line 3644
  i = (size_t )0;
  }
  {
#line 3644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3644
    if (! ((unsigned long )*(cpp + i) != (unsigned long )((void *)0))) {
#line 3644
      goto while_break;
    }
    {
#line 3645
    tmp___1 = strstr((char const   *)*(cpp + i), (char const   *)new);
    }
#line 3645
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 3647
      free((void *)new);
      }
#line 3648
      return (cpp);
    }
#line 3644
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3651
  j = (size_t )0;
  {
#line 3651
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3651
    if (! ((unsigned long )*(cpp + j) != (unsigned long )((void *)0))) {
#line 3651
      goto while_break___0;
    }
    {
#line 3652
    tmp___2 = strstr((char const   *)new, (char const   *)*(cpp + j));
    }
#line 3652
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 3653
      j ++;
    } else {
      {
#line 3656
      free((void *)*(cpp + j));
#line 3657
      i --;
      }
#line 3657
      if (i == j) {
#line 3658
        goto while_break___0;
      }
#line 3659
      *(cpp + j) = *(cpp + i);
#line 3660
      *(cpp + i) = (char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3663
  tmp___3 = xnrealloc((void *)cpp, i + 2UL, sizeof(*cpp));
#line 3663
  cpp = (char **)tmp___3;
#line 3664
  *(cpp + i) = new;
#line 3665
  *(cpp + (i + 1UL)) = (char *)((void *)0);
  }
#line 3666
  return (cpp);
}
}
#line 3671 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char **comsubs(char *left , char const   *right ) 
{ 
  char **cpp ;
  void *tmp ;
  char *lcp ;
  size_t len ;
  char *rcp ;
  char *tmp___0 ;
  size_t i ;

  {
  {
#line 3674
  tmp = xzalloc(sizeof(*cpp));
#line 3674
  cpp = (char **)tmp;
#line 3676
  lcp = left;
  }
  {
#line 3676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3676
    if (! ((int )*lcp != 0)) {
#line 3676
      goto while_break;
    }
    {
#line 3678
    len = (size_t )0;
#line 3679
    tmp___0 = strchr(right, (int )*lcp);
#line 3679
    rcp = tmp___0;
    }
    {
#line 3680
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3680
      if (! ((unsigned long )rcp != (unsigned long )((void *)0))) {
#line 3680
        goto while_break___0;
      }
#line 3683
      i = (size_t )1;
      {
#line 3683
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3683
        if ((int )*(lcp + i) != 0) {
#line 3683
          if (! ((int )*(lcp + i) == (int )*(rcp + i))) {
#line 3683
            goto while_break___1;
          }
        } else {
#line 3683
          goto while_break___1;
        }
#line 3684
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 3683
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3685
      if (i > len) {
#line 3686
        len = i;
      }
      {
#line 3687
      rcp = strchr((char const   *)(rcp + 1), (int )*lcp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3689
    if (len != 0UL) {
      {
#line 3690
      cpp = enlist(cpp, lcp, len);
      }
    }
#line 3676
    lcp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3692
  return (cpp);
}
}
#line 3695 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char **addlists(char **old , char **new ) 
{ 
  size_t tmp ;

  {
  {
#line 3698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3698
    if (! *new) {
#line 3698
      goto while_break;
    }
    {
#line 3699
    tmp = strlen((char const   *)*new);
#line 3699
    old = enlist(old, *new, tmp);
#line 3698
    new ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3700
  return (old);
}
}
#line 3705 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char **inboth(char **left , char **right ) 
{ 
  char **both ;
  void *tmp ;
  size_t lnum ;
  size_t rnum ;
  char **temp ;
  char **tmp___0 ;

  {
  {
#line 3708
  tmp = xzalloc(sizeof(*both));
#line 3708
  both = (char **)tmp;
#line 3710
  lnum = (size_t )0;
  }
  {
#line 3710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3710
    if (! ((unsigned long )*(left + lnum) != (unsigned long )((void *)0))) {
#line 3710
      goto while_break;
    }
#line 3712
    rnum = (size_t )0;
    {
#line 3712
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3712
      if (! ((unsigned long )*(right + rnum) != (unsigned long )((void *)0))) {
#line 3712
        goto while_break___0;
      }
      {
#line 3714
      tmp___0 = comsubs(*(left + lnum), (char const   *)*(right + rnum));
#line 3714
      temp = tmp___0;
#line 3715
      both = addlists(both, temp);
#line 3716
      freelist(temp);
#line 3717
      free((void *)temp);
#line 3712
      rnum ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3710
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3720
  return (both);
}
}
#line 3736 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static must *allocmust(must *mp , size_t size ) 
{ 
  must *new_mp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3739
  tmp = xmalloc(sizeof(*new_mp));
#line 3739
  new_mp = (must *)tmp;
#line 3740
  tmp___0 = xzalloc(sizeof(*(new_mp->in)));
#line 3740
  new_mp->in = (char **)tmp___0;
#line 3741
  tmp___1 = xzalloc(size);
#line 3741
  new_mp->left = (char *)tmp___1;
#line 3742
  tmp___2 = xzalloc(size);
#line 3742
  new_mp->right = (char *)tmp___2;
#line 3743
  tmp___3 = xzalloc(size);
#line 3743
  new_mp->is = (char *)tmp___3;
#line 3744
  new_mp->begline = (_Bool)0;
#line 3745
  new_mp->endline = (_Bool)0;
#line 3746
  new_mp->prev = mp;
  }
#line 3747
  return (new_mp);
}
}
#line 3750 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void resetmust(must *mp ) 
{ 
  char tmp ;
  char tmp___0 ;

  {
  {
#line 3753
  freelist(mp->in);
#line 3754
  *(mp->in + 0) = (char *)((void *)0);
#line 3755
  tmp___0 = (char )'\000';
#line 3755
  *(mp->is + 0) = tmp___0;
#line 3755
  tmp = tmp___0;
#line 3755
  *(mp->right + 0) = tmp;
#line 3755
  *(mp->left + 0) = tmp;
#line 3756
  mp->begline = (_Bool)0;
#line 3757
  mp->endline = (_Bool)0;
  }
#line 3758
  return;
}
}
#line 3760 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void freemust(must *mp ) 
{ 


  {
  {
#line 3763
  freelist(mp->in);
#line 3764
  free((void *)mp->in);
#line 3765
  free((void *)mp->left);
#line 3766
  free((void *)mp->right);
#line 3767
  free((void *)mp->is);
#line 3768
  free((void *)mp);
  }
#line 3769
  return;
}
}
#line 3771 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct dfamust *dfamust(struct dfa  const  *d ) 
{ 
  must *mp ;
  char const   *result ;
  _Bool exact ;
  _Bool begline ;
  _Bool endline ;
  _Bool need_begline ;
  _Bool need_endline ;
  _Bool case_fold_unibyte ;
  size_t tmp ;
  int tmp___0 ;
  size_t ri ;
  token t ;
  char **new ;
  must *rmp ;
  must *lmp ;
  size_t j ;
  size_t ln ;
  size_t rn ;
  size_t n ;
  _Bool tmp___1 ;
  size_t i ;
  size_t i___0 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  _Bool tmp___5 ;
  must *rmp___0 ;
  must *lmp___0 ;
  size_t lrlen ;
  size_t tmp___6 ;
  size_t rllen ;
  size_t tmp___7 ;
  char *tp ;
  void *tmp___8 ;
  charclass *ccl ;
  int j___0 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t rj ;
  char tmp___13 ;
  char tmp___14 ;
  int tmp___15 ;
  size_t i___1 ;
  char tmp___16 ;
  char tmp___17 ;
  int tmp___18 ;
  char tmp___19 ;
  char tmp___20 ;
  struct dfamust *dm ;
  void *tmp___21 ;
  must *prev ;

  {
#line 3774
  mp = (must *)((void *)0);
#line 3775
  result = "";
#line 3776
  exact = (_Bool)0;
#line 3777
  begline = (_Bool)0;
#line 3778
  endline = (_Bool)0;
#line 3779
  need_begline = (_Bool)0;
#line 3780
  need_endline = (_Bool)0;
#line 3781
  if (d->syntax.case_fold) {
    {
#line 3781
    tmp = __ctype_get_mb_cur_max();
    }
#line 3781
    if (tmp == 1UL) {
#line 3781
      tmp___0 = 1;
    } else {
#line 3781
      tmp___0 = 0;
    }
  } else {
#line 3781
    tmp___0 = 0;
  }
#line 3781
  case_fold_unibyte = (_Bool )tmp___0;
#line 3783
  ri = (size_t )0;
  {
#line 3783
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3783
    if (! (ri < (size_t )d->tindex)) {
#line 3783
      goto while_break;
    }
#line 3785
    t = *(d->tokens + ri);
    {
#line 3788
    if (t == 258L) {
#line 3788
      goto case_258;
    }
#line 3793
    if (t == 259L) {
#line 3793
      goto case_259;
    }
#line 3799
    if (t == 271L) {
#line 3799
      goto case_271;
    }
#line 3799
    if (t == 270L) {
#line 3799
      goto case_271;
    }
#line 3809
    if (t == 273L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 272L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 257L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 263L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 262L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 261L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 260L) {
#line 3809
      goto case_273;
    }
#line 3809
    if (t == 256L) {
#line 3809
      goto case_273;
    }
#line 3814
    if (t == 264L) {
#line 3814
      goto case_264;
    }
#line 3814
    if (t == 265L) {
#line 3814
      goto case_264;
    }
#line 3818
    if (t == 269L) {
#line 3818
      goto case_269;
    }
#line 3862
    if (t == 266L) {
#line 3862
      goto case_266;
    }
#line 3866
    if (t == -1L) {
#line 3866
      goto case_neg_1;
    }
#line 3881
    if (t == 268L) {
#line 3881
      goto case_268;
    }
#line 3924
    if (t == 0L) {
#line 3924
      goto case_0;
    }
#line 3928
    goto switch_default;
    case_258: /* CIL Label */ 
    {
#line 3789
    mp = allocmust(mp, (size_t )2);
#line 3790
    mp->begline = (_Bool)1;
#line 3791
    need_begline = (_Bool)1;
    }
#line 3792
    goto switch_break;
    case_259: /* CIL Label */ 
    {
#line 3794
    mp = allocmust(mp, (size_t )2);
#line 3795
    mp->endline = (_Bool)1;
#line 3796
    need_endline = (_Bool)1;
    }
#line 3797
    goto switch_break;
    case_271: /* CIL Label */ 
    case_270: /* CIL Label */ 
    {
#line 3800
    __assert_fail("!\"neither LPAREN nor RPAREN may appear here\"", "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c",
                  3800U, "dfamust");
    }
    case_273: /* CIL Label */ 
    case_272: /* CIL Label */ 
    case_257: /* CIL Label */ 
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
    case_256: /* CIL Label */ 
    {
#line 3810
    mp = allocmust(mp, (size_t )2);
    }
#line 3811
    goto switch_break;
    case_264: /* CIL Label */ 
    case_265: /* CIL Label */ 
    {
#line 3815
    resetmust(mp);
    }
#line 3816
    goto switch_break;
    case_269: /* CIL Label */ 
    {
#line 3821
    rmp = mp;
#line 3822
    mp = mp->prev;
#line 3822
    lmp = mp;
#line 3826
    tmp___1 = streq((char const   *)lmp->is, (char const   *)rmp->is);
    }
#line 3826
    if (tmp___1) {
#line 3828
      lmp->begline = (_Bool )((int )lmp->begline & (int )rmp->begline);
#line 3829
      lmp->endline = (_Bool )((int )lmp->endline & (int )rmp->endline);
    } else {
#line 3833
      *(lmp->is + 0) = (char )'\000';
#line 3834
      lmp->begline = (_Bool)0;
#line 3835
      lmp->endline = (_Bool)0;
    }
#line 3838
    i = (size_t )0;
    {
#line 3839
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3839
      if ((int )*(lmp->left + i) != 0) {
#line 3839
        if (! ((int )*(lmp->left + i) == (int )*(rmp->left + i))) {
#line 3839
          goto while_break___0;
        }
      } else {
#line 3839
        goto while_break___0;
      }
#line 3840
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3841
    *(lmp->left + i) = (char )'\000';
#line 3843
    ln = strlen((char const   *)lmp->right);
#line 3844
    rn = strlen((char const   *)rmp->right);
#line 3845
    n = ln;
    }
#line 3846
    if (n > rn) {
#line 3847
      n = rn;
    }
#line 3848
    i = (size_t )0;
    {
#line 3848
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3848
      if (! (i < n)) {
#line 3848
        goto while_break___1;
      }
#line 3849
      if ((int )*(lmp->right + ((ln - i) - 1UL)) != (int )*(rmp->right + ((rn - i) - 1UL))) {
#line 3850
        goto while_break___1;
      }
#line 3848
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3851
    j = (size_t )0;
    {
#line 3851
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3851
      if (! (j < i)) {
#line 3851
        goto while_break___2;
      }
#line 3852
      *(lmp->right + j) = *(lmp->right + ((ln - i) + j));
#line 3851
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3853
    *(lmp->right + j) = (char )'\000';
#line 3854
    new = inboth(lmp->in, rmp->in);
#line 3855
    freelist(lmp->in);
#line 3856
    free((void *)lmp->in);
#line 3857
    lmp->in = new;
#line 3858
    freemust(rmp);
    }
#line 3860
    goto switch_break;
    case_266: /* CIL Label */ 
#line 3863
    *(mp->is + 0) = (char )'\000';
#line 3864
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 3867
    if (! (! mp->prev)) {
      {
#line 3867
      __assert_fail("!mp->prev", "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c",
                    3867U, "dfamust");
      }
    }
#line 3868
    i___0 = (size_t )0;
    {
#line 3868
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3868
      if (! ((unsigned long )*(mp->in + i___0) != (unsigned long )((void *)0))) {
#line 3868
        goto while_break___3;
      }
      {
#line 3869
      tmp___3 = strlen((char const   *)*(mp->in + i___0));
#line 3869
      tmp___4 = strlen(result);
      }
#line 3869
      if (tmp___3 > tmp___4) {
#line 3870
        result = (char const   *)*(mp->in + i___0);
      }
#line 3868
      i___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 3871
    tmp___5 = streq(result, (char const   *)mp->is);
    }
#line 3871
    if (tmp___5) {
#line 3873
      if (! need_begline) {
#line 3873
        goto _L;
      } else
#line 3873
      if (mp->begline) {
        _L: /* CIL Label */ 
#line 3873
        if (! need_endline) {
#line 3875
          exact = (_Bool)1;
        } else
#line 3873
        if (mp->endline) {
#line 3875
          exact = (_Bool)1;
        }
      }
#line 3876
      begline = mp->begline;
#line 3877
      endline = mp->endline;
    }
#line 3879
    goto done;
    case_268: /* CIL Label */ 
    {
#line 3883
    rmp___0 = mp;
#line 3884
    mp = mp->prev;
#line 3884
    lmp___0 = mp;
#line 3889
    lmp___0->in = addlists(lmp___0->in, rmp___0->in);
    }
#line 3890
    if ((int )*(lmp___0->right + 0) != 0) {
#line 3890
      if ((int )*(rmp___0->left + 0) != 0) {
        {
#line 3892
        tmp___6 = strlen((char const   *)lmp___0->right);
#line 3892
        lrlen = tmp___6;
#line 3893
        tmp___7 = strlen((char const   *)rmp___0->left);
#line 3893
        rllen = tmp___7;
#line 3894
        tmp___8 = xmalloc(lrlen + rllen);
#line 3894
        tp = (char *)tmp___8;
#line 3895
        memcpy((void */* __restrict  */)tp, (void const   */* __restrict  */)lmp___0->right,
               lrlen);
#line 3896
        memcpy((void */* __restrict  */)(tp + lrlen), (void const   */* __restrict  */)rmp___0->left,
               rllen);
#line 3897
        lmp___0->in = enlist(lmp___0->in, tp, lrlen + rllen);
#line 3898
        free((void *)tp);
        }
      }
    }
#line 3901
    if ((int )*(lmp___0->is + 0) != 0) {
      {
#line 3902
      lmp___0->left = icatalloc(lmp___0->left, (char const   *)rmp___0->left);
      }
    }
#line 3904
    if ((int )*(rmp___0->is + 0) == 0) {
#line 3905
      *(lmp___0->right + 0) = (char )'\000';
    }
    {
#line 3906
    lmp___0->right = icatalloc(lmp___0->right, (char const   *)rmp___0->right);
    }
#line 3908
    if ((int )*(lmp___0->is + 0) != 0) {
#line 3908
      goto _L___0;
    } else
#line 3908
    if (lmp___0->begline) {
      _L___0: /* CIL Label */ 
#line 3908
      if ((int )*(rmp___0->is + 0) != 0) {
        {
#line 3911
        lmp___0->is = icatalloc(lmp___0->is, (char const   *)rmp___0->is);
#line 3912
        lmp___0->endline = rmp___0->endline;
        }
      } else
#line 3908
      if (rmp___0->endline) {
        {
#line 3911
        lmp___0->is = icatalloc(lmp___0->is, (char const   *)rmp___0->is);
#line 3912
        lmp___0->endline = rmp___0->endline;
        }
      } else {
#line 3916
        *(lmp___0->is + 0) = (char )'\000';
#line 3917
        lmp___0->begline = (_Bool)0;
#line 3918
        lmp___0->endline = (_Bool)0;
      }
    } else {
#line 3916
      *(lmp___0->is + 0) = (char )'\000';
#line 3917
      lmp___0->begline = (_Bool)0;
#line 3918
      lmp___0->endline = (_Bool)0;
    }
    {
#line 3920
    freemust(rmp___0);
    }
#line 3922
    goto switch_break;
    case_0: /* CIL Label */ 
#line 3926
    goto done;
    switch_default: /* CIL Label */ 
#line 3929
    if (275L <= t) {
#line 3935
      ccl = d->charclasses + (t - 275L);
#line 3937
      j___0 = 0;
      {
#line 3937
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3937
        if (! (j___0 < 256)) {
#line 3937
          goto while_break___4;
        }
        {
#line 3938
        tmp___9 = tstbit((unsigned int )j___0, (charclass const   *)ccl);
        }
#line 3938
        if (tmp___9) {
#line 3939
          goto while_break___4;
        }
#line 3937
        j___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 3940
      if (! (j___0 < 256)) {
        {
#line 3942
        mp = allocmust(mp, (size_t )2);
        }
#line 3943
        goto switch_break;
      }
#line 3945
      t = (token )j___0;
      {
#line 3946
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3946
        j___0 ++;
#line 3946
        if (! (j___0 < 256)) {
#line 3946
          goto while_break___5;
        }
        {
#line 3947
        tmp___10 = tstbit((unsigned int )j___0, (charclass const   *)ccl);
        }
#line 3947
        if (tmp___10) {
#line 3947
          if (case_fold_unibyte) {
            {
#line 3947
            tmp___11 = toupper(j___0);
#line 3947
            tmp___12 = toupper((int )t);
            }
#line 3947
            if (! (tmp___11 == tmp___12)) {
#line 3950
              goto while_break___5;
            }
          } else {
#line 3950
            goto while_break___5;
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 3951
      if (j___0 < 256) {
        {
#line 3953
        mp = allocmust(mp, (size_t )2);
        }
#line 3954
        goto switch_break;
      }
    }
#line 3958
    rj = ri + 2UL;
#line 3959
    if (*(d->tokens + (ri + 1UL)) == 268L) {
      {
#line 3961
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 3961
        if (! (rj < (size_t )(d->tindex - 1UL))) {
#line 3961
          goto while_break___6;
        }
#line 3963
        if (rj != ri) {
#line 3963
          if (*(d->tokens + rj) <= 0L) {
#line 3966
            goto while_break___6;
          } else
#line 3963
          if (256L <= *(d->tokens + rj)) {
#line 3966
            goto while_break___6;
          } else {
#line 3963
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 3963
        if (*(d->tokens + (rj + 1UL)) != 268L) {
#line 3966
          goto while_break___6;
        }
#line 3961
        rj += 2UL;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 3969
    mp = allocmust(mp, ((rj - ri) >> 1) + 1UL);
    }
#line 3970
    if (case_fold_unibyte) {
      {
#line 3970
      tmp___15 = toupper((int )t);
#line 3970
      tmp___14 = (char )tmp___15;
      }
    } else {
#line 3970
      tmp___14 = (char )t;
    }
#line 3970
    *(mp->right + 0) = tmp___14;
#line 3970
    tmp___13 = tmp___14;
#line 3970
    *(mp->left + 0) = tmp___13;
#line 3970
    *(mp->is + 0) = tmp___13;
#line 3974
    i___1 = (size_t )1;
    {
#line 3974
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 3974
      if (! (ri + 2UL < rj)) {
#line 3974
        goto while_break___7;
      }
#line 3976
      ri += 2UL;
#line 3977
      t = *(d->tokens + ri);
#line 3978
      if (case_fold_unibyte) {
        {
#line 3978
        tmp___18 = toupper((int )t);
#line 3978
        tmp___17 = (char )tmp___18;
        }
      } else {
#line 3978
        tmp___17 = (char )t;
      }
#line 3978
      *(mp->right + i___1) = tmp___17;
#line 3978
      tmp___16 = tmp___17;
#line 3978
      *(mp->left + i___1) = tmp___16;
#line 3978
      *(mp->is + i___1) = tmp___16;
#line 3974
      i___1 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 3981
    tmp___20 = (char )'\000';
#line 3981
    *(mp->right + i___1) = tmp___20;
#line 3981
    tmp___19 = tmp___20;
#line 3981
    *(mp->left + i___1) = tmp___19;
#line 3981
    *(mp->is + i___1) = tmp___19;
#line 3982
    mp->in = enlist(mp->in, mp->is, i___1);
    }
#line 3983
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3783
    ri ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 3988
  dm = (struct dfamust *)((void *)0);
#line 3989
  if (*result) {
    {
#line 3991
    tmp___21 = xmalloc(sizeof(*dm));
#line 3991
    dm = (struct dfamust *)tmp___21;
#line 3992
    dm->exact = exact;
#line 3993
    dm->begline = begline;
#line 3994
    dm->endline = endline;
#line 3995
    dm->must = xstrdup(result);
    }
  }
  {
#line 3998
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 3998
    if (! mp) {
#line 3998
      goto while_break___8;
    }
    {
#line 4000
    prev = mp->prev;
#line 4001
    freemust(mp);
#line 4002
    mp = prev;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 4005
  return (dm);
}
}
#line 4008 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
void dfamustfree(struct dfamust *dm ) 
{ 


  {
  {
#line 4011
  free((void *)dm->must);
#line 4012
  free((void *)dm);
  }
#line 4013
  return;
}
}
#line 4015
struct dfa *dfaalloc(void)  __attribute__((__malloc__)) ;
#line 4015 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
struct dfa *dfaalloc(void) 
{ 
  void *tmp ;

  {
  {
#line 4018
  tmp = xmalloc(sizeof(struct dfa ));
  }
#line 4018
  return ((struct dfa *)tmp);
}
}
#line 4022 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
void dfasyntax(struct dfa *dfa , struct localeinfo  const  *linfo , reg_syntax_t bits ,
               int dfaopts ) 
{ 
  int i ;
  unsigned char uc ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 4026
  memset((void *)dfa, 0, (unsigned long )(& ((struct dfa *)0)->dfaexec));
  }
#line 4027
  if (linfo->multibyte) {
#line 4027
    dfa->dfaexec = & dfaexec_mb;
  } else {
#line 4027
    dfa->dfaexec = & dfaexec_sb;
  }
  {
#line 4028
  dfa->simple_locale = using_simple_locale((_Bool )linfo->multibyte);
#line 4029
  dfa->localeinfo = (struct localeinfo )*linfo;
#line 4031
  dfa->fast = (_Bool )(! dfa->localeinfo.multibyte);
#line 4033
  dfa->canychar = (size_t )-1;
#line 4034
  dfa->lex.cur_mb_len = 1;
#line 4035
  dfa->syntax.syntax_bits_set = (_Bool)1;
#line 4036
  dfa->syntax.case_fold = (_Bool )((bits & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) != 0UL);
#line 4037
  dfa->syntax.anchor = (_Bool )((dfaopts & 1) != 0);
  }
#line 4038
  if (dfaopts & 2) {
#line 4038
    dfa->syntax.eolbyte = (unsigned char )'\000';
  } else {
#line 4038
    dfa->syntax.eolbyte = (unsigned char )'\n';
  }
#line 4039
  dfa->syntax.syntax_bits = bits;
#line 4041
  i = -128;
  {
#line 4041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4041
    if (! (i <= 127)) {
#line 4041
      goto while_break;
    }
    {
#line 4043
    uc = (unsigned char )i;
#line 4045
    tmp = char_context((struct dfa  const  *)dfa, uc);
#line 4045
    dfa->syntax.sbit[uc] = (char )tmp;
    }
    {
#line 4048
    if ((int )dfa->syntax.sbit[uc] == 2) {
#line 4048
      goto case_2;
    }
#line 4051
    if ((int )dfa->syntax.sbit[uc] == 4) {
#line 4051
      goto case_4;
    }
#line 4046
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 4049
    setbit((unsigned int )uc, & dfa->syntax.letters);
    }
#line 4050
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 4052
    setbit((unsigned int )uc, & dfa->syntax.newline);
    }
#line 4053
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 4058
    if (dfa->localeinfo.using_utf8) {
#line 4058
      dfa->syntax.never_trail[uc] = (_Bool )(((int )uc & 192) != 128);
    } else {
      {
#line 4058
      tmp___0 = strchr("\n\r./", (int )uc);
#line 4058
      dfa->syntax.never_trail[uc] = (_Bool )((unsigned long )tmp___0 != (unsigned long )((void *)0));
      }
    }
#line 4041
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4062
  return;
}
}
#line 36 "/home/khheo/project/benchmark/grep-3.1/lib/cycle-check.c"
static _Bool is_zero_or_power_of_two(uintmax_t i ) 
{ 


  {
#line 39
  return ((_Bool )((i & (i - 1UL)) == 0UL));
}
}
#line 42 "/home/khheo/project/benchmark/grep-3.1/lib/cycle-check.c"
void cycle_check_init(struct cycle_check_state *state ) 
{ 


  {
#line 45
  state->chdir_counter = (uintmax_t )0;
#line 46
  state->magic = 9827862;
#line 47
  return;
}
}
#line 57 "/home/khheo/project/benchmark/grep-3.1/lib/cycle-check.c"
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) 
{ 
  _Bool tmp___0 ;

  {
#line 60
  if (! (state->magic == 9827862)) {
    {
#line 60
    __assert_fail("state->magic == 9827862", "/home/khheo/project/benchmark/grep-3.1/lib/cycle-check.c",
                  60U, "cycle_check");
    }
  }
#line 65
  if (state->chdir_counter) {
#line 65
    if (sb->st_ino == (__ino_t const   )state->dev_ino.st_ino) {
#line 65
      if (sb->st_dev == (__dev_t const   )state->dev_ino.st_dev) {
#line 66
        return ((_Bool)1);
      }
    }
  }
  {
#line 70
  (state->chdir_counter) ++;
#line 70
  tmp___0 = is_zero_or_power_of_two(state->chdir_counter);
  }
#line 70
  if (tmp___0) {
#line 77
    if (state->chdir_counter == 0UL) {
#line 78
      return ((_Bool)1);
    }
#line 80
    state->dev_ino.st_dev = (dev_t )sb->st_dev;
#line 81
    state->dev_ino.st_ino = (ino_t )sb->st_ino;
  }
#line 84
  return ((_Bool)0);
}
}
#line 23 "/home/khheo/project/benchmark/grep-3.1/lib/fcntl-safer.h"
int creat_safer(char const   *file , mode_t mode ) ;
#line 203 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 27 "/home/khheo/project/benchmark/grep-3.1/lib/creat-safer.c"
int creat_safer(char const   *file , mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 30
  tmp = creat(file, mode);
#line 30
  tmp___0 = fd_safer(tmp);
  }
#line 30
  return (tmp___0);
}
}
#line 22 "./colorize-posix.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 19 "./colorize.h"
int should_colorize(void) ;
#line 20
void init_colorize(void) ;
#line 21
void print_start_colorize(char const   *sgr_start___0 , char const   *sgr_seq ) ;
#line 22
void print_end_colorize(char const   *sgr_end___0 ) ;
#line 626 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 36 "./colorize-posix.c"
int should_colorize(void) 
{ 
  char const   *t ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 39
  tmp = getenv("TERM");
#line 39
  t = (char const   *)tmp;
  }
#line 40
  if (t) {
    {
#line 40
    tmp___0 = strcmp(t, "dumb");
    }
#line 40
    if (tmp___0 != 0) {
#line 40
      tmp___1 = 1;
    } else {
#line 40
      tmp___1 = 0;
    }
  } else {
#line 40
    tmp___1 = 0;
  }
#line 40
  return (tmp___1);
}
}
#line 43 "./colorize-posix.c"
void init_colorize(void) 
{ 


  {
#line 43
  return;
}
}
#line 47 "./colorize-posix.c"
void print_start_colorize(char const   *sgr_start___0 , char const   *sgr_seq ) 
{ 


  {
  {
#line 50
  printf((char const   */* __restrict  */)sgr_start___0, sgr_seq);
  }
#line 51
  return;
}
}
#line 54 "./colorize-posix.c"
void print_end_colorize(char const   *sgr_end___0 ) 
{ 


  {
  {
#line 57
  fputs((char const   */* __restrict  */)sgr_end___0, (FILE */* __restrict  */)stdout);
  }
#line 58
  return;
}
}
#line 28 "/home/khheo/project/benchmark/grep-3.1/lib/closeout.h"
void close_stdout_set_file_name(char const   *file ) ;
#line 29
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
#line 30
void close_stdout(void) ;
#line 606 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 2 "/home/khheo/project/benchmark/grep-3.1/lib/close-stream.h"
int close_stream(FILE *stream ) ;
#line 46 "/home/khheo/project/benchmark/grep-3.1/lib/closeout.c"
static char const   *file_name  ;
#line 50 "/home/khheo/project/benchmark/grep-3.1/lib/closeout.c"
void close_stdout_set_file_name(char const   *file ) 
{ 


  {
#line 53
  file_name = file;
#line 54
  return;
}
}
#line 56 "/home/khheo/project/benchmark/grep-3.1/lib/closeout.c"
static _Bool ignore_EPIPE  ;
#line 87 "/home/khheo/project/benchmark/grep-3.1/lib/closeout.c"
void close_stdout_set_ignore_EPIPE(_Bool ignore ) 
{ 


  {
#line 90
  ignore_EPIPE = ignore;
#line 91
  return;
}
}
#line 116 "/home/khheo/project/benchmark/grep-3.1/lib/closeout.c"
void close_stdout(void) 
{ 
  char const   *write_error ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 119
  tmp___3 = close_stream(stdout);
  }
#line 119
  if (tmp___3 != 0) {
#line 119
    if (ignore_EPIPE) {
      {
#line 119
      tmp___4 = __errno_location();
      }
#line 119
      if (! (*tmp___4 == 32)) {
#line 119
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 122
      tmp = gettext("write error");
#line 122
      write_error = (char const   *)tmp;
      }
#line 123
      if (file_name) {
        {
#line 124
        tmp___0 = quotearg_colon(file_name);
#line 124
        tmp___1 = __errno_location();
#line 124
        error(0, *tmp___1, "%s: %s", tmp___0, write_error);
        }
      } else {
        {
#line 127
        tmp___2 = __errno_location();
#line 127
        error(0, *tmp___2, "%s", write_error);
        }
      }
      {
#line 129
      _exit((int )exit_failure);
      }
    }
  }
  {
#line 134
  tmp___5 = close_stream(stderr);
  }
#line 134
  if (tmp___5 != 0) {
    {
#line 135
    _exit((int )exit_failure);
    }
  }
#line 136
  return;
}
}
#line 75 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __fpending)(FILE *__fp ) ;
#line 55 "/home/khheo/project/benchmark/grep-3.1/lib/close-stream.c"
int close_stream(FILE *stream ) 
{ 
  _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 58
  tmp = __fpending(stream);
#line 58
  some_pending = (_Bool )(tmp != 0UL);
#line 59
  tmp___0 = ferror_unlocked(stream);
#line 59
  prev_fail = (_Bool )(tmp___0 != 0);
#line 60
  tmp___1 = fclose(stream);
#line 60
  fclose_fail = (_Bool )(tmp___1 != 0);
  }
#line 70
  if (prev_fail) {
#line 70
    goto _L___0;
  } else
#line 70
  if (fclose_fail) {
#line 70
    if (some_pending) {
#line 70
      goto _L___0;
    } else {
      {
#line 70
      tmp___3 = __errno_location();
      }
#line 70
      if (*tmp___3 != 9) {
        _L___0: /* CIL Label */ 
#line 72
        if (! fclose_fail) {
          {
#line 73
          tmp___2 = __errno_location();
#line 73
          *tmp___2 = 0;
          }
        }
#line 74
        return (-1);
      }
    }
  }
#line 77
  return (0);
}
}
#line 38 "/home/khheo/project/benchmark/grep-3.1/lib/cloexec.h"
int dup_cloexec(int fd ) ;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 38 "/home/khheo/project/benchmark/grep-3.1/lib/cloexec.c"
int set_cloexec_flag(int desc , _Bool value ) 
{ 
  int flags ;
  int tmp ;
  int newflags ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 43
  tmp = rpl_fcntl(desc, 1, 0);
#line 43
  flags = tmp;
  }
#line 45
  if (0 <= flags) {
#line 47
    if (value) {
#line 47
      tmp___0 = flags | 1;
    } else {
#line 47
      tmp___0 = flags & -2;
    }
#line 47
    newflags = tmp___0;
#line 49
    if (flags == newflags) {
#line 51
      return (0);
    } else {
      {
#line 49
      tmp___1 = rpl_fcntl(desc, 2, newflags);
      }
#line 49
      if (tmp___1 != -1) {
#line 51
        return (0);
      }
    }
  }
#line 54
  return (-1);
}
}
#line 79 "/home/khheo/project/benchmark/grep-3.1/lib/cloexec.c"
int dup_cloexec(int fd ) 
{ 
  int tmp ;

  {
  {
#line 82
  tmp = rpl_fcntl(fd, 1030, 0);
  }
#line 82
  return (tmp);
}
}
#line 500 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 114 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                                                int __c ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 276
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 46 "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c"
static void cdb_init(struct cd_buf *cdb ) 
{ 


  {
#line 49
  cdb->fd = -100;
#line 50
  return;
}
}
#line 52 "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c"
static int cdb_fchdir(struct cd_buf  const  *cdb ) 
{ 
  int tmp ;

  {
  {
#line 55
  tmp = fchdir((int )cdb->fd);
  }
#line 55
  return (tmp);
}
}
#line 58 "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c"
static void cdb_free(struct cd_buf  const  *cdb ) 
{ 
  _Bool close_fail ;
  int tmp ;

  {
#line 61
  if (0 <= (int )cdb->fd) {
    {
#line 63
    tmp = close((int )cdb->fd);
#line 63
    close_fail = (_Bool )tmp;
    }
#line 64
    if (! (! close_fail)) {
      {
#line 64
      __assert_fail("! close_fail", "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c",
                    64U, "cdb_free");
      }
    }
  }
#line 66
  return;
}
}
#line 72 "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c"
static int cdb_advance_fd(struct cd_buf *cdb , char const   *dir ) 
{ 
  int new_fd ;
  int tmp ;

  {
  {
#line 75
  tmp = openat(cdb->fd, dir, 67840);
#line 75
  new_fd = tmp;
  }
#line 77
  if (new_fd < 0) {
#line 78
    return (-1);
  }
  {
#line 80
  cdb_free((struct cd_buf  const  *)cdb);
#line 81
  cdb->fd = new_fd;
  }
#line 83
  return (0);
}
}
#line 87 "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c"
static char * __attribute__((__pure__)) find_non_slash(char const   *s ) 
{ 
  size_t n_slash ;
  size_t tmp ;

  {
  {
#line 90
  tmp = strspn(s, "/");
#line 90
  n_slash = tmp;
  }
#line 91
  return ((char */* __attribute__((__pure__)) */)((char *)s + n_slash));
}
}
#line 109 "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c"
int chdir_long(char *dir ) 
{ 
  int e ;
  int tmp ;
  int *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  char *dir_end ;
  struct cd_buf cdb ;
  size_t n_leading_slash ;
  int err ;
  char *slash ;
  void *tmp___4 ;
  int *tmp___5 ;
  char * __attribute__((__pure__)) tmp___6 ;
  int tmp___7 ;
  int err___0 ;
  char *slash___0 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char * __attribute__((__pure__)) tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int saved_errno ;
  int *tmp___16 ;
  int *tmp___17 ;

  {
  {
#line 112
  tmp = chdir((char const   *)dir);
#line 112
  e = tmp;
  }
#line 113
  if (e == 0) {
#line 114
    return (e);
  } else {
    {
#line 113
    tmp___0 = __errno_location();
    }
#line 113
    if (*tmp___0 != 36) {
#line 114
      return (e);
    }
  }
  {
#line 117
  tmp___1 = strlen((char const   *)dir);
#line 117
  len = tmp___1;
#line 118
  dir_end = dir + len;
#line 122
  cdb_init(& cdb);
  }
#line 126
  if (! (0UL < len)) {
    {
#line 126
    __assert_fail("0 < len", "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c",
                  126U, "chdir_long");
    }
  }
#line 127
  if (! (4096UL <= len)) {
    {
#line 127
    __assert_fail("4096 <= len", "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c",
                  127U, "chdir_long");
    }
  }
  {
#line 130
  n_leading_slash = strspn((char const   *)dir, "/");
  }
#line 137
  if (n_leading_slash == 2UL) {
    {
#line 142
    tmp___4 = memchr((void const   *)(dir + 3), '/', (size_t )(dir_end - (dir + 3)));
#line 142
    slash = (char *)tmp___4;
    }
#line 143
    if ((unsigned long )slash == (unsigned long )((void *)0)) {
      {
#line 145
      tmp___5 = __errno_location();
#line 145
      *tmp___5 = 36;
      }
#line 146
      return (-1);
    }
    {
#line 148
    *slash = (char )'\000';
#line 149
    err = cdb_advance_fd(& cdb, (char const   *)dir);
#line 150
    *slash = (char )'/';
    }
#line 151
    if (err != 0) {
#line 152
      goto Fail;
    }
    {
#line 153
    tmp___6 = find_non_slash((char const   *)(slash + 1));
#line 153
    dir = (char *)tmp___6;
    }
  } else
#line 155
  if (n_leading_slash) {
    {
#line 157
    tmp___7 = cdb_advance_fd(& cdb, "/");
    }
#line 157
    if (tmp___7 != 0) {
#line 158
      goto Fail;
    }
#line 159
    dir += n_leading_slash;
  }
#line 162
  if (! ((int )*dir != 47)) {
    {
#line 162
    __assert_fail("*dir != \'/\'", "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c",
                  162U, "chdir_long");
    }
  }
#line 163
  if (! ((unsigned long )dir <= (unsigned long )dir_end)) {
    {
#line 163
    __assert_fail("dir <= dir_end", "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c",
                  163U, "chdir_long");
    }
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (4096L <= dir_end - dir)) {
#line 165
      goto while_break;
    }
    {
#line 171
    tmp___10 = memrchr((void const   *)dir, '/', (size_t )4096);
#line 171
    slash___0 = (char *)tmp___10;
    }
#line 172
    if ((unsigned long )slash___0 == (unsigned long )((void *)0)) {
      {
#line 174
      tmp___11 = __errno_location();
#line 174
      *tmp___11 = 36;
      }
#line 175
      return (-1);
    }
#line 178
    *slash___0 = (char )'\000';
#line 179
    if (! (slash___0 - dir < 4096L)) {
      {
#line 179
      __assert_fail("slash - dir < 4096", "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c",
                    179U, "chdir_long");
      }
    }
    {
#line 180
    err___0 = cdb_advance_fd(& cdb, (char const   *)dir);
#line 181
    *slash___0 = (char )'/';
    }
#line 182
    if (err___0 != 0) {
#line 183
      goto Fail;
    }
    {
#line 185
    tmp___13 = find_non_slash((char const   *)(slash___0 + 1));
#line 185
    dir = (char *)tmp___13;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if ((unsigned long )dir < (unsigned long )dir_end) {
    {
#line 190
    tmp___14 = cdb_advance_fd(& cdb, (char const   *)dir);
    }
#line 190
    if (tmp___14 != 0) {
#line 191
      goto Fail;
    }
  }
  {
#line 194
  tmp___15 = cdb_fchdir((struct cd_buf  const  *)(& cdb));
  }
#line 194
  if (tmp___15 != 0) {
#line 195
    goto Fail;
  }
  {
#line 197
  cdb_free((struct cd_buf  const  *)(& cdb));
  }
#line 198
  return (0);
  Fail: 
  {
#line 202
  tmp___16 = __errno_location();
#line 202
  saved_errno = *tmp___16;
#line 203
  cdb_free((struct cd_buf  const  *)(& cdb));
#line 204
  tmp___17 = __errno_location();
#line 204
  *tmp___17 = saved_errno;
  }
#line 205
  return (-1);
}
}
#line 47 "/home/khheo/project/benchmark/grep-3.1/lib/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 26 "/home/khheo/project/benchmark/grep-3.1/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/grep-3.1/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  } else
#line 33
  if (n == 0UL) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
#line 41
    n --;
    }
#line 41
    if (n == 0UL) {
#line 42
      goto while_break;
    } else
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 26 "/home/khheo/project/benchmark/grep-3.1/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/grep-3.1/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
    }
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 134
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 81
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/basename-lgpl.c"
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = (_Bool)0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int const   )*base == 47)) {
#line 36
      goto while_break;
    }
#line 37
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  p = base;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! *p) {
#line 39
      goto while_break___0;
    }
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return ((char *)base);
}
}
#line 57
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 57 "/home/khheo/project/benchmark/grep-3.1/lib/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (1UL < len) {
#line 63
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 64
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 63
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (len);
}
}
#line 46 "/home/khheo/project/benchmark/grep-3.1/lib/argmatch.h"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize )  __attribute__((__pure__)) ;
#line 56
void (*argmatch_die)(void) ;
#line 60
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) ;
#line 72
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 83
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
#line 98
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize )  __attribute__((__pure__)) ;
#line 545 "/usr/include/stdio.h"
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 58 "/home/khheo/project/benchmark/grep-3.1/lib/argmatch.c"
void usage(int status ) ;
#line 61 "/home/khheo/project/benchmark/grep-3.1/lib/argmatch.c"
static void __argmatch_die(void) 
{ 


  {
  {
#line 64
  usage(1);
  }
#line 65
  return;
}
}
#line 69 "/home/khheo/project/benchmark/grep-3.1/lib/argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 83
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize )  __attribute__((__pure__)) ;
#line 83 "/home/khheo/project/benchmark/grep-3.1/lib/argmatch.c"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ 
  size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 89
  matchind = (ptrdiff_t )-1;
#line 90
  ambiguous = (_Bool)0;
#line 92
  arglen = strlen(arg);
#line 95
  i = (size_t )0;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! *(arglist + i)) {
#line 95
      goto while_break;
    }
    {
#line 97
    tmp___1 = strncmp((char const   *)*(arglist + i), arg, arglen);
    }
#line 97
    if (! tmp___1) {
      {
#line 99
      tmp___0 = strlen((char const   *)*(arglist + i));
      }
#line 99
      if (tmp___0 == arglen) {
#line 101
        return ((ptrdiff_t )i);
      } else
#line 102
      if (matchind == -1L) {
#line 104
        matchind = (ptrdiff_t )i;
      } else
#line 108
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 114
        ambiguous = (_Bool)1;
      } else {
        {
#line 108
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * i),
                     valsize);
        }
#line 108
        if (tmp) {
#line 114
          ambiguous = (_Bool)1;
        }
      }
    }
#line 95
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  if (ambiguous) {
#line 120
    return ((ptrdiff_t )-2);
  } else {
#line 122
    return (matchind);
  }
}
}
#line 130 "/home/khheo/project/benchmark/grep-3.1/lib/argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) 
{ 
  char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 133
  if (problem == -1L) {
    {
#line 133
    tmp = gettext("invalid argument %s for %s");
#line 133
    tmp___1 = tmp;
    }
  } else {
    {
#line 133
    tmp___0 = gettext("ambiguous argument %s for %s");
#line 133
    tmp___1 = tmp___0;
    }
  }
  {
#line 133
  format = (char const   *)tmp___1;
#line 137
  tmp___2 = quote_n(1, context);
#line 137
  tmp___3 = quotearg_n_style(0, (enum quoting_style )8, value);
#line 137
  error(0, 0, format, tmp___3, tmp___2);
  }
#line 139
  return;
}
}
#line 145 "/home/khheo/project/benchmark/grep-3.1/lib/argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  char const   *last_val ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 150
  last_val = (char const   *)((void *)0);
#line 154
  tmp = gettext("Valid arguments are:");
#line 154
  fputs_unlocked((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
#line 155
  i = (size_t )0;
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! *(arglist + i)) {
#line 155
      goto while_break;
    }
#line 156
    if (i == 0UL) {
      {
#line 159
      tmp___0 = quote((char const   *)*(arglist + i));
#line 159
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - %s",
              tmp___0);
#line 160
      last_val = vallist + valsize * i;
      }
    } else {
      {
#line 156
      tmp___2 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                       valsize);
      }
#line 156
      if (tmp___2) {
        {
#line 159
        tmp___0 = quote((char const   *)*(arglist + i));
#line 159
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - %s",
                tmp___0);
#line 160
        last_val = vallist + valsize * i;
        }
      } else {
        {
#line 164
        tmp___1 = quote((char const   *)*(arglist + i));
#line 164
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", %s",
                tmp___1);
        }
      }
    }
#line 155
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 166
  putc_unlocked('\n', stderr);
  }
#line 167
  return;
}
}
#line 175 "/home/khheo/project/benchmark/grep-3.1/lib/argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) 
{ 
  ptrdiff_t res ;
  ptrdiff_t tmp ;

  {
  {
#line 181
  tmp = argmatch(arg, arglist, vallist, valsize);
#line 181
  res = tmp;
  }
#line 182
  if (res >= 0L) {
#line 184
    return (res);
  }
  {
#line 187
  argmatch_invalid(context, arg, res);
#line 188
  argmatch_valid(arglist, vallist, valsize);
#line 189
  (*exit_fn)();
  }
#line 191
  return ((ptrdiff_t )-1);
}
}
#line 196
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize )  __attribute__((__pure__)) ;
#line 196 "/home/khheo/project/benchmark/grep-3.1/lib/argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 203
  i = (size_t )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! *(arglist + i)) {
#line 203
      goto while_break;
    }
    {
#line 204
    tmp = memcmp((void const   *)value, (void const   *)(vallist + valsize * i), valsize);
    }
#line 204
    if (! tmp) {
#line 205
      return ((char const   *)*(arglist + i));
    }
#line 203
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return ((char const   *)((void *)0));
}
}
#line 59 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
static strtol_error bkm_scale___2(unsigned long *x , int scale_factor ) 
{ 


  {
#line 67
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 69
    *x = 0xffffffffffffffffUL;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (unsigned long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___2(unsigned long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___2(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 59 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
static strtol_error bkm_scale___3(long *x , int scale_factor ) 
{ 


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___3(long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___3(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 46 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol-error.c"
static void xstrtol_error___0(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                              char const   *arg , int exit_status ) 
{ 
  char const   *hyphens ;
  char const   *msgid ;
  char const   *option ;
  char option_buffer[2] ;
  char *tmp ;

  {
#line 52
  hyphens = "--";
  {
#line 62
  if ((unsigned int )err == 4U) {
#line 62
    goto case_4;
  }
#line 67
  if ((unsigned int )err == 3U) {
#line 67
    goto case_3;
  }
#line 67
  if ((unsigned int )err == 2U) {
#line 67
    goto case_3;
  }
#line 71
  if ((unsigned int )err == 1U) {
#line 71
    goto case_1;
  }
#line 59
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 60
  abort();
  }
  case_4: /* CIL Label */ 
#line 63
  msgid = "invalid %s%s argument \'%s\'";
#line 64
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 68
  msgid = "invalid suffix in %s%s argument \'%s\'";
#line 69
  goto switch_break;
  case_1: /* CIL Label */ 
#line 72
  msgid = "%s%s argument \'%s\' too large";
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    option = (char const   *)(option_buffer);
  } else {
#line 84
    option = (char const   *)(long_options___0 + opt_idx)->name;
  }
  {
#line 86
  tmp = gettext(msgid);
#line 86
  error(exit_status, 0, (char const   *)tmp, hyphens, option, arg);
  }
#line 87
  return;
}
}
#line 59 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
static strtol_error bkm_scale___4(intmax_t *x , int scale_factor ) 
{ 


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (intmax_t )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-3.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___4(intmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___4(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 29
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 81
#pragma GCC diagnostic pop
#line 25 "/home/khheo/project/benchmark/grep-3.1/lib/xbinary-io.h"
#pragma GCC diagnostic push
#line 25
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 25
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 46
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 20 "/home/khheo/project/benchmark/grep-3.1/lib/uniwidth/cjk.h"
static int is_cjk_encoding___0(char const   *encoding ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 23
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 23
  if (tmp == 0) {
#line 35
    return (1);
  } else {
    {
#line 23
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 23
    if (tmp___0 == 0) {
#line 35
      return (1);
    } else {
      {
#line 23
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 23
      if (tmp___1 == 0) {
#line 35
        return (1);
      } else {
        {
#line 23
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 23
        if (tmp___2 == 0) {
#line 35
          return (1);
        } else {
          {
#line 23
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 23
          if (tmp___3 == 0) {
#line 35
            return (1);
          } else {
            {
#line 23
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 23
            if (tmp___4 == 0) {
#line 35
              return (1);
            } else {
              {
#line 23
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 23
              if (tmp___5 == 0) {
#line 35
                return (1);
              } else {
                {
#line 23
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 23
                if (tmp___6 == 0) {
#line 35
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 36
  return (0);
}
}
#line 35 "/home/khheo/project/benchmark/grep-3.1/lib/uniwidth/width.c"
static unsigned char const   nonspacing_table_data___0[2304]  = 
#line 35 "/home/khheo/project/benchmark/grep-3.1/lib/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )23, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )191, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )251, 
        (unsigned char const   )239,      (unsigned char const   )62,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )20, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )254,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )224,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )9, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,      (unsigned char const   )127, 
        (unsigned char const   )229,      (unsigned char const   )31,      (unsigned char const   )248,      (unsigned char const   )159, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )60,      (unsigned char const   )59,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )64,      (unsigned char const   )163,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )247,      (unsigned char const   )255, 
        (unsigned char const   )253,      (unsigned char const   )33,      (unsigned char const   )16,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )63,      (unsigned char const   )240, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )223,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )247,      (unsigned char const   )63, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )157,      (unsigned char const   )193, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )38, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )239,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )8,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )211,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )248,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )31,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )133, 
        (unsigned char const   )13,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )176, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )167, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )40,      (unsigned char const   )191,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )188,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )127,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )96, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )248,      (unsigned char const   )255, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )127,      (unsigned char const   )248, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )31,      (unsigned char const   )32,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248, 
        (unsigned char const   )254,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )127,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 361 "/home/khheo/project/benchmark/grep-3.1/lib/uniwidth/width.c"
static signed char const   nonspacing_table_ind___0[248]  = 
#line 361
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21, 
        (signed char const   )22,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )24,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )29,      (signed char const   )-1,      (signed char const   )30, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )31,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )32,      (signed char const   )33,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )34,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )35,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 599 "/home/khheo/project/benchmark/grep-3.1/lib/unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-3.1/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 223
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 599
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 24 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 116 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static struct quoting_options default_quoting_options___0  ;
#line 192 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static struct quoting_options quoting_options_from_style___0(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  unsigned int tmp ;

  {
#line 195
  o.style = (enum quoting_style )0;
#line 195
  o.flags = 0;
#line 195
  o.quote_these_too[0] = 0U;
#line 195
  tmp = 1U;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (tmp >= 8U) {
#line 195
      goto while_break;
    }
#line 195
    o.quote_these_too[tmp] = 0U;
#line 195
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  o.left_quote = (char const   *)((void *)0);
#line 195
  o.right_quote = (char const   *)((void *)0);
#line 196
  if ((unsigned int )style == 10U) {
    {
#line 197
    abort();
    }
  }
#line 198
  o.style = style;
#line 199
  return (o);
}
}
#line 206 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static char const   *gettext_quote___0(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 209
  tmp = gettext(msgid);
#line 209
  translation = (char const   *)tmp;
  }
#line 212
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 213
    return (translation);
  }
  {
#line 233
  locale_code = locale_charset();
#line 234
  tmp___1 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 234
  if (tmp___1 == 0) {
#line 235
    if ((int const   )*(msgid + 0) == 96) {
#line 235
      tmp___0 = "\342\200\230";
    } else {
#line 235
      tmp___0 = "\342\200\231";
    }
#line 235
    return (tmp___0);
  }
  {
#line 236
  tmp___3 = c_strcasecmp(locale_code, "GB18030");
  }
#line 236
  if (tmp___3 == 0) {
#line 237
    if ((int const   )*(msgid + 0) == 96) {
#line 237
      tmp___2 = "\241\ae";
    } else {
#line 237
      tmp___2 = "\241\257";
    }
#line 237
    return (tmp___2);
  }
#line 239
  if ((unsigned int )s == 9U) {
#line 239
    tmp___4 = "\"";
  } else {
#line 239
    tmp___4 = "\'";
  }
#line 239
  return (tmp___4);
}
}
#line 255 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static size_t quotearg_buffer_restyled___0(char *buffer___0 , size_t buffersize ,
                                           char const   *arg , size_t argsize , enum quoting_style quoting_style ,
                                           int flags , unsigned int const   *quote_these_too ,
                                           char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  size_t orig_buffersize ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  _Bool pending_shell_escape_end ;
  _Bool encountered_single_quote ;
  _Bool all_c_and_shell_quote_compat ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  _Bool escaping ;
  _Bool c_and_shell_quote_compat ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___3 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___4 ;
  size_t j ;
  int tmp___5 ;
  int tmp___6 ;
  size_t ilim ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 264
  len = (size_t )0;
#line 265
  orig_buffersize = (size_t )0;
#line 266
  quote_string = (char const   *)0;
#line 267
  quote_string_len = (size_t )0;
#line 268
  backslash_escapes = (_Bool)0;
#line 269
  tmp = __ctype_get_mb_cur_max();
#line 269
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 270
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
#line 271
  pending_shell_escape_end = (_Bool)0;
#line 272
  encountered_single_quote = (_Bool)0;
#line 273
  all_c_and_shell_quote_compat = (_Bool)1;
  }
  process_input: 
  {
#line 318
  if ((unsigned int )quoting_style == 6U) {
#line 318
    goto case_6;
  }
#line 322
  if ((unsigned int )quoting_style == 5U) {
#line 322
    goto case_5;
  }
#line 330
  if ((unsigned int )quoting_style == 7U) {
#line 330
    goto case_7;
  }
#line 337
  if ((unsigned int )quoting_style == 10U) {
#line 337
    goto case_10;
  }
#line 337
  if ((unsigned int )quoting_style == 9U) {
#line 337
    goto case_10;
  }
#line 337
  if ((unsigned int )quoting_style == 8U) {
#line 337
    goto case_10;
  }
#line 374
  if ((unsigned int )quoting_style == 3U) {
#line 374
    goto case_3;
  }
#line 377
  if ((unsigned int )quoting_style == 1U) {
#line 377
    goto case_1;
  }
#line 380
  if ((unsigned int )quoting_style == 4U) {
#line 380
    goto case_4;
  }
#line 384
  if ((unsigned int )quoting_style == 2U) {
#line 384
    goto case_2;
  }
#line 392
  if ((unsigned int )quoting_style == 0U) {
#line 392
    goto case_0;
  }
#line 396
  goto switch_default;
  case_6: /* CIL Label */ 
#line 319
  quoting_style = (enum quoting_style )5;
#line 320
  elide_outer_quotes = (_Bool)1;
  case_5: /* CIL Label */ 
#line 323
  if (! elide_outer_quotes) {
    {
#line 324
    while (1) {
      while_continue: /* CIL Label */ ;
#line 324
      if (len < buffersize) {
#line 324
        *(buffer___0 + len) = (char )'\"';
      }
#line 324
      len ++;
#line 324
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 325
  backslash_escapes = (_Bool)1;
#line 326
  quote_string = "\"";
#line 327
  quote_string_len = (size_t )1;
#line 328
  goto switch_break;
  case_7: /* CIL Label */ 
#line 331
  backslash_escapes = (_Bool)1;
#line 332
  elide_outer_quotes = (_Bool)0;
#line 333
  goto switch_break;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 339
  if ((unsigned int )quoting_style != 10U) {
    {
#line 362
    left_quote = gettext_quote___0("`", quoting_style);
#line 363
    right_quote = gettext_quote___0("\'", quoting_style);
    }
  }
#line 365
  if (! elide_outer_quotes) {
#line 366
    quote_string = left_quote;
    {
#line 366
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 366
      if (! *quote_string) {
#line 366
        goto while_break___0;
      }
      {
#line 367
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 367
        if (len < buffersize) {
#line 367
          *(buffer___0 + len) = (char )*quote_string;
        }
#line 367
        len ++;
#line 367
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 366
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 368
  backslash_escapes = (_Bool)1;
#line 369
  quote_string = right_quote;
#line 370
  quote_string_len = strlen(quote_string);
  }
#line 372
  goto switch_break;
  case_3: /* CIL Label */ 
#line 375
  backslash_escapes = (_Bool)1;
  case_1: /* CIL Label */ 
#line 378
  elide_outer_quotes = (_Bool)1;
  case_4: /* CIL Label */ 
#line 381
  if (! elide_outer_quotes) {
#line 382
    backslash_escapes = (_Bool)1;
  }
  case_2: /* CIL Label */ 
#line 385
  quoting_style = (enum quoting_style )2;
#line 386
  if (! elide_outer_quotes) {
    {
#line 387
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 387
      if (len < buffersize) {
#line 387
        *(buffer___0 + len) = (char )'\'';
      }
#line 387
      len ++;
#line 387
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 388
  quote_string = "\'";
#line 389
  quote_string_len = (size_t )1;
#line 390
  goto switch_break;
  case_0: /* CIL Label */ 
#line 393
  elide_outer_quotes = (_Bool)0;
#line 394
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 397
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 400
  i = (size_t )0;
  {
#line 400
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 400
    if (argsize == 0xffffffffffffffffUL) {
#line 400
      tmp___7 = (int const   )*(arg + i) == 0;
    } else {
#line 400
      tmp___7 = i == argsize;
    }
#line 400
    if (tmp___7) {
#line 400
      goto while_break___3;
    }
#line 404
    is_right_quote = (_Bool)0;
#line 405
    escaping = (_Bool)0;
#line 406
    c_and_shell_quote_compat = (_Bool)0;
#line 408
    if (backslash_escapes) {
#line 408
      if ((unsigned int )quoting_style != 2U) {
#line 408
        if (quote_string_len) {
#line 408
          if (argsize == 0xffffffffffffffffUL) {
#line 408
            if (1UL < quote_string_len) {
              {
#line 408
              argsize = strlen(arg);
#line 408
              tmp___0 = argsize;
              }
            } else {
#line 408
              tmp___0 = argsize;
            }
          } else {
#line 408
            tmp___0 = argsize;
          }
#line 408
          if (i + quote_string_len <= tmp___0) {
            {
#line 408
            tmp___1 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                             quote_string_len);
            }
#line 408
            if (tmp___1 == 0) {
#line 419
              if (elide_outer_quotes) {
#line 420
                goto force_outer_quoting_style;
              }
#line 421
              is_right_quote = (_Bool)1;
            }
          }
        }
      }
    }
#line 424
    c = (unsigned char )*(arg + i);
    {
#line 427
    if ((int )c == 0) {
#line 427
      goto case_0___0;
    }
#line 453
    if ((int )c == 63) {
#line 453
      goto case_63;
    }
#line 491
    if ((int )c == 7) {
#line 491
      goto case_7___0;
    }
#line 492
    if ((int )c == 8) {
#line 492
      goto case_8___0;
    }
#line 493
    if ((int )c == 12) {
#line 493
      goto case_12;
    }
#line 494
    if ((int )c == 10) {
#line 494
      goto case_10___0;
    }
#line 495
    if ((int )c == 13) {
#line 495
      goto case_13;
    }
#line 496
    if ((int )c == 9) {
#line 496
      goto case_9___0;
    }
#line 497
    if ((int )c == 11) {
#line 497
      goto case_11;
    }
#line 498
    if ((int )c == 92) {
#line 498
      goto case_92;
    }
#line 525
    if ((int )c == 125) {
#line 525
      goto case_125;
    }
#line 525
    if ((int )c == 123) {
#line 525
      goto case_125;
    }
#line 529
    if ((int )c == 126) {
#line 529
      goto case_126;
    }
#line 529
    if ((int )c == 35) {
#line 529
      goto case_126;
    }
#line 533
    if ((int )c == 32) {
#line 533
      goto case_32;
    }
#line 543
    if ((int )c == 124) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 96) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 94) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 91) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 62) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 61) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 60) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 59) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 42) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 41) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 40) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 38) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 36) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 34) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 33) {
#line 543
      goto case_124;
    }
#line 553
    if ((int )c == 39) {
#line 553
      goto case_39___0;
    }
#line 588
    if ((int )c == 122) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 121) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 120) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 119) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 118) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 117) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 116) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 115) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 114) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 113) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 112) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 111) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 110) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 109) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 108) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 107) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 106) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 105) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 104) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 103) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 102) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 101) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 100) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 99) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 98) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 97) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 95) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 93) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 90) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 89) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 88) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 87) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 86) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 85) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 84) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 83) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 82) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 81) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 80) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 79) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 78) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 77) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 76) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 75) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 74) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 73) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 72) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 71) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 70) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 69) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 68) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 67) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 66) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 65) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 58) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 57) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 56) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 55) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 54) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 53) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 52) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 51) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 50) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 49) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 48) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 47) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 46) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 45) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 44) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 43) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 37) {
#line 588
      goto case_122;
    }
#line 602
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 428
    if (backslash_escapes) {
      {
#line 430
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 430
        if (elide_outer_quotes) {
#line 430
          goto force_outer_quoting_style;
        }
#line 430
        escaping = (_Bool)1;
#line 430
        if ((unsigned int )quoting_style == 2U) {
#line 430
          if (! pending_shell_escape_end) {
            {
#line 430
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 430
              if (len < buffersize) {
#line 430
                *(buffer___0 + len) = (char )'\'';
              }
#line 430
              len ++;
#line 430
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 430
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 430
              if (len < buffersize) {
#line 430
                *(buffer___0 + len) = (char )'$';
              }
#line 430
              len ++;
#line 430
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 430
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 430
              if (len < buffersize) {
#line 430
                *(buffer___0 + len) = (char )'\'';
              }
#line 430
              len ++;
#line 430
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 430
            pending_shell_escape_end = (_Bool)1;
          }
        }
        {
#line 430
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 430
          if (len < buffersize) {
#line 430
            *(buffer___0 + len) = (char )'\\';
          }
#line 430
          len ++;
#line 430
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 430
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 437
      if ((unsigned int )quoting_style != 2U) {
#line 437
        if (i + 1UL < argsize) {
#line 437
          if (48 <= (int )*(arg + (i + 1UL))) {
#line 437
            if ((int const   )*(arg + (i + 1UL)) <= 57) {
              {
#line 440
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 440
                if (len < buffersize) {
#line 440
                  *(buffer___0 + len) = (char )'0';
                }
#line 440
                len ++;
#line 440
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
              {
#line 441
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 441
                if (len < buffersize) {
#line 441
                  *(buffer___0 + len) = (char )'0';
                }
#line 441
                len ++;
#line 441
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        }
      }
#line 443
      c = (unsigned char )'0';
    } else
#line 449
    if (flags & 1) {
#line 450
      goto __Cont;
    }
#line 451
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 456
    if ((unsigned int )quoting_style == 2U) {
#line 456
      goto case_2___0;
    }
#line 461
    if ((unsigned int )quoting_style == 5U) {
#line 461
      goto case_5___0;
    }
#line 486
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 457
    if (elide_outer_quotes) {
#line 458
      goto force_outer_quoting_style;
    }
#line 459
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 462
    if (flags & 4) {
#line 462
      if (i + 2UL < argsize) {
#line 462
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 468
            goto case_62;
          }
#line 481
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 471
          if (elide_outer_quotes) {
#line 472
            goto force_outer_quoting_style;
          }
#line 473
          c = (unsigned char )*(arg + (i + 2UL));
#line 474
          i += 2UL;
          {
#line 475
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 475
            if (len < buffersize) {
#line 475
              *(buffer___0 + len) = (char )'?';
            }
#line 475
            len ++;
#line 475
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 476
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 476
            if (len < buffersize) {
#line 476
              *(buffer___0 + len) = (char )'\"';
            }
#line 476
            len ++;
#line 476
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 477
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 477
            if (len < buffersize) {
#line 477
              *(buffer___0 + len) = (char )'\"';
            }
#line 477
            len ++;
#line 477
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
          {
#line 478
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 478
            if (len < buffersize) {
#line 478
              *(buffer___0 + len) = (char )'?';
            }
#line 478
            len ++;
#line 478
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 479
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 482
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 484
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 487
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 489
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 491
    esc = (unsigned char )'a';
#line 491
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 492
    esc = (unsigned char )'b';
#line 492
    goto c_escape;
    case_12: /* CIL Label */ 
#line 493
    esc = (unsigned char )'f';
#line 493
    goto c_escape;
    case_10___0: /* CIL Label */ 
#line 494
    esc = (unsigned char )'n';
#line 494
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 495
    esc = (unsigned char )'r';
#line 495
    goto c_and_shell_escape;
    case_9___0: /* CIL Label */ 
#line 496
    esc = (unsigned char )'t';
#line 496
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 497
    esc = (unsigned char )'v';
#line 497
    goto c_escape;
    case_92: /* CIL Label */ 
#line 498
    esc = c;
#line 500
    if ((unsigned int )quoting_style == 2U) {
#line 502
      if (elide_outer_quotes) {
#line 503
        goto force_outer_quoting_style;
      }
#line 504
      goto store_c;
    }
#line 509
    if (backslash_escapes) {
#line 509
      if (elide_outer_quotes) {
#line 509
        if (quote_string_len) {
#line 510
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 513
    if ((unsigned int )quoting_style == 2U) {
#line 513
      if (elide_outer_quotes) {
#line 515
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 518
    if (backslash_escapes) {
#line 520
      c = esc;
#line 521
      goto store_escape;
    }
#line 523
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 526
    if (argsize == 0xffffffffffffffffUL) {
#line 526
      tmp___2 = (int const   )*(arg + 1) == 0;
    } else {
#line 526
      tmp___2 = argsize == 1UL;
    }
#line 526
    if (! tmp___2) {
#line 527
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 530
    if (i != 0UL) {
#line 531
      goto switch_break___0;
    }
    case_32: /* CIL Label */ 
#line 534
    c_and_shell_quote_compat = (_Bool)1;
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
#line 548
    if ((unsigned int )quoting_style == 2U) {
#line 548
      if (elide_outer_quotes) {
#line 550
        goto force_outer_quoting_style;
      }
    }
#line 551
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 554
    encountered_single_quote = (_Bool)1;
#line 555
    c_and_shell_quote_compat = (_Bool)1;
#line 556
    if ((unsigned int )quoting_style == 2U) {
#line 558
      if (elide_outer_quotes) {
#line 559
        goto force_outer_quoting_style;
      }
#line 561
      if (buffersize) {
#line 561
        if (! orig_buffersize) {
#line 566
          orig_buffersize = buffersize;
#line 567
          buffersize = (size_t )0;
        }
      }
      {
#line 570
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 570
        if (len < buffersize) {
#line 570
          *(buffer___0 + len) = (char )'\'';
        }
#line 570
        len ++;
#line 570
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 571
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 571
        if (len < buffersize) {
#line 571
          *(buffer___0 + len) = (char )'\\';
        }
#line 571
        len ++;
#line 571
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 572
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 572
        if (len < buffersize) {
#line 572
          *(buffer___0 + len) = (char )'\'';
        }
#line 572
        len ++;
#line 572
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 573
      pending_shell_escape_end = (_Bool)0;
    }
#line 575
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 599
    c_and_shell_quote_compat = (_Bool)1;
#line 600
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 614
    if (unibyte_locale) {
      {
#line 616
      m = (size_t )1;
#line 617
      tmp___3 = __ctype_b_loc();
#line 617
      printable = (_Bool )(((int const   )*(*tmp___3 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 622
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 624
      m = (size_t )0;
#line 625
      printable = (_Bool)1;
      }
#line 626
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 627
        argsize = strlen(arg);
        }
      }
      {
#line 629
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 632
        tmp___4 = rpl_mbrtowc(& w, arg + (i + m), argsize - (i + m), & mbstate);
#line 632
        bytes = tmp___4;
        }
#line 634
        if (bytes == 0UL) {
#line 635
          goto while_break___18;
        } else
#line 636
        if (bytes == 0xffffffffffffffffUL) {
#line 638
          printable = (_Bool)0;
#line 639
          goto while_break___18;
        } else
#line 641
        if (bytes == 0xfffffffffffffffeUL) {
#line 643
          printable = (_Bool)0;
          {
#line 644
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 644
            if (i + m < argsize) {
#line 644
              if (! *(arg + (i + m))) {
#line 644
                goto while_break___19;
              }
            } else {
#line 644
              goto while_break___19;
            }
#line 645
            m ++;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 646
          goto while_break___18;
        } else {
#line 654
          if (elide_outer_quotes) {
#line 654
            if ((unsigned int )quoting_style == 2U) {
#line 658
              j = (size_t )1;
              {
#line 658
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 658
                if (! (j < bytes)) {
#line 658
                  goto while_break___20;
                }
                {
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 662
                  goto case_124___0;
                }
#line 665
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 663
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 666
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 658
                j ++;
              }
              while_break___20: /* CIL Label */ ;
              }
            }
          }
          {
#line 670
          tmp___5 = iswprint((wint_t )w);
          }
#line 670
          if (! tmp___5) {
#line 671
            printable = (_Bool)0;
          }
#line 672
          m += bytes;
        }
        {
#line 629
        tmp___6 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 629
        if (tmp___6) {
#line 629
          goto while_break___18;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
    }
#line 678
    c_and_shell_quote_compat = printable;
#line 680
    if (1UL < m) {
#line 680
      goto _L___0;
    } else
#line 680
    if (backslash_escapes) {
#line 680
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 684
        ilim = i + m;
        {
#line 686
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 688
          if (backslash_escapes) {
#line 688
            if (! printable) {
              {
#line 690
              while (1) {
                while_continue___22: /* CIL Label */ ;
#line 690
                if (elide_outer_quotes) {
#line 690
                  goto force_outer_quoting_style;
                }
#line 690
                escaping = (_Bool)1;
#line 690
                if ((unsigned int )quoting_style == 2U) {
#line 690
                  if (! pending_shell_escape_end) {
                    {
#line 690
                    while (1) {
                      while_continue___23: /* CIL Label */ ;
#line 690
                      if (len < buffersize) {
#line 690
                        *(buffer___0 + len) = (char )'\'';
                      }
#line 690
                      len ++;
#line 690
                      goto while_break___23;
                    }
                    while_break___23: /* CIL Label */ ;
                    }
                    {
#line 690
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 690
                      if (len < buffersize) {
#line 690
                        *(buffer___0 + len) = (char )'$';
                      }
#line 690
                      len ++;
#line 690
                      goto while_break___24;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                    {
#line 690
                    while (1) {
                      while_continue___25: /* CIL Label */ ;
#line 690
                      if (len < buffersize) {
#line 690
                        *(buffer___0 + len) = (char )'\'';
                      }
#line 690
                      len ++;
#line 690
                      goto while_break___25;
                    }
                    while_break___25: /* CIL Label */ ;
                    }
#line 690
                    pending_shell_escape_end = (_Bool)1;
                  }
                }
                {
#line 690
                while (1) {
                  while_continue___26: /* CIL Label */ ;
#line 690
                  if (len < buffersize) {
#line 690
                    *(buffer___0 + len) = (char )'\\';
                  }
#line 690
                  len ++;
#line 690
                  goto while_break___26;
                }
                while_break___26: /* CIL Label */ ;
                }
#line 690
                goto while_break___22;
              }
              while_break___22: /* CIL Label */ ;
              }
              {
#line 691
              while (1) {
                while_continue___27: /* CIL Label */ ;
#line 691
                if (len < buffersize) {
#line 691
                  *(buffer___0 + len) = (char )(48 + ((int )c >> 6));
                }
#line 691
                len ++;
#line 691
                goto while_break___27;
              }
              while_break___27: /* CIL Label */ ;
              }
              {
#line 692
              while (1) {
                while_continue___28: /* CIL Label */ ;
#line 692
                if (len < buffersize) {
#line 692
                  *(buffer___0 + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 692
                len ++;
#line 692
                goto while_break___28;
              }
              while_break___28: /* CIL Label */ ;
              }
#line 693
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 688
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 695
          if (is_right_quote) {
            {
#line 697
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 697
              if (len < buffersize) {
#line 697
                *(buffer___0 + len) = (char )'\\';
              }
#line 697
              len ++;
#line 697
              goto while_break___29;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 698
            is_right_quote = (_Bool)0;
          }
#line 700
          if (ilim <= i + 1UL) {
#line 701
            goto while_break___21;
          }
          {
#line 702
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 702
            if (pending_shell_escape_end) {
#line 702
              if (! escaping) {
                {
#line 702
                while (1) {
                  while_continue___31: /* CIL Label */ ;
#line 702
                  if (len < buffersize) {
#line 702
                    *(buffer___0 + len) = (char )'\'';
                  }
#line 702
                  len ++;
#line 702
                  goto while_break___31;
                }
                while_break___31: /* CIL Label */ ;
                }
                {
#line 702
                while (1) {
                  while_continue___32: /* CIL Label */ ;
#line 702
                  if (len < buffersize) {
#line 702
                    *(buffer___0 + len) = (char )'\'';
                  }
#line 702
                  len ++;
#line 702
                  goto while_break___32;
                }
                while_break___32: /* CIL Label */ ;
                }
#line 702
                pending_shell_escape_end = (_Bool)0;
              }
            }
#line 702
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
          {
#line 703
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 703
            if (len < buffersize) {
#line 703
              *(buffer___0 + len) = (char )c;
            }
#line 703
            len ++;
#line 703
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
#line 704
          i ++;
#line 704
          c = (unsigned char )*(arg + i);
        }
        while_break___21: /* CIL Label */ ;
        }
#line 707
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 712
    if (backslash_escapes) {
#line 712
      if ((unsigned int )quoting_style != 2U) {
#line 712
        goto _L___3;
      } else {
#line 712
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 712
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 712
      if (quote_these_too) {
#line 712
        if (! ((*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) >> (unsigned long )c % (sizeof(int ) * 8UL)) & 1U)) {
#line 712
          goto _L___2;
        }
      } else {
#line 712
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 712
    if (! is_right_quote) {
#line 717
      goto store_c;
    }
    store_escape: 
    {
#line 720
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 720
      if (elide_outer_quotes) {
#line 720
        goto force_outer_quoting_style;
      }
#line 720
      escaping = (_Bool)1;
#line 720
      if ((unsigned int )quoting_style == 2U) {
#line 720
        if (! pending_shell_escape_end) {
          {
#line 720
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 720
            if (len < buffersize) {
#line 720
              *(buffer___0 + len) = (char )'\'';
            }
#line 720
            len ++;
#line 720
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
          {
#line 720
          while (1) {
            while_continue___36: /* CIL Label */ ;
#line 720
            if (len < buffersize) {
#line 720
              *(buffer___0 + len) = (char )'$';
            }
#line 720
            len ++;
#line 720
            goto while_break___36;
          }
          while_break___36: /* CIL Label */ ;
          }
          {
#line 720
          while (1) {
            while_continue___37: /* CIL Label */ ;
#line 720
            if (len < buffersize) {
#line 720
              *(buffer___0 + len) = (char )'\'';
            }
#line 720
            len ++;
#line 720
            goto while_break___37;
          }
          while_break___37: /* CIL Label */ ;
          }
#line 720
          pending_shell_escape_end = (_Bool)1;
        }
      }
      {
#line 720
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 720
        if (len < buffersize) {
#line 720
          *(buffer___0 + len) = (char )'\\';
        }
#line 720
        len ++;
#line 720
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 720
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    store_c: 
    {
#line 723
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 723
      if (pending_shell_escape_end) {
#line 723
        if (! escaping) {
          {
#line 723
          while (1) {
            while_continue___40: /* CIL Label */ ;
#line 723
            if (len < buffersize) {
#line 723
              *(buffer___0 + len) = (char )'\'';
            }
#line 723
            len ++;
#line 723
            goto while_break___40;
          }
          while_break___40: /* CIL Label */ ;
          }
          {
#line 723
          while (1) {
            while_continue___41: /* CIL Label */ ;
#line 723
            if (len < buffersize) {
#line 723
              *(buffer___0 + len) = (char )'\'';
            }
#line 723
            len ++;
#line 723
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
#line 723
          pending_shell_escape_end = (_Bool)0;
        }
      }
#line 723
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 724
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 724
      if (len < buffersize) {
#line 724
        *(buffer___0 + len) = (char )c;
      }
#line 724
      len ++;
#line 724
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
#line 726
    if (! c_and_shell_quote_compat) {
#line 727
      all_c_and_shell_quote_compat = (_Bool)0;
    }
    __Cont: /* CIL Label */ 
#line 400
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 730
  if (len == 0UL) {
#line 730
    if ((unsigned int )quoting_style == 2U) {
#line 730
      if (elide_outer_quotes) {
#line 732
        goto force_outer_quoting_style;
      }
    }
  }
#line 738
  if ((unsigned int )quoting_style == 2U) {
#line 738
    if (! elide_outer_quotes) {
#line 738
      if (encountered_single_quote) {
#line 741
        if (all_c_and_shell_quote_compat) {
          {
#line 742
          tmp___8 = quotearg_buffer_restyled___0(buffer___0, orig_buffersize, arg,
                                                 argsize, (enum quoting_style )5,
                                                 flags, quote_these_too, left_quote,
                                                 right_quote);
          }
#line 742
          return (tmp___8);
        } else
#line 746
        if (! buffersize) {
#line 746
          if (orig_buffersize) {
#line 749
            buffersize = orig_buffersize;
#line 750
            len = (size_t )0;
#line 751
            goto process_input;
          }
        }
      }
    }
  }
#line 755
  if (quote_string) {
#line 755
    if (! elide_outer_quotes) {
      {
#line 756
      while (1) {
        while_continue___43: /* CIL Label */ ;
#line 756
        if (! *quote_string) {
#line 756
          goto while_break___43;
        }
        {
#line 757
        while (1) {
          while_continue___44: /* CIL Label */ ;
#line 757
          if (len < buffersize) {
#line 757
            *(buffer___0 + len) = (char )*quote_string;
          }
#line 757
          len ++;
#line 757
          goto while_break___44;
        }
        while_break___44: /* CIL Label */ ;
        }
#line 756
        quote_string ++;
      }
      while_break___43: /* CIL Label */ ;
      }
    }
  }
#line 759
  if (len < buffersize) {
#line 760
    *(buffer___0 + len) = (char )'\000';
  }
#line 761
  return (len);
  force_outer_quoting_style: 
#line 766
  if ((unsigned int )quoting_style == 2U) {
#line 766
    if (backslash_escapes) {
#line 767
      quoting_style = (enum quoting_style )4;
    }
  }
  {
#line 768
  tmp___9 = quotearg_buffer_restyled___0(buffer___0, buffersize, arg, argsize, quoting_style,
                                         flags & -3, (unsigned int const   *)((void *)0),
                                         left_quote, right_quote);
  }
#line 768
  return (tmp___9);
}
}
#line 842 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static char slot0___0[256]  ;
#line 843 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static int nslots___0  =    1;
#line 844 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static struct slotvec slotvec0___0  =    {sizeof(slot0___0), slot0___0};
#line 845 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static struct slotvec *slotvec___0  =    & slotvec0___0;
#line 876 "/home/khheo/project/benchmark/grep-3.1/lib/quotearg.c"
static char *quotearg_n_options___0(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  struct slotvec *sv ;
  _Bool preallocated ;
  unsigned long tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 880
  tmp = __errno_location();
#line 880
  e = *tmp;
#line 882
  sv = slotvec___0;
  }
#line 884
  if (n < 0) {
    {
#line 885
    abort();
    }
  }
#line 887
  if (nslots___0 <= n) {
#line 889
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0___0));
#line 891
    if (2147483647UL < 9223372036854775807UL / sizeof(*sv)) {
#line 891
      tmp___0 = 2147483647UL;
    } else {
#line 891
      tmp___0 = 9223372036854775807UL / sizeof(*sv);
    }
#line 891
    if (tmp___0 <= (unsigned long )n) {
      {
#line 892
      xalloc_die();
      }
    }
#line 894
    if (preallocated) {
#line 894
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 894
      tmp___1 = sv;
    }
    {
#line 894
    tmp___2 = xrealloc((void *)tmp___1, (unsigned long )(n + 1) * sizeof(*sv));
#line 894
    sv = (struct slotvec *)tmp___2;
#line 894
    slotvec___0 = sv;
    }
#line 895
    if (preallocated) {
#line 896
      *sv = slotvec0___0;
    }
    {
#line 897
    memset((void *)(sv + nslots___0), 0, (unsigned long )((n + 1) - nslots___0) * sizeof(*sv));
#line 898
    nslots___0 = n + 1;
    }
  }
  {
#line 902
  size = (sv + n)->size;
#line 903
  val = (sv + n)->val;
#line 905
  flags = (int )(options->flags | 1);
#line 906
  tmp___3 = quotearg_buffer_restyled___0(val, size, arg, argsize, (enum quoting_style )options->style,
                                         flags, (unsigned int const   *)(options->quote_these_too),
                                         (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 906
  qsize = tmp___3;
  }
#line 912
  if (size <= qsize) {
#line 914
    size = qsize + 1UL;
#line 914
    (sv + n)->size = size;
#line 915
    if ((unsigned long )val != (unsigned long )(slot0___0)) {
      {
#line 916
      free((void *)val);
      }
    }
    {
#line 917
    val = xcharalloc(size);
#line 917
    (sv + n)->val = val;
#line 918
    quotearg_buffer_restyled___0(val, size, arg, argsize, (enum quoting_style )options->style,
                                 flags, (unsigned int const   *)(options->quote_these_too),
                                 (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 924
  tmp___4 = __errno_location();
#line 924
  *tmp___4 = e;
  }
#line 925
  return (val);
}
}
#line 21 "/home/khheo/project/benchmark/grep-3.1/lib/propername.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 54 "/home/khheo/project/benchmark/grep-3.1/lib/propername.c"
static _Bool mbsstr_trimmed_wordbounded___0(char const   *string , char const   *sub ) 
{ 
  char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 57
  tmp = trim2(sub, 2);
#line 57
  tsub = tmp;
#line 58
  found = (_Bool)0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((int const   )*string != 0)) {
#line 60
      goto while_break;
    }
    {
#line 62
    tmp___0 = mbsstr(string, (char const   *)tsub);
#line 62
    tsub_in_string = (char const   *)tmp___0;
    }
#line 63
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
#line 64
      goto while_break;
    } else {
      {
#line 67
      tmp___11 = __ctype_get_mb_cur_max();
      }
#line 67
      if (tmp___11 > 1UL) {
        {
#line 73
        string_iter.cur.ptr = string;
#line 73
        string_iter.in_shift = (_Bool)0;
#line 73
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 73
        string_iter.next_done = (_Bool)0;
#line 74
        word_boundary_before = (_Bool)1;
        }
#line 75
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
          {
#line 78
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 80
            mbuiter_multi_next(& string_iter);
            }
#line 80
            if (string_iter.cur.wc_valid) {
#line 80
              if (string_iter.cur.wc == 0) {
#line 80
                tmp___1 = 0;
              } else {
#line 80
                tmp___1 = 1;
              }
            } else {
#line 80
              tmp___1 = 1;
            }
#line 80
            if (! tmp___1) {
              {
#line 81
              abort();
              }
            }
#line 82
            last_char_before_tsub = string_iter.cur;
#line 83
            string_iter.cur.ptr += string_iter.cur.bytes;
#line 83
            string_iter.next_done = (_Bool)0;
#line 78
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
#line 78
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 86
          if (last_char_before_tsub.wc_valid) {
            {
#line 86
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
            }
#line 86
            if (tmp___2) {
#line 87
              word_boundary_before = (_Bool)0;
            }
          }
        }
        {
#line 90
        string_iter.cur.ptr = tsub_in_string;
#line 90
        string_iter.in_shift = (_Bool)0;
#line 90
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 90
        string_iter.next_done = (_Bool)0;
#line 94
        tsub_iter.cur.ptr = (char const   *)tsub;
#line 94
        tsub_iter.in_shift = (_Bool)0;
#line 94
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
#line 94
        tsub_iter.next_done = (_Bool)0;
        }
        {
#line 94
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 94
          mbuiter_multi_next(& tsub_iter);
          }
#line 94
          if (tsub_iter.cur.wc_valid) {
#line 94
            if (tsub_iter.cur.wc == 0) {
#line 94
              tmp___4 = 0;
            } else {
#line 94
              tmp___4 = 1;
            }
          } else {
#line 94
            tmp___4 = 1;
          }
#line 94
          if (! tmp___4) {
#line 94
            goto while_break___1;
          }
          {
#line 98
          mbuiter_multi_next(& string_iter);
          }
#line 98
          if (string_iter.cur.wc_valid) {
#line 98
            if (string_iter.cur.wc == 0) {
#line 98
              tmp___3 = 0;
            } else {
#line 98
              tmp___3 = 1;
            }
          } else {
#line 98
            tmp___3 = 1;
          }
#line 98
          if (! tmp___3) {
            {
#line 99
            abort();
            }
          }
#line 100
          string_iter.cur.ptr += string_iter.cur.bytes;
#line 100
          string_iter.next_done = (_Bool)0;
#line 94
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
#line 94
          tsub_iter.next_done = (_Bool)0;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 103
        word_boundary_after = (_Bool)1;
#line 104
        mbuiter_multi_next(& string_iter);
        }
#line 104
        if (string_iter.cur.wc_valid) {
#line 104
          if (string_iter.cur.wc == 0) {
#line 104
            tmp___6 = 0;
          } else {
#line 104
            tmp___6 = 1;
          }
        } else {
#line 104
          tmp___6 = 1;
        }
#line 104
        if (tmp___6) {
#line 106
          first_char_after_tsub = string_iter.cur;
#line 107
          if (first_char_after_tsub.wc_valid) {
            {
#line 107
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
            }
#line 107
            if (tmp___5) {
#line 108
              word_boundary_after = (_Bool)0;
            }
          }
        }
#line 111
        if (word_boundary_before) {
#line 111
          if (word_boundary_after) {
#line 113
            found = (_Bool)1;
#line 114
            goto while_break;
          }
        }
        {
#line 117
        string_iter.cur.ptr = tsub_in_string;
#line 117
        string_iter.in_shift = (_Bool)0;
#line 117
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 117
        string_iter.next_done = (_Bool)0;
#line 118
        mbuiter_multi_next(& string_iter);
        }
#line 118
        if (string_iter.cur.wc_valid) {
#line 118
          if (string_iter.cur.wc == 0) {
#line 118
            tmp___7 = 0;
          } else {
#line 118
            tmp___7 = 1;
          }
        } else {
#line 118
          tmp___7 = 1;
        }
#line 118
        if (! tmp___7) {
#line 119
          goto while_break;
        }
#line 120
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
#line 128
        word_boundary_before___0 = (_Bool)1;
#line 129
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
          {
#line 130
          tmp___8 = __ctype_b_loc();
          }
#line 130
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
#line 131
            word_boundary_before___0 = (_Bool)0;
          }
        }
        {
#line 133
        tmp___9 = strlen((char const   *)tsub);
#line 133
        p = tsub_in_string + tmp___9;
#line 134
        word_boundary_after___0 = (_Bool)1;
        }
#line 135
        if ((int const   )*p != 0) {
          {
#line 136
          tmp___10 = __ctype_b_loc();
          }
#line 136
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
#line 137
            word_boundary_after___0 = (_Bool)0;
          }
        }
#line 139
        if (word_boundary_before___0) {
#line 139
          if (word_boundary_after___0) {
#line 141
            found = (_Bool)1;
#line 142
            goto while_break;
          }
        }
#line 145
        if ((int const   )*tsub_in_string == 0) {
#line 146
          goto while_break;
        }
#line 147
        string = tsub_in_string + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  free((void *)tsub);
  }
#line 152
  return (found);
}
}
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 599
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 599
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 65 "/home/khheo/project/benchmark/grep-3.1/lib/openat-proc.c"
static int proc_status___0  =    0;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-3.1/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 83 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
static void *call_chunkfun___0(struct obstack *h , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 86
  if (h->use_extra_arg) {
    {
#line 87
    tmp = (*(h->chunkfun.extra))(h->extra_arg, size);
    }
#line 87
    return (tmp);
  } else {
    {
#line 89
    tmp___0 = (*(h->chunkfun.plain))(size);
    }
#line 89
    return (tmp___0);
  }
}
}
#line 92 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
static void call_freefun___0(struct obstack *h , void *old_chunk ) 
{ 


  {
#line 95
  if (h->use_extra_arg) {
    {
#line 96
    (*(h->freefun.extra))(h->extra_arg, old_chunk);
    }
  } else {
    {
#line 98
    (*(h->freefun.plain))(old_chunk);
    }
  }
#line 99
  return;
}
}
#line 108 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
static int _obstack_begin_worker___0(struct obstack *h , size_t size , size_t alignment ) 
{ 
  struct _obstack_chunk *chunk ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int extra ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  struct _obstack_chunk *tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;

  {
#line 114
  if (alignment == 0UL) {
#line 115
    if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
      tmp___1 = __alignof__(uintmax_t );
    } else {
#line 115
      tmp___1 = __alignof__(void *);
    }
#line 115
    if (__alignof__(long double ) > tmp___1) {
#line 115
      alignment = __alignof__(long double );
    } else {
#line 115
      if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
        tmp___0 = __alignof__(uintmax_t );
      } else {
#line 115
        tmp___0 = __alignof__(void *);
      }
#line 115
      alignment = tmp___0;
    }
  }
#line 116
  if (size == 0UL) {
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___5 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___5 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___5) {
#line 127
      tmp___4 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___3 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___3 = sizeof(void *);
      }
#line 127
      tmp___4 = tmp___3;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___9 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___9 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___9) {
#line 127
      tmp___8 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___7 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___7 = sizeof(void *);
      }
#line 127
      tmp___8 = tmp___7;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___13 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___13 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___13) {
#line 127
      tmp___12 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___11 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___11 = sizeof(void *);
      }
#line 127
      tmp___12 = tmp___11;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___17 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___17 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___17) {
#line 127
      tmp___16 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___15 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___15 = sizeof(void *);
      }
#line 127
      tmp___16 = tmp___15;
    }
#line 127
    extra = (int )(((((((12UL + tmp___4) - 1UL) & ~ (tmp___8 - 1UL)) + 4UL) + tmp___12) - 1UL) & ~ (tmp___16 - 1UL));
#line 130
    size = (size_t )(4096 - extra);
  }
  {
#line 133
  h->chunk_size = size;
#line 134
  h->alignment_mask = alignment - 1UL;
#line 136
  tmp___19 = call_chunkfun___0(h, h->chunk_size);
#line 136
  tmp___18 = (struct _obstack_chunk *)tmp___19;
#line 136
  h->chunk = tmp___18;
#line 136
  chunk = tmp___18;
  }
#line 137
  if (! chunk) {
    {
#line 138
    (*obstack_alloc_failed_handler)();
    }
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___21 = (char *)chunk;
  } else {
#line 139
    tmp___21 = (char *)0;
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___22 = (char *)chunk;
  } else {
#line 139
    tmp___22 = (char *)0;
  }
#line 139
  tmp___20 = tmp___21 + (((size_t )(chunk->contents - tmp___22) + (alignment - 1UL)) & ~ (alignment - 1UL));
#line 139
  h->object_base = tmp___20;
#line 139
  h->next_free = tmp___20;
#line 141
  tmp___23 = (char *)chunk + h->chunk_size;
#line 141
  chunk->limit = tmp___23;
#line 141
  h->chunk_limit = tmp___23;
#line 142
  chunk->prev = (struct _obstack_chunk *)0;
#line 144
  h->maybe_empty_object = 0U;
#line 145
  h->alloc_failed = 0U;
#line 146
  return (1);
}
}
#line 329 "/home/khheo/project/benchmark/grep-3.1/lib/obstack.c"
static void print_and_abort___0(void) 
{ 
  char *tmp ;

  {
  {
#line 340
  tmp = gettext("memory exhausted");
#line 340
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          tmp);
#line 342
  exit((int )exit_failure);
  }
}
}
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 34 "/home/khheo/project/benchmark/grep-3.1/lib/str-kmp.h"
static _Bool knuth_morris_pratt___0(unsigned char const   *haystack , unsigned char const   *needle ,
                                    size_t needle_len , unsigned char const   **resultp ) 
{ 
  size_t m ;
  size_t *table ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  unsigned char const   *rhaystack ;
  unsigned char const   *phaystack ;

  {
#line 39
  m = needle_len;
#line 42
  if (9223372036854775807UL / sizeof(size_t ) < m) {
#line 42
    tmp___2 = (void *)0;
  } else {
#line 42
    if (m * sizeof(size_t ) < 4016UL) {
      {
#line 42
      tmp = __builtin_alloca(m * sizeof(size_t ) + 16UL);
#line 42
      tmp___1 = (void *)((char *)tmp + 16);
      }
    } else {
      {
#line 42
      tmp___0 = mmalloca(m * sizeof(size_t ));
#line 42
      tmp___1 = tmp___0;
      }
    }
#line 42
    tmp___2 = tmp___1;
  }
#line 42
  table = (size_t *)tmp___2;
#line 43
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 44
    return ((_Bool)0);
  }
#line 64
  *(table + 1) = (size_t )1;
#line 65
  j = (size_t )0;
#line 67
  i = (size_t )2;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < m)) {
#line 67
      goto while_break;
    }
#line 73
    b = (unsigned char )*(needle + (i - 1UL));
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if ((int )b == (int )*(needle + j)) {
#line 83
        j ++;
#line 83
        *(table + i) = i - j;
#line 84
        goto while_break___0;
      }
#line 89
      if (j == 0UL) {
#line 92
        *(table + i) = i;
#line 93
        goto while_break___0;
      }
#line 106
      j -= *(table + j);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  *resultp = (unsigned char const   *)((void *)0);
#line 119
  j___0 = (size_t )0;
#line 120
  rhaystack = haystack;
#line 121
  phaystack = haystack;
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (! ((int const   )*phaystack != 0)) {
#line 123
      goto while_break___1;
    }
#line 124
    if ((int const   )*(needle + j___0) == (int const   )*phaystack) {
#line 126
      j___0 ++;
#line 127
      phaystack ++;
#line 128
      if (j___0 == m) {
#line 131
        *resultp = rhaystack;
#line 132
        goto while_break___1;
      }
    } else
#line 135
    if (j___0 > 0UL) {
#line 138
      rhaystack += *(table + j___0);
#line 139
      j___0 -= *(table + j___0);
    } else {
#line 144
      rhaystack ++;
#line 145
      phaystack ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 149
  freea((void *)table);
  }
#line 150
  return ((_Bool)1);
}
}
#line 39 "/home/khheo/project/benchmark/grep-3.1/lib/mbsstr.c"
static _Bool knuth_morris_pratt_multibyte___0(char const   *haystack , char const   *needle ,
                                              char const   **resultp ) 
{ 
  size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table ;
  void *memory ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *table_memory ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___4 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 43
  tmp = mbslen(needle);
#line 43
  m = tmp;
  }
#line 48
  if (9223372036854775807UL / (sizeof(mbchar_t ) + sizeof(size_t )) < m) {
#line 48
    tmp___3 = (void *)0;
  } else {
#line 48
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
      {
#line 48
      tmp___0 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
#line 48
      tmp___2 = (void *)((char *)tmp___0 + 16);
      }
    } else {
      {
#line 48
      tmp___1 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
#line 48
      tmp___2 = tmp___1;
      }
    }
#line 48
    tmp___3 = tmp___2;
  }
#line 48
  memory = tmp___3;
#line 50
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 51
    return ((_Bool)0);
  }
  {
#line 52
  needle_mbchars = (mbchar_t *)memory;
#line 53
  table_memory = (void *)(needle_mbchars + m);
#line 54
  table = (size_t *)table_memory;
#line 61
  j = (size_t )0;
#line 62
  iter.cur.ptr = needle;
#line 62
  iter.in_shift = (_Bool)0;
#line 62
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 62
  iter.next_done = (_Bool)0;
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 62
    mbuiter_multi_next(& iter);
    }
#line 62
    if (iter.cur.wc_valid) {
#line 62
      if (iter.cur.wc == 0) {
#line 62
        tmp___4 = 0;
      } else {
#line 62
        tmp___4 = 1;
      }
    } else {
#line 62
      tmp___4 = 1;
    }
#line 62
    if (! tmp___4) {
#line 62
      goto while_break;
    }
    {
#line 63
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
#line 62
    iter.cur.ptr += iter.cur.bytes;
#line 62
    iter.next_done = (_Bool)0;
#line 62
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  *(table + 1) = (size_t )1;
#line 86
  j___0 = (size_t )0;
#line 88
  i = (size_t )2;
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! (i < m)) {
#line 88
      goto while_break___0;
    }
#line 94
    b = needle_mbchars + (i - 1UL);
    {
#line 96
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 101
      if (b->wc_valid) {
#line 101
        if ((needle_mbchars + j___0)->wc_valid) {
#line 101
          tmp___7 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
#line 101
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 101
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
          {
#line 101
          tmp___5 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
          }
#line 101
          if (tmp___5 == 0) {
#line 101
            tmp___6 = 1;
          } else {
#line 101
            tmp___6 = 0;
          }
        } else {
#line 101
          tmp___6 = 0;
        }
#line 101
        tmp___7 = tmp___6;
      }
#line 101
      if (tmp___7) {
#line 104
        j___0 ++;
#line 104
        *(table + i) = i - j___0;
#line 105
        goto while_break___1;
      }
#line 110
      if (j___0 == 0UL) {
#line 113
        *(table + i) = i;
#line 114
        goto while_break___1;
      }
#line 127
      j___0 -= *(table + j___0);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 88
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  *resultp = (char const   *)((void *)0);
#line 140
  j___1 = (size_t )0;
#line 141
  rhaystack.cur.ptr = haystack;
#line 141
  rhaystack.in_shift = (_Bool)0;
#line 141
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
#line 141
  rhaystack.next_done = (_Bool)0;
#line 142
  phaystack.cur.ptr = haystack;
#line 142
  phaystack.in_shift = (_Bool)0;
#line 142
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
#line 142
  phaystack.next_done = (_Bool)0;
  }
  {
#line 144
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 144
    mbuiter_multi_next(& phaystack);
    }
#line 144
    if (phaystack.cur.wc_valid) {
#line 144
      if (phaystack.cur.wc == 0) {
#line 144
        tmp___13 = 0;
      } else {
#line 144
        tmp___13 = 1;
      }
    } else {
#line 144
      tmp___13 = 1;
    }
#line 144
    if (! tmp___13) {
#line 144
      goto while_break___2;
    }
#line 145
    if ((needle_mbchars + j___1)->wc_valid) {
#line 145
      if (phaystack.cur.wc_valid) {
#line 145
        tmp___12 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
#line 145
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 145
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
        {
#line 145
        tmp___10 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
        }
#line 145
        if (tmp___10 == 0) {
#line 145
          tmp___11 = 1;
        } else {
#line 145
          tmp___11 = 0;
        }
      } else {
#line 145
        tmp___11 = 0;
      }
#line 145
      tmp___12 = tmp___11;
    }
#line 145
    if (tmp___12) {
#line 147
      j___1 ++;
#line 148
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 148
      phaystack.next_done = (_Bool)0;
#line 149
      if (j___1 == m) {
#line 152
        *resultp = rhaystack.cur.ptr;
#line 153
        goto while_break___2;
      }
    } else
#line 156
    if (j___1 > 0UL) {
#line 159
      count = *(table + j___1);
#line 160
      j___1 -= count;
      {
#line 161
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 161
        if (! (count > 0UL)) {
#line 161
          goto while_break___3;
        }
        {
#line 163
        mbuiter_multi_next(& rhaystack);
        }
#line 163
        if (rhaystack.cur.wc_valid) {
#line 163
          if (rhaystack.cur.wc == 0) {
#line 163
            tmp___8 = 0;
          } else {
#line 163
            tmp___8 = 1;
          }
        } else {
#line 163
          tmp___8 = 1;
        }
#line 163
        if (! tmp___8) {
          {
#line 164
          abort();
          }
        }
#line 165
        rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 165
        rhaystack.next_done = (_Bool)0;
#line 161
        count --;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 171
      mbuiter_multi_next(& rhaystack);
      }
#line 171
      if (rhaystack.cur.wc_valid) {
#line 171
        if (rhaystack.cur.wc == 0) {
#line 171
          tmp___9 = 0;
        } else {
#line 171
          tmp___9 = 1;
        }
      } else {
#line 171
        tmp___9 = 1;
      }
#line 171
      if (! tmp___9) {
        {
#line 172
        abort();
        }
      }
#line 173
      rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 173
      rhaystack.next_done = (_Bool)0;
#line 174
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 174
      phaystack.next_done = (_Bool)0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 178
  freea(memory);
  }
#line 179
  return ((_Bool)1);
}
}
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 24 "/home/khheo/project/benchmark/grep-3.1/lib/mbrlen.c"
static mbstate_t internal_state___0  ;
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-3.1/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 223
#pragma GCC diagnostic pop
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 69 "/home/khheo/project/benchmark/grep-3.1/lib/malloca.c"
static void *mmalloca_results___0[257]  ;
#line 124 "./glthread/lock.h"
#pragma weak pthread_mutex_init
#line 125
#pragma weak pthread_mutex_lock
#line 126
#pragma weak pthread_mutex_unlock
#line 127
#pragma weak pthread_mutex_destroy
#line 128
#pragma weak pthread_rwlock_init
#line 129
#pragma weak pthread_rwlock_rdlock
#line 130
#pragma weak pthread_rwlock_wrlock
#line 131
#pragma weak pthread_rwlock_unlock
#line 132
#pragma weak pthread_rwlock_destroy
#line 133
#pragma weak pthread_once
#line 134
#pragma weak pthread_cond_init
#line 135
#pragma weak pthread_cond_wait
#line 136
#pragma weak pthread_cond_signal
#line 137
#pragma weak pthread_cond_broadcast
#line 138
#pragma weak pthread_cond_destroy
#line 139
#pragma weak pthread_mutexattr_init
#line 140
#pragma weak pthread_mutexattr_settype
#line 141
#pragma weak pthread_mutexattr_destroy
#line 142
#pragma weak pthread_rwlockattr_init
#line 144
#pragma weak pthread_rwlockattr_setkind_np
#line 146
#pragma weak pthread_rwlockattr_destroy
#line 148
#pragma weak pthread_self
#line 152
#pragma weak pthread_cancel
#line 481 "/home/khheo/project/benchmark/grep-3.1/lib/glthread/lock.c"
static int const   fresh_once___0  =    (pthread_once_t const   )0;
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 39 "/home/khheo/project/benchmark/grep-3.1/lib/localeinfo.c"
static _Bool is_using_utf8___0(void) 
{ 
  wchar_t wc ;
  mbstate_t mbs ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 43
  mbs.__count = 0;
#line 43
  mbs.__value.__wch = 0U;
#line 44
  tmp = rpl_mbrtowc(& wc, "\304\200", (size_t )2, & mbs);
  }
#line 44
  if (tmp == 2UL) {
#line 44
    if (wc == 256) {
#line 44
      tmp___0 = 1;
    } else {
#line 44
      tmp___0 = 0;
    }
  } else {
#line 44
    tmp___0 = 0;
  }
#line 44
  return ((_Bool )tmp___0);
}
}
#line 74 "/home/khheo/project/benchmark/grep-3.1/lib/localeinfo.c"
static short const   lonesome_lower___0[19]  = 
#line 74
  {      (short const   )181,      (short const   )305,      (short const   )383,      (short const   )453, 
        (short const   )456,      (short const   )459,      (short const   )498,      (short const   )837, 
        (short const   )962,      (short const   )976,      (short const   )977,      (short const   )981, 
        (short const   )982,      (short const   )1008,      (short const   )1009,      (short const   )1010, 
        (short const   )1013,      (short const   )7835,      (short const   )8126};
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 121 "/home/khheo/project/benchmark/grep-3.1/lib/localcharset.c"
static char const   * volatile  charset_aliases___0  ;
#line 124 "/home/khheo/project/benchmark/grep-3.1/lib/localcharset.c"
static char const   *get_charset_aliases___0(void) 
{ 
  char const   *cp ;
  char *malloc_dir ;
  char const   *dir ;
  char const   *base ;
  char *file_name___1 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 129
  cp = (char const   *)charset_aliases___0;
#line 130
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 133
    malloc_dir = (char *)((void *)0);
#line 135
    base = "charset.alias";
#line 140
    tmp = getenv("CHARSETALIASDIR");
#line 140
    dir = (char const   *)tmp;
    }
#line 141
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 142
      malloc_dir = (char *)((void *)0);
#line 142
      dir = "/usr/local/lib";
    } else
#line 141
    if ((int const   )*(dir + 0) == 0) {
#line 142
      malloc_dir = (char *)((void *)0);
#line 142
      dir = "/usr/local/lib";
    }
    {
#line 146
    tmp___0 = strlen(dir);
#line 146
    dir_len___0 = tmp___0;
#line 147
    tmp___1 = strlen(base);
#line 147
    base_len___0 = tmp___1;
    }
#line 148
    if (dir_len___0 > 0UL) {
#line 148
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 148
        tmp___2 = 1;
      } else {
#line 148
        tmp___2 = 0;
      }
    } else {
#line 148
      tmp___2 = 0;
    }
    {
#line 148
    add_slash = tmp___2;
#line 149
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 149
    file_name___1 = (char *)tmp___3;
    }
#line 150
    if ((unsigned long )file_name___1 != (unsigned long )((void *)0)) {
      {
#line 152
      memcpy((void */* __restrict  */)file_name___1, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 153
      if (add_slash) {
#line 154
        *(file_name___1 + dir_len___0) = (char )'/';
      }
      {
#line 155
      memcpy((void */* __restrict  */)((file_name___1 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
    {
#line 159
    free((void *)malloc_dir);
    }
#line 161
    if ((unsigned long )file_name___1 == (unsigned long )((void *)0)) {
#line 163
      cp = "";
    } else {
      {
#line 175
      fd = open((char const   *)file_name___1, 131072);
      }
#line 177
      if (fd < 0) {
#line 179
        cp = "";
      } else {
        {
#line 184
        fp = fdopen(fd, "r");
        }
#line 185
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 188
          close(fd);
#line 189
          cp = "";
          }
        } else {
#line 194
          res_ptr = (char *)((void *)0);
#line 195
          res_size = (size_t )0;
          {
#line 197
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 205
            c = getc_unlocked(fp);
            }
#line 206
            if (c == -1) {
#line 207
              goto while_break;
            }
#line 208
            if (c == 10) {
#line 209
              goto __Cont;
            } else
#line 208
            if (c == 32) {
#line 209
              goto __Cont;
            } else
#line 208
            if (c == 9) {
#line 209
              goto __Cont;
            }
#line 210
            if (c == 35) {
              {
#line 213
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 214
                c = getc_unlocked(fp);
                }
#line 213
                if (c == -1) {
#line 213
                  goto while_break___0;
                } else
#line 213
                if (c == 10) {
#line 213
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 216
              if (c == -1) {
#line 217
                goto while_break;
              }
#line 218
              goto __Cont;
            }
            {
#line 220
            ungetc(c, fp);
#line 221
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 221
            if (tmp___4 < 2) {
#line 222
              goto while_break;
            }
            {
#line 223
            l1 = strlen((char const   *)(buf1));
#line 224
            l2 = strlen((char const   *)(buf2));
#line 225
            old_res_ptr = res_ptr;
            }
#line 226
            if (res_size == 0UL) {
              {
#line 228
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 229
              tmp___5 = malloc(res_size + 1UL);
#line 229
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 233
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 234
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 234
              res_ptr = (char *)tmp___6;
              }
            }
#line 236
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 239
              res_size = (size_t )0;
#line 240
              free((void *)old_res_ptr);
              }
#line 241
              goto while_break;
            }
            {
#line 243
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1));
#line 244
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 246
          fclose(fp);
          }
#line 247
          if (res_size == 0UL) {
#line 248
            cp = "";
          } else {
#line 251
            *(res_ptr + res_size) = (char )'\000';
#line 252
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 257
      free((void *)file_name___1);
      }
    }
#line 381
    charset_aliases___0 = (char const   */* volatile  */)cp;
  }
#line 384
  return (cp);
}
}
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 134
#pragma GCC diagnostic pop
#line 130 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static struct hash_tuning  const  default_tuning___0  =    {0.0f, 1.0f, 0.8f, 1.414f, (_Bool)0};
#line 248 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static struct hash_entry *safe_hasher___0(Hash_table const   *table , void const   *key ) 
{ 
  size_t n ;
  size_t tmp ;

  {
  {
#line 251
  tmp = (*(table->hasher))(key, (size_t )table->n_buckets);
#line 251
  n = tmp;
  }
#line 252
  if (! (n < (size_t )table->n_buckets)) {
    {
#line 253
    abort();
    }
  }
#line 254
  return ((struct hash_entry *)(table->bucket + n));
}
}
#line 443
static _Bool is_prime___0(size_t candidate )  __attribute__((__const__)) ;
#line 443 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static _Bool is_prime___0(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 446
  divisor = (size_t )3;
#line 447
  square = divisor * divisor;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (square < candidate) {
#line 449
      if (! (candidate % divisor)) {
#line 449
        goto while_break;
      }
    } else {
#line 449
      goto while_break;
    }
#line 451
    divisor ++;
#line 452
    square += 4UL * divisor;
#line 453
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (candidate % divisor) {
#line 456
    tmp = 1;
  } else {
#line 456
    tmp = 0;
  }
#line 456
  return ((_Bool )tmp);
}
}
#line 462
static size_t next_prime___0(size_t candidate )  __attribute__((__const__)) ;
#line 462 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static size_t next_prime___0(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 466
  if (candidate < 10UL) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= 1UL;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (0xffffffffffffffffUL != candidate) {
      {
#line 472
      tmp = is_prime___0(candidate);
      }
#line 472
      if (tmp) {
#line 472
        goto while_break;
      }
    } else {
#line 472
      goto while_break;
    }
#line 473
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (candidate);
}
}
#line 485 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static size_t raw_hasher___0(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t tmp ;

  {
  {
#line 493
  tmp = rotr_sz((size_t )data, 3);
#line 493
  val = tmp;
  }
#line 494
  return (val % n);
}
}
#line 498 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static _Bool raw_comparator___0(void const   *a , void const   *b ) 
{ 


  {
#line 501
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 511 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static _Bool check_tuning___0(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table->tuning;
#line 516
  if ((unsigned long )tuning == (unsigned long )(& default_tuning___0)) {
#line 517
    return ((_Bool)1);
  }
#line 524
  epsilon = 0.1f;
#line 526
  if (epsilon < (float )tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 526
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 526
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float const   )1) {
#line 526
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 533
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table->tuning = & default_tuning___0;
#line 536
  return ((_Bool)0);
}
}
#line 543 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static size_t __attribute__((__pure__))  compute_bucket_size___0(size_t candidate ,
                                                                 Hash_tuning const   *tuning ) 
{ 
  float new_candidate ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 549
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 550
      return ((size_t __attribute__((__pure__))  )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
  {
#line 553
  candidate = next_prime___0(candidate);
  }
#line 554
  if (9223372036854775807UL / sizeof(struct hash_entry *) < candidate) {
#line 555
    return ((size_t __attribute__((__pure__))  )0);
  }
#line 556
  return ((size_t __attribute__((__pure__))  )candidate);
}
}
#line 750 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static struct hash_entry *allocate_entry___0(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 755
  if (table->free_entry_list) {
#line 757
    new = table->free_entry_list;
#line 758
    table->free_entry_list = new->next;
  } else {
    {
#line 765
    tmp = malloc(sizeof(*new));
#line 765
    new = (struct hash_entry *)tmp;
    }
  }
#line 769
  return (new);
}
}
#line 775 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static void free_entry___0(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 778
  entry->data = (void *)0;
#line 779
  entry->next = table->free_entry_list;
#line 780
  table->free_entry_list = entry;
#line 781
  return;
}
}
#line 789 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static void *hash_find_entry___0(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                                 _Bool delete___1 ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 793
  tmp = safe_hasher___0((Hash_table const   *)table, entry);
#line 793
  bucket = tmp;
#line 796
  *bucket_head = bucket;
  }
#line 799
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 800
    return ((void *)0);
  }
#line 803
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 803
    goto _L;
  } else {
    {
#line 803
    tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
    }
#line 803
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 805
      data = bucket->data;
#line 807
      if (delete___1) {
#line 809
        if (bucket->next) {
          {
#line 811
          next = bucket->next;
#line 815
          *bucket = *next;
#line 816
          free_entry___0(table, next);
          }
        } else {
#line 820
          bucket->data = (void *)0;
        }
      }
#line 824
      return (data);
    }
  }
#line 828
  cursor = bucket;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cursor->next) {
#line 828
      goto while_break;
    }
#line 830
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 830
      goto _L___0;
    } else {
      {
#line 830
      tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
      }
#line 830
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 833
        data___0 = (cursor->next)->data;
#line 835
        if (delete___1) {
          {
#line 837
          next___0 = cursor->next;
#line 841
          cursor->next = next___0->next;
#line 842
          free_entry___0(table, next___0);
          }
        }
#line 845
        return (data___0);
      }
    }
#line 828
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return ((void *)0);
}
}
#line 859 "/home/khheo/project/benchmark/grep-3.1/lib/hash.c"
static _Bool transfer_entries___0(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
#line 865
  bucket = src->bucket;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 865
      goto while_break;
    }
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
      {
#line 877
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 877
        if (! cursor) {
#line 877
          goto while_break___0;
        }
        {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher___0((Hash_table const   *)dst, (void const   *)data);
#line 882
        next = cursor->next;
        }
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
          {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry___0(dst, cursor);
          }
        }
#line 877
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
      {
#line 907
      new_bucket = safe_hasher___0((Hash_table const   *)dst, (void const   *)data);
      }
#line 909
      if (new_bucket->data) {
        {
#line 913
        tmp = allocate_entry___0(dst);
#line 913
        new_entry = tmp;
        }
#line 915
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 916
          return ((_Bool)0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */ 
#line 865
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return ((_Bool)1);
}
}
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-3.1/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 214 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static FTSENT *fts_alloc___0(FTS *sp , char const   *name , size_t namelen ) ;
#line 215
static FTSENT *fts_build___0(FTS *sp , int type ) ;
#line 216
static void fts_lfree___0(FTSENT *head ) ;
#line 217
static void fts_load___0(FTS *sp , FTSENT *p ) ;
#line 218
static size_t __attribute__((__pure__))  fts_maxarglen___0(char * const  *argv ) ;
#line 219
static void fts_padjust___0(FTS *sp , FTSENT *head ) ;
#line 220
static _Bool fts_palloc___0(FTS *sp , size_t more ) ;
#line 221
static FTSENT *fts_sort___0(FTS *sp , FTSENT *head , size_t nitems ) ;
#line 222
static unsigned short fts_stat___0(FTS *sp , FTSENT *p , _Bool follow ) ;
#line 223
static int fts_safe_changedir___0(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/fts-cycle.c"
static _Bool AD_compare___0(void const   *x , void const   *y ) 
{ 
  struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;
  int tmp ;

  {
#line 34
  ax = (struct Active_dir  const  *)x;
#line 35
  ay = (struct Active_dir  const  *)y;
#line 36
  if (ax->ino == ay->ino) {
#line 36
    if (ax->dev == ay->dev) {
#line 36
      tmp = 1;
    } else {
#line 36
      tmp = 0;
    }
  } else {
#line 36
    tmp = 0;
  }
#line 36
  return ((_Bool )tmp);
}
}
#line 40 "/home/khheo/project/benchmark/grep-3.1/lib/fts-cycle.c"
static size_t AD_hash___0(void const   *x , size_t table_size ) 
{ 
  struct Active_dir  const  *ax ;

  {
#line 43
  ax = (struct Active_dir  const  *)x;
#line 44
  return ((uintmax_t )ax->ino % table_size);
}
}
#line 49 "/home/khheo/project/benchmark/grep-3.1/lib/fts-cycle.c"
static _Bool setup_dir___0(FTS *fts ) 
{ 
  void *tmp ;

  {
#line 52
  if (fts->fts_options & 258) {
    {
#line 55
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const   *)((void *)0),
                                        & AD_hash___0, & AD_compare___0, (void (*)(void * ))(& free));
    }
#line 57
    if (! fts->fts_cycle.ht) {
#line 58
      return ((_Bool)0);
    }
  } else {
    {
#line 62
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
#line 62
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
    }
#line 63
    if (! fts->fts_cycle.state) {
#line 64
      return ((_Bool)0);
    }
    {
#line 65
    cycle_check_init(fts->fts_cycle.state);
    }
  }
#line 68
  return ((_Bool)1);
}
}
#line 73 "/home/khheo/project/benchmark/grep-3.1/lib/fts-cycle.c"
static _Bool enter_dir___0(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 76
  if (fts->fts_options & 258) {
    {
#line 78
    st = (struct stat  const  *)(ent->fts_statp);
#line 79
    tmp = malloc(sizeof(*ad));
#line 79
    ad = (struct Active_dir *)tmp;
    }
#line 82
    if (! ad) {
#line 83
      return ((_Bool)0);
    }
    {
#line 85
    ad->dev = (dev_t )st->st_dev;
#line 86
    ad->ino = (ino_t )st->st_ino;
#line 87
    ad->fts_ent = ent;
#line 92
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
#line 92
    ad_from_table = (struct Active_dir *)tmp___0;
    }
#line 94
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
      {
#line 96
      free((void *)ad);
      }
#line 97
      if (! ad_from_table) {
#line 98
        return ((_Bool)0);
      }
#line 102
      ent->fts_cycle = ad_from_table->fts_ent;
#line 103
      ent->fts_info = (unsigned short)2;
    }
  } else {
    {
#line 108
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
    }
#line 108
    if (tmp___1) {
#line 114
      ent->fts_cycle = ent;
#line 115
      ent->fts_info = (unsigned short)2;
    }
  }
#line 119
  return ((_Bool)1);
}
}
#line 124 "/home/khheo/project/benchmark/grep-3.1/lib/fts-cycle.c"
static void leave_dir___0(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
#line 127
  st = (struct stat  const  *)(ent->fts_statp);
#line 128
  if (fts->fts_options & 258) {
    {
#line 132
    obj.dev = (dev_t )st->st_dev;
#line 133
    obj.ino = (ino_t )st->st_ino;
#line 134
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
    }
#line 135
    if (! found) {
      {
#line 136
      abort();
      }
    }
    {
#line 137
    free(found);
    }
  } else {
#line 141
    parent = ent->fts_parent;
#line 142
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 142
      if (0L <= parent->fts_level) {
        {
#line 143
        while (1) {
          while_continue: /* CIL Label */ ;
#line 143
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
            {
#line 143
            abort();
            }
          }
#line 143
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
#line 143
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
#line 143
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
#line 143
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
            }
          }
#line 143
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 146
  return;
}
}
#line 150 "/home/khheo/project/benchmark/grep-3.1/lib/fts-cycle.c"
static void free_dir___0(FTS *sp ) 
{ 


  {
#line 153
  if (sp->fts_options & 258) {
#line 155
    if (sp->fts_cycle.ht) {
      {
#line 156
      hash_free(sp->fts_cycle.ht);
      }
    }
  } else {
    {
#line 159
    free((void *)sp->fts_cycle.state);
    }
  }
#line 160
  return;
}
}
#line 279 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void fd_ring_clear___0(I_ring *fd_ring ) 
{ 
  int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 282
    tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
    }
#line 282
    if (tmp___0) {
#line 282
      goto while_break;
    }
    {
#line 284
    tmp = i_ring_pop(fd_ring);
#line 284
    fd = tmp;
    }
#line 285
    if (0 <= fd) {
      {
#line 286
      close(fd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 293 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void fts_set_stat_required___0(FTSENT *p , _Bool required ) 
{ 


  {
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! ((int )p->fts_info == 11)) {
      {
#line 296
      abort();
      }
    }
#line 296
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  if (required) {
#line 297
    p->fts_statp[0].st_size = (__off_t )2;
  } else {
#line 297
    p->fts_statp[0].st_size = (__off_t )1;
  }
#line 300
  return;
}
}
#line 304 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static DIR *opendirat___0(int fd , char const   *dir , int extra_flags , int *pdir_fd ) 
{ 
  int new_fd ;
  int tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 308
  tmp = openat_safer(fd, dir, 67840 | extra_flags);
#line 308
  new_fd = tmp;
  }
#line 313
  if (new_fd < 0) {
#line 314
    return ((DIR *)((void *)0));
  }
  {
#line 315
  set_cloexec_flag(new_fd, (_Bool)1);
#line 316
  dirp = fdopendir(new_fd);
  }
#line 317
  if (dirp) {
#line 318
    *pdir_fd = new_fd;
  } else {
    {
#line 321
    tmp___0 = __errno_location();
#line 321
    saved_errno = *tmp___0;
#line 322
    close(new_fd);
#line 323
    tmp___1 = __errno_location();
#line 323
    *tmp___1 = saved_errno;
    }
  }
#line 325
  return (dirp);
}
}
#line 333 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void cwd_advance_fd___0(FTS *sp , int fd , _Bool chdir_down_one ) 
{ 
  int old ;
  int prev_fd_in_slot ;
  int tmp ;

  {
#line 337
  old = sp->fts_cwd_fd;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (old != fd)) {
#line 338
      if (! (old == -100)) {
        {
#line 338
        abort();
        }
      }
    }
#line 338
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  if (chdir_down_one) {
    {
#line 344
    tmp = i_ring_push(& sp->fts_fd_ring, old);
#line 344
    prev_fd_in_slot = tmp;
    }
#line 346
    if (0 <= prev_fd_in_slot) {
      {
#line 347
      close(prev_fd_in_slot);
      }
    }
  } else
#line 349
  if (! (sp->fts_options & 4)) {
#line 351
    if (0 <= old) {
      {
#line 352
      close(old);
      }
    }
  }
#line 355
  sp->fts_cwd_fd = fd;
#line 356
  return;
}
}
#line 362 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static int restore_initial_cwd___0(FTS *sp ) 
{ 
  int fail ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 365
  if (! (sp->fts_options & 4)) {
#line 365
    if (sp->fts_options & 512) {
#line 365
      if (sp->fts_options & 512) {
#line 365
        tmp = -100;
      } else {
#line 365
        tmp = sp->fts_rfd;
      }
      {
#line 365
      cwd_advance_fd___0(sp, tmp, (_Bool)1);
#line 365
      tmp___2 = 0;
      }
    } else {
#line 365
      if (sp->fts_options & 512) {
#line 365
        tmp___0 = -100;
      } else {
#line 365
        tmp___0 = sp->fts_rfd;
      }
      {
#line 365
      tmp___1 = fchdir(tmp___0);
#line 365
      tmp___2 = tmp___1;
      }
    }
#line 365
    if (tmp___2) {
#line 365
      tmp___3 = 1;
    } else {
#line 365
      tmp___3 = 0;
    }
  } else {
#line 365
    tmp___3 = 0;
  }
  {
#line 365
  fail = tmp___3;
#line 366
  fd_ring_clear___0(& sp->fts_fd_ring);
  }
#line 367
  return (fail);
}
}
#line 374 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static int diropen___0(FTS const   *sp , char const   *dir ) 
{ 
  int open_flags ;
  int tmp ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 378
  if (sp->fts_options & 16) {
#line 378
    tmp = 131072;
  } else {
#line 378
    tmp = 0;
  }
#line 378
  if (sp->fts_options & 2048) {
#line 378
    tmp___0 = 262144;
  } else {
#line 378
    tmp___0 = 0;
  }
#line 378
  open_flags = (67840 | tmp) | tmp___0;
#line 382
  if (sp->fts_options & 512) {
    {
#line 382
    tmp___1 = openat_safer((int )sp->fts_cwd_fd, dir, open_flags);
#line 382
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 382
    tmp___2 = open_safer(dir, open_flags);
#line 382
    tmp___3 = tmp___2;
    }
  }
#line 382
  fd = tmp___3;
#line 385
  if (0 <= fd) {
    {
#line 386
    set_cloexec_flag(fd, (_Bool)1);
    }
  }
#line 387
  return (fd);
}
}
#line 580 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void fts_load___0(FTS *sp , FTSENT *p ) 
{ 
  register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 594
  tmp = p->fts_namelen;
#line 594
  p->fts_pathlen = tmp;
#line 594
  len = tmp;
#line 595
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1UL);
#line 596
  cp = strrchr((char const   *)(p->fts_name), '/');
  }
#line 596
  if (cp) {
#line 596
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
      {
#line 597
      cp ++;
#line 597
      len = strlen((char const   *)cp);
#line 598
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 599
      p->fts_namelen = len;
      }
    } else
#line 596
    if (*(cp + 1)) {
      {
#line 597
      cp ++;
#line 597
      len = strlen((char const   *)cp);
#line 598
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 599
      p->fts_namelen = len;
      }
    }
  }
#line 601
  tmp___0 = sp->fts_path;
#line 601
  p->fts_path = tmp___0;
#line 601
  p->fts_accpath = tmp___0;
#line 602
  return;
}
}
#line 684 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static _Bool dirent_inode_sort_may_be_useful___0(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 695
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 695
  if (tmp != 0) {
#line 696
    return ((_Bool)1);
  }
  {
#line 703
  if (fs_buf.f_type == 26985L) {
#line 703
    goto case_26985;
  }
#line 703
  if (fs_buf.f_type == 16914836L) {
#line 703
    goto case_26985;
  }
#line 708
  goto switch_default;
  case_26985: /* CIL Label */ 
  case_16914836: /* CIL Label */ 
#line 706
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 709
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 716 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static _Bool leaf_optimization_applies___0(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 722
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 722
  if (tmp != 0) {
#line 723
    return ((_Bool)0);
  }
  {
#line 733
  if (fs_buf.f_type == 1481003842L) {
#line 733
    goto case_1481003842;
  }
#line 733
  if (fs_buf.f_type == 1382369651L) {
#line 733
    goto case_1481003842;
  }
#line 738
  if (fs_buf.f_type == 26985L) {
#line 738
    goto case_26985;
  }
#line 744
  if (fs_buf.f_type == 40864L) {
#line 744
    goto case_40864;
  }
#line 748
  goto switch_default;
  case_1481003842: /* CIL Label */ 
  case_1382369651: /* CIL Label */ 
#line 734
  return ((_Bool)1);
  case_26985: /* CIL Label */ ;
  case_40864: /* CIL Label */ ;
  switch_default: /* CIL Label */ 
#line 749
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 773 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static size_t LCO_hash___0(void const   *x , size_t table_size ) 
{ 
  struct LCO_ent  const  *ax ;

  {
#line 776
  ax = (struct LCO_ent  const  *)x;
#line 777
  return ((uintmax_t )ax->st_dev % table_size);
}
}
#line 780 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static _Bool LCO_compare___0(void const   *x , void const   *y ) 
{ 
  struct LCO_ent  const  *ax ;
  struct LCO_ent  const  *ay ;

  {
#line 783
  ax = (struct LCO_ent  const  *)x;
#line 784
  ay = (struct LCO_ent  const  *)y;
#line 785
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
#line 791 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static _Bool link_count_optimize_ok___0(FTSENT const   *p ) 
{ 
  FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 794
  sp = (FTS *)p->fts_fts;
#line 795
  h = sp->fts_leaf_optimization_works_ht;
#line 803
  if (! (sp->fts_options & 512)) {
#line 804
    return ((_Bool)0);
  }
#line 807
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 809
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const   *)((void *)0), & LCO_hash___0,
                              & LCO_compare___0, (void (*)(void * ))(& free));
#line 809
    sp->fts_leaf_optimization_works_ht = tmp___0;
#line 809
    h = tmp___0;
    }
#line 812
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 813
      return ((_Bool)0);
    }
  }
  {
#line 815
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 816
  tmp___1 = hash_lookup((Hash_table const   *)h, (void const   *)(& tmp));
#line 816
  ent = (struct LCO_ent *)tmp___1;
  }
#line 817
  if (ent) {
#line 818
    return (ent->opt_ok);
  }
  {
#line 821
  tmp___2 = malloc(sizeof(*t2));
#line 821
  t2 = (struct LCO_ent *)tmp___2;
  }
#line 822
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
#line 823
    return ((_Bool)0);
  }
  {
#line 826
  opt_ok = leaf_optimization_applies___0(sp->fts_cwd_fd);
#line 827
  t2->opt_ok = opt_ok;
#line 828
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 830
  tmp___3 = hash_insert(h, (void const   *)t2);
#line 830
  ent = (struct LCO_ent *)tmp___3;
  }
#line 831
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
    {
#line 834
    free((void *)t2);
    }
#line 835
    return ((_Bool)0);
  }
  {
#line 837
  while (1) {
    while_continue: /* CIL Label */ ;
#line 837
    if (! ((unsigned long )ent == (unsigned long )t2)) {
      {
#line 837
      abort();
      }
    }
#line 837
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  return (opt_ok);
}
}
#line 1224 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static int fts_compare_ino___0(struct _ftsent  const  **a , struct _ftsent  const  **b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1227
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
#line 1227
    tmp___0 = -1;
  } else {
#line 1227
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
#line 1227
      tmp = 1;
    } else {
#line 1227
      tmp = 0;
    }
#line 1227
    tmp___0 = tmp;
  }
#line 1227
  return (tmp___0);
}
}
#line 1233 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void set_stat_type___0(struct stat *st , unsigned int dtype ) 
{ 
  mode_t type ;

  {
  {
#line 1239
  if (dtype == 6U) {
#line 1239
    goto case_6;
  }
#line 1242
  if (dtype == 2U) {
#line 1242
    goto case_2;
  }
#line 1245
  if (dtype == 4U) {
#line 1245
    goto case_4;
  }
#line 1248
  if (dtype == 1U) {
#line 1248
    goto case_1;
  }
#line 1251
  if (dtype == 10U) {
#line 1251
    goto case_10;
  }
#line 1254
  if (dtype == 8U) {
#line 1254
    goto case_8;
  }
#line 1257
  if (dtype == 12U) {
#line 1257
    goto case_12;
  }
#line 1260
  goto switch_default;
  case_6: /* CIL Label */ 
#line 1240
  type = (mode_t )24576;
#line 1241
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1243
  type = (mode_t )8192;
#line 1244
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1246
  type = (mode_t )16384;
#line 1247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1249
  type = (mode_t )4096;
#line 1250
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1252
  type = (mode_t )40960;
#line 1253
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1255
  type = (mode_t )32768;
#line 1256
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1258
  type = (mode_t )49152;
#line 1259
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1261
  type = (mode_t )0;
  switch_break: /* CIL Label */ ;
  }
#line 1263
  st->st_mode = type;
#line 1264
  return;
}
}
#line 1299 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static FTSENT *fts_build___0(FTS *sp , int type ) 
{ 
  register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *tail ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int dir_fd ;
  FTSENT *cur ;
  _Bool continue_readdir ;
  size_t max_entries ;
  DIR *dp ;
  int *tmp ;
  int *tmp___0 ;
  DIR *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  _Bool is_dir ;
  size_t d_namelen ;
  int *tmp___11 ;
  struct dirent *dp___0 ;
  struct dirent *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  _Bool tmp___17 ;
  int *tmp___18 ;
  _Bool skip_stat ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  _Bool tmp___25 ;

  {
#line 1316
  cur = sp->fts_cur;
#line 1317
  continue_readdir = (_Bool )(! (! cur->fts_dirp));
#line 1323
  if (continue_readdir) {
    {
#line 1325
    dp = cur->fts_dirp;
#line 1326
    dir_fd = dirfd(dp);
    }
#line 1327
    if (dir_fd < 0) {
      {
#line 1329
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1329
        closedir(cur->fts_dirp);
#line 1329
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1329
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1330
      if (type == 3) {
        {
#line 1332
        cur->fts_info = (unsigned short)4;
#line 1333
        tmp = __errno_location();
#line 1333
        cur->fts_errno = *tmp;
        }
      }
#line 1335
      return ((FTSENT *)((void *)0));
    }
  } else {
#line 1342
    if (sp->fts_options & 16) {
#line 1342
      if (sp->fts_options & 1) {
#line 1342
        if (cur->fts_level == 0L) {
#line 1342
          tmp___2 = 0;
        } else {
#line 1342
          tmp___2 = 131072;
        }
      } else {
#line 1342
        tmp___2 = 131072;
      }
    } else {
#line 1342
      tmp___2 = 0;
    }
#line 1342
    if (sp->fts_options & 2048) {
#line 1342
      tmp___3 = 262144;
    } else {
#line 1342
      tmp___3 = 0;
    }
#line 1342
    if (! (sp->fts_options & 4)) {
#line 1342
      if (sp->fts_options & 512) {
#line 1342
        tmp___4 = sp->fts_cwd_fd;
      } else {
#line 1342
        tmp___4 = -100;
      }
    } else {
#line 1342
      tmp___4 = -100;
    }
    {
#line 1342
    tmp___1 = opendirat___0(tmp___4, (char const   *)cur->fts_accpath, tmp___2 | tmp___3,
                            & dir_fd);
#line 1342
    cur->fts_dirp = tmp___1;
    }
#line 1342
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1344
      if (type == 3) {
        {
#line 1346
        cur->fts_info = (unsigned short)4;
#line 1347
        tmp___0 = __errno_location();
#line 1347
        cur->fts_errno = *tmp___0;
        }
      }
#line 1349
      return ((FTSENT *)((void *)0));
    }
#line 1354
    if ((int )cur->fts_info == 11) {
      {
#line 1355
      cur->fts_info = fts_stat___0(sp, cur, (_Bool)0);
      }
    } else
#line 1356
    if (sp->fts_options & 256) {
      {
#line 1363
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1363
        leave_dir___0(sp, cur);
        }
#line 1363
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1364
      fts_stat___0(sp, cur, (_Bool)0);
#line 1365
      tmp___6 = enter_dir___0(sp, cur);
      }
#line 1365
      if (! tmp___6) {
        {
#line 1367
        tmp___5 = __errno_location();
#line 1367
        *tmp___5 = 12;
        }
#line 1368
        return ((FTSENT *)((void *)0));
      }
    }
  }
#line 1380
  if (sp->fts_compar) {
#line 1380
    max_entries = 0xffffffffffffffffUL;
  } else {
#line 1380
    max_entries = (size_t )100000;
  }
#line 1387
  if (type == 2) {
#line 1388
    nlinks = (nlink_t )0;
#line 1390
    nostat = (_Bool)0;
  } else
#line 1391
  if (sp->fts_options & 8) {
#line 1391
    if (sp->fts_options & 16) {
#line 1392
      if (sp->fts_options & 32) {
#line 1392
        tmp___7 = 0;
      } else {
#line 1392
        tmp___7 = 2;
      }
#line 1392
      nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___7;
#line 1394
      nostat = (_Bool)1;
    } else {
#line 1396
      nlinks = (nlink_t )-1;
#line 1397
      nostat = (_Bool)0;
    }
  } else {
#line 1396
    nlinks = (nlink_t )-1;
#line 1397
    nostat = (_Bool)0;
  }
#line 1415
  if (continue_readdir) {
#line 1419
    descend = (_Bool)1;
  } else
#line 1421
  if (nlinks) {
#line 1421
    goto _L___0;
  } else
#line 1421
  if (type == 3) {
    _L___0: /* CIL Label */ 
#line 1422
    if (sp->fts_options & 512) {
      {
#line 1424
      dir_fd = dup_safer(dir_fd);
      }
#line 1425
      if (0 <= dir_fd) {
        {
#line 1426
        set_cloexec_flag(dir_fd, (_Bool)1);
        }
      }
    }
#line 1428
    if (dir_fd < 0) {
#line 1428
      goto _L;
    } else {
      {
#line 1428
      tmp___9 = fts_safe_changedir___0(sp, cur, dir_fd, (char const   *)((void *)0));
      }
#line 1428
      if (tmp___9) {
        _L: /* CIL Label */ 
#line 1429
        if (nlinks) {
#line 1429
          if (type == 3) {
            {
#line 1430
            tmp___8 = __errno_location();
#line 1430
            cur->fts_errno = *tmp___8;
            }
          }
        }
#line 1431
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
#line 1432
        descend = (_Bool)0;
        {
#line 1433
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1433
          closedir(cur->fts_dirp);
#line 1433
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1433
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1434
        if (sp->fts_options & 512) {
#line 1434
          if (0 <= dir_fd) {
            {
#line 1435
            close(dir_fd);
            }
          }
        }
#line 1436
        cur->fts_dirp = (DIR *)((void *)0);
      } else {
#line 1438
        descend = (_Bool)1;
      }
    }
  } else {
#line 1440
    descend = (_Bool)0;
  }
#line 1452
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
#line 1452
    len = cur->fts_pathlen - 1UL;
  } else {
#line 1452
    len = cur->fts_pathlen;
  }
#line 1453
  if (sp->fts_options & 4) {
#line 1454
    cp = sp->fts_path + len;
#line 1455
    tmp___10 = cp;
#line 1455
    cp ++;
#line 1455
    *tmp___10 = (char )'/';
  } else {
#line 1458
    cp = (char *)((void *)0);
  }
#line 1460
  len ++;
#line 1461
  maxlen = sp->fts_pathlen - len;
#line 1463
  level = cur->fts_level + 1L;
#line 1466
  doadjust = (_Bool)0;
#line 1467
  head = (FTSENT *)((void *)0);
#line 1468
  tail = (FTSENT *)((void *)0);
#line 1469
  nitems = (size_t )0;
  {
#line 1470
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1470
    if (! cur->fts_dirp) {
#line 1470
      goto while_break___2;
    }
    {
#line 1473
    tmp___11 = __errno_location();
#line 1473
    *tmp___11 = 0;
#line 1474
    tmp___12 = readdir(cur->fts_dirp);
#line 1474
    dp___0 = tmp___12;
    }
#line 1475
    if ((unsigned long )dp___0 == (unsigned long )((void *)0)) {
      {
#line 1476
      tmp___14 = __errno_location();
      }
#line 1476
      if (*tmp___14) {
        {
#line 1477
        tmp___13 = __errno_location();
#line 1477
        cur->fts_errno = *tmp___13;
        }
#line 1480
        if (continue_readdir) {
#line 1480
          cur->fts_info = (unsigned short)7;
        } else
#line 1480
        if (nitems) {
#line 1480
          cur->fts_info = (unsigned short)7;
        } else {
#line 1480
          cur->fts_info = (unsigned short)4;
        }
      }
#line 1483
      goto while_break___2;
    }
#line 1485
    if (! (sp->fts_options & 32)) {
#line 1485
      if ((int )dp___0->d_name[0] == 46) {
#line 1485
        if (! dp___0->d_name[1]) {
#line 1486
          goto while_continue___2;
        } else
#line 1485
        if ((int )dp___0->d_name[1] == 46) {
#line 1485
          if (! dp___0->d_name[2]) {
#line 1486
            goto while_continue___2;
          }
        }
      }
    }
    {
#line 1488
    d_namelen = strlen((char const   *)(dp___0->d_name));
#line 1489
    p = fts_alloc___0(sp, (char const   *)(dp___0->d_name), d_namelen);
    }
#line 1490
    if (! p) {
#line 1491
      goto mem1;
    }
#line 1492
    if (d_namelen >= maxlen) {
      {
#line 1494
      oldaddr = (void *)sp->fts_path;
#line 1495
      tmp___17 = fts_palloc___0(sp, (d_namelen + len) + 1UL);
      }
#line 1495
      if (! tmp___17) {
        mem1: 
        {
#line 1501
        tmp___15 = __errno_location();
#line 1501
        saved_errno = *tmp___15;
#line 1502
        free((void *)p);
#line 1503
        fts_lfree___0(head);
        }
        {
#line 1504
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1504
          closedir(cur->fts_dirp);
#line 1504
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1504
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1505
        cur->fts_info = (unsigned short)7;
#line 1506
        sp->fts_options |= 16384;
#line 1507
        tmp___16 = __errno_location();
#line 1507
        *tmp___16 = saved_errno;
        }
#line 1508
        return ((FTSENT *)((void *)0));
      }
#line 1511
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
#line 1512
        doadjust = (_Bool)1;
#line 1513
        if (sp->fts_options & 4) {
#line 1514
          cp = sp->fts_path + len;
        }
      }
#line 1516
      maxlen = sp->fts_pathlen - len;
    }
#line 1519
    new_len = len + d_namelen;
#line 1520
    if (new_len < len) {
      {
#line 1527
      free((void *)p);
#line 1528
      fts_lfree___0(head);
      }
      {
#line 1529
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1529
        closedir(cur->fts_dirp);
#line 1529
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1529
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1530
      cur->fts_info = (unsigned short)7;
#line 1531
      sp->fts_options |= 16384;
#line 1532
      tmp___18 = __errno_location();
#line 1532
      *tmp___18 = 36;
      }
#line 1533
      return ((FTSENT *)((void *)0));
    }
#line 1535
    p->fts_level = level;
#line 1536
    p->fts_parent = sp->fts_cur;
#line 1537
    p->fts_pathlen = new_len;
#line 1541
    p->fts_statp[0].st_ino = dp___0->d_ino;
#line 1544
    if (sp->fts_options & 4) {
      {
#line 1545
      p->fts_accpath = p->fts_path;
#line 1546
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
      }
    } else {
#line 1548
      p->fts_accpath = p->fts_name;
    }
#line 1550
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1550
      goto _L___1;
    } else
#line 1550
    if (sp->fts_options & 1024) {
      _L___1: /* CIL Label */ 
#line 1563
      if (sp->fts_options & 16) {
#line 1563
        if (sp->fts_options & 8) {
#line 1563
          if ((int )dp___0->d_type != 0) {
#line 1563
            if (! ((int )dp___0->d_type == 4)) {
#line 1563
              tmp___19 = 1;
            } else {
#line 1563
              tmp___19 = 0;
            }
          } else {
#line 1563
            tmp___19 = 0;
          }
        } else {
#line 1563
          tmp___19 = 0;
        }
      } else {
#line 1563
        tmp___19 = 0;
      }
      {
#line 1563
      skip_stat = (_Bool )tmp___19;
#line 1567
      p->fts_info = (unsigned short)11;
#line 1570
      set_stat_type___0(p->fts_statp, (unsigned int )dp___0->d_type);
#line 1571
      fts_set_stat_required___0(p, (_Bool )(! skip_stat));
      }
#line 1572
      if (sp->fts_options & 16) {
#line 1572
        if ((int )dp___0->d_type == 4) {
#line 1572
          tmp___20 = 1;
        } else {
#line 1572
          tmp___20 = 0;
        }
      } else {
#line 1572
        tmp___20 = 0;
      }
#line 1572
      is_dir = (_Bool )tmp___20;
    } else {
      {
#line 1575
      p->fts_info = fts_stat___0(sp, p, (_Bool)0);
      }
#line 1576
      if ((int )p->fts_info == 1) {
#line 1576
        tmp___21 = 1;
      } else
#line 1576
      if ((int )p->fts_info == 2) {
#line 1576
        tmp___21 = 1;
      } else
#line 1576
      if ((int )p->fts_info == 5) {
#line 1576
        tmp___21 = 1;
      } else {
#line 1576
        tmp___21 = 0;
      }
#line 1576
      is_dir = (_Bool )tmp___21;
    }
#line 1582
    if (nlinks > 0UL) {
#line 1582
      if (is_dir) {
#line 1583
        nlinks -= (nlink_t )nostat;
      }
    }
#line 1586
    p->fts_link = (struct _ftsent *)((void *)0);
#line 1587
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 1588
      tail = p;
#line 1588
      head = tail;
    } else {
#line 1590
      tail->fts_link = p;
#line 1591
      tail = p;
    }
#line 1593
    nitems ++;
#line 1594
    if (max_entries <= nitems) {
#line 1598
      goto break_without_closedir;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1602
  if (cur->fts_dirp) {
    {
#line 1603
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1603
      closedir(cur->fts_dirp);
#line 1603
      cur->fts_dirp = (DIR *)((void *)0);
      }
#line 1603
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  break_without_closedir: 
#line 1611
  if (doadjust) {
    {
#line 1612
    fts_padjust___0(sp, head);
    }
  }
#line 1618
  if (sp->fts_options & 4) {
#line 1619
    if (len == sp->fts_pathlen) {
#line 1620
      cp --;
    } else
#line 1619
    if (nitems == 0UL) {
#line 1620
      cp --;
    }
#line 1621
    *cp = (char )'\000';
  }
#line 1631
  if (! continue_readdir) {
#line 1631
    if (descend) {
#line 1631
      if (type == 1) {
#line 1631
        goto _L___2;
      } else
#line 1631
      if (! nitems) {
        _L___2: /* CIL Label */ 
#line 1631
        if (cur->fts_level == 0L) {
          {
#line 1631
          tmp___22 = restore_initial_cwd___0(sp);
#line 1631
          tmp___24 = tmp___22;
          }
        } else {
          {
#line 1631
          tmp___23 = fts_safe_changedir___0(sp, cur->fts_parent, -1, "..");
#line 1631
          tmp___24 = tmp___23;
          }
        }
#line 1631
        if (tmp___24) {
          {
#line 1635
          cur->fts_info = (unsigned short)7;
#line 1636
          sp->fts_options |= 16384;
#line 1637
          fts_lfree___0(head);
          }
#line 1638
          return ((FTSENT *)((void *)0));
        }
      }
    }
  }
#line 1642
  if (! nitems) {
#line 1643
    if (type == 3) {
#line 1643
      if ((int )cur->fts_info != 4) {
#line 1643
        if ((int )cur->fts_info != 7) {
#line 1645
          cur->fts_info = (unsigned short)6;
        }
      }
    }
    {
#line 1646
    fts_lfree___0(head);
    }
#line 1647
    return ((FTSENT *)((void *)0));
  }
#line 1654
  if (nitems > 10000UL) {
#line 1654
    if (! sp->fts_compar) {
#line 1654
      if (sp->fts_options & 512) {
        {
#line 1654
        tmp___25 = dirent_inode_sort_may_be_useful___0(sp->fts_cwd_fd);
        }
#line 1654
        if (tmp___25) {
          {
#line 1658
          sp->fts_compar = & fts_compare_ino___0;
#line 1659
          head = fts_sort___0(sp, head, nitems);
#line 1660
          sp->fts_compar = (int (*)(struct _ftsent  const  ** , struct _ftsent  const  ** ))((void *)0);
          }
        }
      }
    }
  }
#line 1664
  if (sp->fts_compar) {
#line 1664
    if (nitems > 1UL) {
      {
#line 1665
      head = fts_sort___0(sp, head, nitems);
      }
    }
  }
#line 1666
  return (head);
}
}
#line 1813 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static unsigned short fts_stat___0(FTS *sp , FTSENT *p , _Bool follow ) 
{ 
  struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1817
  sbp = p->fts_statp;
#line 1820
  if (p->fts_level == 0L) {
#line 1820
    if (sp->fts_options & 1) {
#line 1821
      follow = (_Bool)1;
    }
  }
#line 1828
  if (sp->fts_options & 2) {
#line 1828
    goto _L;
  } else
#line 1828
  if (follow) {
    _L: /* CIL Label */ 
    {
#line 1829
    tmp___3 = stat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
    }
#line 1829
    if (tmp___3) {
      {
#line 1830
      tmp = __errno_location();
#line 1830
      saved_errno = *tmp;
#line 1831
      tmp___1 = __errno_location();
      }
#line 1831
      if (*tmp___1 == 2) {
        {
#line 1831
        tmp___2 = lstat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
        }
#line 1831
        if (tmp___2 == 0) {
          {
#line 1833
          tmp___0 = __errno_location();
#line 1833
          *tmp___0 = 0;
          }
#line 1834
          return ((unsigned short)13);
        }
      }
#line 1836
      p->fts_errno = saved_errno;
#line 1837
      goto err;
    }
  } else {
    {
#line 1839
    tmp___5 = fstatat(sp->fts_cwd_fd, (char const   */* __restrict  */)p->fts_accpath,
                      (struct stat */* __restrict  */)sbp, 256);
    }
#line 1839
    if (tmp___5) {
      {
#line 1841
      tmp___4 = __errno_location();
#line 1841
      p->fts_errno = *tmp___4;
      }
      err: 
      {
#line 1842
      memset((void *)sbp, 0, sizeof(struct stat ));
      }
#line 1843
      return ((unsigned short)10);
    }
  }
#line 1846
  if ((sbp->st_mode & 61440U) == 16384U) {
#line 1847
    if (sp->fts_options & 32) {
#line 1847
      tmp___6 = 0;
    } else {
#line 1847
      tmp___6 = 2;
    }
#line 1847
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
#line 1849
    if ((int )p->fts_name[0] == 46) {
#line 1849
      if (! p->fts_name[1]) {
#line 1849
        goto _L___0;
      } else
#line 1849
      if ((int )p->fts_name[1] == 46) {
#line 1849
        if (! p->fts_name[2]) {
          _L___0: /* CIL Label */ 
#line 1851
          if (p->fts_level == 0L) {
#line 1851
            tmp___7 = 1;
          } else {
#line 1851
            tmp___7 = 5;
          }
#line 1851
          return ((unsigned short )tmp___7);
        }
      }
    }
#line 1854
    return ((unsigned short)1);
  }
#line 1856
  if ((sbp->st_mode & 61440U) == 40960U) {
#line 1857
    return ((unsigned short)12);
  }
#line 1858
  if ((sbp->st_mode & 61440U) == 32768U) {
#line 1859
    return ((unsigned short)8);
  }
#line 1860
  return ((unsigned short)3);
}
}
#line 1863 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static int fts_compar___0(void const   *a , void const   *b ) 
{ 
  FTSENT const   **pa ;
  FTSENT const   **pb ;
  int tmp ;

  {
  {
#line 1871
  pa = (FTSENT const   **)a;
#line 1872
  pb = (FTSENT const   **)b;
#line 1873
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
  }
#line 1873
  return (tmp);
}
}
#line 1876 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static FTSENT *fts_sort___0(FTS *sp , FTSENT *head , size_t nitems ) 
{ 
  register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare)(void const   * , void const   * ) ;
  int (*tmp)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;

  {
#line 1890
  if (sizeof(& dummy) == sizeof(void *)) {
#line 1890
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
#line 1890
      tmp = (int (*)(void const   * , void const   * ))sp->fts_compar;
    } else {
#line 1890
      tmp = & fts_compar___0;
    }
  } else {
#line 1890
    tmp = & fts_compar___0;
  }
#line 1890
  compare = tmp;
#line 1903
  if (nitems > sp->fts_nitems) {
#line 1906
    sp->fts_nitems = nitems + 40UL;
#line 1907
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
      {
#line 1910
      free((void *)sp->fts_array);
#line 1911
      sp->fts_array = (struct _ftsent **)((void *)0);
#line 1912
      sp->fts_nitems = (size_t )0;
      }
#line 1913
      return (head);
    } else {
      {
#line 1907
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
#line 1907
      a = (FTSENT **)tmp___0;
      }
#line 1907
      if (! a) {
        {
#line 1910
        free((void *)sp->fts_array);
#line 1911
        sp->fts_array = (struct _ftsent **)((void *)0);
#line 1912
        sp->fts_nitems = (size_t )0;
        }
#line 1913
        return (head);
      }
    }
#line 1915
    sp->fts_array = a;
  }
#line 1917
  ap = sp->fts_array;
#line 1917
  p = head;
  {
#line 1917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1917
    if (! p) {
#line 1917
      goto while_break;
    }
#line 1918
    tmp___1 = ap;
#line 1918
    ap ++;
#line 1918
    *tmp___1 = p;
#line 1917
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1919
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
#line 1920
  ap = sp->fts_array;
#line 1920
  head = *ap;
  }
  {
#line 1920
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1920
    nitems --;
#line 1920
    if (! nitems) {
#line 1920
      goto while_break___0;
    }
#line 1921
    (*(ap + 0))->fts_link = *(ap + 1);
#line 1920
    ap ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1922
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
#line 1923
  return (head);
}
}
#line 1926 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static FTSENT *fts_alloc___0(FTS *sp , char const   *name , size_t namelen ) 
{ 
  register FTSENT *p ;
  size_t len ;
  void *tmp ;

  {
  {
#line 1937
  len = ((((unsigned long )(& ((FTSENT *)0)->fts_name) + __alignof__(FTSENT )) - 1UL) + (namelen + 1UL)) & ~ (__alignof__(FTSENT ) - 1UL);
#line 1938
  tmp = malloc(len);
#line 1938
  p = (FTSENT *)tmp;
  }
#line 1938
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1939
    return ((FTSENT *)((void *)0));
  }
  {
#line 1942
  memcpy((void */* __restrict  */)(p->fts_name), (void const   */* __restrict  */)name,
         namelen);
#line 1943
  p->fts_name[namelen] = (char )'\000';
#line 1945
  p->fts_namelen = namelen;
#line 1946
  p->fts_fts = sp;
#line 1947
  p->fts_path = sp->fts_path;
#line 1948
  p->fts_errno = 0;
#line 1949
  p->fts_dirp = (DIR *)((void *)0);
#line 1950
  p->fts_flags = (unsigned short)0;
#line 1951
  p->fts_instr = (unsigned short)3;
#line 1952
  p->fts_number = 0L;
#line 1953
  p->fts_pointer = (void *)0;
  }
#line 1954
  return (p);
}
}
#line 1957 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void fts_lfree___0(FTSENT *head ) 
{ 
  register FTSENT *p ;

  {
  {
#line 1964
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1964
    p = head;
#line 1964
    if (! p) {
#line 1964
      goto while_break;
    }
#line 1965
    head = head->fts_link;
#line 1966
    if (p->fts_dirp) {
      {
#line 1967
      closedir(p->fts_dirp);
      }
    }
    {
#line 1968
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1970
  return;
}
}
#line 1979 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static _Bool fts_palloc___0(FTS *sp , size_t more ) 
{ 
  char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 1984
  new_len = (sp->fts_pathlen + more) + 256UL;
#line 1989
  if (new_len < sp->fts_pathlen) {
    {
#line 1990
    free((void *)sp->fts_path);
#line 1991
    sp->fts_path = (char *)((void *)0);
#line 1992
    tmp = __errno_location();
#line 1992
    *tmp = 36;
    }
#line 1993
    return ((_Bool)0);
  }
  {
#line 1995
  sp->fts_pathlen = new_len;
#line 1996
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
#line 1996
  p = (char *)tmp___0;
  }
#line 1997
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1998
    free((void *)sp->fts_path);
#line 1999
    sp->fts_path = (char *)((void *)0);
    }
#line 2000
    return ((_Bool)0);
  }
#line 2002
  sp->fts_path = p;
#line 2003
  return ((_Bool)1);
}
}
#line 2010 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static void fts_padjust___0(FTS *sp , FTSENT *head ) 
{ 
  FTSENT *p ;
  char *addr ;

  {
#line 2015
  addr = sp->fts_path;
#line 2025
  p = sp->fts_child;
  {
#line 2025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2025
    if (! p) {
#line 2025
      goto while_break;
    }
    {
#line 2026
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2026
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 2026
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 2026
      p->fts_path = addr;
#line 2026
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2025
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 2029
  p = head;
  {
#line 2029
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2029
    if (! (p->fts_level >= 0L)) {
#line 2029
      goto while_break___1;
    }
    {
#line 2030
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2030
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 2030
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 2030
      p->fts_path = addr;
#line 2030
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2031
    if (p->fts_link) {
#line 2031
      p = p->fts_link;
    } else {
#line 2031
      p = p->fts_parent;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2033
  return;
}
}
#line 2035 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static size_t __attribute__((__pure__))  fts_maxarglen___0(char * const  *argv ) 
{ 
  size_t len ;
  size_t max ;

  {
#line 2041
  max = (size_t )0;
  {
#line 2041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2041
    if (! *argv) {
#line 2041
      goto while_break;
    }
    {
#line 2042
    len = strlen((char const   *)*argv);
    }
#line 2042
    if (len > max) {
#line 2043
      max = len;
    }
#line 2041
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2044
  return ((size_t __attribute__((__pure__))  )(max + 1UL));
}
}
#line 2056 "/home/khheo/project/benchmark/grep-3.1/lib/fts.c"
static int fts_safe_changedir___0(FTS *sp , FTSENT *p , int fd , char const   *dir ) 
{ 
  int ret ;
  _Bool is_dotdot ;
  int tmp ;
  int tmp___0 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___1 ;
  struct stat sb ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int oerrno ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 2061
  if (dir) {
    {
#line 2061
    tmp = strcmp(dir, "..");
    }
#line 2061
    if (tmp == 0) {
#line 2061
      tmp___0 = 1;
    } else {
#line 2061
      tmp___0 = 0;
    }
  } else {
#line 2061
    tmp___0 = 0;
  }
#line 2061
  is_dotdot = (_Bool )tmp___0;
#line 2068
  if (sp->fts_options & 4) {
#line 2070
    if (sp->fts_options & 512) {
#line 2070
      if (0 <= fd) {
        {
#line 2071
        close(fd);
        }
      }
    }
#line 2072
    return (0);
  }
#line 2075
  if (fd < 0) {
#line 2075
    if (is_dotdot) {
#line 2075
      if (sp->fts_options & 512) {
        {
#line 2082
        tmp___1 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
        }
#line 2082
        if (! tmp___1) {
          {
#line 2086
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
#line 2087
          is_dotdot = (_Bool)1;
          }
#line 2088
          if (0 <= parent_fd) {
#line 2090
            fd = parent_fd;
#line 2091
            dir = (char const   *)((void *)0);
          }
        }
      }
    }
  }
#line 2096
  newfd = fd;
#line 2097
  if (fd < 0) {
    {
#line 2097
    newfd = diropen___0((FTS const   *)sp, dir);
    }
#line 2097
    if (newfd < 0) {
#line 2098
      return (-1);
    }
  }
#line 2107
  if (sp->fts_options & 2) {
#line 2107
    goto _L;
  } else
#line 2107
  if (dir) {
    {
#line 2107
    tmp___4 = strcmp(dir, "..");
    }
#line 2107
    if (tmp___4 == 0) {
      _L: /* CIL Label */ 
      {
#line 2111
      tmp___2 = fstat(newfd, & sb);
      }
#line 2111
      if (tmp___2) {
#line 2113
        ret = -1;
#line 2114
        goto bail;
      }
#line 2116
      if (p->fts_statp[0].st_dev != sb.st_dev) {
        {
#line 2119
        tmp___3 = __errno_location();
#line 2119
        *tmp___3 = 2;
#line 2120
        ret = -1;
        }
#line 2121
        goto bail;
      } else
#line 2116
      if (p->fts_statp[0].st_ino != sb.st_ino) {
        {
#line 2119
        tmp___3 = __errno_location();
#line 2119
        *tmp___3 = 2;
#line 2120
        ret = -1;
        }
#line 2121
        goto bail;
      }
    }
  }
#line 2125
  if (sp->fts_options & 512) {
    {
#line 2127
    cwd_advance_fd___0(sp, newfd, (_Bool )(! is_dotdot));
    }
#line 2128
    return (0);
  }
  {
#line 2131
  ret = fchdir(newfd);
  }
  bail: 
#line 2133
  if (fd < 0) {
    {
#line 2135
    tmp___5 = __errno_location();
#line 2135
    oerrno = *tmp___5;
#line 2136
    close(newfd);
#line 2137
    tmp___6 = __errno_location();
#line 2137
    *tmp___6 = oerrno;
    }
  }
#line 2139
  return (ret);
}
}
#line 37 "/home/khheo/project/benchmark/grep-3.1/lib/filenamecat-lgpl.c"
static char const   * __attribute__((__pure__)) longest_relative_suffix___0(char const   *f ) 
{ 


  {
#line 40
  f += 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! ((int const   )*f == 47)) {
#line 40
      goto while_break;
    }
#line 41
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 40
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((char const   */* __attribute__((__pure__)) */)f);
}
}
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 599
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 339 "/home/khheo/project/benchmark/grep-3.1/lib/fcntl.c"
static int have_dupfd_cloexec___0  =    0;
#line 82 "./wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.1/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.1/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 179 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static void unescape_pattern___0(char *str ) 
{ 
  char const   *q ;
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 182
  q = (char const   *)str;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if ((int const   )*q == 92) {
#line 184
      if (*(q + 1)) {
#line 184
        tmp = 1;
      } else {
#line 184
        tmp = 0;
      }
    } else {
#line 184
      tmp = 0;
    }
#line 184
    q += tmp;
#line 183
    tmp___0 = str;
#line 183
    str ++;
#line 183
    tmp___2 = q;
#line 183
    q ++;
#line 183
    tmp___1 = (char )*tmp___2;
#line 183
    *tmp___0 = tmp___1;
#line 183
    if (! tmp___1) {
#line 183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 197 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static size_t string_hasher___0(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  size_t tmp ;

  {
  {
#line 200
  p = (char const   *)data;
#line 201
  tmp = hash_string(p, n_buckets);
  }
#line 201
  return (tmp);
}
}
#line 205 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static size_t string_hasher_ci___0(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  mbui_iterator_t iter ;
  size_t value ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;

  {
  {
#line 208
  p = (char const   *)data;
#line 210
  value = (size_t )0;
#line 212
  iter.cur.ptr = p;
#line 212
  iter.in_shift = (_Bool)0;
#line 212
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 212
  iter.next_done = (_Bool)0;
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    mbuiter_multi_next(& iter);
    }
#line 212
    if (iter.cur.wc_valid) {
#line 212
      if (iter.cur.wc == 0) {
#line 212
        tmp___0 = 0;
      } else {
#line 212
        tmp___0 = 1;
      }
    } else {
#line 212
      tmp___0 = 1;
    }
#line 212
    if (! tmp___0) {
#line 212
      goto while_break;
    }
#line 214
    m = iter.cur;
#line 217
    if (m.wc_valid) {
      {
#line 218
      tmp = towlower((wint_t )m.wc);
#line 218
      wc = (wchar_t )tmp;
      }
    } else {
#line 220
      wc = (wchar_t )*(m.ptr);
    }
#line 222
    value = (value * 31UL + (size_t )wc) % n_buckets;
#line 212
    iter.cur.ptr += iter.cur.bytes;
#line 212
    iter.next_done = (_Bool)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return (value);
}
}
#line 229 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static _Bool string_compare___0(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 232
  p1 = (char const   *)data1;
#line 233
  p2 = (char const   *)data2;
#line 234
  tmp = strcmp(p1, p2);
  }
#line 234
  return ((_Bool )(tmp == 0));
}
}
#line 238 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static _Bool string_compare_ci___0(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 241
  p1 = (char const   *)data1;
#line 242
  p2 = (char const   *)data2;
#line 243
  tmp = mbscasecmp(p1, p2);
  }
#line 243
  return ((_Bool )(tmp == 0));
}
}
#line 246 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static void string_free___0(void *data ) 
{ 


  {
  {
#line 249
  free(data);
  }
#line 250
  return;
}
}
#line 254 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static void new_exclude_segment___0(struct exclude *ex , enum exclude_type type ,
                                    int options ) 
{ 
  struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const   *data1 , void const   *data2 ) ;
  size_t (*tmp___1)(void const   *data , size_t n_buckets ) ;

  {
  {
#line 257
  tmp = xzalloc(sizeof(struct exclude_segment ));
#line 257
  sp = (struct exclude_segment *)tmp;
#line 258
  sp->type = type;
#line 259
  sp->options = options;
  }
  {
#line 262
  if ((unsigned int )type == 1U) {
#line 262
    goto case_1;
  }
#line 265
  if ((unsigned int )type == 0U) {
#line 265
    goto case_0;
  }
#line 260
  goto switch_break;
  case_1: /* CIL Label */ 
#line 263
  goto switch_break;
  case_0: /* CIL Label */ 
#line 266
  if (options & (1 << 4)) {
#line 266
    tmp___0 = & string_compare_ci___0;
  } else {
#line 266
    tmp___0 = & string_compare___0;
  }
#line 266
  if (options & (1 << 4)) {
#line 266
    tmp___1 = & string_hasher_ci___0;
  } else {
#line 266
    tmp___1 = & string_hasher___0;
  }
  {
#line 266
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0), tmp___1,
                                tmp___0, & string_free___0);
  }
#line 274
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 276
  sp->next = ex->head;
#line 277
  ex->head = sp;
#line 278
  return;
}
}
#line 281 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static void free_exclude_segment___0(struct exclude_segment *seg ) 
{ 
  size_t i ;

  {
  {
#line 288
  if ((unsigned int )seg->type == 1U) {
#line 288
    goto case_1;
  }
#line 297
  if ((unsigned int )seg->type == 0U) {
#line 297
    goto case_0;
  }
#line 286
  goto switch_break;
  case_1: /* CIL Label */ 
#line 289
  i = (size_t )0;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (i < seg->v.pat.exclude_count)) {
#line 289
      goto while_break;
    }
#line 291
    if ((seg->v.pat.exclude + i)->options & (1 << 27)) {
      {
#line 292
      regfree(& (seg->v.pat.exclude + i)->v.re);
      }
    }
#line 289
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  free((void *)seg->v.pat.exclude);
  }
#line 295
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 298
  hash_free(seg->v.table);
  }
#line 299
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 301
  free((void *)seg);
  }
#line 302
  return;
}
}
#line 332 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static int fnmatch_no_wildcards___0(char const   *pattern , char const   *f , int options ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t patlen ;
  size_t tmp___2 ;
  int r ;
  int tmp___3 ;
  char *fcopy ;
  char *tmp___4 ;
  char *p ;
  int r___0 ;
  char *tmp___5 ;

  {
#line 335
  if (! (options & (1 << 3))) {
#line 336
    if (options & (1 << 4)) {
      {
#line 336
      tmp = mbscasecmp(pattern, f);
#line 336
      tmp___1 = tmp;
      }
    } else {
      {
#line 336
      tmp___0 = strcmp(pattern, f);
#line 336
      tmp___1 = tmp___0;
      }
    }
#line 336
    return (tmp___1);
  } else
#line 339
  if (! (options & (1 << 4))) {
    {
#line 341
    tmp___2 = strlen(pattern);
#line 341
    patlen = tmp___2;
#line 342
    tmp___3 = strncmp(pattern, f, patlen);
#line 342
    r = tmp___3;
    }
#line 343
    if (! r) {
#line 345
      r = (int )*(f + patlen);
#line 346
      if (r == 47) {
#line 347
        r = 0;
      }
    }
#line 349
    return (r);
  } else {
    {
#line 360
    tmp___4 = xstrdup(f);
#line 360
    fcopy = tmp___4;
#line 363
    p = fcopy;
    }
    {
#line 363
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 365
      p = strchr((char const   *)p, '/');
      }
#line 366
      if (p) {
#line 367
        *p = (char )'\000';
      }
      {
#line 368
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
      }
#line 369
      if (! p) {
#line 370
        goto while_break;
      } else
#line 369
      if (r___0 <= 0) {
#line 370
        goto while_break;
      }
#line 363
      tmp___5 = p;
#line 363
      p ++;
#line 363
      *tmp___5 = (char )'/';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 372
    free((void *)fcopy);
    }
#line 373
    return (r___0);
  }
}
}
#line 395 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static _Bool exclude_patopts___0(struct patopts  const  *opts , char const   *f ) 
{ 
  int options ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
#line 398
  options = (int )opts->options;
#line 400
  if (options & (1 << 27)) {
    {
#line 400
    tmp = regexec((regex_t const   */* __restrict  */)(& opts->v.re), (char const   */* __restrict  */)f,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
#line 400
    tmp___1 = tmp == 0;
    }
  } else {
    {
#line 400
    tmp___0 = exclude_fnmatch((char const   *)opts->v.pattern, f, options);
#line 400
    tmp___1 = (int )tmp___0;
    }
  }
#line 400
  return ((_Bool )tmp___1);
}
}
#line 407 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static _Bool file_pattern_matches___0(struct exclude_segment  const  *seg , char const   *f ) 
{ 
  size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  _Bool tmp ;

  {
#line 410
  exclude_count = (size_t )seg->v.pat.exclude_count;
#line 411
  exclude = (struct patopts  const  *)seg->v.pat.exclude;
#line 414
  i = (size_t )0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i < exclude_count)) {
#line 414
      goto while_break;
    }
    {
#line 416
    tmp = exclude_patopts___0(exclude + i, f);
    }
#line 416
    if (tmp) {
#line 417
      return ((_Bool)1);
    }
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return ((_Bool)0);
}
}
#line 425 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static _Bool file_name_matches___0(struct exclude_segment  const  *seg , char const   *f ,
                                   char *buffer___0 ) 
{ 
  int options ;
  Hash_table *table ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 429
  options = (int )seg->options;
#line 430
  table = (Hash_table *)seg->v.table;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 435
    strcpy((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)f);
    }
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 439
      tmp = hash_lookup((Hash_table const   *)table, (void const   *)buffer___0);
      }
#line 439
      if (tmp) {
#line 440
        return ((_Bool)1);
      }
#line 441
      if (options & (1 << 3)) {
        {
#line 443
        tmp___0 = strrchr((char const   *)buffer___0, '/');
#line 443
        p = tmp___0;
        }
#line 444
        if (p) {
#line 446
          *p = (char)0;
#line 447
          goto while_continue___0;
        }
      }
#line 450
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 453
    if (! (options & (1 << 30))) {
      {
#line 455
      tmp___1 = strchr(f, '/');
#line 455
      f = (char const   *)tmp___1;
      }
#line 456
      if (f) {
#line 457
        f ++;
      }
    } else {
#line 460
      goto while_break;
    }
#line 432
    if (! f) {
#line 432
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  return ((_Bool)0);
}
}
#line 668 "/home/khheo/project/benchmark/grep-3.1/lib/exclude.c"
static void call_addfn___0(struct exclude *ex , char const   *pattern , int options ,
                           void *data ) 
{ 
  void (**addfnptr)(struct exclude * , char const   * , int  ) ;

  {
  {
#line 671
  addfnptr = (void (**)(struct exclude * , char const   * , int  ))data;
#line 672
  (*(*addfnptr))(ex, pattern, options);
  }
#line 673
  return;
}
}
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool streq___0(char const   *a , char const   *b ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = strcmp(a, b);
  }
#line 39
  return ((_Bool )(tmp == 0));
}
}
#line 42 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool isasciidigit___0(char c ) 
{ 
  int tmp ;

  {
#line 45
  if (48 <= (int )c) {
#line 45
    if ((int )c <= 57) {
#line 45
      tmp = 1;
    } else {
#line 45
      tmp = 0;
    }
  } else {
#line 45
    tmp = 0;
  }
#line 45
  return ((_Bool )tmp);
}
}
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 104 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static unsigned long const   CHARCLASS_WORD_MASK___0  =    (charclass_word const   )(((1UL << 63) << 1) - 1UL);
#line 119 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static unsigned char to_uchar___1(char ch ) 
{ 


  {
#line 122
  return ((unsigned char )ch);
}
}
#line 160 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int newline_constraint___0(int constraint ) 
{ 


  {
#line 163
  return ((constraint >> 6) & 7);
}
}
#line 165 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int letter_constraint___0(int constraint ) 
{ 


  {
#line 168
  return ((constraint >> 3) & 7);
}
}
#line 170 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int other_constraint___0(int constraint ) 
{ 


  {
#line 173
  return (constraint & 7);
}
}
#line 176 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool succeeds_in_context___0(int constraint , int prev , int curr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 179
  if (curr & 1) {
    {
#line 179
    tmp = other_constraint___0(constraint);
#line 179
    tmp___0 = tmp;
    }
  } else {
#line 179
    tmp___0 = 0;
  }
#line 179
  if (curr & 2) {
    {
#line 179
    tmp___1 = letter_constraint___0(constraint);
#line 179
    tmp___2 = tmp___1;
    }
  } else {
#line 179
    tmp___2 = 0;
  }
#line 179
  if (curr & 4) {
    {
#line 179
    tmp___3 = newline_constraint___0(constraint);
#line 179
    tmp___4 = tmp___3;
    }
  } else {
#line 179
    tmp___4 = 0;
  }
#line 179
  if (((tmp___0 | tmp___2) | tmp___4) & prev) {
#line 179
    tmp___5 = 1;
  } else {
#line 179
    tmp___5 = 0;
  }
#line 179
  return ((_Bool )tmp___5);
}
}
#line 186 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool prev_newline_dependent___0(int constraint ) 
{ 


  {
#line 189
  return ((_Bool )(((constraint ^ (constraint >> 2)) & 73) != 0));
}
}
#line 191 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool prev_letter_dependent___0(int constraint ) 
{ 


  {
#line 194
  return ((_Bool )(((constraint ^ (constraint >> 1)) & 73) != 0));
}
}
#line 217 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static long const   TOKEN_MAX___0  =    (ptrdiff_t const   )9223372036854775807L;
#line 574 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool accepting___0(state_num s , struct dfa  const  *r ) 
{ 


  {
#line 577
  return ((_Bool )((int )(r->states + s)->constraint != 0));
}
}
#line 581 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool accepts_in_context___0(int prev , int curr , state_num state , struct dfa  const  *dfa ) 
{ 
  _Bool tmp ;

  {
  {
#line 584
  tmp = succeeds_in_context___0((int )(dfa->states + state)->constraint, prev, curr);
  }
#line 584
  return (tmp);
}
}
#line 587
static void regexp___0(struct dfa *dfa ) ;
#line 606 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static size_t mbs_to_wchar___0(wint_t *pwc , char const   *s , size_t n , struct dfa *d ) 
{ 
  unsigned char uc ;
  wint_t wc ;
  wchar_t wch ;
  size_t nbytes ;
  size_t tmp ;

  {
#line 609
  uc = (unsigned char )*(s + 0);
#line 610
  wc = d->localeinfo.sbctowc[uc];
#line 612
  if (wc == 4294967295U) {
    {
#line 615
    tmp = rpl_mbrtowc(& wch, s, n, & d->mbs);
#line 615
    nbytes = tmp;
    }
#line 616
    if (0UL < nbytes) {
#line 616
      if (nbytes < 0xfffffffffffffffeUL) {
#line 618
        *pwc = (wint_t )wch;
#line 619
        return (nbytes);
      }
    }
    {
#line 621
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
  }
#line 624
  *pwc = wc;
#line 625
  return ((size_t )1);
}
}
#line 707 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool tstbit___0(unsigned int b , charclass const   *c ) 
{ 


  {
#line 710
  return ((_Bool )((c->w[b / 64U] >> b % 64U) & 1UL));
}
}
#line 713 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void setbit___0(unsigned int b , charclass *c ) 
{ 
  charclass_word one ;

  {
#line 716
  one = (charclass_word )1;
#line 717
  c->w[b / 64U] |= one << b % 64U;
#line 718
  return;
}
}
#line 720 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void clrbit___0(unsigned int b , charclass *c ) 
{ 
  charclass_word one ;

  {
#line 723
  one = (charclass_word )1;
#line 724
  c->w[b / 64U] &= ~ (one << b % 64U);
#line 725
  return;
}
}
#line 727 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void zeroset___0(charclass *s ) 
{ 


  {
  {
#line 730
  memset((void *)s, 0, sizeof(*s));
  }
#line 731
  return;
}
}
#line 733 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void fillset___0(charclass *s ) 
{ 
  int i ;

  {
#line 736
  i = 0;
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (! (i < 4)) {
#line 736
      goto while_break;
    }
#line 737
    s->w[i] = (charclass_word )CHARCLASS_WORD_MASK___0;
#line 736
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 738
  return;
}
}
#line 740 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void notset___0(charclass *s ) 
{ 
  int i ;

  {
#line 743
  i = 0;
  {
#line 743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 743
    if (! (i < 4)) {
#line 743
      goto while_break;
    }
#line 744
    s->w[i] = (charclass_word )(CHARCLASS_WORD_MASK___0 & (unsigned long const   )(~ s->w[i]));
#line 743
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 745
  return;
}
}
#line 747 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool equal___0(charclass const   *s1 , charclass const   *s2 ) 
{ 
  charclass_word w ;
  int i ;

  {
#line 750
  w = (charclass_word )0;
#line 751
  i = 0;
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 751
    if (! (i < 4)) {
#line 751
      goto while_break;
    }
#line 752
    w |= s1->w[i] ^ s2->w[i];
#line 751
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 753
  return ((_Bool )(w == 0UL));
}
}
#line 756 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool emptyset___0(charclass const   *s ) 
{ 
  charclass_word w ;
  int i ;

  {
#line 759
  w = (charclass_word )0;
#line 760
  i = 0;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! (i < 4)) {
#line 760
      goto while_break;
    }
#line 761
    w |= s->w[i];
#line 760
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 762
  return ((_Bool )(w == 0UL));
}
}
#line 781 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void *xpalloc___0(void *pa , ptrdiff_t *nitems , ptrdiff_t nitems_incr_min ,
                         ptrdiff_t nitems_max , ptrdiff_t item_size ) 
{ 
  ptrdiff_t n0 ;
  ptrdiff_t n ;
  ptrdiff_t nbytes ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  ptrdiff_t adjusted_nbytes ;
  int tmp___217 ;
  unsigned long tmp___218 ;
  int tmp___224 ;
  int tmp___225 ;
  int tmp___226 ;
  int tmp___227 ;
  int tmp___228 ;
  int tmp___229 ;
  int tmp___235 ;
  int tmp___236 ;
  int tmp___237 ;
  int tmp___238 ;
  int tmp___239 ;
  int tmp___240 ;
  int tmp___241 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  int tmp___251 ;
  int tmp___252 ;
  int tmp___258 ;
  int tmp___259 ;
  int tmp___260 ;
  int tmp___261 ;
  int tmp___262 ;
  int tmp___263 ;
  int tmp___264 ;
  int tmp___270 ;
  int tmp___271 ;
  int tmp___272 ;
  int tmp___273 ;
  int tmp___274 ;
  int tmp___275 ;
  int tmp___281 ;
  int tmp___282 ;
  int tmp___283 ;
  int tmp___284 ;
  int tmp___285 ;
  int tmp___286 ;
  int tmp___287 ;
  int tmp___293 ;
  int tmp___294 ;
  int tmp___295 ;
  int tmp___296 ;
  int tmp___297 ;
  int tmp___298 ;
  int tmp___304 ;
  int tmp___305 ;
  int tmp___306 ;
  int tmp___307 ;
  int tmp___308 ;
  int tmp___309 ;
  int tmp___310 ;
  int tmp___316 ;
  int tmp___317 ;
  int tmp___318 ;
  int tmp___319 ;
  int tmp___320 ;
  int tmp___321 ;
  int tmp___327 ;
  int tmp___328 ;
  int tmp___329 ;
  int tmp___330 ;
  int tmp___331 ;
  int tmp___332 ;
  int tmp___333 ;
  int tmp___334 ;
  int tmp___335 ;
  int tmp___336 ;
  int tmp___337 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___344 ;
  int tmp___345 ;
  int tmp___346 ;
  int tmp___351 ;
  int tmp___352 ;
  int tmp___353 ;
  int tmp___354 ;
  int tmp___355 ;
  int tmp___356 ;
  int tmp___361 ;
  int tmp___362 ;
  int tmp___363 ;
  int tmp___364 ;
  int tmp___365 ;
  int tmp___370 ;
  int tmp___371 ;
  int tmp___372 ;
  int tmp___373 ;
  int tmp___374 ;
  int tmp___375 ;
  int tmp___380 ;
  int tmp___381 ;
  int tmp___382 ;
  int tmp___383 ;
  int tmp___384 ;
  int tmp___389 ;
  int tmp___390 ;
  int tmp___391 ;
  int tmp___392 ;
  int tmp___393 ;
  int tmp___394 ;
  int tmp___399 ;
  int tmp___400 ;
  int tmp___401 ;
  int tmp___402 ;
  int tmp___403 ;
  int tmp___408 ;
  int tmp___409 ;
  int tmp___410 ;
  int tmp___411 ;
  int tmp___412 ;
  int tmp___413 ;
  int tmp___418 ;
  int tmp___419 ;
  int tmp___420 ;
  int tmp___421 ;
  int tmp___422 ;
  int tmp___427 ;
  int tmp___428 ;
  int tmp___429 ;
  int tmp___430 ;
  int tmp___431 ;
  int tmp___432 ;
  int tmp___433 ;
  int tmp___434 ;
  int tmp___435 ;
  int tmp___436 ;
  int tmp___442 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___445 ;
  int tmp___446 ;
  int tmp___447 ;
  int tmp___453 ;
  int tmp___454 ;
  int tmp___455 ;
  int tmp___456 ;
  int tmp___457 ;
  int tmp___458 ;
  int tmp___459 ;
  int tmp___465 ;
  int tmp___466 ;
  int tmp___467 ;
  int tmp___468 ;
  int tmp___469 ;
  int tmp___470 ;
  int tmp___476 ;
  int tmp___477 ;
  int tmp___478 ;
  int tmp___479 ;
  int tmp___480 ;
  int tmp___481 ;
  int tmp___482 ;
  int tmp___488 ;
  int tmp___489 ;
  int tmp___490 ;
  int tmp___491 ;
  int tmp___492 ;
  int tmp___493 ;
  int tmp___499 ;
  int tmp___500 ;
  int tmp___501 ;
  int tmp___502 ;
  int tmp___503 ;
  int tmp___504 ;
  int tmp___505 ;
  int tmp___511 ;
  int tmp___512 ;
  int tmp___513 ;
  int tmp___514 ;
  int tmp___515 ;
  int tmp___516 ;
  int tmp___522 ;
  int tmp___523 ;
  int tmp___524 ;
  int tmp___525 ;
  int tmp___526 ;
  int tmp___527 ;
  int tmp___528 ;
  int tmp___534 ;
  int tmp___535 ;
  int tmp___536 ;
  int tmp___537 ;
  int tmp___538 ;
  int tmp___539 ;
  int tmp___545 ;
  int tmp___546 ;
  int tmp___547 ;
  int tmp___548 ;
  int tmp___549 ;
  int tmp___550 ;
  int tmp___551 ;
  int tmp___552 ;
  int tmp___553 ;
  int tmp___554 ;
  int tmp___555 ;

  {
#line 785
  n0 = *nitems;
#line 798
  if (sizeof(n) == sizeof(signed char )) {
#line 798
    if (sizeof(n0 + (n0 >> 1)) < sizeof(signed char )) {
#line 798
      if (~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 798
        if ((int )((signed char )(n0 >> 1)) < 0) {
#line 798
          tmp___4 = (int )((signed char )n0) < ~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )(n0 >> 1));
        } else {
#line 798
          tmp___4 = (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )(n0 >> 1)) < (int )((signed char )n0);
        }
#line 798
        tmp___7 = tmp___4;
      } else {
#line 798
        if ((int )((signed char )n0) < 0) {
#line 798
          tmp___6 = (int )((signed char )(n0 >> 1)) <= (int )((signed char )n0) + (int )((signed char )(n0 >> 1));
        } else {
#line 798
          if ((int )((signed char )(n0 >> 1)) < 0) {
#line 798
            tmp___5 = (int )((signed char )n0) <= (int )((signed char )n0) + (int )((signed char )(n0 >> 1));
          } else {
#line 798
            tmp___5 = (int )((signed char )n0) + (int )((signed char )(n0 >> 1)) < (int )((signed char )(n0 >> 1));
          }
#line 798
          tmp___6 = tmp___5;
        }
#line 798
        tmp___7 = tmp___6;
      }
#line 798
      if (tmp___7) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )(n0 >> 1))));
#line 798
        tmp___3 = 1;
      } else
#line 798
      if ((int )((signed char )n0) + (int )((signed char )(n0 >> 1)) < -128) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )(n0 >> 1))));
#line 798
        tmp___3 = 1;
      } else
#line 798
      if (127 < (int )((signed char )n0) + (int )((signed char )(n0 >> 1))) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )(n0 >> 1))));
#line 798
        tmp___3 = 1;
      } else {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )(n0 >> 1))));
#line 798
        tmp___3 = 0;
      }
#line 798
      tmp___17 = tmp___3;
    } else {
#line 798
      if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
        if (n0 >> 1 < 0L) {
#line 798
          tmp___13 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
        } else {
#line 798
          tmp___13 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
        }
#line 798
        tmp___16 = tmp___13;
      } else {
#line 798
        if (n0 < 0L) {
#line 798
          tmp___15 = n0 >> 1 <= n0 + (n0 >> 1);
        } else {
#line 798
          if (n0 >> 1 < 0L) {
#line 798
            tmp___14 = n0 <= n0 + (n0 >> 1);
          } else {
#line 798
            tmp___14 = n0 + (n0 >> 1) < n0 >> 1;
          }
#line 798
          tmp___15 = tmp___14;
        }
#line 798
        tmp___16 = tmp___15;
      }
#line 798
      if (tmp___16) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
        tmp___12 = 1;
      } else
#line 798
      if (n0 + (n0 >> 1) < -128L) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
        tmp___12 = 1;
      } else
#line 798
      if (127L < n0 + (n0 >> 1)) {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
        tmp___12 = 1;
      } else {
#line 798
        n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
        tmp___12 = 0;
      }
#line 798
      tmp___17 = tmp___12;
    }
#line 798
    tmp___97 = tmp___17;
  } else {
#line 798
    if (sizeof(n) == sizeof(short )) {
#line 798
      if (sizeof(n0 + (n0 >> 1)) < sizeof(short )) {
#line 798
        if (~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 798
          if ((int )((short )(n0 >> 1)) < 0) {
#line 798
            tmp___23 = (int )((short )n0) < ~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )(n0 >> 1));
          } else {
#line 798
            tmp___23 = (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )(n0 >> 1)) < (int )((short )n0);
          }
#line 798
          tmp___26 = tmp___23;
        } else {
#line 798
          if ((int )((short )n0) < 0) {
#line 798
            tmp___25 = (int )((short )(n0 >> 1)) <= (int )((short )n0) + (int )((short )(n0 >> 1));
          } else {
#line 798
            if ((int )((short )(n0 >> 1)) < 0) {
#line 798
              tmp___24 = (int )((short )n0) <= (int )((short )n0) + (int )((short )(n0 >> 1));
            } else {
#line 798
              tmp___24 = (int )((short )n0) + (int )((short )(n0 >> 1)) < (int )((short )(n0 >> 1));
            }
#line 798
            tmp___25 = tmp___24;
          }
#line 798
          tmp___26 = tmp___25;
        }
#line 798
        if (tmp___26) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )(n0 >> 1))));
#line 798
          tmp___22 = 1;
        } else
#line 798
        if ((int )((short )n0) + (int )((short )(n0 >> 1)) < -32768) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )(n0 >> 1))));
#line 798
          tmp___22 = 1;
        } else
#line 798
        if (32767 < (int )((short )n0) + (int )((short )(n0 >> 1))) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )(n0 >> 1))));
#line 798
          tmp___22 = 1;
        } else {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )(n0 >> 1))));
#line 798
          tmp___22 = 0;
        }
#line 798
        tmp___36 = tmp___22;
      } else {
#line 798
        if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
          if (n0 >> 1 < 0L) {
#line 798
            tmp___32 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
          } else {
#line 798
            tmp___32 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
          }
#line 798
          tmp___35 = tmp___32;
        } else {
#line 798
          if (n0 < 0L) {
#line 798
            tmp___34 = n0 >> 1 <= n0 + (n0 >> 1);
          } else {
#line 798
            if (n0 >> 1 < 0L) {
#line 798
              tmp___33 = n0 <= n0 + (n0 >> 1);
            } else {
#line 798
              tmp___33 = n0 + (n0 >> 1) < n0 >> 1;
            }
#line 798
            tmp___34 = tmp___33;
          }
#line 798
          tmp___35 = tmp___34;
        }
#line 798
        if (tmp___35) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
          tmp___31 = 1;
        } else
#line 798
        if (n0 + (n0 >> 1) < -32768L) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
          tmp___31 = 1;
        } else
#line 798
        if (32767L < n0 + (n0 >> 1)) {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
          tmp___31 = 1;
        } else {
#line 798
          n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
          tmp___31 = 0;
        }
#line 798
        tmp___36 = tmp___31;
      }
#line 798
      tmp___96 = tmp___36;
    } else {
#line 798
      if (sizeof(n) == sizeof(int )) {
#line 798
        if (sizeof(n0 + (n0 >> 1)) < sizeof(int )) {
#line 798
          if (~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 798
            if ((int )(n0 >> 1) < 0) {
#line 798
              tmp___42 = (int )n0 < ~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )(n0 >> 1);
            } else {
#line 798
              tmp___42 = (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )(n0 >> 1) < (int )n0;
            }
#line 798
            tmp___45 = tmp___42;
          } else {
#line 798
            if ((int )n0 < 0) {
#line 798
              tmp___44 = (int )(n0 >> 1) <= (int )n0 + (int )(n0 >> 1);
            } else {
#line 798
              if ((int )(n0 >> 1) < 0) {
#line 798
                tmp___43 = (int )n0 <= (int )n0 + (int )(n0 >> 1);
              } else {
#line 798
                tmp___43 = (int )n0 + (int )(n0 >> 1) < (int )(n0 >> 1);
              }
#line 798
              tmp___44 = tmp___43;
            }
#line 798
            tmp___45 = tmp___44;
          }
#line 798
          if (tmp___45) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
#line 798
            tmp___41 = 1;
          } else
#line 798
          if ((int )n0 + (int )(n0 >> 1) < (-0x7FFFFFFF-1)) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
#line 798
            tmp___41 = 1;
          } else
#line 798
          if (2147483647 < (int )n0 + (int )(n0 >> 1)) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
#line 798
            tmp___41 = 1;
          } else {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
#line 798
            tmp___41 = 0;
          }
#line 798
          tmp___55 = tmp___41;
        } else {
#line 798
          if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
            if (n0 >> 1 < 0L) {
#line 798
              tmp___51 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
            } else {
#line 798
              tmp___51 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
            }
#line 798
            tmp___54 = tmp___51;
          } else {
#line 798
            if (n0 < 0L) {
#line 798
              tmp___53 = n0 >> 1 <= n0 + (n0 >> 1);
            } else {
#line 798
              if (n0 >> 1 < 0L) {
#line 798
                tmp___52 = n0 <= n0 + (n0 >> 1);
              } else {
#line 798
                tmp___52 = n0 + (n0 >> 1) < n0 >> 1;
              }
#line 798
              tmp___53 = tmp___52;
            }
#line 798
            tmp___54 = tmp___53;
          }
#line 798
          if (tmp___54) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
            tmp___50 = 1;
          } else
#line 798
          if (n0 + (n0 >> 1) < (-0x7FFFFFFF-1)) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
            tmp___50 = 1;
          } else
#line 798
          if (2147483647L < n0 + (n0 >> 1)) {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
            tmp___50 = 1;
          } else {
#line 798
            n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
#line 798
            tmp___50 = 0;
          }
#line 798
          tmp___55 = tmp___50;
        }
#line 798
        tmp___95 = tmp___55;
      } else {
#line 798
        if (sizeof(n) == sizeof(long )) {
#line 798
          if (sizeof(n0 + (n0 >> 1)) < sizeof(long )) {
#line 798
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
              if (n0 >> 1 < 0L) {
#line 798
                tmp___61 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 798
                tmp___61 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 798
              tmp___64 = tmp___61;
            } else {
#line 798
              if (n0 < 0L) {
#line 798
                tmp___63 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 798
                if (n0 >> 1 < 0L) {
#line 798
                  tmp___62 = n0 <= n0 + (n0 >> 1);
                } else {
#line 798
                  tmp___62 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 798
                tmp___63 = tmp___62;
              }
#line 798
              tmp___64 = tmp___63;
            }
#line 798
            if (tmp___64) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___60 = 1;
            } else
#line 798
            if (n0 + (n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___60 = 1;
            } else
#line 798
            if (9223372036854775807L < n0 + (n0 >> 1)) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___60 = 1;
            } else {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___60 = 0;
            }
#line 798
            tmp___74 = tmp___60;
          } else {
#line 798
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
              if (n0 >> 1 < 0L) {
#line 798
                tmp___70 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 798
                tmp___70 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 798
              tmp___73 = tmp___70;
            } else {
#line 798
              if (n0 < 0L) {
#line 798
                tmp___72 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 798
                if (n0 >> 1 < 0L) {
#line 798
                  tmp___71 = n0 <= n0 + (n0 >> 1);
                } else {
#line 798
                  tmp___71 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 798
                tmp___72 = tmp___71;
              }
#line 798
              tmp___73 = tmp___72;
            }
#line 798
            if (tmp___73) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___69 = 1;
            } else
#line 798
            if (n0 + (n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___69 = 1;
            } else
#line 798
            if (9223372036854775807L < n0 + (n0 >> 1)) {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___69 = 1;
            } else {
#line 798
              n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
#line 798
              tmp___69 = 0;
            }
#line 798
            tmp___74 = tmp___69;
          }
#line 798
          tmp___94 = tmp___74;
        } else {
#line 798
          if (sizeof(n0 + (n0 >> 1)) < sizeof(long long )) {
#line 798
            if (~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 798
              if ((long long )(n0 >> 1) < 0LL) {
#line 798
                tmp___80 = (long long )n0 < ~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )(n0 >> 1);
              } else {
#line 798
                tmp___80 = (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )(n0 >> 1) < (long long )n0;
              }
#line 798
              tmp___83 = tmp___80;
            } else {
#line 798
              if ((long long )n0 < 0LL) {
#line 798
                tmp___82 = (long long )(n0 >> 1) <= (long long )n0 + (long long )(n0 >> 1);
              } else {
#line 798
                if ((long long )(n0 >> 1) < 0LL) {
#line 798
                  tmp___81 = (long long )n0 <= (long long )n0 + (long long )(n0 >> 1);
                } else {
#line 798
                  tmp___81 = (long long )n0 + (long long )(n0 >> 1) < (long long )(n0 >> 1);
                }
#line 798
                tmp___82 = tmp___81;
              }
#line 798
              tmp___83 = tmp___82;
            }
#line 798
            if (tmp___83) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
#line 798
              tmp___79 = 1;
            } else
#line 798
            if ((long long )n0 + (long long )(n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
#line 798
              tmp___79 = 1;
            } else
#line 798
            if (9223372036854775807LL < (long long )n0 + (long long )(n0 >> 1)) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
#line 798
              tmp___79 = 1;
            } else {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
#line 798
              tmp___79 = 0;
            }
#line 798
            tmp___93 = tmp___79;
          } else {
#line 798
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 798
              if (n0 >> 1 < 0L) {
#line 798
                tmp___89 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 798
                tmp___89 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 798
              tmp___92 = tmp___89;
            } else {
#line 798
              if (n0 < 0L) {
#line 798
                tmp___91 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 798
                if (n0 >> 1 < 0L) {
#line 798
                  tmp___90 = n0 <= n0 + (n0 >> 1);
                } else {
#line 798
                  tmp___90 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 798
                tmp___91 = tmp___90;
              }
#line 798
              tmp___92 = tmp___91;
            }
#line 798
            if (tmp___92) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
#line 798
              tmp___88 = 1;
            } else
#line 798
            if ((long long )(n0 + (n0 >> 1)) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
#line 798
              tmp___88 = 1;
            } else
#line 798
            if (9223372036854775807LL < (long long )(n0 + (n0 >> 1))) {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
#line 798
              tmp___88 = 1;
            } else {
#line 798
              n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
#line 798
              tmp___88 = 0;
            }
#line 798
            tmp___93 = tmp___88;
          }
#line 798
          tmp___94 = tmp___93;
        }
#line 798
        tmp___95 = tmp___94;
      }
#line 798
      tmp___96 = tmp___95;
    }
#line 798
    tmp___97 = tmp___96;
  }
#line 798
  if (tmp___97) {
#line 799
    n = 9223372036854775807L;
  }
#line 800
  if (0L <= nitems_max) {
#line 800
    if (nitems_max < n) {
#line 801
      n = nitems_max;
    }
  }
#line 803
  if (sizeof(nbytes) == sizeof(signed char )) {
#line 803
    if (sizeof(n * item_size) < sizeof(signed char )) {
#line 803
      if (~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 803
        if ((int )((signed char )n) < 0) {
#line 803
          if (0 < (int )((signed char )item_size)) {
#line 803
            nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
            tmp___224 = 1;
          } else {
#line 803
            goto _L___20;
          }
        } else
        _L___20: /* CIL Label */ 
#line 803
        if ((int )((signed char )item_size) < 0) {
#line 803
          if (0 < (int )((signed char )n)) {
#line 803
            nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
            tmp___224 = 1;
          } else {
#line 803
            goto _L___19;
          }
        } else {
#line 803
          goto _L___19;
        }
      } else {
        _L___19: /* CIL Label */ 
#line 803
        if ((int )((signed char )item_size) < 0) {
#line 803
          if ((int )((signed char )n) < 0) {
#line 803
            tmp___226 = (int )((signed char )n) < (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
          } else {
#line 803
            if ((int )((signed char )item_size) == -1) {
#line 803
              tmp___225 = 0;
            } else {
#line 803
              tmp___225 = ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
            }
#line 803
            tmp___226 = tmp___225;
          }
#line 803
          tmp___229 = tmp___226;
        } else {
#line 803
          if ((int )((signed char )item_size) == 0) {
#line 803
            tmp___228 = 0;
          } else {
#line 803
            if ((int )((signed char )n) < 0) {
#line 803
              tmp___227 = (int )((signed char )n) < ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
            } else {
#line 803
              tmp___227 = (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
            }
#line 803
            tmp___228 = tmp___227;
          }
#line 803
          tmp___229 = tmp___228;
        }
#line 803
        if (tmp___229) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
          tmp___224 = 1;
        } else
#line 803
        if ((int )((signed char )n) * (int )((signed char )item_size) < -128) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
          tmp___224 = 1;
        } else
#line 803
        if (127 < (int )((signed char )n) * (int )((signed char )item_size)) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
          tmp___224 = 1;
        } else {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 803
          tmp___224 = 0;
        }
      }
#line 803
      tmp___241 = tmp___224;
    } else {
#line 803
      if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
        if (n < 0L) {
#line 803
          if (0L < item_size) {
#line 803
            nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___235 = 1;
          } else {
#line 803
            goto _L___22;
          }
        } else
        _L___22: /* CIL Label */ 
#line 803
        if (item_size < 0L) {
#line 803
          if (0L < n) {
#line 803
            nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___235 = 1;
          } else {
#line 803
            goto _L___21;
          }
        } else {
#line 803
          goto _L___21;
        }
      } else {
        _L___21: /* CIL Label */ 
#line 803
        if (item_size < 0L) {
#line 803
          if (n < 0L) {
#line 803
            tmp___237 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
          } else {
#line 803
            if (item_size == -1L) {
#line 803
              tmp___236 = 0;
            } else {
#line 803
              tmp___236 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
            }
#line 803
            tmp___237 = tmp___236;
          }
#line 803
          tmp___240 = tmp___237;
        } else {
#line 803
          if (item_size == 0L) {
#line 803
            tmp___239 = 0;
          } else {
#line 803
            if (n < 0L) {
#line 803
              tmp___238 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
            } else {
#line 803
              tmp___238 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
            }
#line 803
            tmp___239 = tmp___238;
          }
#line 803
          tmp___240 = tmp___239;
        }
#line 803
        if (tmp___240) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
          tmp___235 = 1;
        } else
#line 803
        if (n * item_size < -128L) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
          tmp___235 = 1;
        } else
#line 803
        if (127L < n * item_size) {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
          tmp___235 = 1;
        } else {
#line 803
          nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 803
          tmp___235 = 0;
        }
      }
#line 803
      tmp___241 = tmp___235;
    }
#line 803
    tmp___337 = tmp___241;
  } else {
#line 803
    if (sizeof(nbytes) == sizeof(short )) {
#line 803
      if (sizeof(n * item_size) < sizeof(short )) {
#line 803
        if (~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 803
          if ((int )((short )n) < 0) {
#line 803
            if (0 < (int )((short )item_size)) {
#line 803
              nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
              tmp___247 = 1;
            } else {
#line 803
              goto _L___24;
            }
          } else
          _L___24: /* CIL Label */ 
#line 803
          if ((int )((short )item_size) < 0) {
#line 803
            if (0 < (int )((short )n)) {
#line 803
              nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
              tmp___247 = 1;
            } else {
#line 803
              goto _L___23;
            }
          } else {
#line 803
            goto _L___23;
          }
        } else {
          _L___23: /* CIL Label */ 
#line 803
          if ((int )((short )item_size) < 0) {
#line 803
            if ((int )((short )n) < 0) {
#line 803
              tmp___249 = (int )((short )n) < (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
            } else {
#line 803
              if ((int )((short )item_size) == -1) {
#line 803
                tmp___248 = 0;
              } else {
#line 803
                tmp___248 = ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
              }
#line 803
              tmp___249 = tmp___248;
            }
#line 803
            tmp___252 = tmp___249;
          } else {
#line 803
            if ((int )((short )item_size) == 0) {
#line 803
              tmp___251 = 0;
            } else {
#line 803
              if ((int )((short )n) < 0) {
#line 803
                tmp___250 = (int )((short )n) < ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
              } else {
#line 803
                tmp___250 = (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
              }
#line 803
              tmp___251 = tmp___250;
            }
#line 803
            tmp___252 = tmp___251;
          }
#line 803
          if (tmp___252) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
            tmp___247 = 1;
          } else
#line 803
          if ((int )((short )n) * (int )((short )item_size) < -32768) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
            tmp___247 = 1;
          } else
#line 803
          if (32767 < (int )((short )n) * (int )((short )item_size)) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
            tmp___247 = 1;
          } else {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 803
            tmp___247 = 0;
          }
        }
#line 803
        tmp___264 = tmp___247;
      } else {
#line 803
        if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
          if (n < 0L) {
#line 803
            if (0L < item_size) {
#line 803
              nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___258 = 1;
            } else {
#line 803
              goto _L___26;
            }
          } else
          _L___26: /* CIL Label */ 
#line 803
          if (item_size < 0L) {
#line 803
            if (0L < n) {
#line 803
              nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___258 = 1;
            } else {
#line 803
              goto _L___25;
            }
          } else {
#line 803
            goto _L___25;
          }
        } else {
          _L___25: /* CIL Label */ 
#line 803
          if (item_size < 0L) {
#line 803
            if (n < 0L) {
#line 803
              tmp___260 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
            } else {
#line 803
              if (item_size == -1L) {
#line 803
                tmp___259 = 0;
              } else {
#line 803
                tmp___259 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
              }
#line 803
              tmp___260 = tmp___259;
            }
#line 803
            tmp___263 = tmp___260;
          } else {
#line 803
            if (item_size == 0L) {
#line 803
              tmp___262 = 0;
            } else {
#line 803
              if (n < 0L) {
#line 803
                tmp___261 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 803
                tmp___261 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
              }
#line 803
              tmp___262 = tmp___261;
            }
#line 803
            tmp___263 = tmp___262;
          }
#line 803
          if (tmp___263) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___258 = 1;
          } else
#line 803
          if (n * item_size < -32768L) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___258 = 1;
          } else
#line 803
          if (32767L < n * item_size) {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___258 = 1;
          } else {
#line 803
            nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 803
            tmp___258 = 0;
          }
        }
#line 803
        tmp___264 = tmp___258;
      }
#line 803
      tmp___336 = tmp___264;
    } else {
#line 803
      if (sizeof(nbytes) == sizeof(int )) {
#line 803
        if (sizeof(n * item_size) < sizeof(int )) {
#line 803
          if (~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 803
            if ((int )n < 0) {
#line 803
              if (0 < (int )item_size) {
#line 803
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
                tmp___270 = 1;
              } else {
#line 803
                goto _L___28;
              }
            } else
            _L___28: /* CIL Label */ 
#line 803
            if ((int )item_size < 0) {
#line 803
              if (0 < (int )n) {
#line 803
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
                tmp___270 = 1;
              } else {
#line 803
                goto _L___27;
              }
            } else {
#line 803
              goto _L___27;
            }
          } else {
            _L___27: /* CIL Label */ 
#line 803
            if ((int )item_size < 0) {
#line 803
              if ((int )n < 0) {
#line 803
                tmp___272 = (int )n < (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
              } else {
#line 803
                if ((int )item_size == -1) {
#line 803
                  tmp___271 = 0;
                } else {
#line 803
                  tmp___271 = ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                }
#line 803
                tmp___272 = tmp___271;
              }
#line 803
              tmp___275 = tmp___272;
            } else {
#line 803
              if ((int )item_size == 0) {
#line 803
                tmp___274 = 0;
              } else {
#line 803
                if ((int )n < 0) {
#line 803
                  tmp___273 = (int )n < ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                } else {
#line 803
                  tmp___273 = (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                }
#line 803
                tmp___274 = tmp___273;
              }
#line 803
              tmp___275 = tmp___274;
            }
#line 803
            if (tmp___275) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
              tmp___270 = 1;
            } else
#line 803
            if ((int )n * (int )item_size < (-0x7FFFFFFF-1)) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
              tmp___270 = 1;
            } else
#line 803
            if (2147483647 < (int )n * (int )item_size) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
              tmp___270 = 1;
            } else {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 803
              tmp___270 = 0;
            }
          }
#line 803
          tmp___287 = tmp___270;
        } else {
#line 803
          if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
            if (n < 0L) {
#line 803
              if (0L < item_size) {
#line 803
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
                tmp___281 = 1;
              } else {
#line 803
                goto _L___30;
              }
            } else
            _L___30: /* CIL Label */ 
#line 803
            if (item_size < 0L) {
#line 803
              if (0L < n) {
#line 803
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
                tmp___281 = 1;
              } else {
#line 803
                goto _L___29;
              }
            } else {
#line 803
              goto _L___29;
            }
          } else {
            _L___29: /* CIL Label */ 
#line 803
            if (item_size < 0L) {
#line 803
              if (n < 0L) {
#line 803
                tmp___283 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 803
                if (item_size == -1L) {
#line 803
                  tmp___282 = 0;
                } else {
#line 803
                  tmp___282 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 803
                tmp___283 = tmp___282;
              }
#line 803
              tmp___286 = tmp___283;
            } else {
#line 803
              if (item_size == 0L) {
#line 803
                tmp___285 = 0;
              } else {
#line 803
                if (n < 0L) {
#line 803
                  tmp___284 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 803
                  tmp___284 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 803
                tmp___285 = tmp___284;
              }
#line 803
              tmp___286 = tmp___285;
            }
#line 803
            if (tmp___286) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___281 = 1;
            } else
#line 803
            if (n * item_size < (-0x7FFFFFFF-1)) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___281 = 1;
            } else
#line 803
            if (2147483647L < n * item_size) {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___281 = 1;
            } else {
#line 803
              nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 803
              tmp___281 = 0;
            }
          }
#line 803
          tmp___287 = tmp___281;
        }
#line 803
        tmp___335 = tmp___287;
      } else {
#line 803
        if (sizeof(nbytes) == sizeof(long )) {
#line 803
          if (sizeof(n * item_size) < sizeof(long )) {
#line 803
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
              if (n < 0L) {
#line 803
                if (0L < item_size) {
#line 803
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                  tmp___293 = 1;
                } else {
#line 803
                  goto _L___32;
                }
              } else
              _L___32: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (0L < n) {
#line 803
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                  tmp___293 = 1;
                } else {
#line 803
                  goto _L___31;
                }
              } else {
#line 803
                goto _L___31;
              }
            } else {
              _L___31: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (n < 0L) {
#line 803
                  tmp___295 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 803
                  if (item_size == -1L) {
#line 803
                    tmp___294 = 0;
                  } else {
#line 803
                    tmp___294 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___295 = tmp___294;
                }
#line 803
                tmp___298 = tmp___295;
              } else {
#line 803
                if (item_size == 0L) {
#line 803
                  tmp___297 = 0;
                } else {
#line 803
                  if (n < 0L) {
#line 803
                    tmp___296 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 803
                    tmp___296 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___297 = tmp___296;
                }
#line 803
                tmp___298 = tmp___297;
              }
#line 803
              if (tmp___298) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___293 = 1;
              } else
#line 803
              if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___293 = 1;
              } else
#line 803
              if (9223372036854775807L < n * item_size) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___293 = 1;
              } else {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___293 = 0;
              }
            }
#line 803
            tmp___310 = tmp___293;
          } else {
#line 803
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
              if (n < 0L) {
#line 803
                if (0L < item_size) {
#line 803
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                  tmp___304 = 1;
                } else {
#line 803
                  goto _L___34;
                }
              } else
              _L___34: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (0L < n) {
#line 803
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                  tmp___304 = 1;
                } else {
#line 803
                  goto _L___33;
                }
              } else {
#line 803
                goto _L___33;
              }
            } else {
              _L___33: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (n < 0L) {
#line 803
                  tmp___306 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 803
                  if (item_size == -1L) {
#line 803
                    tmp___305 = 0;
                  } else {
#line 803
                    tmp___305 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___306 = tmp___305;
                }
#line 803
                tmp___309 = tmp___306;
              } else {
#line 803
                if (item_size == 0L) {
#line 803
                  tmp___308 = 0;
                } else {
#line 803
                  if (n < 0L) {
#line 803
                    tmp___307 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 803
                    tmp___307 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___308 = tmp___307;
                }
#line 803
                tmp___309 = tmp___308;
              }
#line 803
              if (tmp___309) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___304 = 1;
              } else
#line 803
              if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___304 = 1;
              } else
#line 803
              if (9223372036854775807L < n * item_size) {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___304 = 1;
              } else {
#line 803
                nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 803
                tmp___304 = 0;
              }
            }
#line 803
            tmp___310 = tmp___304;
          }
#line 803
          tmp___334 = tmp___310;
        } else {
#line 803
          if (sizeof(n * item_size) < sizeof(long long )) {
#line 803
            if (~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 803
              if ((long long )n < 0LL) {
#line 803
                if (0LL < (long long )item_size) {
#line 803
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                  tmp___316 = 1;
                } else {
#line 803
                  goto _L___36;
                }
              } else
              _L___36: /* CIL Label */ 
#line 803
              if ((long long )item_size < 0LL) {
#line 803
                if (0LL < (long long )n) {
#line 803
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                  tmp___316 = 1;
                } else {
#line 803
                  goto _L___35;
                }
              } else {
#line 803
                goto _L___35;
              }
            } else {
              _L___35: /* CIL Label */ 
#line 803
              if ((long long )item_size < 0LL) {
#line 803
                if ((long long )n < 0LL) {
#line 803
                  tmp___318 = (long long )n < (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                } else {
#line 803
                  if ((long long )item_size == -1LL) {
#line 803
                    tmp___317 = 0;
                  } else {
#line 803
                    tmp___317 = ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                  }
#line 803
                  tmp___318 = tmp___317;
                }
#line 803
                tmp___321 = tmp___318;
              } else {
#line 803
                if ((long long )item_size == 0LL) {
#line 803
                  tmp___320 = 0;
                } else {
#line 803
                  if ((long long )n < 0LL) {
#line 803
                    tmp___319 = (long long )n < ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                  } else {
#line 803
                    tmp___319 = (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                  }
#line 803
                  tmp___320 = tmp___319;
                }
#line 803
                tmp___321 = tmp___320;
              }
#line 803
              if (tmp___321) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                tmp___316 = 1;
              } else
#line 803
              if ((long long )n * (long long )item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                tmp___316 = 1;
              } else
#line 803
              if (9223372036854775807LL < (long long )n * (long long )item_size) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                tmp___316 = 1;
              } else {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 803
                tmp___316 = 0;
              }
            }
#line 803
            tmp___333 = tmp___316;
          } else {
#line 803
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 803
              if (n < 0L) {
#line 803
                if (0L < item_size) {
#line 803
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                  tmp___327 = 1;
                } else {
#line 803
                  goto _L___38;
                }
              } else
              _L___38: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (0L < n) {
#line 803
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                  tmp___327 = 1;
                } else {
#line 803
                  goto _L___37;
                }
              } else {
#line 803
                goto _L___37;
              }
            } else {
              _L___37: /* CIL Label */ 
#line 803
              if (item_size < 0L) {
#line 803
                if (n < 0L) {
#line 803
                  tmp___329 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 803
                  if (item_size == -1L) {
#line 803
                    tmp___328 = 0;
                  } else {
#line 803
                    tmp___328 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___329 = tmp___328;
                }
#line 803
                tmp___332 = tmp___329;
              } else {
#line 803
                if (item_size == 0L) {
#line 803
                  tmp___331 = 0;
                } else {
#line 803
                  if (n < 0L) {
#line 803
                    tmp___330 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 803
                    tmp___330 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 803
                  tmp___331 = tmp___330;
                }
#line 803
                tmp___332 = tmp___331;
              }
#line 803
              if (tmp___332) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                tmp___327 = 1;
              } else
#line 803
              if ((long long )(n * item_size) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                tmp___327 = 1;
              } else
#line 803
              if (9223372036854775807LL < (long long )(n * item_size)) {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                tmp___327 = 1;
              } else {
#line 803
                nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 803
                tmp___327 = 0;
              }
            }
#line 803
            tmp___333 = tmp___327;
          }
#line 803
          tmp___334 = tmp___333;
        }
#line 803
        tmp___335 = tmp___334;
      }
#line 803
      tmp___336 = tmp___335;
    }
#line 803
    tmp___337 = tmp___336;
  }
#line 803
  if (tmp___337) {
#line 803
    tmp___218 = 9223372036854775807UL;
  } else
#line 803
  if (0xffffffffffffffffUL < (unsigned long )nbytes) {
#line 803
    tmp___218 = 9223372036854775807UL;
  } else {
#line 803
    if (nbytes < 128L) {
#line 803
      tmp___217 = 128;
    } else {
#line 803
      tmp___217 = 0;
    }
#line 803
    tmp___218 = (unsigned long )tmp___217;
  }
#line 803
  adjusted_nbytes = (ptrdiff_t )tmp___218;
#line 807
  if (adjusted_nbytes) {
#line 809
    n = adjusted_nbytes / item_size;
#line 810
    nbytes = adjusted_nbytes - adjusted_nbytes % item_size;
  }
#line 813
  if (! pa) {
#line 814
    *nitems = (ptrdiff_t )0;
  }
#line 815
  if (n - n0 < nitems_incr_min) {
#line 815
    if (sizeof(n) == sizeof(signed char )) {
#line 815
      if (sizeof(n0 + nitems_incr_min) < sizeof(signed char )) {
#line 815
        if (~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 815
          if ((int )((signed char )nitems_incr_min) < 0) {
#line 815
            tmp___343 = (int )((signed char )n0) < ~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )nitems_incr_min);
          } else {
#line 815
            tmp___343 = (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )nitems_incr_min) < (int )((signed char )n0);
          }
#line 815
          tmp___346 = tmp___343;
        } else {
#line 815
          if ((int )((signed char )n0) < 0) {
#line 815
            tmp___345 = (int )((signed char )nitems_incr_min) <= (int )((signed char )n0) + (int )((signed char )nitems_incr_min);
          } else {
#line 815
            if ((int )((signed char )nitems_incr_min) < 0) {
#line 815
              tmp___344 = (int )((signed char )n0) <= (int )((signed char )n0) + (int )((signed char )nitems_incr_min);
            } else {
#line 815
              tmp___344 = (int )((signed char )n0) + (int )((signed char )nitems_incr_min) < (int )((signed char )nitems_incr_min);
            }
#line 815
            tmp___345 = tmp___344;
          }
#line 815
          tmp___346 = tmp___345;
        }
#line 815
        if (tmp___346) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )nitems_incr_min)));
#line 815
          tmp___342 = 1;
        } else
#line 815
        if ((int )((signed char )n0) + (int )((signed char )nitems_incr_min) < -128) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )nitems_incr_min)));
#line 815
          tmp___342 = 1;
        } else
#line 815
        if (127 < (int )((signed char )n0) + (int )((signed char )nitems_incr_min)) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )nitems_incr_min)));
#line 815
          tmp___342 = 1;
        } else {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )((signed char )n0) + (unsigned int )((signed char )nitems_incr_min)));
#line 815
          tmp___342 = 0;
        }
#line 815
        tmp___356 = tmp___342;
      } else {
#line 815
        if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
          if (nitems_incr_min < 0L) {
#line 815
            tmp___352 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
          } else {
#line 815
            tmp___352 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
          }
#line 815
          tmp___355 = tmp___352;
        } else {
#line 815
          if (n0 < 0L) {
#line 815
            tmp___354 = nitems_incr_min <= n0 + nitems_incr_min;
          } else {
#line 815
            if (nitems_incr_min < 0L) {
#line 815
              tmp___353 = n0 <= n0 + nitems_incr_min;
            } else {
#line 815
              tmp___353 = n0 + nitems_incr_min < nitems_incr_min;
            }
#line 815
            tmp___354 = tmp___353;
          }
#line 815
          tmp___355 = tmp___354;
        }
#line 815
        if (tmp___355) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
          tmp___351 = 1;
        } else
#line 815
        if (n0 + nitems_incr_min < -128L) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
          tmp___351 = 1;
        } else
#line 815
        if (127L < n0 + nitems_incr_min) {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
          tmp___351 = 1;
        } else {
#line 815
          n = (ptrdiff_t )((signed char )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
          tmp___351 = 0;
        }
#line 815
        tmp___356 = tmp___351;
      }
#line 815
      tmp___436 = tmp___356;
    } else {
#line 815
      if (sizeof(n) == sizeof(short )) {
#line 815
        if (sizeof(n0 + nitems_incr_min) < sizeof(short )) {
#line 815
          if (~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 815
            if ((int )((short )nitems_incr_min) < 0) {
#line 815
              tmp___362 = (int )((short )n0) < ~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )nitems_incr_min);
            } else {
#line 815
              tmp___362 = (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )nitems_incr_min) < (int )((short )n0);
            }
#line 815
            tmp___365 = tmp___362;
          } else {
#line 815
            if ((int )((short )n0) < 0) {
#line 815
              tmp___364 = (int )((short )nitems_incr_min) <= (int )((short )n0) + (int )((short )nitems_incr_min);
            } else {
#line 815
              if ((int )((short )nitems_incr_min) < 0) {
#line 815
                tmp___363 = (int )((short )n0) <= (int )((short )n0) + (int )((short )nitems_incr_min);
              } else {
#line 815
                tmp___363 = (int )((short )n0) + (int )((short )nitems_incr_min) < (int )((short )nitems_incr_min);
              }
#line 815
              tmp___364 = tmp___363;
            }
#line 815
            tmp___365 = tmp___364;
          }
#line 815
          if (tmp___365) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )nitems_incr_min)));
#line 815
            tmp___361 = 1;
          } else
#line 815
          if ((int )((short )n0) + (int )((short )nitems_incr_min) < -32768) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )nitems_incr_min)));
#line 815
            tmp___361 = 1;
          } else
#line 815
          if (32767 < (int )((short )n0) + (int )((short )nitems_incr_min)) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )nitems_incr_min)));
#line 815
            tmp___361 = 1;
          } else {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )((short )n0) + (unsigned int )((short )nitems_incr_min)));
#line 815
            tmp___361 = 0;
          }
#line 815
          tmp___375 = tmp___361;
        } else {
#line 815
          if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
            if (nitems_incr_min < 0L) {
#line 815
              tmp___371 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
            } else {
#line 815
              tmp___371 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
            }
#line 815
            tmp___374 = tmp___371;
          } else {
#line 815
            if (n0 < 0L) {
#line 815
              tmp___373 = nitems_incr_min <= n0 + nitems_incr_min;
            } else {
#line 815
              if (nitems_incr_min < 0L) {
#line 815
                tmp___372 = n0 <= n0 + nitems_incr_min;
              } else {
#line 815
                tmp___372 = n0 + nitems_incr_min < nitems_incr_min;
              }
#line 815
              tmp___373 = tmp___372;
            }
#line 815
            tmp___374 = tmp___373;
          }
#line 815
          if (tmp___374) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
            tmp___370 = 1;
          } else
#line 815
          if (n0 + nitems_incr_min < -32768L) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
            tmp___370 = 1;
          } else
#line 815
          if (32767L < n0 + nitems_incr_min) {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
            tmp___370 = 1;
          } else {
#line 815
            n = (ptrdiff_t )((short )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
            tmp___370 = 0;
          }
#line 815
          tmp___375 = tmp___370;
        }
#line 815
        tmp___435 = tmp___375;
      } else {
#line 815
        if (sizeof(n) == sizeof(int )) {
#line 815
          if (sizeof(n0 + nitems_incr_min) < sizeof(int )) {
#line 815
            if (~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 815
              if ((int )nitems_incr_min < 0) {
#line 815
                tmp___381 = (int )n0 < ~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )nitems_incr_min;
              } else {
#line 815
                tmp___381 = (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )nitems_incr_min < (int )n0;
              }
#line 815
              tmp___384 = tmp___381;
            } else {
#line 815
              if ((int )n0 < 0) {
#line 815
                tmp___383 = (int )nitems_incr_min <= (int )n0 + (int )nitems_incr_min;
              } else {
#line 815
                if ((int )nitems_incr_min < 0) {
#line 815
                  tmp___382 = (int )n0 <= (int )n0 + (int )nitems_incr_min;
                } else {
#line 815
                  tmp___382 = (int )n0 + (int )nitems_incr_min < (int )nitems_incr_min;
                }
#line 815
                tmp___383 = tmp___382;
              }
#line 815
              tmp___384 = tmp___383;
            }
#line 815
            if (tmp___384) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
#line 815
              tmp___380 = 1;
            } else
#line 815
            if ((int )n0 + (int )nitems_incr_min < (-0x7FFFFFFF-1)) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
#line 815
              tmp___380 = 1;
            } else
#line 815
            if (2147483647 < (int )n0 + (int )nitems_incr_min) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
#line 815
              tmp___380 = 1;
            } else {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
#line 815
              tmp___380 = 0;
            }
#line 815
            tmp___394 = tmp___380;
          } else {
#line 815
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
              if (nitems_incr_min < 0L) {
#line 815
                tmp___390 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
              } else {
#line 815
                tmp___390 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
              }
#line 815
              tmp___393 = tmp___390;
            } else {
#line 815
              if (n0 < 0L) {
#line 815
                tmp___392 = nitems_incr_min <= n0 + nitems_incr_min;
              } else {
#line 815
                if (nitems_incr_min < 0L) {
#line 815
                  tmp___391 = n0 <= n0 + nitems_incr_min;
                } else {
#line 815
                  tmp___391 = n0 + nitems_incr_min < nitems_incr_min;
                }
#line 815
                tmp___392 = tmp___391;
              }
#line 815
              tmp___393 = tmp___392;
            }
#line 815
            if (tmp___393) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
              tmp___389 = 1;
            } else
#line 815
            if (n0 + nitems_incr_min < (-0x7FFFFFFF-1)) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
              tmp___389 = 1;
            } else
#line 815
            if (2147483647L < n0 + nitems_incr_min) {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
              tmp___389 = 1;
            } else {
#line 815
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
#line 815
              tmp___389 = 0;
            }
#line 815
            tmp___394 = tmp___389;
          }
#line 815
          tmp___434 = tmp___394;
        } else {
#line 815
          if (sizeof(n) == sizeof(long )) {
#line 815
            if (sizeof(n0 + nitems_incr_min) < sizeof(long )) {
#line 815
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
                if (nitems_incr_min < 0L) {
#line 815
                  tmp___400 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 815
                  tmp___400 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 815
                tmp___403 = tmp___400;
              } else {
#line 815
                if (n0 < 0L) {
#line 815
                  tmp___402 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 815
                  if (nitems_incr_min < 0L) {
#line 815
                    tmp___401 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 815
                    tmp___401 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 815
                  tmp___402 = tmp___401;
                }
#line 815
                tmp___403 = tmp___402;
              }
#line 815
              if (tmp___403) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___399 = 1;
              } else
#line 815
              if (n0 + nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___399 = 1;
              } else
#line 815
              if (9223372036854775807L < n0 + nitems_incr_min) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___399 = 1;
              } else {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___399 = 0;
              }
#line 815
              tmp___413 = tmp___399;
            } else {
#line 815
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
                if (nitems_incr_min < 0L) {
#line 815
                  tmp___409 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 815
                  tmp___409 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 815
                tmp___412 = tmp___409;
              } else {
#line 815
                if (n0 < 0L) {
#line 815
                  tmp___411 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 815
                  if (nitems_incr_min < 0L) {
#line 815
                    tmp___410 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 815
                    tmp___410 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 815
                  tmp___411 = tmp___410;
                }
#line 815
                tmp___412 = tmp___411;
              }
#line 815
              if (tmp___412) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___408 = 1;
              } else
#line 815
              if (n0 + nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___408 = 1;
              } else
#line 815
              if (9223372036854775807L < n0 + nitems_incr_min) {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___408 = 1;
              } else {
#line 815
                n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
#line 815
                tmp___408 = 0;
              }
#line 815
              tmp___413 = tmp___408;
            }
#line 815
            tmp___433 = tmp___413;
          } else {
#line 815
            if (sizeof(n0 + nitems_incr_min) < sizeof(long long )) {
#line 815
              if (~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 815
                if ((long long )nitems_incr_min < 0LL) {
#line 815
                  tmp___419 = (long long )n0 < ~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )nitems_incr_min;
                } else {
#line 815
                  tmp___419 = (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )nitems_incr_min < (long long )n0;
                }
#line 815
                tmp___422 = tmp___419;
              } else {
#line 815
                if ((long long )n0 < 0LL) {
#line 815
                  tmp___421 = (long long )nitems_incr_min <= (long long )n0 + (long long )nitems_incr_min;
                } else {
#line 815
                  if ((long long )nitems_incr_min < 0LL) {
#line 815
                    tmp___420 = (long long )n0 <= (long long )n0 + (long long )nitems_incr_min;
                  } else {
#line 815
                    tmp___420 = (long long )n0 + (long long )nitems_incr_min < (long long )nitems_incr_min;
                  }
#line 815
                  tmp___421 = tmp___420;
                }
#line 815
                tmp___422 = tmp___421;
              }
#line 815
              if (tmp___422) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
#line 815
                tmp___418 = 1;
              } else
#line 815
              if ((long long )n0 + (long long )nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
#line 815
                tmp___418 = 1;
              } else
#line 815
              if (9223372036854775807LL < (long long )n0 + (long long )nitems_incr_min) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
#line 815
                tmp___418 = 1;
              } else {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
#line 815
                tmp___418 = 0;
              }
#line 815
              tmp___432 = tmp___418;
            } else {
#line 815
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 815
                if (nitems_incr_min < 0L) {
#line 815
                  tmp___428 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 815
                  tmp___428 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 815
                tmp___431 = tmp___428;
              } else {
#line 815
                if (n0 < 0L) {
#line 815
                  tmp___430 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 815
                  if (nitems_incr_min < 0L) {
#line 815
                    tmp___429 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 815
                    tmp___429 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 815
                  tmp___430 = tmp___429;
                }
#line 815
                tmp___431 = tmp___430;
              }
#line 815
              if (tmp___431) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
#line 815
                tmp___427 = 1;
              } else
#line 815
              if ((long long )(n0 + nitems_incr_min) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
#line 815
                tmp___427 = 1;
              } else
#line 815
              if (9223372036854775807LL < (long long )(n0 + nitems_incr_min)) {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
#line 815
                tmp___427 = 1;
              } else {
#line 815
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
#line 815
                tmp___427 = 0;
              }
#line 815
              tmp___432 = tmp___427;
            }
#line 815
            tmp___433 = tmp___432;
          }
#line 815
          tmp___434 = tmp___433;
        }
#line 815
        tmp___435 = tmp___434;
      }
#line 815
      tmp___436 = tmp___435;
    }
#line 815
    if (tmp___436) {
      {
#line 819
      xalloc_die();
      }
    } else
#line 815
    if (0L <= nitems_max) {
#line 815
      if (nitems_max < n) {
        {
#line 819
        xalloc_die();
        }
      } else {
#line 815
        goto _L___59;
      }
    } else {
      _L___59: /* CIL Label */ 
#line 815
      if (sizeof(nbytes) == sizeof(signed char )) {
#line 815
        if (sizeof(n * item_size) < sizeof(signed char )) {
#line 815
          if (~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 815
            if ((int )((signed char )n) < 0) {
#line 815
              if (0 < (int )((signed char )item_size)) {
#line 815
                nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
                tmp___442 = 1;
              } else {
#line 815
                goto _L___40;
              }
            } else
            _L___40: /* CIL Label */ 
#line 815
            if ((int )((signed char )item_size) < 0) {
#line 815
              if (0 < (int )((signed char )n)) {
#line 815
                nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
                tmp___442 = 1;
              } else {
#line 815
                goto _L___39;
              }
            } else {
#line 815
              goto _L___39;
            }
          } else {
            _L___39: /* CIL Label */ 
#line 815
            if ((int )((signed char )item_size) < 0) {
#line 815
              if ((int )((signed char )n) < 0) {
#line 815
                tmp___444 = (int )((signed char )n) < (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
              } else {
#line 815
                if ((int )((signed char )item_size) == -1) {
#line 815
                  tmp___443 = 0;
                } else {
#line 815
                  tmp___443 = ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
                }
#line 815
                tmp___444 = tmp___443;
              }
#line 815
              tmp___447 = tmp___444;
            } else {
#line 815
              if ((int )((signed char )item_size) == 0) {
#line 815
                tmp___446 = 0;
              } else {
#line 815
                if ((int )((signed char )n) < 0) {
#line 815
                  tmp___445 = (int )((signed char )n) < ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
                } else {
#line 815
                  tmp___445 = (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
                }
#line 815
                tmp___446 = tmp___445;
              }
#line 815
              tmp___447 = tmp___446;
            }
#line 815
            if (tmp___447) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
              tmp___442 = 1;
            } else
#line 815
            if ((int )((signed char )n) * (int )((signed char )item_size) < -128) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
              tmp___442 = 1;
            } else
#line 815
            if (127 < (int )((signed char )n) * (int )((signed char )item_size)) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
              tmp___442 = 1;
            } else {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )((signed char )n) * (unsigned int )((signed char )item_size)));
#line 815
              tmp___442 = 0;
            }
          }
#line 815
          tmp___459 = tmp___442;
        } else {
#line 815
          if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
            if (n < 0L) {
#line 815
              if (0L < item_size) {
#line 815
                nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___453 = 1;
              } else {
#line 815
                goto _L___42;
              }
            } else
            _L___42: /* CIL Label */ 
#line 815
            if (item_size < 0L) {
#line 815
              if (0L < n) {
#line 815
                nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___453 = 1;
              } else {
#line 815
                goto _L___41;
              }
            } else {
#line 815
              goto _L___41;
            }
          } else {
            _L___41: /* CIL Label */ 
#line 815
            if (item_size < 0L) {
#line 815
              if (n < 0L) {
#line 815
                tmp___455 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 815
                if (item_size == -1L) {
#line 815
                  tmp___454 = 0;
                } else {
#line 815
                  tmp___454 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 815
                tmp___455 = tmp___454;
              }
#line 815
              tmp___458 = tmp___455;
            } else {
#line 815
              if (item_size == 0L) {
#line 815
                tmp___457 = 0;
              } else {
#line 815
                if (n < 0L) {
#line 815
                  tmp___456 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 815
                  tmp___456 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 815
                tmp___457 = tmp___456;
              }
#line 815
              tmp___458 = tmp___457;
            }
#line 815
            if (tmp___458) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
              tmp___453 = 1;
            } else
#line 815
            if (n * item_size < -128L) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
              tmp___453 = 1;
            } else
#line 815
            if (127L < n * item_size) {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
              tmp___453 = 1;
            } else {
#line 815
              nbytes = (ptrdiff_t )((signed char )((unsigned int )n * (unsigned int )item_size));
#line 815
              tmp___453 = 0;
            }
          }
#line 815
          tmp___459 = tmp___453;
        }
#line 815
        tmp___555 = tmp___459;
      } else {
#line 815
        if (sizeof(nbytes) == sizeof(short )) {
#line 815
          if (sizeof(n * item_size) < sizeof(short )) {
#line 815
            if (~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 815
              if ((int )((short )n) < 0) {
#line 815
                if (0 < (int )((short )item_size)) {
#line 815
                  nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                  tmp___465 = 1;
                } else {
#line 815
                  goto _L___44;
                }
              } else
              _L___44: /* CIL Label */ 
#line 815
              if ((int )((short )item_size) < 0) {
#line 815
                if (0 < (int )((short )n)) {
#line 815
                  nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                  tmp___465 = 1;
                } else {
#line 815
                  goto _L___43;
                }
              } else {
#line 815
                goto _L___43;
              }
            } else {
              _L___43: /* CIL Label */ 
#line 815
              if ((int )((short )item_size) < 0) {
#line 815
                if ((int )((short )n) < 0) {
#line 815
                  tmp___467 = (int )((short )n) < (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
                } else {
#line 815
                  if ((int )((short )item_size) == -1) {
#line 815
                    tmp___466 = 0;
                  } else {
#line 815
                    tmp___466 = ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
                  }
#line 815
                  tmp___467 = tmp___466;
                }
#line 815
                tmp___470 = tmp___467;
              } else {
#line 815
                if ((int )((short )item_size) == 0) {
#line 815
                  tmp___469 = 0;
                } else {
#line 815
                  if ((int )((short )n) < 0) {
#line 815
                    tmp___468 = (int )((short )n) < ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
                  } else {
#line 815
                    tmp___468 = (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
                  }
#line 815
                  tmp___469 = tmp___468;
                }
#line 815
                tmp___470 = tmp___469;
              }
#line 815
              if (tmp___470) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                tmp___465 = 1;
              } else
#line 815
              if ((int )((short )n) * (int )((short )item_size) < -32768) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                tmp___465 = 1;
              } else
#line 815
              if (32767 < (int )((short )n) * (int )((short )item_size)) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                tmp___465 = 1;
              } else {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )((short )n) * (unsigned int )((short )item_size)));
#line 815
                tmp___465 = 0;
              }
            }
#line 815
            tmp___482 = tmp___465;
          } else {
#line 815
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
              if (n < 0L) {
#line 815
                if (0L < item_size) {
#line 815
                  nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___476 = 1;
                } else {
#line 815
                  goto _L___46;
                }
              } else
              _L___46: /* CIL Label */ 
#line 815
              if (item_size < 0L) {
#line 815
                if (0L < n) {
#line 815
                  nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___476 = 1;
                } else {
#line 815
                  goto _L___45;
                }
              } else {
#line 815
                goto _L___45;
              }
            } else {
              _L___45: /* CIL Label */ 
#line 815
              if (item_size < 0L) {
#line 815
                if (n < 0L) {
#line 815
                  tmp___478 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 815
                  if (item_size == -1L) {
#line 815
                    tmp___477 = 0;
                  } else {
#line 815
                    tmp___477 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 815
                  tmp___478 = tmp___477;
                }
#line 815
                tmp___481 = tmp___478;
              } else {
#line 815
                if (item_size == 0L) {
#line 815
                  tmp___480 = 0;
                } else {
#line 815
                  if (n < 0L) {
#line 815
                    tmp___479 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 815
                    tmp___479 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 815
                  tmp___480 = tmp___479;
                }
#line 815
                tmp___481 = tmp___480;
              }
#line 815
              if (tmp___481) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___476 = 1;
              } else
#line 815
              if (n * item_size < -32768L) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___476 = 1;
              } else
#line 815
              if (32767L < n * item_size) {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___476 = 1;
              } else {
#line 815
                nbytes = (ptrdiff_t )((short )((unsigned int )n * (unsigned int )item_size));
#line 815
                tmp___476 = 0;
              }
            }
#line 815
            tmp___482 = tmp___476;
          }
#line 815
          tmp___554 = tmp___482;
        } else {
#line 815
          if (sizeof(nbytes) == sizeof(int )) {
#line 815
            if (sizeof(n * item_size) < sizeof(int )) {
#line 815
              if (~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 815
                if ((int )n < 0) {
#line 815
                  if (0 < (int )item_size) {
#line 815
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                    tmp___488 = 1;
                  } else {
#line 815
                    goto _L___48;
                  }
                } else
                _L___48: /* CIL Label */ 
#line 815
                if ((int )item_size < 0) {
#line 815
                  if (0 < (int )n) {
#line 815
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                    tmp___488 = 1;
                  } else {
#line 815
                    goto _L___47;
                  }
                } else {
#line 815
                  goto _L___47;
                }
              } else {
                _L___47: /* CIL Label */ 
#line 815
                if ((int )item_size < 0) {
#line 815
                  if ((int )n < 0) {
#line 815
                    tmp___490 = (int )n < (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                  } else {
#line 815
                    if ((int )item_size == -1) {
#line 815
                      tmp___489 = 0;
                    } else {
#line 815
                      tmp___489 = ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                    }
#line 815
                    tmp___490 = tmp___489;
                  }
#line 815
                  tmp___493 = tmp___490;
                } else {
#line 815
                  if ((int )item_size == 0) {
#line 815
                    tmp___492 = 0;
                  } else {
#line 815
                    if ((int )n < 0) {
#line 815
                      tmp___491 = (int )n < ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                    } else {
#line 815
                      tmp___491 = (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                    }
#line 815
                    tmp___492 = tmp___491;
                  }
#line 815
                  tmp___493 = tmp___492;
                }
#line 815
                if (tmp___493) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                  tmp___488 = 1;
                } else
#line 815
                if ((int )n * (int )item_size < (-0x7FFFFFFF-1)) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                  tmp___488 = 1;
                } else
#line 815
                if (2147483647 < (int )n * (int )item_size) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                  tmp___488 = 1;
                } else {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
#line 815
                  tmp___488 = 0;
                }
              }
#line 815
              tmp___505 = tmp___488;
            } else {
#line 815
              if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
                if (n < 0L) {
#line 815
                  if (0L < item_size) {
#line 815
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                    tmp___499 = 1;
                  } else {
#line 815
                    goto _L___50;
                  }
                } else
                _L___50: /* CIL Label */ 
#line 815
                if (item_size < 0L) {
#line 815
                  if (0L < n) {
#line 815
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                    tmp___499 = 1;
                  } else {
#line 815
                    goto _L___49;
                  }
                } else {
#line 815
                  goto _L___49;
                }
              } else {
                _L___49: /* CIL Label */ 
#line 815
                if (item_size < 0L) {
#line 815
                  if (n < 0L) {
#line 815
                    tmp___501 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 815
                    if (item_size == -1L) {
#line 815
                      tmp___500 = 0;
                    } else {
#line 815
                      tmp___500 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                    }
#line 815
                    tmp___501 = tmp___500;
                  }
#line 815
                  tmp___504 = tmp___501;
                } else {
#line 815
                  if (item_size == 0L) {
#line 815
                    tmp___503 = 0;
                  } else {
#line 815
                    if (n < 0L) {
#line 815
                      tmp___502 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 815
                      tmp___502 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                    }
#line 815
                    tmp___503 = tmp___502;
                  }
#line 815
                  tmp___504 = tmp___503;
                }
#line 815
                if (tmp___504) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___499 = 1;
                } else
#line 815
                if (n * item_size < (-0x7FFFFFFF-1)) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___499 = 1;
                } else
#line 815
                if (2147483647L < n * item_size) {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___499 = 1;
                } else {
#line 815
                  nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
#line 815
                  tmp___499 = 0;
                }
              }
#line 815
              tmp___505 = tmp___499;
            }
#line 815
            tmp___553 = tmp___505;
          } else {
#line 815
            if (sizeof(nbytes) == sizeof(long )) {
#line 815
              if (sizeof(n * item_size) < sizeof(long )) {
#line 815
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
                  if (n < 0L) {
#line 815
                    if (0L < item_size) {
#line 815
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                      tmp___511 = 1;
                    } else {
#line 815
                      goto _L___52;
                    }
                  } else
                  _L___52: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (0L < n) {
#line 815
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                      tmp___511 = 1;
                    } else {
#line 815
                      goto _L___51;
                    }
                  } else {
#line 815
                    goto _L___51;
                  }
                } else {
                  _L___51: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (n < 0L) {
#line 815
                      tmp___513 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 815
                      if (item_size == -1L) {
#line 815
                        tmp___512 = 0;
                      } else {
#line 815
                        tmp___512 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___513 = tmp___512;
                    }
#line 815
                    tmp___516 = tmp___513;
                  } else {
#line 815
                    if (item_size == 0L) {
#line 815
                      tmp___515 = 0;
                    } else {
#line 815
                      if (n < 0L) {
#line 815
                        tmp___514 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 815
                        tmp___514 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___515 = tmp___514;
                    }
#line 815
                    tmp___516 = tmp___515;
                  }
#line 815
                  if (tmp___516) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___511 = 1;
                  } else
#line 815
                  if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___511 = 1;
                  } else
#line 815
                  if (9223372036854775807L < n * item_size) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___511 = 1;
                  } else {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___511 = 0;
                  }
                }
#line 815
                tmp___528 = tmp___511;
              } else {
#line 815
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
                  if (n < 0L) {
#line 815
                    if (0L < item_size) {
#line 815
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                      tmp___522 = 1;
                    } else {
#line 815
                      goto _L___54;
                    }
                  } else
                  _L___54: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (0L < n) {
#line 815
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                      tmp___522 = 1;
                    } else {
#line 815
                      goto _L___53;
                    }
                  } else {
#line 815
                    goto _L___53;
                  }
                } else {
                  _L___53: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (n < 0L) {
#line 815
                      tmp___524 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 815
                      if (item_size == -1L) {
#line 815
                        tmp___523 = 0;
                      } else {
#line 815
                        tmp___523 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___524 = tmp___523;
                    }
#line 815
                    tmp___527 = tmp___524;
                  } else {
#line 815
                    if (item_size == 0L) {
#line 815
                      tmp___526 = 0;
                    } else {
#line 815
                      if (n < 0L) {
#line 815
                        tmp___525 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 815
                        tmp___525 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___526 = tmp___525;
                    }
#line 815
                    tmp___527 = tmp___526;
                  }
#line 815
                  if (tmp___527) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___522 = 1;
                  } else
#line 815
                  if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___522 = 1;
                  } else
#line 815
                  if (9223372036854775807L < n * item_size) {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___522 = 1;
                  } else {
#line 815
                    nbytes = (long )((unsigned long )n * (unsigned long )item_size);
#line 815
                    tmp___522 = 0;
                  }
                }
#line 815
                tmp___528 = tmp___522;
              }
#line 815
              tmp___552 = tmp___528;
            } else {
#line 815
              if (sizeof(n * item_size) < sizeof(long long )) {
#line 815
                if (~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 815
                  if ((long long )n < 0LL) {
#line 815
                    if (0LL < (long long )item_size) {
#line 815
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                      tmp___534 = 1;
                    } else {
#line 815
                      goto _L___56;
                    }
                  } else
                  _L___56: /* CIL Label */ 
#line 815
                  if ((long long )item_size < 0LL) {
#line 815
                    if (0LL < (long long )n) {
#line 815
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                      tmp___534 = 1;
                    } else {
#line 815
                      goto _L___55;
                    }
                  } else {
#line 815
                    goto _L___55;
                  }
                } else {
                  _L___55: /* CIL Label */ 
#line 815
                  if ((long long )item_size < 0LL) {
#line 815
                    if ((long long )n < 0LL) {
#line 815
                      tmp___536 = (long long )n < (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                    } else {
#line 815
                      if ((long long )item_size == -1LL) {
#line 815
                        tmp___535 = 0;
                      } else {
#line 815
                        tmp___535 = ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                      }
#line 815
                      tmp___536 = tmp___535;
                    }
#line 815
                    tmp___539 = tmp___536;
                  } else {
#line 815
                    if ((long long )item_size == 0LL) {
#line 815
                      tmp___538 = 0;
                    } else {
#line 815
                      if ((long long )n < 0LL) {
#line 815
                        tmp___537 = (long long )n < ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                      } else {
#line 815
                        tmp___537 = (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                      }
#line 815
                      tmp___538 = tmp___537;
                    }
#line 815
                    tmp___539 = tmp___538;
                  }
#line 815
                  if (tmp___539) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                    tmp___534 = 1;
                  } else
#line 815
                  if ((long long )n * (long long )item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                    tmp___534 = 1;
                  } else
#line 815
                  if (9223372036854775807LL < (long long )n * (long long )item_size) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                    tmp___534 = 1;
                  } else {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
#line 815
                    tmp___534 = 0;
                  }
                }
#line 815
                tmp___551 = tmp___534;
              } else {
#line 815
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 815
                  if (n < 0L) {
#line 815
                    if (0L < item_size) {
#line 815
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                      tmp___545 = 1;
                    } else {
#line 815
                      goto _L___58;
                    }
                  } else
                  _L___58: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (0L < n) {
#line 815
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                      tmp___545 = 1;
                    } else {
#line 815
                      goto _L___57;
                    }
                  } else {
#line 815
                    goto _L___57;
                  }
                } else {
                  _L___57: /* CIL Label */ 
#line 815
                  if (item_size < 0L) {
#line 815
                    if (n < 0L) {
#line 815
                      tmp___547 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 815
                      if (item_size == -1L) {
#line 815
                        tmp___546 = 0;
                      } else {
#line 815
                        tmp___546 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___547 = tmp___546;
                    }
#line 815
                    tmp___550 = tmp___547;
                  } else {
#line 815
                    if (item_size == 0L) {
#line 815
                      tmp___549 = 0;
                    } else {
#line 815
                      if (n < 0L) {
#line 815
                        tmp___548 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 815
                        tmp___548 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 815
                      tmp___549 = tmp___548;
                    }
#line 815
                    tmp___550 = tmp___549;
                  }
#line 815
                  if (tmp___550) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                    tmp___545 = 1;
                  } else
#line 815
                  if ((long long )(n * item_size) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                    tmp___545 = 1;
                  } else
#line 815
                  if (9223372036854775807LL < (long long )(n * item_size)) {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                    tmp___545 = 1;
                  } else {
#line 815
                    nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
#line 815
                    tmp___545 = 0;
                  }
                }
#line 815
                tmp___551 = tmp___545;
              }
#line 815
              tmp___552 = tmp___551;
            }
#line 815
            tmp___553 = tmp___552;
          }
#line 815
          tmp___554 = tmp___553;
        }
#line 815
        tmp___555 = tmp___554;
      }
#line 815
      if (tmp___555) {
        {
#line 819
        xalloc_die();
        }
      }
    }
  }
  {
#line 820
  pa = xrealloc(pa, (size_t )nbytes);
#line 821
  *nitems = n;
  }
#line 822
  return (pa);
}
}
#line 834 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void *maybe_realloc___0(void *pa , ptrdiff_t i , ptrdiff_t *nitems , ptrdiff_t nitems_max ,
                               ptrdiff_t item_size ) 
{ 
  void *tmp ;

  {
#line 838
  if (i < *nitems) {
#line 839
    return (pa);
  }
  {
#line 840
  tmp = xpalloc___0(pa, nitems, (ptrdiff_t )1, nitems_max, item_size);
  }
#line 840
  return (tmp);
}
}
#line 844 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static ptrdiff_t charclass_index___0(struct dfa *d , charclass *s ) 
{ 
  ptrdiff_t i ;
  _Bool tmp ;
  void *tmp___0 ;

  {
#line 849
  i = (ptrdiff_t )0;
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    if (! (i < d->cindex)) {
#line 849
      goto while_break;
    }
    {
#line 850
    tmp = equal___0((charclass const   *)s, (charclass const   *)(d->charclasses + i));
    }
#line 850
    if (tmp) {
#line 851
      return (i);
    }
#line 849
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 852
  tmp___0 = maybe_realloc___0((void *)d->charclasses, d->cindex, & d->calloc, (ptrdiff_t )(TOKEN_MAX___0 - 275L),
                              (ptrdiff_t )sizeof(*(d->charclasses)));
#line 852
  d->charclasses = (charclass *)tmp___0;
#line 854
  (d->cindex) ++;
#line 855
  *(d->charclasses + i) = *s;
  }
#line 856
  return (i);
}
}
#line 859 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool unibyte_word_constituent___0(struct dfa  const  *dfa , unsigned char c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 862
  if (dfa->localeinfo.sbctowc[c] != 4294967295U) {
    {
#line 862
    tmp = __ctype_b_loc();
    }
#line 862
    if ((int const   )*(*tmp + (int )c) & 8) {
#line 862
      tmp___0 = 1;
    } else
#line 862
    if ((int )c == 95) {
#line 862
      tmp___0 = 1;
    } else {
#line 862
      tmp___0 = 0;
    }
  } else {
#line 862
    tmp___0 = 0;
  }
#line 862
  return ((_Bool )tmp___0);
}
}
#line 865 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int char_context___0(struct dfa  const  *dfa , unsigned char c ) 
{ 
  _Bool tmp ;

  {
#line 868
  if ((int )c == (int )dfa->syntax.eolbyte) {
#line 868
    if (! dfa->syntax.anchor) {
#line 869
      return (4);
    }
  }
  {
#line 870
  tmp = unibyte_word_constituent___0(dfa, c);
  }
#line 870
  if (tmp) {
#line 871
    return (2);
  }
#line 872
  return (1);
}
}
#line 880 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool setbit_wc___0(wint_t wc , charclass *c ) 
{ 
  int b ;
  int tmp ;

  {
  {
#line 883
  tmp = wctob(wc);
#line 883
  b = tmp;
  }
#line 884
  if (b < 0) {
#line 885
    return ((_Bool)0);
  }
  {
#line 887
  setbit___0((unsigned int )b, c);
  }
#line 888
  return ((_Bool)1);
}
}
#line 893 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void setbit_case_fold_c___0(int b , charclass *c ) 
{ 
  int ub ;
  int tmp ;
  int i ;
  int tmp___0 ;

  {
  {
#line 896
  tmp = toupper(b);
#line 896
  ub = tmp;
#line 897
  i = 0;
  }
  {
#line 897
  while (1) {
    while_continue: /* CIL Label */ ;
#line 897
    if (! (i < 256)) {
#line 897
      goto while_break;
    }
    {
#line 898
    tmp___0 = toupper(i);
    }
#line 898
    if (tmp___0 == ub) {
      {
#line 899
      setbit___0((unsigned int )i, c);
      }
    }
#line 897
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  return;
}
}
#line 904 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool using_simple_locale___0(_Bool multibyte ) 
{ 
  char const   *loc ;
  char *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
#line 923
  if (multibyte) {
#line 924
    return ((_Bool)0);
  } else {
    {
#line 929
    tmp = setlocale(6, (char const   *)((void *)0));
#line 929
    loc = (char const   *)tmp;
    }
#line 930
    if (! loc) {
#line 930
      tmp___2 = 1;
    } else {
      {
#line 930
      tmp___0 = streq___0(loc, "C");
      }
#line 930
      if (tmp___0) {
#line 930
        tmp___2 = 1;
      } else {
        {
#line 930
        tmp___1 = streq___0(loc, "POSIX");
        }
#line 930
        if (tmp___1) {
#line 930
          tmp___2 = 1;
        } else {
#line 930
          tmp___2 = 0;
        }
      }
    }
#line 930
    return ((_Bool )tmp___2);
  }
}
}
#line 940 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int fetch_wc___0(struct dfa *dfa ) 
{ 
  size_t nbytes ;
  size_t tmp ;
  int c ;
  unsigned char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 943
  tmp = mbs_to_wchar___0(& dfa->lex.wctok, dfa->lex.ptr, dfa->lex.left, dfa);
#line 943
  nbytes = tmp;
#line 945
  dfa->lex.cur_mb_len = (int )nbytes;
  }
#line 946
  if (nbytes == 1UL) {
    {
#line 946
    tmp___0 = to_uchar___1((char )*(dfa->lex.ptr + 0));
#line 946
    tmp___1 = (int )tmp___0;
    }
  } else {
#line 946
    tmp___1 = -1;
  }
#line 946
  c = tmp___1;
#line 947
  dfa->lex.ptr += nbytes;
#line 948
  dfa->lex.left -= nbytes;
#line 949
  return (c);
}
}
#line 954 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int bracket_fetch_wc___0(struct dfa *dfa ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 957
  if (! dfa->lex.left) {
    {
#line 958
    tmp = gettext("unbalanced [");
#line 958
    dfaerror((char const   *)tmp);
    }
  }
  {
#line 959
  tmp___0 = fetch_wc___0(dfa);
  }
#line 959
  return (tmp___0);
}
}
#line 975 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static struct dfa_ctype  const  prednames___0[13]  = 
#line 975
  {      {"alpha", (predicate *)(& isalpha), (_Bool)0}, 
        {"upper", (predicate *)(& isupper), (_Bool)0}, 
        {"lower", (predicate *)(& islower), (_Bool)0}, 
        {"digit", (predicate *)(& isdigit), (_Bool)1}, 
        {"xdigit", (predicate *)(& isxdigit), (_Bool)0}, 
        {"space", (predicate *)(& isspace), (_Bool)0}, 
        {"punct", (predicate *)(& ispunct), (_Bool)0}, 
        {"alnum", (predicate *)(& isalnum), (_Bool)0}, 
        {"print", (predicate *)(& isprint), (_Bool)0}, 
        {"graph", (predicate *)(& isgraph), (_Bool)0}, 
        {"cntrl", (predicate *)(& iscntrl), (_Bool)0}, 
        {"blank", (predicate *)(& isblank), (_Bool)0}, 
        {(char const   *)((void *)0), (predicate *)((void *)0), (_Bool)0}};
#line 991 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static struct dfa_ctype  const  * __attribute__((__pure__)) find_pred___0(char const   *str ) 
{ 
  unsigned int i ;
  _Bool tmp ;

  {
#line 994
  i = 0U;
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 994
    if (! prednames___0[i].name) {
#line 994
      goto while_break;
    }
    {
#line 995
    tmp = streq___0(str, (char const   *)prednames___0[i].name);
    }
#line 995
    if (tmp) {
#line 996
      return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)(& prednames___0[i]));
    }
#line 994
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 997
  return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)((void *)0));
}
}
#line 1002 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static token parse_bracket_exp___0(struct dfa *dfa ) 
{ 
  _Bool known_bracket_exp ;
  int colon_warning_state ;
  charclass ccl ;
  int c ;
  int tmp ;
  _Bool invert ;
  wint_t wc ;
  int c1 ;
  wint_t wc1 ;
  char str[33] ;
  size_t len ;
  size_t tmp___0 ;
  char const   *class ;
  char const   *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  struct dfa_ctype  const  *pred ;
  struct dfa_ctype  const  * __attribute__((__pure__)) tmp___6 ;
  char *tmp___7 ;
  int c2 ;
  int tmp___8 ;
  int c2___0 ;
  int tmp___9 ;
  wint_t wc2 ;
  int ci ;
  unsigned short const   **tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;
  wchar_t folded[33] ;
  unsigned int n ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned int i ;
  void *tmp___17 ;
  ptrdiff_t tmp___18 ;
  _Bool tmp___19 ;
  char *tmp___20 ;
  ptrdiff_t tmp___22 ;
  _Bool tmp___23 ;
  ptrdiff_t tmp___24 ;

  {
  {
#line 1007
  known_bracket_exp = (_Bool)1;
#line 1016
  dfa->lex.brack.nchars = (ptrdiff_t )0;
#line 1018
  zeroset___0(& ccl);
#line 1019
  tmp = bracket_fetch_wc___0(dfa);
#line 1019
  c = tmp;
#line 1020
  invert = (_Bool )(c == 94);
  }
#line 1021
  if (invert) {
    {
#line 1023
    c = bracket_fetch_wc___0(dfa);
#line 1024
    known_bracket_exp = dfa->simple_locale;
    }
  }
#line 1026
  wc = dfa->lex.wctok;
#line 1029
  colon_warning_state = c == 58;
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1032
    c1 = 256;
#line 1033
    colon_warning_state &= -3;
#line 1039
    if (c == 91) {
      {
#line 1041
      c1 = bracket_fetch_wc___0(dfa);
#line 1042
      wc1 = dfa->lex.wctok;
      }
#line 1044
      if (c1 == 58) {
#line 1044
        if (dfa->syntax.syntax_bits & ((1UL << 1) << 1)) {
#line 1044
          goto _L___0;
        } else {
#line 1044
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1044
      if (c1 == 46) {
#line 1044
        goto _L___0;
      } else
#line 1044
      if (c1 == 61) {
        _L___0: /* CIL Label */ 
#line 1049
        len = (size_t )0;
        {
#line 1050
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1052
          c = bracket_fetch_wc___0(dfa);
          }
#line 1053
          if (dfa->lex.left == 0UL) {
#line 1055
            goto while_break___0;
          } else
#line 1053
          if (c == c1) {
#line 1053
            if ((int const   )*(dfa->lex.ptr + 0) == 93) {
#line 1055
              goto while_break___0;
            }
          }
#line 1056
          if (len < 32UL) {
#line 1057
            tmp___0 = len;
#line 1057
            len ++;
#line 1057
            str[tmp___0] = (char )c;
          } else {
#line 1060
            str[0] = (char )'\000';
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1062
        str[len] = (char )'\000';
#line 1065
        c = bracket_fetch_wc___0(dfa);
#line 1066
        wc = dfa->lex.wctok;
        }
#line 1067
        if (c1 == 58) {
#line 1073
          if (dfa->syntax.case_fold) {
            {
#line 1073
            tmp___4 = streq___0((char const   *)(str), "upper");
            }
#line 1073
            if (tmp___4) {
#line 1073
              tmp___3 = "alpha";
            } else {
              {
#line 1073
              tmp___5 = streq___0((char const   *)(str), "lower");
              }
#line 1073
              if (tmp___5) {
#line 1073
                tmp___3 = "alpha";
              } else {
#line 1073
                tmp___3 = (char const   *)(str);
              }
            }
          } else {
#line 1073
            tmp___3 = (char const   *)(str);
          }
          {
#line 1073
          class = tmp___3;
#line 1077
          tmp___6 = find_pred___0(class);
#line 1077
          pred = (struct dfa_ctype  const  *)tmp___6;
          }
#line 1078
          if (! pred) {
            {
#line 1079
            tmp___7 = gettext("invalid character class");
#line 1079
            dfaerror((char const   *)tmp___7);
            }
          }
#line 1081
          if (dfa->localeinfo.multibyte) {
#line 1081
            if (! pred->single_byte_only) {
#line 1082
              known_bracket_exp = (_Bool)0;
            } else {
#line 1081
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 1084
            c2 = 0;
            {
#line 1084
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1084
              if (! (c2 < 256)) {
#line 1084
                goto while_break___1;
              }
              {
#line 1085
              tmp___8 = (*(pred->func))(c2);
              }
#line 1085
              if (tmp___8) {
                {
#line 1086
                setbit___0((unsigned int )c2, & ccl);
                }
              }
#line 1084
              c2 ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        } else {
#line 1089
          known_bracket_exp = (_Bool)0;
        }
        {
#line 1091
        colon_warning_state |= 8;
#line 1094
        c1 = bracket_fetch_wc___0(dfa);
#line 1095
        wc1 = dfa->lex.wctok;
        }
#line 1096
        goto __Cont;
      }
    }
#line 1103
    if (c == 92) {
#line 1103
      if (dfa->syntax.syntax_bits & 1UL) {
        {
#line 1106
        c = bracket_fetch_wc___0(dfa);
#line 1107
        wc = dfa->lex.wctok;
        }
      }
    }
#line 1110
    if (c1 == 256) {
      {
#line 1112
      c1 = bracket_fetch_wc___0(dfa);
#line 1113
      wc1 = dfa->lex.wctok;
      }
    }
#line 1116
    if (c1 == 45) {
      {
#line 1119
      tmp___9 = bracket_fetch_wc___0(dfa);
#line 1119
      c2___0 = tmp___9;
#line 1120
      wc2 = dfa->lex.wctok;
      }
#line 1125
      if (c2___0 == 91) {
#line 1125
        if ((int const   )*(dfa->lex.ptr + 0) == 46) {
#line 1127
          known_bracket_exp = (_Bool)0;
#line 1128
          c2___0 = ']';
        }
      }
#line 1131
      if (c2___0 == 93) {
#line 1135
        dfa->lex.ptr -= dfa->lex.cur_mb_len;
#line 1136
        dfa->lex.left += (size_t )dfa->lex.cur_mb_len;
      } else {
#line 1140
        if (c2___0 == 92) {
#line 1140
          if (dfa->syntax.syntax_bits & 1UL) {
            {
#line 1143
            c2___0 = bracket_fetch_wc___0(dfa);
#line 1144
            wc2 = dfa->lex.wctok;
            }
          }
        }
        {
#line 1147
        colon_warning_state |= 8;
#line 1148
        c1 = bracket_fetch_wc___0(dfa);
#line 1149
        wc1 = dfa->lex.wctok;
        }
#line 1152
        if (wc != wc2) {
#line 1152
          goto _L___3;
        } else
#line 1152
        if (wc == 4294967295U) {
          _L___3: /* CIL Label */ 
#line 1154
          if (dfa->simple_locale) {
#line 1154
            goto _L___2;
          } else {
            {
#line 1154
            tmp___11 = isasciidigit___0((char )c);
#line 1154
            tmp___12 = isasciidigit___0((char )c2___0);
            }
#line 1154
            if ((int )tmp___11 & (int )tmp___12) {
              _L___2: /* CIL Label */ 
#line 1157
              ci = c;
              {
#line 1157
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 1157
                if (! (ci <= c2___0)) {
#line 1157
                  goto while_break___2;
                }
#line 1158
                if (dfa->syntax.case_fold) {
                  {
#line 1158
                  tmp___10 = __ctype_b_loc();
                  }
#line 1158
                  if ((int const   )*(*tmp___10 + ci) & 1024) {
                    {
#line 1159
                    setbit_case_fold_c___0(ci, & ccl);
                    }
                  } else {
                    {
#line 1161
                    setbit___0((unsigned int )ci, & ccl);
                    }
                  }
                } else {
                  {
#line 1161
                  setbit___0((unsigned int )ci, & ccl);
                  }
                }
#line 1157
                ci ++;
              }
              while_break___2: /* CIL Label */ ;
              }
            } else {
#line 1164
              known_bracket_exp = (_Bool)0;
            }
          }
#line 1166
          goto __Cont;
        }
      }
    }
#line 1171
    if (c == 58) {
#line 1171
      tmp___13 = 2;
    } else {
#line 1171
      tmp___13 = 4;
    }
#line 1171
    colon_warning_state |= tmp___13;
#line 1173
    if (! dfa->localeinfo.multibyte) {
#line 1175
      if (dfa->syntax.case_fold) {
        {
#line 1175
        tmp___14 = __ctype_b_loc();
        }
#line 1175
        if ((int const   )*(*tmp___14 + c) & 1024) {
          {
#line 1176
          setbit_case_fold_c___0(c, & ccl);
          }
        } else {
          {
#line 1178
          setbit___0((unsigned int )c, & ccl);
          }
        }
      } else {
        {
#line 1178
        setbit___0((unsigned int )c, & ccl);
        }
      }
#line 1179
      goto __Cont;
    }
#line 1182
    if (wc == 4294967295U) {
#line 1183
      known_bracket_exp = (_Bool)0;
    } else {
#line 1187
      if (dfa->syntax.case_fold) {
        {
#line 1187
        tmp___15 = case_folded_counterparts(wc, (wchar_t *)(folded + 1));
#line 1187
        tmp___16 = tmp___15 + 1;
        }
      } else {
#line 1187
        tmp___16 = 1;
      }
#line 1187
      n = (unsigned int )tmp___16;
#line 1190
      folded[0] = (wchar_t )wc;
#line 1191
      i = 0U;
      {
#line 1191
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1191
        if (! (i < n)) {
#line 1191
          goto while_break___3;
        }
        {
#line 1192
        tmp___19 = setbit_wc___0((wint_t )folded[i], & ccl);
        }
#line 1192
        if (! tmp___19) {
          {
#line 1194
          tmp___17 = maybe_realloc___0((void *)dfa->lex.brack.chars, dfa->lex.brack.nchars,
                                       & dfa->lex.brack.nchars_alloc, (ptrdiff_t )-1,
                                       (ptrdiff_t )sizeof(*(dfa->lex.brack.chars)));
#line 1194
          dfa->lex.brack.chars = (wchar_t *)tmp___17;
#line 1198
          tmp___18 = dfa->lex.brack.nchars;
#line 1198
          (dfa->lex.brack.nchars) ++;
#line 1198
          *(dfa->lex.brack.chars + tmp___18) = folded[i];
          }
        }
#line 1191
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1030
    wc = wc1;
#line 1030
    c = c1;
#line 1030
    if (! (c != 93)) {
#line 1030
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1204
  if (colon_warning_state == 7) {
    {
#line 1205
    tmp___20 = gettext("character class syntax is [[:space:]], not [:space:]");
#line 1205
    dfawarn((char const   *)tmp___20);
    }
  }
#line 1207
  if (! known_bracket_exp) {
#line 1208
    return ((token )257);
  }
#line 1210
  if (dfa->localeinfo.multibyte) {
#line 1210
    if (invert) {
#line 1210
      goto _L___4;
    } else
#line 1210
    if (dfa->lex.brack.nchars != 0L) {
      _L___4: /* CIL Label */ 
      {
#line 1212
      dfa->lex.brack.invert = invert;
#line 1213
      tmp___23 = emptyset___0((charclass const   *)(& ccl));
      }
#line 1213
      if (tmp___23) {
#line 1213
        dfa->lex.brack.cset = (ptrdiff_t )-1;
      } else {
        {
#line 1213
        tmp___22 = charclass_index___0(dfa, & ccl);
#line 1213
        dfa->lex.brack.cset = tmp___22;
        }
      }
#line 1214
      return ((token )273);
    }
  }
#line 1217
  if (invert) {
    {
#line 1219
    notset___0(& ccl);
    }
#line 1220
    if (dfa->syntax.syntax_bits & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 1221
      clrbit___0((unsigned int )'\n', & ccl);
      }
    }
  }
  {
#line 1224
  tmp___24 = charclass_index___0(dfa, & ccl);
  }
#line 1224
  return (275L + tmp___24);
}
}
#line 1233 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void push_lex_state___0(struct dfa *dfa , struct lexptr *ls , char const   *s ) 
{ 


  {
  {
#line 1236
  ls->ptr = dfa->lex.ptr;
#line 1237
  ls->left = dfa->lex.left;
#line 1238
  dfa->lex.ptr = s;
#line 1239
  dfa->lex.left = strlen(s);
  }
#line 1240
  return;
}
}
#line 1242 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void pop_lex_state___0(struct dfa *dfa , struct lexptr  const  *ls ) 
{ 


  {
#line 1245
  dfa->lex.ptr = (char const   *)ls->ptr;
#line 1246
  dfa->lex.left = (size_t )ls->left;
#line 1247
  return;
}
}
#line 1249 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static token lex___0(struct dfa *dfa ) 
{ 
  _Bool backslash ;
  int i ;
  token tmp ;
  int c ;
  int tmp___0 ;
  char *tmp___1 ;
  token tmp___2 ;
  token tmp___3 ;
  token tmp___4 ;
  token tmp___5 ;
  token tmp___6 ;
  token tmp___7 ;
  token tmp___8 ;
  token tmp___9 ;
  token tmp___10 ;
  token tmp___11 ;
  token tmp___12 ;
  token tmp___13 ;
  char const   *p ;
  char const   *lim ;
  int tmp___14 ;
  int tmp___15 ;
  _Bool tmp___16 ;
  int tmp___17 ;
  _Bool tmp___18 ;
  char *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  token tmp___23 ;
  token tmp___24 ;
  token tmp___25 ;
  token tmp___26 ;
  token tmp___27 ;
  charclass ccl ;
  int c2 ;
  ptrdiff_t tmp___28 ;
  token tmp___29 ;
  charclass ccl___0 ;
  int c2___0 ;
  unsigned short const   **tmp___30 ;
  token tmp___31 ;
  ptrdiff_t tmp___32 ;
  struct lexptr ls ;
  charclass ccl___1 ;
  int c2___1 ;
  token tmp___33 ;
  ptrdiff_t tmp___34 ;
  struct lexptr ls___0 ;
  token tmp___35 ;
  token tmp___36 ;
  charclass ccl___2 ;
  token tmp___37 ;
  ptrdiff_t tmp___38 ;
  unsigned short const   **tmp___39 ;
  token tmp___40 ;

  {
#line 1252
  backslash = (_Bool)0;
#line 1260
  i = 0;
  {
#line 1260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1260
    if (! (i < 2)) {
#line 1260
      goto while_break;
    }
#line 1262
    if (! dfa->lex.left) {
#line 1263
      tmp = (token )-1;
#line 1263
      dfa->lex.lasttok = tmp;
#line 1263
      return (tmp);
    }
    {
#line 1264
    tmp___0 = fetch_wc___0(dfa);
#line 1264
    c = tmp___0;
    }
    {
#line 1268
    if (c == 92) {
#line 1268
      goto case_92;
    }
#line 1276
    if (c == 94) {
#line 1276
      goto case_94;
    }
#line 1285
    if (c == 36) {
#line 1285
      goto case_36;
    }
#line 1313
    if (c == 57) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 56) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 55) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 54) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 53) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 52) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 51) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 50) {
#line 1313
      goto case_57;
    }
#line 1313
    if (c == 49) {
#line 1313
      goto case_57;
    }
#line 1321
    if (c == 96) {
#line 1321
      goto case_96;
    }
#line 1329
    if (c == 39) {
#line 1329
      goto case_39;
    }
#line 1337
    if (c == 60) {
#line 1337
      goto case_60;
    }
#line 1342
    if (c == 62) {
#line 1342
      goto case_62;
    }
#line 1347
    if (c == 98) {
#line 1347
      goto case_98;
    }
#line 1352
    if (c == 66) {
#line 1352
      goto case_66;
    }
#line 1357
    if (c == 63) {
#line 1357
      goto case_63;
    }
#line 1367
    if (c == 42) {
#line 1367
      goto case_42;
    }
#line 1375
    if (c == 43) {
#line 1375
      goto case_43;
    }
#line 1385
    if (c == 123) {
#line 1385
      goto case_123;
    }
#line 1443
    if (c == 124) {
#line 1443
      goto case_124;
    }
#line 1451
    if (c == 10) {
#line 1451
      goto case_10;
    }
#line 1458
    if (c == 40) {
#line 1458
      goto case_40;
    }
#line 1465
    if (c == 41) {
#line 1465
      goto case_41;
    }
#line 1475
    if (c == 46) {
#line 1475
      goto case_46;
    }
#line 1498
    if (c == 83) {
#line 1498
      goto case_83;
    }
#line 1498
    if (c == 115) {
#line 1498
      goto case_83;
    }
#line 1531
    if (c == 87) {
#line 1531
      goto case_87;
    }
#line 1531
    if (c == 119) {
#line 1531
      goto case_87;
    }
#line 1564
    if (c == 91) {
#line 1564
      goto case_91;
    }
#line 1570
    goto normal_char;
    case_92: /* CIL Label */ 
#line 1269
    if (backslash) {
#line 1270
      goto normal_char;
    }
#line 1271
    if (dfa->lex.left == 0UL) {
      {
#line 1272
      tmp___1 = gettext("unfinished \\ escape");
#line 1272
      dfaerror((char const   *)tmp___1);
      }
    }
#line 1273
    backslash = (_Bool)1;
#line 1274
    goto switch_break;
    case_94: /* CIL Label */ 
#line 1277
    if (backslash) {
#line 1278
      goto normal_char;
    }
#line 1279
    if (dfa->syntax.syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1282
      tmp___2 = (token )258;
#line 1282
      dfa->lex.lasttok = tmp___2;
#line 1282
      return (tmp___2);
    } else
#line 1279
    if (dfa->lex.lasttok == -1L) {
#line 1282
      tmp___2 = (token )258;
#line 1282
      dfa->lex.lasttok = tmp___2;
#line 1282
      return (tmp___2);
    } else
#line 1279
    if (dfa->lex.lasttok == 270L) {
#line 1282
      tmp___2 = (token )258;
#line 1282
      dfa->lex.lasttok = tmp___2;
#line 1282
      return (tmp___2);
    } else
#line 1279
    if (dfa->lex.lasttok == 269L) {
#line 1282
      tmp___2 = (token )258;
#line 1282
      dfa->lex.lasttok = tmp___2;
#line 1282
      return (tmp___2);
    }
#line 1283
    goto normal_char;
    case_36: /* CIL Label */ 
#line 1286
    if (backslash) {
#line 1287
      goto normal_char;
    }
#line 1288
    if (dfa->syntax.syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1302
      tmp___3 = (token )259;
#line 1302
      dfa->lex.lasttok = tmp___3;
#line 1302
      return (tmp___3);
    } else
#line 1288
    if (dfa->lex.left == 0UL) {
#line 1302
      tmp___3 = (token )259;
#line 1302
      dfa->lex.lasttok = tmp___3;
#line 1302
      return (tmp___3);
    } else
#line 1288
    if (dfa->lex.left > (size_t )(! (dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1288
      if ((int const   )*(dfa->lex.ptr + (! (dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ((int const   )*(dfa->lex.ptr + 0) == 92))) == 41) {
#line 1302
        tmp___3 = (token )259;
#line 1302
        dfa->lex.lasttok = tmp___3;
#line 1302
        return (tmp___3);
      } else {
#line 1288
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1288
    if (dfa->lex.left > (size_t )(! (dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1288
      if ((int const   )*(dfa->lex.ptr + (! (dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ((int const   )*(dfa->lex.ptr + 0) == 92))) == 124) {
#line 1302
        tmp___3 = (token )259;
#line 1302
        dfa->lex.lasttok = tmp___3;
#line 1302
        return (tmp___3);
      } else {
#line 1288
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1288
    if (dfa->syntax.syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1288
      if (dfa->lex.left > 0UL) {
#line 1288
        if ((int const   )*(dfa->lex.ptr + 0) == 10) {
#line 1302
          tmp___3 = (token )259;
#line 1302
          dfa->lex.lasttok = tmp___3;
#line 1302
          return (tmp___3);
        }
      }
    }
#line 1303
    goto normal_char;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1314
    if (backslash) {
#line 1314
      if (! (dfa->syntax.syntax_bits & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1316
        dfa->lex.laststart = (_Bool)0;
#line 1317
        tmp___4 = (token )257;
#line 1317
        dfa->lex.lasttok = tmp___4;
#line 1317
        return (tmp___4);
      }
    }
#line 1319
    goto normal_char;
    case_96: /* CIL Label */ 
#line 1322
    if (backslash) {
#line 1322
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1325
        tmp___5 = (token )258;
#line 1325
        dfa->lex.lasttok = tmp___5;
#line 1325
        return (tmp___5);
      }
    }
#line 1327
    goto normal_char;
    case_39: /* CIL Label */ 
#line 1330
    if (backslash) {
#line 1330
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1333
        tmp___6 = (token )259;
#line 1333
        dfa->lex.lasttok = tmp___6;
#line 1333
        return (tmp___6);
      }
    }
#line 1335
    goto normal_char;
    case_60: /* CIL Label */ 
#line 1338
    if (backslash) {
#line 1338
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1339
        tmp___7 = (token )260;
#line 1339
        dfa->lex.lasttok = tmp___7;
#line 1339
        return (tmp___7);
      }
    }
#line 1340
    goto normal_char;
    case_62: /* CIL Label */ 
#line 1343
    if (backslash) {
#line 1343
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1344
        tmp___8 = (token )261;
#line 1344
        dfa->lex.lasttok = tmp___8;
#line 1344
        return (tmp___8);
      }
    }
#line 1345
    goto normal_char;
    case_98: /* CIL Label */ 
#line 1348
    if (backslash) {
#line 1348
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1349
        tmp___9 = (token )262;
#line 1349
        dfa->lex.lasttok = tmp___9;
#line 1349
        return (tmp___9);
      }
    }
#line 1350
    goto normal_char;
    case_66: /* CIL Label */ 
#line 1353
    if (backslash) {
#line 1353
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1354
        tmp___10 = (token )263;
#line 1354
        dfa->lex.lasttok = tmp___10;
#line 1354
        return (tmp___10);
      }
    }
#line 1355
    goto normal_char;
    case_63: /* CIL Label */ 
#line 1358
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1359
      goto normal_char;
    }
#line 1360
    if ((int )backslash != ((dfa->syntax.syntax_bits & (1UL << 1)) != 0UL)) {
#line 1361
      goto normal_char;
    }
#line 1362
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1362
      if (dfa->lex.laststart) {
#line 1364
        goto normal_char;
      }
    }
#line 1365
    tmp___11 = (token )264;
#line 1365
    dfa->lex.lasttok = tmp___11;
#line 1365
    return (tmp___11);
    case_42: /* CIL Label */ 
#line 1368
    if (backslash) {
#line 1369
      goto normal_char;
    }
#line 1370
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1370
      if (dfa->lex.laststart) {
#line 1372
        goto normal_char;
      }
    }
#line 1373
    tmp___12 = (token )265;
#line 1373
    dfa->lex.lasttok = tmp___12;
#line 1373
    return (tmp___12);
    case_43: /* CIL Label */ 
#line 1376
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1377
      goto normal_char;
    }
#line 1378
    if ((int )backslash != ((dfa->syntax.syntax_bits & (1UL << 1)) != 0UL)) {
#line 1379
      goto normal_char;
    }
#line 1380
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1380
      if (dfa->lex.laststart) {
#line 1382
        goto normal_char;
      }
    }
#line 1383
    tmp___13 = (token )266;
#line 1383
    dfa->lex.lasttok = tmp___13;
#line 1383
    return (tmp___13);
    case_123: /* CIL Label */ 
#line 1386
    if (! (dfa->syntax.syntax_bits & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1387
      goto normal_char;
    }
#line 1388
    if ((int )backslash != ((dfa->syntax.syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1389
      goto normal_char;
    }
#line 1390
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1390
      if (dfa->lex.laststart) {
#line 1392
        goto normal_char;
      }
    }
#line 1401
    p = dfa->lex.ptr;
#line 1402
    lim = p + dfa->lex.left;
#line 1403
    tmp___14 = -1;
#line 1403
    dfa->lex.maxrep = tmp___14;
#line 1403
    dfa->lex.minrep = tmp___14;
    {
#line 1404
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1404
      if ((unsigned long )p != (unsigned long )lim) {
        {
#line 1404
        tmp___16 = isasciidigit___0((char )*p);
        }
#line 1404
        if (! tmp___16) {
#line 1404
          goto while_break___0;
        }
      } else {
#line 1404
        goto while_break___0;
      }
#line 1405
      if (dfa->lex.minrep < 0) {
#line 1405
        dfa->lex.minrep = (int )((int const   )*p - 48);
      } else {
#line 1405
        if (32768 < (dfa->lex.minrep * 10 + (int )*p) - 48) {
#line 1405
          tmp___15 = 32768;
        } else {
#line 1405
          tmp___15 = (dfa->lex.minrep * 10 + (int )*p) - 48;
        }
#line 1405
        dfa->lex.minrep = tmp___15;
      }
#line 1404
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1409
    if ((unsigned long )p != (unsigned long )lim) {
#line 1411
      if ((int const   )*p != 44) {
#line 1412
        dfa->lex.maxrep = dfa->lex.minrep;
      } else {
#line 1415
        if (dfa->lex.minrep < 0) {
#line 1416
          dfa->lex.minrep = 0;
        }
        {
#line 1417
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1417
          p ++;
#line 1417
          if ((unsigned long )p != (unsigned long )lim) {
            {
#line 1417
            tmp___18 = isasciidigit___0((char )*p);
            }
#line 1417
            if (! tmp___18) {
#line 1417
              goto while_break___1;
            }
          } else {
#line 1417
            goto while_break___1;
          }
#line 1418
          if (dfa->lex.maxrep < 0) {
#line 1418
            dfa->lex.maxrep = (int )((int const   )*p - 48);
          } else {
#line 1418
            if (32768 < (dfa->lex.maxrep * 10 + (int )*p) - 48) {
#line 1418
              tmp___17 = 32768;
            } else {
#line 1418
              tmp___17 = (dfa->lex.maxrep * 10 + (int )*p) - 48;
            }
#line 1418
            dfa->lex.maxrep = tmp___17;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 1425
    if (! backslash) {
#line 1425
      goto _L___5;
    } else
#line 1425
    if ((unsigned long )p != (unsigned long )lim) {
#line 1425
      tmp___20 = p;
#line 1425
      p ++;
#line 1425
      if ((int const   )*tmp___20 == 92) {
        _L___5: /* CIL Label */ 
#line 1425
        if ((unsigned long )p != (unsigned long )lim) {
#line 1425
          tmp___21 = p;
#line 1425
          p ++;
#line 1425
          if ((int const   )*tmp___21 == 125) {
#line 1425
            if (0 <= dfa->lex.minrep) {
#line 1425
              if (! (dfa->lex.maxrep < 0)) {
#line 1425
                if (! (dfa->lex.minrep <= dfa->lex.maxrep)) {
#line 1425
                  goto _L___6;
                }
              }
            } else {
#line 1425
              goto _L___6;
            }
          } else {
#line 1425
            goto _L___6;
          }
        } else {
#line 1425
          goto _L___6;
        }
      } else {
#line 1425
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
#line 1431
      if (dfa->syntax.syntax_bits & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1432
        goto normal_char;
      }
      {
#line 1433
      tmp___19 = gettext("invalid content of \\{\\}");
#line 1433
      dfaerror((char const   *)tmp___19);
      }
    }
#line 1435
    if (32767 < dfa->lex.maxrep) {
      {
#line 1436
      tmp___22 = gettext("regular expression too big");
#line 1436
      dfaerror((char const   *)tmp___22);
      }
    }
#line 1437
    dfa->lex.ptr = p;
#line 1438
    dfa->lex.left = (size_t )(lim - p);
#line 1440
    dfa->lex.laststart = (_Bool)0;
#line 1441
    tmp___23 = (token )267;
#line 1441
    dfa->lex.lasttok = tmp___23;
#line 1441
    return (tmp___23);
    case_124: /* CIL Label */ 
#line 1444
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1445
      goto normal_char;
    }
#line 1446
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1447
      goto normal_char;
    }
#line 1448
    dfa->lex.laststart = (_Bool)1;
#line 1449
    tmp___24 = (token )269;
#line 1449
    dfa->lex.lasttok = tmp___24;
#line 1449
    return (tmp___24);
    case_10: /* CIL Label */ 
#line 1452
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1454
      goto normal_char;
    } else
#line 1452
    if (backslash) {
#line 1454
      goto normal_char;
    } else
#line 1452
    if (! (dfa->syntax.syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1454
      goto normal_char;
    }
#line 1455
    dfa->lex.laststart = (_Bool)1;
#line 1456
    tmp___25 = (token )269;
#line 1456
    dfa->lex.lasttok = tmp___25;
#line 1456
    return (tmp___25);
    case_40: /* CIL Label */ 
#line 1459
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1460
      goto normal_char;
    }
#line 1461
    (dfa->lex.parens) ++;
#line 1462
    dfa->lex.laststart = (_Bool)1;
#line 1463
    tmp___26 = (token )270;
#line 1463
    dfa->lex.lasttok = tmp___26;
#line 1463
    return (tmp___26);
    case_41: /* CIL Label */ 
#line 1466
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1467
      goto normal_char;
    }
#line 1468
    if (dfa->lex.parens == 0UL) {
#line 1468
      if (dfa->syntax.syntax_bits & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1470
        goto normal_char;
      }
    }
#line 1471
    (dfa->lex.parens) --;
#line 1472
    dfa->lex.laststart = (_Bool)0;
#line 1473
    tmp___27 = (token )271;
#line 1473
    dfa->lex.lasttok = tmp___27;
#line 1473
    return (tmp___27);
    case_46: /* CIL Label */ 
#line 1476
    if (backslash) {
#line 1477
      goto normal_char;
    }
#line 1478
    if (dfa->canychar == 0xffffffffffffffffUL) {
      {
#line 1481
      fillset___0(& ccl);
      }
#line 1482
      if (! (dfa->syntax.syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
        {
#line 1483
        clrbit___0((unsigned int )'\n', & ccl);
        }
      }
#line 1484
      if (dfa->syntax.syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
#line 1485
        clrbit___0((unsigned int )'\000', & ccl);
        }
      }
#line 1486
      if (dfa->localeinfo.multibyte) {
#line 1487
        c2 = 0;
        {
#line 1487
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1487
          if (! (c2 < 256)) {
#line 1487
            goto while_break___2;
          }
#line 1488
          if (dfa->localeinfo.sbctowc[c2] == 4294967295U) {
            {
#line 1489
            clrbit___0((unsigned int )c2, & ccl);
            }
          }
#line 1487
          c2 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 1490
      tmp___28 = charclass_index___0(dfa, & ccl);
#line 1490
      dfa->canychar = (size_t )tmp___28;
      }
    }
#line 1492
    dfa->lex.laststart = (_Bool)0;
#line 1493
    if (dfa->localeinfo.multibyte) {
#line 1493
      tmp___29 = (token )272;
    } else {
#line 1493
      tmp___29 = (token )(275UL + dfa->canychar);
    }
#line 1493
    dfa->lex.lasttok = tmp___29;
#line 1493
    return (tmp___29);
    case_83: /* CIL Label */ 
    case_115: /* CIL Label */ 
#line 1499
    if (! backslash) {
#line 1500
      goto normal_char;
    } else
#line 1499
    if (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1500
      goto normal_char;
    }
#line 1501
    if (! dfa->localeinfo.multibyte) {
      {
#line 1504
      zeroset___0(& ccl___0);
#line 1505
      c2___0 = 0;
      }
      {
#line 1505
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1505
        if (! (c2___0 < 256)) {
#line 1505
          goto while_break___3;
        }
        {
#line 1506
        tmp___30 = __ctype_b_loc();
        }
#line 1506
        if ((int const   )*(*tmp___30 + c2___0) & 8192) {
          {
#line 1507
          setbit___0((unsigned int )c2___0, & ccl___0);
          }
        }
#line 1505
        c2___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1508
      if (c == 83) {
        {
#line 1509
        notset___0(& ccl___0);
        }
      }
      {
#line 1510
      dfa->lex.laststart = (_Bool)0;
#line 1511
      tmp___32 = charclass_index___0(dfa, & ccl___0);
#line 1511
      tmp___31 = 275L + tmp___32;
#line 1511
      dfa->lex.lasttok = tmp___31;
      }
#line 1511
      return (tmp___31);
    }
    {
#line 1522
    push_lex_state___0(dfa, & ls, "^[:space:]]" + (c == 115));
#line 1523
    dfa->lex.lasttok = parse_bracket_exp___0(dfa);
#line 1524
    pop_lex_state___0(dfa, (struct lexptr  const  *)(& ls));
#line 1527
    dfa->lex.laststart = (_Bool)0;
    }
#line 1528
    return (dfa->lex.lasttok);
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
#line 1532
    if (! backslash) {
#line 1533
      goto normal_char;
    } else
#line 1532
    if (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1533
      goto normal_char;
    }
#line 1535
    if (! dfa->localeinfo.multibyte) {
      {
#line 1538
      zeroset___0(& ccl___1);
#line 1539
      c2___1 = 0;
      }
      {
#line 1539
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1539
        if (! (c2___1 < 256)) {
#line 1539
          goto while_break___4;
        }
#line 1540
        if ((int )dfa->syntax.sbit[c2___1] == 2) {
          {
#line 1541
          setbit___0((unsigned int )c2___1, & ccl___1);
          }
        }
#line 1539
        c2___1 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1542
      if (c == 87) {
        {
#line 1543
        notset___0(& ccl___1);
        }
      }
      {
#line 1544
      dfa->lex.laststart = (_Bool)0;
#line 1545
      tmp___34 = charclass_index___0(dfa, & ccl___1);
#line 1545
      tmp___33 = 275L + tmp___34;
#line 1545
      dfa->lex.lasttok = tmp___33;
      }
#line 1545
      return (tmp___33);
    }
    {
#line 1556
    push_lex_state___0(dfa, & ls___0, "^_[:alnum:]]" + (c == 119));
#line 1557
    dfa->lex.lasttok = parse_bracket_exp___0(dfa);
#line 1558
    pop_lex_state___0(dfa, (struct lexptr  const  *)(& ls___0));
#line 1561
    dfa->lex.laststart = (_Bool)0;
    }
#line 1562
    return (dfa->lex.lasttok);
    case_91: /* CIL Label */ 
#line 1565
    if (backslash) {
#line 1566
      goto normal_char;
    }
    {
#line 1567
    dfa->lex.laststart = (_Bool)0;
#line 1568
    tmp___35 = parse_bracket_exp___0(dfa);
#line 1568
    dfa->lex.lasttok = tmp___35;
    }
#line 1568
    return (tmp___35);
    normal_char: 
    switch_default: /* CIL Label */ 
#line 1572
    dfa->lex.laststart = (_Bool)0;
#line 1575
    if (dfa->localeinfo.multibyte) {
#line 1576
      tmp___36 = (token )274;
#line 1576
      dfa->lex.lasttok = tmp___36;
#line 1576
      return (tmp___36);
    }
#line 1578
    if (dfa->syntax.case_fold) {
      {
#line 1578
      tmp___39 = __ctype_b_loc();
      }
#line 1578
      if ((int const   )*(*tmp___39 + c) & 1024) {
        {
#line 1581
        zeroset___0(& ccl___2);
#line 1582
        setbit_case_fold_c___0(c, & ccl___2);
#line 1583
        tmp___38 = charclass_index___0(dfa, & ccl___2);
#line 1583
        tmp___37 = 275L + tmp___38;
#line 1583
        dfa->lex.lasttok = tmp___37;
        }
#line 1583
        return (tmp___37);
      }
    }
#line 1586
    tmp___40 = (token )c;
#line 1586
    dfa->lex.lasttok = tmp___40;
#line 1586
    return (tmp___40);
    switch_break: /* CIL Label */ ;
    }
#line 1260
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1592
  abort();
  }
#line 1593
  return ((token )-1);
}
}
#line 1596 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void addtok_mb___0(struct dfa *dfa , token t , char mbprop ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1599
  if (dfa->talloc == dfa->tindex) {
    {
#line 1601
    tmp = x2nrealloc((void *)dfa->tokens, & dfa->talloc, sizeof(*(dfa->tokens)));
#line 1601
    dfa->tokens = (token *)tmp;
    }
#line 1603
    if (dfa->localeinfo.multibyte) {
      {
#line 1604
      tmp___0 = xnrealloc((void *)dfa->multibyte_prop, dfa->talloc, sizeof(*(dfa->multibyte_prop)));
#line 1604
      dfa->multibyte_prop = (char *)tmp___0;
      }
    }
  }
#line 1607
  if (dfa->localeinfo.multibyte) {
#line 1608
    *(dfa->multibyte_prop + dfa->tindex) = mbprop;
  }
#line 1609
  tmp___1 = dfa->tindex;
#line 1609
  (dfa->tindex) ++;
#line 1609
  *(dfa->tokens + tmp___1) = t;
  {
#line 1615
  if (t == 266L) {
#line 1615
    goto case_266;
  }
#line 1615
  if (t == 265L) {
#line 1615
    goto case_266;
  }
#line 1615
  if (t == 264L) {
#line 1615
    goto case_266;
  }
#line 1619
  if (t == 269L) {
#line 1619
    goto case_269;
  }
#line 1619
  if (t == 268L) {
#line 1619
    goto case_269;
  }
#line 1623
  if (t == 257L) {
#line 1623
    goto case_257;
  }
#line 1629
  if (t == 256L) {
#line 1629
    goto case_256;
  }
#line 1626
  goto switch_default;
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
#line 1616
  goto switch_break;
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
#line 1620
  (dfa->parse.depth) --;
#line 1621
  goto switch_break;
  case_257: /* CIL Label */ 
#line 1624
  dfa->fast = (_Bool)0;
  switch_default: /* CIL Label */ 
#line 1627
  (dfa->nleaves) ++;
  case_256: /* CIL Label */ 
#line 1630
  (dfa->parse.depth) ++;
#line 1631
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1633
  if (dfa->parse.depth > dfa->depth) {
#line 1634
    dfa->depth = dfa->parse.depth;
  }
#line 1635
  return;
}
}
#line 1637
static void addtok_wc___0(struct dfa *dfa , wint_t wc ) ;
#line 1641 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void addtok___0(struct dfa *dfa , token t ) 
{ 
  _Bool need_or ;
  ptrdiff_t i ;

  {
#line 1644
  if (dfa->localeinfo.multibyte) {
#line 1644
    if (t == 273L) {
#line 1646
      need_or = (_Bool)0;
#line 1650
      i = (ptrdiff_t )0;
      {
#line 1650
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1650
        if (! (i < dfa->lex.brack.nchars)) {
#line 1650
          goto while_break;
        }
        {
#line 1652
        addtok_wc___0(dfa, (wint_t )*(dfa->lex.brack.chars + i));
        }
#line 1653
        if (need_or) {
          {
#line 1654
          addtok___0(dfa, (token )269);
          }
        }
#line 1655
        need_or = (_Bool)1;
#line 1650
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1657
      dfa->lex.brack.nchars = (ptrdiff_t )0;
#line 1661
      if (dfa->lex.brack.cset != -1L) {
        {
#line 1663
        addtok___0(dfa, 275L + dfa->lex.brack.cset);
        }
#line 1664
        if (need_or) {
          {
#line 1665
          addtok___0(dfa, (token )269);
          }
        }
      }
    } else {
      {
#line 1670
      addtok_mb___0(dfa, t, (char)3);
      }
    }
  } else {
    {
#line 1670
    addtok_mb___0(dfa, t, (char)3);
    }
  }
#line 1672
  return;
}
}
#line 1680 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void addtok_wc___0(struct dfa *dfa , wint_t wc ) 
{ 
  unsigned char buf[16] ;
  mbstate_t s ;
  size_t stored_bytes ;
  size_t tmp ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 1684
  s.__count = 0;
#line 1684
  s.__value.__wch = 0U;
#line 1685
  tmp = wcrtomb((char */* __restrict  */)((char *)(buf)), (wchar_t )wc, (mbstate_t */* __restrict  */)(& s));
#line 1685
  stored_bytes = tmp;
  }
#line 1687
  if (stored_bytes != 0xffffffffffffffffUL) {
#line 1688
    dfa->lex.cur_mb_len = (int )stored_bytes;
  } else {
#line 1693
    dfa->lex.cur_mb_len = 1;
#line 1694
    buf[0] = (unsigned char)0;
  }
#line 1697
  if (dfa->lex.cur_mb_len == 1) {
#line 1697
    tmp___0 = 3;
  } else {
#line 1697
    tmp___0 = 1;
  }
  {
#line 1697
  addtok_mb___0(dfa, (token )buf[0], (char )tmp___0);
#line 1698
  i = 1;
  }
  {
#line 1698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1698
    if (! (i < dfa->lex.cur_mb_len)) {
#line 1698
      goto while_break;
    }
#line 1700
    if (i == dfa->lex.cur_mb_len - 1) {
#line 1700
      tmp___1 = 2;
    } else {
#line 1700
      tmp___1 = 0;
    }
    {
#line 1700
    addtok_mb___0(dfa, (token )buf[i], (char )tmp___1);
#line 1701
    addtok___0(dfa, (token )268);
#line 1698
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1703
  return;
}
}
#line 1708
static void add_utf8_anychar___0(struct dfa *dfa ) ;
#line 1708 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static charclass const   utf8_classes___0[5]  = {      {{0UL, 0UL, (4294967295UL << 32) + 4294967295UL, 0UL}}, 
        {{(4294967295UL << 32) + 4294967295UL, (4294967295UL << 32) + 4294967295UL, 0UL,
       0UL}}, 
        {{0UL, 0UL, 0UL, 4294967292UL}}, 
        {{0UL, 0UL, 0UL, 65535UL << 32}}, 
        {{0UL, 0UL, 0UL, 16711680UL << 32}}};
#line 1705 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void add_utf8_anychar___0(struct dfa *dfa ) 
{ 
  unsigned int n ;
  unsigned int i ;
  charclass c ;
  ptrdiff_t tmp ;
  unsigned int i___0 ;

  {
#line 1724
  n = (unsigned int )(sizeof(utf8_classes___0) / sizeof(utf8_classes___0[0]));
#line 1727
  if (dfa->utf8_anychar_classes[0] == 0L) {
#line 1728
    i = 0U;
    {
#line 1728
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1728
      if (! (i < n)) {
#line 1728
        goto while_break;
      }
#line 1730
      c = utf8_classes___0[i];
#line 1731
      if (i == 1U) {
#line 1733
        if (! (dfa->syntax.syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
          {
#line 1734
          clrbit___0((unsigned int )'\n', & c);
          }
        }
#line 1735
        if (dfa->syntax.syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          {
#line 1736
          clrbit___0((unsigned int )'\000', & c);
          }
        }
      }
      {
#line 1738
      tmp = charclass_index___0(dfa, & c);
#line 1738
      dfa->utf8_anychar_classes[i] = 275L + tmp;
#line 1728
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1752
  i___0 = 1U;
  {
#line 1752
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1752
    if (! (i___0 < n)) {
#line 1752
      goto while_break___0;
    }
    {
#line 1753
    addtok___0(dfa, dfa->utf8_anychar_classes[i___0]);
#line 1752
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1754
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1754
    i___0 --;
#line 1754
    if (! (i___0 > 1U)) {
#line 1754
      goto while_break___1;
    }
    {
#line 1756
    addtok___0(dfa, dfa->utf8_anychar_classes[0]);
#line 1757
    addtok___0(dfa, (token )268);
#line 1758
    addtok___0(dfa, (token )269);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1760
  return;
}
}
#line 1797 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void atom___0(struct dfa *dfa ) 
{ 
  wchar_t folded[32] ;
  unsigned int n ;
  int tmp ;
  unsigned int i ;
  char *tmp___0 ;

  {
#line 1800
  if (dfa->parse.tok == 274L) {
#line 1802
    if (dfa->lex.wctok == 4294967295U) {
      {
#line 1803
      addtok___0(dfa, (token )257);
      }
    } else {
      {
#line 1806
      addtok_wc___0(dfa, dfa->lex.wctok);
      }
#line 1808
      if (dfa->syntax.case_fold) {
        {
#line 1811
        tmp = case_folded_counterparts(dfa->lex.wctok, (wchar_t *)(folded));
#line 1811
        n = (unsigned int )tmp;
#line 1813
        i = 0U;
        }
        {
#line 1813
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1813
          if (! (i < n)) {
#line 1813
            goto while_break;
          }
          {
#line 1815
          addtok_wc___0(dfa, (wint_t )folded[i]);
#line 1816
          addtok___0(dfa, (token )269);
#line 1813
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 1821
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1823
  if (dfa->parse.tok == 272L) {
#line 1823
    if (dfa->localeinfo.using_utf8) {
      {
#line 1832
      add_utf8_anychar___0(dfa);
#line 1833
      dfa->parse.tok = lex___0(dfa);
      }
    } else {
#line 1823
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1835
  if (0L <= dfa->parse.tok) {
#line 1835
    if (dfa->parse.tok < 256L) {
      {
#line 1842
      addtok___0(dfa, dfa->parse.tok);
#line 1843
      dfa->parse.tok = lex___0(dfa);
      }
    } else {
#line 1835
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1835
  if (dfa->parse.tok >= 275L) {
    {
#line 1842
    addtok___0(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 257L) {
    {
#line 1842
    addtok___0(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 258L) {
    {
#line 1842
    addtok___0(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 259L) {
    {
#line 1842
    addtok___0(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 260L) {
    {
#line 1842
    addtok___0(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 272L) {
    {
#line 1842
    addtok___0(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 273L) {
    {
#line 1842
    addtok___0(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 261L) {
    {
#line 1842
    addtok___0(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 262L) {
    {
#line 1842
    addtok___0(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1835
  if (dfa->parse.tok == 263L) {
    {
#line 1842
    addtok___0(dfa, dfa->parse.tok);
#line 1843
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1845
  if (dfa->parse.tok == 270L) {
    {
#line 1847
    dfa->parse.tok = lex___0(dfa);
#line 1848
    regexp___0(dfa);
    }
#line 1849
    if (dfa->parse.tok != 271L) {
      {
#line 1850
      tmp___0 = gettext("unbalanced (");
#line 1850
      dfaerror((char const   *)tmp___0);
      }
    }
    {
#line 1851
    dfa->parse.tok = lex___0(dfa);
    }
  } else {
    {
#line 1854
    addtok___0(dfa, (token )256);
    }
  }
#line 1855
  return;
}
}
#line 1858 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static size_t __attribute__((__pure__))  nsubtoks___0(struct dfa  const  *dfa , size_t tindex ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t ntoks1 ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 1867
  if (*(dfa->tokens + (tindex - 1UL)) == 266L) {
#line 1867
    goto case_266;
  }
#line 1867
  if (*(dfa->tokens + (tindex - 1UL)) == 265L) {
#line 1867
    goto case_266;
  }
#line 1867
  if (*(dfa->tokens + (tindex - 1UL)) == 264L) {
#line 1867
    goto case_266;
  }
#line 1870
  if (*(dfa->tokens + (tindex - 1UL)) == 269L) {
#line 1870
    goto case_269;
  }
#line 1870
  if (*(dfa->tokens + (tindex - 1UL)) == 268L) {
#line 1870
    goto case_269;
  }
#line 1863
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1864
  return ((size_t __attribute__((__pure__))  )1);
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
  {
#line 1868
  tmp = nsubtoks___0(dfa, tindex - 1UL);
  }
#line 1868
  return ((size_t __attribute__((__pure__))  )1 + tmp);
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
  {
#line 1872
  tmp___0 = nsubtoks___0(dfa, tindex - 1UL);
#line 1872
  ntoks1 = (size_t )tmp___0;
#line 1873
  tmp___1 = nsubtoks___0(dfa, (tindex - 1UL) - ntoks1);
  }
#line 1873
  return ((size_t __attribute__((__pure__))  )((1UL + ntoks1) + (size_t )tmp___1));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1879 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void copytoks___0(struct dfa *dfa , size_t tindex , size_t ntokens ) 
{ 
  size_t i ;
  size_t i___0 ;

  {
#line 1882
  if (dfa->localeinfo.multibyte) {
#line 1883
    i = (size_t )0;
    {
#line 1883
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1883
      if (! (i < ntokens)) {
#line 1883
        goto while_break;
      }
      {
#line 1884
      addtok_mb___0(dfa, *(dfa->tokens + (tindex + i)), *(dfa->multibyte_prop + (tindex + i)));
#line 1883
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1887
    i___0 = (size_t )0;
    {
#line 1887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1887
      if (! (i___0 < ntokens)) {
#line 1887
        goto while_break___0;
      }
      {
#line 1888
      addtok_mb___0(dfa, *(dfa->tokens + (tindex + i___0)), (char)3);
#line 1887
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1889
  return;
}
}
#line 1891 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void closure___0(struct dfa *dfa ) 
{ 
  size_t ntokens ;
  size_t __attribute__((__pure__))  tmp ;
  size_t tindex ;
  int i ;
  size_t __attribute__((__pure__))  tmp___0 ;

  {
  {
#line 1894
  atom___0(dfa);
  }
  {
#line 1895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1895
    if (! (dfa->parse.tok == 264L)) {
#line 1895
      if (! (dfa->parse.tok == 265L)) {
#line 1895
        if (! (dfa->parse.tok == 266L)) {
#line 1895
          if (! (dfa->parse.tok == 267L)) {
#line 1895
            goto while_break;
          }
        }
      }
    }
#line 1897
    if (dfa->parse.tok == 267L) {
#line 1897
      if (dfa->lex.minrep) {
#line 1897
        goto _L___0;
      } else
#line 1897
      if (dfa->lex.maxrep) {
        _L___0: /* CIL Label */ 
        {
#line 1899
        tmp = nsubtoks___0((struct dfa  const  *)dfa, dfa->tindex);
#line 1899
        ntokens = (size_t )tmp;
#line 1900
        tindex = dfa->tindex - ntokens;
        }
#line 1901
        if (dfa->lex.maxrep < 0) {
          {
#line 1902
          addtok___0(dfa, (token )266);
          }
        }
#line 1903
        if (dfa->lex.minrep == 0) {
          {
#line 1904
          addtok___0(dfa, (token )264);
          }
        }
#line 1906
        i = 1;
        {
#line 1906
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1906
          if (! (i < dfa->lex.minrep)) {
#line 1906
            goto while_break___0;
          }
          {
#line 1908
          copytoks___0(dfa, tindex, ntokens);
#line 1909
          addtok___0(dfa, (token )268);
#line 1906
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1911
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1911
          if (! (i < dfa->lex.maxrep)) {
#line 1911
            goto while_break___1;
          }
          {
#line 1913
          copytoks___0(dfa, tindex, ntokens);
#line 1914
          addtok___0(dfa, (token )264);
#line 1915
          addtok___0(dfa, (token )268);
#line 1911
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1917
        dfa->parse.tok = lex___0(dfa);
        }
      } else {
#line 1897
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1919
    if (dfa->parse.tok == 267L) {
      {
#line 1921
      tmp___0 = nsubtoks___0((struct dfa  const  *)dfa, dfa->tindex);
#line 1921
      dfa->tindex -= (size_t )tmp___0;
#line 1922
      dfa->parse.tok = lex___0(dfa);
#line 1923
      closure___0(dfa);
      }
    } else {
      {
#line 1927
      addtok___0(dfa, dfa->parse.tok);
#line 1928
      dfa->parse.tok = lex___0(dfa);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1930
  return;
}
}
#line 1932 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void branch___0(struct dfa *dfa ) 
{ 


  {
  {
#line 1935
  closure___0(dfa);
  }
  {
#line 1936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1936
    if (dfa->parse.tok != 271L) {
#line 1936
      if (dfa->parse.tok != 269L) {
#line 1936
        if (! (dfa->parse.tok >= 0L)) {
#line 1936
          goto while_break;
        }
      } else {
#line 1936
        goto while_break;
      }
    } else {
#line 1936
      goto while_break;
    }
    {
#line 1939
    closure___0(dfa);
#line 1940
    addtok___0(dfa, (token )268);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1942
  return;
}
}
#line 1944 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void regexp___0(struct dfa *dfa ) 
{ 


  {
  {
#line 1947
  branch___0(dfa);
  }
  {
#line 1948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1948
    if (! (dfa->parse.tok == 269L)) {
#line 1948
      goto while_break;
    }
    {
#line 1950
    dfa->parse.tok = lex___0(dfa);
#line 1951
    branch___0(dfa);
#line 1952
    addtok___0(dfa, (token )269);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1954
  return;
}
}
#line 1959 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void dfaparse___0(char const   *s , size_t len , struct dfa *d ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 1962
  d->lex.ptr = s;
#line 1963
  d->lex.left = len;
#line 1964
  d->lex.lasttok = (token )-1;
#line 1965
  d->lex.laststart = (_Bool)1;
#line 1967
  if (! d->syntax.syntax_bits_set) {
    {
#line 1968
    tmp = gettext("no syntax specified");
#line 1968
    dfaerror((char const   *)tmp);
    }
  }
  {
#line 1970
  d->parse.tok = lex___0(d);
#line 1971
  d->parse.depth = d->depth;
#line 1973
  regexp___0(d);
  }
#line 1975
  if (d->parse.tok != -1L) {
    {
#line 1976
    tmp___0 = gettext("unbalanced )");
#line 1976
    dfaerror((char const   *)tmp___0);
    }
  }
  {
#line 1978
  addtok___0(d, (token )(0xffffffffffffffffUL - d->nregexps));
#line 1979
  addtok___0(d, (token )268);
  }
#line 1981
  if (d->nregexps) {
    {
#line 1982
    addtok___0(d, (token )269);
    }
  }
#line 1984
  (d->nregexps) ++;
#line 1985
  return;
}
}
#line 1990 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void copy___0(position_set const   *src , position_set *dst ) 
{ 
  void *tmp ;

  {
#line 1993
  if (dst->alloc < (ptrdiff_t )src->nelem) {
    {
#line 1995
    free((void *)dst->elems);
#line 1996
    tmp = xpalloc___0((void *)0, & dst->alloc, (ptrdiff_t )(src->nelem - (ptrdiff_t const   )dst->alloc),
                      (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(dst->elems)));
#line 1996
    dst->elems = (position *)tmp;
    }
  }
#line 1999
  dst->nelem = (ptrdiff_t )src->nelem;
#line 2000
  if (src->nelem != 0L) {
    {
#line 2001
    memcpy((void */* __restrict  */)dst->elems, (void const   */* __restrict  */)src->elems,
           (unsigned long )src->nelem * sizeof(*(dst->elems)));
    }
  }
#line 2002
  return;
}
}
#line 2004 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void alloc_position_set___0(position_set *s , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2007
  tmp = xnmalloc(size, sizeof(*(s->elems)));
#line 2007
  s->elems = (position *)tmp;
#line 2008
  s->alloc = (ptrdiff_t )size;
#line 2009
  s->nelem = (ptrdiff_t )0;
  }
#line 2010
  return;
}
}
#line 2016 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void insert___0(position p , position_set *s ) 
{ 
  ptrdiff_t count ;
  ptrdiff_t lo ;
  ptrdiff_t hi ;
  ptrdiff_t mid ;
  void *tmp ;
  ptrdiff_t i ;

  {
#line 2019
  count = s->nelem;
#line 2020
  lo = (ptrdiff_t )0;
#line 2020
  hi = count;
  {
#line 2021
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2021
    if (! (lo < hi)) {
#line 2021
      goto while_break;
    }
#line 2023
    mid = (lo + hi) >> 1;
#line 2024
    if ((s->elems + mid)->index > p.index) {
#line 2025
      lo = mid + 1L;
    } else
#line 2026
    if ((s->elems + mid)->index == p.index) {
#line 2028
      (s->elems + mid)->constraint |= p.constraint;
#line 2029
      return;
    } else {
#line 2032
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2035
  tmp = maybe_realloc___0((void *)s->elems, count, & s->alloc, (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(s->elems)));
#line 2035
  s->elems = (position *)tmp;
#line 2036
  i = count;
  }
  {
#line 2036
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2036
    if (! (i > lo)) {
#line 2036
      goto while_break___0;
    }
#line 2037
    *(s->elems + i) = *(s->elems + (i - 1L));
#line 2036
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2038
  *(s->elems + lo) = p;
#line 2039
  (s->nelem) ++;
#line 2040
  return;
}
}
#line 2045 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void merge_constrained___0(position_set const   *s1 , position_set const   *s2 ,
                                  unsigned int c2 , position_set *m ) 
{ 
  ptrdiff_t i ;
  ptrdiff_t j ;
  void *tmp ;
  unsigned int c ;
  ptrdiff_t tmp___0 ;
  unsigned int tmp___1 ;
  ptrdiff_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  ptrdiff_t tmp___4 ;

  {
#line 2049
  i = (ptrdiff_t )0;
#line 2049
  j = (ptrdiff_t )0;
#line 2051
  if (m->alloc - (ptrdiff_t )s1->nelem < (ptrdiff_t )s2->nelem) {
    {
#line 2053
    free((void *)m->elems);
#line 2054
    m->alloc = (ptrdiff_t )s1->nelem;
#line 2055
    tmp = xpalloc___0((void *)0, & m->alloc, (ptrdiff_t )s2->nelem, (ptrdiff_t )-1,
                      (ptrdiff_t )sizeof(*(m->elems)));
#line 2055
    m->elems = (position *)tmp;
    }
  }
#line 2057
  m->nelem = (ptrdiff_t )0;
  {
#line 2058
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2058
    if (! (i < (ptrdiff_t )s1->nelem)) {
#line 2058
      if (! (j < (ptrdiff_t )s2->nelem)) {
#line 2058
        goto while_break;
      }
    }
#line 2059
    if (! (j < (ptrdiff_t )s2->nelem)) {
#line 2059
      goto _L;
    } else
#line 2059
    if (i < (ptrdiff_t )s1->nelem) {
#line 2059
      if ((s1->elems + i)->index >= (s2->elems + j)->index) {
        _L: /* CIL Label */ 
#line 2062
        if (i < (ptrdiff_t )s1->nelem) {
#line 2062
          if (j < (ptrdiff_t )s2->nelem) {
#line 2062
            if ((s1->elems + i)->index == (s2->elems + j)->index) {
#line 2062
              tmp___0 = j;
#line 2062
              j ++;
#line 2062
              tmp___1 = (s2->elems + tmp___0)->constraint & c2;
            } else {
#line 2062
              tmp___1 = 0U;
            }
          } else {
#line 2062
            tmp___1 = 0U;
          }
        } else {
#line 2062
          tmp___1 = 0U;
        }
#line 2062
        c = tmp___1;
#line 2066
        (m->elems + m->nelem)->index = (s1->elems + i)->index;
#line 2067
        tmp___2 = m->nelem;
#line 2067
        (m->nelem) ++;
#line 2067
        tmp___3 = i;
#line 2067
        i ++;
#line 2067
        (m->elems + tmp___2)->constraint = (s1->elems + tmp___3)->constraint | c;
      } else {
#line 2059
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2071
      if ((s2->elems + j)->constraint & c2) {
#line 2073
        (m->elems + m->nelem)->index = (s2->elems + j)->index;
#line 2074
        tmp___4 = m->nelem;
#line 2074
        (m->nelem) ++;
#line 2074
        (m->elems + tmp___4)->constraint = (s2->elems + j)->constraint & c2;
      }
#line 2076
      j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2078
  return;
}
}
#line 2082 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void merge___0(position_set const   *s1 , position_set const   *s2 , position_set *m ) 
{ 


  {
  {
#line 2085
  merge_constrained___0(s1, s2, 4294967295U, m);
  }
#line 2086
  return;
}
}
#line 2090 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static unsigned int delete___0(size_t del , position_set *s ) 
{ 
  size_t count ;
  size_t lo ;
  size_t hi ;
  size_t mid ;
  unsigned int c ;
  size_t i ;

  {
#line 2093
  count = (size_t )s->nelem;
#line 2094
  lo = (size_t )0;
#line 2094
  hi = count;
  {
#line 2095
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2095
    if (! (lo < hi)) {
#line 2095
      goto while_break;
    }
#line 2097
    mid = (lo + hi) >> 1;
#line 2098
    if ((s->elems + mid)->index > del) {
#line 2099
      lo = mid + 1UL;
    } else
#line 2100
    if ((s->elems + mid)->index == del) {
#line 2102
      c = (s->elems + mid)->constraint;
#line 2104
      i = mid;
      {
#line 2104
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2104
        if (! (i + 1UL < count)) {
#line 2104
          goto while_break___0;
        }
#line 2105
        *(s->elems + i) = *(s->elems + (i + 1UL));
#line 2104
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2106
      s->nelem = (ptrdiff_t )i;
#line 2107
      return (c);
    } else {
#line 2110
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2112
  return (0U);
}
}
#line 2116 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void replace___0(position_set *dst , size_t del , position_set *add , unsigned int constraint ,
                        position_set *tmp ) 
{ 
  unsigned int c ;
  unsigned int tmp___0 ;

  {
  {
#line 2120
  tmp___0 = delete___0(del, dst);
#line 2120
  c = tmp___0 & constraint;
  }
#line 2122
  if (c) {
    {
#line 2124
    copy___0((position_set const   *)dst, tmp);
#line 2125
    merge_constrained___0((position_set const   *)tmp, (position_set const   *)add,
                          c, dst);
    }
  }
#line 2127
  return;
}
}
#line 2132 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static state_num state_index___0(struct dfa *d , position_set const   *s , int context ) 
{ 
  size_t hash ;
  int constraint ;
  state_num i ;
  token first_end ;
  state_num j ;
  state_num j___0 ;
  int c ;
  _Bool tmp ;
  void *tmp___0 ;

  {
#line 2135
  hash = (size_t )0;
#line 2136
  constraint = 0;
#line 2138
  first_end = (token )0;
#line 2140
  i = (state_num )0;
  {
#line 2140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2140
    if (! (i < (state_num )s->nelem)) {
#line 2140
      goto while_break;
    }
#line 2141
    hash ^= (s->elems + i)->index + (size_t )(s->elems + i)->constraint;
#line 2140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2144
  i = (state_num )0;
  {
#line 2144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2144
    if (! (i < d->sindex)) {
#line 2144
      goto while_break___0;
    }
#line 2146
    if (hash != (d->states + i)->hash) {
#line 2148
      goto __Cont;
    } else
#line 2146
    if (s->nelem != (ptrdiff_t const   )(d->states + i)->elems.nelem) {
#line 2148
      goto __Cont;
    } else
#line 2146
    if (context != (int )(d->states + i)->context) {
#line 2148
      goto __Cont;
    }
#line 2150
    j = (state_num )0;
    {
#line 2150
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2150
      if (! (j < (state_num )s->nelem)) {
#line 2150
        goto while_break___1;
      }
#line 2151
      if ((s->elems + j)->constraint != ((d->states + i)->elems.elems + j)->constraint) {
#line 2153
        goto while_break___1;
      } else
#line 2151
      if ((s->elems + j)->index != ((d->states + i)->elems.elems + j)->index) {
#line 2153
        goto while_break___1;
      }
#line 2150
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2154
    if (j == (state_num )s->nelem) {
#line 2155
      return (i);
    }
    __Cont: /* CIL Label */ 
#line 2144
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2180
  j___0 = (state_num )0;
  {
#line 2180
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2180
    if (! (j___0 < (state_num )s->nelem)) {
#line 2180
      goto while_break___2;
    }
#line 2182
    c = (int )(s->elems + j___0)->constraint;
#line 2183
    if (*(d->tokens + (s->elems + j___0)->index) < 0L) {
      {
#line 2185
      tmp = succeeds_in_context___0(c, context, 7);
      }
#line 2185
      if (tmp) {
#line 2186
        constraint |= c;
      }
#line 2187
      if (! first_end) {
#line 2188
        first_end = *(d->tokens + (s->elems + j___0)->index);
      }
    } else
#line 2190
    if (*(d->tokens + (s->elems + j___0)->index) == 257L) {
#line 2191
      constraint = 511;
    }
#line 2180
    j___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2196
  tmp___0 = maybe_realloc___0((void *)d->states, d->sindex, & d->salloc, (ptrdiff_t )-1,
                              (ptrdiff_t )sizeof(*(d->states)));
#line 2196
  d->states = (dfa_state *)tmp___0;
#line 2198
  (d->states + i)->hash = hash;
#line 2199
  alloc_position_set___0(& (d->states + i)->elems, (size_t )s->nelem);
#line 2200
  copy___0(s, & (d->states + i)->elems);
#line 2201
  (d->states + i)->context = (unsigned char )context;
#line 2202
  (d->states + i)->constraint = (unsigned short )constraint;
#line 2203
  (d->states + i)->first_end = first_end;
#line 2204
  (d->states + i)->mbps.nelem = (ptrdiff_t )0;
#line 2205
  (d->states + i)->mbps.elems = (position *)((void *)0);
#line 2206
  (d->states + i)->mb_trindex = (state_num )-1;
#line 2208
  (d->sindex) ++;
  }
#line 2210
  return (i);
}
}
#line 2218 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void epsclosure___0(position_set *initial , struct dfa  const  *d ) 
{ 
  position_set tmp ;
  size_t i ;
  unsigned int constraint ;
  size_t j ;

  {
  {
#line 2222
  alloc_position_set___0(& tmp, (size_t )d->nleaves);
#line 2223
  i = (size_t )0;
  }
  {
#line 2223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2223
    if (! (i < (size_t )d->tindex)) {
#line 2223
      goto while_break;
    }
#line 2224
    if ((d->follows + i)->nelem > 0L) {
#line 2224
      if (*(d->tokens + i) >= 256L) {
#line 2224
        if (*(d->tokens + i) != 257L) {
#line 2224
          if (*(d->tokens + i) != 272L) {
#line 2224
            if (*(d->tokens + i) != 273L) {
#line 2224
              if (*(d->tokens + i) < 275L) {
                {
#line 2231
                if (*(d->tokens + i) == 258L) {
#line 2231
                  goto case_258;
                }
#line 2234
                if (*(d->tokens + i) == 259L) {
#line 2234
                  goto case_259;
                }
#line 2237
                if (*(d->tokens + i) == 260L) {
#line 2237
                  goto case_260;
                }
#line 2240
                if (*(d->tokens + i) == 261L) {
#line 2240
                  goto case_261;
                }
#line 2243
                if (*(d->tokens + i) == 262L) {
#line 2243
                  goto case_262;
                }
#line 2246
                if (*(d->tokens + i) == 263L) {
#line 2246
                  goto case_263;
                }
#line 2249
                goto switch_default;
                case_258: /* CIL Label */ 
#line 2232
                constraint = 292U;
#line 2233
                goto switch_break;
                case_259: /* CIL Label */ 
#line 2235
                constraint = 448U;
#line 2236
                goto switch_break;
                case_260: /* CIL Label */ 
#line 2238
                constraint = 40U;
#line 2239
                goto switch_break;
                case_261: /* CIL Label */ 
#line 2241
                constraint = 130U;
#line 2242
                goto switch_break;
                case_262: /* CIL Label */ 
#line 2244
                constraint = 170U;
#line 2245
                goto switch_break;
                case_263: /* CIL Label */ 
#line 2247
                constraint = 341U;
#line 2248
                goto switch_break;
                switch_default: /* CIL Label */ 
#line 2250
                constraint = 511U;
#line 2251
                goto switch_break;
                switch_break: /* CIL Label */ ;
                }
                {
#line 2254
                delete___0(i, d->follows + i);
#line 2256
                j = (size_t )0;
                }
                {
#line 2256
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 2256
                  if (! (j < (size_t )d->tindex)) {
#line 2256
                    goto while_break___0;
                  }
#line 2257
                  if (i != j) {
#line 2257
                    if ((d->follows + j)->nelem > 0L) {
                      {
#line 2258
                      replace___0(d->follows + j, i, d->follows + i, constraint, & tmp);
                      }
                    }
                  }
#line 2256
                  j ++;
                }
                while_break___0: /* CIL Label */ ;
                }
                {
#line 2260
                replace___0(initial, i, d->follows + i, constraint, & tmp);
                }
              }
            }
          }
        }
      }
    }
#line 2223
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2262
  free((void *)tmp.elems);
  }
#line 2263
  return;
}
}
#line 2268 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int charclass_context___0(struct dfa  const  *dfa , charclass const   *c ) 
{ 
  int context ;
  unsigned int j ;

  {
#line 2271
  context = 0;
#line 2273
  j = 0U;
  {
#line 2273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2273
    if (! (j < 4U)) {
#line 2273
      goto while_break;
    }
#line 2275
    if (c->w[j] & dfa->syntax.newline.w[j]) {
#line 2276
      context |= 4;
    }
#line 2277
    if (c->w[j] & dfa->syntax.letters.w[j]) {
#line 2278
      context |= 2;
    }
#line 2279
    if (c->w[j] & ~ (dfa->syntax.letters.w[j] | dfa->syntax.newline.w[j])) {
#line 2280
      context |= 1;
    }
#line 2273
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2283
  return (context);
}
}
#line 2292 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static int __attribute__((__pure__))  state_separate_contexts___0(position_set const   *s ) 
{ 
  int separate_contexts ;
  size_t j ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 2295
  separate_contexts = 0;
#line 2297
  j = (size_t )0;
  {
#line 2297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2297
    if (! (j < (size_t )s->nelem)) {
#line 2297
      goto while_break;
    }
    {
#line 2299
    tmp = prev_newline_dependent___0((int )(s->elems + j)->constraint);
    }
#line 2299
    if (tmp) {
#line 2300
      separate_contexts |= 4;
    }
    {
#line 2301
    tmp___0 = prev_letter_dependent___0((int )(s->elems + j)->constraint);
    }
#line 2301
    if (tmp___0) {
#line 2302
      separate_contexts |= 2;
    }
#line 2297
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2305
  return ((int __attribute__((__pure__))  )separate_contexts);
}
}
#line 2361 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void dfaanalyze___0(struct dfa *d , _Bool searchflag ) 
{ 
  position *posalloc ;
  void *tmp ;
  position *firstpos ;
  position *lastpos ;
  struct __anonstruct_stkalloc_360611398___0 *stkalloc ;
  void *tmp___0 ;
  struct __anonstruct_stkalloc_360611398___0 *stk ;
  position_set merged ;
  void *tmp___1 ;
  size_t i ;
  size_t tmp___2 ;
  position_set tmp___3 ;
  position *pos ;
  size_t j ;
  position_set tmp___4 ;
  position *pos___0 ;
  size_t j___0 ;
  position *pos___1 ;
  size_t j___1 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  unsigned int tmp___8 ;
  size_t i___0 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___9 ;
  int tmp___10 ;
  state_num tmp___11 ;
  state_num tmp___12 ;

  {
  {
#line 2365
  tmp = xnmalloc(d->nleaves, 2UL * sizeof(*posalloc));
#line 2365
  posalloc = (position *)tmp;
#line 2367
  firstpos = posalloc + d->nleaves;
#line 2368
  lastpos = firstpos + d->nleaves;
#line 2371
  tmp___0 = xnmalloc(d->depth, sizeof(*stkalloc));
#line 2371
  stkalloc = (struct __anonstruct_stkalloc_360611398___0 *)tmp___0;
#line 2371
  stk = stkalloc;
#line 2393
  d->searchflag = searchflag;
#line 2394
  alloc_position_set___0(& merged, d->nleaves);
#line 2395
  tmp___1 = xcalloc(d->tindex, sizeof(*(d->follows)));
#line 2395
  d->follows = (position_set *)tmp___1;
#line 2397
  i = (size_t )0;
  }
  {
#line 2397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2397
    if (! (i < d->tindex)) {
#line 2397
      goto while_break;
    }
    {
#line 2401
    if (*(d->tokens + i) == 256L) {
#line 2401
      goto case_256;
    }
#line 2411
    if (*(d->tokens + i) == 266L) {
#line 2411
      goto case_266;
    }
#line 2411
    if (*(d->tokens + i) == 265L) {
#line 2411
      goto case_266;
    }
#line 2426
    if (*(d->tokens + i) == 264L) {
#line 2426
      goto case_264;
    }
#line 2432
    if (*(d->tokens + i) == 268L) {
#line 2432
      goto case_268;
    }
#line 2472
    if (*(d->tokens + i) == 269L) {
#line 2472
      goto case_269;
    }
#line 2484
    goto switch_default;
    case_256: /* CIL Label */ 
#line 2403
    stk->nullable = (_Bool)1;
#line 2406
    tmp___2 = (size_t )0;
#line 2406
    stk->nlastpos = tmp___2;
#line 2406
    stk->nfirstpos = tmp___2;
#line 2407
    stk ++;
#line 2408
    goto switch_break;
    case_266: /* CIL Label */ 
    case_265: /* CIL Label */ 
#line 2416
    tmp___3.nelem = (ptrdiff_t )(stk + -1)->nfirstpos;
#line 2417
    tmp___3.elems = firstpos;
#line 2418
    pos = lastpos;
#line 2419
    j = (size_t )0;
    {
#line 2419
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2419
      if (! (j < (stk + -1)->nlastpos)) {
#line 2419
        goto while_break___0;
      }
      {
#line 2421
      merge___0((position_set const   *)(& tmp___3), (position_set const   *)(d->follows + (pos + j)->index),
                & merged);
#line 2422
      copy___0((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2419
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_264: /* CIL Label */ 
#line 2428
    if (*(d->tokens + i) != 266L) {
#line 2429
      (stk + -1)->nullable = (_Bool)1;
    }
#line 2430
    goto switch_break;
    case_268: /* CIL Label */ 
#line 2437
    tmp___4.nelem = (ptrdiff_t )(stk + -1)->nfirstpos;
#line 2438
    tmp___4.elems = firstpos;
#line 2439
    pos___0 = lastpos + (stk + -1)->nlastpos;
#line 2440
    j___0 = (size_t )0;
    {
#line 2440
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2440
      if (! (j___0 < (stk + -2)->nlastpos)) {
#line 2440
        goto while_break___1;
      }
      {
#line 2442
      merge___0((position_set const   *)(& tmp___4), (position_set const   *)(d->follows + (pos___0 + j___0)->index),
                & merged);
#line 2443
      copy___0((position_set const   *)(& merged), d->follows + (pos___0 + j___0)->index);
#line 2440
      j___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2449
    if ((stk + -2)->nullable) {
#line 2450
      (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
    } else {
#line 2452
      firstpos += (stk + -1)->nfirstpos;
    }
#line 2456
    if ((stk + -1)->nullable) {
#line 2457
      (stk + -2)->nlastpos += (stk + -1)->nlastpos;
    } else {
#line 2460
      pos___1 = lastpos + (stk + -2)->nlastpos;
#line 2461
      j___1 = (stk + -1)->nlastpos;
      {
#line 2461
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2461
        tmp___5 = j___1;
#line 2461
        j___1 --;
#line 2461
        if (! (tmp___5 > 0UL)) {
#line 2461
          goto while_break___2;
        }
#line 2462
        *(pos___1 + j___1) = *(lastpos + j___1);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2463
      lastpos += (stk + -2)->nlastpos;
#line 2464
      (stk + -2)->nlastpos = (stk + -1)->nlastpos;
    }
#line 2468
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable & (int )(stk + -1)->nullable);
#line 2469
    stk --;
#line 2470
    goto switch_break;
    case_269: /* CIL Label */ 
#line 2474
    (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
#line 2477
    (stk + -2)->nlastpos += (stk + -1)->nlastpos;
#line 2480
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable | (int )(stk + -1)->nullable);
#line 2481
    stk --;
#line 2482
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2490
    stk->nullable = (_Bool )(*(d->tokens + i) == 257L);
#line 2493
    tmp___6 = (size_t )1;
#line 2493
    stk->nlastpos = tmp___6;
#line 2493
    stk->nfirstpos = tmp___6;
#line 2494
    stk ++;
#line 2496
    firstpos --;
#line 2496
    lastpos --;
#line 2497
    tmp___7 = i;
#line 2497
    lastpos->index = tmp___7;
#line 2497
    firstpos->index = tmp___7;
#line 2498
    tmp___8 = 511U;
#line 2498
    lastpos->constraint = tmp___8;
#line 2498
    firstpos->constraint = tmp___8;
#line 2500
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2397
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2545
  merged.nelem = (ptrdiff_t )0;
#line 2546
  i___0 = (size_t )0;
  {
#line 2546
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2546
    if (! (i___0 < (stk + -1)->nfirstpos)) {
#line 2546
      goto while_break___3;
    }
    {
#line 2547
    insert___0(*(firstpos + i___0), & merged);
#line 2546
    i___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2551
  epsclosure___0(& merged, (struct dfa  const  *)d);
#line 2554
  tmp___9 = state_separate_contexts___0((position_set const   *)(& merged));
#line 2554
  separate_contexts = (int )tmp___9;
  }
#line 2557
  if (separate_contexts & 4) {
    {
#line 2558
    state_index___0(d, (position_set const   *)(& merged), 4);
    }
  }
  {
#line 2559
  tmp___11 = state_index___0(d, (position_set const   *)(& merged), separate_contexts ^ 7);
#line 2559
  tmp___10 = (int )tmp___11;
#line 2559
  d->min_trcount = tmp___10;
#line 2559
  d->initstate_notbol = (state_num )tmp___10;
  }
#line 2561
  if (separate_contexts & 2) {
    {
#line 2562
    tmp___12 = state_index___0(d, (position_set const   *)(& merged), 2);
#line 2562
    d->min_trcount = (int )tmp___12;
    }
  }
  {
#line 2563
  (d->min_trcount) ++;
#line 2564
  d->trcount = 0;
#line 2566
  free((void *)posalloc);
#line 2567
  free((void *)stkalloc);
#line 2568
  free((void *)merged.elems);
  }
#line 2569
  return;
}
}
#line 2572 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void realloc_trans_if_necessary___0(struct dfa *d ) 
{ 
  state_num oldalloc ;
  state_num **realtrans ;
  state_num **tmp ;
  ptrdiff_t newalloc1 ;
  state_num tmp___0 ;
  void *tmp___1 ;
  state_num *tmp___2 ;
  ptrdiff_t newalloc ;
  state_num tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  state_num *tmp___8 ;

  {
#line 2575
  oldalloc = d->tralloc;
#line 2576
  if (oldalloc < d->sindex) {
#line 2578
    if (d->trans) {
#line 2578
      tmp = d->trans - 2;
    } else {
#line 2578
      tmp = (state_num **)((void *)0);
    }
#line 2578
    realtrans = tmp;
#line 2579
    if (realtrans) {
#line 2579
      tmp___0 = d->tralloc + 2L;
    } else {
#line 2579
      tmp___0 = (state_num )0;
    }
    {
#line 2579
    newalloc1 = tmp___0;
#line 2580
    tmp___1 = xpalloc___0((void *)realtrans, & newalloc1, d->sindex - oldalloc, (ptrdiff_t )-1,
                          (ptrdiff_t )sizeof(*realtrans));
#line 2580
    realtrans = (state_num **)tmp___1;
#line 2582
    tmp___2 = (state_num *)((void *)0);
#line 2582
    *(realtrans + 1) = tmp___2;
#line 2582
    *(realtrans + 0) = tmp___2;
#line 2583
    d->trans = realtrans + 2;
#line 2584
    tmp___3 = newalloc1 - 2L;
#line 2584
    d->tralloc = tmp___3;
#line 2584
    newalloc = tmp___3;
#line 2585
    tmp___4 = xnrealloc((void *)d->fails, (size_t )newalloc, sizeof(*(d->fails)));
#line 2585
    d->fails = (state_num **)tmp___4;
#line 2586
    tmp___5 = xnrealloc((void *)d->success, (size_t )newalloc, sizeof(*(d->success)));
#line 2586
    d->success = (char *)tmp___5;
#line 2587
    tmp___6 = xnrealloc((void *)d->newlines, (size_t )newalloc, sizeof(*(d->newlines)));
#line 2587
    d->newlines = (state_num *)tmp___6;
    }
#line 2588
    if (d->localeinfo.multibyte) {
#line 2590
      if (d->mb_trans) {
#line 2590
        realtrans = d->mb_trans - 2;
      } else {
#line 2590
        realtrans = (state_num **)((void *)0);
      }
      {
#line 2591
      tmp___7 = xnrealloc((void *)realtrans, (size_t )newalloc1, sizeof(*realtrans));
#line 2591
      realtrans = (state_num **)tmp___7;
      }
#line 2592
      if (oldalloc == 0L) {
#line 2593
        tmp___8 = (state_num *)((void *)0);
#line 2593
        *(realtrans + 1) = tmp___8;
#line 2593
        *(realtrans + 0) = tmp___8;
      }
#line 2594
      d->mb_trans = realtrans + 2;
    }
    {
#line 2596
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2596
      if (! (oldalloc < newalloc)) {
#line 2596
        goto while_break;
      }
#line 2598
      *(d->trans + oldalloc) = (state_num *)((void *)0);
#line 2599
      *(d->fails + oldalloc) = (state_num *)((void *)0);
#line 2600
      if (d->localeinfo.multibyte) {
#line 2601
        *(d->mb_trans + oldalloc) = (state_num *)((void *)0);
      }
#line 2596
      oldalloc ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2604
  return;
}
}
#line 2639 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static state_num build_state___0(state_num s , struct dfa *d , unsigned char uc ) 
{ 
  position_set follows ;
  position_set tmp ;
  state_num state ;
  state_num state_newline ;
  state_num state_letter ;
  state_num **ptrans ;
  state_num **tmp___1 ;
  _Bool tmp___2 ;
  state_num *trans ;
  state_num i ;
  state_num *tmp___3 ;
  void *tmp___4 ;
  int i___0 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  leaf_set group ;
  void *tmp___8 ;
  charclass label___0 ;
  size_t i___1 ;
  charclass matches ;
  position pos ;
  _Bool matched ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  size_t j ;
  _Bool tmp___11 ;
  size_t j___0 ;
  _Bool tmp___12 ;
  size_t j___1 ;
  _Bool tmp___13 ;
  size_t j___2 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  size_t k ;
  size_t tmp___17 ;
  size_t k___0 ;
  size_t j___3 ;
  size_t k___1 ;
  _Bool mergeit ;
  size_t j___4 ;
  int possible_contexts ;
  int tmp___18 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___19 ;
  size_t i___2 ;
  _Bool tmp___20 ;
  _Bool tmp___21 ;

  {
  {
#line 2653
  tmp___2 = accepting___0(s, (struct dfa  const  *)d);
  }
#line 2653
  if (tmp___2) {
#line 2653
    tmp___1 = d->fails;
  } else {
#line 2653
    tmp___1 = d->trans;
  }
#line 2653
  ptrans = tmp___1 + s;
#line 2654
  trans = *ptrans;
#line 2656
  if (! trans) {
#line 2662
    if (1024 <= d->trcount) {
#line 2664
      i = (state_num )d->min_trcount;
      {
#line 2664
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2664
        if (! (i < d->tralloc)) {
#line 2664
          goto while_break;
        }
        {
#line 2666
        free((void *)*(d->trans + i));
#line 2667
        free((void *)*(d->fails + i));
#line 2668
        tmp___3 = (state_num *)((void *)0);
#line 2668
        *(d->fails + i) = tmp___3;
#line 2668
        *(d->trans + i) = tmp___3;
#line 2664
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 2670
      d->trcount = 0;
    }
    {
#line 2673
    (d->trcount) ++;
#line 2674
    tmp___4 = xmalloc(256UL * sizeof(*trans));
#line 2674
    trans = (state_num *)tmp___4;
#line 2674
    *ptrans = trans;
#line 2678
    i___0 = 0;
    }
    {
#line 2678
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2678
      if (! (i___0 < 256)) {
#line 2678
        goto while_break___0;
      }
#line 2679
      *(trans + i___0) = (state_num )-2;
#line 2678
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2683
  *(d->success + s) = (char)0;
#line 2684
  tmp___5 = accepts_in_context___0((int )(d->states + s)->context, 4, s, (struct dfa  const  *)d);
  }
#line 2684
  if (tmp___5) {
#line 2685
    *(d->success + s) = (char )((int )*(d->success + s) | 4);
  }
  {
#line 2686
  tmp___6 = accepts_in_context___0((int )(d->states + s)->context, 2, s, (struct dfa  const  *)d);
  }
#line 2686
  if (tmp___6) {
#line 2687
    *(d->success + s) = (char )((int )*(d->success + s) | 2);
  }
  {
#line 2688
  tmp___7 = accepts_in_context___0((int )(d->states + s)->context, 1, s, (struct dfa  const  *)d);
  }
#line 2688
  if (tmp___7) {
#line 2689
    *(d->success + s) = (char )((int )*(d->success + s) | 1);
  }
  {
#line 2693
  tmp___8 = xnmalloc(d->nleaves, sizeof(*(group.elems)));
#line 2693
  group.elems = (size_t *)tmp___8;
#line 2694
  group.nelem = (size_t )0;
#line 2698
  fillset___0(& label___0);
#line 2700
  i___1 = (size_t )0;
  }
  {
#line 2700
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2700
    if (! (i___1 < (size_t )(d->states + s)->elems.nelem)) {
#line 2700
      goto while_break___1;
    }
#line 2703
    pos = *((d->states + s)->elems.elems + i___1);
#line 2704
    matched = (_Bool)0;
#line 2705
    if (*(d->tokens + pos.index) >= 0L) {
#line 2705
      if (*(d->tokens + pos.index) < 256L) {
        {
#line 2707
        zeroset___0(& matches);
#line 2708
        setbit___0((unsigned int )*(d->tokens + pos.index), & matches);
        }
#line 2709
        if (*(d->tokens + pos.index) == (token )uc) {
#line 2710
          matched = (_Bool)1;
        }
      } else {
#line 2705
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2712
    if (*(d->tokens + pos.index) >= 275L) {
      {
#line 2714
      matches = *(d->charclasses + (*(d->tokens + pos.index) - 275L));
#line 2715
      tmp___9 = tstbit___0((unsigned int )uc, (charclass const   *)(& matches));
      }
#line 2715
      if (tmp___9) {
#line 2716
        matched = (_Bool)1;
      }
    } else
#line 2718
    if (*(d->tokens + pos.index) == 272L) {
      {
#line 2720
      matches = *(d->charclasses + d->canychar);
#line 2721
      tmp___10 = tstbit___0((unsigned int )uc, (charclass const   *)(& matches));
      }
#line 2721
      if (tmp___10) {
#line 2722
        matched = (_Bool)1;
      }
      {
#line 2730
      tmp___11 = succeeds_in_context___0((int )pos.constraint, (int )(d->states + s)->context,
                                         1);
      }
#line 2730
      if (tmp___11) {
#line 2733
        if ((d->states + s)->mbps.nelem == 0L) {
          {
#line 2734
          alloc_position_set___0(& (d->states + s)->mbps, (size_t )(d->follows + pos.index)->nelem);
          }
        }
#line 2736
        j = (size_t )0;
        {
#line 2736
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2736
          if (! (j < (size_t )(d->follows + pos.index)->nelem)) {
#line 2736
            goto while_break___2;
          }
          {
#line 2737
          insert___0(*((d->follows + pos.index)->elems + j), & (d->states + s)->mbps);
#line 2736
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
#line 2741
      goto __Cont;
    }
#line 2745
    if (pos.constraint != 511U) {
      {
#line 2747
      tmp___12 = succeeds_in_context___0((int )pos.constraint, (int )(d->states + s)->context,
                                         4);
      }
#line 2747
      if (! tmp___12) {
#line 2749
        j___0 = (size_t )0;
        {
#line 2749
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2749
          if (! (j___0 < 4UL)) {
#line 2749
            goto while_break___3;
          }
#line 2750
          matches.w[j___0] &= ~ d->syntax.newline.w[j___0];
#line 2749
          j___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 2751
      tmp___13 = succeeds_in_context___0((int )pos.constraint, (int )(d->states + s)->context,
                                         2);
      }
#line 2751
      if (! tmp___13) {
#line 2753
        j___1 = (size_t )0;
        {
#line 2753
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2753
          if (! (j___1 < 4UL)) {
#line 2753
            goto while_break___4;
          }
#line 2754
          matches.w[j___1] &= ~ d->syntax.letters.w[j___1];
#line 2753
          j___1 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 2755
      tmp___14 = succeeds_in_context___0((int )pos.constraint, (int )(d->states + s)->context,
                                         1);
      }
#line 2755
      if (! tmp___14) {
#line 2757
        j___2 = (size_t )0;
        {
#line 2757
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2757
          if (! (j___2 < 4UL)) {
#line 2757
            goto while_break___5;
          }
#line 2758
          matches.w[j___2] &= d->syntax.letters.w[j___2] | d->syntax.newline.w[j___2];
#line 2757
          j___2 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      {
#line 2761
      tmp___15 = emptyset___0((charclass const   *)(& matches));
      }
#line 2761
      if (tmp___15) {
#line 2762
        goto __Cont;
      }
      {
#line 2767
      tmp___16 = tstbit___0((unsigned int )uc, (charclass const   *)(& matches));
      }
#line 2767
      if (! tmp___16) {
#line 2768
        matched = (_Bool)0;
      }
    }
#line 2781
    if (matched) {
#line 2783
      k = (size_t )0;
      {
#line 2783
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2783
        if (! (k < 4UL)) {
#line 2783
          goto while_break___6;
        }
#line 2784
        label___0.w[k] &= matches.w[k];
#line 2783
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2785
      tmp___17 = group.nelem;
#line 2785
      (group.nelem) ++;
#line 2785
      *(group.elems + tmp___17) = pos.index;
    } else {
#line 2789
      k___0 = (size_t )0;
      {
#line 2789
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2789
        if (! (k___0 < 4UL)) {
#line 2789
          goto while_break___7;
        }
#line 2790
        label___0.w[k___0] &= ~ matches.w[k___0];
#line 2789
        k___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 2700
    i___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2794
  alloc_position_set___0(& follows, d->nleaves);
#line 2795
  alloc_position_set___0(& tmp, d->nleaves);
  }
#line 2797
  if (group.nelem > 0UL) {
#line 2799
    follows.nelem = (ptrdiff_t )0;
#line 2803
    j___3 = (size_t )0;
    {
#line 2803
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2803
      if (! (j___3 < group.nelem)) {
#line 2803
        goto while_break___8;
      }
#line 2804
      k___1 = (size_t )0;
      {
#line 2804
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 2804
        if (! (k___1 < (size_t )(d->follows + *(group.elems + j___3))->nelem)) {
#line 2804
          goto while_break___9;
        }
        {
#line 2805
        insert___0(*((d->follows + *(group.elems + j___3))->elems + k___1), & follows);
#line 2804
        k___1 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 2803
      j___3 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 2809
    if (d->searchflag) {
#line 2828
      mergeit = (_Bool )(! d->localeinfo.multibyte);
#line 2829
      if (! mergeit) {
#line 2831
        mergeit = (_Bool)1;
#line 2832
        j___4 = (size_t )0;
        {
#line 2832
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 2832
          if (mergeit) {
#line 2832
            if (! (j___4 < (size_t )follows.nelem)) {
#line 2832
              goto while_break___10;
            }
          } else {
#line 2832
            goto while_break___10;
          }
#line 2833
          mergeit = (_Bool )((int )mergeit & (int )*(d->multibyte_prop + (follows.elems + j___4)->index));
#line 2832
          j___4 ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 2835
      if (mergeit) {
        {
#line 2837
        merge___0((position_set const   *)(& (d->states + 0)->elems), (position_set const   *)(& follows),
                  & tmp);
#line 2838
        copy___0((position_set const   *)(& tmp), & follows);
        }
      }
    }
    {
#line 2845
    tmp___18 = charclass_context___0((struct dfa  const  *)d, (charclass const   *)(& label___0));
#line 2845
    possible_contexts = tmp___18;
#line 2846
    tmp___19 = state_separate_contexts___0((position_set const   *)(& follows));
#line 2846
    separate_contexts = (int )tmp___19;
    }
#line 2849
    if (possible_contexts & ~ separate_contexts) {
      {
#line 2850
      state = state_index___0(d, (position_set const   *)(& follows), separate_contexts ^ 7);
      }
    } else {
#line 2852
      state = (state_num )-1;
    }
#line 2853
    if ((separate_contexts & possible_contexts) & 4) {
      {
#line 2854
      state_newline = state_index___0(d, (position_set const   *)(& follows), 4);
      }
    } else {
#line 2856
      state_newline = state;
    }
#line 2857
    if ((separate_contexts & possible_contexts) & 2) {
      {
#line 2858
      state_letter = state_index___0(d, (position_set const   *)(& follows), 2);
      }
    } else {
#line 2860
      state_letter = state;
    }
    {
#line 2863
    realloc_trans_if_necessary___0(d);
    }
  } else
#line 2869
  if (d->searchflag) {
#line 2871
    state_newline = (state_num )0;
#line 2872
    state_letter = (state_num )(d->min_trcount - 1);
#line 2873
    state = d->initstate_notbol;
  } else {
#line 2877
    state_newline = (state_num )-1;
#line 2878
    state_letter = (state_num )-1;
#line 2879
    state = (state_num )-1;
  }
#line 2883
  i___2 = (size_t )0;
  {
#line 2883
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 2883
    if (! (i___2 < 256UL)) {
#line 2883
      goto while_break___11;
    }
    {
#line 2884
    tmp___20 = tstbit___0((unsigned int )i___2, (charclass const   *)(& label___0));
    }
#line 2884
    if (tmp___20) {
      {
#line 2887
      if ((int )d->syntax.sbit[i___2] == 4) {
#line 2887
        goto case_4;
      }
#line 2890
      if ((int )d->syntax.sbit[i___2] == 2) {
#line 2890
        goto case_2;
      }
#line 2893
      goto switch_default;
      case_4: /* CIL Label */ 
#line 2888
      *(trans + i___2) = state_newline;
#line 2889
      goto switch_break;
      case_2: /* CIL Label */ 
#line 2891
      *(trans + i___2) = state_letter;
#line 2892
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2894
      *(trans + i___2) = state;
#line 2895
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 2883
    i___2 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 2909
  free((void *)group.elems);
#line 2910
  free((void *)follows.elems);
#line 2911
  free((void *)tmp.elems);
#line 2915
  tmp___21 = tstbit___0((unsigned int )d->syntax.eolbyte, (charclass const   *)(& label___0));
  }
#line 2915
  if (tmp___21) {
#line 2917
    *(d->newlines + s) = *(trans + d->syntax.eolbyte);
#line 2918
    *(trans + d->syntax.eolbyte) = (state_num )-1;
  }
#line 2921
  return (*(trans + uc));
}
}
#line 2930 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static state_num transit_state_singlebyte___0(struct dfa *d , state_num s , unsigned char const   **pp ) 
{ 
  state_num *t ;
  unsigned char const   *tmp___0 ;

  {
#line 2935
  if (*(d->trans + s)) {
#line 2936
    t = *(d->trans + s);
  } else
#line 2937
  if (*(d->fails + s)) {
#line 2938
    t = *(d->fails + s);
  } else {
    {
#line 2941
    build_state___0(s, d, (unsigned char )*(*pp));
    }
#line 2942
    if (*(d->trans + s)) {
#line 2943
      t = *(d->trans + s);
    } else {
#line 2946
      t = *(d->fails + s);
#line 2947
      if (! t) {
        {
#line 2947
        __assert_fail("t", "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c", 2947U,
                      "transit_state_singlebyte");
        }
      }
    }
  }
#line 2951
  if (*(t + *(*pp)) == -2L) {
    {
#line 2952
    build_state___0(s, d, (unsigned char )*(*pp));
    }
  }
#line 2954
  tmp___0 = *pp;
#line 2954
  (*pp) ++;
#line 2954
  return (*(t + *tmp___0));
}
}
#line 2960 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static state_num transit_state___0(struct dfa *d , state_num s , unsigned char const   **pp ,
                                   unsigned char const   *end ) 
{ 
  wint_t wc ;
  int mbclen ;
  size_t tmp ;
  state_num s1 ;
  int mbci ;
  state_num s3 ;
  state_num i ;
  state_num tmp___0 ;
  void *tmp___1 ;
  int i___0 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___2 ;
  state_num s2 ;
  state_num tmp___3 ;

  {
  {
#line 2966
  tmp = mbs_to_wchar___0(& wc, (char const   *)*pp, (size_t )(end - *pp), d);
#line 2966
  mbclen = (int )tmp;
#line 2969
  d->mb_follows.nelem = (ptrdiff_t )0;
#line 2973
  s1 = s;
#line 2975
  mbci = 0;
  }
  {
#line 2975
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2975
    if (mbci < mbclen) {
#line 2975
      if (! (mbci == 0)) {
#line 2975
        if (! ((state_num )d->min_trcount <= s)) {
#line 2975
          goto while_break;
        }
      }
    } else {
#line 2975
      goto while_break;
    }
    {
#line 2976
    s = transit_state_singlebyte___0(d, s, pp);
#line 2975
    mbci ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2977
  *pp += mbclen - mbci;
#line 2979
  if (wc == 4294967295U) {
#line 2982
    return (s);
  }
#line 2988
  if ((d->states + s1)->mb_trindex < 0L) {
#line 2990
    if (1024L <= d->mb_trcount) {
#line 2993
      s3 = (state_num )-1;
      {
#line 2993
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2993
        if (! (s3 < d->tralloc)) {
#line 2993
          goto while_break___0;
        }
        {
#line 2995
        free((void *)*(d->mb_trans + s3));
#line 2996
        *(d->mb_trans + s3) = (state_num *)((void *)0);
#line 2993
        s3 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2999
      i = (state_num )0;
      {
#line 2999
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2999
        if (! (i < d->sindex)) {
#line 2999
          goto while_break___1;
        }
#line 3000
        (d->states + i)->mb_trindex = (state_num )-1;
#line 2999
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3001
      d->mb_trcount = (state_num )0;
    }
#line 3003
    tmp___0 = d->mb_trcount;
#line 3003
    (d->mb_trcount) ++;
#line 3003
    (d->states + s1)->mb_trindex = tmp___0;
  }
#line 3006
  if (! *(d->mb_trans + s)) {
    {
#line 3010
    tmp___1 = xmalloc((size_t )8192);
#line 3010
    *(d->mb_trans + s) = (state_num *)tmp___1;
#line 3011
    i___0 = 0;
    }
    {
#line 3011
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3011
      if (! (i___0 < 1024)) {
#line 3011
        goto while_break___2;
      }
#line 3012
      *(*(d->mb_trans + s) + i___0) = (state_num )-1;
#line 3011
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 3014
  if (*(*(d->mb_trans + s) + (d->states + s1)->mb_trindex) >= 0L) {
#line 3015
    return (*(*(d->mb_trans + s) + (d->states + s1)->mb_trindex));
  }
#line 3017
  if (s == -1L) {
    {
#line 3018
    copy___0((position_set const   *)(& (d->states + s1)->mbps), & d->mb_follows);
    }
  } else {
    {
#line 3020
    merge___0((position_set const   *)(& (d->states + s1)->mbps), (position_set const   *)(& (d->states + s)->elems),
              & d->mb_follows);
    }
  }
  {
#line 3022
  tmp___2 = state_separate_contexts___0((position_set const   *)(& d->mb_follows));
#line 3022
  separate_contexts = (int )tmp___2;
#line 3023
  tmp___3 = state_index___0(d, (position_set const   *)(& d->mb_follows), separate_contexts ^ 7);
#line 3023
  s2 = tmp___3;
#line 3024
  realloc_trans_if_necessary___0(d);
#line 3026
  *(*(d->mb_trans + s) + (d->states + s1)->mb_trindex) = s2;
  }
#line 3028
  return (s2);
}
}
#line 3046 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static unsigned char const   *skip_remains_mb___0(struct dfa *d , unsigned char const   *p ,
                                                  unsigned char const   *mbp , char const   *end ) 
{ 
  wint_t wc ;
  size_t tmp ;

  {
#line 3050
  if (d->syntax.never_trail[*p]) {
#line 3051
    return (p);
  }
  {
#line 3052
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3052
    if (! ((unsigned long )mbp < (unsigned long )p)) {
#line 3052
      goto while_break;
    }
    {
#line 3055
    tmp = mbs_to_wchar___0(& wc, (char const   *)mbp, (size_t )(end - (char const   *)mbp),
                           d);
#line 3055
    mbp += tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3058
  return (mbp);
}
}
#line 3081 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
__inline static char *dfaexec_main___0(struct dfa *d , char const   *begin , char *end ,
                                       _Bool allow_nl , size_t *count , _Bool multibyte ) 
{ 
  state_num s ;
  state_num s___0 ;
  state_num *tmp ;
  state_num s___1 ;
  state_num s___2 ;
  state_num s___3 ;
  state_num s1 ;
  unsigned char const   *p ;
  unsigned char const   *mbp ;
  state_num **trans ;
  unsigned char eol ;
  unsigned char saved_end ;
  size_t nlcount ;
  state_num *t ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  state_num tmp___2 ;
  unsigned char const   *tmp___3 ;
  state_num tmp___4 ;
  state_num tmp___5 ;
  _Bool tmp___6 ;
  unsigned char const   *tmp___7 ;

  {
#line 3085
  if (1024L <= d->sindex) {
#line 3087
    s = (state_num )d->min_trcount;
    {
#line 3087
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3087
      if (! (s < d->sindex)) {
#line 3087
        goto while_break;
      }
      {
#line 3089
      free((void *)(d->states + s)->elems.elems);
#line 3090
      free((void *)(d->states + s)->mbps.elems);
#line 3087
      s ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3092
    d->sindex = (state_num )d->min_trcount;
#line 3094
    if (d->trans) {
#line 3096
      s___0 = (state_num )0;
      {
#line 3096
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3096
        if (! (s___0 < d->tralloc)) {
#line 3096
          goto while_break___0;
        }
        {
#line 3098
        free((void *)*(d->trans + s___0));
#line 3099
        free((void *)*(d->fails + s___0));
#line 3100
        tmp = (state_num *)((void *)0);
#line 3100
        *(d->fails + s___0) = tmp;
#line 3100
        *(d->trans + s___0) = tmp;
#line 3096
        s___0 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3102
      d->trcount = 0;
    }
#line 3105
    if (d->localeinfo.multibyte) {
#line 3105
      if (d->mb_trans) {
#line 3107
        s___1 = (state_num )-1;
        {
#line 3107
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3107
          if (! (s___1 < d->tralloc)) {
#line 3107
            goto while_break___1;
          }
          {
#line 3109
          free((void *)*(d->mb_trans + s___1));
#line 3110
          *(d->mb_trans + s___1) = (state_num *)((void *)0);
#line 3107
          s___1 ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3112
        s___2 = (state_num )0;
        {
#line 3112
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3112
          if (! (s___2 < (state_num )d->min_trcount)) {
#line 3112
            goto while_break___2;
          }
#line 3113
          (d->states + s___2)->mb_trindex = (state_num )-1;
#line 3112
          s___2 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3114
        d->mb_trcount = (state_num )0;
      }
    }
  }
#line 3118
  if (! d->tralloc) {
    {
#line 3119
    realloc_trans_if_necessary___0(d);
    }
  }
#line 3122
  s___3 = (state_num )0;
#line 3122
  s1 = (state_num )0;
#line 3125
  p = (unsigned char const   *)begin;
#line 3126
  mbp = p;
#line 3129
  trans = d->trans;
#line 3130
  eol = d->syntax.eolbyte;
#line 3131
  saved_end = *((unsigned char *)end);
#line 3132
  *end = (char )eol;
#line 3134
  if (multibyte) {
    {
#line 3136
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
#line 3137
    if (d->mb_follows.alloc == 0L) {
      {
#line 3138
      alloc_position_set___0(& d->mb_follows, d->nleaves);
      }
    }
  }
#line 3141
  nlcount = (size_t )0;
  {
#line 3142
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 3145
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3145
      t = *(trans + s___3);
#line 3145
      if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 3145
        goto while_break___4;
      }
#line 3147
      if (s___3 < (state_num )d->min_trcount) {
#line 3149
        if (! multibyte) {
#line 3149
          goto _L;
        } else
#line 3149
        if ((d->states + s___3)->mbps.nelem == 0L) {
          _L: /* CIL Label */ 
          {
#line 3151
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 3151
            if (! (*(t + *p) == s___3)) {
#line 3151
              goto while_break___5;
            }
#line 3152
            p ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 3154
        if (multibyte) {
          {
#line 3155
          mbp = skip_remains_mb___0(d, p, mbp, (char const   *)end);
#line 3155
          p = mbp;
          }
        }
      }
#line 3158
      if (multibyte) {
#line 3160
        s1 = s___3;
#line 3162
        if ((d->states + s___3)->mbps.nelem == 0L) {
#line 3167
          tmp___0 = p;
#line 3167
          p ++;
#line 3167
          s___3 = *(t + *tmp___0);
        } else
#line 3162
        if (d->localeinfo.sbctowc[*p] != 4294967295U) {
#line 3167
          tmp___0 = p;
#line 3167
          p ++;
#line 3167
          s___3 = *(t + *tmp___0);
        } else
#line 3162
        if ((unsigned long )((char *)p) >= (unsigned long )end) {
#line 3167
          tmp___0 = p;
#line 3167
          p ++;
#line 3167
          s___3 = *(t + *tmp___0);
        } else {
          {
#line 3171
          s___3 = transit_state___0(d, s___3, & p, (unsigned char const   *)((unsigned char *)end));
#line 3172
          mbp = p;
#line 3173
          trans = d->trans;
          }
        }
      } else {
#line 3178
        tmp___1 = p;
#line 3178
        p ++;
#line 3178
        s1 = *(t + *tmp___1);
#line 3179
        t = *(trans + s1);
#line 3180
        if (! t) {
#line 3182
          tmp___2 = s___3;
#line 3183
          s___3 = s1;
#line 3184
          s1 = tmp___2;
#line 3185
          goto while_break___4;
        }
#line 3187
        if (s___3 < (state_num )d->min_trcount) {
          {
#line 3189
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 3189
            if (! (*(t + *p) == s1)) {
#line 3189
              goto while_break___6;
            }
#line 3190
            p ++;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 3192
        tmp___3 = p;
#line 3192
        p ++;
#line 3192
        s___3 = *(t + *tmp___3);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3196
    if (s___3 < 0L) {
#line 3198
      if (s___3 == -2L) {
        {
#line 3200
        s___3 = build_state___0(s1, d, (unsigned char )*(p + -1));
#line 3201
        trans = d->trans;
        }
      } else
#line 3203
      if ((unsigned long )((char *)p) <= (unsigned long )end) {
#line 3203
        if ((int const   )*(p + -1) == (int const   )eol) {
#line 3203
          if (0L <= *(d->newlines + s1)) {
#line 3207
            nlcount ++;
#line 3208
            mbp = p;
#line 3210
            if (allow_nl) {
#line 3210
              s___3 = *(d->newlines + s1);
            } else {
#line 3210
              if ((int )d->syntax.sbit[eol] == 4) {
#line 3210
                tmp___5 = (state_num )0;
              } else {
#line 3210
                if ((int )d->syntax.sbit[eol] == 2) {
#line 3210
                  tmp___4 = (state_num )(d->min_trcount - 1);
                } else {
#line 3210
                  tmp___4 = d->initstate_notbol;
                }
#line 3210
                tmp___5 = tmp___4;
              }
#line 3210
              s___3 = tmp___5;
            }
          } else {
#line 3217
            p = (unsigned char const   *)((void *)0);
#line 3218
            goto done;
          }
        } else {
#line 3217
          p = (unsigned char const   *)((void *)0);
#line 3218
          goto done;
        }
      } else {
#line 3217
        p = (unsigned char const   *)((void *)0);
#line 3218
        goto done;
      }
    } else
#line 3221
    if (*(d->fails + s___3)) {
#line 3223
      if ((int )*(d->success + s___3) & (int )d->syntax.sbit[*p]) {
#line 3227
        goto done;
      } else
#line 3223
      if ((unsigned long )((char *)p) == (unsigned long )end) {
        {
#line 3223
        tmp___6 = accepts_in_context___0((int )(d->states + s___3)->context, 4, s___3,
                                         (struct dfa  const  *)d);
        }
#line 3223
        if (tmp___6) {
#line 3227
          goto done;
        }
      }
#line 3229
      if (multibyte) {
#line 3229
        if (s___3 < (state_num )d->min_trcount) {
          {
#line 3230
          mbp = skip_remains_mb___0(d, p, mbp, (char const   *)end);
#line 3230
          p = mbp;
          }
        }
      }
#line 3232
      s1 = s___3;
#line 3233
      if (! multibyte) {
#line 3238
        tmp___7 = p;
#line 3238
        p ++;
#line 3238
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3233
      if ((d->states + s___3)->mbps.nelem == 0L) {
#line 3238
        tmp___7 = p;
#line 3238
        p ++;
#line 3238
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3233
      if (d->localeinfo.sbctowc[*p] != 4294967295U) {
#line 3238
        tmp___7 = p;
#line 3238
        p ++;
#line 3238
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3233
      if ((unsigned long )((char *)p) >= (unsigned long )end) {
#line 3238
        tmp___7 = p;
#line 3238
        p ++;
#line 3238
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else {
        {
#line 3242
        s___3 = transit_state___0(d, s___3, & p, (unsigned char const   *)((unsigned char *)end));
#line 3243
        mbp = p;
#line 3244
        trans = d->trans;
        }
      }
    } else {
      {
#line 3249
      build_state___0(s___3, d, (unsigned char )*(p + 0));
#line 3250
      trans = d->trans;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  done: 
#line 3255
  if (count) {
#line 3256
    *count += nlcount;
  }
#line 3257
  *end = (char )saved_end;
#line 3258
  return ((char *)p);
}
}
#line 3264 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char *dfaexec_mb___0(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                            size_t *count , _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3268
  tmp = dfaexec_main___0(d, begin, end, allow_nl, count, (_Bool)1);
  }
#line 3268
  return (tmp);
}
}
#line 3271 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char *dfaexec_sb___0(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                            size_t *count , _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3275
  tmp = dfaexec_main___0(d, begin, end, allow_nl, count, (_Bool)0);
  }
#line 3275
  return (tmp);
}
}
#line 3280 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char *dfaexec_noop___0(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                              size_t *count , _Bool *backref ) 
{ 


  {
#line 3284
  *backref = (_Bool)1;
#line 3285
  return ((char *)begin);
}
}
#line 3311 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void free_mbdata___0(struct dfa *d ) 
{ 
  state_num s ;

  {
  {
#line 3314
  free((void *)d->multibyte_prop);
#line 3315
  free((void *)d->lex.brack.chars);
#line 3316
  free((void *)d->mb_follows.elems);
  }
#line 3318
  if (d->mb_trans) {
#line 3321
    s = (state_num )-1;
    {
#line 3321
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3321
      if (! (s < d->tralloc)) {
#line 3321
        goto while_break;
      }
      {
#line 3322
      free((void *)*(d->mb_trans + s));
#line 3321
      s ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3323
    free((void *)(d->mb_trans - 2));
    }
  }
#line 3325
  return;
}
}
#line 3328 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static _Bool __attribute__((__pure__))  dfa_supported___0(struct dfa  const  *d ) 
{ 
  size_t i ;

  {
#line 3331
  i = (size_t )0;
  {
#line 3331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3331
    if (! (i < (size_t )d->tindex)) {
#line 3331
      goto while_break;
    }
    {
#line 3338
    if (*(d->tokens + i) == 263L) {
#line 3338
      goto case_263;
    }
#line 3338
    if (*(d->tokens + i) == 262L) {
#line 3338
      goto case_263;
    }
#line 3338
    if (*(d->tokens + i) == 261L) {
#line 3338
      goto case_263;
    }
#line 3338
    if (*(d->tokens + i) == 260L) {
#line 3338
      goto case_263;
    }
#line 3343
    if (*(d->tokens + i) == 273L) {
#line 3343
      goto case_273;
    }
#line 3343
    if (*(d->tokens + i) == 257L) {
#line 3343
      goto case_273;
    }
#line 3333
    goto switch_break;
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 3339
    if (! d->localeinfo.multibyte) {
#line 3340
      goto __Cont;
    }
    case_273: /* CIL Label */ 
    case_257: /* CIL Label */ 
#line 3344
    return ((_Bool __attribute__((__pure__))  )0);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 3331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3347
  return ((_Bool __attribute__((__pure__))  )1);
}
}
#line 3350 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void dfaoptimize___0(struct dfa *d ) 
{ 
  _Bool have_backref ;
  size_t i ;

  {
#line 3353
  if (! d->localeinfo.using_utf8) {
#line 3354
    return;
  }
#line 3356
  have_backref = (_Bool)0;
#line 3357
  i = (size_t )0;
  {
#line 3357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3357
    if (! (i < d->tindex)) {
#line 3357
      goto while_break;
    }
    {
#line 3361
    if (*(d->tokens + i) == 272L) {
#line 3361
      goto case_272;
    }
#line 3364
    if (*(d->tokens + i) == 257L) {
#line 3364
      goto case_257;
    }
#line 3367
    if (*(d->tokens + i) == 273L) {
#line 3367
      goto case_273;
    }
#line 3370
    goto switch_default;
    case_272: /* CIL Label */ 
    {
#line 3363
    abort();
    }
    case_257: /* CIL Label */ 
#line 3365
    have_backref = (_Bool)1;
#line 3366
    goto switch_break;
    case_273: /* CIL Label */ 
#line 3369
    return;
    switch_default: /* CIL Label */ 
#line 3371
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3357
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3375
  if (! have_backref) {
#line 3375
    if (d->superset) {
      {
#line 3378
      dfafree(d->superset);
#line 3379
      free((void *)d->superset);
#line 3380
      d->superset = (struct dfa *)((void *)0);
      }
    }
  }
  {
#line 3383
  free_mbdata___0(d);
#line 3384
  d->localeinfo.multibyte = (_Bool)0;
#line 3385
  d->dfaexec = & dfaexec_sb___0;
#line 3386
  d->fast = (_Bool)1;
  }
#line 3387
  return;
}
}
#line 3389 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void dfassbuild___0(struct dfa *d ) 
{ 
  struct dfa *sup ;
  struct dfa *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  _Bool have_achar ;
  _Bool have_nchar ;
  size_t j ;
  size_t i ;
  charclass ccl ;
  size_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 3392
  tmp = dfaalloc();
#line 3392
  sup = tmp;
#line 3394
  *sup = *d;
#line 3395
  sup->localeinfo.multibyte = (_Bool)0;
#line 3396
  sup->dfaexec = & dfaexec_sb___0;
#line 3397
  sup->multibyte_prop = (char *)((void *)0);
#line 3398
  sup->superset = (struct dfa *)((void *)0);
#line 3399
  sup->states = (dfa_state *)((void *)0);
#line 3400
  sup->sindex = (state_num )0;
#line 3401
  sup->follows = (position_set *)((void *)0);
#line 3402
  sup->tralloc = (state_num )0;
#line 3403
  sup->trans = (state_num **)((void *)0);
#line 3404
  sup->fails = (state_num **)((void *)0);
#line 3405
  sup->success = (char *)((void *)0);
#line 3406
  sup->newlines = (state_num *)((void *)0);
#line 3408
  tmp___0 = xnmalloc((size_t )sup->calloc, sizeof(*(sup->charclasses)));
#line 3408
  sup->charclasses = (charclass *)tmp___0;
  }
#line 3409
  if (d->cindex) {
    {
#line 3411
    memcpy((void */* __restrict  */)sup->charclasses, (void const   */* __restrict  */)d->charclasses,
           (unsigned long )d->cindex * sizeof(*(sup->charclasses)));
    }
  }
  {
#line 3415
  tmp___1 = xnmalloc(d->tindex, 2UL * sizeof(*(sup->tokens)));
#line 3415
  sup->tokens = (token *)tmp___1;
#line 3416
  sup->talloc = d->tindex * 2UL;
#line 3418
  have_achar = (_Bool)0;
#line 3419
  have_nchar = (_Bool)0;
#line 3421
  j = (size_t )0;
#line 3421
  i = j;
  }
  {
#line 3421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3421
    if (! (i < d->tindex)) {
#line 3421
      goto while_break;
    }
    {
#line 3427
    if (*(d->tokens + i) == 257L) {
#line 3427
      goto case_257;
    }
#line 3427
    if (*(d->tokens + i) == 273L) {
#line 3427
      goto case_257;
    }
#line 3427
    if (*(d->tokens + i) == 272L) {
#line 3427
      goto case_257;
    }
#line 3442
    if (*(d->tokens + i) == 263L) {
#line 3442
      goto case_263;
    }
#line 3442
    if (*(d->tokens + i) == 262L) {
#line 3442
      goto case_263;
    }
#line 3442
    if (*(d->tokens + i) == 261L) {
#line 3442
      goto case_263;
    }
#line 3442
    if (*(d->tokens + i) == 260L) {
#line 3442
      goto case_263;
    }
#line 3451
    goto switch_default;
    case_257: /* CIL Label */ 
    case_273: /* CIL Label */ 
    case_272: /* CIL Label */ 
    {
#line 3430
    fillset___0(& ccl);
#line 3431
    tmp___2 = j;
#line 3431
    j ++;
#line 3431
    tmp___3 = charclass_index___0(sup, & ccl);
#line 3431
    *(sup->tokens + tmp___2) = 275L + tmp___3;
#line 3432
    tmp___4 = j;
#line 3432
    j ++;
#line 3432
    *(sup->tokens + tmp___4) = (token )265;
    }
#line 3433
    if (*(d->tokens + (i + 1UL)) == 264L) {
#line 3435
      i ++;
    } else
#line 3433
    if (*(d->tokens + (i + 1UL)) == 265L) {
#line 3435
      i ++;
    } else
#line 3433
    if (*(d->tokens + (i + 1UL)) == 266L) {
#line 3435
      i ++;
    }
#line 3436
    have_achar = (_Bool)1;
#line 3438
    goto switch_break;
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 3443
    if (d->localeinfo.multibyte) {
#line 3447
      tmp___5 = j;
#line 3447
      j ++;
#line 3447
      *(sup->tokens + tmp___5) = (token )256;
#line 3448
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 3452
    tmp___6 = j;
#line 3452
    j ++;
#line 3452
    *(sup->tokens + tmp___6) = *(d->tokens + i);
#line 3453
    if (0L <= *(d->tokens + i)) {
#line 3453
      if (*(d->tokens + i) < 256L) {
#line 3455
        have_nchar = (_Bool)1;
      } else {
#line 3453
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3453
    if (*(d->tokens + i) >= 275L) {
#line 3455
      have_nchar = (_Bool)1;
    }
#line 3456
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3421
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3459
  sup->tindex = j;
#line 3461
  if (have_nchar) {
#line 3461
    if (have_achar) {
#line 3462
      d->superset = sup;
    } else
#line 3461
    if (d->localeinfo.multibyte) {
#line 3462
      d->superset = sup;
    } else {
      {
#line 3465
      dfafree(sup);
#line 3466
      free((void *)sup);
      }
    }
  } else {
    {
#line 3465
    dfafree(sup);
#line 3466
    free((void *)sup);
    }
  }
#line 3468
  return;
}
}
#line 3618 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char *icatalloc___0(char *old , char const   *new ) 
{ 
  size_t newsize ;
  size_t tmp ;
  size_t oldsize ;
  size_t tmp___0 ;
  char *result ;
  void *tmp___1 ;

  {
  {
#line 3621
  tmp = strlen(new);
#line 3621
  newsize = tmp;
  }
#line 3622
  if (newsize == 0UL) {
#line 3623
    return (old);
  }
  {
#line 3624
  tmp___0 = strlen((char const   *)old);
#line 3624
  oldsize = tmp___0;
#line 3625
  tmp___1 = xrealloc((void *)old, (oldsize + newsize) + 1UL);
#line 3625
  result = (char *)tmp___1;
#line 3626
  memcpy((void */* __restrict  */)(result + oldsize), (void const   */* __restrict  */)new,
         newsize + 1UL);
  }
#line 3627
  return (result);
}
}
#line 3630 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void freelist___0(char **cpp ) 
{ 
  char **tmp ;

  {
  {
#line 3633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3633
    if (! *cpp) {
#line 3633
      goto while_break;
    }
    {
#line 3634
    tmp = cpp;
#line 3634
    cpp ++;
#line 3634
    free((void *)*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3635
  return;
}
}
#line 3637 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char **enlist___0(char **cpp , char *new , size_t len ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  size_t i ;
  char *tmp___1 ;
  size_t j ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3640
  tmp = xmalloc(len + 1UL);
#line 3640
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)new,
                   len);
#line 3640
  new = (char *)tmp___0;
#line 3641
  *(new + len) = (char )'\000';
#line 3644
  i = (size_t )0;
  }
  {
#line 3644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3644
    if (! ((unsigned long )*(cpp + i) != (unsigned long )((void *)0))) {
#line 3644
      goto while_break;
    }
    {
#line 3645
    tmp___1 = strstr((char const   *)*(cpp + i), (char const   *)new);
    }
#line 3645
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 3647
      free((void *)new);
      }
#line 3648
      return (cpp);
    }
#line 3644
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3651
  j = (size_t )0;
  {
#line 3651
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3651
    if (! ((unsigned long )*(cpp + j) != (unsigned long )((void *)0))) {
#line 3651
      goto while_break___0;
    }
    {
#line 3652
    tmp___2 = strstr((char const   *)new, (char const   *)*(cpp + j));
    }
#line 3652
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 3653
      j ++;
    } else {
      {
#line 3656
      free((void *)*(cpp + j));
#line 3657
      i --;
      }
#line 3657
      if (i == j) {
#line 3658
        goto while_break___0;
      }
#line 3659
      *(cpp + j) = *(cpp + i);
#line 3660
      *(cpp + i) = (char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3663
  tmp___3 = xnrealloc((void *)cpp, i + 2UL, sizeof(*cpp));
#line 3663
  cpp = (char **)tmp___3;
#line 3664
  *(cpp + i) = new;
#line 3665
  *(cpp + (i + 1UL)) = (char *)((void *)0);
  }
#line 3666
  return (cpp);
}
}
#line 3671 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char **comsubs___0(char *left , char const   *right ) 
{ 
  char **cpp ;
  void *tmp ;
  char *lcp ;
  size_t len ;
  char *rcp ;
  char *tmp___0 ;
  size_t i ;

  {
  {
#line 3674
  tmp = xzalloc(sizeof(*cpp));
#line 3674
  cpp = (char **)tmp;
#line 3676
  lcp = left;
  }
  {
#line 3676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3676
    if (! ((int )*lcp != 0)) {
#line 3676
      goto while_break;
    }
    {
#line 3678
    len = (size_t )0;
#line 3679
    tmp___0 = strchr(right, (int )*lcp);
#line 3679
    rcp = tmp___0;
    }
    {
#line 3680
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3680
      if (! ((unsigned long )rcp != (unsigned long )((void *)0))) {
#line 3680
        goto while_break___0;
      }
#line 3683
      i = (size_t )1;
      {
#line 3683
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3683
        if ((int )*(lcp + i) != 0) {
#line 3683
          if (! ((int )*(lcp + i) == (int )*(rcp + i))) {
#line 3683
            goto while_break___1;
          }
        } else {
#line 3683
          goto while_break___1;
        }
#line 3684
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 3683
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3685
      if (i > len) {
#line 3686
        len = i;
      }
      {
#line 3687
      rcp = strchr((char const   *)(rcp + 1), (int )*lcp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3689
    if (len != 0UL) {
      {
#line 3690
      cpp = enlist___0(cpp, lcp, len);
      }
    }
#line 3676
    lcp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3692
  return (cpp);
}
}
#line 3695 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char **addlists___0(char **old , char **new ) 
{ 
  size_t tmp ;

  {
  {
#line 3698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3698
    if (! *new) {
#line 3698
      goto while_break;
    }
    {
#line 3699
    tmp = strlen((char const   *)*new);
#line 3699
    old = enlist___0(old, *new, tmp);
#line 3698
    new ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3700
  return (old);
}
}
#line 3705 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static char **inboth___0(char **left , char **right ) 
{ 
  char **both ;
  void *tmp ;
  size_t lnum ;
  size_t rnum ;
  char **temp ;
  char **tmp___0 ;

  {
  {
#line 3708
  tmp = xzalloc(sizeof(*both));
#line 3708
  both = (char **)tmp;
#line 3710
  lnum = (size_t )0;
  }
  {
#line 3710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3710
    if (! ((unsigned long )*(left + lnum) != (unsigned long )((void *)0))) {
#line 3710
      goto while_break;
    }
#line 3712
    rnum = (size_t )0;
    {
#line 3712
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3712
      if (! ((unsigned long )*(right + rnum) != (unsigned long )((void *)0))) {
#line 3712
        goto while_break___0;
      }
      {
#line 3714
      tmp___0 = comsubs___0(*(left + lnum), (char const   *)*(right + rnum));
#line 3714
      temp = tmp___0;
#line 3715
      both = addlists___0(both, temp);
#line 3716
      freelist___0(temp);
#line 3717
      free((void *)temp);
#line 3712
      rnum ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3710
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3720
  return (both);
}
}
#line 3736 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static must *allocmust___0(must *mp , size_t size ) 
{ 
  must *new_mp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3739
  tmp = xmalloc(sizeof(*new_mp));
#line 3739
  new_mp = (must *)tmp;
#line 3740
  tmp___0 = xzalloc(sizeof(*(new_mp->in)));
#line 3740
  new_mp->in = (char **)tmp___0;
#line 3741
  tmp___1 = xzalloc(size);
#line 3741
  new_mp->left = (char *)tmp___1;
#line 3742
  tmp___2 = xzalloc(size);
#line 3742
  new_mp->right = (char *)tmp___2;
#line 3743
  tmp___3 = xzalloc(size);
#line 3743
  new_mp->is = (char *)tmp___3;
#line 3744
  new_mp->begline = (_Bool)0;
#line 3745
  new_mp->endline = (_Bool)0;
#line 3746
  new_mp->prev = mp;
  }
#line 3747
  return (new_mp);
}
}
#line 3750 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void resetmust___0(must *mp ) 
{ 
  char tmp ;
  char tmp___0 ;

  {
  {
#line 3753
  freelist___0(mp->in);
#line 3754
  *(mp->in + 0) = (char *)((void *)0);
#line 3755
  tmp___0 = (char )'\000';
#line 3755
  *(mp->is + 0) = tmp___0;
#line 3755
  tmp = tmp___0;
#line 3755
  *(mp->right + 0) = tmp;
#line 3755
  *(mp->left + 0) = tmp;
#line 3756
  mp->begline = (_Bool)0;
#line 3757
  mp->endline = (_Bool)0;
  }
#line 3758
  return;
}
}
#line 3760 "/home/khheo/project/benchmark/grep-3.1/lib/dfa.c"
static void freemust___0(must *mp ) 
{ 


  {
  {
#line 3763
  freelist___0(mp->in);
#line 3764
  free((void *)mp->in);
#line 3765
  free((void *)mp->left);
#line 3766
  free((void *)mp->right);
#line 3767
  free((void *)mp->is);
#line 3768
  free((void *)mp);
  }
#line 3769
  return;
}
}
#line 36 "/home/khheo/project/benchmark/grep-3.1/lib/cycle-check.c"
static _Bool is_zero_or_power_of_two___0(uintmax_t i ) 
{ 


  {
#line 39
  return ((_Bool )((i & (i - 1UL)) == 0UL));
}
}
#line 22 "./colorize-posix.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 599
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 46 "/home/khheo/project/benchmark/grep-3.1/lib/closeout.c"
static char const   *file_name___0  ;
#line 56 "/home/khheo/project/benchmark/grep-3.1/lib/closeout.c"
static _Bool ignore_EPIPE___0  ;
#line 599 "./unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 599
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 46 "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c"
static void cdb_init___0(struct cd_buf *cdb ) 
{ 


  {
#line 49
  cdb->fd = -100;
#line 50
  return;
}
}
#line 52 "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c"
static int cdb_fchdir___0(struct cd_buf  const  *cdb ) 
{ 
  int tmp ;

  {
  {
#line 55
  tmp = fchdir((int )cdb->fd);
  }
#line 55
  return (tmp);
}
}
#line 58 "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c"
static void cdb_free___0(struct cd_buf  const  *cdb ) 
{ 
  _Bool close_fail ;
  int tmp ;

  {
#line 61
  if (0 <= (int )cdb->fd) {
    {
#line 63
    tmp = close((int )cdb->fd);
#line 63
    close_fail = (_Bool )tmp;
    }
#line 64
    if (! (! close_fail)) {
      {
#line 64
      __assert_fail("! close_fail", "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c",
                    64U, "cdb_free");
      }
    }
  }
#line 66
  return;
}
}
#line 72 "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c"
static int cdb_advance_fd___0(struct cd_buf *cdb , char const   *dir ) 
{ 
  int new_fd ;
  int tmp ;

  {
  {
#line 75
  tmp = openat(cdb->fd, dir, 67840);
#line 75
  new_fd = tmp;
  }
#line 77
  if (new_fd < 0) {
#line 78
    return (-1);
  }
  {
#line 80
  cdb_free___0((struct cd_buf  const  *)cdb);
#line 81
  cdb->fd = new_fd;
  }
#line 83
  return (0);
}
}
#line 87 "/home/khheo/project/benchmark/grep-3.1/lib/chdir-long.c"
static char * __attribute__((__pure__)) find_non_slash___0(char const   *s ) 
{ 
  size_t n_slash ;
  size_t tmp ;

  {
  {
#line 90
  tmp = strspn(s, "/");
#line 90
  n_slash = tmp;
  }
#line 91
  return ((char */* __attribute__((__pure__)) */)((char *)s + n_slash));
}
}
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 31
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 31
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.1/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 134
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-3.1/lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 81
#pragma GCC diagnostic pop
#line 61 "/home/khheo/project/benchmark/grep-3.1/lib/argmatch.c"
static void __argmatch_die___0(void) 
{ 


  {
  {
#line 64
  usage(1);
  }
#line 65
  return;
}
}
#line 82 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 599 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 53 "/home/khheo/project/benchmark/grep-3.1/src/system.h"
#pragma GCC diagnostic push
#line 53
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 53
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 63 "/home/khheo/project/benchmark/grep-3.1/src/system.h"
__inline unsigned char to_uchar(char ch ) 
{ 


  {
#line 66
  return ((unsigned char )ch);
}
}
#line 69
#pragma GCC diagnostic pop
#line 27 "/home/khheo/project/benchmark/grep-3.1/src/grep.h"
_Bool match_icase ;
#line 37 "/home/khheo/project/benchmark/grep-3.1/src/kwset.h"
kwset_t kwsalloc(char const   *trans ) ;
#line 29 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 37 "/home/khheo/project/benchmark/grep-3.1/src/search.h"
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 37
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 49
void wordinit(void) ;
#line 50
kwset_t kwsinit(_Bool mb_trans ) ;
#line 51
size_t wordchars_size(char const   *buf , char const   *end )  __attribute__((__pure__)) ;
#line 52
size_t wordchar_next(char const   *buf , char const   *end )  __attribute__((__pure__)) ;
#line 53
size_t wordchar_prev(char const   *buf , char const   *cur , char const   *end )  __attribute__((__pure__)) ;
#line 55
ptrdiff_t mb_goback(char const   **mb_start , char const   *cur , char const   *end ) ;
#line 70
struct localeinfo localeinfo ;
#line 77 "/home/khheo/project/benchmark/grep-3.1/src/search.h"
__inline size_t mb_clen(char const   *s , size_t n , mbstate_t *mbs ) 
{ 
  size_t len ;
  unsigned char tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 80
  tmp = to_uchar((char )*s);
#line 80
  len = (size_t )localeinfo.sbclen[tmp];
  }
#line 81
  if (len == 0xfffffffffffffffeUL) {
    {
#line 81
    tmp___0 = rpl_mbrlen(s, n, mbs);
#line 81
    tmp___1 = tmp___0;
    }
  } else {
#line 81
    tmp___1 = len;
  }
#line 81
  return (tmp___1);
}
}
#line 84
#pragma GCC diagnostic pop
#line 27 "/home/khheo/project/benchmark/grep-3.1/src/searchutils.c"
static _Bool sbwordchar[256]  ;
#line 30 "/home/khheo/project/benchmark/grep-3.1/src/searchutils.c"
static _Bool wordchar(wint_t wc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 33
  if (wc == 95U) {
#line 33
    tmp___0 = 1;
  } else {
    {
#line 33
    tmp = iswalnum(wc);
    }
#line 33
    if (tmp) {
#line 33
      tmp___0 = 1;
    } else {
#line 33
      tmp___0 = 0;
    }
  }
#line 33
  return ((_Bool )tmp___0);
}
}
#line 36 "/home/khheo/project/benchmark/grep-3.1/src/searchutils.c"
void wordinit(void) 
{ 
  int i ;

  {
#line 39
  i = 0;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! (i < 256)) {
#line 39
      goto while_break;
    }
    {
#line 40
    sbwordchar[i] = wordchar(localeinfo.sbctowc[i]);
#line 39
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 43 "/home/khheo/project/benchmark/grep-3.1/src/searchutils.c"
kwset_t kwsinit(_Bool mb_trans ) 
{ 
  char *trans ;
  void *tmp ;
  int i ;
  int tmp___0 ;
  int i___0 ;
  wint_t wc ;
  wint_t uwc ;
  wint_t tmp___1 ;
  mbstate_t mbs ;
  size_t len ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  kwset_t tmp___5 ;

  {
#line 46
  trans = (char *)((void *)0);
#line 48
  if (match_icase) {
    {
#line 48
    tmp___4 = __ctype_get_mb_cur_max();
    }
#line 48
    if (tmp___4 == 1UL) {
#line 48
      goto _L;
    } else
#line 48
    if (mb_trans) {
      _L: /* CIL Label */ 
      {
#line 50
      tmp = xmalloc((size_t )256);
#line 50
      trans = (char *)tmp;
#line 51
      tmp___3 = __ctype_get_mb_cur_max();
      }
#line 51
      if (tmp___3 == 1UL) {
#line 52
        i = 0;
        {
#line 52
        while (1) {
          while_continue: /* CIL Label */ ;
#line 52
          if (! (i < 256)) {
#line 52
            goto while_break;
          }
          {
#line 53
          tmp___0 = toupper(i);
#line 53
          *(trans + i) = (char )tmp___0;
#line 52
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 55
        i___0 = 0;
        {
#line 55
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 55
          if (! (i___0 < 256)) {
#line 55
            goto while_break___0;
          }
          {
#line 57
          wc = localeinfo.sbctowc[i___0];
#line 58
          tmp___1 = towupper(wc);
#line 58
          uwc = tmp___1;
          }
#line 59
          if (uwc != wc) {
            {
#line 61
            mbs.__count = 0;
#line 61
            mbs.__value.__wch = 0U;
#line 62
            tmp___2 = wcrtomb((char */* __restrict  */)(trans + i___0), (wchar_t )uwc,
                              (mbstate_t */* __restrict  */)(& mbs));
#line 62
            len = tmp___2;
            }
#line 63
            if (len != 1UL) {
              {
#line 64
              abort();
              }
            }
          } else {
#line 67
            *(trans + i___0) = (char )i___0;
          }
#line 55
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 71
  tmp___5 = kwsalloc((char const   *)trans);
  }
#line 71
  return (tmp___5);
}
}
#line 85 "/home/khheo/project/benchmark/grep-3.1/src/searchutils.c"
ptrdiff_t mb_goback(char const   **mb_start , char const   *cur , char const   *end ) 
{ 
  char const   *p ;
  char const   *p0 ;
  int i ;
  mbstate_t mbs ;
  size_t clen ;
  size_t tmp ;
  mbstate_t mbs___0 ;
  size_t clen___0 ;
  size_t tmp___0 ;
  long tmp___1 ;

  {
#line 88
  p = *mb_start;
#line 89
  p0 = p;
#line 91
  if ((unsigned long )cur <= (unsigned long )p) {
#line 92
    return (cur - p);
  }
#line 94
  if (localeinfo.using_utf8) {
#line 96
    p = cur;
#line 98
    if ((unsigned long )cur < (unsigned long )end) {
#line 98
      if (((int const   )*cur & 192) == 128) {
#line 99
        i = 1;
        {
#line 99
        while (1) {
          while_continue: /* CIL Label */ ;
#line 99
          if (! (i <= 3)) {
#line 99
            goto while_break;
          }
#line 100
          if (((int const   )*(cur + - i) & 192) != 128) {
            {
#line 102
            mbs.__count = 0;
#line 102
            mbs.__value.__wch = 0U;
#line 103
            tmp = mb_clen(cur - i, (size_t )(end - (cur - i)), & mbs);
#line 103
            clen = tmp;
            }
#line 104
            if ((size_t )i < clen) {
#line 104
              if (clen < 0xfffffffffffffffeUL) {
#line 106
                p0 = cur - i;
#line 107
                p = p0 + clen;
              }
            }
#line 109
            goto while_break;
          }
#line 99
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  } else {
#line 114
    mbs___0.__count = 0;
#line 114
    mbs___0.__value.__wch = 0U;
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 117
      tmp___0 = mb_clen(p, (size_t )(end - p), & mbs___0);
#line 117
      clen___0 = tmp___0;
      }
#line 119
      if (0xfffffffffffffffeUL <= clen___0) {
        {
#line 123
        clen___0 = (size_t )1;
#line 124
        memset((void *)(& mbs___0), 0, sizeof(mbs___0));
        }
      }
#line 126
      p0 = p;
#line 127
      p += clen___0;
#line 115
      if (! ((unsigned long )p < (unsigned long )cur)) {
#line 115
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 132
  *mb_start = p;
#line 133
  if ((unsigned long )p == (unsigned long )cur) {
#line 133
    tmp___1 = 0L;
  } else {
#line 133
    tmp___1 = cur - p0;
  }
#line 133
  return (tmp___1);
}
}
#line 139 "/home/khheo/project/benchmark/grep-3.1/src/searchutils.c"
static size_t wordchars_count(char const   *buf , char const   *end , _Bool countall ) 
{ 
  size_t n ;
  mbstate_t mbs ;
  unsigned char b ;
  wchar_t wc ;
  size_t wcbytes ;
  size_t tmp ;
  _Bool tmp___0 ;

  {
#line 142
  n = (size_t )0;
#line 143
  mbs.__count = 0;
#line 143
  mbs.__value.__wch = 0U;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (n < (size_t )(end - buf))) {
#line 144
      goto while_break;
    }
#line 146
    b = (unsigned char )*(buf + n);
#line 147
    if (sbwordchar[b]) {
#line 148
      n ++;
    } else
#line 149
    if ((int )localeinfo.sbclen[b] != -2) {
#line 150
      goto while_break;
    } else {
      {
#line 153
      wc = 0;
#line 154
      tmp = rpl_mbrtowc(& wc, buf + n, (size_t )(end - buf) - n, & mbs);
#line 154
      wcbytes = tmp;
#line 155
      tmp___0 = wordchar((wint_t )wc);
      }
#line 155
      if (! tmp___0) {
#line 156
        goto while_break;
      }
#line 157
      n += wcbytes + (size_t )(! wcbytes);
    }
#line 159
    if (! countall) {
#line 160
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (n);
}
}
#line 168
size_t wordchars_size(char const   *buf , char const   *end )  __attribute__((__pure__)) ;
#line 168 "/home/khheo/project/benchmark/grep-3.1/src/searchutils.c"
size_t wordchars_size(char const   *buf , char const   *end ) 
{ 
  size_t tmp ;

  {
  {
#line 171
  tmp = wordchars_count(buf, end, (_Bool)1);
  }
#line 171
  return (tmp);
}
}
#line 176
size_t wordchar_next(char const   *buf , char const   *end )  __attribute__((__pure__)) ;
#line 176 "/home/khheo/project/benchmark/grep-3.1/src/searchutils.c"
size_t wordchar_next(char const   *buf , char const   *end ) 
{ 
  size_t tmp ;

  {
  {
#line 179
  tmp = wordchars_count(buf, end, (_Bool)0);
  }
#line 179
  return (tmp);
}
}
#line 185
size_t wordchar_prev(char const   *buf , char const   *cur , char const   *end )  __attribute__((__pure__)) ;
#line 185 "/home/khheo/project/benchmark/grep-3.1/src/searchutils.c"
size_t wordchar_prev(char const   *buf , char const   *cur , char const   *end ) 
{ 
  unsigned char b ;
  char const   *p ;
  ptrdiff_t tmp ;
  size_t tmp___0 ;

  {
#line 188
  if ((unsigned long )buf == (unsigned long )cur) {
#line 189
    return ((size_t )0);
  }
#line 190
  cur --;
#line 190
  b = (unsigned char )*cur;
#line 191
  if (! localeinfo.multibyte) {
#line 193
    return ((size_t )sbwordchar[b]);
  } else
#line 191
  if (localeinfo.using_utf8) {
#line 191
    if ((int )localeinfo.sbclen[b] != -2) {
#line 193
      return ((size_t )sbwordchar[b]);
    }
  }
  {
#line 194
  p = buf;
#line 195
  tmp = mb_goback(& p, cur, end);
#line 195
  cur -= tmp;
#line 196
  tmp___0 = wordchar_next(cur, end);
  }
#line 196
  return (tmp___0);
}
}
#line 82 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 599 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 53 "/home/khheo/project/benchmark/grep-3.1/src/system.h"
#pragma GCC diagnostic push
#line 53
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 53
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 69
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-3.1/src/grep.h"
_Bool match_words ;
#line 29
_Bool match_lines ;
#line 30
char eolbyte ;
#line 29 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 37 "/home/khheo/project/benchmark/grep-3.1/src/search.h"
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 37
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 66
void *Pcompile(char *pattern , size_t size , reg_syntax_t ignored ) ;
#line 67
size_t Pexecute(void *vcp , char const   *buf , size_t size , size_t *match_size ,
                char const   *start_ptr ) ;
#line 84
#pragma GCC diagnostic pop
#line 540 "/usr/include/pcre.h"
extern pcre *pcre_compile(char const   * , int  , char const   ** , int * , unsigned char const   * ) ;
#line 573
extern int pcre_exec(pcre const   * , pcre_extra const   * , char const   * , int  ,
                     int  , int  , int * , int  ) ;
#line 594
extern int pcre_fullinfo(pcre const   * , pcre_extra const   * , int  , void * ) ;
#line 627
extern unsigned char const   *pcre_maketables(void) ;
#line 633
extern pcre_extra *pcre_study(pcre const   * , int  , char const   ** ) ;
#line 657
extern pcre_jit_stack *pcre_jit_stack_alloc(int  , int  ) ;
#line 660
extern void pcre_jit_stack_free(pcre_jit_stack * ) ;
#line 663
extern void pcre_assign_jit_stack(pcre_extra * , pcre_jit_stack *(*)(void * ) , void * ) ;
#line 60 "/home/khheo/project/benchmark/grep-3.1/src/pcresearch.c"
static int jit_exec(struct pcre_comp *pc , char const   *subject , int search_bytes ,
                    int search_offset , int options , int *sub ) 
{ 
  int e ;
  int tmp ;
  int old_size ;
  int new_size ;
  int tmp___0 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    tmp = pcre_exec((pcre const   *)pc->cre, (pcre_extra const   *)pc->extra, subject,
                    search_bytes, search_offset, options, sub, 300);
#line 66
    e = tmp;
    }
#line 70
    if (e == -27) {
#line 70
      if (0 < pc->jit_stack_size) {
#line 70
        if (pc->jit_stack_size <= 1073741823) {
#line 73
          old_size = pc->jit_stack_size;
#line 74
          tmp___0 = old_size * 2;
#line 74
          pc->jit_stack_size = tmp___0;
#line 74
          new_size = tmp___0;
#line 75
          if (pc->jit_stack) {
            {
#line 76
            pcre_jit_stack_free(pc->jit_stack);
            }
          }
          {
#line 77
          pc->jit_stack = pcre_jit_stack_alloc(old_size, new_size);
          }
#line 78
          if (! pc->jit_stack) {
            {
#line 79
            exit(1);
            }
          }
          {
#line 81
          pcre_assign_jit_stack(pc->extra, (pcre_jit_stack *(*)(void * ))((void *)0),
                                (void *)pc->jit_stack);
          }
#line 82
          goto while_continue;
        }
      }
    }
#line 86
    return (e);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 102 "/home/khheo/project/benchmark/grep-3.1/src/pcresearch.c"
static char const   wprefix[11]  = 
#line 102
  {      (char const   )'(',      (char const   )'?',      (char const   )'<',      (char const   )'!', 
        (char const   )'\\',      (char const   )'w',      (char const   )')',      (char const   )'(', 
        (char const   )'?',      (char const   )':',      (char const   )'\000'};
#line 103 "/home/khheo/project/benchmark/grep-3.1/src/pcresearch.c"
static char const   wsuffix[8]  = 
#line 103
  {      (char const   )')',      (char const   )'(',      (char const   )'?',      (char const   )'!', 
        (char const   )'\\',      (char const   )'w',      (char const   )')',      (char const   )'\000'};
#line 104 "/home/khheo/project/benchmark/grep-3.1/src/pcresearch.c"
static char const   xprefix[5]  = {      (char const   )'^',      (char const   )'(',      (char const   )'?',      (char const   )':', 
        (char const   )'\000'};
#line 105 "/home/khheo/project/benchmark/grep-3.1/src/pcresearch.c"
static char const   xsuffix[3]  = {      (char const   )')',      (char const   )'$',      (char const   )'\000'};
#line 92 "/home/khheo/project/benchmark/grep-3.1/src/pcresearch.c"
void *Pcompile(char *pattern , size_t size , reg_syntax_t ignored ) 
{ 
  int e ;
  char const   *ep ;
  int fix_len_max ;
  unsigned long tmp ;
  char *re ;
  void *tmp___0 ;
  int flags ;
  int tmp___1 ;
  char const   *patlim ;
  char *n ;
  char const   *p ;
  char const   *pnul ;
  struct pcre_comp *pc ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  unsigned char const   *tmp___6 ;
  int tmp___7 ;
  int sub[300] ;

  {
#line 106
  if (((sizeof(wprefix) - 1UL) + sizeof(wsuffix)) - 1UL > ((sizeof(xprefix) - 1UL) + sizeof(xsuffix)) - 1UL) {
#line 106
    tmp = ((sizeof(wprefix) - 1UL) + sizeof(wsuffix)) - 1UL;
  } else {
#line 106
    tmp = ((sizeof(xprefix) - 1UL) + sizeof(xsuffix)) - 1UL;
  }
  {
#line 106
  fix_len_max = (int )tmp;
#line 108
  tmp___0 = xnmalloc((size_t )4, size + (size_t )(((fix_len_max + 4) - 1) / 4));
#line 108
  re = (char *)tmp___0;
  }
#line 109
  if (match_icase) {
#line 109
    tmp___1 = 1;
  } else {
#line 109
    tmp___1 = 0;
  }
  {
#line 109
  flags = 32 | tmp___1;
#line 110
  patlim = (char const   *)(pattern + size);
#line 111
  n = re;
#line 114
  tmp___2 = xcalloc((size_t )1, sizeof(*pc));
#line 114
  pc = (struct pcre_comp *)tmp___2;
  }
#line 116
  if (localeinfo.multibyte) {
#line 118
    if (! localeinfo.using_utf8) {
      {
#line 119
      exit(1);
      }
    }
#line 120
    flags |= 2048;
  }
  {
#line 124
  tmp___3 = memchr((void const   *)pattern, '\n', size);
  }
#line 124
  if (tmp___3) {
    {
#line 125
    exit(1);
    }
  }
#line 127
  *n = (char )'\000';
#line 128
  if (match_words) {
    {
#line 129
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)(wprefix));
    }
  }
#line 130
  if (match_lines) {
    {
#line 131
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)(xprefix));
    }
  }
  {
#line 132
  tmp___4 = strlen((char const   *)n);
#line 132
  n += tmp___4;
#line 138
  p = (char const   *)pattern;
  }
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 138
    tmp___5 = memchr((void const   *)p, '\000', (size_t )(patlim - p));
#line 138
    pnul = (char const   *)tmp___5;
    }
#line 138
    if (! pnul) {
#line 138
      goto while_break;
    }
    {
#line 140
    memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)p, (size_t )(pnul - p));
#line 141
    n += pnul - p;
#line 142
    p = pnul;
    }
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 142
      if ((unsigned long )pattern < (unsigned long )p) {
#line 142
        if (! ((int const   )*(p + -1) == 92)) {
#line 142
          goto while_break___0;
        }
      } else {
#line 142
        goto while_break___0;
      }
#line 143
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 142
      p --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 144
    n -= (pnul - p) & 1L;
#line 145
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)"\\000");
#line 146
    n += 4;
#line 138
    p = pnul + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 149
  memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)p, (size_t )(patlim - p));
#line 150
  n += patlim - p;
#line 151
  *n = (char )'\000';
  }
#line 152
  if (match_words) {
    {
#line 153
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)(wsuffix));
    }
  }
#line 154
  if (match_lines) {
    {
#line 155
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)(xsuffix));
    }
  }
  {
#line 157
  tmp___6 = pcre_maketables();
#line 157
  pc->cre = pcre_compile((char const   *)re, flags, & ep, & e, tmp___6);
  }
#line 158
  if (! pc->cre) {
    {
#line 159
    exit(1);
    }
  }
  {
#line 161
  pc->extra = pcre_study((pcre const   *)pc->cre, 1, & ep);
  }
#line 162
  if (ep) {
    {
#line 163
    exit(1);
    }
  }
  {
#line 166
  tmp___7 = pcre_fullinfo((pcre const   *)pc->cre, (pcre_extra const   *)pc->extra,
                          16, (void *)(& e));
  }
#line 166
  if (tmp___7) {
    {
#line 167
    exit(1);
    }
  }
#line 170
  if (e) {
#line 171
    pc->jit_stack_size = 32 << 10;
  }
  {
#line 174
  free((void *)re);
#line 177
  pc->empty_match[0] = pcre_exec((pcre const   *)pc->cre, (pcre_extra const   *)pc->extra,
                                 "", 0, 0, 128, sub, 300);
#line 179
  pc->empty_match[1] = pcre_exec((pcre const   *)pc->cre, (pcre_extra const   *)pc->extra,
                                 "", 0, 0, 0, sub, 300);
  }
#line 182
  return ((void *)pc);
}
}
#line 186 "/home/khheo/project/benchmark/grep-3.1/src/pcresearch.c"
size_t Pexecute(void *vcp , char const   *buf , size_t size , size_t *match_size ,
                char const   *start_ptr ) 
{ 
  int sub[300] ;
  char const   *p ;
  char const   *tmp ;
  _Bool bol ;
  char const   *line_start ;
  int e ;
  char const   *line_end ;
  struct pcre_comp *pc ;
  char const   *subject ;
  void *tmp___0 ;
  unsigned char tmp___1 ;
  int search_offset ;
  int options ;
  int valid_bytes ;
  char const   *matchbeg ;
  char const   *matchend ;
  char const   *beg ;
  char const   *end ;

  {
#line 195
  if (start_ptr) {
#line 195
    tmp = start_ptr;
  } else {
#line 195
    tmp = buf;
  }
#line 195
  p = tmp;
#line 196
  bol = (_Bool )((int const   )*(p + -1) == (int const   )eolbyte);
#line 197
  line_start = buf;
#line 198
  e = -1;
#line 200
  pc = (struct pcre_comp *)vcp;
#line 205
  subject = buf;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___0 = memchr((void const   *)p, (int )eolbyte, (size_t )((buf + size) - p));
#line 213
    line_end = (char const   *)tmp___0;
    }
#line 214
    if (2147483647L < line_end - p) {
      {
#line 215
      exit(1);
      }
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 222
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 222
        tmp___1 = to_uchar((char )*p);
        }
#line 222
        if (! ((int )localeinfo.sbclen[tmp___1] == -1)) {
#line 222
          goto while_break___1;
        }
#line 224
        p ++;
#line 225
        subject = p;
#line 226
        bol = (_Bool)0;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 229
      search_offset = (int )(p - subject);
#line 233
      if ((unsigned long )p == (unsigned long )line_end) {
#line 235
        sub[1] = search_offset;
#line 235
        sub[0] = sub[1];
#line 236
        e = pc->empty_match[bol];
#line 237
        goto while_break___0;
      }
#line 240
      options = 0;
#line 241
      if (! bol) {
#line 242
        options |= 128;
      }
      {
#line 244
      e = jit_exec(pc, subject, (int )(line_end - subject), search_offset, options,
                   sub);
      }
#line 246
      if (e != -10) {
#line 247
        goto while_break___0;
      }
#line 248
      valid_bytes = sub[0];
#line 250
      if (search_offset <= valid_bytes) {
#line 253
        if (valid_bytes == 0) {
#line 258
          sub[1] = 0;
#line 259
          e = pc->empty_match[bol];
        } else {
          {
#line 262
          e = jit_exec(pc, subject, valid_bytes, search_offset, (options | 8192) | 256,
                       sub);
          }
        }
#line 265
        if (e != -1) {
#line 266
          goto while_break___0;
        }
#line 269
        p = (subject + valid_bytes) + 1;
#line 270
        bol = (_Bool)0;
      }
#line 273
      subject += valid_bytes + 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 276
    if (e != -1) {
#line 277
      goto while_break;
    }
#line 278
    bol = (_Bool)1;
#line 279
    line_start = line_end + 1;
#line 279
    subject = line_start;
#line 279
    p = subject;
#line 207
    if (! ((unsigned long )p < (unsigned long )(buf + size))) {
#line 207
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  if (e <= 0) {
    {
#line 287
    if (e == -1) {
#line 287
      goto case_neg_1;
    }
#line 290
    if (e == -6) {
#line 290
      goto case_neg_6;
    }
#line 294
    if (e == -27) {
#line 294
      goto case_neg_27;
    }
#line 298
    if (e == -8) {
#line 298
      goto case_neg_8;
    }
#line 301
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 288
    goto switch_break;
    case_neg_6: /* CIL Label */ 
    {
#line 291
    exit(1);
    }
    case_neg_27: /* CIL Label */ 
    {
#line 295
    exit(1);
    }
    case_neg_8: /* CIL Label */ 
    {
#line 299
    exit(1);
    }
    switch_default: /* CIL Label */ 
    {
#line 306
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 309
    return ((size_t )-1);
  } else {
#line 313
    matchbeg = subject + sub[0];
#line 314
    matchend = subject + sub[1];
#line 317
    if (start_ptr) {
#line 319
      beg = matchbeg;
#line 320
      end = matchend;
    } else {
#line 324
      beg = line_start;
#line 325
      end = line_end + 1;
    }
#line 327
    *match_size = (size_t )(end - beg);
#line 328
    return ((size_t )(beg - buf));
  }
}
}
/* compiler builtin: 
   void __builtin_unreachable(void) ;  */
#line 38 "/home/khheo/project/benchmark/grep-3.1/src/kwset.h"
void kwsincr(kwset_t kwset , char const   *text , ptrdiff_t len ) ;
#line 39
ptrdiff_t kwswords(kwset_t kwset )  __attribute__((__pure__)) ;
#line 40
void kwsprep(kwset_t kwset ) ;
#line 41
ptrdiff_t ( __attribute__((__nonnull__(4))) kwsexec)(kwset_t kwset , char const   *text ,
                                                     ptrdiff_t size , struct kwsmatch *kwsmatch ,
                                                     _Bool longest ) ;
#line 44
void kwsfree(kwset_t kwset ) ;
#line 599 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 53 "/home/khheo/project/benchmark/grep-3.1/src/system.h"
#pragma GCC diagnostic push
#line 53
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 53
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 69
#pragma GCC diagnostic pop
#line 29 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 54 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
static unsigned char U(char ch ) 
{ 
  unsigned char tmp ;

  {
  {
#line 57
  tmp = to_uchar(ch);
  }
#line 57
  return (tmp);
}
}
#line 129 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
__inline static char tr(char const   *trans , char c ) 
{ 
  unsigned char tmp ;
  int tmp___0 ;

  {
#line 132
  if (trans) {
    {
#line 132
    tmp = U(c);
#line 132
    tmp___0 = (int const   )*(trans + tmp);
    }
  } else {
#line 132
    tmp___0 = (int const   )c;
  }
#line 132
  return ((char )tmp___0);
}
}
#line 135
static ptrdiff_t acexec(kwset_t kwset , char const   *text , ptrdiff_t size , struct kwsmatch *kwsmatch ,
                        _Bool longest ) ;
#line 137
static ptrdiff_t bmexec(kwset_t kwset , char const   *text , ptrdiff_t size , struct kwsmatch *kwsmatch ,
                        _Bool longest ) ;
#line 143 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
kwset_t kwsalloc(char const   *trans ) 
{ 
  struct kwset *kwset ;
  void *tmp ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 146
  tmp = xmalloc(sizeof(*kwset));
#line 146
  kwset = (struct kwset *)tmp;
#line 148
  _obstack_begin(& kwset->obstack, (size_t )0, (size_t )0, & xmalloc, (void (*)(void * ))(& free));
#line 149
  kwset->words = (ptrdiff_t )0;
#line 150
  __h = & kwset->obstack;
#line 150
  __o = __h;
#line 150
  __len = sizeof(*(kwset->trie));
#line 150
  __o1 = (struct obstack  const  *)__o;
  }
#line 150
  if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
    {
#line 150
    _obstack_newchunk(__o, __len);
    }
  }
#line 150
  __o->next_free += __len;
#line 150
  __o1___0 = __h;
#line 150
  __value = (void *)__o1___0->object_base;
#line 150
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 150
    __o1___0->maybe_empty_object = 1U;
  }
#line 150
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 150
    tmp___0 = __o1___0->object_base;
  } else {
#line 150
    tmp___0 = (char *)0;
  }
#line 150
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 150
    tmp___1 = __o1___0->object_base;
  } else {
#line 150
    tmp___1 = (char *)0;
  }
#line 150
  __o1___0->next_free = tmp___0 + (((size_t )(__o1___0->next_free - tmp___1) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 150
  if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 150
    __o1___0->next_free = __o1___0->chunk_limit;
  }
#line 150
  __o1___0->object_base = __o1___0->next_free;
#line 150
  kwset->trie = (struct trie *)__value;
#line 151
  (kwset->trie)->accepting = (size_t )0;
#line 152
  (kwset->trie)->links = (struct tree *)((void *)0);
#line 153
  (kwset->trie)->parent = (struct trie *)((void *)0);
#line 154
  (kwset->trie)->next = (struct trie *)((void *)0);
#line 155
  (kwset->trie)->fail = (struct trie *)((void *)0);
#line 156
  (kwset->trie)->depth = (ptrdiff_t )0;
#line 157
  (kwset->trie)->shift = (ptrdiff_t )0;
#line 158
  kwset->mind = 9223372036854775807L;
#line 159
  kwset->maxd = (ptrdiff_t )-1;
#line 160
  kwset->target = (char *)((void *)0);
#line 161
  kwset->trans = trans;
#line 162
  kwset->kwsexec = & acexec;
#line 164
  return (kwset);
}
}
#line 172 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
void kwsincr(kwset_t kwset , char const   *text , ptrdiff_t len ) 
{ 
  struct trie *trie ;
  char const   *trans ;
  _Bool reverse ;
  unsigned char uc ;
  char const   *tmp ;
  int tmp___0 ;
  unsigned char label___0 ;
  int tmp___1 ;
  struct tree *cur ;
  struct tree *links[12] ;
  enum __anonenum_dirs_744895363 dirs[12] ;
  ptrdiff_t depth ;
  ptrdiff_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  size_t __len___0 ;
  struct obstack  const  *__o1___1 ;
  struct obstack *__o1___2 ;
  void *__value___0 ;
  char *tmp___6 ;
  char *tmp___7 ;
  struct tree *t ;
  struct tree *r ;
  struct tree *l ;
  struct tree *rl ;
  struct tree *lr ;
  char tmp___8 ;
  char tmp___9 ;
  ptrdiff_t tmp___10 ;
  size_t words ;

  {
#line 175
  if (! (0L <= len)) {
    {
#line 175
    __builtin_unreachable();
    }
  }
#line 176
  trie = kwset->trie;
#line 177
  trans = kwset->trans;
#line 178
  reverse = (_Bool )((unsigned long )kwset->kwsexec == (unsigned long )(& bmexec));
#line 180
  if (reverse) {
#line 181
    text += len;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    tmp___10 = len;
#line 185
    len --;
#line 185
    if (! tmp___10) {
#line 185
      goto while_break;
    }
#line 187
    if (reverse) {
#line 187
      text --;
#line 187
      tmp___0 = (int const   )*text;
    } else {
#line 187
      tmp = text;
#line 187
      text ++;
#line 187
      tmp___0 = (int const   )*tmp;
    }
#line 187
    uc = (unsigned char )tmp___0;
#line 188
    if (trans) {
#line 188
      tmp___1 = (int const   )*(trans + uc);
    } else {
#line 188
      tmp___1 = (int const   )uc;
    }
#line 188
    label___0 = (unsigned char )tmp___1;
#line 193
    cur = trie->links;
#line 196
    links[0] = (struct tree *)(& trie->links);
#line 197
    dirs[0] = (enum __anonenum_dirs_744895363 )0;
#line 198
    depth = (ptrdiff_t )1;
    {
#line 200
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 200
      if (cur) {
#line 200
        if (! ((int )label___0 != (int )cur->label)) {
#line 200
          goto while_break___0;
        }
      } else {
#line 200
        goto while_break___0;
      }
#line 202
      links[depth] = cur;
#line 203
      if ((int )label___0 < (int )cur->label) {
#line 204
        tmp___2 = depth;
#line 204
        depth ++;
#line 204
        dirs[tmp___2] = (enum __anonenum_dirs_744895363 )0;
#line 204
        cur = cur->llink;
      } else {
#line 206
        tmp___3 = depth;
#line 206
        depth ++;
#line 206
        dirs[tmp___3] = (enum __anonenum_dirs_744895363 )1;
#line 206
        cur = cur->rlink;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 212
    if (! cur) {
#line 214
      __h = & kwset->obstack;
#line 214
      __o = __h;
#line 214
      __len = sizeof(*cur);
#line 214
      __o1 = (struct obstack  const  *)__o;
#line 214
      if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
        {
#line 214
        _obstack_newchunk(__o, __len);
        }
      }
#line 214
      __o->next_free += __len;
#line 214
      __o1___0 = __h;
#line 214
      __value = (void *)__o1___0->object_base;
#line 214
      if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 214
        __o1___0->maybe_empty_object = 1U;
      }
#line 214
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 214
        tmp___4 = __o1___0->object_base;
      } else {
#line 214
        tmp___4 = (char *)0;
      }
#line 214
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 214
        tmp___5 = __o1___0->object_base;
      } else {
#line 214
        tmp___5 = (char *)0;
      }
#line 214
      __o1___0->next_free = tmp___4 + (((size_t )(__o1___0->next_free - tmp___5) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 214
      if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 214
        __o1___0->next_free = __o1___0->chunk_limit;
      }
#line 214
      __o1___0->object_base = __o1___0->next_free;
#line 214
      cur = (struct tree *)__value;
#line 215
      cur->llink = (struct tree *)((void *)0);
#line 216
      cur->rlink = (struct tree *)((void *)0);
#line 217
      __h___0 = & kwset->obstack;
#line 217
      __o___0 = __h___0;
#line 217
      __len___0 = sizeof(*(cur->trie));
#line 217
      __o1___1 = (struct obstack  const  *)__o___0;
#line 217
      if ((size_t )(__o1___1->chunk_limit - __o1___1->next_free) < __len___0) {
        {
#line 217
        _obstack_newchunk(__o___0, __len___0);
        }
      }
#line 217
      __o___0->next_free += __len___0;
#line 217
      __o1___2 = __h___0;
#line 217
      __value___0 = (void *)__o1___2->object_base;
#line 217
      if ((unsigned long )__o1___2->next_free == (unsigned long )__value___0) {
#line 217
        __o1___2->maybe_empty_object = 1U;
      }
#line 217
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
        tmp___6 = __o1___2->object_base;
      } else {
#line 217
        tmp___6 = (char *)0;
      }
#line 217
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
        tmp___7 = __o1___2->object_base;
      } else {
#line 217
        tmp___7 = (char *)0;
      }
#line 217
      __o1___2->next_free = tmp___6 + (((size_t )(__o1___2->next_free - tmp___7) + __o1___2->alignment_mask) & ~ __o1___2->alignment_mask);
#line 217
      if ((size_t )(__o1___2->next_free - (char *)__o1___2->chunk) > (size_t )(__o1___2->chunk_limit - (char *)__o1___2->chunk)) {
#line 217
        __o1___2->next_free = __o1___2->chunk_limit;
      }
#line 217
      __o1___2->object_base = __o1___2->next_free;
#line 217
      cur->trie = (struct trie *)__value___0;
#line 218
      (cur->trie)->accepting = (size_t )0;
#line 219
      (cur->trie)->links = (struct tree *)((void *)0);
#line 220
      (cur->trie)->parent = trie;
#line 221
      (cur->trie)->next = (struct trie *)((void *)0);
#line 222
      (cur->trie)->fail = (struct trie *)((void *)0);
#line 223
      (cur->trie)->depth = trie->depth + 1L;
#line 224
      (cur->trie)->shift = (ptrdiff_t )0;
#line 225
      cur->label = label___0;
#line 226
      cur->balance = (char)0;
#line 229
      depth --;
#line 229
      if ((unsigned int )dirs[depth] == 0U) {
#line 230
        (links[depth])->llink = cur;
      } else {
#line 232
        (links[depth])->rlink = cur;
      }
      {
#line 235
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 235
        if (depth) {
#line 235
          if (! (! (links[depth])->balance)) {
#line 235
            goto while_break___1;
          }
        } else {
#line 235
          goto while_break___1;
        }
#line 237
        if ((unsigned int )dirs[depth] == 0U) {
#line 238
          (links[depth])->balance = (char )((int )(links[depth])->balance - 1);
        } else {
#line 240
          (links[depth])->balance = (char )((int )(links[depth])->balance + 1);
        }
#line 241
        depth --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 245
      if (depth) {
#line 245
        if ((unsigned int )dirs[depth] == 0U) {
#line 245
          (links[depth])->balance = (char )((int )(links[depth])->balance - 1);
#line 245
          if ((links[depth])->balance) {
#line 245
            goto _L;
          } else {
#line 245
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 245
        if ((unsigned int )dirs[depth] == 1U) {
#line 245
          (links[depth])->balance = (char )((int )(links[depth])->balance + 1);
#line 245
          if ((links[depth])->balance) {
            _L: /* CIL Label */ 
            {
#line 252
            if ((int )(links[depth])->balance == -2) {
#line 252
              goto case_neg_2;
            }
#line 272
            if ((int )(links[depth])->balance == 2) {
#line 272
              goto case_2;
            }
#line 292
            goto switch_default___1;
            case_neg_2: /* CIL Label */ 
            {
#line 255
            if ((unsigned int )dirs[depth + 1L] == 0U) {
#line 255
              goto case_0;
            }
#line 260
            if ((unsigned int )dirs[depth + 1L] == 1U) {
#line 260
              goto case_1;
            }
#line 268
            goto switch_default;
            case_0: /* CIL Label */ 
#line 256
            r = links[depth];
#line 256
            t = r->llink;
#line 256
            rl = t->rlink;
#line 257
            t->rlink = r;
#line 257
            r->llink = rl;
#line 258
            tmp___8 = (char)0;
#line 258
            r->balance = tmp___8;
#line 258
            t->balance = tmp___8;
#line 259
            goto switch_break___0;
            case_1: /* CIL Label */ 
#line 261
            r = links[depth];
#line 261
            l = r->llink;
#line 261
            t = l->rlink;
#line 262
            rl = t->rlink;
#line 262
            lr = t->llink;
#line 263
            t->llink = l;
#line 263
            l->rlink = lr;
#line 263
            t->rlink = r;
#line 263
            r->llink = rl;
#line 264
            if ((int )t->balance != 1) {
#line 264
              l->balance = (char)0;
            } else {
#line 264
              l->balance = (char)-1;
            }
#line 265
            if ((int )t->balance != -1) {
#line 265
              r->balance = (char)0;
            } else {
#line 265
              r->balance = (char)1;
            }
#line 266
            t->balance = (char)0;
#line 267
            goto switch_break___0;
            switch_default: /* CIL Label */ 
            {
#line 269
            abort();
            }
            switch_break___0: /* CIL Label */ ;
            }
#line 271
            goto switch_break;
            case_2: /* CIL Label */ 
            {
#line 275
            if ((unsigned int )dirs[depth + 1L] == 1U) {
#line 275
              goto case_1___0;
            }
#line 280
            if ((unsigned int )dirs[depth + 1L] == 0U) {
#line 280
              goto case_0___0;
            }
#line 288
            goto switch_default___0;
            case_1___0: /* CIL Label */ 
#line 276
            l = links[depth];
#line 276
            t = l->rlink;
#line 276
            lr = t->llink;
#line 277
            t->llink = l;
#line 277
            l->rlink = lr;
#line 278
            tmp___9 = (char)0;
#line 278
            l->balance = tmp___9;
#line 278
            t->balance = tmp___9;
#line 279
            goto switch_break___1;
            case_0___0: /* CIL Label */ 
#line 281
            l = links[depth];
#line 281
            r = l->rlink;
#line 281
            t = r->llink;
#line 282
            lr = t->llink;
#line 282
            rl = t->rlink;
#line 283
            t->llink = l;
#line 283
            l->rlink = lr;
#line 283
            t->rlink = r;
#line 283
            r->llink = rl;
#line 284
            if ((int )t->balance != 1) {
#line 284
              l->balance = (char)0;
            } else {
#line 284
              l->balance = (char)-1;
            }
#line 285
            if ((int )t->balance != -1) {
#line 285
              r->balance = (char)0;
            } else {
#line 285
              r->balance = (char)1;
            }
#line 286
            t->balance = (char)0;
#line 287
            goto switch_break___1;
            switch_default___0: /* CIL Label */ 
            {
#line 289
            abort();
            }
            switch_break___1: /* CIL Label */ ;
            }
#line 291
            goto switch_break;
            switch_default___1: /* CIL Label */ 
            {
#line 293
            abort();
            }
            switch_break: /* CIL Label */ ;
            }
#line 296
            if ((unsigned int )dirs[depth - 1L] == 0U) {
#line 297
              (links[depth - 1L])->llink = t;
            } else {
#line 299
              (links[depth - 1L])->rlink = t;
            }
          }
        }
      }
    }
#line 303
    trie = cur->trie;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  if (! trie->accepting) {
#line 310
    words = (size_t )kwset->words;
#line 311
    trie->accepting = 2UL * words + 1UL;
  }
#line 313
  (kwset->words) ++;
#line 316
  if (trie->depth < kwset->mind) {
#line 317
    kwset->mind = trie->depth;
  }
#line 318
  if (trie->depth > kwset->maxd) {
#line 319
    kwset->maxd = trie->depth;
  }
#line 320
  return;
}
}
#line 322
ptrdiff_t kwswords(kwset_t kwset )  __attribute__((__pure__)) ;
#line 322 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
ptrdiff_t kwswords(kwset_t kwset ) 
{ 


  {
#line 325
  return (kwset->words);
}
}
#line 330 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
static void enqueue(struct tree *tree , struct trie **last ) 
{ 
  struct trie *tmp ;

  {
#line 333
  if (! tree) {
#line 334
    return;
  }
  {
#line 335
  enqueue(tree->llink, last);
#line 336
  enqueue(tree->rlink, last);
#line 337
  tmp = tree->trie;
#line 337
  (*last)->next = tmp;
#line 337
  *last = tmp;
  }
#line 338
  return;
}
}
#line 343 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
static void treefails(struct tree  const  *tree , struct trie  const  *fail , struct trie *recourse ,
                      _Bool reverse ) 
{ 
  struct tree *cur ;

  {
#line 349
  if (! tree) {
#line 350
    return;
  }
  {
#line 352
  treefails((struct tree  const  *)tree->llink, fail, recourse, reverse);
#line 353
  treefails((struct tree  const  *)tree->rlink, fail, recourse, reverse);
  }
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! fail) {
#line 357
      goto while_break;
    }
#line 359
    cur = (struct tree *)fail->links;
    {
#line 360
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 360
      if (cur) {
#line 360
        if (! ((int const   )tree->label != (int const   )cur->label)) {
#line 360
          goto while_break___0;
        }
      } else {
#line 360
        goto while_break___0;
      }
#line 361
      if ((int const   )tree->label < (int const   )cur->label) {
#line 362
        cur = cur->llink;
      } else {
#line 364
        cur = cur->rlink;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 365
    if (cur) {
#line 367
      (tree->trie)->fail = cur->trie;
#line 368
      if (! reverse) {
#line 368
        if ((cur->trie)->accepting) {
#line 368
          if (! (tree->trie)->accepting) {
#line 369
            (tree->trie)->accepting = 0xffffffffffffffffUL;
          }
        }
      }
#line 370
      return;
    }
#line 372
    fail = (struct trie  const  *)fail->fail;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  (tree->trie)->fail = recourse;
#line 376
  return;
}
}
#line 380 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
static void treedelta(struct tree  const  *tree , ptrdiff_t depth , unsigned char *delta ) 
{ 


  {
#line 383
  if (! tree) {
#line 384
    return;
  }
  {
#line 385
  treedelta((struct tree  const  *)tree->llink, depth, delta);
#line 386
  treedelta((struct tree  const  *)tree->rlink, depth, delta);
  }
#line 387
  if (depth < (ptrdiff_t )*(delta + tree->label)) {
#line 388
    *(delta + tree->label) = (unsigned char )depth;
  }
#line 389
  return;
}
}
#line 392 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
static _Bool __attribute__((__pure__))  hasevery(struct tree  const  *a , struct tree  const  *b ) 
{ 
  _Bool __attribute__((__pure__))  tmp ;
  _Bool __attribute__((__pure__))  tmp___0 ;

  {
#line 395
  if (! b) {
#line 396
    return ((_Bool __attribute__((__pure__))  )1);
  }
  {
#line 397
  tmp = hasevery(a, (struct tree  const  *)b->llink);
  }
#line 397
  if (! tmp) {
#line 398
    return ((_Bool __attribute__((__pure__))  )0);
  }
  {
#line 399
  tmp___0 = hasevery(a, (struct tree  const  *)b->rlink);
  }
#line 399
  if (! tmp___0) {
#line 400
    return ((_Bool __attribute__((__pure__))  )0);
  }
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (a) {
#line 401
      if (! ((int const   )b->label != (int const   )a->label)) {
#line 401
        goto while_break;
      }
    } else {
#line 401
      goto while_break;
    }
#line 402
    if ((int const   )b->label < (int const   )a->label) {
#line 403
      a = (struct tree  const  *)a->llink;
    } else {
#line 405
      a = (struct tree  const  *)a->rlink;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  return ((_Bool __attribute__((__pure__))  )(! (! a)));
}
}
#line 411 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
static void treenext(struct tree  const  *tree , struct trie **next ) 
{ 


  {
#line 414
  if (! tree) {
#line 415
    return;
  }
  {
#line 416
  treenext((struct tree  const  *)tree->llink, next);
#line 417
  treenext((struct tree  const  *)tree->rlink, next);
#line 418
  *(next + tree->label) = (struct trie *)tree->trie;
  }
#line 419
  return;
}
}
#line 422 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
void kwsprep(kwset_t kwset ) 
{ 
  char const   *trans ;
  ptrdiff_t i ;
  unsigned char deltabuf[256] ;
  unsigned char *delta ;
  unsigned char *tmp ;
  struct trie *curr ;
  struct trie *last ;
  _Bool reverse ;
  kwset_t new_kwset ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct obstack *__o___0 ;
  void *__obj ;
  char *tmp___2 ;
  ptrdiff_t tmp___3 ;
  struct trie *fail ;
  _Bool __attribute__((__pure__))  tmp___4 ;
  struct trie *nextbuf[256] ;
  struct trie **next ;
  struct trie **tmp___5 ;
  int gc1 ;
  int gc1help ;
  int ti ;
  unsigned char tmp___6 ;
  struct obstack *__h___0 ;
  struct obstack *__o___1 ;
  size_t __len___0 ;
  struct obstack  const  *__o1___1 ;
  struct obstack *__o1___2 ;
  void *__value___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  struct obstack *__h___1 ;
  struct obstack *__o___2 ;
  size_t __len___1 ;
  struct obstack  const  *__o1___3 ;
  struct obstack *__o1___4 ;
  void *__value___1 ;
  char *tmp___9 ;
  char *tmp___10 ;
  unsigned char tmp___11 ;

  {
#line 425
  trans = kwset->trans;
#line 428
  if (trans) {
#line 428
    tmp = deltabuf;
  } else {
#line 428
    tmp = kwset->delta;
  }
#line 428
  delta = tmp;
#line 432
  reverse = (_Bool )(kwset->words == 1L);
#line 434
  if (reverse) {
#line 439
    last = kwset->trie;
#line 439
    curr = last;
    {
#line 439
    while (1) {
      while_continue: /* CIL Label */ ;
#line 439
      if (! curr) {
#line 439
        goto while_break;
      }
      {
#line 440
      enqueue(curr->links, & last);
#line 439
      curr = curr->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 443
    __h = & kwset->obstack;
#line 443
    __o = __h;
#line 443
    __len = (size_t )kwset->mind;
#line 443
    __o1 = (struct obstack  const  *)__o;
#line 443
    if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
      {
#line 443
      _obstack_newchunk(__o, __len);
      }
    }
#line 443
    __o->next_free += __len;
#line 443
    __o1___0 = __h;
#line 443
    __value = (void *)__o1___0->object_base;
#line 443
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 443
      __o1___0->maybe_empty_object = 1U;
    }
#line 443
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 443
      tmp___0 = __o1___0->object_base;
    } else {
#line 443
      tmp___0 = (char *)0;
    }
#line 443
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 443
      tmp___1 = __o1___0->object_base;
    } else {
#line 443
      tmp___1 = (char *)0;
    }
#line 443
    __o1___0->next_free = tmp___0 + (((size_t )(__o1___0->next_free - tmp___1) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 443
    if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 443
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 443
    __o1___0->object_base = __o1___0->next_free;
#line 443
    kwset->target = (char *)__value;
#line 444
    i = (ptrdiff_t )0;
#line 444
    curr = kwset->trie;
    {
#line 444
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 444
      if (! (i < kwset->mind)) {
#line 444
        goto while_break___0;
      }
#line 446
      *(kwset->target + i) = (char )(curr->links)->label;
#line 447
      curr = curr->next;
#line 444
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 450
    new_kwset = kwsalloc(kwset->trans);
#line 451
    new_kwset->kwsexec = & bmexec;
#line 452
    kwsincr(new_kwset, (char const   *)kwset->target, kwset->mind);
#line 453
    __o___0 = & kwset->obstack;
#line 453
    __obj = (void *)0;
    }
#line 453
    if ((unsigned long )__obj > (unsigned long )((void *)__o___0->chunk)) {
#line 453
      if ((unsigned long )__obj < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 453
        tmp___2 = (char *)__obj;
#line 453
        __o___0->object_base = tmp___2;
#line 453
        __o___0->next_free = tmp___2;
      } else {
        {
#line 453
        _obstack_free(__o___0, __obj);
        }
      }
    } else {
      {
#line 453
      _obstack_free(__o___0, __obj);
      }
    }
    {
#line 454
    *kwset = *new_kwset;
#line 455
    free((void *)new_kwset);
    }
  }
#line 461
  if (kwset->mind < 255L) {
#line 461
    tmp___3 = kwset->mind;
  } else {
#line 461
    tmp___3 = (ptrdiff_t )255;
  }
  {
#line 461
  memset((void *)delta, (int )tmp___3, sizeof(deltabuf));
#line 465
  last = kwset->trie;
#line 465
  curr = last;
  }
  {
#line 465
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 465
    if (! curr) {
#line 465
      goto while_break___1;
    }
    {
#line 468
    enqueue(curr->links, & last);
#line 471
    treedelta((struct tree  const  *)curr->links, curr->depth, delta);
#line 474
    treefails((struct tree  const  *)curr->links, (struct trie  const  *)curr->fail,
              kwset->trie, reverse);
    }
#line 476
    if (reverse) {
#line 478
      curr->shift = kwset->mind;
#line 479
      curr->maxshift = kwset->mind;
#line 484
      fail = curr->fail;
      {
#line 484
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 484
        if (! fail) {
#line 484
          goto while_break___2;
        }
        {
#line 489
        tmp___4 = hasevery((struct tree  const  *)fail->links, (struct tree  const  *)curr->links);
        }
#line 489
        if (! tmp___4) {
#line 490
          if (curr->depth - fail->depth < fail->shift) {
#line 491
            fail->shift = curr->depth - fail->depth;
          }
        }
#line 496
        if (curr->accepting) {
#line 496
          if (fail->maxshift > curr->depth - fail->depth) {
#line 497
            fail->maxshift = curr->depth - fail->depth;
          }
        }
#line 484
        fail = fail->fail;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 465
    curr = curr->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 502
  if (reverse) {
#line 506
    curr = (kwset->trie)->next;
    {
#line 506
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 506
      if (! curr) {
#line 506
        goto while_break___3;
      }
#line 508
      if (curr->maxshift > (curr->parent)->maxshift) {
#line 509
        curr->maxshift = (curr->parent)->maxshift;
      }
#line 510
      if (curr->shift > curr->maxshift) {
#line 511
        curr->shift = curr->maxshift;
      }
#line 506
      curr = curr->next;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 518
  if (trans) {
#line 518
    tmp___5 = nextbuf;
  } else {
#line 518
    tmp___5 = kwset->next;
  }
  {
#line 518
  next = tmp___5;
#line 519
  memset((void *)next, 0, sizeof(nextbuf));
#line 520
  treenext((struct tree  const  *)(kwset->trie)->links, next);
#line 521
  gc1 = -2;
#line 522
  gc1help = -1;
#line 523
  i = (ptrdiff_t )0;
  }
  {
#line 523
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 523
    if (! (i < 256L)) {
#line 523
      goto while_break___4;
    }
#line 525
    ti = (int )i;
#line 526
    if (trans) {
      {
#line 528
      tmp___6 = U((char )*(trans + i));
#line 528
      ti = (int )tmp___6;
#line 529
      kwset->next[i] = *(next + ti);
      }
    }
#line 531
    if (kwset->next[i]) {
#line 533
      if (gc1 < -1) {
#line 535
        gc1 = ti;
#line 536
        gc1help = (int )i;
      } else
#line 538
      if (gc1 == ti) {
#line 539
        if (gc1help == ti) {
#line 539
          gc1help = (int )i;
        } else {
#line 539
          gc1help = -1;
        }
      } else
#line 540
      if (i == (ptrdiff_t )ti) {
#line 540
        if (gc1 == gc1help) {
#line 541
          gc1help = (int )i;
        } else {
#line 543
          gc1 = -1;
        }
      } else {
#line 543
        gc1 = -1;
      }
    }
#line 523
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 546
  kwset->gc1 = gc1;
#line 547
  kwset->gc1help = gc1help;
#line 549
  if (reverse) {
#line 552
    __h___0 = & kwset->obstack;
#line 552
    __o___1 = __h___0;
#line 552
    __len___0 = (size_t )kwset->mind;
#line 552
    __o1___1 = (struct obstack  const  *)__o___1;
#line 552
    if ((size_t )(__o1___1->chunk_limit - __o1___1->next_free) < __len___0) {
      {
#line 552
      _obstack_newchunk(__o___1, __len___0);
      }
    }
#line 552
    __o___1->next_free += __len___0;
#line 552
    __o1___2 = __h___0;
#line 552
    __value___0 = (void *)__o1___2->object_base;
#line 552
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___0) {
#line 552
      __o1___2->maybe_empty_object = 1U;
    }
#line 552
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 552
      tmp___7 = __o1___2->object_base;
    } else {
#line 552
      tmp___7 = (char *)0;
    }
#line 552
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 552
      tmp___8 = __o1___2->object_base;
    } else {
#line 552
      tmp___8 = (char *)0;
    }
#line 552
    __o1___2->next_free = tmp___7 + (((size_t )(__o1___2->next_free - tmp___8) + __o1___2->alignment_mask) & ~ __o1___2->alignment_mask);
#line 552
    if ((size_t )(__o1___2->next_free - (char *)__o1___2->chunk) > (size_t )(__o1___2->chunk_limit - (char *)__o1___2->chunk)) {
#line 552
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 552
    __o1___2->object_base = __o1___2->next_free;
#line 552
    kwset->target = (char *)__value___0;
#line 553
    i = kwset->mind - 1L;
#line 553
    curr = kwset->trie;
    {
#line 553
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 553
      if (! (i >= 0L)) {
#line 553
        goto while_break___5;
      }
#line 555
      *(kwset->target + i) = (char )(curr->links)->label;
#line 556
      curr = curr->next;
#line 553
      i --;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 559
    if (kwset->mind > 1L) {
#line 564
      __h___1 = & kwset->obstack;
#line 564
      __o___2 = __h___1;
#line 564
      __len___1 = sizeof(*(kwset->shift)) * (unsigned long )(kwset->mind - 1L);
#line 564
      __o1___3 = (struct obstack  const  *)__o___2;
#line 564
      if ((size_t )(__o1___3->chunk_limit - __o1___3->next_free) < __len___1) {
        {
#line 564
        _obstack_newchunk(__o___2, __len___1);
        }
      }
#line 564
      __o___2->next_free += __len___1;
#line 564
      __o1___4 = __h___1;
#line 564
      __value___1 = (void *)__o1___4->object_base;
#line 564
      if ((unsigned long )__o1___4->next_free == (unsigned long )__value___1) {
#line 564
        __o1___4->maybe_empty_object = 1U;
      }
#line 564
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 564
        tmp___9 = __o1___4->object_base;
      } else {
#line 564
        tmp___9 = (char *)0;
      }
#line 564
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 564
        tmp___10 = __o1___4->object_base;
      } else {
#line 564
        tmp___10 = (char *)0;
      }
#line 564
      __o1___4->next_free = tmp___9 + (((size_t )(__o1___4->next_free - tmp___10) + __o1___4->alignment_mask) & ~ __o1___4->alignment_mask);
#line 564
      if ((size_t )(__o1___4->next_free - (char *)__o1___4->chunk) > (size_t )(__o1___4->chunk_limit - (char *)__o1___4->chunk)) {
#line 564
        __o1___4->next_free = __o1___4->chunk_limit;
      }
#line 564
      __o1___4->object_base = __o1___4->next_free;
#line 564
      kwset->shift = (ptrdiff_t *)__value___1;
#line 566
      i = (ptrdiff_t )0;
#line 566
      curr = (kwset->trie)->next;
      {
#line 566
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 566
        if (! (i < kwset->mind - 1L)) {
#line 566
          goto while_break___6;
        }
#line 568
        *(kwset->shift + i) = curr->shift;
#line 569
        curr = curr->next;
#line 566
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 573
      kwset->gc2 = tr(trans, *(kwset->target + (kwset->mind - 2L)));
      }
    }
  }
#line 578
  if (trans) {
#line 579
    i = (ptrdiff_t )0;
    {
#line 579
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 579
      if (! (i < 256L)) {
#line 579
        goto while_break___7;
      }
      {
#line 580
      tmp___11 = U((char )*(trans + i));
#line 580
      kwset->delta[i] = *(delta + tmp___11);
#line 579
      i ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 581
  return;
}
}
#line 591 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
__inline static _Bool bm_delta2_search(char const   **tpp , char const   *ep , char const   *sp ,
                                       ptrdiff_t len , char const   *trans , char gc1 ,
                                       char gc2 , unsigned char const   *d1 , kwset_t kwset ) 
{ 
  char const   *tp ;
  ptrdiff_t d ;
  ptrdiff_t skip ;
  ptrdiff_t i ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  unsigned char tmp___4 ;
  char tmp___5 ;

  {
#line 597
  tp = *tpp;
#line 598
  d = len;
#line 598
  skip = (ptrdiff_t )0;
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 602
    i = (ptrdiff_t )2;
#line 603
    tmp___3 = tr(trans, (char )*(tp + -2));
    }
#line 603
    if ((int )tmp___3 == (int )gc2) {
      {
#line 605
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 605
        i ++;
#line 605
        if (! (i <= d)) {
#line 605
          goto while_break___0;
        }
        {
#line 606
        tmp = tr(trans, (char )*(tp + - i));
#line 606
        tmp___0 = tr(trans, (char )*(sp + - i));
        }
#line 606
        if ((int )tmp != (int )tmp___0) {
#line 607
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 608
      if (i > d) {
#line 610
        i = (d + skip) + 1L;
        {
#line 610
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 610
          if (! (i <= len)) {
#line 610
            goto while_break___1;
          }
          {
#line 611
          tmp___1 = tr(trans, (char )*(tp + - i));
#line 611
          tmp___2 = tr(trans, (char )*(sp + - i));
          }
#line 611
          if ((int )tmp___1 != (int )tmp___2) {
#line 612
            goto while_break___1;
          }
#line 610
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 613
        if (i > len) {
#line 615
          *tpp = tp - len;
#line 616
          return ((_Bool)1);
        }
      }
    }
#line 621
    d = *(kwset->shift + (i - 2L));
#line 621
    tp += d;
#line 622
    if ((unsigned long )tp > (unsigned long )ep) {
#line 623
      goto while_break;
    }
    {
#line 624
    tmp___5 = tr(trans, (char )*(tp + -1));
    }
#line 624
    if ((int )tmp___5 != (int )gc1) {
#line 626
      if (d1) {
        {
#line 627
        tmp___4 = U((char )*(tp + -1));
#line 627
        tp += (int const   )*(d1 + tmp___4);
        }
      }
#line 628
      goto while_break;
    }
#line 630
    skip = i - 1L;
  }
  while_break: /* CIL Label */ ;
  }
#line 633
  *tpp = tp;
#line 634
  return ((_Bool)0);
}
}
#line 640 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
static char const   *memchr_kwset(char const   *s , ptrdiff_t n , kwset_t kwset ) 
{ 
  char const   *slim ;
  unsigned char tmp ;
  int small_heuristic ;
  size_t small_bytes ;
  unsigned char tmp___0 ;
  void *tmp___1 ;

  {
#line 643
  slim = s + n;
#line 644
  if (kwset->gc1help < 0) {
    {
#line 646
    while (1) {
      while_continue: /* CIL Label */ ;
#line 646
      if (! ((unsigned long )s < (unsigned long )slim)) {
#line 646
        goto while_break;
      }
      {
#line 647
      tmp = U((char )*s);
      }
#line 647
      if (kwset->next[tmp]) {
#line 648
        return (s);
      }
#line 646
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 652
    small_heuristic = 2;
#line 653
    small_bytes = (unsigned long )small_heuristic * sizeof(unsigned long );
    {
#line 654
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 654
      if (! ((unsigned long )s < (unsigned long )slim)) {
#line 654
        goto while_break___0;
      }
      {
#line 656
      tmp___0 = U((char )*s);
      }
#line 656
      if (kwset->next[tmp___0]) {
#line 657
        return (s);
      }
#line 658
      s ++;
#line 659
      if ((uintptr_t )s % small_bytes == 0UL) {
        {
#line 660
        tmp___1 = memchr2((void const   *)s, kwset->gc1, kwset->gc1help, (size_t )(slim - s));
        }
#line 660
        return ((char const   *)tmp___1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 663
  return ((char const   *)((void *)0));
}
}
#line 667 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
__inline static ptrdiff_t bmexec_trans(kwset_t kwset , char const   *text , ptrdiff_t size ) 
{ 
  unsigned char const   *d1 ;
  char const   *ep ;
  char const   *sp ;
  char const   *tp ;
  int d ;
  ptrdiff_t len ;
  char const   *trans ;
  long tmp ;
  char gc1 ;
  char gc2 ;
  ptrdiff_t len12 ;
  char const   *tp0 ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  int advance_heuristic ;
  _Bool tmp___10 ;
  int tmp___13 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___35 ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___46 ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___59 ;
  int tmp___62 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  unsigned char tmp___70 ;
  unsigned char tmp___71 ;
  _Bool tmp___72 ;

  {
#line 670
  if (! (0L <= size)) {
    {
#line 670
    __builtin_unreachable();
    }
  }
#line 674
  len = kwset->mind;
#line 675
  trans = kwset->trans;
#line 677
  if (len == 0L) {
#line 678
    return ((ptrdiff_t )0);
  }
#line 679
  if (len > size) {
#line 680
    return ((ptrdiff_t )-1);
  }
#line 681
  if (len == 1L) {
    {
#line 683
    tp = memchr_kwset(text, size, kwset);
    }
#line 684
    if (tp) {
#line 684
      tmp = tp - text;
    } else {
#line 684
      tmp = -1L;
    }
#line 684
    return (tmp);
  }
#line 687
  d1 = (unsigned char const   *)(kwset->delta);
#line 688
  sp = (char const   *)(kwset->target + len);
#line 689
  tp = text + len;
#line 690
  gc1 = (char )kwset->gc1;
#line 691
  gc2 = kwset->gc2;
#line 695
  if (sizeof(len12) == sizeof(signed char )) {
#line 695
    if (sizeof(len * 12L) < sizeof(signed char )) {
#line 695
      if (~ (((1 << (sizeof((int )((signed char )len)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 695
        if ((int )((signed char )len) < 0) {
#line 695
          len12 = (ptrdiff_t )((signed char )((unsigned int )((signed char )len) * 12U));
#line 695
          tmp___13 = 1;
        } else {
#line 695
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 695
        if ((int )((signed char )len) < 0) {
#line 695
          tmp___15 = (int )((signed char )len) < ~ (((1 << (sizeof((int )((signed char )len)) * 8UL - 2UL)) - 1) * 2 + 1) / 12;
        } else {
#line 695
          tmp___15 = (((1 << (sizeof((int )((signed char )len)) * 8UL - 2UL)) - 1) * 2 + 1) / 12 < (int )((signed char )len);
        }
#line 695
        if (tmp___15) {
#line 695
          len12 = (ptrdiff_t )((signed char )((unsigned int )((signed char )len) * 12U));
#line 695
          tmp___13 = 1;
        } else
#line 695
        if ((int )((signed char )len) * 12 < -128) {
#line 695
          len12 = (ptrdiff_t )((signed char )((unsigned int )((signed char )len) * 12U));
#line 695
          tmp___13 = 1;
        } else
#line 695
        if (127 < (int )((signed char )len) * 12) {
#line 695
          len12 = (ptrdiff_t )((signed char )((unsigned int )((signed char )len) * 12U));
#line 695
          tmp___13 = 1;
        } else {
#line 695
          len12 = (ptrdiff_t )((signed char )((unsigned int )((signed char )len) * 12U));
#line 695
          tmp___13 = 0;
        }
      }
#line 695
      tmp___21 = tmp___13;
    } else {
#line 695
      if (~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 695
        if (len < 0L) {
#line 695
          len12 = (ptrdiff_t )((signed char )((unsigned int )len * 12U));
#line 695
          tmp___18 = 1;
        } else {
#line 695
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 695
        if (len < 0L) {
#line 695
          tmp___20 = len < ~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L;
        } else {
#line 695
          tmp___20 = (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L < len;
        }
#line 695
        if (tmp___20) {
#line 695
          len12 = (ptrdiff_t )((signed char )((unsigned int )len * 12U));
#line 695
          tmp___18 = 1;
        } else
#line 695
        if (len * 12L < -128L) {
#line 695
          len12 = (ptrdiff_t )((signed char )((unsigned int )len * 12U));
#line 695
          tmp___18 = 1;
        } else
#line 695
        if (127L < len * 12L) {
#line 695
          len12 = (ptrdiff_t )((signed char )((unsigned int )len * 12U));
#line 695
          tmp___18 = 1;
        } else {
#line 695
          len12 = (ptrdiff_t )((signed char )((unsigned int )len * 12U));
#line 695
          tmp___18 = 0;
        }
      }
#line 695
      tmp___21 = tmp___18;
    }
#line 695
    tmp___69 = tmp___21;
  } else {
#line 695
    if (sizeof(len12) == sizeof(short )) {
#line 695
      if (sizeof(len * 12L) < sizeof(short )) {
#line 695
        if (~ (((1 << (sizeof((int )((short )len)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 695
          if ((int )((short )len) < 0) {
#line 695
            len12 = (ptrdiff_t )((short )((unsigned int )((short )len) * 12U));
#line 695
            tmp___24 = 1;
          } else {
#line 695
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 695
          if ((int )((short )len) < 0) {
#line 695
            tmp___26 = (int )((short )len) < ~ (((1 << (sizeof((int )((short )len)) * 8UL - 2UL)) - 1) * 2 + 1) / 12;
          } else {
#line 695
            tmp___26 = (((1 << (sizeof((int )((short )len)) * 8UL - 2UL)) - 1) * 2 + 1) / 12 < (int )((short )len);
          }
#line 695
          if (tmp___26) {
#line 695
            len12 = (ptrdiff_t )((short )((unsigned int )((short )len) * 12U));
#line 695
            tmp___24 = 1;
          } else
#line 695
          if ((int )((short )len) * 12 < -32768) {
#line 695
            len12 = (ptrdiff_t )((short )((unsigned int )((short )len) * 12U));
#line 695
            tmp___24 = 1;
          } else
#line 695
          if (32767 < (int )((short )len) * 12) {
#line 695
            len12 = (ptrdiff_t )((short )((unsigned int )((short )len) * 12U));
#line 695
            tmp___24 = 1;
          } else {
#line 695
            len12 = (ptrdiff_t )((short )((unsigned int )((short )len) * 12U));
#line 695
            tmp___24 = 0;
          }
        }
#line 695
        tmp___32 = tmp___24;
      } else {
#line 695
        if (~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 695
          if (len < 0L) {
#line 695
            len12 = (ptrdiff_t )((short )((unsigned int )len * 12U));
#line 695
            tmp___29 = 1;
          } else {
#line 695
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 695
          if (len < 0L) {
#line 695
            tmp___31 = len < ~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L;
          } else {
#line 695
            tmp___31 = (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L < len;
          }
#line 695
          if (tmp___31) {
#line 695
            len12 = (ptrdiff_t )((short )((unsigned int )len * 12U));
#line 695
            tmp___29 = 1;
          } else
#line 695
          if (len * 12L < -32768L) {
#line 695
            len12 = (ptrdiff_t )((short )((unsigned int )len * 12U));
#line 695
            tmp___29 = 1;
          } else
#line 695
          if (32767L < len * 12L) {
#line 695
            len12 = (ptrdiff_t )((short )((unsigned int )len * 12U));
#line 695
            tmp___29 = 1;
          } else {
#line 695
            len12 = (ptrdiff_t )((short )((unsigned int )len * 12U));
#line 695
            tmp___29 = 0;
          }
        }
#line 695
        tmp___32 = tmp___29;
      }
#line 695
      tmp___68 = tmp___32;
    } else {
#line 695
      if (sizeof(len12) == sizeof(int )) {
#line 695
        if (sizeof(len * 12L) < sizeof(int )) {
#line 695
          if (~ (((1 << (sizeof((int )len) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 695
            if ((int )len < 0) {
#line 695
              len12 = (ptrdiff_t )((int )((unsigned int )((int )len) * 12U));
#line 695
              tmp___35 = 1;
            } else {
#line 695
              goto _L___3;
            }
          } else {
            _L___3: /* CIL Label */ 
#line 695
            if ((int )len < 0) {
#line 695
              tmp___37 = (int )len < ~ (((1 << (sizeof((int )len) * 8UL - 2UL)) - 1) * 2 + 1) / 12;
            } else {
#line 695
              tmp___37 = (((1 << (sizeof((int )len) * 8UL - 2UL)) - 1) * 2 + 1) / 12 < (int )len;
            }
#line 695
            if (tmp___37) {
#line 695
              len12 = (ptrdiff_t )((int )((unsigned int )((int )len) * 12U));
#line 695
              tmp___35 = 1;
            } else
#line 695
            if ((int )len * 12 < (-0x7FFFFFFF-1)) {
#line 695
              len12 = (ptrdiff_t )((int )((unsigned int )((int )len) * 12U));
#line 695
              tmp___35 = 1;
            } else
#line 695
            if (2147483647 < (int )len * 12) {
#line 695
              len12 = (ptrdiff_t )((int )((unsigned int )((int )len) * 12U));
#line 695
              tmp___35 = 1;
            } else {
#line 695
              len12 = (ptrdiff_t )((int )((unsigned int )((int )len) * 12U));
#line 695
              tmp___35 = 0;
            }
          }
#line 695
          tmp___43 = tmp___35;
        } else {
#line 695
          if (~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 695
            if (len < 0L) {
#line 695
              len12 = (ptrdiff_t )((int )((unsigned int )len * 12U));
#line 695
              tmp___40 = 1;
            } else {
#line 695
              goto _L___4;
            }
          } else {
            _L___4: /* CIL Label */ 
#line 695
            if (len < 0L) {
#line 695
              tmp___42 = len < ~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L;
            } else {
#line 695
              tmp___42 = (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L < len;
            }
#line 695
            if (tmp___42) {
#line 695
              len12 = (ptrdiff_t )((int )((unsigned int )len * 12U));
#line 695
              tmp___40 = 1;
            } else
#line 695
            if (len * 12L < (-0x7FFFFFFF-1)) {
#line 695
              len12 = (ptrdiff_t )((int )((unsigned int )len * 12U));
#line 695
              tmp___40 = 1;
            } else
#line 695
            if (2147483647L < len * 12L) {
#line 695
              len12 = (ptrdiff_t )((int )((unsigned int )len * 12U));
#line 695
              tmp___40 = 1;
            } else {
#line 695
              len12 = (ptrdiff_t )((int )((unsigned int )len * 12U));
#line 695
              tmp___40 = 0;
            }
          }
#line 695
          tmp___43 = tmp___40;
        }
#line 695
        tmp___67 = tmp___43;
      } else {
#line 695
        if (sizeof(len12) == sizeof(long )) {
#line 695
          if (sizeof(len * 12L) < sizeof(long )) {
#line 695
            if (~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 695
              if (len < 0L) {
#line 695
                len12 = (long )((unsigned long )len * 12UL);
#line 695
                tmp___46 = 1;
              } else {
#line 695
                goto _L___5;
              }
            } else {
              _L___5: /* CIL Label */ 
#line 695
              if (len < 0L) {
#line 695
                tmp___48 = len < ~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L;
              } else {
#line 695
                tmp___48 = (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L < len;
              }
#line 695
              if (tmp___48) {
#line 695
                len12 = (long )((unsigned long )len * 12UL);
#line 695
                tmp___46 = 1;
              } else
#line 695
              if (len * 12L < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 695
                len12 = (long )((unsigned long )len * 12UL);
#line 695
                tmp___46 = 1;
              } else
#line 695
              if (9223372036854775807L < len * 12L) {
#line 695
                len12 = (long )((unsigned long )len * 12UL);
#line 695
                tmp___46 = 1;
              } else {
#line 695
                len12 = (long )((unsigned long )len * 12UL);
#line 695
                tmp___46 = 0;
              }
            }
#line 695
            tmp___54 = tmp___46;
          } else {
#line 695
            if (~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 695
              if (len < 0L) {
#line 695
                len12 = (long )((unsigned long )len * 12UL);
#line 695
                tmp___51 = 1;
              } else {
#line 695
                goto _L___6;
              }
            } else {
              _L___6: /* CIL Label */ 
#line 695
              if (len < 0L) {
#line 695
                tmp___53 = len < ~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L;
              } else {
#line 695
                tmp___53 = (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L < len;
              }
#line 695
              if (tmp___53) {
#line 695
                len12 = (long )((unsigned long )len * 12UL);
#line 695
                tmp___51 = 1;
              } else
#line 695
              if (len * 12L < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 695
                len12 = (long )((unsigned long )len * 12UL);
#line 695
                tmp___51 = 1;
              } else
#line 695
              if (9223372036854775807L < len * 12L) {
#line 695
                len12 = (long )((unsigned long )len * 12UL);
#line 695
                tmp___51 = 1;
              } else {
#line 695
                len12 = (long )((unsigned long )len * 12UL);
#line 695
                tmp___51 = 0;
              }
            }
#line 695
            tmp___54 = tmp___51;
          }
#line 695
          tmp___66 = tmp___54;
        } else {
#line 695
          if (sizeof(len * 12L) < sizeof(long long )) {
#line 695
            if (~ (((1LL << (sizeof((long long )len) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 695
              if ((long long )len < 0LL) {
#line 695
                len12 = (ptrdiff_t )((long long )((unsigned long long )((long long )len) * 12ULL));
#line 695
                tmp___57 = 1;
              } else {
#line 695
                goto _L___7;
              }
            } else {
              _L___7: /* CIL Label */ 
#line 695
              if ((long long )len < 0LL) {
#line 695
                tmp___59 = (long long )len < ~ (((1LL << (sizeof((long long )len) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / 12LL;
              } else {
#line 695
                tmp___59 = (((1LL << (sizeof((long long )len) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / 12LL < (long long )len;
              }
#line 695
              if (tmp___59) {
#line 695
                len12 = (ptrdiff_t )((long long )((unsigned long long )((long long )len) * 12ULL));
#line 695
                tmp___57 = 1;
              } else
#line 695
              if ((long long )len * 12LL < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 695
                len12 = (ptrdiff_t )((long long )((unsigned long long )((long long )len) * 12ULL));
#line 695
                tmp___57 = 1;
              } else
#line 695
              if (9223372036854775807LL < (long long )len * 12LL) {
#line 695
                len12 = (ptrdiff_t )((long long )((unsigned long long )((long long )len) * 12ULL));
#line 695
                tmp___57 = 1;
              } else {
#line 695
                len12 = (ptrdiff_t )((long long )((unsigned long long )((long long )len) * 12ULL));
#line 695
                tmp___57 = 0;
              }
            }
#line 695
            tmp___65 = tmp___57;
          } else {
#line 695
            if (~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 695
              if (len < 0L) {
#line 695
                len12 = (ptrdiff_t )((long long )((unsigned long long )len * 12ULL));
#line 695
                tmp___62 = 1;
              } else {
#line 695
                goto _L___8;
              }
            } else {
              _L___8: /* CIL Label */ 
#line 695
              if (len < 0L) {
#line 695
                tmp___64 = len < ~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L;
              } else {
#line 695
                tmp___64 = (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L < len;
              }
#line 695
              if (tmp___64) {
#line 695
                len12 = (ptrdiff_t )((long long )((unsigned long long )len * 12ULL));
#line 695
                tmp___62 = 1;
              } else
#line 695
              if ((long long )(len * 12L) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 695
                len12 = (ptrdiff_t )((long long )((unsigned long long )len * 12ULL));
#line 695
                tmp___62 = 1;
              } else
#line 695
              if (9223372036854775807LL < (long long )(len * 12L)) {
#line 695
                len12 = (ptrdiff_t )((long long )((unsigned long long )len * 12ULL));
#line 695
                tmp___62 = 1;
              } else {
#line 695
                len12 = (ptrdiff_t )((long long )((unsigned long long )len * 12ULL));
#line 695
                tmp___62 = 0;
              }
            }
#line 695
            tmp___65 = tmp___62;
          }
#line 695
          tmp___66 = tmp___65;
        }
#line 695
        tmp___67 = tmp___66;
      }
#line 695
      tmp___68 = tmp___67;
    }
#line 695
    tmp___69 = tmp___68;
  }
#line 695
  if (! tmp___69) {
#line 695
    if (len12 < size) {
#line 697
      ep = (text + size) - 11L * len;
      {
#line 697
      while (1) {
        while_continue: /* CIL Label */ ;
#line 697
        if (! ((unsigned long )tp <= (unsigned long )ep)) {
#line 697
          goto while_break;
        }
        {
#line 699
        tp0 = tp;
#line 700
        tmp___0 = U((char )*(tp + -1));
#line 700
        d = (int )*(d1 + tmp___0);
#line 700
        tp += d;
#line 701
        tmp___1 = U((char )*(tp + -1));
#line 701
        d = (int )*(d1 + tmp___1);
#line 701
        tp += d;
        }
#line 702
        if (d != 0) {
          {
#line 704
          tmp___2 = U((char )*(tp + -1));
#line 704
          d = (int )*(d1 + tmp___2);
#line 704
          tp += d;
#line 705
          tmp___3 = U((char )*(tp + -1));
#line 705
          d = (int )*(d1 + tmp___3);
#line 705
          tp += d;
#line 706
          tmp___4 = U((char )*(tp + -1));
#line 706
          d = (int )*(d1 + tmp___4);
#line 706
          tp += d;
          }
#line 707
          if (d != 0) {
            {
#line 709
            tmp___5 = U((char )*(tp + -1));
#line 709
            d = (int )*(d1 + tmp___5);
#line 709
            tp += d;
#line 710
            tmp___6 = U((char )*(tp + -1));
#line 710
            d = (int )*(d1 + tmp___6);
#line 710
            tp += d;
#line 711
            tmp___7 = U((char )*(tp + -1));
#line 711
            d = (int )*(d1 + tmp___7);
#line 711
            tp += d;
            }
#line 712
            if (d != 0) {
              {
#line 714
              tmp___8 = U((char )*(tp + -1));
#line 714
              d = (int )*(d1 + tmp___8);
#line 714
              tp += d;
#line 715
              tmp___9 = U((char )*(tp + -1));
#line 715
              d = (int )*(d1 + tmp___9);
#line 715
              tp += d;
#line 719
              advance_heuristic = (int )(16UL * sizeof(long ));
              }
#line 720
              if ((long )advance_heuristic <= tp - tp0) {
#line 721
                goto __Cont;
              }
              {
#line 722
              tp --;
#line 723
              tp = memchr_kwset(tp, (text + size) - tp, kwset);
              }
#line 724
              if (! tp) {
#line 725
                return ((ptrdiff_t )-1);
              }
#line 726
              tp ++;
#line 727
              if ((unsigned long )ep <= (unsigned long )tp) {
#line 728
                goto while_break;
              }
            }
          }
        }
        {
#line 732
        tmp___10 = bm_delta2_search(& tp, ep, sp, len, trans, gc1, gc2, d1, kwset);
        }
#line 732
        if (tmp___10) {
#line 733
          return (tp - text);
        }
        __Cont: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 738
  ep = text + size;
#line 739
  tmp___70 = U((char )*(tp + -1));
#line 739
  d = (int )*(d1 + tmp___70);
  }
  {
#line 740
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 740
    if (! ((long )d <= ep - tp)) {
#line 740
      goto while_break___0;
    }
    {
#line 742
    tp += d;
#line 742
    tmp___71 = U((char )*(tp + -1));
#line 742
    d = (int )*(d1 + tmp___71);
    }
#line 743
    if (d != 0) {
#line 744
      goto while_continue___0;
    }
    {
#line 745
    tmp___72 = bm_delta2_search(& tp, ep, sp, len, trans, gc1, gc2, (unsigned char const   *)((void *)0),
                                kwset);
    }
#line 745
    if (tmp___72) {
#line 746
      return (tp - text);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 749
  return ((ptrdiff_t )-1);
}
}
#line 753 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
static ptrdiff_t bmexec(kwset_t kwset , char const   *text , ptrdiff_t size , struct kwsmatch *kwsmatch ,
                        _Bool longest ) 
{ 
  ptrdiff_t ret ;
  ptrdiff_t tmp ;
  ptrdiff_t tmp___0 ;
  ptrdiff_t tmp___1 ;

  {
#line 759
  if (kwset->trans) {
    {
#line 759
    tmp = bmexec_trans(kwset, text, size);
#line 759
    tmp___1 = tmp;
    }
  } else {
    {
#line 759
    tmp___0 = bmexec_trans(kwset, text, size);
#line 759
    tmp___1 = tmp___0;
    }
  }
#line 759
  ret = tmp___1;
#line 763
  if (0L <= ret) {
#line 765
    kwsmatch->index = (ptrdiff_t )0;
#line 766
    kwsmatch->offset[0] = ret;
#line 767
    kwsmatch->size[0] = kwset->mind;
  }
#line 770
  return (ret);
}
}
#line 775 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
__inline static ptrdiff_t acexec_trans(kwset_t kwset , char const   *text , ptrdiff_t len ,
                                       struct kwsmatch *kwsmatch , _Bool longest ) 
{ 
  struct trie  const  *trie ;
  struct trie  const  *accept ;
  char const   *tp ;
  char const   *left ;
  char const   *lim ;
  struct tree  const  *tree ;
  char const   *trans ;
  unsigned char c ;
  int gc1 ;
  char const   *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;
  char tmp___2 ;
  char const   *tmp___3 ;
  char tmp___4 ;
  struct trie  const  *accept1 ;
  char const   *left1 ;
  unsigned char c___0 ;
  char const   *tmp___5 ;
  char tmp___6 ;

  {
#line 785
  if (len < kwset->mind) {
#line 786
    return ((ptrdiff_t )-1);
  }
#line 787
  trans = kwset->trans;
#line 788
  trie = (struct trie  const  *)kwset->trie;
#line 789
  lim = text + len;
#line 790
  tp = text;
#line 792
  if (! trie->accepting) {
#line 795
    gc1 = kwset->gc1;
    {
#line 797
    while (1) {
      while_continue: /* CIL Label */ ;
#line 799
      if (gc1 < 0) {
        {
#line 801
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 801
          tmp = tp;
#line 801
          tp ++;
#line 801
          tmp___0 = tr(trans, (char )*tmp);
#line 801
          c = (unsigned char )tmp___0;
#line 801
          trie = (struct trie  const  *)kwset->next[c];
          }
#line 801
          if (trie) {
#line 801
            goto while_break___0;
          }
#line 802
          if ((unsigned long )tp >= (unsigned long )lim) {
#line 803
            return ((ptrdiff_t )-1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 807
        tp = memchr_kwset(tp, lim - tp, kwset);
        }
#line 808
        if (! tp) {
#line 809
          return ((ptrdiff_t )-1);
        }
        {
#line 810
        tmp___1 = tp;
#line 810
        tp ++;
#line 810
        tmp___2 = tr(trans, (char )*tmp___1);
#line 810
        c = (unsigned char )tmp___2;
#line 811
        trie = (struct trie  const  *)kwset->next[c];
        }
      }
      {
#line 814
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 816
        if (trie->accepting) {
#line 817
          goto match;
        }
#line 818
        if ((unsigned long )tp >= (unsigned long )lim) {
#line 819
          return ((ptrdiff_t )-1);
        }
        {
#line 820
        tmp___3 = tp;
#line 820
        tp ++;
#line 820
        tmp___4 = tr(trans, (char )*tmp___3);
#line 820
        c = (unsigned char )tmp___4;
#line 822
        tree = (struct tree  const  *)trie->links;
        }
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          if (! ((int )c != (int )tree->label)) {
#line 822
            goto while_break___2;
          }
#line 824
          if ((int )c < (int )tree->label) {
#line 824
            tree = (struct tree  const  *)tree->llink;
          } else {
#line 824
            tree = (struct tree  const  *)tree->rlink;
          }
#line 825
          if (! tree) {
#line 827
            trie = (struct trie  const  *)trie->fail;
#line 828
            if (! trie) {
#line 830
              trie = (struct trie  const  *)kwset->next[c];
#line 831
              if (trie) {
#line 832
                goto have_trie;
              }
#line 833
              if ((unsigned long )tp >= (unsigned long )lim) {
#line 834
                return ((ptrdiff_t )-1);
              }
#line 835
              goto next_c;
            }
#line 837
            if (trie->accepting) {
#line 839
              tp --;
#line 840
              goto match;
            }
#line 842
            tree = (struct tree  const  *)trie->links;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 845
        trie = (struct trie  const  *)tree->trie;
        have_trie: ;
      }
      while_break___1: /* CIL Label */ ;
      }
      next_c: ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  match: 
#line 853
  accept = trie;
  {
#line 854
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 854
    if (! (accept->accepting == 0xffffffffffffffffUL)) {
#line 854
      goto while_break___3;
    }
#line 855
    accept = (struct trie  const  *)accept->fail;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 856
  left = tp - accept->depth;
#line 859
  if (longest) {
    {
#line 861
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 861
      if (! ((unsigned long )tp < (unsigned long )lim)) {
#line 861
        goto while_break___4;
      }
      {
#line 865
      tmp___5 = tp;
#line 865
      tp ++;
#line 865
      tmp___6 = tr(trans, (char )*tmp___5);
#line 865
      c___0 = (unsigned char )tmp___6;
      }
      {
#line 867
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 869
        tree = (struct tree  const  *)trie->links;
        {
#line 870
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 870
          if (tree) {
#line 870
            if (! ((int )c___0 != (int )tree->label)) {
#line 870
              goto while_break___6;
            }
          } else {
#line 870
            goto while_break___6;
          }
#line 871
          if ((int )c___0 < (int )tree->label) {
#line 871
            tree = (struct tree  const  *)tree->llink;
          } else {
#line 871
            tree = (struct tree  const  *)tree->rlink;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 867
        if (! tree) {
#line 867
          trie = (struct trie  const  *)trie->fail;
#line 867
          if (trie) {
#line 867
            if (! (accept->depth <= trie->depth)) {
#line 867
              goto while_break___5;
            }
          } else {
#line 867
            goto while_break___5;
          }
        } else {
#line 867
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 875
      if (! tree) {
#line 876
        goto while_break___4;
      }
#line 877
      trie = (struct trie  const  *)tree->trie;
#line 878
      if (trie->accepting) {
#line 880
        accept1 = trie;
        {
#line 881
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 881
          if (! (accept1->accepting == 0xffffffffffffffffUL)) {
#line 881
            goto while_break___7;
          }
#line 882
          accept1 = (struct trie  const  *)accept1->fail;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 883
        left1 = tp - accept1->depth;
#line 884
        if ((unsigned long )left1 <= (unsigned long )left) {
#line 886
          left = left1;
#line 887
          accept = accept1;
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 893
  kwsmatch->index = (ptrdiff_t )(accept->accepting / 2UL);
#line 894
  kwsmatch->offset[0] = left - text;
#line 895
  kwsmatch->size[0] = (ptrdiff_t )accept->depth;
#line 897
  return (left - text);
}
}
#line 901 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
static ptrdiff_t acexec(kwset_t kwset , char const   *text , ptrdiff_t size , struct kwsmatch *kwsmatch ,
                        _Bool longest ) 
{ 
  ptrdiff_t tmp ;
  ptrdiff_t tmp___0 ;
  ptrdiff_t tmp___1 ;

  {
#line 905
  if (! (0L <= size)) {
    {
#line 905
    __builtin_unreachable();
    }
  }
#line 908
  if (kwset->trans) {
    {
#line 908
    tmp = acexec_trans(kwset, text, size, kwsmatch, longest);
#line 908
    tmp___1 = tmp;
    }
  } else {
    {
#line 908
    tmp___0 = acexec_trans(kwset, text, size, kwsmatch, longest);
#line 908
    tmp___1 = tmp___0;
    }
  }
#line 908
  return (tmp___1);
}
}
#line 920 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
ptrdiff_t ( __attribute__((__nonnull__(4))) kwsexec)(kwset_t kwset , char const   *text ,
                                                     ptrdiff_t size , struct kwsmatch *kwsmatch ,
                                                     _Bool longest ) 
{ 
  ptrdiff_t tmp ;

  {
  {
#line 924
  tmp = (*(kwset->kwsexec))(kwset, text, size, kwsmatch, longest);
  }
#line 924
  return (tmp);
}
}
#line 928 "/home/khheo/project/benchmark/grep-3.1/src/kwset.c"
void kwsfree(kwset_t kwset ) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 931
  __o = & kwset->obstack;
#line 931
  __obj = (void *)0;
#line 931
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 931
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 931
      tmp = (char *)__obj;
#line 931
      __o->object_base = tmp;
#line 931
      __o->next_free = tmp;
    } else {
      {
#line 931
      _obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 931
    _obstack_free(__o, __obj);
    }
  }
  {
#line 932
  free((void *)kwset);
  }
#line 933
  return;
}
}
#line 82 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 599 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 53 "/home/khheo/project/benchmark/grep-3.1/src/system.h"
#pragma GCC diagnostic push
#line 53
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 53
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 69
#pragma GCC diagnostic pop
#line 29 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 37 "/home/khheo/project/benchmark/grep-3.1/src/search.h"
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 37
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 58
void *GEAcompile(char *pattern , size_t size , reg_syntax_t syntax_bits ) ;
#line 59
size_t EGexecute(void *vdc , char const   *buf , size_t size , size_t *match_size ,
                 char const   *start_ptr ) ;
#line 62
void *Fcompile(char *pattern , size_t size , reg_syntax_t ignored ) ;
#line 63
size_t Fexecute(void *vcp , char const   *buf , size_t size , size_t *match_size ,
                char const   *start_ptr ) ;
#line 71
void fgrep_to_grep_pattern(char **keys_p , size_t *len_p ) ;
#line 84
#pragma GCC diagnostic pop
#line 49 "/home/khheo/project/benchmark/grep-3.1/src/kwsearch.c"
void *Fcompile(char *pattern , size_t size , reg_syntax_t ignored ) 
{ 
  kwset_t kwset ;
  ptrdiff_t total ;
  char *buf ;
  size_t bufalloc___0 ;
  char const   *p ;
  ptrdiff_t len ;
  char const   *sep ;
  void *tmp ;
  void *tmp___0 ;
  ptrdiff_t words ;
  ptrdiff_t tmp___1 ;
  mbstate_t mbs ;
  char checked[256] ;
  unsigned int tmp___2 ;
  unsigned char c ;
  wint_t wc ;
  wchar_t folded[32] ;
  int i ;
  int tmp___3 ;
  char s[16] ;
  int nbytes ;
  size_t tmp___4 ;
  struct kwsearch *kwsearch ;
  void *tmp___5 ;

  {
  {
#line 53
  total = (ptrdiff_t )size;
#line 54
  buf = (char *)((void *)0);
#line 55
  bufalloc___0 = (size_t )0;
#line 57
  kwset = kwsinit((_Bool)1);
#line 59
  p = (char const   *)pattern;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 63
    tmp = memchr((void const   *)p, '\n', (size_t )total);
#line 63
    sep = (char const   *)tmp;
    }
#line 64
    if (sep) {
#line 66
      len = sep - p;
#line 67
      sep ++;
#line 68
      total -= len + 1L;
    } else {
#line 72
      len = total;
#line 73
      total = (ptrdiff_t )0;
    }
#line 76
    if (match_lines) {
#line 78
      if ((int )eolbyte == 10) {
#line 78
        if ((unsigned long )pattern < (unsigned long )p) {
#line 78
          if (sep) {
#line 79
            p --;
          } else {
#line 78
            goto _L___0;
          }
        } else {
#line 78
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 82
        if (bufalloc___0 < (size_t )(len + 2L)) {
          {
#line 84
          free((void *)buf);
#line 85
          bufalloc___0 = (size_t )(len + 2L);
#line 86
          tmp___0 = x2realloc((void *)0, & bufalloc___0);
#line 86
          buf = (char *)tmp___0;
#line 87
          *(buf + 0) = eolbyte;
          }
        }
        {
#line 89
        memcpy((void */* __restrict  */)(buf + 1), (void const   */* __restrict  */)p,
               (size_t )len);
#line 90
        *(buf + (len + 1L)) = eolbyte;
#line 91
        p = (char const   *)buf;
        }
      }
#line 93
      len += 2L;
    }
    {
#line 95
    kwsincr(kwset, p, len);
#line 97
    p = sep;
    }
#line 60
    if (! p) {
#line 60
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  free((void *)buf);
#line 102
  tmp___1 = kwswords(kwset);
#line 102
  words = tmp___1;
  }
#line 104
  if (match_icase) {
#line 114
    mbs.__count = 0;
#line 114
    mbs.__value.__wch = 0U;
#line 115
    checked[0] = (char)0;
#line 115
    tmp___2 = 1U;
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 115
      if (tmp___2 >= 256U) {
#line 115
        goto while_break___0;
      }
#line 115
      checked[tmp___2] = (char)0;
#line 115
      tmp___2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 116
    p = (char const   *)pattern;
    {
#line 116
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 116
      if (! ((unsigned long )p < (unsigned long )(pattern + size))) {
#line 116
        goto while_break___1;
      }
#line 118
      c = (unsigned char )*p;
#line 119
      if (checked[c]) {
#line 120
        goto __Cont;
      }
      {
#line 121
      checked[c] = (char)1;
#line 123
      wc = localeinfo.sbctowc[c];
#line 126
      tmp___3 = case_folded_counterparts(wc, (wchar_t *)(folded));
#line 126
      i = tmp___3;
      }
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 126
        i --;
#line 126
        if (! (0 <= i)) {
#line 126
          goto while_break___2;
        }
        {
#line 129
        tmp___4 = wcrtomb((char */* __restrict  */)(s), folded[i], (mbstate_t */* __restrict  */)(& mbs));
#line 129
        nbytes = (int )tmp___4;
        }
#line 130
        if (1 < nbytes) {
          {
#line 131
          kwsincr(kwset, (char const   *)(s), (ptrdiff_t )nbytes);
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 116
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 136
  kwsprep(kwset);
#line 138
  tmp___5 = xmalloc(sizeof(*kwsearch));
#line 138
  kwsearch = (struct kwsearch *)tmp___5;
#line 139
  kwsearch->kwset = kwset;
#line 140
  kwsearch->words = words;
#line 141
  kwsearch->pattern = pattern;
#line 142
  kwsearch->size = size;
#line 143
  kwsearch->re = (void *)0;
  }
#line 144
  return ((void *)kwsearch);
}
}
#line 151 "/home/khheo/project/benchmark/grep-3.1/src/kwsearch.c"
size_t Fexecute(void *vcp , char const   *buf , size_t size , size_t *match_size ,
                char const   *start_ptr ) 
{ 
  char const   *beg ;
  char const   *end ;
  char const   *mb_start ;
  ptrdiff_t len ;
  char eol ;
  struct kwsmatch kwsmatch ;
  size_t ret_val ;
  _Bool mb_check ;
  _Bool longest ;
  struct kwsearch *kwsearch ;
  kwset_t kwset ;
  ptrdiff_t offset ;
  ptrdiff_t tmp ;
  size_t tmp___0 ;
  ptrdiff_t tmp___1 ;
  char const   *bol ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  size_t off ;

  {
#line 157
  eol = eolbyte;
#line 162
  kwsearch = (struct kwsearch *)vcp;
#line 163
  kwset = kwsearch->kwset;
#line 165
  if (match_lines) {
#line 166
    longest = (_Bool)0;
#line 166
    mb_check = longest;
  } else {
#line 169
    mb_check = (_Bool )((int )localeinfo.multibyte & ! localeinfo.using_utf8);
#line 170
    longest = (_Bool )(((int )mb_check | ! (! start_ptr)) | (int )match_words);
  }
#line 173
  if (start_ptr) {
#line 173
    beg = start_ptr;
  } else {
#line 173
    beg = buf;
  }
#line 173
  mb_start = beg;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! ((unsigned long )beg <= (unsigned long )(buf + size))) {
#line 173
      goto while_break;
    }
    {
#line 175
    tmp = kwsexec(kwset, beg - (int )match_lines, ((buf + size) - beg) + (long )match_lines,
                  & kwsmatch, longest);
#line 175
    offset = tmp;
    }
#line 178
    if (offset < 0L) {
#line 179
      goto while_break;
    }
#line 180
    len = kwsmatch.size[0] - (ptrdiff_t )(2 * (int )match_lines);
#line 182
    if (kwsearch->words <= kwsmatch.index) {
#line 188
      if (! kwsearch->re) {
        {
#line 190
        fgrep_to_grep_pattern(& kwsearch->pattern, & kwsearch->size);
#line 191
        kwsearch->re = GEAcompile(kwsearch->pattern, kwsearch->size, (((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ~ (((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
        }
      }
      {
#line 194
      tmp___0 = EGexecute(kwsearch->re, buf, size, match_size, start_ptr);
      }
#line 194
      return (tmp___0);
    }
#line 197
    if (mb_check) {
      {
#line 197
      tmp___1 = mb_goback(& mb_start, beg + offset, buf + size);
      }
#line 197
      if (tmp___1 != 0L) {
#line 212
        beg = mb_start - 1;
#line 213
        goto __Cont;
      }
    }
#line 215
    beg += offset;
#line 216
    if (! (! start_ptr) & ! match_words) {
#line 217
      goto success_in_beg_and_len;
    }
#line 218
    if (match_lines) {
#line 220
      len += (ptrdiff_t )((unsigned long )start_ptr == (unsigned long )((void *)0));
#line 221
      goto success_in_beg_and_len;
    }
#line 223
    if (! match_words) {
#line 224
      goto success;
    }
    {
#line 229
    tmp___2 = memrchr((void const   *)mb_start, (int )eol, (size_t )(beg - mb_start));
#line 229
    bol = (char const   *)tmp___2;
    }
#line 230
    if (bol) {
#line 231
      mb_start = bol + 1;
    }
    {
#line 232
    tmp___4 = wordchar_prev(mb_start, beg, buf + size);
    }
#line 232
    if (! tmp___4) {
      {
#line 233
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 235
        tmp___3 = wordchar_next(beg + len, buf + size);
        }
#line 235
        if (! tmp___3) {
#line 237
          if (start_ptr) {
#line 238
            goto success_in_beg_and_len;
          } else {
#line 240
            goto success;
          }
        }
#line 242
        if (! len) {
#line 243
          goto while_break___0;
        }
        {
#line 244
        len --;
#line 244
        offset = kwsexec(kwset, beg, len, & kwsmatch, (_Bool)1);
        }
#line 245
        if (offset != 0L) {
#line 246
          goto while_break___0;
        }
#line 247
        len = kwsmatch.size[0];
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 253
    tmp___5 = wordchars_size(beg, buf + size);
#line 253
    beg += tmp___5;
#line 254
    mb_start = beg;
    }
    __Cont: /* CIL Label */ 
#line 173
    beg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return ((size_t )-1);
  success: 
  {
#line 260
  tmp___6 = memchr((void const   *)(beg + len), (int )eol, (size_t )((buf + size) - (beg + len)));
#line 260
  end = (char const   *)tmp___6;
  }
#line 261
  if (end) {
#line 261
    end ++;
  } else {
#line 261
    end = buf + size;
  }
  {
#line 262
  tmp___7 = memrchr((void const   *)buf, (int )eol, (size_t )(beg - buf));
#line 262
  beg = (char const   *)tmp___7;
  }
#line 263
  if (beg) {
#line 263
    beg ++;
  } else {
#line 263
    beg = buf;
  }
#line 264
  len = end - beg;
  success_in_beg_and_len: 
#line 266
  off = (size_t )(beg - buf);
#line 268
  *match_size = (size_t )len;
#line 269
  ret_val = off;
#line 270
  return (ret_val);
}
}
#line 408 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
extern __ssize_t splice(int __fdin , __off64_t *__offin , int __fdout , __off64_t *__offout ,
                        size_t __len , unsigned int __flags ) ;
#line 213 "/usr/include/stdio.h"
extern int fflush_unlocked(FILE *__stream ) ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 546
extern int putchar_unlocked(int __c ) ;
#line 673
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n ,
                             FILE * __restrict  __stream ) ;
#line 675
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 622
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 782
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 599 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 592 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 53 "/home/khheo/project/benchmark/grep-3.1/src/system.h"
#pragma GCC diagnostic push
#line 53
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 53
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 69
#pragma GCC diagnostic pop
#line 31 "../lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 66 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
extern int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc , char * const  *___argv ,
                                                            char const   *__shortopts ,
                                                            struct option  const  *__longopts ,
                                                            int *__longind ) ;
#line 27 "/home/khheo/project/benchmark/grep-3.1/src/grep.h"
_Bool match_icase  ;
#line 28 "/home/khheo/project/benchmark/grep-3.1/src/grep.h"
_Bool match_words  ;
#line 29 "/home/khheo/project/benchmark/grep-3.1/src/grep.h"
_Bool match_lines  ;
#line 30 "/home/khheo/project/benchmark/grep-3.1/src/grep.h"
char eolbyte  ;
#line 32
char const   * __attribute__((__pure__)) pattern_file_name(size_t lineno , size_t *new_lineno ) ;
#line 82 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 29 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 37 "/home/khheo/project/benchmark/grep-3.1/src/search.h"
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 37
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 70 "/home/khheo/project/benchmark/grep-3.1/src/search.h"
struct localeinfo localeinfo  ;
#line 84
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 81
#pragma GCC diagnostic pop
#line 25 "../lib/xbinary-io.h"
#pragma GCC diagnostic push
#line 25
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 25
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 46
#pragma GCC diagnostic pop
#line 56 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   SEP_STR_GROUP[3]  = {      (char const   )'-',      (char const   )'-',      (char const   )'\000'};
#line 65 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static struct stat out_stat  ;
#line 68 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int show_help  ;
#line 71 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool show_version  ;
#line 74 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool suppress_errors  ;
#line 77 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int color_option  ;
#line 80 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool only_matching  ;
#line 83 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool align_tabs  ;
#line 86 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int offset_width  ;
#line 102 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static struct FL_pair *fl_pair  ;
#line 103 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static size_t n_fl_pair_slots  ;
#line 106 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static size_t n_pattern_files  ;
#line 111 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static size_t n_patterns  ;
#line 114 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static size_t __attribute__((__pure__))  count_nl_bytes(char const   *buf , size_t size ) 
{ 
  char const   *p ;
  char const   *end_p ;
  size_t n ;
  void *tmp ;

  {
#line 117
  p = buf;
#line 118
  end_p = buf + size;
#line 119
  n = (size_t )0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = memchr((void const   *)p, '\n', (size_t )(end_p - p));
#line 120
    p = (char const   *)tmp;
    }
#line 120
    if (! p) {
#line 120
      goto while_break;
    }
#line 121
    p ++;
#line 121
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return ((size_t __attribute__((__pure__))  )n);
}
}
#line 127 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void fl_add(char const   *buf , size_t size , char const   *filename___0 ) 
{ 
  void *tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;

  {
#line 130
  if (n_fl_pair_slots <= n_pattern_files) {
    {
#line 131
    tmp = x2nrealloc((void *)fl_pair, & n_fl_pair_slots, sizeof(*fl_pair));
#line 131
    fl_pair = (struct FL_pair *)tmp;
    }
  }
  {
#line 133
  (fl_pair + n_pattern_files)->lineno = n_patterns + 1UL;
#line 134
  (fl_pair + n_pattern_files)->filename = filename___0;
#line 135
  n_pattern_files ++;
#line 136
  tmp___0 = count_nl_bytes(buf, size);
#line 136
  n_patterns += (size_t )tmp___0;
  }
#line 137
  return;
}
}
#line 142 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
char const   * __attribute__((__pure__)) pattern_file_name(size_t lineno , size_t *new_lineno ) 
{ 
  size_t i ;

  {
#line 146
  i = (size_t )1;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i < n_pattern_files)) {
#line 146
      goto while_break;
    }
#line 148
    if (lineno < (fl_pair + i)->lineno) {
#line 149
      goto while_break;
    }
#line 146
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  *new_lineno = (lineno - (fl_pair + (i - 1UL))->lineno) + 1UL;
#line 153
  return ((char const   */* __attribute__((__pure__)) */)(fl_pair + (i - 1UL))->filename);
}
}
#line 178 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void clear_asan_poison(void) 
{ 


  {
#line 178
  return;
}
}
#line 179 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void asan_poison(void const volatile   *addr , size_t size ) 
{ 


  {
#line 179
  return;
}
}
#line 183 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *group_separator  =    SEP_STR_GROUP;
#line 230 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *selected_match_color  =    "01;31";
#line 231 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *context_match_color  =    "01;31";
#line 234 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *filename_color  =    "35";
#line 235 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *line_num_color  =    "32";
#line 236 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *byte_num_color  =    "32";
#line 237 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *sep_color  =    "36";
#line 238 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *selected_line_color  =    "";
#line 239 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *context_line_color  =    "";
#line 298 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *sgr_start  =    "\033[%sm\033[K";
#line 299 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *sgr_end  =    "\033[m\033[K";
#line 302 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void pr_sgr_start(char const   *s ) 
{ 


  {
#line 305
  if (*s) {
    {
#line 306
    print_start_colorize(sgr_start, s);
    }
  }
#line 307
  return;
}
}
#line 308 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void pr_sgr_end(char const   *s ) 
{ 


  {
#line 311
  if (*s) {
    {
#line 312
    print_end_colorize(sgr_end);
    }
  }
#line 313
  return;
}
}
#line 314 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void pr_sgr_start_if(char const   *s ) 
{ 


  {
#line 317
  if (color_option) {
    {
#line 318
    pr_sgr_start(s);
    }
  }
#line 319
  return;
}
}
#line 320 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void pr_sgr_end_if(char const   *s ) 
{ 


  {
#line 323
  if (color_option) {
    {
#line 324
    pr_sgr_end(s);
    }
  }
#line 325
  return;
}
}
#line 334 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void color_cap_mt_fct(void) 
{ 


  {
#line 338
  context_match_color = selected_match_color;
#line 339
  return;
}
}
#line 341 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void color_cap_rv_fct(void) 
{ 


  {
#line 345
  color_option = -1;
#line 346
  return;
}
}
#line 348 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void color_cap_ne_fct(void) 
{ 


  {
#line 351
  sgr_start = "\033[%sm";
#line 352
  sgr_end = "\033[m";
#line 353
  return;
}
}
#line 356 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static struct color_cap  const  color_dict[12]  = 
#line 356
  {      {"mt", & selected_match_color, & color_cap_mt_fct}, 
        {"ms", & selected_match_color, (void (*)(void))((void *)0)}, 
        {"mc", & context_match_color, (void (*)(void))((void *)0)}, 
        {"fn", & filename_color, (void (*)(void))((void *)0)}, 
        {"ln", & line_num_color, (void (*)(void))((void *)0)}, 
        {"bn", & byte_num_color, (void (*)(void))((void *)0)}, 
        {"se", & sep_color, (void (*)(void))((void *)0)}, 
        {"sl", & selected_line_color, (void (*)(void))((void *)0)}, 
        {"cx", & context_line_color, (void (*)(void))((void *)0)}, 
        {"rv", (char const   **)((void *)0), & color_cap_rv_fct}, 
        {"ne", (char const   **)((void *)0), & color_cap_ne_fct}, 
        {(char const   *)((void *)0), (char const   **)((void *)0), (void (*)(void))((void *)0)}};
#line 373 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int stdout_errno  ;
#line 375 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void putchar_errno(int c ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 378
  tmp___0 = putchar_unlocked(c);
  }
#line 378
  if (tmp___0 < 0) {
    {
#line 379
    tmp = __errno_location();
#line 379
    stdout_errno = *tmp;
    }
  }
#line 380
  return;
}
}
#line 382 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void fputs_errno(char const   *s ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 385
  tmp___0 = fputs_unlocked((char const   */* __restrict  */)s, (FILE */* __restrict  */)stdout);
  }
#line 385
  if (tmp___0 < 0) {
    {
#line 386
    tmp = __errno_location();
#line 386
    stdout_errno = *tmp;
    }
  }
#line 387
  return;
}
}
#line 389 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void ( /* format attribute */  printf_errno)(char const   *format  , ...) 
{ 
  va_list ap ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 393
  __builtin_va_start(ap, format);
#line 394
  tmp___0 = vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)format,
                     ap);
  }
#line 394
  if (tmp___0 < 0) {
    {
#line 395
    tmp = __errno_location();
#line 395
    stdout_errno = *tmp;
    }
  }
  {
#line 396
  __builtin_va_end(ap);
  }
#line 397
  return;
}
}
#line 399 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void fwrite_errno(void const   *ptr , size_t size , size_t nmemb ) 
{ 
  int *tmp ;
  size_t tmp___0 ;

  {
  {
#line 402
  tmp___0 = fwrite_unlocked((void const   */* __restrict  */)ptr, size, nmemb, (FILE */* __restrict  */)stdout);
  }
#line 402
  if (tmp___0 != nmemb) {
    {
#line 403
    tmp = __errno_location();
#line 403
    stdout_errno = *tmp;
    }
  }
#line 404
  return;
}
}
#line 406 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void fflush_errno(void) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 409
  tmp___0 = fflush_unlocked(stdout);
  }
#line 409
  if (tmp___0 != 0) {
    {
#line 410
    tmp = __errno_location();
#line 410
    stdout_errno = *tmp;
    }
  }
#line 411
  return;
}
}
#line 413 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static struct exclude *excluded_patterns[2]  ;
#line 414 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static struct exclude *excluded_directory_patterns[2]  ;
#line 416 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   short_options[58]  = 
#line 416
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )':', 
        (char const   )'B',      (char const   )':',      (char const   )'C',      (char const   )':', 
        (char const   )'D',      (char const   )':',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'P', 
        (char const   )'T',      (char const   )'U',      (char const   )'V',      (char const   )'X', 
        (char const   )':',      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )':',      (char const   )'e',      (char const   )':', 
        (char const   )'f',      (char const   )':',      (char const   )'h',      (char const   )'i', 
        (char const   )'L',      (char const   )'l',      (char const   )'m',      (char const   )':', 
        (char const   )'n',      (char const   )'o',      (char const   )'q',      (char const   )'R', 
        (char const   )'r',      (char const   )'s',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'Z', 
        (char const   )'z',      (char const   )'\000'};
#line 434 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static struct option  const  long_options[50]  = 
#line 434
  {      {"basic-regexp", 0, (int *)((void *)0), 'G'}, 
        {"extended-regexp", 0, (int *)((void *)0), 'E'}, 
        {"fixed-regexp", 0, (int *)((void *)0), 'F'}, 
        {"fixed-strings", 0, (int *)((void *)0), 'F'}, 
        {"perl-regexp", 0, (int *)((void *)0), 'P'}, 
        {"after-context", 1, (int *)((void *)0), 'A'}, 
        {"before-context", 1, (int *)((void *)0), 'B'}, 
        {"binary-files", 1, (int *)((void *)0), 128}, 
        {"byte-offset", 0, (int *)((void *)0), 'b'}, 
        {"context", 1, (int *)((void *)0), 'C'}, 
        {"color", 2, (int *)((void *)0), 129}, 
        {"colour", 2, (int *)((void *)0), 129}, 
        {"count", 0, (int *)((void *)0), 'c'}, 
        {"devices", 1, (int *)((void *)0), 'D'}, 
        {"directories", 1, (int *)((void *)0), 'd'}, 
        {"exclude", 1, (int *)((void *)0), 131}, 
        {"exclude-from", 1, (int *)((void *)0), 132}, 
        {"exclude-dir", 1, (int *)((void *)0), 130}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"files-with-matches", 0, (int *)((void *)0), 'l'}, 
        {"files-without-match", 0, (int *)((void *)0), 'L'}, 
        {"group-separator", 1, (int *)((void *)0), 133}, 
        {"help", 0, & show_help, 1}, 
        {"include", 1, (int *)((void *)0), 134}, 
        {"ignore-case", 0, (int *)((void *)0), 'i'}, 
        {"initial-tab", 0, (int *)((void *)0), 'T'}, 
        {"label", 1, (int *)((void *)0), 136}, 
        {"line-buffered", 0, (int *)((void *)0), 135}, 
        {"line-number", 0, (int *)((void *)0), 'n'}, 
        {"line-regexp", 0, (int *)((void *)0), 'x'}, 
        {"max-count", 1, (int *)((void *)0), 'm'}, 
        {"no-filename", 0, (int *)((void *)0), 'h'}, 
        {"no-group-separator", 0, (int *)((void *)0), 133}, 
        {"no-messages", 0, (int *)((void *)0), 's'}, 
        {"null", 0, (int *)((void *)0), 'Z'}, 
        {"null-data", 0, (int *)((void *)0), 'z'}, 
        {"only-matching", 0, (int *)((void *)0), 'o'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"recursive", 0, (int *)((void *)0), 'r'}, 
        {"dereference-recursive", 0, (int *)((void *)0), 'R'}, 
        {"regexp", 1, (int *)((void *)0), 'e'}, 
        {"invert-match", 0, (int *)((void *)0), 'v'}, 
        {"silent", 0, (int *)((void *)0), 'q'}, 
        {"text", 0, (int *)((void *)0), 'a'}, 
        {"binary", 0, (int *)((void *)0), 'U'}, 
        {"unix-byte-offsets", 0, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"with-filename", 0, (int *)((void *)0), 'H'}, 
        {"word-regexp", 0, (int *)((void *)0), 'w'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 497 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *filename  ;
#line 499 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool omit_dot_slash  ;
#line 500 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool errseen  ;
#line 504 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool encoding_error_output  ;
#line 514 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   * const  directories_args[4]  = {      (char const   */* const  */)"read",      (char const   */* const  */)"recurse",      (char const   */* const  */)"skip",      (char const   */* const  */)((void *)0)};
#line 518 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static enum directories_type  const  directories_types[3]  = {      (enum directories_type  const  )2,      (enum directories_type  const  )3,      (enum directories_type  const  )4};
#line 524 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static enum directories_type directories  =    (enum directories_type )2;
#line 527 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int fts_options  =    793;
#line 530 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static enum __anonenum_devices_473526324 devices  =    (enum __anonenum_devices_473526324 )0;
#line 537
static _Bool grepfile(int dirdesc , char const   *name , _Bool follow , _Bool command_line ) ;
#line 538
static _Bool grepdesc(int desc , _Bool command_line ) ;
#line 540 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool is_device_mode(mode_t m ) 
{ 
  int tmp ;

  {
#line 543
  if ((m & 61440U) == 8192U) {
#line 543
    tmp = 1;
  } else
#line 543
  if ((m & 61440U) == 24576U) {
#line 543
    tmp = 1;
  } else
#line 543
  if ((m & 61440U) == 49152U) {
#line 543
    tmp = 1;
  } else
#line 543
  if ((m & 61440U) == 4096U) {
#line 543
    tmp = 1;
  } else {
#line 543
    tmp = 0;
  }
#line 543
  return ((_Bool )tmp);
}
}
#line 546 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool skip_devices(_Bool command_line ) 
{ 
  int tmp ;

  {
#line 549
  if ((unsigned int )devices == 2U) {
#line 549
    tmp = 1;
  } else
#line 549
  if (((unsigned int )devices == 0U) & ! command_line) {
#line 549
    tmp = 1;
  } else {
#line 549
    tmp = 0;
  }
#line 549
  return ((_Bool )tmp);
}
}
#line 555 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool usable_st_size(struct stat  const  *st ) 
{ 
  int tmp ;

  {
#line 558
  if ((st->st_mode & 61440U) == 32768U) {
#line 558
    tmp = 1;
  } else
#line 558
  if (st->st_mode - st->st_mode) {
#line 558
    tmp = 1;
  } else {
#line 558
    tmp = 0;
  }
#line 558
  return ((_Bool )tmp);
}
}
#line 571 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool seek_failed  ;
#line 572 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool seek_data_failed  ;
#line 578 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static size_t (*execute)(void * , char const   * , size_t  , size_t * , char const   * )  ;
#line 579 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void *compiled_pattern  ;
#line 581 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *input_filename(void) 
{ 
  char *tmp ;

  {
#line 584
  if (! filename) {
    {
#line 585
    tmp = gettext("(standard input)");
#line 585
    filename = (char const   *)tmp;
    }
  }
#line 586
  return (filename);
}
}
#line 590 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void suppressible_error(int errnum ) 
{ 
  char const   *tmp ;

  {
#line 593
  if (! suppress_errors) {
    {
#line 594
    tmp = input_filename();
#line 594
    error(0, errnum, "%s", tmp);
    }
  }
#line 595
  errseen = (_Bool)1;
#line 596
  return;
}
}
#line 600 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void clean_up_stdout(void) 
{ 


  {
#line 603
  if (! stdout_errno) {
    {
#line 604
    close_stdout();
    }
  }
#line 605
  return;
}
}
#line 635 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static uword unibyte_mask  ;
#line 637 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void initialize_unibyte_mask(void) 
{ 
  unsigned char mask ;
  int ms1b ;
  int i ;
  uword uword_max ;

  {
#line 644
  mask = (unsigned char)0;
#line 645
  ms1b = 1;
#line 646
  i = 1;
  {
#line 646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 646
    if (! (i <= 255)) {
#line 646
      goto while_break;
    }
#line 647
    if (((int )localeinfo.sbclen[i] != 1) & ! ((int )mask & i)) {
      {
#line 649
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 649
        if (! (ms1b * 2 <= i)) {
#line 649
          goto while_break___0;
        }
#line 650
        ms1b *= 2;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 651
      mask = (unsigned char )((int )mask | ms1b);
    }
#line 646
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  uword_max = (uword )-1;
#line 658
  unibyte_mask = (uword_max / 255UL) * (uword )mask;
#line 659
  return;
}
}
#line 664 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   * __attribute__((__pure__)) skip_easy_bytes(char const   *buf ) 
{ 
  char const   *p ;
  uword const   *s ;
  unsigned char tmp ;
  char const   *val_ ;
  unsigned char tmp___0 ;

  {
#line 673
  p = buf;
  {
#line 673
  while (1) {
    while_continue: /* CIL Label */ ;
#line 673
    if (! ((uintptr_t )p % sizeof(uword ) != 0UL)) {
#line 673
      goto while_break;
    }
    {
#line 674
    tmp = to_uchar((char )*p);
    }
#line 674
    if ((unsigned long )tmp & unibyte_mask) {
#line 675
      return ((char const   */* __attribute__((__pure__)) */)p);
    }
#line 673
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 676
  val_ = p;
#line 676
  s = (uword const   *)val_;
  {
#line 676
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 676
    if (! (! (*s & (unsigned long const   )unibyte_mask))) {
#line 676
      goto while_break___0;
    }
#line 677
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 676
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 678
  p = (char const   *)s;
  {
#line 678
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 678
    tmp___0 = to_uchar((char )*p);
    }
#line 678
    if ((unsigned long )tmp___0 & unibyte_mask) {
#line 678
      goto while_break___1;
    }
#line 679
    goto __Cont___0;
    __Cont___0: /* CIL Label */ 
#line 678
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 680
  return ((char const   */* __attribute__((__pure__)) */)p);
}
}
#line 686 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool buf_has_encoding_errors(char *buf , size_t size ) 
{ 
  mbstate_t mbs ;
  size_t clen ;
  char const   *p ;
  char const   * __attribute__((__pure__)) tmp ;

  {
#line 689
  if (! unibyte_mask) {
#line 690
    return ((_Bool)0);
  }
#line 692
  mbs.__count = 0;
#line 692
  mbs.__value.__wch = 0U;
#line 695
  *(buf + size) = (char)-1;
#line 696
  p = (char const   *)buf;
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 696
    tmp = skip_easy_bytes(p);
#line 696
    p = (char const   *)tmp;
    }
#line 696
    if (! ((unsigned long )p < (unsigned long )(buf + size))) {
#line 696
      goto while_break;
    }
    {
#line 698
    clen = rpl_mbrlen(p, (size_t )((buf + size) - (char *)p), & mbs);
    }
#line 699
    if (0xfffffffffffffffeUL <= clen) {
#line 700
      return ((_Bool)1);
    }
#line 696
    p += clen;
  }
  while_break: /* CIL Label */ ;
  }
#line 703
  return ((_Bool)0);
}
}
#line 710 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool buf_has_nulls(char *buf , size_t size ) 
{ 
  size_t tmp ;

  {
  {
#line 713
  *(buf + size) = (char)0;
#line 714
  tmp = strlen((char const   *)buf);
  }
#line 714
  return ((_Bool )(tmp != size));
}
}
#line 720 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool file_must_have_nulls(size_t size , int fd , struct stat  const  *st ) 
{ 
  off_t cur ;
  off_t hole_start ;
  __off_t tmp ;
  int *tmp___0 ;
  __off_t tmp___1 ;
  _Bool tmp___2 ;

  {
#line 724
  if (! seek_failed) {
    {
#line 724
    tmp___2 = usable_st_size(st);
    }
#line 724
    if (tmp___2) {
#line 724
      if (size < (size_t )st->st_size) {
#line 727
        cur = (off_t )size;
#line 728
        if (fd == 0) {
          {
#line 730
          cur = lseek(fd, (__off_t )0, 1);
          }
#line 731
          if (cur < 0L) {
#line 732
            return ((_Bool)0);
          }
        }
        {
#line 736
        tmp = lseek(fd, cur, 4);
#line 736
        hole_start = tmp;
        }
#line 737
        if (0L <= hole_start) {
          {
#line 739
          tmp___1 = lseek(fd, cur, 0);
          }
#line 739
          if (tmp___1 < 0L) {
            {
#line 740
            tmp___0 = __errno_location();
#line 740
            suppressible_error(*tmp___0);
            }
          }
#line 741
          if (hole_start < (off_t )st->st_size) {
#line 742
            return ((_Bool)1);
          }
        }
      }
    }
  }
#line 746
  return ((_Bool)0);
}
}
#line 753 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void context_length_arg(char const   *str , intmax_t *out ) 
{ 
  strtol_error tmp ;

  {
  {
#line 756
  tmp = xstrtoimax(str, (char **)0, 10, out, "");
  }
  {
#line 759
  if ((unsigned int )tmp == 1U) {
#line 759
    goto case_1;
  }
#line 759
  if ((unsigned int )tmp == 0U) {
#line 759
    goto case_1;
  }
#line 763
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 760
  if (0L <= *out) {
#line 761
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
  {
#line 764
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 767
  return;
}
}
#line 771 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int exclude_options(_Bool command_line ) 
{ 
  int tmp ;

  {
#line 774
  if (command_line) {
#line 774
    tmp = 0;
  } else {
#line 774
    tmp = 1 << 30;
  }
#line 774
  return ((1 << 28) | tmp);
}
}
#line 780 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool skipped_file(char const   *name , _Bool command_line , _Bool is_dir ) 
{ 
  struct exclude **pats ;
  _Bool tmp ;
  int tmp___0 ;

  {
#line 784
  if (! is_dir) {
#line 785
    pats = excluded_patterns;
  } else
#line 786
  if ((unsigned int )directories == 4U) {
#line 787
    return ((_Bool)1);
  } else
#line 788
  if (command_line) {
#line 788
    if (omit_dot_slash) {
#line 789
      return ((_Bool)0);
    } else {
#line 791
      pats = excluded_directory_patterns;
    }
  } else {
#line 791
    pats = excluded_directory_patterns;
  }
#line 792
  if (*(pats + command_line)) {
    {
#line 792
    tmp = excluded_file_name((struct exclude  const  *)*(pats + command_line), name);
    }
#line 792
    if (tmp) {
#line 792
      tmp___0 = 1;
    } else {
#line 792
      tmp___0 = 0;
    }
  } else {
#line 792
    tmp___0 = 0;
  }
#line 792
  return ((_Bool )tmp___0);
}
}
#line 799 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char *buffer  ;
#line 800 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static size_t bufalloc  ;
#line 802 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int bufdesc  ;
#line 803 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char *bufbeg  ;
#line 804 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char *buflim  ;
#line 805 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static size_t pagesize  ;
#line 806 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static off_t bufoffset  ;
#line 807 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static off_t after_last_match  ;
#line 810 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool skip_nuls  ;
#line 811 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool skip_empty_lines  ;
#line 812 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static uintmax_t totalnl  ;
#line 823 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static uintmax_t add_count(uintmax_t a , uintmax_t b ) 
{ 
  uintmax_t sum ;

  {
#line 826
  sum = a + b;
#line 827
  if (sum < a) {
    {
#line 828
    exit(1);
    }
  }
#line 829
  return (sum);
}
}
#line 833 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool all_zeros(char const   *buf , size_t size ) 
{ 
  char const   *p ;

  {
#line 836
  p = buf;
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (! ((unsigned long )p < (unsigned long )(buf + size))) {
#line 836
      goto while_break;
    }
#line 837
    if (*p) {
#line 838
      return ((_Bool)0);
    }
#line 836
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  return ((_Bool)1);
}
}
#line 844 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool reset(int fd , struct stat  const  *st ) 
{ 
  __off_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 847
  if ((size_t )(buffer + 1) % pagesize == 0UL) {
#line 847
    buflim = buffer + 1;
  } else {
#line 847
    buflim = (buffer + 1) + (pagesize - (size_t )(buffer + 1) % pagesize);
  }
#line 847
  bufbeg = buflim;
#line 848
  *(bufbeg + -1) = eolbyte;
#line 849
  bufdesc = fd;
#line 850
  if (fd == 0) {
    {
#line 850
    tmp = lseek(fd, (__off_t )0, 1);
#line 850
    bufoffset = tmp;
    }
  } else {
#line 850
    bufoffset = (off_t )0;
  }
#line 851
  seek_failed = (_Bool )(bufoffset < 0L);
#line 854
  seek_data_failed = seek_failed;
#line 856
  if (seek_failed) {
    {
#line 858
    tmp___1 = __errno_location();
    }
#line 858
    if (*tmp___1 != 29) {
      {
#line 860
      tmp___0 = __errno_location();
#line 860
      suppressible_error(*tmp___0);
      }
#line 861
      return ((_Bool)0);
    }
#line 863
    bufoffset = (off_t )0;
  }
#line 865
  return ((_Bool)1);
}
}
#line 872 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool fillbuf(size_t save , struct stat  const  *st ) 
{ 
  size_t fillsize ;
  _Bool cc ;
  char *readbuf ;
  size_t readsize ;
  size_t saved_offset ;
  size_t minsize ;
  size_t newsize ;
  size_t newalloc ;
  char *newbuf ;
  off_t to_be_read ;
  off_t maxsize_off ;
  _Bool tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  off_t data_start ;
  __off_t tmp___2 ;
  int *tmp___3 ;
  _Bool tmp___4 ;

  {
#line 876
  cc = (_Bool)1;
#line 882
  saved_offset = (size_t )((buflim - save) - buffer);
#line 884
  if (pagesize <= (size_t )(((buffer + bufalloc) - sizeof(uword )) - buflim)) {
#line 886
    readbuf = buflim;
#line 887
    bufbeg = buflim - save;
  } else {
#line 891
    minsize = save + pagesize;
#line 897
    newsize = (bufalloc - pagesize) - sizeof(uword );
    {
#line 897
    while (1) {
      while_continue: /* CIL Label */ ;
#line 897
      if (! (newsize < minsize)) {
#line 897
        goto while_break;
      }
#line 900
      if (((0xffffffffffffffffUL - pagesize) - sizeof(uword )) / 2UL < newsize) {
        {
#line 901
        xalloc_die();
        }
      }
#line 897
      newsize *= 2UL;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 908
    tmp = usable_st_size(st);
    }
#line 908
    if (tmp) {
#line 910
      to_be_read = (off_t )(st->st_size - (__off_t const   )bufoffset);
#line 911
      maxsize_off = (off_t )(save + (size_t )to_be_read);
#line 912
      if (0L <= to_be_read) {
#line 912
        if (to_be_read <= maxsize_off) {
#line 912
          if ((size_t )maxsize_off == (size_t )maxsize_off) {
#line 912
            if (minsize <= (size_t )maxsize_off) {
#line 912
              if ((size_t )maxsize_off < newsize) {
#line 916
                newsize = (size_t )maxsize_off;
              }
            }
          }
        }
      }
    }
#line 922
    newalloc = (newsize + pagesize) + sizeof(uword );
#line 924
    if (bufalloc < newalloc) {
      {
#line 924
      bufalloc = newalloc;
#line 924
      tmp___0 = xmalloc(bufalloc);
#line 924
      newbuf = (char *)tmp___0;
      }
    } else {
#line 924
      newbuf = buffer;
    }
#line 925
    if ((size_t )((newbuf + 1) + save) % pagesize == 0UL) {
#line 925
      readbuf = (newbuf + 1) + save;
    } else {
#line 925
      readbuf = ((newbuf + 1) + save) + (pagesize - (size_t )((newbuf + 1) + save) % pagesize);
    }
    {
#line 926
    bufbeg = readbuf - save;
#line 927
    memmove((void *)bufbeg, (void const   *)(buffer + saved_offset), save);
#line 928
    *(bufbeg + -1) = eolbyte;
    }
#line 929
    if ((unsigned long )newbuf != (unsigned long )buffer) {
      {
#line 931
      free((void *)buffer);
#line 932
      buffer = newbuf;
      }
    }
  }
  {
#line 936
  clear_asan_poison();
#line 938
  readsize = (size_t )(((buffer + bufalloc) - sizeof(uword )) - readbuf);
#line 939
  readsize -= readsize % pagesize;
  }
  {
#line 941
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 943
    fillsize = safe_read(bufdesc, (void *)readbuf, readsize);
    }
#line 944
    if (fillsize == 0xffffffffffffffffUL) {
#line 946
      fillsize = (size_t )0;
#line 947
      cc = (_Bool)0;
    }
#line 949
    bufoffset = (off_t )((size_t )bufoffset + fillsize);
#line 951
    if ((fillsize == 0UL) | ! skip_nuls) {
#line 952
      goto while_break___0;
    } else {
      {
#line 951
      tmp___1 = all_zeros((char const   *)readbuf, fillsize);
      }
#line 951
      if (! tmp___1) {
#line 952
        goto while_break___0;
      }
    }
    {
#line 953
    totalnl = add_count(totalnl, fillsize);
    }
#line 955
    if (! seek_data_failed) {
      {
#line 958
      tmp___2 = lseek(bufdesc, bufoffset, 3);
#line 958
      data_start = tmp___2;
      }
#line 959
      if (data_start < 0L) {
        {
#line 959
        tmp___3 = __errno_location();
        }
#line 959
        if (*tmp___3 == 6) {
          {
#line 959
          tmp___4 = usable_st_size(st);
          }
#line 959
          if (tmp___4) {
#line 959
            if (bufoffset < (off_t )st->st_size) {
              {
#line 961
              data_start = lseek(bufdesc, (__off_t )0, 2);
              }
            }
          }
        }
      }
#line 963
      if (data_start < 0L) {
#line 964
        seek_data_failed = (_Bool)1;
      } else {
        {
#line 967
        totalnl = add_count(totalnl, (uintmax_t )(data_start - bufoffset));
#line 968
        bufoffset = data_start;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 973
  buflim = readbuf + fillsize;
#line 978
  memset((void *)buflim, 0, sizeof(uword ));
#line 982
  asan_poison((void const volatile   *)(buflim + sizeof(uword )), (bufalloc - (size_t )(buflim - buffer)) - sizeof(uword ));
  }
#line 985
  return (cc);
}
}
#line 989 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static enum __anonenum_binary_files_601436154 binary_files  ;
#line 997 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static enum __anonenum_list_files_328606374 list_files  ;
#line 1004 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int filename_mask  ;
#line 1005 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool out_quiet  ;
#line 1006 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool out_invert  ;
#line 1007 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int out_file  ;
#line 1008 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool out_line  ;
#line 1009 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool out_byte  ;
#line 1010 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static intmax_t out_before  ;
#line 1011 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static intmax_t out_after  ;
#line 1012 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool count_matches  ;
#line 1013 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool no_filenames  ;
#line 1014 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static intmax_t max_count  ;
#line 1016 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool line_buffered  ;
#line 1017 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char *label  =    (char *)((void *)0);
#line 1021 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static uintmax_t totalcc  ;
#line 1022 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char const   *lastnl  ;
#line 1023 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char *lastout  ;
#line 1026 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static intmax_t outleft  ;
#line 1027 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static intmax_t pending  ;
#line 1029 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool done_on_match  ;
#line 1030 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool exit_on_match  ;
#line 1031 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool dev_null_output  ;
#line 1032 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool binary  ;
#line 1034 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void nlscan(char const   *lim ) 
{ 
  size_t newlines ;
  char const   *beg ;
  void *tmp ;

  {
#line 1037
  newlines = (size_t )0;
#line 1039
  beg = lastnl;
  {
#line 1039
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1039
    if (! ((unsigned long )beg < (unsigned long )lim)) {
#line 1039
      goto while_break;
    }
    {
#line 1041
    tmp = memchr((void const   *)beg, (int )eolbyte, (size_t )(lim - beg));
#line 1041
    beg = (char const   *)tmp;
    }
#line 1042
    if (! beg) {
#line 1043
      goto while_break;
    }
#line 1044
    newlines ++;
#line 1039
    beg ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1046
  totalnl = add_count(totalnl, newlines);
#line 1047
  lastnl = lim;
  }
#line 1048
  return;
}
}
#line 1051 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void print_filename(void) 
{ 
  char const   *tmp ;

  {
  {
#line 1054
  pr_sgr_start_if(filename_color);
#line 1055
  tmp = input_filename();
#line 1055
  fputs_errno(tmp);
#line 1056
  pr_sgr_end_if(filename_color);
  }
#line 1057
  return;
}
}
#line 1060 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void print_sep(char sep ) 
{ 


  {
  {
#line 1063
  pr_sgr_start_if(sep_color);
#line 1064
  putchar_errno((int )sep);
#line 1065
  pr_sgr_end_if(sep_color);
  }
#line 1066
  return;
}
}
#line 1069 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void print_offset(uintmax_t pos , char const   *color ) 
{ 


  {
  {
#line 1072
  pr_sgr_start_if(color);
#line 1073
  printf_errno("%*lu", offset_width, pos);
#line 1074
  pr_sgr_end_if(color);
  }
#line 1075
  return;
}
}
#line 1086 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool print_line_head(char *beg , size_t len , char const   *lim , char sep ) 
{ 
  char ch ;
  _Bool encoding_errors ;
  _Bool tmp ;
  uintmax_t pos ;
  uintmax_t tmp___0 ;

  {
#line 1089
  if ((unsigned int )binary_files != 1U) {
    {
#line 1091
    ch = *(beg + len);
#line 1092
    tmp = buf_has_encoding_errors(beg, len);
#line 1092
    encoding_errors = tmp;
#line 1093
    *(beg + len) = ch;
    }
#line 1094
    if (encoding_errors) {
#line 1096
      encoding_error_output = (_Bool)1;
#line 1097
      return ((_Bool)0);
    }
  }
#line 1101
  if (out_file) {
    {
#line 1103
    print_filename();
    }
#line 1104
    if (filename_mask) {
      {
#line 1105
      print_sep(sep);
      }
    } else {
      {
#line 1107
      putchar_errno(0);
      }
    }
  }
#line 1110
  if (out_line) {
#line 1112
    if ((unsigned long )lastnl < (unsigned long )lim) {
      {
#line 1114
      nlscan((char const   *)beg);
#line 1115
      totalnl = add_count(totalnl, (uintmax_t )1);
#line 1116
      lastnl = lim;
      }
    }
    {
#line 1118
    print_offset(totalnl, line_num_color);
#line 1119
    print_sep(sep);
    }
  }
#line 1122
  if (out_byte) {
    {
#line 1124
    tmp___0 = add_count(totalcc, (uintmax_t )(beg - bufbeg));
#line 1124
    pos = tmp___0;
#line 1125
    print_offset(pos, byte_num_color);
#line 1126
    print_sep(sep);
    }
  }
#line 1129
  if (align_tabs) {
#line 1129
    if ((out_file | (int )out_line) | (int )out_byte) {
#line 1129
      if (len != 0UL) {
        {
#line 1130
        putchar_errno('\t');
        }
      }
    }
  }
#line 1132
  return ((_Bool)1);
}
}
#line 1135 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char *print_line_middle(char *beg , char *lim , char const   *line_color ,
                               char const   *match_color ) 
{ 
  size_t match_size ;
  size_t match_offset ;
  char *cur ;
  char *mid ;
  char *b ;
  char sep ;
  int tmp ;
  _Bool tmp___0 ;

  {
#line 1142
  mid = (char *)((void *)0);
#line 1145
  cur = beg;
  {
#line 1145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1145
    if ((unsigned long )cur < (unsigned long )lim) {
      {
#line 1145
      match_offset = (*execute)(compiled_pattern, (char const   *)beg, (size_t )(lim - beg),
                                & match_size, (char const   *)cur);
      }
#line 1145
      if (! (match_offset != 0xffffffffffffffffUL)) {
#line 1145
        goto while_break;
      }
    } else {
#line 1145
      goto while_break;
    }
#line 1151
    b = beg + match_offset;
#line 1154
    if ((unsigned long )b == (unsigned long )lim) {
#line 1155
      goto while_break;
    }
#line 1158
    if (match_size == 0UL) {
#line 1162
      match_size = (size_t )1;
#line 1163
      if (! mid) {
#line 1164
        mid = cur;
      }
    } else {
#line 1170
      if (only_matching) {
#line 1172
        if (out_invert) {
#line 1172
          tmp = 45;
        } else {
#line 1172
          tmp = 58;
        }
        {
#line 1172
        sep = (char )tmp;
#line 1173
        tmp___0 = print_line_head(b, match_size, (char const   *)lim, sep);
        }
#line 1173
        if (! tmp___0) {
#line 1174
          return ((char *)((void *)0));
        }
      } else {
        {
#line 1178
        pr_sgr_start(line_color);
        }
#line 1179
        if (mid) {
#line 1181
          cur = mid;
#line 1182
          mid = (char *)((void *)0);
        }
        {
#line 1184
        fwrite_errno((void const   *)cur, (size_t )1, (size_t )(b - cur));
        }
      }
      {
#line 1187
      pr_sgr_start_if(match_color);
#line 1188
      fwrite_errno((void const   *)b, (size_t )1, match_size);
#line 1189
      pr_sgr_end_if(match_color);
      }
#line 1190
      if (only_matching) {
        {
#line 1191
        putchar_errno((int )eolbyte);
        }
      }
    }
#line 1145
    cur = b + match_size;
  }
  while_break: /* CIL Label */ ;
  }
#line 1195
  if (only_matching) {
#line 1196
    cur = lim;
  } else
#line 1197
  if (mid) {
#line 1198
    cur = mid;
  }
#line 1200
  return (cur);
}
}
#line 1203 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char *print_line_tail(char *beg , char const   *lim , char const   *line_color ) 
{ 
  size_t eol_size ;
  size_t tail_size ;
  int tmp ;
  int tmp___0 ;

  {
#line 1209
  if ((unsigned long )lim > (unsigned long )beg) {
#line 1209
    if ((int const   )*(lim + -1) == (int const   )eolbyte) {
#line 1209
      tmp = 1;
    } else {
#line 1209
      tmp = 0;
    }
  } else {
#line 1209
    tmp = 0;
  }
#line 1209
  eol_size = (size_t )tmp;
#line 1210
  if ((unsigned long )(lim - eol_size) > (unsigned long )beg) {
#line 1210
    if ((int const   )*(lim + - (1UL + eol_size)) == 13) {
#line 1210
      tmp___0 = 1;
    } else {
#line 1210
      tmp___0 = 0;
    }
  } else {
#line 1210
    tmp___0 = 0;
  }
#line 1210
  eol_size += (size_t )tmp___0;
#line 1211
  tail_size = (size_t )((lim - eol_size) - (char const   *)beg);
#line 1213
  if (tail_size > 0UL) {
    {
#line 1215
    pr_sgr_start(line_color);
#line 1216
    fwrite_errno((void const   *)beg, (size_t )1, tail_size);
#line 1217
    beg += tail_size;
#line 1218
    pr_sgr_end(line_color);
    }
  }
#line 1221
  return (beg);
}
}
#line 1224 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void prline(char *beg , char *lim , char sep ) 
{ 
  _Bool matching ;
  char const   *line_color ;
  char const   *match_color ;
  _Bool tmp ;
  int tmp___1 ;

  {
#line 1231
  if (! only_matching) {
    {
#line 1232
    tmp = print_line_head(beg, (size_t )((lim - beg) - 1L), (char const   *)lim, sep);
    }
#line 1232
    if (! tmp) {
#line 1233
      return;
    }
  }
#line 1235
  matching = (_Bool )(((int )sep == 58) ^ (int )out_invert);
#line 1237
  if (color_option) {
#line 1239
    if (out_invert) {
#line 1239
      if (color_option < 0) {
#line 1239
        tmp___1 = 1;
      } else {
#line 1239
        tmp___1 = 0;
      }
    } else {
#line 1239
      tmp___1 = 0;
    }
#line 1239
    if (((int )sep == 58) ^ tmp___1) {
#line 1239
      line_color = selected_line_color;
    } else {
#line 1239
      line_color = context_line_color;
    }
#line 1242
    if ((int )sep == 58) {
#line 1242
      match_color = selected_match_color;
    } else {
#line 1242
      match_color = context_match_color;
    }
  } else {
#line 1246
    match_color = (char const   *)((void *)0);
#line 1246
    line_color = match_color;
  }
#line 1248
  if (only_matching) {
#line 1248
    if (matching) {
#line 1248
      goto _L___1;
    } else {
#line 1248
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1248
  if (color_option) {
#line 1248
    if (*line_color) {
#line 1248
      goto _L___1;
    } else
#line 1248
    if (*match_color) {
      _L___1: /* CIL Label */ 
#line 1252
      if (matching) {
#line 1252
        if (only_matching) {
#line 1252
          goto _L;
        } else
#line 1252
        if (*match_color) {
          _L: /* CIL Label */ 
          {
#line 1254
          beg = print_line_middle(beg, lim, line_color, match_color);
          }
#line 1255
          if (! beg) {
#line 1256
            return;
          }
        }
      }
#line 1259
      if (! only_matching) {
#line 1259
        if (*line_color) {
          {
#line 1263
          beg = print_line_tail(beg, (char const   *)lim, line_color);
          }
        }
      }
    }
  }
#line 1267
  if (! only_matching) {
#line 1267
    if ((unsigned long )lim > (unsigned long )beg) {
      {
#line 1268
      fwrite_errno((void const   *)beg, (size_t )1, (size_t )(lim - beg));
      }
    }
  }
#line 1270
  if (line_buffered) {
    {
#line 1271
    fflush_errno();
    }
  }
#line 1273
  if (stdout_errno) {
    {
#line 1274
    exit(1);
    }
  }
#line 1276
  lastout = lim;
#line 1277
  return;
}
}
#line 1280 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void prpending(char const   *lim ) 
{ 
  char *nl ;
  void *tmp ;

  {
#line 1283
  if (! lastout) {
#line 1284
    lastout = bufbeg;
  }
  {
#line 1285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1285
    if (0L < pending) {
#line 1285
      if (! ((unsigned long )lastout < (unsigned long )lim)) {
#line 1285
        goto while_break;
      }
    } else {
#line 1285
      goto while_break;
    }
    {
#line 1287
    tmp = memchr((void const   *)lastout, (int )eolbyte, (size_t )(lim - (char const   *)lastout));
#line 1287
    nl = (char *)tmp;
#line 1288
    prline(lastout, nl + 1, (char)45);
#line 1285
    pending --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1290
  return;
}
}
#line 1296 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool used  ;
#line 1293 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void prtext(char *beg , char *lim ) 
{ 
  char eol ;
  char *p ;
  char const   *bp ;
  char *tmp ;
  intmax_t i ;
  char *nl ;
  void *tmp___0 ;
  intmax_t n ;
  char *nl___0 ;
  void *tmp___1 ;
  intmax_t tmp___2 ;

  {
#line 1297
  eol = eolbyte;
#line 1299
  if (! out_quiet) {
#line 1299
    if (pending > 0L) {
      {
#line 1300
      prpending((char const   *)beg);
      }
    }
  }
#line 1302
  p = beg;
#line 1304
  if (! out_quiet) {
#line 1307
    if (lastout) {
#line 1307
      tmp = lastout;
    } else {
#line 1307
      tmp = bufbeg;
    }
#line 1307
    bp = (char const   *)tmp;
#line 1309
    i = (intmax_t )0;
    {
#line 1309
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1309
      if (! (i < out_before)) {
#line 1309
        goto while_break;
      }
#line 1310
      if ((unsigned long )p > (unsigned long )bp) {
        {
#line 1311
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1312
          p --;
#line 1311
          if (! ((int )*(p + -1) != (int )eol)) {
#line 1311
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1309
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1317
    if (0L <= out_before) {
#line 1317
      goto _L;
    } else
#line 1317
    if (0L <= out_after) {
      _L: /* CIL Label */ 
#line 1317
      if (used) {
#line 1317
        if ((unsigned long )p != (unsigned long )lastout) {
#line 1317
          if (group_separator) {
            {
#line 1320
            pr_sgr_start_if(sep_color);
#line 1321
            fputs_errno(group_separator);
#line 1322
            pr_sgr_end_if(sep_color);
#line 1323
            putchar_errno('\n');
            }
          }
        }
      }
    }
    {
#line 1326
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1326
      if (! ((unsigned long )p < (unsigned long )beg)) {
#line 1326
        goto while_break___1;
      }
      {
#line 1328
      tmp___0 = memchr((void const   *)p, (int )eol, (size_t )(beg - p));
#line 1328
      nl = (char *)tmp___0;
#line 1329
      nl ++;
#line 1330
      prline(p, nl, (char)45);
#line 1331
      p = nl;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1336
  if (out_invert) {
#line 1339
    n = (intmax_t )0;
    {
#line 1339
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1339
      if ((unsigned long )p < (unsigned long )lim) {
#line 1339
        if (! (n < outleft)) {
#line 1339
          goto while_break___2;
        }
      } else {
#line 1339
        goto while_break___2;
      }
      {
#line 1341
      tmp___1 = memchr((void const   *)p, (int )eol, (size_t )(lim - p));
#line 1341
      nl___0 = (char *)tmp___1;
#line 1342
      nl___0 ++;
      }
#line 1343
      if (! out_quiet) {
        {
#line 1344
        prline(p, nl___0, (char)58);
        }
      }
#line 1345
      p = nl___0;
#line 1339
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 1351
    if (! out_quiet) {
      {
#line 1352
      prline(beg, lim, (char)58);
      }
    }
#line 1353
    n = (intmax_t )1;
#line 1354
    p = lim;
  }
#line 1357
  after_last_match = bufoffset - (buflim - p);
#line 1358
  if (out_quiet) {
#line 1358
    pending = (intmax_t )0;
  } else {
#line 1358
    if (0L > out_after) {
#line 1358
      tmp___2 = (intmax_t )0;
    } else {
#line 1358
      tmp___2 = out_after;
    }
#line 1358
    pending = tmp___2;
  }
#line 1359
  used = (_Bool)1;
#line 1360
  outleft -= n;
#line 1361
  return;
}
}
#line 1367 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void zap_nuls(char *p , char *lim , char eol ) 
{ 
  size_t tmp ;
  char *tmp___0 ;

  {
#line 1370
  if (eol) {
    {
#line 1371
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1373
      *lim = (char )'\000';
#line 1374
      tmp = strlen((char const   *)p);
#line 1374
      p += tmp;
#line 1375
      *lim = eol;
      }
#line 1376
      if ((unsigned long )p == (unsigned long )lim) {
#line 1377
        goto while_break;
      }
      {
#line 1378
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1379
        tmp___0 = p;
#line 1379
        p ++;
#line 1379
        *tmp___0 = eol;
#line 1378
        if (! (! *p)) {
#line 1378
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1382
  return;
}
}
#line 1387 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static intmax_t grepbuf(char *beg , char const   *lim ) 
{ 
  intmax_t outleft0 ;
  char *endp ;
  char *p ;
  size_t match_size ;
  size_t match_offset ;
  size_t tmp ;
  char *b ;
  char *prbeg ;
  char *tmp___0 ;
  char *prend ;
  char *tmp___1 ;
  int volatile   tmp___2 ;

  {
#line 1390
  outleft0 = outleft;
#line 1393
  p = beg;
  {
#line 1393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1393
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 1393
      goto while_break;
    }
    {
#line 1396
    tmp = (*execute)(compiled_pattern, (char const   *)p, (size_t )(lim - (char const   *)p),
                     & match_size, (char const   *)((void *)0));
#line 1396
    match_offset = tmp;
    }
#line 1398
    if (match_offset == 0xffffffffffffffffUL) {
#line 1400
      if (! out_invert) {
#line 1401
        goto while_break;
      }
#line 1402
      match_offset = (size_t )(lim - (char const   *)p);
#line 1403
      match_size = (size_t )0;
    }
#line 1405
    b = p + match_offset;
#line 1406
    endp = b + match_size;
#line 1408
    if (! out_invert) {
#line 1408
      if ((unsigned long )b == (unsigned long )lim) {
#line 1409
        goto while_break;
      }
    }
#line 1410
    if (! out_invert) {
#line 1410
      goto _L___0;
    } else
#line 1410
    if ((unsigned long )p < (unsigned long )b) {
      _L___0: /* CIL Label */ 
#line 1412
      if (out_invert) {
#line 1412
        tmp___0 = p;
      } else {
#line 1412
        tmp___0 = b;
      }
#line 1412
      prbeg = tmp___0;
#line 1413
      if (out_invert) {
#line 1413
        tmp___1 = b;
      } else {
#line 1413
        tmp___1 = endp;
      }
      {
#line 1413
      prend = tmp___1;
#line 1414
      prtext(prbeg, prend);
      }
#line 1415
      if (! outleft) {
#line 1415
        goto _L;
      } else
#line 1415
      if (done_on_match) {
        _L: /* CIL Label */ 
#line 1417
        if (exit_on_match) {
#line 1418
          if (errseen) {
#line 1418
            tmp___2 = exit_failure;
          } else {
#line 1418
            tmp___2 = (int volatile   )0;
          }
          {
#line 1418
          exit((int )tmp___2);
          }
        }
#line 1419
        goto while_break;
      }
    }
#line 1393
    p = endp;
  }
  while_break: /* CIL Label */ ;
  }
#line 1424
  return (outleft0 - outleft);
}
}
#line 1429 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static intmax_t grep(int fd , struct stat  const  *st , _Bool *ineof ) 
{ 
  intmax_t nlines ;
  intmax_t i ;
  size_t residue ;
  size_t save ;
  char oldc ;
  char *beg ;
  char *lim ;
  char eol ;
  char nul_zapper ;
  _Bool done_on_match_0 ;
  _Bool out_quiet_0 ;
  intmax_t nlines_first_null ;
  _Bool tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  _Bool tmp___2 ;
  uintmax_t num ;
  unsigned long tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  _Bool firsttime ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  void *tmp___9 ;
  intmax_t tmp___10 ;
  intmax_t tmp___11 ;
  int *tmp___12 ;
  _Bool tmp___13 ;
  char *tmp___14 ;
  intmax_t tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;

  {
  {
#line 1437
  eol = eolbyte;
#line 1438
  nul_zapper = (char )'\000';
#line 1439
  done_on_match_0 = done_on_match;
#line 1440
  out_quiet_0 = out_quiet;
#line 1445
  nlines_first_null = (intmax_t )-1;
#line 1447
  tmp = reset(fd, st);
  }
#line 1447
  if (! tmp) {
#line 1448
    return ((intmax_t )0);
  }
#line 1450
  totalcc = (uintmax_t )0;
#line 1451
  lastout = (char *)0;
#line 1452
  totalnl = (uintmax_t )0;
#line 1453
  outleft = max_count;
#line 1454
  after_last_match = (off_t )0;
#line 1455
  pending = (intmax_t )0;
#line 1456
  if (skip_empty_lines) {
#line 1456
    if (! eol) {
#line 1456
      tmp___0 = 1;
    } else {
#line 1456
      tmp___0 = 0;
    }
  } else {
#line 1456
    tmp___0 = 0;
  }
  {
#line 1456
  skip_nuls = (_Bool )tmp___0;
#line 1457
  encoding_error_output = (_Bool)0;
#line 1459
  nlines = (intmax_t )0;
#line 1460
  residue = (size_t )0;
#line 1461
  save = (size_t )0;
#line 1463
  tmp___2 = fillbuf(save, st);
  }
#line 1463
  if (! tmp___2) {
    {
#line 1465
    tmp___1 = __errno_location();
#line 1465
    suppressible_error(*tmp___1);
    }
#line 1466
    return ((intmax_t )0);
  }
#line 1469
  offset_width = 0;
#line 1470
  if (align_tabs) {
    {
#line 1473
    tmp___5 = usable_st_size(st);
    }
#line 1473
    if (tmp___5) {
#line 1473
      tmp___4 = (unsigned long )st->st_size;
    } else {
#line 1473
      tmp___4 = 0xffffffffffffffffUL;
    }
#line 1473
    num = tmp___4;
#line 1474
    if (out_line) {
#line 1474
      if (num < 0xffffffffffffffffUL) {
#line 1474
        tmp___6 = 1;
      } else {
#line 1474
        tmp___6 = 0;
      }
    } else {
#line 1474
      tmp___6 = 0;
    }
#line 1474
    num += (uintmax_t )tmp___6;
    {
#line 1475
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1476
      offset_width ++;
#line 1475
      num /= 10UL;
#line 1475
      if (! (num != 0UL)) {
#line 1475
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1480
  firsttime = (_Bool)1;
  {
#line 1480
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1482
    if (nlines_first_null < 0L) {
#line 1482
      if (eol) {
#line 1482
        if ((unsigned int )binary_files != 1U) {
          {
#line 1482
          tmp___7 = buf_has_nulls(bufbeg, (size_t )(buflim - bufbeg));
          }
#line 1482
          if (tmp___7) {
#line 1482
            goto _L;
          } else
#line 1482
          if (firsttime) {
            {
#line 1482
            tmp___8 = file_must_have_nulls((size_t )(buflim - bufbeg), fd, st);
            }
#line 1482
            if (tmp___8) {
              _L: /* CIL Label */ 
#line 1486
              if ((unsigned int )binary_files == 2U) {
#line 1487
                return ((intmax_t )0);
              }
#line 1488
              if (! count_matches) {
#line 1489
                out_quiet = (_Bool)1;
#line 1489
                done_on_match = out_quiet;
              }
#line 1490
              nlines_first_null = nlines;
#line 1491
              nul_zapper = eol;
#line 1492
              skip_nuls = skip_empty_lines;
            }
          }
        }
      }
    }
#line 1495
    lastnl = (char const   *)bufbeg;
#line 1496
    if (lastout) {
#line 1497
      lastout = bufbeg;
    }
#line 1499
    beg = bufbeg + save;
#line 1502
    if ((unsigned long )beg == (unsigned long )buflim) {
#line 1504
      *ineof = (_Bool)1;
#line 1505
      goto while_break___0;
    }
    {
#line 1508
    zap_nuls(beg, buflim, nul_zapper);
#line 1512
    oldc = *(beg + -1);
#line 1513
    *(beg + -1) = eol;
#line 1516
    tmp___9 = memrchr((void const   *)(beg - 1), (int )eol, (size_t )((buflim - beg) + 1L));
#line 1516
    lim = (char *)tmp___9;
#line 1517
    lim ++;
#line 1518
    *(beg + -1) = oldc;
    }
#line 1519
    if ((unsigned long )lim == (unsigned long )beg) {
#line 1520
      lim = beg - residue;
    }
#line 1521
    beg -= residue;
#line 1522
    residue = (size_t )(buflim - lim);
#line 1524
    if ((unsigned long )beg < (unsigned long )lim) {
#line 1526
      if (outleft) {
        {
#line 1527
        tmp___10 = grepbuf(beg, (char const   *)lim);
#line 1527
        nlines += tmp___10;
        }
      }
#line 1528
      if (pending) {
        {
#line 1529
        prpending((char const   *)lim);
        }
      }
#line 1530
      if (! outleft) {
#line 1530
        if (! pending) {
#line 1532
          goto finish_grep;
        } else {
#line 1530
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1530
      if (done_on_match) {
#line 1530
        if (0L > nlines_first_null) {
#line 1530
          tmp___11 = (intmax_t )0;
        } else {
#line 1530
          tmp___11 = nlines_first_null;
        }
#line 1530
        if (tmp___11 < nlines) {
#line 1532
          goto finish_grep;
        }
      }
    }
#line 1538
    i = (intmax_t )0;
#line 1539
    beg = lim;
    {
#line 1540
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1540
      if (i < out_before) {
#line 1540
        if ((unsigned long )beg > (unsigned long )bufbeg) {
#line 1540
          if (! ((unsigned long )beg != (unsigned long )lastout)) {
#line 1540
            goto while_break___1;
          }
        } else {
#line 1540
          goto while_break___1;
        }
      } else {
#line 1540
        goto while_break___1;
      }
#line 1542
      i ++;
      {
#line 1543
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1544
        beg --;
#line 1543
        if (! ((int )*(beg + -1) != (int )eol)) {
#line 1543
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1549
    if ((unsigned long )beg != (unsigned long )lastout) {
#line 1550
      lastout = (char *)0;
    }
#line 1553
    save = (size_t )((lim + residue) - beg);
#line 1554
    if (out_byte) {
      {
#line 1555
      totalcc = add_count(totalcc, (size_t )(buflim - bufbeg) - save);
      }
    }
#line 1556
    if (out_line) {
      {
#line 1557
      nlscan((char const   *)beg);
      }
    }
    {
#line 1558
    tmp___13 = fillbuf(save, st);
    }
#line 1558
    if (! tmp___13) {
      {
#line 1560
      tmp___12 = __errno_location();
#line 1560
      suppressible_error(*tmp___12);
      }
#line 1561
      goto finish_grep;
    }
#line 1480
    firsttime = (_Bool)0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1564
  if (residue) {
#line 1566
    tmp___14 = buflim;
#line 1566
    buflim ++;
#line 1566
    *tmp___14 = eol;
#line 1567
    if (outleft) {
      {
#line 1568
      tmp___15 = grepbuf((bufbeg + save) - residue, (char const   *)buflim);
#line 1568
      nlines += tmp___15;
      }
    }
#line 1569
    if (pending) {
      {
#line 1570
      prpending((char const   *)buflim);
      }
    }
  }
  finish_grep: 
#line 1574
  done_on_match = done_on_match_0;
#line 1575
  out_quiet = out_quiet_0;
#line 1576
  if (! out_quiet) {
#line 1576
    if (encoding_error_output) {
#line 1576
      goto _L___1;
    } else
#line 1576
    if (0L <= nlines_first_null) {
#line 1576
      if (nlines_first_null < nlines) {
        _L___1: /* CIL Label */ 
        {
#line 1579
        tmp___16 = input_filename();
#line 1579
        tmp___17 = gettext("Binary file %s matches\n");
#line 1579
        printf_errno((char const   *)tmp___17, tmp___16);
        }
#line 1580
        if (line_buffered) {
          {
#line 1581
          fflush_errno();
          }
        }
      }
    }
  }
#line 1583
  return (nlines);
}
}
#line 1586 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool grepdirent(FTS *fts , FTSENT *ent , _Bool command_line ) 
{ 
  _Bool follow ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct stat *st ;
  struct stat st1 ;
  int flag ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;

  {
#line 1590
  command_line = (_Bool )((int )command_line & (ent->fts_level == 0L));
#line 1592
  if ((int )ent->fts_info == 6) {
#line 1594
    if ((unsigned int )directories == 3U) {
#line 1594
      if (command_line) {
#line 1595
        out_file &= ~ (2 * ! no_filenames);
      }
    }
#line 1596
    return ((_Bool)1);
  }
#line 1599
  if (! command_line) {
#line 1599
    if ((int )ent->fts_info == 1) {
#line 1599
      tmp = 1;
    } else
#line 1599
    if ((int )ent->fts_info == 2) {
#line 1599
      tmp = 1;
    } else
#line 1599
    if ((int )ent->fts_info == 4) {
#line 1599
      tmp = 1;
    } else {
#line 1599
      tmp = 0;
    }
    {
#line 1599
    tmp___0 = skipped_file((char const   *)(ent->fts_name), (_Bool)0, (_Bool )tmp);
    }
#line 1599
    if (tmp___0) {
      {
#line 1604
      fts_set(fts, ent, 4);
      }
#line 1605
      return ((_Bool)1);
    }
  }
#line 1608
  filename = (char const   *)ent->fts_path;
#line 1609
  if (omit_dot_slash) {
#line 1609
    if (*(filename + 1)) {
#line 1610
      filename += 2;
    }
  }
#line 1611
  if (fts->fts_options & 2) {
#line 1611
    tmp___1 = 1;
  } else
#line 1611
  if (fts->fts_options & 1) {
#line 1611
    if (command_line) {
#line 1611
      tmp___1 = 1;
    } else {
#line 1611
      tmp___1 = 0;
    }
  } else {
#line 1611
    tmp___1 = 0;
  }
#line 1611
  follow = (_Bool )tmp___1;
  {
#line 1616
  if ((int )ent->fts_info == 1) {
#line 1616
    goto case_1;
  }
#line 1625
  if ((int )ent->fts_info == 2) {
#line 1625
    goto case_2;
  }
#line 1633
  if ((int )ent->fts_info == 10) {
#line 1633
    goto case_10;
  }
#line 1633
  if ((int )ent->fts_info == 7) {
#line 1633
    goto case_10;
  }
#line 1633
  if ((int )ent->fts_info == 4) {
#line 1633
    goto case_10;
  }
#line 1638
  if ((int )ent->fts_info == 11) {
#line 1638
    goto case_11;
  }
#line 1638
  if ((int )ent->fts_info == 3) {
#line 1638
    goto case_11;
  }
#line 1662
  if ((int )ent->fts_info == 13) {
#line 1662
    goto case_13;
  }
#line 1662
  if ((int )ent->fts_info == 8) {
#line 1662
    goto case_13;
  }
#line 1666
  if ((int )ent->fts_info == 14) {
#line 1666
    goto case_14;
  }
#line 1666
  if ((int )ent->fts_info == 12) {
#line 1666
    goto case_14;
  }
#line 1669
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1617
  if ((unsigned int )directories == 3U) {
#line 1619
    out_file |= 2 * ! no_filenames;
#line 1620
    return ((_Bool)1);
  }
  {
#line 1622
  fts_set(fts, ent, 4);
  }
#line 1623
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1626
  if (! suppress_errors) {
    {
#line 1627
    tmp___2 = gettext("recursive directory loop");
#line 1627
    tmp___3 = gettext("warning: %s: %s");
#line 1627
    error(0, 0, (char const   *)tmp___3, filename, tmp___2);
    }
  }
#line 1629
  return ((_Bool)1);
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 1634
  suppressible_error(ent->fts_errno);
  }
#line 1635
  return ((_Bool)1);
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1639
  tmp___8 = skip_devices(command_line);
  }
#line 1639
  if (tmp___8) {
#line 1641
    st = ent->fts_statp;
#line 1643
    if (! st->st_mode) {
#line 1648
      if (follow) {
#line 1648
        tmp___4 = 0;
      } else {
#line 1648
        tmp___4 = 256;
      }
      {
#line 1648
      flag = tmp___4;
#line 1649
      tmp___6 = fstatat(fts->fts_cwd_fd, (char const   */* __restrict  */)ent->fts_accpath,
                        (struct stat */* __restrict  */)(& st1), flag);
      }
#line 1649
      if (tmp___6 != 0) {
        {
#line 1651
        tmp___5 = __errno_location();
#line 1651
        suppressible_error(*tmp___5);
        }
#line 1652
        return ((_Bool)1);
      }
#line 1654
      st = & st1;
    }
    {
#line 1656
    tmp___7 = is_device_mode(st->st_mode);
    }
#line 1656
    if (tmp___7) {
#line 1657
      return ((_Bool)1);
    }
  }
#line 1659
  goto switch_break;
  case_13: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 1663
  goto switch_break;
  case_14: /* CIL Label */ 
  case_12: /* CIL Label */ 
#line 1667
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
  {
#line 1670
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1673
  tmp___9 = grepfile(fts->fts_cwd_fd, (char const   *)ent->fts_accpath, follow, command_line);
  }
#line 1673
  return (tmp___9);
}
}
#line 1678 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool open_symlink_nofollow_error(int err ) 
{ 


  {
#line 1681
  if (err == 40) {
#line 1682
    return ((_Bool)1);
  } else
#line 1681
  if (err == 31) {
#line 1682
    return ((_Bool)1);
  }
#line 1687
  return ((_Bool)0);
}
}
#line 1690 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool grepfile(int dirdesc , char const   *name , _Bool follow , _Bool command_line ) 
{ 
  int oflag ;
  int tmp ;
  int tmp___0 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  int desc ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
#line 1693
  if (binary) {
#line 1693
    tmp = 0;
  } else {
#line 1693
    tmp = 0;
  }
#line 1693
  if (follow) {
#line 1693
    tmp___0 = 0;
  } else {
#line 1693
    tmp___0 = 131072;
  }
  {
#line 1693
  tmp___3 = skip_devices(command_line);
  }
#line 1693
  if (tmp___3) {
#line 1693
    tmp___2 = 2048;
  } else {
#line 1693
    tmp___2 = 0;
  }
  {
#line 1693
  oflag = ((256 | tmp) | tmp___0) | tmp___2;
#line 1698
  tmp___4 = openat_safer(dirdesc, name, oflag);
#line 1698
  desc = tmp___4;
  }
#line 1699
  if (desc < 0) {
#line 1701
    if (follow) {
      {
#line 1702
      tmp___5 = __errno_location();
#line 1702
      suppressible_error(*tmp___5);
      }
    } else {
      {
#line 1701
      tmp___6 = __errno_location();
#line 1701
      tmp___7 = open_symlink_nofollow_error(*tmp___6);
      }
#line 1701
      if (! tmp___7) {
        {
#line 1702
        tmp___5 = __errno_location();
#line 1702
        suppressible_error(*tmp___5);
        }
      }
    }
#line 1703
    return ((_Bool)1);
  }
  {
#line 1705
  tmp___8 = grepdesc(desc, command_line);
  }
#line 1705
  return (tmp___8);
}
}
#line 1710 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool drain_input(int fd , struct stat  const  *st ) 
{ 
  ssize_t nbytes ;
  int *tmp ;
  size_t tmp___0 ;

  {
#line 1714
  if ((st->st_mode & 61440U) == 4096U) {
#line 1714
    if (dev_null_output) {
      {
#line 1718
      nbytes = splice(fd, (__off64_t *)((void *)0), 1, (__off64_t *)((void *)0), (size_t )32768,
                      1U);
      }
#line 1720
      if (0L <= nbytes) {
#line 1720
        goto _L;
      } else {
        {
#line 1720
        tmp = __errno_location();
        }
#line 1720
        if (*tmp != 22) {
          _L: /* CIL Label */ 
          {
#line 1722
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1722
            if (! (0L < nbytes)) {
#line 1722
              goto while_break;
            }
            {
#line 1723
            nbytes = splice(fd, (__off64_t *)((void *)0), 1, (__off64_t *)((void *)0),
                            (size_t )32768, 1U);
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1725
          return ((_Bool )(nbytes == 0L));
        }
      }
    }
  }
  {
#line 1729
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1729
    tmp___0 = safe_read(fd, (void *)buffer, bufalloc);
#line 1729
    nbytes = (ssize_t )tmp___0;
    }
#line 1729
    if (! nbytes) {
#line 1729
      goto while_break___0;
    }
#line 1730
    if ((size_t )nbytes == 0xffffffffffffffffUL) {
#line 1731
      return ((_Bool)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1732
  return ((_Bool)1);
}
}
#line 1740 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void finalize_input(int fd , struct stat  const  *st , _Bool ineof ) 
{ 
  int *tmp ;
  __off_t tmp___0 ;
  int *tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  __off_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1743
  if (fd == 0) {
#line 1743
    if (outleft) {
#line 1743
      if (! ineof) {
#line 1743
        if (seek_failed) {
#line 1743
          goto _L;
        } else {
          {
#line 1743
          tmp___0 = lseek(fd, (__off_t )0, 2);
          }
#line 1743
          if (tmp___0 < 0L) {
            {
#line 1743
            tmp___1 = __errno_location();
            }
#line 1743
            if (*tmp___1 != 22) {
              _L: /* CIL Label */ 
              {
#line 1743
              tmp___2 = drain_input(fd, st);
              }
#line 1743
              if (tmp___2) {
#line 1743
                tmp___3 = 0;
              } else {
#line 1743
                tmp___3 = 1;
              }
            } else {
#line 1743
              tmp___3 = 0;
            }
          } else {
#line 1743
            tmp___3 = 0;
          }
        }
      } else {
#line 1743
        tmp___3 = 0;
      }
#line 1743
      tmp___6 = tmp___3;
    } else {
#line 1743
      if (bufoffset != after_last_match) {
#line 1743
        if (! seek_failed) {
          {
#line 1743
          tmp___4 = lseek(fd, after_last_match, 0);
          }
#line 1743
          if (tmp___4 < 0L) {
#line 1743
            tmp___5 = 1;
          } else {
#line 1743
            tmp___5 = 0;
          }
        } else {
#line 1743
          tmp___5 = 0;
        }
      } else {
#line 1743
        tmp___5 = 0;
      }
#line 1743
      tmp___6 = tmp___5;
    }
#line 1743
    if (tmp___6) {
      {
#line 1753
      tmp = __errno_location();
#line 1753
      suppressible_error(*tmp);
      }
    }
  }
#line 1754
  return;
}
}
#line 1756 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool grepdesc(int desc , _Bool command_line ) 
{ 
  intmax_t count ;
  _Bool status ;
  _Bool ineof ;
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  FTS *fts ;
  FTSENT *ent ;
  int opts ;
  int tmp___4 ;
  char *fts_arg[2] ;
  int *tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  _Bool tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;

  {
  {
#line 1760
  status = (_Bool)1;
#line 1761
  ineof = (_Bool)0;
#line 1770
  tmp___0 = fstat(desc, & st);
  }
#line 1770
  if (tmp___0 != 0) {
    {
#line 1772
    tmp = __errno_location();
#line 1772
    suppressible_error(*tmp);
    }
#line 1773
    goto closeout;
  }
#line 1776
  if (desc != 0) {
    {
#line 1776
    tmp___1 = skip_devices(command_line);
    }
#line 1776
    if (tmp___1) {
      {
#line 1776
      tmp___2 = is_device_mode(st.st_mode);
      }
#line 1776
      if (tmp___2) {
#line 1778
        goto closeout;
      }
    }
  }
#line 1780
  if (desc != 0) {
#line 1780
    if (command_line) {
      {
#line 1780
      tmp___3 = skipped_file(filename, (_Bool)1, (_Bool )(((st.st_mode & 61440U) == 16384U) != 0));
      }
#line 1780
      if (tmp___3) {
#line 1782
        goto closeout;
      }
    }
  }
#line 1784
  if (desc != 0) {
#line 1784
    if ((unsigned int )directories == 3U) {
#line 1784
      if ((st.st_mode & 61440U) == 16384U) {
#line 1793
        if (command_line) {
#line 1793
          tmp___4 = 0;
        } else {
#line 1793
          tmp___4 = 1;
        }
        {
#line 1793
        opts = fts_options & ~ tmp___4;
#line 1798
        tmp___6 = close(desc);
        }
#line 1798
        if (tmp___6 != 0) {
          {
#line 1799
          tmp___5 = __errno_location();
#line 1799
          suppressible_error(*tmp___5);
          }
        }
        {
#line 1801
        fts_arg[0] = (char *)filename;
#line 1802
        fts_arg[1] = (char *)((void *)0);
#line 1803
        fts = fts_open((char * const  *)(fts_arg), opts, (int (*)(FTSENT const   ** ,
                                                                  FTSENT const   ** ))((void *)0));
        }
#line 1805
        if (! fts) {
          {
#line 1806
          xalloc_die();
          }
        }
        {
#line 1807
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 1807
          ent = fts_read(fts);
          }
#line 1807
          if (! ent) {
#line 1807
            goto while_break;
          }
          {
#line 1808
          tmp___7 = grepdirent(fts, ent, command_line);
#line 1808
          status = (_Bool )((int )status & (int )tmp___7);
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1809
        tmp___9 = __errno_location();
        }
#line 1809
        if (*tmp___9) {
          {
#line 1810
          tmp___8 = __errno_location();
#line 1810
          suppressible_error(*tmp___8);
          }
        }
        {
#line 1811
        tmp___11 = fts_close(fts);
        }
#line 1811
        if (tmp___11 != 0) {
          {
#line 1812
          tmp___10 = __errno_location();
#line 1812
          suppressible_error(*tmp___10);
          }
        }
#line 1813
        return (status);
      }
    }
  }
#line 1815
  if (desc != 0) {
#line 1815
    if ((unsigned int )directories == 4U) {
#line 1815
      if ((st.st_mode & 61440U) == 16384U) {
#line 1820
        goto closeout;
      } else {
#line 1815
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1815
    if ((unsigned int )devices == 2U) {
#line 1815
      goto _L;
    } else
#line 1815
    if ((unsigned int )devices == 0U) {
#line 1815
      if (! command_line) {
        _L: /* CIL Label */ 
        {
#line 1815
        tmp___12 = is_device_mode(st.st_mode);
        }
#line 1815
        if (tmp___12) {
#line 1820
          goto closeout;
        }
      }
    }
  }
#line 1840
  if (! out_quiet) {
#line 1840
    if ((unsigned int )list_files == 0U) {
#line 1840
      if (1L < max_count) {
#line 1840
        if ((st.st_mode & 61440U) == 32768U) {
#line 1840
          if (st.st_ino == out_stat.st_ino) {
#line 1840
            if (st.st_dev == out_stat.st_dev) {
#line 1843
              if (! suppress_errors) {
                {
#line 1844
                tmp___13 = input_filename();
#line 1844
                tmp___14 = quote(tmp___13);
#line 1844
                tmp___15 = gettext("input file %s is also the output");
#line 1844
                error(0, 0, (char const   *)tmp___15, tmp___14);
                }
              }
#line 1846
              errseen = (_Bool)1;
#line 1847
              goto closeout;
            }
          }
        }
      }
    }
  }
  {
#line 1850
  count = grep(desc, (struct stat  const  *)(& st), & ineof);
  }
#line 1851
  if (count_matches) {
#line 1853
    if (out_file) {
      {
#line 1855
      print_filename();
      }
#line 1856
      if (filename_mask) {
        {
#line 1857
        print_sep((char)58);
        }
      } else {
        {
#line 1859
        putchar_errno(0);
        }
      }
    }
    {
#line 1861
    printf_errno("%ld\n", count);
    }
#line 1862
    if (line_buffered) {
      {
#line 1863
      fflush_errno();
      }
    }
  }
#line 1866
  status = (_Bool )(! count);
#line 1868
  if ((unsigned int )list_files == 0U) {
    {
#line 1869
    finalize_input(desc, (struct stat  const  *)(& st), ineof);
    }
  } else {
#line 1870
    if (status) {
#line 1870
      tmp___16 = 2;
    } else {
#line 1870
      tmp___16 = 1;
    }
#line 1870
    if ((unsigned int )list_files == (unsigned int )tmp___16) {
      {
#line 1872
      print_filename();
#line 1873
      putchar_errno(10 & filename_mask);
      }
#line 1874
      if (line_buffered) {
        {
#line 1875
        fflush_errno();
        }
      }
    }
  }
  closeout: 
#line 1879
  if (desc != 0) {
    {
#line 1879
    tmp___18 = close(desc);
    }
#line 1879
    if (tmp___18 != 0) {
      {
#line 1880
      tmp___17 = __errno_location();
#line 1880
      suppressible_error(*tmp___17);
      }
    }
  }
#line 1881
  return (status);
}
}
#line 1884 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool grep_command_line_arg(char const   *arg ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1887
  tmp___1 = strcmp(arg, "-");
  }
#line 1887
  if (tmp___1 == 0) {
#line 1889
    filename = (char const   *)label;
#line 1890
    if (binary) {
      {
#line 1891
      xset_binary_mode(0, 0);
      }
    }
    {
#line 1892
    tmp = grepdesc(0, (_Bool)1);
    }
#line 1892
    return (tmp);
  } else {
    {
#line 1896
    filename = arg;
#line 1897
    tmp___0 = grepfile(-100, arg, (_Bool)1, (_Bool)1);
    }
#line 1897
    return (tmp___0);
  }
}
}
#line 1902 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
void usage(int status ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
#line 1905
  if (status != 0) {
    {
#line 1907
    tmp = getprogname();
#line 1907
    tmp___0 = gettext("Usage: %s [OPTION]... PATTERN [FILE]...\n");
#line 1907
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            tmp);
#line 1909
    tmp___1 = getprogname();
#line 1909
    tmp___2 = gettext("Try \'%s --help\' for more information.\n");
#line 1909
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            tmp___1);
    }
  } else {
    {
#line 1914
    tmp___3 = getprogname();
#line 1914
    tmp___4 = gettext("Usage: %s [OPTION]... PATTERN [FILE]...\n");
#line 1914
    printf((char const   */* __restrict  */)tmp___4, tmp___3);
#line 1915
    tmp___5 = gettext("Search for PATTERN in each FILE.\n");
#line 1915
    printf((char const   */* __restrict  */)tmp___5);
#line 1916
    tmp___6 = getprogname();
#line 1916
    tmp___7 = gettext("Example: %s -i \'hello world\' menu.h main.c\n\nPattern selection and interpretation:\n");
#line 1916
    printf((char const   */* __restrict  */)tmp___7, tmp___6);
#line 1920
    tmp___8 = gettext("  -E, --extended-regexp     PATTERN is an extended regular expression\n  -F, --fixed-strings       PATTERN is a set of newline-separated strings\n  -G, --basic-regexp        PATTERN is a basic regular expression (default)\n  -P, --perl-regexp         PATTERN is a Perl regular expression\n");
#line 1920
    printf((char const   */* __restrict  */)tmp___8);
#line 1926
    tmp___9 = gettext("  -e, --regexp=PATTERN      use PATTERN for matching\n  -f, --file=FILE           obtain PATTERN from FILE\n  -i, --ignore-case         ignore case distinctions\n  -w, --word-regexp         force PATTERN to match only whole words\n  -x, --line-regexp         force PATTERN to match only whole lines\n  -z, --null-data           a data line ends in 0 byte, not newline\n");
#line 1926
    printf((char const   */* __restrict  */)tmp___9);
#line 1933
    tmp___10 = gettext("\nMiscellaneous:\n  -s, --no-messages         suppress error messages\n  -v, --invert-match        select non-matching lines\n  -V, --version             display version information and exit\n      --help                display this help text and exit\n");
#line 1933
    printf((char const   */* __restrict  */)tmp___10);
#line 1940
    tmp___11 = gettext("\nOutput control:\n  -m, --max-count=NUM       stop after NUM selected lines\n  -b, --byte-offset         print the byte offset with output lines\n  -n, --line-number         print line number with output lines\n      --line-buffered       flush output on every line\n  -H, --with-filename       print file name with output lines\n  -h, --no-filename         suppress the file name prefix on output\n      --label=LABEL         use LABEL as the standard input file name prefix\n");
#line 1940
    printf((char const   */* __restrict  */)tmp___11);
#line 1951
    tmp___12 = gettext("  -o, --only-matching       show only the part of a line matching PATTERN\n  -q, --quiet, --silent     suppress all normal output\n      --binary-files=TYPE   assume that binary files are TYPE;\n                            TYPE is \'binary\', \'text\', or \'without-match\'\n  -a, --text                equivalent to --binary-files=text\n");
#line 1951
    printf((char const   */* __restrict  */)tmp___12);
#line 1958
    tmp___13 = gettext("  -I                        equivalent to --binary-files=without-match\n  -d, --directories=ACTION  how to handle directories;\n                            ACTION is \'read\', \'recurse\', or \'skip\'\n  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;\n                            ACTION is \'read\' or \'skip\'\n  -r, --recursive           like --directories=recurse\n  -R, --dereference-recursive  likewise, but follow all symlinks\n");
#line 1958
    printf((char const   */* __restrict  */)tmp___13);
#line 1967
    tmp___14 = gettext("      --include=FILE_PATTERN  search only files that match FILE_PATTERN\n      --exclude=FILE_PATTERN  skip files and directories matching FILE_PATTERN\n      --exclude-from=FILE   skip files matching any file pattern from FILE\n      --exclude-dir=PATTERN  directories that match PATTERN will be skipped.\n");
#line 1967
    printf((char const   */* __restrict  */)tmp___14);
#line 1974
    tmp___15 = gettext("  -L, --files-without-match  print only names of FILEs with no selected lines\n  -l, --files-with-matches  print only names of FILEs with selected lines\n  -c, --count               print only a count of selected lines per FILE\n  -T, --initial-tab         make tabs line up (if needed)\n  -Z, --null                print 0 byte after FILE name\n");
#line 1974
    printf((char const   */* __restrict  */)tmp___15);
#line 1980
    tmp___16 = gettext("\nContext control:\n  -B, --before-context=NUM  print NUM lines of leading context\n  -A, --after-context=NUM   print NUM lines of trailing context\n  -C, --context=NUM         print NUM lines of output context\n");
#line 1980
    printf((char const   */* __restrict  */)tmp___16);
#line 1987
    tmp___17 = gettext("  -NUM                      same as --context=NUM\n      --color[=WHEN],\n      --colour[=WHEN]       use markers to highlight the matching strings;\n                            WHEN is \'always\', \'never\', or \'auto\'\n  -U, --binary              do not strip CR characters at EOL (MSDOS/Windows)\n\n");
#line 1987
    printf((char const   */* __restrict  */)tmp___17);
#line 1994
    tmp___18 = gettext("When FILE is \'-\', read standard input.  With no FILE, read \'.\' if\nrecursive, \'-\' otherwise.  With fewer than two FILEs, assume -h.\nExit status is 0 if any line is selected, 1 otherwise;\nif any error occurs and -q is not given, the exit status is 2.\n");
#line 1994
    printf((char const   */* __restrict  */)tmp___18);
#line 1999
    emit_bug_reporting_address();
    }
  }
  {
#line 2001
  exit(status);
  }
}
}
#line 2006 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static struct __anonstruct_matchers_307522949  const  matchers[7]  = {      {{(char const   )'g', (char const   )'r', (char const   )'e', (char const   )'p',
       (char const   )'\000'}, (int )((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ~ (((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1))),
      & GEAcompile, & EGexecute}, 
        {{(char const   )'e', (char const   )'g', (char const   )'r', (char const   )'e',
       (char const   )'p', (char const   )'\000'}, (int )((((((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1))),
      & GEAcompile, & EGexecute}, 
        {{(char const   )'f', (char const   )'g', (char const   )'r', (char const   )'e',
       (char const   )'p', (char const   )'\000'}, 0, & Fcompile, & Fexecute}, 
        {{(char const   )'a', (char const   )'w', (char const   )'k', (char const   )'\000'},
      (int )((((((((((1UL | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((1UL << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)),
      & GEAcompile, & EGexecute}, 
        {{(char const   )'g', (char const   )'a', (char const   )'w', (char const   )'k',
       (char const   )'\000'}, (int )((((((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | 1UL) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ~ (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((1UL << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1))),
      & GEAcompile, & EGexecute}, 
        {{(char const   )'p', (char const   )'o', (char const   )'s', (char const   )'i',
       (char const   )'x', (char const   )'a', (char const   )'w', (char const   )'k',
       (char const   )'\000'}, (int )(((((((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | 1UL) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)),
      & GEAcompile, & EGexecute}, 
        {{(char const   )'p', (char const   )'e', (char const   )'r', (char const   )'l',
       (char const   )'\000'}, 0, & Pcompile, & Pexecute}};
#line 2027 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int setmatcher(char const   *m , int matcher ) 
{ 
  int i ;
  int tmp ;

  {
#line 2030
  i = 0;
  {
#line 2030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2030
    if (! ((unsigned long )i < sizeof(matchers) / sizeof(matchers[0]))) {
#line 2030
      goto while_break;
    }
    {
#line 2031
    tmp = strcmp(m, (char const   *)(matchers[i].name));
    }
#line 2031
    if (tmp == 0) {
#line 2033
      if (0 <= matcher) {
#line 2033
        if (matcher != i) {
          {
#line 2034
          exit(1);
          }
        }
      }
#line 2035
      return (i);
    }
#line 2030
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2038
  exit(1);
  }
}
}
#line 2046 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static size_t prepend_args(char const   *options , char *buf , char **argv ) 
{ 
  char const   *o ;
  char *b ;
  size_t n ;
  unsigned char tmp ;
  _Bool tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char tmp___3 ;
  char const   *tmp___4 ;
  unsigned char tmp___5 ;
  _Bool tmp___6 ;
  char *tmp___7 ;

  {
#line 2049
  o = options;
#line 2050
  b = buf;
#line 2051
  n = (size_t )0;
  {
#line 2053
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2055
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2055
      tmp = to_uchar((char )*o);
#line 2055
      tmp___0 = c_isspace((int )tmp);
      }
#line 2055
      if (! tmp___0) {
#line 2055
        goto while_break___0;
      }
#line 2056
      o ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2057
    if (! *o) {
#line 2058
      return (n);
    }
#line 2059
    if (argv) {
#line 2060
      *(argv + n) = b;
    }
#line 2061
    n ++;
    {
#line 2063
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2064
      tmp___2 = b;
#line 2064
      b ++;
#line 2064
      tmp___4 = o;
#line 2064
      o ++;
#line 2064
      tmp___3 = (char )*tmp___4;
#line 2064
      *tmp___2 = tmp___3;
#line 2064
      if ((int )tmp___3 == 92) {
#line 2064
        if (*o) {
#line 2065
          tmp___1 = o;
#line 2065
          o ++;
#line 2065
          *(b + -1) = (char )*tmp___1;
        }
      }
#line 2063
      if (*o) {
        {
#line 2063
        tmp___5 = to_uchar((char )*o);
#line 2063
        tmp___6 = c_isspace((int )tmp___5);
        }
#line 2063
        if (tmp___6) {
#line 2063
          goto while_break___1;
        }
      } else {
#line 2063
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2068
    tmp___7 = b;
#line 2068
    b ++;
#line 2068
    *tmp___7 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2075 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int prepend_default_options(char const   *options , int *pargc , char ***pargv ) 
{ 
  char *buf ;
  size_t tmp ;
  void *tmp___0 ;
  size_t prepended ;
  size_t tmp___1 ;
  int argc ;
  char * const  *argv ;
  char **pp ;
  void *tmp___2 ;
  char **tmp___3 ;
  char * const  *tmp___4 ;
  size_t tmp___5 ;
  char **tmp___6 ;
  char *tmp___7 ;
  char * const  *tmp___8 ;

  {
#line 2078
  if (options) {
#line 2078
    if (*options) {
      {
#line 2080
      tmp = strlen(options);
#line 2080
      tmp___0 = xmalloc(tmp + 1UL);
#line 2080
      buf = (char *)tmp___0;
#line 2081
      tmp___1 = prepend_args(options, buf, (char **)((void *)0));
#line 2081
      prepended = tmp___1;
#line 2082
      argc = *pargc;
#line 2083
      argv = (char * const  *)*pargv;
      }
#line 2086
      if ((size_t )(2147483647 - argc) < prepended) {
        {
#line 2087
        xalloc_die();
        }
      }
      {
#line 2088
      tmp___2 = xmalloc(((prepended + (size_t )argc) + 1UL) * sizeof(*pp));
#line 2088
      pp = (char **)tmp___2;
#line 2089
      *pargc = (int )(prepended + (size_t )argc);
#line 2090
      *pargv = pp;
#line 2091
      tmp___3 = pp;
#line 2091
      pp ++;
#line 2091
      tmp___4 = argv;
#line 2091
      argv ++;
#line 2091
      *tmp___3 = (char *)*tmp___4;
#line 2092
      tmp___5 = prepend_args(options, buf, pp);
#line 2092
      pp += tmp___5;
      }
      {
#line 2093
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2093
        tmp___6 = pp;
#line 2093
        pp ++;
#line 2093
        tmp___8 = argv;
#line 2093
        argv ++;
#line 2093
        tmp___7 = (char *)*tmp___8;
#line 2093
        *tmp___6 = tmp___7;
#line 2093
        if (! tmp___7) {
#line 2093
          goto while_break;
        }
#line 2094
        goto while_continue;
      }
      while_break: /* CIL Label */ ;
      }
#line 2095
      return ((int )prepended);
    }
  }
#line 2098
  return (0);
}
}
#line 2108
static int get_nondigit_option(int argc , char * const  *argv , intmax_t *default_context ) ;
#line 2108 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int prev_digit_optind  =    -1;
#line 2105 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int get_nondigit_option(int argc , char * const  *argv , intmax_t *default_context ) 
{ 
  int this_digit_optind ;
  _Bool was_digit ;
  char buf[((((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL) + 4UL] ;
  char *p ;
  int opt ;
  _Bool tmp ;
  char *tmp___0 ;

  {
#line 2112
  p = buf;
#line 2115
  was_digit = (_Bool)0;
#line 2116
  this_digit_optind = optind;
  {
#line 2117
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2119
    opt = getopt_long(argc, (char * const  *)((char **)argv), short_options, long_options,
                      (int *)((void *)0));
#line 2121
    tmp = c_isdigit(opt);
    }
#line 2121
    if (! tmp) {
#line 2122
      goto while_break;
    }
#line 2124
    if (prev_digit_optind != this_digit_optind) {
#line 2127
      p = buf;
    } else
#line 2124
    if (! was_digit) {
#line 2127
      p = buf;
    } else {
#line 2133
      p -= (int )buf[0] == 48;
    }
#line 2136
    if ((unsigned long )p == (unsigned long )((buf + sizeof(buf)) - 4)) {
      {
#line 2141
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"...");
#line 2142
      p += 3;
      }
#line 2143
      goto while_break;
    }
#line 2145
    tmp___0 = p;
#line 2145
    p ++;
#line 2145
    *tmp___0 = (char )opt;
#line 2147
    was_digit = (_Bool)1;
#line 2148
    prev_digit_optind = this_digit_optind;
#line 2149
    this_digit_optind = optind;
  }
  while_break: /* CIL Label */ ;
  }
#line 2151
  if ((unsigned long )p != (unsigned long )(buf)) {
    {
#line 2153
    *p = (char )'\000';
#line 2154
    context_length_arg((char const   *)(buf), default_context);
    }
  }
#line 2157
  return (opt);
}
}
#line 2164 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static void parse_grep_colors(void) 
{ 
  char const   *p ;
  char *q ;
  char *name ;
  char *val ;
  char *tmp ;
  char c ;
  struct color_cap  const  *cap ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 2172
  tmp = getenv("GREP_COLORS");
#line 2172
  p = (char const   *)tmp;
  }
#line 2173
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2174
    return;
  } else
#line 2173
  if ((int const   )*p == 0) {
#line 2174
    return;
  }
  {
#line 2177
  q = xstrdup(p);
#line 2179
  name = q;
#line 2180
  val = (char *)((void *)0);
  }
  {
#line 2182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2183
    if ((int )*q == 58) {
#line 2183
      goto _L;
    } else
#line 2183
    if ((int )*q == 0) {
      _L: /* CIL Label */ 
#line 2185
      c = *q;
#line 2188
      tmp___0 = q;
#line 2188
      q ++;
#line 2188
      *tmp___0 = (char )'\000';
#line 2191
      cap = color_dict;
      {
#line 2191
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2191
        if (! cap->name) {
#line 2191
          goto while_break___0;
        }
        {
#line 2192
        tmp___1 = strcmp((char const   *)cap->name, (char const   *)name);
        }
#line 2192
        if (tmp___1 == 0) {
#line 2193
          goto while_break___0;
        }
#line 2191
        cap ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2195
      if (cap->var) {
#line 2195
        if (val) {
#line 2196
          *(cap->var) = (char const   *)val;
        }
      }
#line 2197
      if (cap->fct) {
        {
#line 2198
        (*(cap->fct))();
        }
      }
#line 2199
      if ((int )c == 0) {
#line 2200
        return;
      }
#line 2201
      name = q;
#line 2202
      val = (char *)((void *)0);
    } else
#line 2204
    if ((int )*q == 61) {
#line 2206
      if ((unsigned long )q == (unsigned long )name) {
#line 2207
        return;
      } else
#line 2206
      if (val) {
#line 2207
        return;
      }
#line 2208
      tmp___2 = q;
#line 2208
      q ++;
#line 2208
      *tmp___2 = (char )'\000';
#line 2209
      val = q;
    } else
#line 2211
    if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 2212
      q ++;
    } else
#line 2213
    if ((int )*q == 59) {
#line 2214
      q ++;
    } else {
      {
#line 2213
      tmp___3 = c_isdigit((int )*q);
      }
#line 2213
      if (tmp___3) {
#line 2214
        q ++;
      } else {
#line 2216
        return;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2220 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool contains_encoding_error(char const   *pat , size_t patlen ) 
{ 
  mbstate_t mbs ;
  size_t i ;
  size_t charlen ;

  {
#line 2223
  mbs.__count = 0;
#line 2223
  mbs.__value.__wch = 0U;
#line 2226
  i = (size_t )0;
  {
#line 2226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2226
    if (! (i < patlen)) {
#line 2226
      goto while_break;
    }
    {
#line 2228
    charlen = mb_clen(pat + i, patlen - i, & mbs);
    }
#line 2229
    if (0xfffffffffffffffeUL <= charlen) {
#line 2230
      return ((_Bool)1);
    }
#line 2226
    i += charlen;
  }
  while_break: /* CIL Label */ ;
  }
#line 2232
  return ((_Bool)0);
}
}
#line 2242 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int fgrep_icase_charlen(char const   *pat , size_t patlen , mbstate_t *mbs ) 
{ 
  int n ;
  unsigned char tmp ;
  wchar_t wc ;
  wchar_t folded[32] ;
  size_t wn ;
  size_t tmp___0 ;
  int tmp___1 ;
  int i ;
  unsigned char c ;
  int tmp___2 ;

  {
  {
#line 2245
  tmp = to_uchar((char )*pat);
#line 2245
  n = (int )localeinfo.sbclen[tmp];
  }
#line 2246
  if (n < 0) {
    {
#line 2250
    tmp___0 = rpl_mbrtowc(& wc, pat, patlen, mbs);
#line 2250
    wn = tmp___0;
    }
#line 2251
    if (16UL < wn) {
#line 2252
      return (-1);
    } else {
      {
#line 2251
      tmp___1 = case_folded_counterparts((wint_t )wc, (wchar_t *)(folded));
      }
#line 2251
      if (tmp___1) {
#line 2252
        return (-1);
      }
    }
#line 2253
    i = (int )wn;
    {
#line 2253
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2253
      i --;
#line 2253
      if (! (0 < i)) {
#line 2253
        goto while_break;
      }
      {
#line 2255
      c = (unsigned char )*(pat + i);
#line 2256
      tmp___2 = toupper((int )c);
      }
#line 2256
      if (tmp___2 != (int )c) {
#line 2257
        return (-1);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2259
    n = (int )wn;
  }
#line 2261
  return (n);
}
}
#line 2268 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static _Bool fgrep_icase_available(char const   *pat , size_t patlen ) 
{ 
  mbstate_t mbs ;
  size_t i ;
  int n ;
  int tmp ;

  {
#line 2271
  mbs.__count = 0;
#line 2271
  mbs.__value.__wch = 0U;
#line 2273
  i = (size_t )0;
  {
#line 2273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2273
    if (! (i < patlen)) {
#line 2273
      goto while_break;
    }
    {
#line 2275
    tmp = fgrep_icase_charlen(pat + i, patlen - i, & mbs);
#line 2275
    n = tmp;
    }
#line 2276
    if (n < 0) {
#line 2277
      return ((_Bool)0);
    }
#line 2278
    i += (size_t )n;
  }
  while_break: /* CIL Label */ ;
  }
#line 2281
  return ((_Bool)1);
}
}
#line 2286 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
void fgrep_to_grep_pattern(char **keys_p , size_t *len_p ) 
{ 
  size_t len ;
  char *keys ;
  mbstate_t mb_state ;
  char *new_keys ;
  void *tmp ;
  char *p ;
  size_t n ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 2289
  len = *len_p;
#line 2290
  keys = *keys_p;
#line 2291
  mb_state.__count = 0;
#line 2291
  mb_state.__value.__wch = 0U;
#line 2292
  tmp = xnmalloc(len + 1UL, (size_t )2);
#line 2292
  new_keys = (char *)tmp;
#line 2293
  p = new_keys;
  }
  {
#line 2296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2296
    if (! len) {
#line 2296
      goto while_break;
    }
    {
#line 2298
    n = mb_clen((char const   *)keys, len, & mb_state);
    }
    {
#line 2301
    if (n == 0xfffffffffffffffeUL) {
#line 2301
      goto case_18446744073709551614;
    }
#line 2308
    if (n == 0xffffffffffffffffUL) {
#line 2308
      goto case_18446744073709551615;
    }
#line 2312
    if (n == 1UL) {
#line 2312
      goto case_1;
    }
#line 2304
    goto switch_default;
    case_18446744073709551614: /* CIL Label */ 
#line 2302
    n = len;
    switch_default: /* CIL Label */ 
    {
#line 2305
    tmp___0 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)keys,
                      n);
#line 2305
    p = (char *)tmp___0;
    }
#line 2306
    goto switch_break;
    case_18446744073709551615: /* CIL Label */ 
    {
#line 2309
    memset((void *)(& mb_state), 0, sizeof(mb_state));
#line 2310
    n = (size_t )1;
    }
    case_1: /* CIL Label */ 
    {
#line 2315
    if ((int )*keys == 94) {
#line 2315
      goto case_94;
    }
#line 2315
    if ((int )*keys == 92) {
#line 2315
      goto case_94;
    }
#line 2315
    if ((int )*keys == 91) {
#line 2315
      goto case_94;
    }
#line 2315
    if ((int )*keys == 46) {
#line 2315
      goto case_94;
    }
#line 2315
    if ((int )*keys == 42) {
#line 2315
      goto case_94;
    }
#line 2315
    if ((int )*keys == 36) {
#line 2315
      goto case_94;
    }
#line 2313
    goto switch_break___0;
    case_94: /* CIL Label */ 
    case_92: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_36: /* CIL Label */ 
#line 2316
    tmp___1 = p;
#line 2316
    p ++;
#line 2316
    *tmp___1 = (char )'\\';
#line 2316
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 2318
    tmp___2 = p;
#line 2318
    p ++;
#line 2318
    *tmp___2 = *keys;
#line 2319
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2296
    keys += n;
#line 2296
    len -= n;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2323
  free((void *)*keys_p);
#line 2324
  *keys_p = new_keys;
#line 2325
  *len_p = (size_t )(p - new_keys);
  }
#line 2326
  return;
}
}
#line 2335 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static int try_fgrep_pattern(int matcher , char *keys , size_t *len_p ) 
{ 
  int result ;
  size_t len ;
  char *new_keys ;
  void *tmp ;
  char *p ;
  char const   *q ;
  mbstate_t mb_state ;
  size_t n ;
  int ni ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 2338
  result = matcher;
#line 2339
  len = *len_p;
#line 2340
  tmp = xmalloc(len + 1UL);
#line 2340
  new_keys = (char *)tmp;
#line 2341
  p = new_keys;
#line 2342
  q = (char const   *)keys;
#line 2343
  mb_state.__count = 0;
#line 2343
  mb_state.__value.__wch = 0U;
  }
  {
#line 2345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2345
    if (! (len != 0UL)) {
#line 2345
      goto while_break;
    }
    {
#line 2349
    if ((int const   )*q == 94) {
#line 2349
      goto case_94;
    }
#line 2349
    if ((int const   )*q == 91) {
#line 2349
      goto case_94;
    }
#line 2349
    if ((int const   )*q == 46) {
#line 2349
      goto case_94;
    }
#line 2349
    if ((int const   )*q == 42) {
#line 2349
      goto case_94;
    }
#line 2349
    if ((int const   )*q == 36) {
#line 2349
      goto case_94;
    }
#line 2352
    if ((int const   )*q == 124) {
#line 2352
      goto case_124;
    }
#line 2352
    if ((int const   )*q == 123) {
#line 2352
      goto case_124;
    }
#line 2352
    if ((int const   )*q == 63) {
#line 2352
      goto case_124;
    }
#line 2352
    if ((int const   )*q == 43) {
#line 2352
      goto case_124;
    }
#line 2352
    if ((int const   )*q == 40) {
#line 2352
      goto case_124;
    }
#line 2357
    if ((int const   )*q == 92) {
#line 2357
      goto case_92;
    }
#line 2347
    goto switch_break;
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_36: /* CIL Label */ 
#line 2350
    goto fail;
    case_124: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_40: /* CIL Label */ 
#line 2353
    if (matcher != 0) {
#line 2354
      goto fail;
    }
#line 2355
    goto switch_break;
    case_92: /* CIL Label */ 
#line 2358
    if (1UL < len) {
      {
#line 2365
      if ((int const   )*(q + 1) == 57) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 56) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 55) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 54) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 53) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 52) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 51) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 50) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 49) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 62) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 96) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 119) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 115) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 98) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 60) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 39) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 87) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 83) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 66) {
#line 2365
        goto case_57;
      }
#line 2365
      if ((int const   )*(q + 1) == 10) {
#line 2365
        goto case_57;
      }
#line 2368
      if ((int const   )*(q + 1) == 124) {
#line 2368
        goto case_124___0;
      }
#line 2368
      if ((int const   )*(q + 1) == 123) {
#line 2368
        goto case_124___0;
      }
#line 2368
      if ((int const   )*(q + 1) == 63) {
#line 2368
        goto case_124___0;
      }
#line 2368
      if ((int const   )*(q + 1) == 43) {
#line 2368
        goto case_124___0;
      }
#line 2368
      if ((int const   )*(q + 1) == 40) {
#line 2368
        goto case_124___0;
      }
#line 2372
      goto switch_default;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_62: /* CIL Label */ 
      case_96: /* CIL Label */ 
      case_119: /* CIL Label */ 
      case_115: /* CIL Label */ 
      case_98: /* CIL Label */ 
      case_60: /* CIL Label */ 
      case_39: /* CIL Label */ 
      case_87: /* CIL Label */ 
      case_83: /* CIL Label */ 
      case_66: /* CIL Label */ 
      case_10: /* CIL Label */ 
#line 2366
      goto fail;
      case_124___0: /* CIL Label */ 
      case_123___0: /* CIL Label */ 
      case_63___0: /* CIL Label */ 
      case_43___0: /* CIL Label */ 
      case_40___0: /* CIL Label */ 
#line 2369
      if (matcher == 0) {
#line 2370
        goto fail;
      }
      switch_default: /* CIL Label */ 
#line 2373
      q ++;
#line 2373
      len --;
#line 2374
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 2376
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2381
    if (match_icase) {
      {
#line 2383
      tmp___0 = fgrep_icase_charlen(q, len, & mb_state);
#line 2383
      ni = tmp___0;
      }
#line 2384
      if (ni < 0) {
#line 2385
        goto fail;
      }
#line 2386
      n = (size_t )ni;
    } else {
      {
#line 2390
      n = mb_clen(q, len, & mb_state);
      }
#line 2391
      if (16UL < n) {
#line 2392
        goto fail;
      }
    }
    {
#line 2395
    tmp___1 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)q,
                      n);
#line 2395
    p = (char *)tmp___1;
#line 2396
    q += n;
#line 2397
    len -= n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2401
  if (*len_p != (size_t )(p - new_keys)) {
    {
#line 2403
    *len_p = (size_t )(p - new_keys);
#line 2404
    memcpy((void */* __restrict  */)keys, (void const   */* __restrict  */)new_keys,
           (size_t )(p - new_keys));
    }
  }
#line 2406
  result = 2;
  fail: 
  {
#line 2409
  free((void *)new_keys);
  }
#line 2410
  return (result);
}
}
#line 2916
int main(int argc , char **argv ) ;
#line 2916 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char * const  cwd_only[2]  = {      (char */* const  */)((char *)"."),      (char */* const  */)((void *)0)};
#line 2922 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
static char * const  stdin_only[2]  = {      (char */* const  */)((char *)"-"),      (char */* const  */)((void *)0)};
#line 2413 "/home/khheo/project/benchmark/grep-3.1/src/grep.c"
int main(int argc , char **argv ) 
{ 
  char *keys ;
  size_t keycc ;
  size_t oldcc ;
  size_t keyalloc ;
  int matcher ;
  _Bool with_filenames ;
  size_t cc ;
  int opt ;
  int prepended ;
  int prev_optind ;
  int last_recursive ;
  int fread_errno ;
  intmax_t default_context ;
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ptrdiff_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  strtol_error tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int cmd ;
  int tmp___25 ;
  int tmp___26 ;
  int cmd___0 ;
  int tmp___27 ;
  int tmp___28 ;
  int cmd___1 ;
  int tmp___29 ;
  char *tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  _Bool possibly_tty ;
  struct stat tmp_stat ;
  struct stat null_stat ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  char *userval ;
  char *tmp___40 ;
  int tmp___41 ;
  _Bool tmp___42 ;
  _Bool tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  char eolbytes[3] ;
  size_t match_size ;
  size_t tmp___46 ;
  long psize ;
  long tmp___47 ;
  size_t tmp___48 ;
  void *tmp___49 ;
  char * const  *files ;
  _Bool status ;
  char * const  *tmp___50 ;
  _Bool tmp___51 ;
  int tmp___52 ;

  {
  {
#line 2416
  keys = (char *)((void *)0);
#line 2417
  keycc = (size_t )0;
#line 2417
  keyalloc = (size_t )0;
#line 2418
  matcher = -1;
#line 2419
  with_filenames = (_Bool)0;
#line 2426
  exit_failure = (int volatile   )2;
#line 2429
  eolbyte = (char )'\n';
#line 2430
  filename_mask = ~ 0;
#line 2432
  max_count = 9223372036854775807L;
#line 2435
  out_before = (intmax_t )-1;
#line 2435
  out_after = out_before;
#line 2437
  default_context = (intmax_t )-1;
#line 2439
  only_matching = (_Bool)0;
#line 2443
  setlocale(6, "");
#line 2446
  bindtextdomain("grep", "/usr/local/share/locale");
#line 2447
  textdomain("grep");
#line 2450
  init_localeinfo(& localeinfo);
#line 2452
  atexit(& clean_up_stdout);
#line 2454
  last_recursive = 0;
#line 2456
  tmp = getenv("GREP_OPTIONS");
#line 2456
  prepended = prepend_default_options((char const   *)tmp, & argc, & argv);
  }
#line 2457
  if (prepended) {
    {
#line 2458
    tmp___0 = gettext("warning: GREP_OPTIONS is deprecated; please use an alias or script");
#line 2458
    error(0, 0, (char const   *)tmp___0);
    }
  }
  {
#line 2461
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2461
    prev_optind = optind;
#line 2461
    opt = get_nondigit_option(argc, (char * const  *)argv, & default_context);
    }
#line 2461
    if (! (opt != -1)) {
#line 2461
      goto while_break;
    }
    {
#line 2465
    if (opt == 65) {
#line 2465
      goto case_65;
    }
#line 2469
    if (opt == 66) {
#line 2469
      goto case_66;
    }
#line 2473
    if (opt == 67) {
#line 2473
      goto case_67;
    }
#line 2479
    if (opt == 68) {
#line 2479
      goto case_68;
    }
#line 2488
    if (opt == 69) {
#line 2488
      goto case_69;
    }
#line 2492
    if (opt == 70) {
#line 2492
      goto case_70;
    }
#line 2496
    if (opt == 80) {
#line 2496
      goto case_80;
    }
#line 2500
    if (opt == 71) {
#line 2500
      goto case_71;
    }
#line 2504
    if (opt == 88) {
#line 2504
      goto case_88;
    }
#line 2508
    if (opt == 72) {
#line 2508
      goto case_72;
    }
#line 2513
    if (opt == 73) {
#line 2513
      goto case_73;
    }
#line 2517
    if (opt == 84) {
#line 2517
      goto case_84;
    }
#line 2521
    if (opt == 85) {
#line 2521
      goto case_85;
    }
#line 2526
    if (opt == 117) {
#line 2526
      goto case_117;
    }
#line 2531
    if (opt == 86) {
#line 2531
      goto case_86;
    }
#line 2535
    if (opt == 97) {
#line 2535
      goto case_97;
    }
#line 2539
    if (opt == 98) {
#line 2539
      goto case_98;
    }
#line 2543
    if (opt == 99) {
#line 2543
      goto case_99;
    }
#line 2547
    if (opt == 100) {
#line 2547
      goto case_100;
    }
#line 2554
    if (opt == 101) {
#line 2554
      goto case_101;
    }
#line 2568
    if (opt == 102) {
#line 2568
      goto case_102;
    }
#line 2601
    if (opt == 104) {
#line 2601
      goto case_104;
    }
#line 2607
    if (opt == 121) {
#line 2607
      goto case_121;
    }
#line 2607
    if (opt == 105) {
#line 2607
      goto case_121;
    }
#line 2611
    if (opt == 76) {
#line 2611
      goto case_76;
    }
#line 2617
    if (opt == 108) {
#line 2617
      goto case_108;
    }
#line 2621
    if (opt == 109) {
#line 2621
      goto case_109;
    }
#line 2633
    if (opt == 110) {
#line 2633
      goto case_110;
    }
#line 2637
    if (opt == 111) {
#line 2637
      goto case_111;
    }
#line 2641
    if (opt == 113) {
#line 2641
      goto case_113;
    }
#line 2646
    if (opt == 82) {
#line 2646
      goto case_82;
    }
#line 2649
    if (opt == 114) {
#line 2649
      goto case_114;
    }
#line 2654
    if (opt == 115) {
#line 2654
      goto case_115;
    }
#line 2658
    if (opt == 118) {
#line 2658
      goto case_118;
    }
#line 2662
    if (opt == 119) {
#line 2662
      goto case_119;
    }
#line 2667
    if (opt == 120) {
#line 2667
      goto case_120;
    }
#line 2671
    if (opt == 90) {
#line 2671
      goto case_90;
    }
#line 2675
    if (opt == 122) {
#line 2675
      goto case_122;
    }
#line 2679
    if (opt == 128) {
#line 2679
      goto case_128;
    }
#line 2690
    if (opt == 129) {
#line 2690
      goto case_129;
    }
#line 2710
    if (opt == 134) {
#line 2710
      goto case_134;
    }
#line 2710
    if (opt == 131) {
#line 2710
      goto case_134;
    }
#line 2720
    if (opt == 132) {
#line 2720
      goto case_132;
    }
#line 2732
    if (opt == 130) {
#line 2732
      goto case_130;
    }
#line 2743
    if (opt == 133) {
#line 2743
      goto case_133;
    }
#line 2747
    if (opt == 135) {
#line 2747
      goto case_135;
    }
#line 2751
    if (opt == 136) {
#line 2751
      goto case_136;
    }
#line 2755
    if (opt == 0) {
#line 2755
      goto case_0___0;
    }
#line 2759
    goto switch_default___0;
    case_65: /* CIL Label */ 
    {
#line 2466
    context_length_arg((char const   *)optarg, & out_after);
    }
#line 2467
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 2470
    context_length_arg((char const   *)optarg, & out_before);
    }
#line 2471
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 2476
    context_length_arg((char const   *)optarg, & default_context);
    }
#line 2477
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 2480
    tmp___2 = strcmp((char const   *)optarg, "read");
    }
#line 2480
    if (tmp___2 == 0) {
#line 2481
      devices = (enum __anonenum_devices_473526324 )1;
    } else {
      {
#line 2482
      tmp___1 = strcmp((char const   *)optarg, "skip");
      }
#line 2482
      if (tmp___1 == 0) {
#line 2483
        devices = (enum __anonenum_devices_473526324 )2;
      } else {
        {
#line 2485
        exit(1);
        }
      }
    }
#line 2486
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 2489
    matcher = setmatcher("egrep", matcher);
    }
#line 2490
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 2493
    matcher = setmatcher("fgrep", matcher);
    }
#line 2494
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 2497
    matcher = setmatcher("perl", matcher);
    }
#line 2498
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 2501
    matcher = setmatcher("grep", matcher);
    }
#line 2502
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 2505
    matcher = setmatcher((char const   *)optarg, matcher);
    }
#line 2506
    goto switch_break;
    case_72: /* CIL Label */ 
#line 2509
    with_filenames = (_Bool)1;
#line 2510
    no_filenames = (_Bool)0;
#line 2511
    goto switch_break;
    case_73: /* CIL Label */ 
#line 2514
    binary_files = (enum __anonenum_binary_files_601436154 )2;
#line 2515
    goto switch_break;
    case_84: /* CIL Label */ 
#line 2518
    align_tabs = (_Bool)1;
#line 2519
    goto switch_break;
    case_85: /* CIL Label */ ;
#line 2524
    goto switch_break;
    case_117: /* CIL Label */ 
#line 2529
    goto switch_break;
    case_86: /* CIL Label */ 
#line 2532
    show_version = (_Bool)1;
#line 2533
    goto switch_break;
    case_97: /* CIL Label */ 
#line 2536
    binary_files = (enum __anonenum_binary_files_601436154 )1;
#line 2537
    goto switch_break;
    case_98: /* CIL Label */ 
#line 2540
    out_byte = (_Bool)1;
#line 2541
    goto switch_break;
    case_99: /* CIL Label */ 
#line 2544
    count_matches = (_Bool)1;
#line 2545
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 2548
    tmp___3 = __xargmatch_internal("--directories", (char const   *)optarg, directories_args,
                                   (char const   *)(directories_types), sizeof(directories_types[0]),
                                   argmatch_die);
#line 2548
    directories = (enum directories_type )directories_types[tmp___3];
    }
#line 2550
    if ((unsigned int )directories == 3U) {
#line 2551
      last_recursive = prev_optind;
    }
#line 2552
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 2555
    cc = strlen((char const   *)optarg);
    }
#line 2556
    if (keyalloc < (keycc + cc) + 1UL) {
      {
#line 2558
      keyalloc = (keycc + cc) + 1UL;
#line 2559
      tmp___4 = x2realloc((void *)keys, & keyalloc);
#line 2559
      keys = (char *)tmp___4;
      }
    }
    {
#line 2561
    oldcc = keycc;
#line 2562
    memcpy((void */* __restrict  */)(keys + oldcc), (void const   */* __restrict  */)optarg,
           cc);
#line 2563
    keycc += cc;
#line 2564
    tmp___5 = keycc;
#line 2564
    keycc ++;
#line 2564
    *(keys + tmp___5) = (char )'\n';
#line 2565
    fl_add((char const   *)(keys + oldcc), cc + 1UL, "");
    }
#line 2566
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 2569
    tmp___7 = strcmp((char const   *)optarg, "-");
    }
#line 2569
    if (tmp___7 == 0) {
#line 2571
      if (binary) {
        {
#line 2572
        xset_binary_mode(0, 0);
        }
      }
#line 2573
      fp = stdin;
    } else {
#line 2577
      if (binary) {
#line 2577
        tmp___6 = "rb";
      } else {
#line 2577
        tmp___6 = "r";
      }
      {
#line 2577
      fp = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)tmp___6);
      }
#line 2578
      if (! fp) {
        {
#line 2579
        exit(1);
        }
      }
    }
#line 2581
    oldcc = keycc;
    {
#line 2582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2584
      if (keyalloc <= keycc + 1UL) {
        {
#line 2585
        tmp___8 = x2realloc((void *)keys, & keyalloc);
#line 2585
        keys = (char *)tmp___8;
        }
      }
      {
#line 2586
      cc = fread_unlocked((void */* __restrict  */)(keys + keycc), (size_t )1, keyalloc - (keycc + 1UL),
                          (FILE */* __restrict  */)fp);
      }
#line 2587
      if (cc == 0UL) {
#line 2588
        goto while_break___0;
      }
#line 2582
      keycc += cc;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2590
    tmp___9 = __errno_location();
#line 2590
    fread_errno = *tmp___9;
#line 2591
    tmp___10 = ferror_unlocked(fp);
    }
#line 2591
    if (tmp___10) {
      {
#line 2592
      exit(1);
      }
    }
#line 2593
    if ((unsigned long )fp != (unsigned long )stdin) {
      {
#line 2594
      fclose(fp);
      }
    }
#line 2596
    if (oldcc != keycc) {
#line 2596
      if ((int )*(keys + (keycc - 1UL)) != 10) {
#line 2597
        tmp___11 = keycc;
#line 2597
        keycc ++;
#line 2597
        *(keys + tmp___11) = (char )'\n';
      }
    }
    {
#line 2598
    fl_add((char const   *)(keys + oldcc), keycc - oldcc, (char const   *)optarg);
    }
#line 2599
    goto switch_break;
    case_104: /* CIL Label */ 
#line 2602
    with_filenames = (_Bool)0;
#line 2603
    no_filenames = (_Bool)1;
#line 2604
    goto switch_break;
    case_121: /* CIL Label */ 
    case_105: /* CIL Label */ 
#line 2608
    match_icase = (_Bool)1;
#line 2609
    goto switch_break;
    case_76: /* CIL Label */ 
#line 2614
    list_files = (enum __anonenum_list_files_328606374 )2;
#line 2615
    goto switch_break;
    case_108: /* CIL Label */ 
#line 2618
    list_files = (enum __anonenum_list_files_328606374 )1;
#line 2619
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 2622
    tmp___12 = xstrtoimax((char const   *)optarg, (char **)0, 10, & max_count, "");
    }
    {
#line 2625
    if ((unsigned int )tmp___12 == 1U) {
#line 2625
      goto case_1;
    }
#line 2625
    if ((unsigned int )tmp___12 == 0U) {
#line 2625
      goto case_1;
    }
#line 2628
    goto switch_default;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 2626
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 2629
    exit(1);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 2631
    goto switch_break;
    case_110: /* CIL Label */ 
#line 2634
    out_line = (_Bool)1;
#line 2635
    goto switch_break;
    case_111: /* CIL Label */ 
#line 2638
    only_matching = (_Bool)1;
#line 2639
    goto switch_break;
    case_113: /* CIL Label */ 
#line 2642
    exit_on_match = (_Bool)1;
#line 2643
    exit_failure = (int volatile   )0;
#line 2644
    goto switch_break;
    case_82: /* CIL Label */ 
#line 2647
    fts_options = 778;
    case_114: /* CIL Label */ 
#line 2650
    directories = (enum directories_type )3;
#line 2651
    last_recursive = prev_optind;
#line 2652
    goto switch_break;
    case_115: /* CIL Label */ 
#line 2655
    suppress_errors = (_Bool)1;
#line 2656
    goto switch_break;
    case_118: /* CIL Label */ 
#line 2659
    out_invert = (_Bool)1;
#line 2660
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 2663
    wordinit();
#line 2664
    match_words = (_Bool)1;
    }
#line 2665
    goto switch_break;
    case_120: /* CIL Label */ 
#line 2668
    match_lines = (_Bool)1;
#line 2669
    goto switch_break;
    case_90: /* CIL Label */ 
#line 2672
    filename_mask = 0;
#line 2673
    goto switch_break;
    case_122: /* CIL Label */ 
#line 2676
    eolbyte = (char )'\000';
#line 2677
    goto switch_break;
    case_128: /* CIL Label */ 
    {
#line 2680
    tmp___15 = strcmp((char const   *)optarg, "binary");
    }
#line 2680
    if (tmp___15 == 0) {
#line 2681
      binary_files = (enum __anonenum_binary_files_601436154 )0;
    } else {
      {
#line 2682
      tmp___14 = strcmp((char const   *)optarg, "text");
      }
#line 2682
      if (tmp___14 == 0) {
#line 2683
        binary_files = (enum __anonenum_binary_files_601436154 )1;
      } else {
        {
#line 2684
        tmp___13 = strcmp((char const   *)optarg, "without-match");
        }
#line 2684
        if (tmp___13 == 0) {
#line 2685
          binary_files = (enum __anonenum_binary_files_601436154 )2;
        } else {
          {
#line 2687
          exit(1);
          }
        }
      }
    }
#line 2688
    goto switch_break;
    case_129: /* CIL Label */ 
#line 2691
    if (optarg) {
      {
#line 2693
      tmp___22 = strcasecmp((char const   *)optarg, "always");
      }
#line 2693
      if (tmp___22) {
        {
#line 2693
        tmp___23 = strcasecmp((char const   *)optarg, "yes");
        }
#line 2693
        if (tmp___23) {
          {
#line 2693
          tmp___24 = strcasecmp((char const   *)optarg, "force");
          }
#line 2693
          if (tmp___24) {
            {
#line 2696
            tmp___19 = strcasecmp((char const   *)optarg, "never");
            }
#line 2696
            if (tmp___19) {
              {
#line 2696
              tmp___20 = strcasecmp((char const   *)optarg, "no");
              }
#line 2696
              if (tmp___20) {
                {
#line 2696
                tmp___21 = strcasecmp((char const   *)optarg, "none");
                }
#line 2696
                if (tmp___21) {
                  {
#line 2699
                  tmp___16 = strcasecmp((char const   *)optarg, "auto");
                  }
#line 2699
                  if (tmp___16) {
                    {
#line 2699
                    tmp___17 = strcasecmp((char const   *)optarg, "tty");
                    }
#line 2699
                    if (tmp___17) {
                      {
#line 2699
                      tmp___18 = strcasecmp((char const   *)optarg, "if-tty");
                      }
#line 2699
                      if (tmp___18) {
#line 2703
                        show_help = 1;
                      } else {
#line 2701
                        color_option = 2;
                      }
                    } else {
#line 2701
                      color_option = 2;
                    }
                  } else {
#line 2701
                    color_option = 2;
                  }
                } else {
#line 2698
                  color_option = 0;
                }
              } else {
#line 2698
                color_option = 0;
              }
            } else {
#line 2698
              color_option = 0;
            }
          } else {
#line 2695
            color_option = 1;
          }
        } else {
#line 2695
          color_option = 1;
        }
      } else {
#line 2695
        color_option = 1;
      }
    } else {
#line 2706
      color_option = 2;
    }
#line 2707
    goto switch_break;
    case_134: /* CIL Label */ 
    case_131: /* CIL Label */ 
#line 2711
    cmd = 0;
    {
#line 2711
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2711
      if (! (cmd < 2)) {
#line 2711
        goto while_break___1;
      }
#line 2713
      if (! excluded_patterns[cmd]) {
        {
#line 2714
        excluded_patterns[cmd] = new_exclude();
        }
      }
#line 2715
      if (opt == 134) {
#line 2715
        tmp___25 = 1 << 29;
      } else {
#line 2715
        tmp___25 = 0;
      }
      {
#line 2715
      tmp___26 = exclude_options((_Bool )cmd);
#line 2715
      add_exclude(excluded_patterns[cmd], (char const   *)optarg, tmp___25 | tmp___26);
#line 2711
      cmd ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2719
    goto switch_break;
    case_132: /* CIL Label */ 
#line 2721
    cmd___0 = 0;
    {
#line 2721
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2721
      if (! (cmd___0 < 2)) {
#line 2721
        goto while_break___2;
      }
#line 2723
      if (! excluded_patterns[cmd___0]) {
        {
#line 2724
        excluded_patterns[cmd___0] = new_exclude();
        }
      }
      {
#line 2725
      tmp___27 = exclude_options((_Bool )cmd___0);
#line 2725
      tmp___28 = add_exclude_file(& add_exclude, excluded_patterns[cmd___0], (char const   *)optarg,
                                  tmp___27, (char )'\n');
      }
#line 2725
      if (tmp___28 != 0) {
        {
#line 2728
        exit(1);
        }
      }
#line 2721
      cmd___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2730
    goto switch_break;
    case_130: /* CIL Label */ 
    {
#line 2733
    strip_trailing_slashes(optarg);
#line 2734
    cmd___1 = 0;
    }
    {
#line 2734
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2734
      if (! (cmd___1 < 2)) {
#line 2734
        goto while_break___3;
      }
#line 2736
      if (! excluded_directory_patterns[cmd___1]) {
        {
#line 2737
        excluded_directory_patterns[cmd___1] = new_exclude();
        }
      }
      {
#line 2738
      tmp___29 = exclude_options((_Bool )cmd___1);
#line 2738
      add_exclude(excluded_directory_patterns[cmd___1], (char const   *)optarg, tmp___29);
#line 2734
      cmd___1 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2741
    goto switch_break;
    case_133: /* CIL Label */ 
#line 2744
    group_separator = (char const   *)optarg;
#line 2745
    goto switch_break;
    case_135: /* CIL Label */ 
#line 2748
    line_buffered = (_Bool)1;
#line 2749
    goto switch_break;
    case_136: /* CIL Label */ 
#line 2752
    label = optarg;
#line 2753
    goto switch_break;
    case_0___0: /* CIL Label */ 
#line 2757
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 2760
    usage(2);
    }
#line 2761
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2765
  if (show_version) {
    {
#line 2767
    tmp___30 = gettext("others, see <http://git.sv.gnu.org/cgit/grep.git/tree/AUTHORS>");
#line 2767
    tmp___31 = proper_name("Mike Haertel");
#line 2767
    tmp___32 = getprogname();
#line 2767
    version_etc(stdout, tmp___32, "GNU grep", "3.1", tmp___31, tmp___30, (char *)((void *)0));
    }
#line 2769
    return (0);
  }
#line 2772
  if (show_help) {
    {
#line 2773
    usage(0);
    }
  }
#line 2775
  if (keys) {
#line 2777
    if (keycc == 0UL) {
#line 2780
      out_invert = (_Bool )((int )out_invert ^ 1);
#line 2781
      match_words = (_Bool)0;
#line 2781
      match_lines = match_words;
    } else {
#line 2785
      keycc --;
    }
  } else
#line 2787
  if (optind < argc) {
    {
#line 2790
    keycc = strlen((char const   *)*(argv + optind));
#line 2791
    tmp___33 = optind;
#line 2791
    optind ++;
#line 2791
    tmp___34 = xmemdup((void const   *)*(argv + tmp___33), keycc + 1UL);
#line 2791
    keys = (char *)tmp___34;
#line 2792
    fl_add((char const   *)keys, keycc, "");
#line 2793
    n_patterns ++;
    }
  } else {
    {
#line 2796
    usage(2);
    }
  }
#line 2798
  possibly_tty = (_Bool)0;
#line 2800
  if (! exit_on_match) {
    {
#line 2800
    tmp___36 = fstat(1, & tmp_stat);
    }
#line 2800
    if (tmp___36 == 0) {
#line 2802
      if ((tmp_stat.st_mode & 61440U) == 32768U) {
#line 2803
        out_stat = tmp_stat;
      } else
#line 2804
      if ((tmp_stat.st_mode & 61440U) == 8192U) {
        {
#line 2807
        tmp___35 = stat((char const   */* __restrict  */)"/dev/null", (struct stat */* __restrict  */)(& null_stat));
        }
#line 2807
        if (tmp___35 == 0) {
#line 2807
          if (tmp_stat.st_ino == null_stat.st_ino) {
#line 2807
            if (tmp_stat.st_dev == null_stat.st_dev) {
#line 2809
              dev_null_output = (_Bool)1;
            } else {
#line 2811
              possibly_tty = (_Bool)1;
            }
          } else {
#line 2811
            possibly_tty = (_Bool)1;
          }
        } else {
#line 2811
          possibly_tty = (_Bool)1;
        }
      }
    }
  }
#line 2817
  if ((int )exit_on_match | (int )dev_null_output) {
#line 2818
    list_files = (enum __anonenum_list_files_328606374 )0;
  }
#line 2819
  if ((int )exit_on_match | (int )dev_null_output) {
#line 2821
    count_matches = (_Bool)0;
#line 2822
    done_on_match = (_Bool)1;
  } else
#line 2819
  if ((unsigned int )list_files != 0U) {
#line 2821
    count_matches = (_Bool)0;
#line 2822
    done_on_match = (_Bool)1;
  }
#line 2824
  out_quiet = (_Bool )((int )count_matches | (int )done_on_match);
#line 2826
  if (out_after < 0L) {
#line 2827
    out_after = default_context;
  }
#line 2828
  if (out_before < 0L) {
#line 2829
    out_before = default_context;
  }
#line 2833
  if (max_count == 0L) {
#line 2833
    goto _L;
  } else
#line 2833
  if (keycc == 0UL) {
#line 2833
    if (out_invert) {
#line 2833
      if (! match_lines) {
#line 2833
        if (! match_words) {
          _L: /* CIL Label */ 
#line 2833
          if ((unsigned int )list_files != 2U) {
#line 2836
            return (1);
          }
        }
      }
    }
  }
#line 2838
  if (color_option == 2) {
#line 2839
    if (possibly_tty) {
      {
#line 2839
      tmp___37 = should_colorize();
      }
#line 2839
      if (tmp___37) {
        {
#line 2839
        tmp___38 = isatty(1);
        }
#line 2839
        if (tmp___38) {
#line 2839
          tmp___39 = 1;
        } else {
#line 2839
          tmp___39 = 0;
        }
      } else {
#line 2839
        tmp___39 = 0;
      }
    } else {
#line 2839
      tmp___39 = 0;
    }
#line 2839
    color_option = tmp___39;
  }
  {
#line 2840
  init_colorize();
  }
#line 2842
  if (color_option) {
    {
#line 2845
    tmp___40 = getenv("GREP_COLOR");
#line 2845
    userval = tmp___40;
    }
#line 2846
    if ((unsigned long )userval != (unsigned long )((void *)0)) {
#line 2846
      if ((int )*userval != 0) {
#line 2847
        context_match_color = (char const   *)userval;
#line 2847
        selected_match_color = context_match_color;
      }
    }
    {
#line 2850
    parse_grep_colors();
    }
  }
  {
#line 2853
  initialize_unibyte_mask();
  }
#line 2855
  if (matcher < 0) {
#line 2856
    matcher = 0;
  }
#line 2863
  if (matcher == 2) {
#line 2863
    if (! localeinfo.multibyte) {
#line 2863
      if (n_patterns == 1UL) {
#line 2863
        if (match_words) {
#line 2863
          tmp___41 = 1;
        } else {
#line 2863
          tmp___41 = 0;
        }
      } else {
#line 2863
        tmp___41 = 0;
      }
#line 2863
      tmp___45 = tmp___41;
    } else {
      {
#line 2863
      tmp___42 = contains_encoding_error((char const   *)keys, keycc);
      }
#line 2863
      if (tmp___42) {
#line 2863
        tmp___44 = 1;
      } else
#line 2863
      if (match_icase) {
        {
#line 2863
        tmp___43 = fgrep_icase_available((char const   *)keys, keycc);
        }
#line 2863
        if (tmp___43) {
#line 2863
          tmp___44 = 0;
        } else {
#line 2863
          tmp___44 = 1;
        }
      } else {
#line 2863
        tmp___44 = 0;
      }
#line 2863
      tmp___45 = tmp___44;
    }
#line 2863
    if (tmp___45) {
      {
#line 2869
      fgrep_to_grep_pattern(& keys, & keycc);
#line 2870
      matcher = 0;
      }
    } else {
#line 2863
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2874
  if (matcher == 0) {
#line 2874
    goto _L___0;
  } else
#line 2874
  if (matcher == 1) {
    _L___0: /* CIL Label */ 
#line 2874
    if (1UL < n_patterns) {
      {
#line 2876
      matcher = try_fgrep_pattern(matcher, keys, & keycc);
      }
    }
  }
  {
#line 2878
  execute = (size_t (*)(void * , char const   * , size_t  , size_t * , char const   * ))matchers[matcher].execute;
#line 2879
  compiled_pattern = (*(matchers[matcher].compile))(keys, keycc, (reg_syntax_t )matchers[matcher].syntax);
#line 2882
  eolbytes[0] = (char)0;
#line 2882
  eolbytes[1] = eolbyte;
#line 2882
  eolbytes[2] = (char)0;
#line 2884
  tmp___46 = (*execute)(compiled_pattern, (char const   *)(eolbytes + 1), (size_t )1,
                        & match_size, (char const   *)((void *)0));
#line 2884
  skip_empty_lines = (_Bool )((tmp___46 == 0UL) == (int )out_invert);
  }
#line 2888
  if (argc - optind > 1) {
#line 2888
    if (! no_filenames) {
#line 2889
      out_file = 1;
    } else {
#line 2888
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2888
  if (with_filenames) {
#line 2889
    out_file = 1;
  }
#line 2891
  if (binary) {
    {
#line 2892
    xset_binary_mode(1, 0);
    }
  }
  {
#line 2896
  tmp___47 = sysconf(30);
#line 2896
  psize = tmp___47;
  }
#line 2900
  if (0L < psize) {
#line 2900
    if (! ((unsigned long )psize <= (0xffffffffffffffffUL - sizeof(uword )) / 2UL)) {
      {
#line 2901
      abort();
      }
    }
  } else {
    {
#line 2901
    abort();
    }
  }
#line 2902
  pagesize = (size_t )psize;
#line 2903
  if (32768UL % pagesize == 0UL) {
#line 2903
    tmp___48 = (size_t )32768;
  } else {
#line 2903
    tmp___48 = 32768UL + (pagesize - 32768UL % pagesize);
  }
  {
#line 2903
  bufalloc = (tmp___48 + pagesize) + sizeof(uword );
#line 2904
  tmp___49 = xmalloc(bufalloc);
#line 2904
  buffer = (char *)tmp___49;
  }
#line 2906
  if (fts_options & 2) {
#line 2906
    if ((unsigned int )devices == 0U) {
#line 2907
      devices = (enum __anonenum_devices_473526324 )1;
    }
  }
#line 2910
  if (optind < argc) {
#line 2912
    files = (char * const  *)(argv + optind);
  } else
#line 2914
  if ((unsigned int )directories == 3U) {
#line 2914
    if (prepended < last_recursive) {
#line 2917
      files = cwd_only;
#line 2918
      omit_dot_slash = (_Bool)1;
    } else {
#line 2923
      files = stdin_only;
    }
  } else {
#line 2923
    files = stdin_only;
  }
#line 2926
  status = (_Bool)1;
  {
#line 2927
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 2928
    tmp___50 = files;
#line 2928
    files ++;
#line 2928
    tmp___51 = grep_command_line_arg((char const   *)*tmp___50);
#line 2928
    status = (_Bool )((int )status & (int )tmp___51);
    }
#line 2927
    if (! ((unsigned long )*files != (unsigned long )((void *)0))) {
#line 2927
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2932
  if (errseen) {
#line 2932
    tmp___52 = 2;
  } else {
#line 2932
    tmp___52 = (int )status;
  }
#line 2932
  return (tmp___52);
}
}
#line 82 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 82
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 82
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 955
#pragma GCC diagnostic pop
#line 529 "../lib/regex.h"
extern reg_syntax_t re_set_syntax(reg_syntax_t __syntax ) ;
#line 539
extern char const   *re_compile_pattern(char const   *__pattern , size_t __length ,
                                        struct re_pattern_buffer *__buffer ) ;
#line 554
extern regoff_t re_search(struct re_pattern_buffer *__buffer , char const   *__String ,
                          regoff_t __length , regoff_t __start , regoff_t __range ,
                          struct re_registers *__regs ) ;
#line 572
extern regoff_t re_match(struct re_pattern_buffer *__buffer , char const   *__String ,
                         regoff_t __length , regoff_t __start , struct re_registers *__regs ) ;
#line 599 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 599
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 599
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 2068
#pragma GCC diagnostic pop
#line 53 "/home/khheo/project/benchmark/grep-3.1/src/system.h"
#pragma GCC diagnostic push
#line 53
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 53
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 69
#pragma GCC diagnostic pop
#line 29 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 266
#pragma GCC diagnostic pop
#line 37 "/home/khheo/project/benchmark/grep-3.1/src/search.h"
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 37
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 84
#pragma GCC diagnostic pop
#line 50 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
void dfaerror(char const   *mesg ) 
{ 


  {
  {
#line 53
  exit(1);
  }
}
}
#line 59 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
void dfawarn(char const   *mesg ) 
{ 
  char *tmp ;

  {
  {
#line 62
  tmp = getenv("POSIXLY_CORRECT");
  }
#line 62
  if (! tmp) {
    {
#line 63
    dfaerror(mesg);
    }
  }
#line 64
  return;
}
}
#line 70 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
static void kwsmusts(struct dfa_comp *dc ) 
{ 
  struct dfamust *dm ;
  struct dfamust *tmp ;
  ptrdiff_t old_len ;
  size_t tmp___0 ;
  ptrdiff_t new_len ;
  char *must ;
  void *tmp___1 ;
  char *mp ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dfamust((struct dfa  const  *)dc->dfa);
#line 73
  dm = tmp;
  }
#line 74
  if (! dm) {
#line 75
    return;
  }
  {
#line 76
  dc->kwset = kwsinit((_Bool)0);
  }
#line 77
  if (dm->exact) {
    {
#line 82
    (dc->kwset_exact_matches) ++;
#line 83
    tmp___0 = strlen((char const   *)dm->must);
#line 83
    old_len = (ptrdiff_t )tmp___0;
#line 84
    new_len = (old_len + (ptrdiff_t )dm->begline) + (ptrdiff_t )dm->endline;
#line 85
    tmp___1 = xmalloc((size_t )new_len);
#line 85
    must = (char *)tmp___1;
#line 86
    mp = must;
#line 87
    *mp = eolbyte;
#line 88
    mp += (int )dm->begline;
#line 89
    dc->begline = (_Bool )((int )dc->begline | (int )dm->begline);
#line 90
    memcpy((void */* __restrict  */)mp, (void const   */* __restrict  */)dm->must,
           (size_t )old_len);
    }
#line 91
    if (dm->endline) {
#line 92
      *(mp + old_len) = eolbyte;
    }
    {
#line 93
    kwsincr(dc->kwset, (char const   *)must, new_len);
#line 94
    free((void *)must);
    }
  } else {
    {
#line 100
    tmp___2 = strlen((char const   *)dm->must);
#line 100
    kwsincr(dc->kwset, (char const   *)dm->must, (ptrdiff_t )tmp___2);
    }
  }
  {
#line 102
  kwsprep(dc->kwset);
#line 103
  dfamustfree(dm);
  }
#line 104
  return;
}
}
#line 180 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
static char const   line_beg_no_bk[3]  = {      (char const   )'^',      (char const   )'(',      (char const   )'\000'};
#line 181 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
static char const   line_end_no_bk[3]  = {      (char const   )')',      (char const   )'$',      (char const   )'\000'};
#line 182 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
static char const   word_beg_no_bk[19]  = 
#line 182
  {      (char const   )'(',      (char const   )'^',      (char const   )'|',      (char const   )'[', 
        (char const   )'^',      (char const   )'[',      (char const   )':',      (char const   )'a', 
        (char const   )'l',      (char const   )'n',      (char const   )'u',      (char const   )'m', 
        (char const   )':',      (char const   )']',      (char const   )'_',      (char const   )']', 
        (char const   )')',      (char const   )'(',      (char const   )'\000'};
#line 183 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
static char const   word_end_no_bk[19]  = 
#line 183
  {      (char const   )')',      (char const   )'(',      (char const   )'[',      (char const   )'^', 
        (char const   )'[',      (char const   )':',      (char const   )'a',      (char const   )'l', 
        (char const   )'n',      (char const   )'u',      (char const   )'m',      (char const   )':', 
        (char const   )']',      (char const   )'_',      (char const   )']',      (char const   )'|', 
        (char const   )'$',      (char const   )')',      (char const   )'\000'};
#line 184 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
static char const   line_beg_bk[4]  = {      (char const   )'^',      (char const   )'\\',      (char const   )'(',      (char const   )'\000'};
#line 185 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
static char const   line_end_bk[4]  = {      (char const   )'\\',      (char const   )')',      (char const   )'$',      (char const   )'\000'};
#line 186 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
static char const   word_beg_bk[23]  = 
#line 186
  {      (char const   )'\\',      (char const   )'(',      (char const   )'^',      (char const   )'\\', 
        (char const   )'|',      (char const   )'[',      (char const   )'^',      (char const   )'[', 
        (char const   )':',      (char const   )'a',      (char const   )'l',      (char const   )'n', 
        (char const   )'u',      (char const   )'m',      (char const   )':',      (char const   )']', 
        (char const   )'_',      (char const   )']',      (char const   )'\\',      (char const   )')', 
        (char const   )'\\',      (char const   )'(',      (char const   )'\000'};
#line 187 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
static char const   word_end_bk[23]  = 
#line 187
  {      (char const   )'\\',      (char const   )')',      (char const   )'\\',      (char const   )'(', 
        (char const   )'[',      (char const   )'^',      (char const   )'[',      (char const   )':', 
        (char const   )'a',      (char const   )'l',      (char const   )'n',      (char const   )'u', 
        (char const   )'m',      (char const   )':',      (char const   )']',      (char const   )'_', 
        (char const   )']',      (char const   )'\\',      (char const   )'|',      (char const   )'$', 
        (char const   )'\\',      (char const   )')',      (char const   )'\000'};
#line 106 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
void *GEAcompile(char *pattern , size_t size , reg_syntax_t syntax_bits ) 
{ 
  char *motif ;
  struct dfa_comp *dc ;
  void *tmp ;
  int dfaopts ;
  int tmp___0 ;
  char const   *p ;
  char const   *patlim ;
  _Bool compilation_failed ;
  size_t palloc ;
  size_t len ;
  char const   *sep ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct re_pattern_buffer *pat ;
  void *tmp___3 ;
  char const   *err ;
  char const   *tmp___4 ;
  size_t lineno ;
  char const   *pat_filename ;
  char const   *tmp___5 ;
  int bk ;
  char *n ;
  void *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  size_t total ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  size_t tmp___14 ;

  {
  {
#line 110
  tmp = xcalloc((size_t )1, sizeof(*dc));
#line 110
  dc = (struct dfa_comp *)tmp;
#line 112
  dc->dfa = dfaalloc();
  }
#line 114
  if (match_icase) {
#line 115
    syntax_bits |= (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  }
  {
#line 116
  re_set_syntax(syntax_bits);
  }
#line 117
  if (eolbyte) {
#line 117
    tmp___0 = 0;
  } else {
#line 117
    tmp___0 = 2;
  }
  {
#line 117
  dfaopts = tmp___0;
#line 118
  dfasyntax(dc->dfa, (struct localeinfo  const  *)(& localeinfo), syntax_bits, dfaopts);
#line 124
  p = (char const   *)pattern;
#line 125
  patlim = (char const   *)(pattern + size);
#line 126
  compilation_failed = (_Bool)0;
#line 127
  palloc = (size_t )0;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 132
    tmp___1 = memchr((void const   *)p, '\n', (size_t )(patlim - p));
#line 132
    sep = (char const   *)tmp___1;
    }
#line 133
    if (sep) {
#line 135
      len = (size_t )(sep - p);
#line 136
      sep ++;
    } else {
#line 139
      len = (size_t )(patlim - p);
    }
#line 141
    if (palloc <= dc->pcount) {
      {
#line 142
      tmp___2 = x2nrealloc((void *)dc->patterns, & palloc, sizeof(*(dc->patterns)));
#line 142
      dc->patterns = (struct re_pattern_buffer *)tmp___2;
      }
    }
#line 143
    pat = dc->patterns + dc->pcount;
#line 144
    pat->buffer = (struct re_dfa_t *)((void *)0);
#line 145
    pat->allocated = (__re_long_size_t )0;
#line 148
    if (match_icase) {
#line 148
      pat->fastmap = (char *)((void *)0);
    } else {
      {
#line 148
      tmp___3 = xmalloc((size_t )256);
#line 148
      pat->fastmap = (char *)tmp___3;
      }
    }
    {
#line 150
    pat->translate = (unsigned char *)((void *)0);
#line 152
    tmp___4 = re_compile_pattern(p, len, pat);
#line 152
    err = tmp___4;
    }
#line 153
    if (err) {
      {
#line 158
      tmp___5 = (char const   *)pattern_file_name(dc->pcount + 1UL, & lineno);
#line 158
      pat_filename = tmp___5;
      }
#line 160
      if ((int const   )*pat_filename == 0) {
        {
#line 161
        error(0, 0, "%s", err);
        }
      } else {
        {
#line 163
        error(0, 0, "%s:%zu: %s", pat_filename, lineno, err);
        }
      }
#line 164
      compilation_failed = (_Bool)1;
    }
#line 166
    (dc->pcount) ++;
#line 167
    p = sep;
#line 129
    if (! p) {
#line 129
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  if (compilation_failed) {
    {
#line 172
    exit(2);
    }
  }
#line 178
  if (match_words) {
#line 178
    goto _L;
  } else
#line 178
  if (match_lines) {
    _L: /* CIL Label */ 
    {
#line 188
    bk = ! (syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 189
    tmp___6 = xmalloc(((sizeof(word_beg_bk) - 1UL) + size) + sizeof(word_end_bk));
#line 189
    n = (char *)tmp___6;
    }
#line 191
    if (match_lines) {
#line 191
      if (bk) {
#line 191
        tmp___7 = line_beg_bk;
      } else {
#line 191
        tmp___7 = line_beg_no_bk;
      }
#line 191
      tmp___9 = tmp___7;
    } else {
#line 191
      if (bk) {
#line 191
        tmp___8 = word_beg_bk;
      } else {
#line 191
        tmp___8 = word_beg_no_bk;
      }
#line 191
      tmp___9 = tmp___8;
    }
    {
#line 191
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)tmp___9);
#line 193
    tmp___10 = strlen((char const   *)n);
#line 193
    total = tmp___10;
#line 194
    memcpy((void */* __restrict  */)(n + total), (void const   */* __restrict  */)pattern,
           size);
#line 195
    total += size;
    }
#line 196
    if (match_lines) {
#line 196
      if (bk) {
#line 196
        tmp___11 = line_end_bk;
      } else {
#line 196
        tmp___11 = line_end_no_bk;
      }
#line 196
      tmp___13 = tmp___11;
    } else {
#line 196
      if (bk) {
#line 196
        tmp___12 = word_end_bk;
      } else {
#line 196
        tmp___12 = word_end_no_bk;
      }
#line 196
      tmp___13 = tmp___12;
    }
    {
#line 196
    strcpy((char */* __restrict  */)(n + total), (char const   */* __restrict  */)tmp___13);
#line 198
    tmp___14 = strlen((char const   *)(n + total));
#line 198
    total += tmp___14;
#line 199
    motif = n;
#line 199
    pattern = motif;
#line 200
    size = total;
    }
  } else {
#line 203
    motif = (char *)((void *)0);
  }
  {
#line 205
  dfacomp((char const   *)pattern, size, dc->dfa, (_Bool)1);
#line 206
  kwsmusts(dc);
#line 208
  free((void *)motif);
  }
#line 210
  return ((void *)dc);
}
}
#line 213 "/home/khheo/project/benchmark/grep-3.1/src/dfasearch.c"
size_t EGexecute(void *vdc , char const   *buf , size_t size , size_t *match_size ,
                 char const   *start_ptr ) 
{ 
  char const   *buflim___0 ;
  char const   *beg ;
  char const   *end ;
  char const   *ptr ;
  char const   *match ;
  char const   *best_match ;
  char const   *mb_start ;
  char eol ;
  regoff_t start ;
  size_t len ;
  size_t best_len ;
  struct kwsmatch kwsm ;
  size_t i ;
  struct dfa_comp *dc ;
  struct dfa *superset ;
  struct dfa *tmp ;
  _Bool dfafast ;
  _Bool tmp___0 ;
  char const   *next_beg ;
  char const   *dfa_beg ;
  size_t count ;
  _Bool exact_kwset_match ;
  _Bool backref ;
  char const   *prev_beg ;
  ptrdiff_t offset ;
  ptrdiff_t tmp___1 ;
  void *tmp___2 ;
  long tmp___5 ;
  char const   *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  ptrdiff_t tmp___10 ;
  char *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  char *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  regoff_t shorter_len ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t off ;

  {
  {
#line 218
  eol = eolbyte;
#line 223
  dc = (struct dfa_comp *)vdc;
#line 224
  tmp = dfasuperset((struct dfa  const  *)dc->dfa);
#line 224
  superset = tmp;
#line 225
  tmp___0 = dfaisfast((struct dfa  const  *)dc->dfa);
#line 225
  dfafast = tmp___0;
#line 227
  mb_start = buf;
#line 228
  buflim___0 = buf + size;
#line 230
  end = buf;
#line 230
  beg = end;
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! ((unsigned long )end < (unsigned long )buflim___0)) {
#line 230
      goto while_break;
    }
#line 232
    end = buflim___0;
#line 234
    if (! start_ptr) {
#line 236
      dfa_beg = beg;
#line 237
      count = (size_t )0;
#line 238
      exact_kwset_match = (_Bool)0;
#line 239
      backref = (_Bool)0;
#line 242
      if (dc->kwset) {
        {
#line 247
        tmp___1 = kwsexec(dc->kwset, beg - (int )dc->begline, (buflim___0 - beg) + (long )dc->begline,
                          & kwsm, (_Bool)1);
#line 247
        offset = tmp___1;
        }
#line 250
        if (offset < 0L) {
#line 251
          goto failure;
        }
        {
#line 252
        match = beg + offset;
#line 253
        prev_beg = beg;
#line 256
        tmp___2 = memrchr((void const   *)buf, (int )eol, (size_t )(match - buf));
#line 256
        beg = (char const   *)tmp___2;
        }
#line 257
        if (beg) {
#line 257
          beg ++;
        } else {
#line 257
          beg = buf;
        }
#line 258
        dfa_beg = beg;
#line 266
        exact_kwset_match = (_Bool )(kwsm.index < dc->kwset_exact_matches);
#line 267
        if (exact_kwset_match) {
#line 267
          end = match;
        } else
#line 267
        if (! dfafast) {
#line 267
          end = match;
        } else {
#line 267
          if (16L > match - beg) {
#line 267
            tmp___8 = 16L;
          } else {
#line 267
            tmp___8 = match - beg;
          }
#line 267
          if (tmp___8 < (match - prev_beg) >> 2) {
#line 267
            end = match;
          } else {
#line 267
            if (16L > match - beg) {
#line 267
              tmp___7 = 16L;
            } else {
#line 267
              tmp___7 = match - beg;
            }
#line 267
            if (tmp___7 < (buflim___0 - prev_beg) >> 2) {
#line 267
              if (16L > match - beg) {
#line 267
                tmp___5 = 16L;
              } else {
#line 267
                tmp___5 = match - beg;
              }
#line 267
              tmp___6 = prev_beg + 4L * tmp___5;
            } else {
#line 267
              tmp___6 = buflim___0;
            }
#line 267
            end = tmp___6;
          }
        }
        {
#line 273
        tmp___9 = memchr((void const   *)end, (int )eol, (size_t )(buflim___0 - end));
#line 273
        end = (char const   *)tmp___9;
        }
#line 274
        if (end) {
#line 274
          end ++;
        } else {
#line 274
          end = buflim___0;
        }
#line 276
        if (exact_kwset_match) {
#line 278
          if (! localeinfo.multibyte | (int )localeinfo.using_utf8) {
#line 279
            goto success;
          }
#line 280
          if ((unsigned long )mb_start < (unsigned long )beg) {
#line 281
            mb_start = beg;
          }
          {
#line 282
          tmp___10 = mb_goback(& mb_start, match, buflim___0);
          }
#line 282
          if (tmp___10 == 0L) {
#line 283
            goto success;
          }
#line 287
          dfa_beg = mb_start;
        }
      }
#line 292
      if (superset) {
#line 292
        if (! exact_kwset_match) {
          {
#line 297
          tmp___11 = dfaexec(superset, dfa_beg, (char *)end, (_Bool)0, & count, (_Bool *)((void *)0));
#line 297
          next_beg = (char const   *)tmp___11;
          }
#line 299
          if ((unsigned long )next_beg == (unsigned long )((void *)0)) {
#line 300
            goto __Cont;
          } else
#line 299
          if ((unsigned long )next_beg == (unsigned long )end) {
#line 300
            goto __Cont;
          }
#line 303
          if (count != 0UL) {
            {
#line 305
            tmp___12 = memrchr((void const   *)buf, (int )eol, (size_t )(next_beg - buf));
#line 305
            beg = (char const   *)tmp___12;
#line 306
            beg ++;
#line 307
            dfa_beg = beg;
            }
          }
          {
#line 309
          tmp___13 = memchr((void const   *)next_beg, (int )eol, (size_t )(buflim___0 - next_beg));
#line 309
          end = (char const   *)tmp___13;
          }
#line 310
          if (end) {
#line 310
            end ++;
          } else {
#line 310
            end = buflim___0;
          }
#line 312
          count = (size_t )0;
        }
      }
      {
#line 316
      tmp___14 = dfaexec(dc->dfa, dfa_beg, (char *)end, (_Bool)0, & count, & backref);
#line 316
      next_beg = (char const   *)tmp___14;
      }
#line 321
      if ((unsigned long )next_beg == (unsigned long )((void *)0)) {
#line 322
        goto __Cont;
      } else
#line 321
      if ((unsigned long )next_beg == (unsigned long )end) {
#line 322
        goto __Cont;
      }
#line 325
      if (count != 0UL) {
        {
#line 327
        tmp___15 = memrchr((void const   *)buf, (int )eol, (size_t )(next_beg - buf));
#line 327
        beg = (char const   *)tmp___15;
#line 328
        beg ++;
        }
      }
      {
#line 330
      tmp___16 = memchr((void const   *)next_beg, (int )eol, (size_t )(buflim___0 - next_beg));
#line 330
      end = (char const   *)tmp___16;
      }
#line 331
      if (end) {
#line 331
        end ++;
      } else {
#line 331
        end = buflim___0;
      }
#line 334
      if (! backref) {
#line 335
        goto success;
      }
#line 336
      ptr = beg;
    } else {
#line 342
      ptr = start_ptr;
    }
#line 347
    if ((long )(((1 << (sizeof(regoff_t ) * 8UL - 2UL)) - 1) * 2 + 1) < (end - beg) - 1L) {
      {
#line 348
      xalloc_die();
      }
    }
#line 351
    best_match = end;
#line 352
    best_len = (size_t )0;
#line 353
    i = (size_t )0;
    {
#line 353
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 353
      if (! (i < dc->pcount)) {
#line 353
        goto while_break___0;
      }
      {
#line 355
      (dc->patterns + i)->not_eol = 0U;
#line 356
      (dc->patterns + i)->newline_anchor = (unsigned int )((int )eolbyte == 10);
#line 357
      start = re_search(dc->patterns + i, beg, (regoff_t )((end - beg) - 1L), (regoff_t )(ptr - beg),
                        (regoff_t )((end - ptr) - 1L), & dc->regs);
      }
#line 359
      if (start < -1) {
        {
#line 360
        xalloc_die();
        }
      } else
#line 361
      if (0 <= start) {
#line 363
        len = (size_t )(*(dc->regs.end + 0) - start);
#line 364
        match = beg + start;
#line 365
        if ((unsigned long )match > (unsigned long )best_match) {
#line 366
          goto __Cont___0;
        }
#line 367
        if (start_ptr) {
#line 367
          if (! match_words) {
#line 368
            goto assess_pattern_match;
          }
        }
#line 369
        if (! match_lines) {
#line 369
          if (! match_words) {
#line 372
            match = ptr;
#line 373
            len = (size_t )(end - ptr);
#line 374
            goto assess_pattern_match;
          } else {
#line 369
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 369
        if (match_lines) {
#line 369
          if (len == (size_t )((end - ptr) - 1L)) {
#line 372
            match = ptr;
#line 373
            len = (size_t )(end - ptr);
#line 374
            goto assess_pattern_match;
          }
        }
#line 383
        if (! match_lines) {
#line 383
          if (match_words) {
            {
#line 384
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 384
              if (! ((unsigned long )match <= (unsigned long )best_match)) {
#line 384
                goto while_break___1;
              }
              {
#line 386
              shorter_len = 0;
#line 387
              tmp___17 = wordchar_next(match + len, end - 1);
              }
#line 387
              if (! tmp___17) {
                {
#line 387
                tmp___18 = wordchar_prev(beg, match, end - 1);
                }
#line 387
                if (! tmp___18) {
#line 389
                  goto assess_pattern_match;
                }
              }
#line 390
              if (len > 0UL) {
                {
#line 393
                len --;
#line 394
                (dc->patterns + i)->not_eol = 1U;
#line 395
                shorter_len = re_match(dc->patterns + i, beg, (regoff_t )((match + len) - ptr),
                                       (regoff_t )(match - beg), & dc->regs);
                }
#line 398
                if (shorter_len < -1) {
                  {
#line 399
                  xalloc_die();
                  }
                }
              }
#line 401
              if (0 < shorter_len) {
#line 402
                len = (size_t )shorter_len;
              } else {
#line 406
                if ((unsigned long )match == (unsigned long )(end - 1)) {
#line 407
                  goto while_break___1;
                }
                {
#line 408
                match ++;
#line 409
                (dc->patterns + i)->not_eol = 0U;
#line 410
                start = re_search(dc->patterns + i, beg, (regoff_t )((end - beg) - 1L),
                                  (regoff_t )(match - beg), (regoff_t )((end - match) - 1L),
                                  & dc->regs);
                }
#line 413
                if (start < 0) {
#line 415
                  if (start < -1) {
                    {
#line 416
                    xalloc_die();
                    }
                  }
#line 417
                  goto while_break___1;
                }
#line 419
                len = (size_t )(*(dc->regs.end + 0) - start);
#line 420
                match = beg + start;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 423
        goto __Cont___0;
        assess_pattern_match: 
#line 425
        if (! start_ptr) {
#line 429
          goto success;
        }
#line 431
        if ((unsigned long )match < (unsigned long )best_match) {
#line 434
          best_match = match;
#line 435
          best_len = len;
        } else
#line 431
        if ((unsigned long )match == (unsigned long )best_match) {
#line 431
          if (len > best_len) {
#line 434
            best_match = match;
#line 435
            best_len = len;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 353
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 439
    if ((unsigned long )best_match < (unsigned long )end) {
#line 443
      beg = best_match;
#line 444
      len = best_len;
#line 445
      goto success_in_len;
    }
    __Cont: /* CIL Label */ 
#line 230
    beg = end;
  }
  while_break: /* CIL Label */ ;
  }
  failure: 
#line 450
  return ((size_t )-1);
  success: 
#line 453
  len = (size_t )(end - beg);
  success_in_len: 
#line 455
  off = (size_t )(beg - buf);
#line 456
  *match_size = len;
#line 457
  return (off);
}
}
